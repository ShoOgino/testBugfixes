{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","commits":[{"id":"6249f3a9e6b3580715fd7ab5f4da0bf6e096f8f2","date":1498616740,"type":1,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","sourceNew":"  public Clause(Map<String, Object> m) {\n    this.original = m;\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + Utils.toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if(m.get(REPLICA) == null){\n        throw new RuntimeException(StrUtils.formatString(\"'replica' is required in {0}\", Utils.toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new RuntimeException(\"replica val cannot be null\" + Utils.toJSONString(m));\n      m.forEach((s, o) -> parseCondition(s, o));\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + Utils.toJSONString(m));\n\n  }\n\n","sourceOld":"  Clause(Map<String, Object> m) {\n    this.original = m;\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + Utils.toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if(m.get(REPLICA) == null){\n        throw new RuntimeException(StrUtils.formatString(\"'replica' is required in {0}\", Utils.toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new RuntimeException(\"replica val cannot be null\" + Utils.toJSONString(m));\n      m.forEach((s, o) -> parseCondition(s, o));\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + Utils.toJSONString(m));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98f11c416d30e556e0004a9a84960702d12d35b1","date":1498628359,"type":1,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","sourceNew":"  public Clause(Map<String, Object> m) {\n    this.original = m;\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + Utils.toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if(m.get(REPLICA) == null){\n        throw new RuntimeException(StrUtils.formatString(\"'replica' is required in {0}\", Utils.toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new RuntimeException(\"replica val cannot be null\" + Utils.toJSONString(m));\n      m.forEach((s, o) -> parseCondition(s, o));\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + Utils.toJSONString(m));\n\n  }\n\n","sourceOld":"  Clause(Map<String, Object> m) {\n    this.original = m;\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + Utils.toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if(m.get(REPLICA) == null){\n        throw new RuntimeException(StrUtils.formatString(\"'replica' is required in {0}\", Utils.toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new RuntimeException(\"replica val cannot be null\" + Utils.toJSONString(m));\n      m.forEach((s, o) -> parseCondition(s, o));\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + Utils.toJSONString(m));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","pathOld":"/dev/null","sourceNew":"  public Clause(Map<String, Object> m) {\n    this.original = m;\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + Utils.toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if(m.get(REPLICA) == null){\n        throw new RuntimeException(StrUtils.formatString(\"'replica' is required in {0}\", Utils.toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new RuntimeException(\"replica val cannot be null\" + Utils.toJSONString(m));\n      m.forEach((s, o) -> parseCondition(s, o));\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + Utils.toJSONString(m));\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"219ac4e012cb38bcfcd8f4290dccd4f5b4d7bc25","date":1499961129,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","sourceNew":"  public Clause(Map<String, Object> m) {\n    this.original = Utils.getDeepCopy(m, 10);\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + Utils.toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if (m.get(REPLICA) == null) {\n        throw new RuntimeException(StrUtils.formatString(\"'replica' is required in {0}\", Utils.toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new RuntimeException(\"replica val cannot be null\" + Utils.toJSONString(m));\n      m.forEach((s, o) -> parseCondition(s, o));\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + Utils.toJSONString(m));\n\n  }\n\n","sourceOld":"  public Clause(Map<String, Object> m) {\n    this.original = m;\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + Utils.toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if(m.get(REPLICA) == null){\n        throw new RuntimeException(StrUtils.formatString(\"'replica' is required in {0}\", Utils.toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new RuntimeException(\"replica val cannot be null\" + Utils.toJSONString(m));\n      m.forEach((s, o) -> parseCondition(s, o));\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + Utils.toJSONString(m));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7811b56f2d9e37eb839450d346535c87f1f504c2","date":1502459873,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","sourceNew":"  public Clause(Map<String, Object> m) {\n    this.original = Utils.getDeepCopy(m, 10);\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + Utils.toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if (m.get(REPLICA) == null) {\n        throw new RuntimeException(StrUtils.formatString(\"'replica' is required in {0}\", Utils.toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new RuntimeException(\"replica val cannot be null\" + Utils.toJSONString(m));\n      m.forEach((s, o) -> parseCondition(s, o));\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + Utils.toJSONString(m));\n    if (tag.name.startsWith(Clause.METRICS_PREFIX)) {\n      List<String> ss = StrUtils.splitSmart(tag.name, ':');\n      if (ss.size() < 3 || ss.size() > 4) {\n        throw new RuntimeException(\"Invalid metrics: param in \" + Utils.toJSONString(m) + \" must have at 2 or 3 segments after 'metrics:' separated by ':'\");\n      }\n    }\n\n  }\n\n","sourceOld":"  public Clause(Map<String, Object> m) {\n    this.original = Utils.getDeepCopy(m, 10);\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + Utils.toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if (m.get(REPLICA) == null) {\n        throw new RuntimeException(StrUtils.formatString(\"'replica' is required in {0}\", Utils.toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new RuntimeException(\"replica val cannot be null\" + Utils.toJSONString(m));\n      m.forEach((s, o) -> parseCondition(s, o));\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + Utils.toJSONString(m));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c304e97e7c1d472bc70e801b35ee78583916c6cd","date":1507105431,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","sourceNew":"  public Clause(Map<String, Object> m) {\n    this.original = Utils.getDeepCopy(m, 10);\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + Utils.toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if (m.get(REPLICA) == null) {\n        throw new RuntimeException(StrUtils.formatString(\"'replica' is required in {0}\", Utils.toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new RuntimeException(\"replica val cannot be null\" + Utils.toJSONString(m));\n      m.forEach((s, o) -> parseCondition(s, o));\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + Utils.toJSONString(m));\n    if (tag.name.startsWith(Clause.METRICS_PREFIX)) {\n      List<String> ss = StrUtils.splitSmart(tag.name, ':');\n      if (ss.size() < 3 || ss.size() > 4) {\n        throw new RuntimeException(\"Invalid metrics: param in \" + Utils.toJSONString(m) + \" must have at 2 or 3 segments after 'metrics:' separated by ':'\");\n      }\n    }\n\n  }\n\n","sourceOld":"  public Clause(Map<String, Object> m) {\n    this.original = m;\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + Utils.toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if(m.get(REPLICA) == null){\n        throw new RuntimeException(StrUtils.formatString(\"'replica' is required in {0}\", Utils.toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new RuntimeException(\"replica val cannot be null\" + Utils.toJSONString(m));\n      m.forEach((s, o) -> parseCondition(s, o));\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + Utils.toJSONString(m));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"560c18d71dad43d675158783c3840f8c80d6d39c","date":1507105532,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","sourceNew":"  public Clause(Map<String, Object> m) {\n    this.original = Utils.getDeepCopy(m, 10);\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + Utils.toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if (m.get(REPLICA) == null) {\n        throw new RuntimeException(StrUtils.formatString(\"'replica' is required in {0}\", Utils.toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new RuntimeException(\"replica val cannot be null\" + Utils.toJSONString(m));\n      m.forEach((s, o) -> parseCondition(s, o));\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + Utils.toJSONString(m));\n    if (tag.name.startsWith(Clause.METRICS_PREFIX)) {\n      List<String> ss = StrUtils.splitSmart(tag.name, ':');\n      if (ss.size() < 3 || ss.size() > 4) {\n        throw new RuntimeException(\"Invalid metrics: param in \" + Utils.toJSONString(m) + \" must have at 2 or 3 segments after 'metrics:' separated by ':'\");\n      }\n    }\n\n  }\n\n","sourceOld":"  public Clause(Map<String, Object> m) {\n    this.original = m;\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + Utils.toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if(m.get(REPLICA) == null){\n        throw new RuntimeException(StrUtils.formatString(\"'replica' is required in {0}\", Utils.toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new RuntimeException(\"replica val cannot be null\" + Utils.toJSONString(m));\n      m.forEach((s, o) -> parseCondition(s, o));\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + Utils.toJSONString(m));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"33ae23947c41339ea2b352422bb762dfb4a17077","date":1524235117,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","sourceNew":"  public Clause(Map<String, Object> m) {\n    this.original = Utils.getDeepCopy(m, 10);\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + Utils.toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if (m.get(REPLICA) == null) {\n        throw new RuntimeException(StrUtils.formatString(\"'replica' is required in {0}\", Utils.toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new RuntimeException(\"replica val cannot be null\" + Utils.toJSONString(m));\n      m.forEach(this::parseCondition);\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + Utils.toJSONString(m));\n    if (tag.name.startsWith(Clause.METRICS_PREFIX)) {\n      List<String> ss = StrUtils.splitSmart(tag.name, ':');\n      if (ss.size() < 3 || ss.size() > 4) {\n        throw new RuntimeException(\"Invalid metrics: param in \" + Utils.toJSONString(m) + \" must have at 2 or 3 segments after 'metrics:' separated by ':'\");\n      }\n    }\n\n  }\n\n","sourceOld":"  public Clause(Map<String, Object> m) {\n    this.original = Utils.getDeepCopy(m, 10);\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + Utils.toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if (m.get(REPLICA) == null) {\n        throw new RuntimeException(StrUtils.formatString(\"'replica' is required in {0}\", Utils.toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new RuntimeException(\"replica val cannot be null\" + Utils.toJSONString(m));\n      m.forEach((s, o) -> parseCondition(s, o));\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + Utils.toJSONString(m));\n    if (tag.name.startsWith(Clause.METRICS_PREFIX)) {\n      List<String> ss = StrUtils.splitSmart(tag.name, ':');\n      if (ss.size() < 3 || ss.size() > 4) {\n        throw new RuntimeException(\"Invalid metrics: param in \" + Utils.toJSONString(m) + \" must have at 2 or 3 segments after 'metrics:' separated by ':'\");\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9837f40c922407d857991971de6def18eda0857b","date":1529994497,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","sourceNew":"  private Clause(Map<String, Object> m) {\n    this.original = Utils.getDeepCopy(m, 10);\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + Utils.toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if (m.get(REPLICA) == null) {\n        throw new RuntimeException(StrUtils.formatString(\"'replica' is required in {0}\", Utils.toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new RuntimeException(\"replica val cannot be null\" + Utils.toJSONString(m));\n      m.forEach(this::parseCondition);\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + Utils.toJSONString(m));\n    if (tag.name.startsWith(Clause.METRICS_PREFIX)) {\n      List<String> ss = StrUtils.splitSmart(tag.name, ':');\n      if (ss.size() < 3 || ss.size() > 4) {\n        throw new RuntimeException(\"Invalid metrics: param in \" + Utils.toJSONString(m) + \" must have at 2 or 3 segments after 'metrics:' separated by ':'\");\n      }\n    }\n    hasComputedValue = hasComputedValue();\n  }\n\n","sourceOld":"  public Clause(Map<String, Object> m) {\n    this.original = Utils.getDeepCopy(m, 10);\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + Utils.toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if (m.get(REPLICA) == null) {\n        throw new RuntimeException(StrUtils.formatString(\"'replica' is required in {0}\", Utils.toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new RuntimeException(\"replica val cannot be null\" + Utils.toJSONString(m));\n      m.forEach(this::parseCondition);\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + Utils.toJSONString(m));\n    if (tag.name.startsWith(Clause.METRICS_PREFIX)) {\n      List<String> ss = StrUtils.splitSmart(tag.name, ':');\n      if (ss.size() < 3 || ss.size() > 4) {\n        throw new RuntimeException(\"Invalid metrics: param in \" + Utils.toJSONString(m) + \" must have at 2 or 3 segments after 'metrics:' separated by ':'\");\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7d6bec22994bec86702ad05304ae983f7be5b5a7","date":1530715192,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","sourceNew":"  private Clause(Map<String, Object> m) {\n    this.original = Utils.getDeepCopy(m, 10);\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + Utils.toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if (m.get(REPLICA) == null) {\n        throw new RuntimeException(StrUtils.formatString(\"'replica' is required in {0}\", Utils.toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new RuntimeException(\"replica val cannot be null\" + Utils.toJSONString(m));\n      m.forEach(this::parseCondition);\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + Utils.toJSONString(m));\n    if (tag.name.startsWith(Clause.METRICS_PREFIX)) {\n      List<String> ss = StrUtils.splitSmart(tag.name, ':');\n      if (ss.size() < 3 || ss.size() > 4) {\n        throw new RuntimeException(\"Invalid metrics: param in \" + Utils.toJSONString(m) + \" must have at 2 or 3 segments after 'metrics:' separated by ':'\");\n      }\n    }\n    doPostValidate(collection, shard, replica, tag, globalTag);\n    hasComputedValue = hasComputedValue();\n  }\n\n","sourceOld":"  private Clause(Map<String, Object> m) {\n    this.original = Utils.getDeepCopy(m, 10);\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + Utils.toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if (m.get(REPLICA) == null) {\n        throw new RuntimeException(StrUtils.formatString(\"'replica' is required in {0}\", Utils.toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new RuntimeException(\"replica val cannot be null\" + Utils.toJSONString(m));\n      m.forEach(this::parseCondition);\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + Utils.toJSONString(m));\n    if (tag.name.startsWith(Clause.METRICS_PREFIX)) {\n      List<String> ss = StrUtils.splitSmart(tag.name, ':');\n      if (ss.size() < 3 || ss.size() > 4) {\n        throw new RuntimeException(\"Invalid metrics: param in \" + Utils.toJSONString(m) + \" must have at 2 or 3 segments after 'metrics:' separated by ':'\");\n      }\n    }\n    hasComputedValue = hasComputedValue();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","sourceNew":"  private Clause(Map<String, Object> m) {\n    this.original = Utils.getDeepCopy(m, 10);\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + Utils.toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if (m.get(REPLICA) == null) {\n        throw new RuntimeException(StrUtils.formatString(\"'replica' is required in {0}\", Utils.toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new RuntimeException(\"replica val cannot be null\" + Utils.toJSONString(m));\n      m.forEach(this::parseCondition);\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + Utils.toJSONString(m));\n    if (tag.name.startsWith(Clause.METRICS_PREFIX)) {\n      List<String> ss = StrUtils.splitSmart(tag.name, ':');\n      if (ss.size() < 3 || ss.size() > 4) {\n        throw new RuntimeException(\"Invalid metrics: param in \" + Utils.toJSONString(m) + \" must have at 2 or 3 segments after 'metrics:' separated by ':'\");\n      }\n    }\n    doPostValidate(collection, shard, replica, tag, globalTag);\n    hasComputedValue = hasComputedValue();\n  }\n\n","sourceOld":"  public Clause(Map<String, Object> m) {\n    this.original = Utils.getDeepCopy(m, 10);\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + Utils.toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if (m.get(REPLICA) == null) {\n        throw new RuntimeException(StrUtils.formatString(\"'replica' is required in {0}\", Utils.toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new RuntimeException(\"replica val cannot be null\" + Utils.toJSONString(m));\n      m.forEach(this::parseCondition);\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + Utils.toJSONString(m));\n    if (tag.name.startsWith(Clause.METRICS_PREFIX)) {\n      List<String> ss = StrUtils.splitSmart(tag.name, ':');\n      if (ss.size() < 3 || ss.size() > 4) {\n        throw new RuntimeException(\"Invalid metrics: param in \" + Utils.toJSONString(m) + \" must have at 2 or 3 segments after 'metrics:' separated by ':'\");\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","sourceNew":"  private Clause(Map<String, Object> m) {\n    this.original = Utils.getDeepCopy(m, 10);\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + Utils.toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if (m.get(REPLICA) == null) {\n        throw new RuntimeException(StrUtils.formatString(\"'replica' is required in {0}\", Utils.toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new RuntimeException(\"replica val cannot be null\" + Utils.toJSONString(m));\n      m.forEach(this::parseCondition);\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + Utils.toJSONString(m));\n    if (tag.name.startsWith(Clause.METRICS_PREFIX)) {\n      List<String> ss = StrUtils.splitSmart(tag.name, ':');\n      if (ss.size() < 3 || ss.size() > 4) {\n        throw new RuntimeException(\"Invalid metrics: param in \" + Utils.toJSONString(m) + \" must have at 2 or 3 segments after 'metrics:' separated by ':'\");\n      }\n    }\n    doPostValidate(collection, shard, replica, tag, globalTag);\n    hasComputedValue = hasComputedValue();\n  }\n\n","sourceOld":"  public Clause(Map<String, Object> m) {\n    this.original = Utils.getDeepCopy(m, 10);\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + Utils.toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if (m.get(REPLICA) == null) {\n        throw new RuntimeException(StrUtils.formatString(\"'replica' is required in {0}\", Utils.toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new RuntimeException(\"replica val cannot be null\" + Utils.toJSONString(m));\n      m.forEach(this::parseCondition);\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + Utils.toJSONString(m));\n    if (tag.name.startsWith(Clause.METRICS_PREFIX)) {\n      List<String> ss = StrUtils.splitSmart(tag.name, ':');\n      if (ss.size() < 3 || ss.size() > 4) {\n        throw new RuntimeException(\"Invalid metrics: param in \" + Utils.toJSONString(m) + \" must have at 2 or 3 segments after 'metrics:' separated by ':'\");\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b9f478d4eb5c08e4b0a9717fe37bd99f09ea733","date":1532604765,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","sourceNew":"  private Clause(Map<String, Object> m) {\n    this.original = Utils.getDeepCopy(m, 10);\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if (m.get(REPLICA) == null) {\n        throw new IllegalArgumentException(formatString(\"'replica' is required in {0}\", toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new IllegalArgumentException(\"replica val cannot be null\" + toJSONString(m));\n      m.forEach(this::parseCondition);\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + toJSONString(m));\n    if (tag.name.startsWith(Clause.METRICS_PREFIX)) {\n      List<String> ss = StrUtils.splitSmart(tag.name, ':');\n      if (ss.size() < 3 || ss.size() > 4) {\n        throw new RuntimeException(\"Invalid metrics: param in \" + toJSONString(m) + \" must have at 2 or 3 segments after 'metrics:' separated by ':'\");\n      }\n    }\n    doPostValidate(collection, shard, replica, tag, globalTag);\n    hasComputedValue = hasComputedValue();\n  }\n\n","sourceOld":"  private Clause(Map<String, Object> m) {\n    this.original = Utils.getDeepCopy(m, 10);\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + Utils.toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if (m.get(REPLICA) == null) {\n        throw new RuntimeException(StrUtils.formatString(\"'replica' is required in {0}\", Utils.toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new RuntimeException(\"replica val cannot be null\" + Utils.toJSONString(m));\n      m.forEach(this::parseCondition);\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + Utils.toJSONString(m));\n    if (tag.name.startsWith(Clause.METRICS_PREFIX)) {\n      List<String> ss = StrUtils.splitSmart(tag.name, ':');\n      if (ss.size() < 3 || ss.size() > 4) {\n        throw new RuntimeException(\"Invalid metrics: param in \" + Utils.toJSONString(m) + \" must have at 2 or 3 segments after 'metrics:' separated by ':'\");\n      }\n    }\n    doPostValidate(collection, shard, replica, tag, globalTag);\n    hasComputedValue = hasComputedValue();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c73f63a2a7b9f4a6b21e8723912461026968d87e","date":1539669411,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","sourceNew":"  private Clause(Map<String, Object> m) {\n    derivedFrom = (Clause) m.remove(Clause.class.getName());\n    this.original = Utils.getDeepCopy(m, 10);\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if (m.get(REPLICA) == null) {\n        throw new IllegalArgumentException(formatString(\"'replica' is required in {0}\", toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new IllegalArgumentException(\"replica val cannot be null\" + toJSONString(m));\n      m.forEach(this::parseCondition);\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + toJSONString(m));\n    if (tag.name.startsWith(Clause.METRICS_PREFIX)) {\n      List<String> ss = StrUtils.splitSmart(tag.name, ':');\n      if (ss.size() < 3 || ss.size() > 4) {\n        throw new RuntimeException(\"Invalid metrics: param in \" + toJSONString(m) + \" must have at 2 or 3 segments after 'metrics:' separated by ':'\");\n      }\n    }\n    doPostValidate(collection, shard, replica, tag, globalTag);\n    hasComputedValue = hasComputedValue();\n  }\n\n","sourceOld":"  private Clause(Map<String, Object> m) {\n    this.original = Utils.getDeepCopy(m, 10);\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if (m.get(REPLICA) == null) {\n        throw new IllegalArgumentException(formatString(\"'replica' is required in {0}\", toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new IllegalArgumentException(\"replica val cannot be null\" + toJSONString(m));\n      m.forEach(this::parseCondition);\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + toJSONString(m));\n    if (tag.name.startsWith(Clause.METRICS_PREFIX)) {\n      List<String> ss = StrUtils.splitSmart(tag.name, ':');\n      if (ss.size() < 3 || ss.size() > 4) {\n        throw new RuntimeException(\"Invalid metrics: param in \" + toJSONString(m) + \" must have at 2 or 3 segments after 'metrics:' separated by ':'\");\n      }\n    }\n    doPostValidate(collection, shard, replica, tag, globalTag);\n    hasComputedValue = hasComputedValue();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"58e890cd5653ae8550bc6088d739f4eaaf950aff","date":1547036285,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","sourceNew":"  private Clause(Map<String, Object> m) {\n    derivedFrom = (Clause) m.remove(Clause.class.getName());\n    this.original = Utils.getDeepCopy(m, 10);\n    this.hashCode = original.hashCode();\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if (m.get(REPLICA) == null) {\n        throw new IllegalArgumentException(formatString(\"'replica' is required in {0}\", toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new IllegalArgumentException(\"replica val cannot be null\" + toJSONString(m));\n      m.forEach(this::parseCondition);\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + toJSONString(m));\n    if (tag.name.startsWith(Clause.METRICS_PREFIX)) {\n      List<String> ss = StrUtils.splitSmart(tag.name, ':');\n      if (ss.size() < 3 || ss.size() > 4) {\n        throw new RuntimeException(\"Invalid metrics: param in \" + toJSONString(m) + \" must have at 2 or 3 segments after 'metrics:' separated by ':'\");\n      }\n    }\n    doPostValidate(collection, shard, replica, tag, globalTag);\n    hasComputedValue = hasComputedValue();\n  }\n\n","sourceOld":"  private Clause(Map<String, Object> m) {\n    derivedFrom = (Clause) m.remove(Clause.class.getName());\n    this.original = Utils.getDeepCopy(m, 10);\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if (m.get(REPLICA) == null) {\n        throw new IllegalArgumentException(formatString(\"'replica' is required in {0}\", toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new IllegalArgumentException(\"replica val cannot be null\" + toJSONString(m));\n      m.forEach(this::parseCondition);\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + toJSONString(m));\n    if (tag.name.startsWith(Clause.METRICS_PREFIX)) {\n      List<String> ss = StrUtils.splitSmart(tag.name, ':');\n      if (ss.size() < 3 || ss.size() > 4) {\n        throw new RuntimeException(\"Invalid metrics: param in \" + toJSONString(m) + \" must have at 2 or 3 segments after 'metrics:' separated by ':'\");\n      }\n    }\n    doPostValidate(collection, shard, replica, tag, globalTag);\n    hasComputedValue = hasComputedValue();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ddd9a76400512cda8f22bbc69e3d8b85672a91a","date":1559288755,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","sourceNew":"  private Clause(Map<String, Object> m) {\n    derivedFrom = (Clause) m.remove(Clause.class.getName());\n    this.original = Utils.getDeepCopy(m, 10);\n    this.hashCode = original.hashCode();\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if (m.get(REPLICA) == null) {\n        throw new IllegalArgumentException(formatString(\"'replica' is required in {0}\", toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new IllegalArgumentException(\"replica val cannot be null\" + toJSONString(m));\n\n      this.nodeSetPresent = parseNodeset(m);\n      m.forEach((s, o) -> parseCondition(s, o, m));\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + toJSONString(m));\n    if (tag.name.startsWith(Clause.METRICS_PREFIX)) {\n      List<String> ss = StrUtils.splitSmart(tag.name, ':');\n      if (ss.size() < 3 || ss.size() > 4) {\n        throw new RuntimeException(\"Invalid metrics: param in \" + toJSONString(m) + \" must have at 2 or 3 segments after 'metrics:' separated by ':'\");\n      }\n    }\n    doPostValidate(collection, shard, replica, tag, globalTag);\n    hasComputedValue = hasComputedValue();\n  }\n\n","sourceOld":"  private Clause(Map<String, Object> m) {\n    derivedFrom = (Clause) m.remove(Clause.class.getName());\n    this.original = Utils.getDeepCopy(m, 10);\n    this.hashCode = original.hashCode();\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if (m.get(REPLICA) == null) {\n        throw new IllegalArgumentException(formatString(\"'replica' is required in {0}\", toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new IllegalArgumentException(\"replica val cannot be null\" + toJSONString(m));\n      m.forEach(this::parseCondition);\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + toJSONString(m));\n    if (tag.name.startsWith(Clause.METRICS_PREFIX)) {\n      List<String> ss = StrUtils.splitSmart(tag.name, ':');\n      if (ss.size() < 3 || ss.size() > 4) {\n        throw new RuntimeException(\"Invalid metrics: param in \" + toJSONString(m) + \" must have at 2 or 3 segments after 'metrics:' separated by ':'\");\n      }\n    }\n    doPostValidate(collection, shard, replica, tag, globalTag);\n    hasComputedValue = hasComputedValue();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"58af973abe9f7c0faa777c1a6285fc7f72c171c5","date":1559329541,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","sourceNew":"  private Clause(Map<String, Object> m) {\n    derivedFrom = (Clause) m.remove(Clause.class.getName());\n    this.original = Utils.getDeepCopy(m, 10);\n    this.hashCode = original.hashCode();\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if (m.get(REPLICA) == null) {\n        throw new IllegalArgumentException(formatString(\"'replica' is required in {0}\", toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new IllegalArgumentException(\"replica val cannot be null\" + toJSONString(m));\n\n      this.nodeSetPresent = parseNodeset(m);\n      m.forEach((s, o) -> parseCondition(s, o, m));\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + toJSONString(m));\n    if (tag.name.startsWith(Clause.METRICS_PREFIX)) {\n      List<String> ss = StrUtils.splitSmart(tag.name, ':');\n      if (ss.size() < 3 || ss.size() > 4) {\n        throw new RuntimeException(\"Invalid metrics: param in \" + toJSONString(m) + \" must have at 2 or 3 segments after 'metrics:' separated by ':'\");\n      }\n    }\n    doPostValidate(collection, shard, replica, tag, globalTag);\n    hasComputedValue = hasComputedValue();\n  }\n\n","sourceOld":"  private Clause(Map<String, Object> m) {\n    derivedFrom = (Clause) m.remove(Clause.class.getName());\n    this.original = Utils.getDeepCopy(m, 10);\n    this.hashCode = original.hashCode();\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if (m.get(REPLICA) == null) {\n        throw new IllegalArgumentException(formatString(\"'replica' is required in {0}\", toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new IllegalArgumentException(\"replica val cannot be null\" + toJSONString(m));\n      m.forEach(this::parseCondition);\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + toJSONString(m));\n    if (tag.name.startsWith(Clause.METRICS_PREFIX)) {\n      List<String> ss = StrUtils.splitSmart(tag.name, ':');\n      if (ss.size() < 3 || ss.size() > 4) {\n        throw new RuntimeException(\"Invalid metrics: param in \" + toJSONString(m) + \" must have at 2 or 3 segments after 'metrics:' separated by ':'\");\n      }\n    }\n    doPostValidate(collection, shard, replica, tag, globalTag);\n    hasComputedValue = hasComputedValue();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"081849c2756a6c9b9883ab9e332f3f3fcf2f05fa","date":1559549598,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","sourceNew":"  private Clause(Map<String, Object> m) {\n    derivedFrom = (Clause) m.remove(Clause.class.getName());\n    this.original = Utils.getDeepCopy(m, 10);\n    this.hashCode = original.hashCode();\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    String put = (String) m.getOrDefault(\"put\", m.containsKey(NODESET)? Put.ON_ALL.val: null );\n    if (put != null) {\n      this.put = Put.get(put);\n      if (this.put == null) throwExp(m, \"invalid value for put : {0}\", put);\n    }\n\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if (m.get(REPLICA) == null) {\n        throw new IllegalArgumentException(formatString(\"'replica' is required in {0}\", toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new IllegalArgumentException(\"replica val cannot be null\" + toJSONString(m));\n\n      this.nodeSetPresent = parseNodeset(m);\n      m.forEach((s, o) -> parseCondition(s, o, m));\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + toJSONString(m));\n    if (tag.name.startsWith(Clause.METRICS_PREFIX)) {\n      List<String> ss = StrUtils.splitSmart(tag.name, ':');\n      if (ss.size() < 3 || ss.size() > 4) {\n        throw new RuntimeException(\"Invalid metrics: param in \" + toJSONString(m) + \" must have at 2 or 3 segments after 'metrics:' separated by ':'\");\n      }\n    }\n    doPostValidate(collection, shard, replica, tag, globalTag);\n    hasComputedValue = hasComputedValue();\n  }\n\n","sourceOld":"  private Clause(Map<String, Object> m) {\n    derivedFrom = (Clause) m.remove(Clause.class.getName());\n    this.original = Utils.getDeepCopy(m, 10);\n    this.hashCode = original.hashCode();\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if (m.get(REPLICA) == null) {\n        throw new IllegalArgumentException(formatString(\"'replica' is required in {0}\", toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new IllegalArgumentException(\"replica val cannot be null\" + toJSONString(m));\n\n      this.nodeSetPresent = parseNodeset(m);\n      m.forEach((s, o) -> parseCondition(s, o, m));\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + toJSONString(m));\n    if (tag.name.startsWith(Clause.METRICS_PREFIX)) {\n      List<String> ss = StrUtils.splitSmart(tag.name, ':');\n      if (ss.size() < 3 || ss.size() > 4) {\n        throw new RuntimeException(\"Invalid metrics: param in \" + toJSONString(m) + \" must have at 2 or 3 segments after 'metrics:' separated by ':'\");\n      }\n    }\n    doPostValidate(collection, shard, replica, tag, globalTag);\n    hasComputedValue = hasComputedValue();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"067ba8c807b0f23eae8bf41bc27046a87b548134","date":1587570399,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","sourceNew":"  private Clause(Map<String, Object> m) {\n    derivedFrom = (Clause) m.remove(Clause.class.getName());\n    this.original = Utils.getDeepCopy(m, 10);\n    this.hashCode = original.hashCode();\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    String put = (String) m.getOrDefault(\"put\", m.containsKey(NODESET)? Put.ON_ALL.val: null );\n    if (put != null) {\n      this.put = Put.get(put);\n      if (this.put == null) throwExp(m, \"invalid value for put : {0}\", put);\n    }\n\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 3) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if (m.get(REPLICA) == null) {\n        throw new IllegalArgumentException(formatString(\"'replica' is required in {0}\", toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new IllegalArgumentException(\"replica val cannot be null\" + toJSONString(m));\n\n      this.nodeSetPresent = parseNodeset(m);\n      m.forEach((s, o) -> parseCondition(s, o, m));\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + toJSONString(m));\n    if (tag.name.startsWith(Clause.METRICS_PREFIX)) {\n      List<String> ss = StrUtils.splitSmart(tag.name, ':');\n      if (ss.size() < 3 || ss.size() > 4) {\n        throw new RuntimeException(\"Invalid metrics: param in \" + toJSONString(m) + \" must have at 2 or 3 segments after 'metrics:' separated by ':'\");\n      }\n    }\n    doPostValidate(collection, shard, replica, tag, globalTag);\n    hasComputedValue = hasComputedValue();\n  }\n\n","sourceOld":"  private Clause(Map<String, Object> m) {\n    derivedFrom = (Clause) m.remove(Clause.class.getName());\n    this.original = Utils.getDeepCopy(m, 10);\n    this.hashCode = original.hashCode();\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    String put = (String) m.getOrDefault(\"put\", m.containsKey(NODESET)? Put.ON_ALL.val: null );\n    if (put != null) {\n      this.put = Put.get(put);\n      if (this.put == null) throwExp(m, \"invalid value for put : {0}\", put);\n    }\n\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 2) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if (m.get(REPLICA) == null) {\n        throw new IllegalArgumentException(formatString(\"'replica' is required in {0}\", toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new IllegalArgumentException(\"replica val cannot be null\" + toJSONString(m));\n\n      this.nodeSetPresent = parseNodeset(m);\n      m.forEach((s, o) -> parseCondition(s, o, m));\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + toJSONString(m));\n    if (tag.name.startsWith(Clause.METRICS_PREFIX)) {\n      List<String> ss = StrUtils.splitSmart(tag.name, ':');\n      if (ss.size() < 3 || ss.size() > 4) {\n        throw new RuntimeException(\"Invalid metrics: param in \" + toJSONString(m) + \" must have at 2 or 3 segments after 'metrics:' separated by ':'\");\n      }\n    }\n    doPostValidate(collection, shard, replica, tag, globalTag);\n    hasComputedValue = hasComputedValue();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"527adea7ce767368d7317339023e18e39702132e","date":1592163810,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  private Clause(Map<String, Object> m) {\n    derivedFrom = (Clause) m.remove(Clause.class.getName());\n    this.original = Utils.getDeepCopy(m, 10);\n    this.hashCode = original.hashCode();\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    String put = (String) m.getOrDefault(\"put\", m.containsKey(NODESET)? Put.ON_ALL.val: null );\n    if (put != null) {\n      this.put = Put.get(put);\n      if (this.put == null) throwExp(m, \"invalid value for put : {0}\", put);\n    }\n\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 3) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if (m.get(REPLICA) == null) {\n        throw new IllegalArgumentException(formatString(\"'replica' is required in {0}\", toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new IllegalArgumentException(\"replica val cannot be null\" + toJSONString(m));\n\n      this.nodeSetPresent = parseNodeset(m);\n      m.forEach((s, o) -> parseCondition(s, o, m));\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + toJSONString(m));\n    if (tag.name.startsWith(Clause.METRICS_PREFIX)) {\n      List<String> ss = StrUtils.splitSmart(tag.name, ':');\n      if (ss.size() < 3 || ss.size() > 4) {\n        throw new RuntimeException(\"Invalid metrics: param in \" + toJSONString(m) + \" must have at 2 or 3 segments after 'metrics:' separated by ':'\");\n      }\n    }\n    doPostValidate(collection, shard, replica, tag, globalTag);\n    hasComputedValue = hasComputedValue();\n  }\n\n","sourceOld":"  private Clause(Map<String, Object> m) {\n    derivedFrom = (Clause) m.remove(Clause.class.getName());\n    this.original = Utils.getDeepCopy(m, 10);\n    this.hashCode = original.hashCode();\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    String put = (String) m.getOrDefault(\"put\", m.containsKey(NODESET)? Put.ON_ALL.val: null );\n    if (put != null) {\n      this.put = Put.get(put);\n      if (this.put == null) throwExp(m, \"invalid value for put : {0}\", put);\n    }\n\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 3) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if (m.get(REPLICA) == null) {\n        throw new IllegalArgumentException(formatString(\"'replica' is required in {0}\", toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new IllegalArgumentException(\"replica val cannot be null\" + toJSONString(m));\n\n      this.nodeSetPresent = parseNodeset(m);\n      m.forEach((s, o) -> parseCondition(s, o, m));\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + toJSONString(m));\n    if (tag.name.startsWith(Clause.METRICS_PREFIX)) {\n      List<String> ss = StrUtils.splitSmart(tag.name, ':');\n      if (ss.size() < 3 || ss.size() > 4) {\n        throw new RuntimeException(\"Invalid metrics: param in \" + toJSONString(m) + \" must have at 2 or 3 segments after 'metrics:' separated by ':'\");\n      }\n    }\n    doPostValidate(collection, shard, replica, tag, globalTag);\n    hasComputedValue = hasComputedValue();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Clause#Clause(Map[String,Object]).mjava","sourceNew":null,"sourceOld":"  @SuppressWarnings({\"unchecked\"})\n  private Clause(Map<String, Object> m) {\n    derivedFrom = (Clause) m.remove(Clause.class.getName());\n    this.original = Utils.getDeepCopy(m, 10);\n    this.hashCode = original.hashCode();\n    String type = (String) m.get(\"type\");\n    this.type = type == null || ANY.equals(type) ? null : Replica.Type.valueOf(type.toUpperCase(Locale.ROOT));\n    String put = (String) m.getOrDefault(\"put\", m.containsKey(NODESET)? Put.ON_ALL.val: null );\n    if (put != null) {\n      this.put = Put.get(put);\n      if (this.put == null) throwExp(m, \"invalid value for put : {0}\", put);\n    }\n\n    strict = Boolean.parseBoolean(String.valueOf(m.getOrDefault(\"strict\", \"true\")));\n    Optional<String> globalTagName = m.keySet().stream().filter(Policy.GLOBAL_ONLY_TAGS::contains).findFirst();\n    if (globalTagName.isPresent()) {\n      globalTag = parse(globalTagName.get(), m);\n      if (m.size() > 3) {\n        throw new RuntimeException(\"Only one extra tag supported for the tag \" + globalTagName.get() + \" in \" + toJSONString(m));\n      }\n      tag = parse(m.keySet().stream()\n          .filter(s -> (!globalTagName.get().equals(s) && !IGNORE_TAGS.contains(s)))\n          .findFirst().get(), m);\n    } else {\n      collection = parse(COLLECTION, m);\n      shard = parse(SHARD, m);\n      if (m.get(REPLICA) == null) {\n        throw new IllegalArgumentException(formatString(\"'replica' is required in {0}\", toJSONString(m)));\n      }\n      this.replica = parse(REPLICA, m);\n      if (replica.op == WILDCARD) throw new IllegalArgumentException(\"replica val cannot be null\" + toJSONString(m));\n\n      this.nodeSetPresent = parseNodeset(m);\n      m.forEach((s, o) -> parseCondition(s, o, m));\n    }\n    if (tag == null)\n      throw new RuntimeException(\"Invalid op, must have one and only one tag other than collection, shard,replica \" + toJSONString(m));\n    if (tag.name.startsWith(Clause.METRICS_PREFIX)) {\n      List<String> ss = StrUtils.splitSmart(tag.name, ':');\n      if (ss.size() < 3 || ss.size() > 4) {\n        throw new RuntimeException(\"Invalid metrics: param in \" + toJSONString(m) + \" must have at 2 or 3 segments after 'metrics:' separated by ':'\");\n      }\n    }\n    doPostValidate(collection, shard, replica, tag, globalTag);\n    hasComputedValue = hasComputedValue();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c304e97e7c1d472bc70e801b35ee78583916c6cd":["28288370235ed02234a64753cdbf0c6ec096304a","7811b56f2d9e37eb839450d346535c87f1f504c2"],"6249f3a9e6b3580715fd7ab5f4da0bf6e096f8f2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3f504512a03d978990cbff30db0522b354e846db":["527adea7ce767368d7317339023e18e39702132e"],"067ba8c807b0f23eae8bf41bc27046a87b548134":["081849c2756a6c9b9883ab9e332f3f3fcf2f05fa"],"c73f63a2a7b9f4a6b21e8723912461026968d87e":["7b9f478d4eb5c08e4b0a9717fe37bd99f09ea733"],"7b9f478d4eb5c08e4b0a9717fe37bd99f09ea733":["7d6bec22994bec86702ad05304ae983f7be5b5a7"],"7d6bec22994bec86702ad05304ae983f7be5b5a7":["9837f40c922407d857991971de6def18eda0857b"],"219ac4e012cb38bcfcd8f4290dccd4f5b4d7bc25":["98f11c416d30e556e0004a9a84960702d12d35b1"],"081849c2756a6c9b9883ab9e332f3f3fcf2f05fa":["9ddd9a76400512cda8f22bbc69e3d8b85672a91a"],"28288370235ed02234a64753cdbf0c6ec096304a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6249f3a9e6b3580715fd7ab5f4da0bf6e096f8f2"],"58e890cd5653ae8550bc6088d739f4eaaf950aff":["c73f63a2a7b9f4a6b21e8723912461026968d87e"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["33ae23947c41339ea2b352422bb762dfb4a17077","7d6bec22994bec86702ad05304ae983f7be5b5a7"],"7811b56f2d9e37eb839450d346535c87f1f504c2":["219ac4e012cb38bcfcd8f4290dccd4f5b4d7bc25"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"58af973abe9f7c0faa777c1a6285fc7f72c171c5":["58e890cd5653ae8550bc6088d739f4eaaf950aff","9ddd9a76400512cda8f22bbc69e3d8b85672a91a"],"527adea7ce767368d7317339023e18e39702132e":["067ba8c807b0f23eae8bf41bc27046a87b548134"],"9ddd9a76400512cda8f22bbc69e3d8b85672a91a":["58e890cd5653ae8550bc6088d739f4eaaf950aff"],"33ae23947c41339ea2b352422bb762dfb4a17077":["560c18d71dad43d675158783c3840f8c80d6d39c"],"9837f40c922407d857991971de6def18eda0857b":["33ae23947c41339ea2b352422bb762dfb4a17077"],"560c18d71dad43d675158783c3840f8c80d6d39c":["28288370235ed02234a64753cdbf0c6ec096304a","c304e97e7c1d472bc70e801b35ee78583916c6cd"],"98f11c416d30e556e0004a9a84960702d12d35b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6249f3a9e6b3580715fd7ab5f4da0bf6e096f8f2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["33ae23947c41339ea2b352422bb762dfb4a17077","7d6bec22994bec86702ad05304ae983f7be5b5a7"]},"commit2Childs":{"c304e97e7c1d472bc70e801b35ee78583916c6cd":["560c18d71dad43d675158783c3840f8c80d6d39c"],"6249f3a9e6b3580715fd7ab5f4da0bf6e096f8f2":["28288370235ed02234a64753cdbf0c6ec096304a","98f11c416d30e556e0004a9a84960702d12d35b1"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"067ba8c807b0f23eae8bf41bc27046a87b548134":["527adea7ce767368d7317339023e18e39702132e"],"c73f63a2a7b9f4a6b21e8723912461026968d87e":["58e890cd5653ae8550bc6088d739f4eaaf950aff"],"7b9f478d4eb5c08e4b0a9717fe37bd99f09ea733":["c73f63a2a7b9f4a6b21e8723912461026968d87e"],"7d6bec22994bec86702ad05304ae983f7be5b5a7":["7b9f478d4eb5c08e4b0a9717fe37bd99f09ea733","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"219ac4e012cb38bcfcd8f4290dccd4f5b4d7bc25":["7811b56f2d9e37eb839450d346535c87f1f504c2"],"28288370235ed02234a64753cdbf0c6ec096304a":["c304e97e7c1d472bc70e801b35ee78583916c6cd","560c18d71dad43d675158783c3840f8c80d6d39c"],"081849c2756a6c9b9883ab9e332f3f3fcf2f05fa":["067ba8c807b0f23eae8bf41bc27046a87b548134"],"58e890cd5653ae8550bc6088d739f4eaaf950aff":["58af973abe9f7c0faa777c1a6285fc7f72c171c5","9ddd9a76400512cda8f22bbc69e3d8b85672a91a"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"7811b56f2d9e37eb839450d346535c87f1f504c2":["c304e97e7c1d472bc70e801b35ee78583916c6cd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6249f3a9e6b3580715fd7ab5f4da0bf6e096f8f2","28288370235ed02234a64753cdbf0c6ec096304a","98f11c416d30e556e0004a9a84960702d12d35b1"],"58af973abe9f7c0faa777c1a6285fc7f72c171c5":[],"527adea7ce767368d7317339023e18e39702132e":["3f504512a03d978990cbff30db0522b354e846db"],"9ddd9a76400512cda8f22bbc69e3d8b85672a91a":["081849c2756a6c9b9883ab9e332f3f3fcf2f05fa","58af973abe9f7c0faa777c1a6285fc7f72c171c5"],"33ae23947c41339ea2b352422bb762dfb4a17077":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","9837f40c922407d857991971de6def18eda0857b","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"9837f40c922407d857991971de6def18eda0857b":["7d6bec22994bec86702ad05304ae983f7be5b5a7"],"560c18d71dad43d675158783c3840f8c80d6d39c":["33ae23947c41339ea2b352422bb762dfb4a17077"],"98f11c416d30e556e0004a9a84960702d12d35b1":["219ac4e012cb38bcfcd8f4290dccd4f5b4d7bc25"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","58af973abe9f7c0faa777c1a6285fc7f72c171c5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}