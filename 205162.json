{"path":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#applyAffix(char[],int,int,int,int,boolean,boolean).mjava","commits":[{"id":"38e7d0aeceab994177a0a6b52f475611b52f09bf","date":1393856424,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#applyAffix(char[],int,int,int,int,boolean,boolean).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#applyAffix(char[],int,int,int,int,boolean).mjava","sourceNew":"  /**\n   * Applies the affix rule to the given word, producing a list of stems if any are found\n   *\n   * @param strippedWord Word the affix has been removed and the strip added\n   * @param length valid length of stripped word\n   * @param affix HunspellAffix representing the affix rule itself\n   * @param prefixFlag when we already stripped a prefix, we cant simply recurse and check the suffix, unless both are compatible\n   *                   so we must check dictionary form against both to add it as a stem!\n   * @param recursionDepth current recursion depth\n   * @param prefix true if we are removing a prefix (false if its a suffix)\n   * @return List of stems for the word, or an empty list if none are found\n   */\n  List<CharsRef> applyAffix(char strippedWord[], int length, int affix, int prefixFlag, int recursionDepth, boolean prefix, boolean circumfix) {\n    segment.setLength(0);\n    segment.append(strippedWord, 0, length);\n    \n    // TODO: just pass this in from before, no need to decode it twice\n    affixReader.setPosition(8 * affix);\n    char flag = (char) (affixReader.readShort() & 0xffff);\n    affixReader.skipBytes(2); // strip\n    int condition = (char) (affixReader.readShort() & 0xffff);\n    boolean crossProduct = (condition & 1) == 1;\n    condition >>>= 1;\n    char append = (char) (affixReader.readShort() & 0xffff);\n    \n    Pattern pattern = dictionary.patterns.get(condition);\n    if (!pattern.matcher(segment).matches()) {\n      return Collections.emptyList();\n    }\n\n    List<CharsRef> stems = new ArrayList<CharsRef>();\n\n    IntsRef forms = dictionary.lookupWord(strippedWord, 0, length);\n    if (forms != null) {\n      for (int i = 0; i < forms.length; i++) {\n        dictionary.flagLookup.get(forms.ints[forms.offset+i], scratch);\n        char wordFlags[] = Dictionary.decodeFlags(scratch);\n        if (Dictionary.hasFlag(wordFlags, flag)) {\n          // confusing: in this one exception, we already chained the first prefix against the second,\n          // so it doesnt need to be checked against the word\n          boolean chainedPrefix = dictionary.complexPrefixes && recursionDepth == 1 && prefix;\n          if (chainedPrefix == false && prefixFlag >= 0 && !Dictionary.hasFlag(wordFlags, (char)prefixFlag)) {\n            // see if we can chain prefix thru the suffix continuation class (only if it has any!)\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            if (!hasCrossCheckedFlag((char)prefixFlag, appendFlags, false)) {\n              continue;\n            }\n          }\n          \n          // if circumfix was previously set by a prefix, we must check this suffix,\n          // to ensure it has it, and vice versa\n          if (dictionary.circumfix != -1) {\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            boolean suffixCircumfix = Dictionary.hasFlag(appendFlags, (char)dictionary.circumfix);\n            if (circumfix != suffixCircumfix) {\n              continue;\n            }\n          }\n          stems.add(new CharsRef(strippedWord, 0, length));\n        }\n      }\n    }\n    \n    // if a circumfix flag is defined in the dictionary, and we are a prefix, we need to check if we have that flag\n    if (dictionary.circumfix != -1 && !circumfix && prefix) {\n      dictionary.flagLookup.get(append, scratch);\n      char appendFlags[] = Dictionary.decodeFlags(scratch);\n      circumfix = Dictionary.hasFlag(appendFlags, (char)dictionary.circumfix);\n    }\n\n    if (crossProduct) {\n      if (recursionDepth == 0) {\n        if (prefix) {\n          // we took away the first prefix.\n          // COMPLEXPREFIXES = true:  combine with a second prefix and another suffix \n          // COMPLEXPREFIXES = false: combine with another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, flag, ++recursionDepth, dictionary.complexPrefixes, true, true, circumfix));\n        } else if (!dictionary.complexPrefixes) {\n          // we took away a suffix.\n          // COMPLEXPREFIXES = true: we don't recurse! only one suffix allowed\n          // COMPLEXPREFIXES = false: combine with another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, prefixFlag, ++recursionDepth, false, true, false, circumfix));\n        }\n      } else if (recursionDepth == 1) {\n        if (prefix && dictionary.complexPrefixes) {\n          // we took away the second prefix: go look for another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, flag, ++recursionDepth, false, true, true, circumfix));\n        } else if (prefix == false && dictionary.complexPrefixes == false) {\n          // we took away a prefix, then a suffix: go look for another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, prefixFlag, ++recursionDepth, false, true, false, circumfix));\n        }\n      }\n    }\n\n    return stems;\n  }\n\n","sourceOld":"  /**\n   * Applies the affix rule to the given word, producing a list of stems if any are found\n   *\n   * @param strippedWord Word the affix has been removed and the strip added\n   * @param length valid length of stripped word\n   * @param affix HunspellAffix representing the affix rule itself\n   * @param prefixFlag when we already stripped a prefix, we cant simply recurse and check the suffix, unless both are compatible\n   *                   so we must check dictionary form against both to add it as a stem!\n   * @param recursionDepth current recursion depth\n   * @param prefix true if we are removing a prefix (false if its a suffix)\n   * @return List of stems for the word, or an empty list if none are found\n   */\n  List<CharsRef> applyAffix(char strippedWord[], int length, int affix, int prefixFlag, int recursionDepth, boolean prefix) {\n    segment.setLength(0);\n    segment.append(strippedWord, 0, length);\n    \n    // TODO: just pass this in from before, no need to decode it twice\n    affixReader.setPosition(8 * affix);\n    char flag = (char) (affixReader.readShort() & 0xffff);\n    affixReader.skipBytes(2); // strip\n    int condition = (char) (affixReader.readShort() & 0xffff);\n    boolean crossProduct = (condition & 1) == 1;\n    condition >>>= 1;\n    char append = (char) (affixReader.readShort() & 0xffff);\n    \n    Pattern pattern = dictionary.patterns.get(condition);\n    if (!pattern.matcher(segment).matches()) {\n      return Collections.emptyList();\n    }\n\n    List<CharsRef> stems = new ArrayList<CharsRef>();\n\n    IntsRef forms = dictionary.lookupWord(strippedWord, 0, length);\n    if (forms != null) {\n      for (int i = 0; i < forms.length; i++) {\n        dictionary.flagLookup.get(forms.ints[forms.offset+i], scratch);\n        char wordFlags[] = Dictionary.decodeFlags(scratch);\n        if (Dictionary.hasFlag(wordFlags, flag)) {\n          // confusing: in this one exception, we already chained the first prefix against the second,\n          // so it doesnt need to be checked against the word\n          boolean chainedPrefix = dictionary.complexPrefixes && recursionDepth == 1 && prefix;\n          if (chainedPrefix == false && prefixFlag >= 0 && !Dictionary.hasFlag(wordFlags, (char)prefixFlag)) {\n            // see if we can chain prefix thru the suffix continuation class (only if it has any!)\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            if (!hasCrossCheckedFlag((char)prefixFlag, appendFlags, false)) {\n              continue;\n            }\n          }\n          stems.add(new CharsRef(strippedWord, 0, length));\n        }\n      }\n    }\n\n    if (crossProduct) {\n      if (recursionDepth == 0) {\n        if (prefix) {\n          // we took away the first prefix.\n          // COMPLEXPREFIXES = true:  combine with a second prefix and another suffix \n          // COMPLEXPREFIXES = false: combine with another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, flag, ++recursionDepth, dictionary.complexPrefixes, true, true));\n        } else if (!dictionary.complexPrefixes) {\n          // we took away a suffix.\n          // COMPLEXPREFIXES = true: we don't recurse! only one suffix allowed\n          // COMPLEXPREFIXES = false: combine with another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, prefixFlag, ++recursionDepth, false, true, false));\n        }\n      } else if (recursionDepth == 1) {\n        if (prefix && dictionary.complexPrefixes) {\n          // we took away the second prefix: go look for another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, flag, ++recursionDepth, false, true, true));\n        } else if (prefix == false && dictionary.complexPrefixes == false) {\n          // we took away a prefix, then a suffix: go look for another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, prefixFlag, ++recursionDepth, false, true, false));\n        }\n      }\n    }\n\n    return stems;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ae9942cbee38a49d234c2f022e3a265133d1914","date":1393952688,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#applyAffix(char[],int,int,int,int,boolean,boolean).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#applyAffix(char[],int,int,int,int,boolean,boolean).mjava","sourceNew":"  /**\n   * Applies the affix rule to the given word, producing a list of stems if any are found\n   *\n   * @param strippedWord Word the affix has been removed and the strip added\n   * @param length valid length of stripped word\n   * @param affix HunspellAffix representing the affix rule itself\n   * @param prefixFlag when we already stripped a prefix, we cant simply recurse and check the suffix, unless both are compatible\n   *                   so we must check dictionary form against both to add it as a stem!\n   * @param recursionDepth current recursion depth\n   * @param prefix true if we are removing a prefix (false if its a suffix)\n   * @return List of stems for the word, or an empty list if none are found\n   */\n  List<CharsRef> applyAffix(char strippedWord[], int length, int affix, int prefixFlag, int recursionDepth, boolean prefix, boolean circumfix) {\n    segment.setLength(0);\n    segment.append(strippedWord, 0, length);\n    \n    // TODO: just pass this in from before, no need to decode it twice\n    affixReader.setPosition(8 * affix);\n    char flag = (char) (affixReader.readShort() & 0xffff);\n    affixReader.skipBytes(2); // strip\n    int condition = (char) (affixReader.readShort() & 0xffff);\n    boolean crossProduct = (condition & 1) == 1;\n    condition >>>= 1;\n    char append = (char) (affixReader.readShort() & 0xffff);\n    \n    Pattern pattern = dictionary.patterns.get(condition);\n    if (!pattern.matcher(segment).matches()) {\n      return Collections.emptyList();\n    }\n\n    List<CharsRef> stems = new ArrayList<CharsRef>();\n\n    IntsRef forms = dictionary.lookupWord(strippedWord, 0, length);\n    if (forms != null) {\n      for (int i = 0; i < forms.length; i++) {\n        dictionary.flagLookup.get(forms.ints[forms.offset+i], scratch);\n        char wordFlags[] = Dictionary.decodeFlags(scratch);\n        if (Dictionary.hasFlag(wordFlags, flag)) {\n          // confusing: in this one exception, we already chained the first prefix against the second,\n          // so it doesnt need to be checked against the word\n          boolean chainedPrefix = dictionary.complexPrefixes && recursionDepth == 1 && prefix;\n          if (chainedPrefix == false && prefixFlag >= 0 && !Dictionary.hasFlag(wordFlags, (char)prefixFlag)) {\n            // see if we can chain prefix thru the suffix continuation class (only if it has any!)\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            if (!hasCrossCheckedFlag((char)prefixFlag, appendFlags, false)) {\n              continue;\n            }\n          }\n          \n          // if circumfix was previously set by a prefix, we must check this suffix,\n          // to ensure it has it, and vice versa\n          if (dictionary.circumfix != -1) {\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            boolean suffixCircumfix = Dictionary.hasFlag(appendFlags, (char)dictionary.circumfix);\n            if (circumfix != suffixCircumfix) {\n              continue;\n            }\n          }\n          stems.add(newStem(strippedWord, length));\n        }\n      }\n    }\n    \n    // if a circumfix flag is defined in the dictionary, and we are a prefix, we need to check if we have that flag\n    if (dictionary.circumfix != -1 && !circumfix && prefix) {\n      dictionary.flagLookup.get(append, scratch);\n      char appendFlags[] = Dictionary.decodeFlags(scratch);\n      circumfix = Dictionary.hasFlag(appendFlags, (char)dictionary.circumfix);\n    }\n\n    if (crossProduct) {\n      if (recursionDepth == 0) {\n        if (prefix) {\n          // we took away the first prefix.\n          // COMPLEXPREFIXES = true:  combine with a second prefix and another suffix \n          // COMPLEXPREFIXES = false: combine with another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, flag, ++recursionDepth, dictionary.complexPrefixes, true, true, circumfix));\n        } else if (!dictionary.complexPrefixes) {\n          // we took away a suffix.\n          // COMPLEXPREFIXES = true: we don't recurse! only one suffix allowed\n          // COMPLEXPREFIXES = false: combine with another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, prefixFlag, ++recursionDepth, false, true, false, circumfix));\n        }\n      } else if (recursionDepth == 1) {\n        if (prefix && dictionary.complexPrefixes) {\n          // we took away the second prefix: go look for another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, flag, ++recursionDepth, false, true, true, circumfix));\n        } else if (prefix == false && dictionary.complexPrefixes == false) {\n          // we took away a prefix, then a suffix: go look for another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, prefixFlag, ++recursionDepth, false, true, false, circumfix));\n        }\n      }\n    }\n\n    return stems;\n  }\n\n","sourceOld":"  /**\n   * Applies the affix rule to the given word, producing a list of stems if any are found\n   *\n   * @param strippedWord Word the affix has been removed and the strip added\n   * @param length valid length of stripped word\n   * @param affix HunspellAffix representing the affix rule itself\n   * @param prefixFlag when we already stripped a prefix, we cant simply recurse and check the suffix, unless both are compatible\n   *                   so we must check dictionary form against both to add it as a stem!\n   * @param recursionDepth current recursion depth\n   * @param prefix true if we are removing a prefix (false if its a suffix)\n   * @return List of stems for the word, or an empty list if none are found\n   */\n  List<CharsRef> applyAffix(char strippedWord[], int length, int affix, int prefixFlag, int recursionDepth, boolean prefix, boolean circumfix) {\n    segment.setLength(0);\n    segment.append(strippedWord, 0, length);\n    \n    // TODO: just pass this in from before, no need to decode it twice\n    affixReader.setPosition(8 * affix);\n    char flag = (char) (affixReader.readShort() & 0xffff);\n    affixReader.skipBytes(2); // strip\n    int condition = (char) (affixReader.readShort() & 0xffff);\n    boolean crossProduct = (condition & 1) == 1;\n    condition >>>= 1;\n    char append = (char) (affixReader.readShort() & 0xffff);\n    \n    Pattern pattern = dictionary.patterns.get(condition);\n    if (!pattern.matcher(segment).matches()) {\n      return Collections.emptyList();\n    }\n\n    List<CharsRef> stems = new ArrayList<CharsRef>();\n\n    IntsRef forms = dictionary.lookupWord(strippedWord, 0, length);\n    if (forms != null) {\n      for (int i = 0; i < forms.length; i++) {\n        dictionary.flagLookup.get(forms.ints[forms.offset+i], scratch);\n        char wordFlags[] = Dictionary.decodeFlags(scratch);\n        if (Dictionary.hasFlag(wordFlags, flag)) {\n          // confusing: in this one exception, we already chained the first prefix against the second,\n          // so it doesnt need to be checked against the word\n          boolean chainedPrefix = dictionary.complexPrefixes && recursionDepth == 1 && prefix;\n          if (chainedPrefix == false && prefixFlag >= 0 && !Dictionary.hasFlag(wordFlags, (char)prefixFlag)) {\n            // see if we can chain prefix thru the suffix continuation class (only if it has any!)\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            if (!hasCrossCheckedFlag((char)prefixFlag, appendFlags, false)) {\n              continue;\n            }\n          }\n          \n          // if circumfix was previously set by a prefix, we must check this suffix,\n          // to ensure it has it, and vice versa\n          if (dictionary.circumfix != -1) {\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            boolean suffixCircumfix = Dictionary.hasFlag(appendFlags, (char)dictionary.circumfix);\n            if (circumfix != suffixCircumfix) {\n              continue;\n            }\n          }\n          stems.add(new CharsRef(strippedWord, 0, length));\n        }\n      }\n    }\n    \n    // if a circumfix flag is defined in the dictionary, and we are a prefix, we need to check if we have that flag\n    if (dictionary.circumfix != -1 && !circumfix && prefix) {\n      dictionary.flagLookup.get(append, scratch);\n      char appendFlags[] = Dictionary.decodeFlags(scratch);\n      circumfix = Dictionary.hasFlag(appendFlags, (char)dictionary.circumfix);\n    }\n\n    if (crossProduct) {\n      if (recursionDepth == 0) {\n        if (prefix) {\n          // we took away the first prefix.\n          // COMPLEXPREFIXES = true:  combine with a second prefix and another suffix \n          // COMPLEXPREFIXES = false: combine with another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, flag, ++recursionDepth, dictionary.complexPrefixes, true, true, circumfix));\n        } else if (!dictionary.complexPrefixes) {\n          // we took away a suffix.\n          // COMPLEXPREFIXES = true: we don't recurse! only one suffix allowed\n          // COMPLEXPREFIXES = false: combine with another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, prefixFlag, ++recursionDepth, false, true, false, circumfix));\n        }\n      } else if (recursionDepth == 1) {\n        if (prefix && dictionary.complexPrefixes) {\n          // we took away the second prefix: go look for another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, flag, ++recursionDepth, false, true, true, circumfix));\n        } else if (prefix == false && dictionary.complexPrefixes == false) {\n          // we took away a prefix, then a suffix: go look for another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, prefixFlag, ++recursionDepth, false, true, false, circumfix));\n        }\n      }\n    }\n\n    return stems;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"96ea64d994d340044e0d57aeb6a5871539d10ca5","date":1394225445,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#applyAffix(char[],int,int,int,int,boolean,boolean).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#applyAffix(char[],int,int,int,int,boolean,boolean).mjava","sourceNew":"  /**\n   * Applies the affix rule to the given word, producing a list of stems if any are found\n   *\n   * @param strippedWord Word the affix has been removed and the strip added\n   * @param length valid length of stripped word\n   * @param affix HunspellAffix representing the affix rule itself\n   * @param prefixFlag when we already stripped a prefix, we cant simply recurse and check the suffix, unless both are compatible\n   *                   so we must check dictionary form against both to add it as a stem!\n   * @param recursionDepth current recursion depth\n   * @param prefix true if we are removing a prefix (false if its a suffix)\n   * @return List of stems for the word, or an empty list if none are found\n   */\n  List<CharsRef> applyAffix(char strippedWord[], int length, int affix, int prefixFlag, int recursionDepth, boolean prefix, boolean circumfix) {\n    segment.setLength(0);\n    segment.append(strippedWord, 0, length);\n    \n    // TODO: just pass this in from before, no need to decode it twice\n    affixReader.setPosition(8 * affix);\n    char flag = (char) (affixReader.readShort() & 0xffff);\n    affixReader.skipBytes(2); // strip\n    int condition = (char) (affixReader.readShort() & 0xffff);\n    boolean crossProduct = (condition & 1) == 1;\n    condition >>>= 1;\n    char append = (char) (affixReader.readShort() & 0xffff);\n    \n    Pattern pattern = dictionary.patterns.get(condition);\n    if (!pattern.matcher(segment).matches()) {\n      return Collections.emptyList();\n    }\n\n    List<CharsRef> stems = new ArrayList<CharsRef>();\n\n    IntsRef forms = dictionary.lookupWord(strippedWord, 0, length);\n    if (forms != null) {\n      for (int i = 0; i < forms.length; i++) {\n        dictionary.flagLookup.get(forms.ints[forms.offset+i], scratch);\n        char wordFlags[] = Dictionary.decodeFlags(scratch);\n        if (Dictionary.hasFlag(wordFlags, flag)) {\n          // confusing: in this one exception, we already chained the first prefix against the second,\n          // so it doesnt need to be checked against the word\n          boolean chainedPrefix = dictionary.complexPrefixes && recursionDepth == 1 && prefix;\n          if (chainedPrefix == false && prefixFlag >= 0 && !Dictionary.hasFlag(wordFlags, (char)prefixFlag)) {\n            // see if we can chain prefix thru the suffix continuation class (only if it has any!)\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            if (!hasCrossCheckedFlag((char)prefixFlag, appendFlags, false)) {\n              continue;\n            }\n          }\n          \n          // if circumfix was previously set by a prefix, we must check this suffix,\n          // to ensure it has it, and vice versa\n          if (dictionary.circumfix != -1) {\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            boolean suffixCircumfix = Dictionary.hasFlag(appendFlags, (char)dictionary.circumfix);\n            if (circumfix != suffixCircumfix) {\n              continue;\n            }\n          }\n          stems.add(newStem(strippedWord, length));\n        }\n      }\n    }\n    \n    // if a circumfix flag is defined in the dictionary, and we are a prefix, we need to check if we have that flag\n    if (dictionary.circumfix != -1 && !circumfix && prefix) {\n      dictionary.flagLookup.get(append, scratch);\n      char appendFlags[] = Dictionary.decodeFlags(scratch);\n      circumfix = Dictionary.hasFlag(appendFlags, (char)dictionary.circumfix);\n    }\n\n    if (crossProduct) {\n      if (recursionDepth == 0) {\n        if (prefix) {\n          // we took away the first prefix.\n          // COMPLEXPREFIXES = true:  combine with a second prefix and another suffix \n          // COMPLEXPREFIXES = false: combine with another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, flag, ++recursionDepth, dictionary.complexPrefixes, true, true, circumfix));\n        } else if (!dictionary.complexPrefixes) {\n          // we took away a suffix.\n          // COMPLEXPREFIXES = true: we don't recurse! only one suffix allowed\n          // COMPLEXPREFIXES = false: combine with another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, prefixFlag, ++recursionDepth, false, true, false, circumfix));\n        }\n      } else if (recursionDepth == 1) {\n        if (prefix && dictionary.complexPrefixes) {\n          // we took away the second prefix: go look for another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, flag, ++recursionDepth, false, true, true, circumfix));\n        } else if (prefix == false && dictionary.complexPrefixes == false) {\n          // we took away a prefix, then a suffix: go look for another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, prefixFlag, ++recursionDepth, false, true, false, circumfix));\n        }\n      }\n    }\n\n    return stems;\n  }\n\n","sourceOld":"  /**\n   * Applies the affix rule to the given word, producing a list of stems if any are found\n   *\n   * @param strippedWord Word the affix has been removed and the strip added\n   * @param length valid length of stripped word\n   * @param affix HunspellAffix representing the affix rule itself\n   * @param prefixFlag when we already stripped a prefix, we cant simply recurse and check the suffix, unless both are compatible\n   *                   so we must check dictionary form against both to add it as a stem!\n   * @param recursionDepth current recursion depth\n   * @param prefix true if we are removing a prefix (false if its a suffix)\n   * @return List of stems for the word, or an empty list if none are found\n   */\n  List<CharsRef> applyAffix(char strippedWord[], int length, int affix, int prefixFlag, int recursionDepth, boolean prefix, boolean circumfix) {\n    segment.setLength(0);\n    segment.append(strippedWord, 0, length);\n    \n    // TODO: just pass this in from before, no need to decode it twice\n    affixReader.setPosition(8 * affix);\n    char flag = (char) (affixReader.readShort() & 0xffff);\n    affixReader.skipBytes(2); // strip\n    int condition = (char) (affixReader.readShort() & 0xffff);\n    boolean crossProduct = (condition & 1) == 1;\n    condition >>>= 1;\n    char append = (char) (affixReader.readShort() & 0xffff);\n    \n    Pattern pattern = dictionary.patterns.get(condition);\n    if (!pattern.matcher(segment).matches()) {\n      return Collections.emptyList();\n    }\n\n    List<CharsRef> stems = new ArrayList<CharsRef>();\n\n    IntsRef forms = dictionary.lookupWord(strippedWord, 0, length);\n    if (forms != null) {\n      for (int i = 0; i < forms.length; i++) {\n        dictionary.flagLookup.get(forms.ints[forms.offset+i], scratch);\n        char wordFlags[] = Dictionary.decodeFlags(scratch);\n        if (Dictionary.hasFlag(wordFlags, flag)) {\n          // confusing: in this one exception, we already chained the first prefix against the second,\n          // so it doesnt need to be checked against the word\n          boolean chainedPrefix = dictionary.complexPrefixes && recursionDepth == 1 && prefix;\n          if (chainedPrefix == false && prefixFlag >= 0 && !Dictionary.hasFlag(wordFlags, (char)prefixFlag)) {\n            // see if we can chain prefix thru the suffix continuation class (only if it has any!)\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            if (!hasCrossCheckedFlag((char)prefixFlag, appendFlags, false)) {\n              continue;\n            }\n          }\n          \n          // if circumfix was previously set by a prefix, we must check this suffix,\n          // to ensure it has it, and vice versa\n          if (dictionary.circumfix != -1) {\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            boolean suffixCircumfix = Dictionary.hasFlag(appendFlags, (char)dictionary.circumfix);\n            if (circumfix != suffixCircumfix) {\n              continue;\n            }\n          }\n          stems.add(new CharsRef(strippedWord, 0, length));\n        }\n      }\n    }\n    \n    // if a circumfix flag is defined in the dictionary, and we are a prefix, we need to check if we have that flag\n    if (dictionary.circumfix != -1 && !circumfix && prefix) {\n      dictionary.flagLookup.get(append, scratch);\n      char appendFlags[] = Dictionary.decodeFlags(scratch);\n      circumfix = Dictionary.hasFlag(appendFlags, (char)dictionary.circumfix);\n    }\n\n    if (crossProduct) {\n      if (recursionDepth == 0) {\n        if (prefix) {\n          // we took away the first prefix.\n          // COMPLEXPREFIXES = true:  combine with a second prefix and another suffix \n          // COMPLEXPREFIXES = false: combine with another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, flag, ++recursionDepth, dictionary.complexPrefixes, true, true, circumfix));\n        } else if (!dictionary.complexPrefixes) {\n          // we took away a suffix.\n          // COMPLEXPREFIXES = true: we don't recurse! only one suffix allowed\n          // COMPLEXPREFIXES = false: combine with another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, prefixFlag, ++recursionDepth, false, true, false, circumfix));\n        }\n      } else if (recursionDepth == 1) {\n        if (prefix && dictionary.complexPrefixes) {\n          // we took away the second prefix: go look for another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, flag, ++recursionDepth, false, true, true, circumfix));\n        } else if (prefix == false && dictionary.complexPrefixes == false) {\n          // we took away a prefix, then a suffix: go look for another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, prefixFlag, ++recursionDepth, false, true, false, circumfix));\n        }\n      }\n    }\n\n    return stems;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09fb4238d56f62faff1f0c866bee53facad482ec","date":1394631888,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#applyAffix(char[],int,int,int,int,boolean,boolean).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#applyAffix(char[],int,int,int,int,boolean,boolean).mjava","sourceNew":"  /**\n   * Applies the affix rule to the given word, producing a list of stems if any are found\n   *\n   * @param strippedWord Word the affix has been removed and the strip added\n   * @param length valid length of stripped word\n   * @param affix HunspellAffix representing the affix rule itself\n   * @param prefixFlag when we already stripped a prefix, we cant simply recurse and check the suffix, unless both are compatible\n   *                   so we must check dictionary form against both to add it as a stem!\n   * @param recursionDepth current recursion depth\n   * @param prefix true if we are removing a prefix (false if its a suffix)\n   * @return List of stems for the word, or an empty list if none are found\n   */\n  List<CharsRef> applyAffix(char strippedWord[], int length, int affix, int prefixFlag, int recursionDepth, boolean prefix, boolean circumfix) {    \n    // TODO: just pass this in from before, no need to decode it twice\n    affixReader.setPosition(8 * affix);\n    char flag = (char) (affixReader.readShort() & 0xffff);\n    affixReader.skipBytes(2); // strip\n    int condition = (char) (affixReader.readShort() & 0xffff);\n    boolean crossProduct = (condition & 1) == 1;\n    condition >>>= 1;\n    char append = (char) (affixReader.readShort() & 0xffff);\n\n    List<CharsRef> stems = new ArrayList<CharsRef>();\n\n    IntsRef forms = dictionary.lookupWord(strippedWord, 0, length);\n    if (forms != null) {\n      for (int i = 0; i < forms.length; i++) {\n        dictionary.flagLookup.get(forms.ints[forms.offset+i], scratch);\n        char wordFlags[] = Dictionary.decodeFlags(scratch);\n        if (Dictionary.hasFlag(wordFlags, flag)) {\n          // confusing: in this one exception, we already chained the first prefix against the second,\n          // so it doesnt need to be checked against the word\n          boolean chainedPrefix = dictionary.complexPrefixes && recursionDepth == 1 && prefix;\n          if (chainedPrefix == false && prefixFlag >= 0 && !Dictionary.hasFlag(wordFlags, (char)prefixFlag)) {\n            // see if we can chain prefix thru the suffix continuation class (only if it has any!)\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            if (!hasCrossCheckedFlag((char)prefixFlag, appendFlags, false)) {\n              continue;\n            }\n          }\n          \n          // if circumfix was previously set by a prefix, we must check this suffix,\n          // to ensure it has it, and vice versa\n          if (dictionary.circumfix != -1) {\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            boolean suffixCircumfix = Dictionary.hasFlag(appendFlags, (char)dictionary.circumfix);\n            if (circumfix != suffixCircumfix) {\n              continue;\n            }\n          }\n          stems.add(newStem(strippedWord, length));\n        }\n      }\n    }\n    \n    // if a circumfix flag is defined in the dictionary, and we are a prefix, we need to check if we have that flag\n    if (dictionary.circumfix != -1 && !circumfix && prefix) {\n      dictionary.flagLookup.get(append, scratch);\n      char appendFlags[] = Dictionary.decodeFlags(scratch);\n      circumfix = Dictionary.hasFlag(appendFlags, (char)dictionary.circumfix);\n    }\n\n    if (crossProduct) {\n      if (recursionDepth == 0) {\n        if (prefix) {\n          // we took away the first prefix.\n          // COMPLEXPREFIXES = true:  combine with a second prefix and another suffix \n          // COMPLEXPREFIXES = false: combine with a suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, flag, ++recursionDepth, dictionary.complexPrefixes && dictionary.twoStageAffix, true, true, circumfix));\n        } else if (dictionary.complexPrefixes == false && dictionary.twoStageAffix) {\n          // we took away a suffix.\n          // COMPLEXPREFIXES = true: we don't recurse! only one suffix allowed\n          // COMPLEXPREFIXES = false: combine with another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, prefixFlag, ++recursionDepth, false, true, false, circumfix));\n        }\n      } else if (recursionDepth == 1) {\n        if (prefix && dictionary.complexPrefixes) {\n          // we took away the second prefix: go look for another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, flag, ++recursionDepth, false, true, true, circumfix));\n        } else if (prefix == false && dictionary.complexPrefixes == false && dictionary.twoStageAffix) {\n          // we took away a prefix, then a suffix: go look for another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, prefixFlag, ++recursionDepth, false, true, false, circumfix));\n        }\n      }\n    }\n\n    return stems;\n  }\n\n","sourceOld":"  /**\n   * Applies the affix rule to the given word, producing a list of stems if any are found\n   *\n   * @param strippedWord Word the affix has been removed and the strip added\n   * @param length valid length of stripped word\n   * @param affix HunspellAffix representing the affix rule itself\n   * @param prefixFlag when we already stripped a prefix, we cant simply recurse and check the suffix, unless both are compatible\n   *                   so we must check dictionary form against both to add it as a stem!\n   * @param recursionDepth current recursion depth\n   * @param prefix true if we are removing a prefix (false if its a suffix)\n   * @return List of stems for the word, or an empty list if none are found\n   */\n  List<CharsRef> applyAffix(char strippedWord[], int length, int affix, int prefixFlag, int recursionDepth, boolean prefix, boolean circumfix) {\n    segment.setLength(0);\n    segment.append(strippedWord, 0, length);\n    \n    // TODO: just pass this in from before, no need to decode it twice\n    affixReader.setPosition(8 * affix);\n    char flag = (char) (affixReader.readShort() & 0xffff);\n    affixReader.skipBytes(2); // strip\n    int condition = (char) (affixReader.readShort() & 0xffff);\n    boolean crossProduct = (condition & 1) == 1;\n    condition >>>= 1;\n    char append = (char) (affixReader.readShort() & 0xffff);\n    \n    Pattern pattern = dictionary.patterns.get(condition);\n    if (!pattern.matcher(segment).matches()) {\n      return Collections.emptyList();\n    }\n\n    List<CharsRef> stems = new ArrayList<CharsRef>();\n\n    IntsRef forms = dictionary.lookupWord(strippedWord, 0, length);\n    if (forms != null) {\n      for (int i = 0; i < forms.length; i++) {\n        dictionary.flagLookup.get(forms.ints[forms.offset+i], scratch);\n        char wordFlags[] = Dictionary.decodeFlags(scratch);\n        if (Dictionary.hasFlag(wordFlags, flag)) {\n          // confusing: in this one exception, we already chained the first prefix against the second,\n          // so it doesnt need to be checked against the word\n          boolean chainedPrefix = dictionary.complexPrefixes && recursionDepth == 1 && prefix;\n          if (chainedPrefix == false && prefixFlag >= 0 && !Dictionary.hasFlag(wordFlags, (char)prefixFlag)) {\n            // see if we can chain prefix thru the suffix continuation class (only if it has any!)\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            if (!hasCrossCheckedFlag((char)prefixFlag, appendFlags, false)) {\n              continue;\n            }\n          }\n          \n          // if circumfix was previously set by a prefix, we must check this suffix,\n          // to ensure it has it, and vice versa\n          if (dictionary.circumfix != -1) {\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            boolean suffixCircumfix = Dictionary.hasFlag(appendFlags, (char)dictionary.circumfix);\n            if (circumfix != suffixCircumfix) {\n              continue;\n            }\n          }\n          stems.add(newStem(strippedWord, length));\n        }\n      }\n    }\n    \n    // if a circumfix flag is defined in the dictionary, and we are a prefix, we need to check if we have that flag\n    if (dictionary.circumfix != -1 && !circumfix && prefix) {\n      dictionary.flagLookup.get(append, scratch);\n      char appendFlags[] = Dictionary.decodeFlags(scratch);\n      circumfix = Dictionary.hasFlag(appendFlags, (char)dictionary.circumfix);\n    }\n\n    if (crossProduct) {\n      if (recursionDepth == 0) {\n        if (prefix) {\n          // we took away the first prefix.\n          // COMPLEXPREFIXES = true:  combine with a second prefix and another suffix \n          // COMPLEXPREFIXES = false: combine with another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, flag, ++recursionDepth, dictionary.complexPrefixes, true, true, circumfix));\n        } else if (!dictionary.complexPrefixes) {\n          // we took away a suffix.\n          // COMPLEXPREFIXES = true: we don't recurse! only one suffix allowed\n          // COMPLEXPREFIXES = false: combine with another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, prefixFlag, ++recursionDepth, false, true, false, circumfix));\n        }\n      } else if (recursionDepth == 1) {\n        if (prefix && dictionary.complexPrefixes) {\n          // we took away the second prefix: go look for another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, flag, ++recursionDepth, false, true, true, circumfix));\n        } else if (prefix == false && dictionary.complexPrefixes == false) {\n          // we took away a prefix, then a suffix: go look for another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, prefixFlag, ++recursionDepth, false, true, false, circumfix));\n        }\n      }\n    }\n\n    return stems;\n  }\n\n","bugFix":null,"bugIntro":["23ccc3a9bdacbdab4dbedf7c926b76298d8bd1db"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#applyAffix(char[],int,int,int,int,boolean,boolean).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#applyAffix(char[],int,int,int,int,boolean,boolean).mjava","sourceNew":"  /**\n   * Applies the affix rule to the given word, producing a list of stems if any are found\n   *\n   * @param strippedWord Word the affix has been removed and the strip added\n   * @param length valid length of stripped word\n   * @param affix HunspellAffix representing the affix rule itself\n   * @param prefixFlag when we already stripped a prefix, we cant simply recurse and check the suffix, unless both are compatible\n   *                   so we must check dictionary form against both to add it as a stem!\n   * @param recursionDepth current recursion depth\n   * @param prefix true if we are removing a prefix (false if its a suffix)\n   * @return List of stems for the word, or an empty list if none are found\n   */\n  List<CharsRef> applyAffix(char strippedWord[], int length, int affix, int prefixFlag, int recursionDepth, boolean prefix, boolean circumfix) {    \n    // TODO: just pass this in from before, no need to decode it twice\n    affixReader.setPosition(8 * affix);\n    char flag = (char) (affixReader.readShort() & 0xffff);\n    affixReader.skipBytes(2); // strip\n    int condition = (char) (affixReader.readShort() & 0xffff);\n    boolean crossProduct = (condition & 1) == 1;\n    condition >>>= 1;\n    char append = (char) (affixReader.readShort() & 0xffff);\n\n    List<CharsRef> stems = new ArrayList<>();\n\n    IntsRef forms = dictionary.lookupWord(strippedWord, 0, length);\n    if (forms != null) {\n      for (int i = 0; i < forms.length; i++) {\n        dictionary.flagLookup.get(forms.ints[forms.offset+i], scratch);\n        char wordFlags[] = Dictionary.decodeFlags(scratch);\n        if (Dictionary.hasFlag(wordFlags, flag)) {\n          // confusing: in this one exception, we already chained the first prefix against the second,\n          // so it doesnt need to be checked against the word\n          boolean chainedPrefix = dictionary.complexPrefixes && recursionDepth == 1 && prefix;\n          if (chainedPrefix == false && prefixFlag >= 0 && !Dictionary.hasFlag(wordFlags, (char)prefixFlag)) {\n            // see if we can chain prefix thru the suffix continuation class (only if it has any!)\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            if (!hasCrossCheckedFlag((char)prefixFlag, appendFlags, false)) {\n              continue;\n            }\n          }\n          \n          // if circumfix was previously set by a prefix, we must check this suffix,\n          // to ensure it has it, and vice versa\n          if (dictionary.circumfix != -1) {\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            boolean suffixCircumfix = Dictionary.hasFlag(appendFlags, (char)dictionary.circumfix);\n            if (circumfix != suffixCircumfix) {\n              continue;\n            }\n          }\n          stems.add(newStem(strippedWord, length));\n        }\n      }\n    }\n    \n    // if a circumfix flag is defined in the dictionary, and we are a prefix, we need to check if we have that flag\n    if (dictionary.circumfix != -1 && !circumfix && prefix) {\n      dictionary.flagLookup.get(append, scratch);\n      char appendFlags[] = Dictionary.decodeFlags(scratch);\n      circumfix = Dictionary.hasFlag(appendFlags, (char)dictionary.circumfix);\n    }\n\n    if (crossProduct) {\n      if (recursionDepth == 0) {\n        if (prefix) {\n          // we took away the first prefix.\n          // COMPLEXPREFIXES = true:  combine with a second prefix and another suffix \n          // COMPLEXPREFIXES = false: combine with a suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, flag, ++recursionDepth, dictionary.complexPrefixes && dictionary.twoStageAffix, true, true, circumfix));\n        } else if (dictionary.complexPrefixes == false && dictionary.twoStageAffix) {\n          // we took away a suffix.\n          // COMPLEXPREFIXES = true: we don't recurse! only one suffix allowed\n          // COMPLEXPREFIXES = false: combine with another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, prefixFlag, ++recursionDepth, false, true, false, circumfix));\n        }\n      } else if (recursionDepth == 1) {\n        if (prefix && dictionary.complexPrefixes) {\n          // we took away the second prefix: go look for another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, flag, ++recursionDepth, false, true, true, circumfix));\n        } else if (prefix == false && dictionary.complexPrefixes == false && dictionary.twoStageAffix) {\n          // we took away a prefix, then a suffix: go look for another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, prefixFlag, ++recursionDepth, false, true, false, circumfix));\n        }\n      }\n    }\n\n    return stems;\n  }\n\n","sourceOld":"  /**\n   * Applies the affix rule to the given word, producing a list of stems if any are found\n   *\n   * @param strippedWord Word the affix has been removed and the strip added\n   * @param length valid length of stripped word\n   * @param affix HunspellAffix representing the affix rule itself\n   * @param prefixFlag when we already stripped a prefix, we cant simply recurse and check the suffix, unless both are compatible\n   *                   so we must check dictionary form against both to add it as a stem!\n   * @param recursionDepth current recursion depth\n   * @param prefix true if we are removing a prefix (false if its a suffix)\n   * @return List of stems for the word, or an empty list if none are found\n   */\n  List<CharsRef> applyAffix(char strippedWord[], int length, int affix, int prefixFlag, int recursionDepth, boolean prefix, boolean circumfix) {    \n    // TODO: just pass this in from before, no need to decode it twice\n    affixReader.setPosition(8 * affix);\n    char flag = (char) (affixReader.readShort() & 0xffff);\n    affixReader.skipBytes(2); // strip\n    int condition = (char) (affixReader.readShort() & 0xffff);\n    boolean crossProduct = (condition & 1) == 1;\n    condition >>>= 1;\n    char append = (char) (affixReader.readShort() & 0xffff);\n\n    List<CharsRef> stems = new ArrayList<CharsRef>();\n\n    IntsRef forms = dictionary.lookupWord(strippedWord, 0, length);\n    if (forms != null) {\n      for (int i = 0; i < forms.length; i++) {\n        dictionary.flagLookup.get(forms.ints[forms.offset+i], scratch);\n        char wordFlags[] = Dictionary.decodeFlags(scratch);\n        if (Dictionary.hasFlag(wordFlags, flag)) {\n          // confusing: in this one exception, we already chained the first prefix against the second,\n          // so it doesnt need to be checked against the word\n          boolean chainedPrefix = dictionary.complexPrefixes && recursionDepth == 1 && prefix;\n          if (chainedPrefix == false && prefixFlag >= 0 && !Dictionary.hasFlag(wordFlags, (char)prefixFlag)) {\n            // see if we can chain prefix thru the suffix continuation class (only if it has any!)\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            if (!hasCrossCheckedFlag((char)prefixFlag, appendFlags, false)) {\n              continue;\n            }\n          }\n          \n          // if circumfix was previously set by a prefix, we must check this suffix,\n          // to ensure it has it, and vice versa\n          if (dictionary.circumfix != -1) {\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            boolean suffixCircumfix = Dictionary.hasFlag(appendFlags, (char)dictionary.circumfix);\n            if (circumfix != suffixCircumfix) {\n              continue;\n            }\n          }\n          stems.add(newStem(strippedWord, length));\n        }\n      }\n    }\n    \n    // if a circumfix flag is defined in the dictionary, and we are a prefix, we need to check if we have that flag\n    if (dictionary.circumfix != -1 && !circumfix && prefix) {\n      dictionary.flagLookup.get(append, scratch);\n      char appendFlags[] = Dictionary.decodeFlags(scratch);\n      circumfix = Dictionary.hasFlag(appendFlags, (char)dictionary.circumfix);\n    }\n\n    if (crossProduct) {\n      if (recursionDepth == 0) {\n        if (prefix) {\n          // we took away the first prefix.\n          // COMPLEXPREFIXES = true:  combine with a second prefix and another suffix \n          // COMPLEXPREFIXES = false: combine with a suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, flag, ++recursionDepth, dictionary.complexPrefixes && dictionary.twoStageAffix, true, true, circumfix));\n        } else if (dictionary.complexPrefixes == false && dictionary.twoStageAffix) {\n          // we took away a suffix.\n          // COMPLEXPREFIXES = true: we don't recurse! only one suffix allowed\n          // COMPLEXPREFIXES = false: combine with another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, prefixFlag, ++recursionDepth, false, true, false, circumfix));\n        }\n      } else if (recursionDepth == 1) {\n        if (prefix && dictionary.complexPrefixes) {\n          // we took away the second prefix: go look for another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, flag, ++recursionDepth, false, true, true, circumfix));\n        } else if (prefix == false && dictionary.complexPrefixes == false && dictionary.twoStageAffix) {\n          // we took away a prefix, then a suffix: go look for another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, prefixFlag, ++recursionDepth, false, true, false, circumfix));\n        }\n      }\n    }\n\n    return stems;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"23ccc3a9bdacbdab4dbedf7c926b76298d8bd1db","date":1397463062,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#applyAffix(char[],int,int,int,int,boolean,boolean).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#applyAffix(char[],int,int,int,int,boolean,boolean).mjava","sourceNew":"  /**\n   * Applies the affix rule to the given word, producing a list of stems if any are found\n   *\n   * @param strippedWord Word the affix has been removed and the strip added\n   * @param length valid length of stripped word\n   * @param affix HunspellAffix representing the affix rule itself\n   * @param prefixFlag when we already stripped a prefix, we cant simply recurse and check the suffix, unless both are compatible\n   *                   so we must check dictionary form against both to add it as a stem!\n   * @param recursionDepth current recursion depth\n   * @param prefix true if we are removing a prefix (false if its a suffix)\n   * @return List of stems for the word, or an empty list if none are found\n   */\n  List<CharsRef> applyAffix(char strippedWord[], int length, int affix, int prefixFlag, int recursionDepth, boolean prefix, boolean circumfix) throws IOException {    \n    // TODO: just pass this in from before, no need to decode it twice\n    affixReader.setPosition(8 * affix);\n    char flag = (char) (affixReader.readShort() & 0xffff);\n    affixReader.skipBytes(2); // strip\n    int condition = (char) (affixReader.readShort() & 0xffff);\n    boolean crossProduct = (condition & 1) == 1;\n    condition >>>= 1;\n    char append = (char) (affixReader.readShort() & 0xffff);\n\n    List<CharsRef> stems = new ArrayList<>();\n\n    IntsRef forms = dictionary.lookupWord(strippedWord, 0, length);\n    if (forms != null) {\n      for (int i = 0; i < forms.length; i++) {\n        dictionary.flagLookup.get(forms.ints[forms.offset+i], scratch);\n        char wordFlags[] = Dictionary.decodeFlags(scratch);\n        if (Dictionary.hasFlag(wordFlags, flag)) {\n          // confusing: in this one exception, we already chained the first prefix against the second,\n          // so it doesnt need to be checked against the word\n          boolean chainedPrefix = dictionary.complexPrefixes && recursionDepth == 1 && prefix;\n          if (chainedPrefix == false && prefixFlag >= 0 && !Dictionary.hasFlag(wordFlags, (char)prefixFlag)) {\n            // see if we can chain prefix thru the suffix continuation class (only if it has any!)\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            if (!hasCrossCheckedFlag((char)prefixFlag, appendFlags, false)) {\n              continue;\n            }\n          }\n          \n          // if circumfix was previously set by a prefix, we must check this suffix,\n          // to ensure it has it, and vice versa\n          if (dictionary.circumfix != -1) {\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            boolean suffixCircumfix = Dictionary.hasFlag(appendFlags, (char)dictionary.circumfix);\n            if (circumfix != suffixCircumfix) {\n              continue;\n            }\n          }\n          stems.add(newStem(strippedWord, length));\n        }\n      }\n    }\n    \n    // if a circumfix flag is defined in the dictionary, and we are a prefix, we need to check if we have that flag\n    if (dictionary.circumfix != -1 && !circumfix && prefix) {\n      dictionary.flagLookup.get(append, scratch);\n      char appendFlags[] = Dictionary.decodeFlags(scratch);\n      circumfix = Dictionary.hasFlag(appendFlags, (char)dictionary.circumfix);\n    }\n\n    if (crossProduct) {\n      if (recursionDepth == 0) {\n        if (prefix) {\n          // we took away the first prefix.\n          // COMPLEXPREFIXES = true:  combine with a second prefix and another suffix \n          // COMPLEXPREFIXES = false: combine with a suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, flag, ++recursionDepth, dictionary.complexPrefixes && dictionary.twoStageAffix, true, true, circumfix));\n        } else if (dictionary.complexPrefixes == false && dictionary.twoStageAffix) {\n          // we took away a suffix.\n          // COMPLEXPREFIXES = true: we don't recurse! only one suffix allowed\n          // COMPLEXPREFIXES = false: combine with another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, prefixFlag, ++recursionDepth, false, true, false, circumfix));\n        }\n      } else if (recursionDepth == 1) {\n        if (prefix && dictionary.complexPrefixes) {\n          // we took away the second prefix: go look for another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, flag, ++recursionDepth, false, true, true, circumfix));\n        } else if (prefix == false && dictionary.complexPrefixes == false && dictionary.twoStageAffix) {\n          // we took away a prefix, then a suffix: go look for another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, prefixFlag, ++recursionDepth, false, true, false, circumfix));\n        }\n      }\n    }\n\n    return stems;\n  }\n\n","sourceOld":"  /**\n   * Applies the affix rule to the given word, producing a list of stems if any are found\n   *\n   * @param strippedWord Word the affix has been removed and the strip added\n   * @param length valid length of stripped word\n   * @param affix HunspellAffix representing the affix rule itself\n   * @param prefixFlag when we already stripped a prefix, we cant simply recurse and check the suffix, unless both are compatible\n   *                   so we must check dictionary form against both to add it as a stem!\n   * @param recursionDepth current recursion depth\n   * @param prefix true if we are removing a prefix (false if its a suffix)\n   * @return List of stems for the word, or an empty list if none are found\n   */\n  List<CharsRef> applyAffix(char strippedWord[], int length, int affix, int prefixFlag, int recursionDepth, boolean prefix, boolean circumfix) {    \n    // TODO: just pass this in from before, no need to decode it twice\n    affixReader.setPosition(8 * affix);\n    char flag = (char) (affixReader.readShort() & 0xffff);\n    affixReader.skipBytes(2); // strip\n    int condition = (char) (affixReader.readShort() & 0xffff);\n    boolean crossProduct = (condition & 1) == 1;\n    condition >>>= 1;\n    char append = (char) (affixReader.readShort() & 0xffff);\n\n    List<CharsRef> stems = new ArrayList<>();\n\n    IntsRef forms = dictionary.lookupWord(strippedWord, 0, length);\n    if (forms != null) {\n      for (int i = 0; i < forms.length; i++) {\n        dictionary.flagLookup.get(forms.ints[forms.offset+i], scratch);\n        char wordFlags[] = Dictionary.decodeFlags(scratch);\n        if (Dictionary.hasFlag(wordFlags, flag)) {\n          // confusing: in this one exception, we already chained the first prefix against the second,\n          // so it doesnt need to be checked against the word\n          boolean chainedPrefix = dictionary.complexPrefixes && recursionDepth == 1 && prefix;\n          if (chainedPrefix == false && prefixFlag >= 0 && !Dictionary.hasFlag(wordFlags, (char)prefixFlag)) {\n            // see if we can chain prefix thru the suffix continuation class (only if it has any!)\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            if (!hasCrossCheckedFlag((char)prefixFlag, appendFlags, false)) {\n              continue;\n            }\n          }\n          \n          // if circumfix was previously set by a prefix, we must check this suffix,\n          // to ensure it has it, and vice versa\n          if (dictionary.circumfix != -1) {\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            boolean suffixCircumfix = Dictionary.hasFlag(appendFlags, (char)dictionary.circumfix);\n            if (circumfix != suffixCircumfix) {\n              continue;\n            }\n          }\n          stems.add(newStem(strippedWord, length));\n        }\n      }\n    }\n    \n    // if a circumfix flag is defined in the dictionary, and we are a prefix, we need to check if we have that flag\n    if (dictionary.circumfix != -1 && !circumfix && prefix) {\n      dictionary.flagLookup.get(append, scratch);\n      char appendFlags[] = Dictionary.decodeFlags(scratch);\n      circumfix = Dictionary.hasFlag(appendFlags, (char)dictionary.circumfix);\n    }\n\n    if (crossProduct) {\n      if (recursionDepth == 0) {\n        if (prefix) {\n          // we took away the first prefix.\n          // COMPLEXPREFIXES = true:  combine with a second prefix and another suffix \n          // COMPLEXPREFIXES = false: combine with a suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, flag, ++recursionDepth, dictionary.complexPrefixes && dictionary.twoStageAffix, true, true, circumfix));\n        } else if (dictionary.complexPrefixes == false && dictionary.twoStageAffix) {\n          // we took away a suffix.\n          // COMPLEXPREFIXES = true: we don't recurse! only one suffix allowed\n          // COMPLEXPREFIXES = false: combine with another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, prefixFlag, ++recursionDepth, false, true, false, circumfix));\n        }\n      } else if (recursionDepth == 1) {\n        if (prefix && dictionary.complexPrefixes) {\n          // we took away the second prefix: go look for another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, flag, ++recursionDepth, false, true, true, circumfix));\n        } else if (prefix == false && dictionary.complexPrefixes == false && dictionary.twoStageAffix) {\n          // we took away a prefix, then a suffix: go look for another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, prefixFlag, ++recursionDepth, false, true, false, circumfix));\n        }\n      }\n    }\n\n    return stems;\n  }\n\n","bugFix":["09fb4238d56f62faff1f0c866bee53facad482ec"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5916de6e2f6deb9da923b2710f6451668e94a20c","date":1403356557,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#applyAffix(char[],int,int,int,int,boolean,boolean).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#applyAffix(char[],int,int,int,int,boolean,boolean).mjava","sourceNew":"  /**\n   * Applies the affix rule to the given word, producing a list of stems if any are found\n   *\n   * @param strippedWord Word the affix has been removed and the strip added\n   * @param length valid length of stripped word\n   * @param affix HunspellAffix representing the affix rule itself\n   * @param prefixFlag when we already stripped a prefix, we cant simply recurse and check the suffix, unless both are compatible\n   *                   so we must check dictionary form against both to add it as a stem!\n   * @param recursionDepth current recursion depth\n   * @param prefix true if we are removing a prefix (false if its a suffix)\n   * @return List of stems for the word, or an empty list if none are found\n   */\n  List<CharsRef> applyAffix(char strippedWord[], int length, int affix, int prefixFlag, int recursionDepth, boolean prefix, boolean circumfix) throws IOException {    \n    // TODO: just pass this in from before, no need to decode it twice\n    affixReader.setPosition(8 * affix);\n    char flag = (char) (affixReader.readShort() & 0xffff);\n    affixReader.skipBytes(2); // strip\n    int condition = (char) (affixReader.readShort() & 0xffff);\n    boolean crossProduct = (condition & 1) == 1;\n    condition >>>= 1;\n    char append = (char) (affixReader.readShort() & 0xffff);\n\n    List<CharsRef> stems = new ArrayList<>();\n\n    IntsRef forms = dictionary.lookupWord(strippedWord, 0, length);\n    if (forms != null) {\n      for (int i = 0; i < forms.length; i += formStep) {\n        dictionary.flagLookup.get(forms.ints[forms.offset+i], scratch);\n        char wordFlags[] = Dictionary.decodeFlags(scratch);\n        if (Dictionary.hasFlag(wordFlags, flag)) {\n          // confusing: in this one exception, we already chained the first prefix against the second,\n          // so it doesnt need to be checked against the word\n          boolean chainedPrefix = dictionary.complexPrefixes && recursionDepth == 1 && prefix;\n          if (chainedPrefix == false && prefixFlag >= 0 && !Dictionary.hasFlag(wordFlags, (char)prefixFlag)) {\n            // see if we can chain prefix thru the suffix continuation class (only if it has any!)\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            if (!hasCrossCheckedFlag((char)prefixFlag, appendFlags, false)) {\n              continue;\n            }\n          }\n          \n          // if circumfix was previously set by a prefix, we must check this suffix,\n          // to ensure it has it, and vice versa\n          if (dictionary.circumfix != -1) {\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            boolean suffixCircumfix = Dictionary.hasFlag(appendFlags, (char)dictionary.circumfix);\n            if (circumfix != suffixCircumfix) {\n              continue;\n            }\n          }\n          stems.add(newStem(strippedWord, length, forms, i));\n        }\n      }\n    }\n    \n    // if a circumfix flag is defined in the dictionary, and we are a prefix, we need to check if we have that flag\n    if (dictionary.circumfix != -1 && !circumfix && prefix) {\n      dictionary.flagLookup.get(append, scratch);\n      char appendFlags[] = Dictionary.decodeFlags(scratch);\n      circumfix = Dictionary.hasFlag(appendFlags, (char)dictionary.circumfix);\n    }\n\n    if (crossProduct) {\n      if (recursionDepth == 0) {\n        if (prefix) {\n          // we took away the first prefix.\n          // COMPLEXPREFIXES = true:  combine with a second prefix and another suffix \n          // COMPLEXPREFIXES = false: combine with a suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, flag, ++recursionDepth, dictionary.complexPrefixes && dictionary.twoStageAffix, true, true, circumfix));\n        } else if (dictionary.complexPrefixes == false && dictionary.twoStageAffix) {\n          // we took away a suffix.\n          // COMPLEXPREFIXES = true: we don't recurse! only one suffix allowed\n          // COMPLEXPREFIXES = false: combine with another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, prefixFlag, ++recursionDepth, false, true, false, circumfix));\n        }\n      } else if (recursionDepth == 1) {\n        if (prefix && dictionary.complexPrefixes) {\n          // we took away the second prefix: go look for another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, flag, ++recursionDepth, false, true, true, circumfix));\n        } else if (prefix == false && dictionary.complexPrefixes == false && dictionary.twoStageAffix) {\n          // we took away a prefix, then a suffix: go look for another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, prefixFlag, ++recursionDepth, false, true, false, circumfix));\n        }\n      }\n    }\n\n    return stems;\n  }\n\n","sourceOld":"  /**\n   * Applies the affix rule to the given word, producing a list of stems if any are found\n   *\n   * @param strippedWord Word the affix has been removed and the strip added\n   * @param length valid length of stripped word\n   * @param affix HunspellAffix representing the affix rule itself\n   * @param prefixFlag when we already stripped a prefix, we cant simply recurse and check the suffix, unless both are compatible\n   *                   so we must check dictionary form against both to add it as a stem!\n   * @param recursionDepth current recursion depth\n   * @param prefix true if we are removing a prefix (false if its a suffix)\n   * @return List of stems for the word, or an empty list if none are found\n   */\n  List<CharsRef> applyAffix(char strippedWord[], int length, int affix, int prefixFlag, int recursionDepth, boolean prefix, boolean circumfix) throws IOException {    \n    // TODO: just pass this in from before, no need to decode it twice\n    affixReader.setPosition(8 * affix);\n    char flag = (char) (affixReader.readShort() & 0xffff);\n    affixReader.skipBytes(2); // strip\n    int condition = (char) (affixReader.readShort() & 0xffff);\n    boolean crossProduct = (condition & 1) == 1;\n    condition >>>= 1;\n    char append = (char) (affixReader.readShort() & 0xffff);\n\n    List<CharsRef> stems = new ArrayList<>();\n\n    IntsRef forms = dictionary.lookupWord(strippedWord, 0, length);\n    if (forms != null) {\n      for (int i = 0; i < forms.length; i++) {\n        dictionary.flagLookup.get(forms.ints[forms.offset+i], scratch);\n        char wordFlags[] = Dictionary.decodeFlags(scratch);\n        if (Dictionary.hasFlag(wordFlags, flag)) {\n          // confusing: in this one exception, we already chained the first prefix against the second,\n          // so it doesnt need to be checked against the word\n          boolean chainedPrefix = dictionary.complexPrefixes && recursionDepth == 1 && prefix;\n          if (chainedPrefix == false && prefixFlag >= 0 && !Dictionary.hasFlag(wordFlags, (char)prefixFlag)) {\n            // see if we can chain prefix thru the suffix continuation class (only if it has any!)\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            if (!hasCrossCheckedFlag((char)prefixFlag, appendFlags, false)) {\n              continue;\n            }\n          }\n          \n          // if circumfix was previously set by a prefix, we must check this suffix,\n          // to ensure it has it, and vice versa\n          if (dictionary.circumfix != -1) {\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            boolean suffixCircumfix = Dictionary.hasFlag(appendFlags, (char)dictionary.circumfix);\n            if (circumfix != suffixCircumfix) {\n              continue;\n            }\n          }\n          stems.add(newStem(strippedWord, length));\n        }\n      }\n    }\n    \n    // if a circumfix flag is defined in the dictionary, and we are a prefix, we need to check if we have that flag\n    if (dictionary.circumfix != -1 && !circumfix && prefix) {\n      dictionary.flagLookup.get(append, scratch);\n      char appendFlags[] = Dictionary.decodeFlags(scratch);\n      circumfix = Dictionary.hasFlag(appendFlags, (char)dictionary.circumfix);\n    }\n\n    if (crossProduct) {\n      if (recursionDepth == 0) {\n        if (prefix) {\n          // we took away the first prefix.\n          // COMPLEXPREFIXES = true:  combine with a second prefix and another suffix \n          // COMPLEXPREFIXES = false: combine with a suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, flag, ++recursionDepth, dictionary.complexPrefixes && dictionary.twoStageAffix, true, true, circumfix));\n        } else if (dictionary.complexPrefixes == false && dictionary.twoStageAffix) {\n          // we took away a suffix.\n          // COMPLEXPREFIXES = true: we don't recurse! only one suffix allowed\n          // COMPLEXPREFIXES = false: combine with another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, prefixFlag, ++recursionDepth, false, true, false, circumfix));\n        }\n      } else if (recursionDepth == 1) {\n        if (prefix && dictionary.complexPrefixes) {\n          // we took away the second prefix: go look for another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, flag, ++recursionDepth, false, true, true, circumfix));\n        } else if (prefix == false && dictionary.complexPrefixes == false && dictionary.twoStageAffix) {\n          // we took away a prefix, then a suffix: go look for another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, prefixFlag, ++recursionDepth, false, true, false, circumfix));\n        }\n      }\n    }\n\n    return stems;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"422da43e6414338103dfc37b7c8c68dcbe309d87","date":1405540909,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#applyAffix(char[],int,int,int,int,boolean,boolean,boolean).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Stemmer#applyAffix(char[],int,int,int,int,boolean,boolean).mjava","sourceNew":"  /**\n   * Applies the affix rule to the given word, producing a list of stems if any are found\n   *\n   * @param strippedWord Word the affix has been removed and the strip added\n   * @param length valid length of stripped word\n   * @param affix HunspellAffix representing the affix rule itself\n   * @param prefixFlag when we already stripped a prefix, we cant simply recurse and check the suffix, unless both are compatible\n   *                   so we must check dictionary form against both to add it as a stem!\n   * @param recursionDepth current recursion depth\n   * @param prefix true if we are removing a prefix (false if its a suffix)\n   * @return List of stems for the word, or an empty list if none are found\n   */\n  List<CharsRef> applyAffix(char strippedWord[], int length, int affix, int prefixFlag, int recursionDepth, boolean prefix, boolean circumfix, boolean caseVariant) throws IOException {    \n    // TODO: just pass this in from before, no need to decode it twice\n    affixReader.setPosition(8 * affix);\n    char flag = (char) (affixReader.readShort() & 0xffff);\n    affixReader.skipBytes(2); // strip\n    int condition = (char) (affixReader.readShort() & 0xffff);\n    boolean crossProduct = (condition & 1) == 1;\n    condition >>>= 1;\n    char append = (char) (affixReader.readShort() & 0xffff);\n\n    List<CharsRef> stems = new ArrayList<>();\n\n    IntsRef forms = dictionary.lookupWord(strippedWord, 0, length);\n    if (forms != null) {\n      for (int i = 0; i < forms.length; i += formStep) {\n        dictionary.flagLookup.get(forms.ints[forms.offset+i], scratch);\n        char wordFlags[] = Dictionary.decodeFlags(scratch);\n        if (Dictionary.hasFlag(wordFlags, flag)) {\n          // confusing: in this one exception, we already chained the first prefix against the second,\n          // so it doesnt need to be checked against the word\n          boolean chainedPrefix = dictionary.complexPrefixes && recursionDepth == 1 && prefix;\n          if (chainedPrefix == false && prefixFlag >= 0 && !Dictionary.hasFlag(wordFlags, (char)prefixFlag)) {\n            // see if we can chain prefix thru the suffix continuation class (only if it has any!)\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            if (!hasCrossCheckedFlag((char)prefixFlag, appendFlags, false)) {\n              continue;\n            }\n          }\n          \n          // if circumfix was previously set by a prefix, we must check this suffix,\n          // to ensure it has it, and vice versa\n          if (dictionary.circumfix != -1) {\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            boolean suffixCircumfix = Dictionary.hasFlag(appendFlags, (char)dictionary.circumfix);\n            if (circumfix != suffixCircumfix) {\n              continue;\n            }\n          }\n          \n          // we are looking for a case variant, but this word does not allow it\n          if (caseVariant && dictionary.keepcase != -1 && Dictionary.hasFlag(wordFlags, (char)dictionary.keepcase)) {\n            continue;\n          }\n          // we aren't decompounding (yet)\n          if (dictionary.onlyincompound != -1 && Dictionary.hasFlag(wordFlags, (char)dictionary.onlyincompound)) {\n            continue;\n          }\n          stems.add(newStem(strippedWord, length, forms, i));\n        }\n      }\n    }\n    \n    // if a circumfix flag is defined in the dictionary, and we are a prefix, we need to check if we have that flag\n    if (dictionary.circumfix != -1 && !circumfix && prefix) {\n      dictionary.flagLookup.get(append, scratch);\n      char appendFlags[] = Dictionary.decodeFlags(scratch);\n      circumfix = Dictionary.hasFlag(appendFlags, (char)dictionary.circumfix);\n    }\n\n    if (crossProduct) {\n      if (recursionDepth == 0) {\n        if (prefix) {\n          // we took away the first prefix.\n          // COMPLEXPREFIXES = true:  combine with a second prefix and another suffix \n          // COMPLEXPREFIXES = false: combine with a suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, flag, ++recursionDepth, dictionary.complexPrefixes && dictionary.twoStageAffix, true, true, circumfix, caseVariant));\n        } else if (dictionary.complexPrefixes == false && dictionary.twoStageAffix) {\n          // we took away a suffix.\n          // COMPLEXPREFIXES = true: we don't recurse! only one suffix allowed\n          // COMPLEXPREFIXES = false: combine with another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, prefixFlag, ++recursionDepth, false, true, false, circumfix, caseVariant));\n        }\n      } else if (recursionDepth == 1) {\n        if (prefix && dictionary.complexPrefixes) {\n          // we took away the second prefix: go look for another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, flag, ++recursionDepth, false, true, true, circumfix, caseVariant));\n        } else if (prefix == false && dictionary.complexPrefixes == false && dictionary.twoStageAffix) {\n          // we took away a prefix, then a suffix: go look for another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, prefixFlag, ++recursionDepth, false, true, false, circumfix, caseVariant));\n        }\n      }\n    }\n\n    return stems;\n  }\n\n","sourceOld":"  /**\n   * Applies the affix rule to the given word, producing a list of stems if any are found\n   *\n   * @param strippedWord Word the affix has been removed and the strip added\n   * @param length valid length of stripped word\n   * @param affix HunspellAffix representing the affix rule itself\n   * @param prefixFlag when we already stripped a prefix, we cant simply recurse and check the suffix, unless both are compatible\n   *                   so we must check dictionary form against both to add it as a stem!\n   * @param recursionDepth current recursion depth\n   * @param prefix true if we are removing a prefix (false if its a suffix)\n   * @return List of stems for the word, or an empty list if none are found\n   */\n  List<CharsRef> applyAffix(char strippedWord[], int length, int affix, int prefixFlag, int recursionDepth, boolean prefix, boolean circumfix) throws IOException {    \n    // TODO: just pass this in from before, no need to decode it twice\n    affixReader.setPosition(8 * affix);\n    char flag = (char) (affixReader.readShort() & 0xffff);\n    affixReader.skipBytes(2); // strip\n    int condition = (char) (affixReader.readShort() & 0xffff);\n    boolean crossProduct = (condition & 1) == 1;\n    condition >>>= 1;\n    char append = (char) (affixReader.readShort() & 0xffff);\n\n    List<CharsRef> stems = new ArrayList<>();\n\n    IntsRef forms = dictionary.lookupWord(strippedWord, 0, length);\n    if (forms != null) {\n      for (int i = 0; i < forms.length; i += formStep) {\n        dictionary.flagLookup.get(forms.ints[forms.offset+i], scratch);\n        char wordFlags[] = Dictionary.decodeFlags(scratch);\n        if (Dictionary.hasFlag(wordFlags, flag)) {\n          // confusing: in this one exception, we already chained the first prefix against the second,\n          // so it doesnt need to be checked against the word\n          boolean chainedPrefix = dictionary.complexPrefixes && recursionDepth == 1 && prefix;\n          if (chainedPrefix == false && prefixFlag >= 0 && !Dictionary.hasFlag(wordFlags, (char)prefixFlag)) {\n            // see if we can chain prefix thru the suffix continuation class (only if it has any!)\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            if (!hasCrossCheckedFlag((char)prefixFlag, appendFlags, false)) {\n              continue;\n            }\n          }\n          \n          // if circumfix was previously set by a prefix, we must check this suffix,\n          // to ensure it has it, and vice versa\n          if (dictionary.circumfix != -1) {\n            dictionary.flagLookup.get(append, scratch);\n            char appendFlags[] = Dictionary.decodeFlags(scratch);\n            boolean suffixCircumfix = Dictionary.hasFlag(appendFlags, (char)dictionary.circumfix);\n            if (circumfix != suffixCircumfix) {\n              continue;\n            }\n          }\n          stems.add(newStem(strippedWord, length, forms, i));\n        }\n      }\n    }\n    \n    // if a circumfix flag is defined in the dictionary, and we are a prefix, we need to check if we have that flag\n    if (dictionary.circumfix != -1 && !circumfix && prefix) {\n      dictionary.flagLookup.get(append, scratch);\n      char appendFlags[] = Dictionary.decodeFlags(scratch);\n      circumfix = Dictionary.hasFlag(appendFlags, (char)dictionary.circumfix);\n    }\n\n    if (crossProduct) {\n      if (recursionDepth == 0) {\n        if (prefix) {\n          // we took away the first prefix.\n          // COMPLEXPREFIXES = true:  combine with a second prefix and another suffix \n          // COMPLEXPREFIXES = false: combine with a suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, flag, ++recursionDepth, dictionary.complexPrefixes && dictionary.twoStageAffix, true, true, circumfix));\n        } else if (dictionary.complexPrefixes == false && dictionary.twoStageAffix) {\n          // we took away a suffix.\n          // COMPLEXPREFIXES = true: we don't recurse! only one suffix allowed\n          // COMPLEXPREFIXES = false: combine with another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, prefixFlag, ++recursionDepth, false, true, false, circumfix));\n        }\n      } else if (recursionDepth == 1) {\n        if (prefix && dictionary.complexPrefixes) {\n          // we took away the second prefix: go look for another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, flag, ++recursionDepth, false, true, true, circumfix));\n        } else if (prefix == false && dictionary.complexPrefixes == false && dictionary.twoStageAffix) {\n          // we took away a prefix, then a suffix: go look for another suffix\n          stems.addAll(stem(strippedWord, length, affix, flag, prefixFlag, ++recursionDepth, false, true, false, circumfix));\n        }\n      }\n    }\n\n    return stems;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["09fb4238d56f62faff1f0c866bee53facad482ec"],"38e7d0aeceab994177a0a6b52f475611b52f09bf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"96ea64d994d340044e0d57aeb6a5871539d10ca5":["38e7d0aeceab994177a0a6b52f475611b52f09bf","5ae9942cbee38a49d234c2f022e3a265133d1914"],"5916de6e2f6deb9da923b2710f6451668e94a20c":["23ccc3a9bdacbdab4dbedf7c926b76298d8bd1db"],"5ae9942cbee38a49d234c2f022e3a265133d1914":["38e7d0aeceab994177a0a6b52f475611b52f09bf"],"23ccc3a9bdacbdab4dbedf7c926b76298d8bd1db":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"09fb4238d56f62faff1f0c866bee53facad482ec":["5ae9942cbee38a49d234c2f022e3a265133d1914"],"422da43e6414338103dfc37b7c8c68dcbe309d87":["5916de6e2f6deb9da923b2710f6451668e94a20c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["422da43e6414338103dfc37b7c8c68dcbe309d87"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["23ccc3a9bdacbdab4dbedf7c926b76298d8bd1db"],"38e7d0aeceab994177a0a6b52f475611b52f09bf":["96ea64d994d340044e0d57aeb6a5871539d10ca5","5ae9942cbee38a49d234c2f022e3a265133d1914"],"96ea64d994d340044e0d57aeb6a5871539d10ca5":[],"5916de6e2f6deb9da923b2710f6451668e94a20c":["422da43e6414338103dfc37b7c8c68dcbe309d87"],"5ae9942cbee38a49d234c2f022e3a265133d1914":["96ea64d994d340044e0d57aeb6a5871539d10ca5","09fb4238d56f62faff1f0c866bee53facad482ec"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["38e7d0aeceab994177a0a6b52f475611b52f09bf"],"23ccc3a9bdacbdab4dbedf7c926b76298d8bd1db":["5916de6e2f6deb9da923b2710f6451668e94a20c"],"09fb4238d56f62faff1f0c866bee53facad482ec":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"422da43e6414338103dfc37b7c8c68dcbe309d87":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["96ea64d994d340044e0d57aeb6a5871539d10ca5","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}