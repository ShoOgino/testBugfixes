{"path":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seek(BytesRef,boolean).mjava","commits":[{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seek(BytesRef,boolean).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public SeekStatus seek(BytesRef term, boolean useCache) throws IOException {\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = new Term(fieldInfo.name, term.utf8ToString());\n      if (termEnum == null) {\n        termEnum = tis.terms(t0);\n      } else {\n        tis.seekEnum(termEnum, t0);\n      }\n      final Term t = termEnum.term();\n\n      final BytesRef tr;\n      if (t != null) {\n        tr = scratchBytesRef;\n        scratchBytesRef.copy(t.text());\n      } else {\n        tr = null;\n      }\n\n      if (t != null && t.field() == fieldInfo.name && term.bytesEquals(tr)) {\n        current = tr;\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != fieldInfo.name) {\n        current = null;\n        return SeekStatus.END;\n      } else {\n        current = tr;\n        return SeekStatus.NOT_FOUND;\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"08932c793647a36953d1816b1060121f48820d3f","date":1277386540,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seek(BytesRef,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seek(BytesRef,boolean).mjava","sourceNew":"    @Override\n    public SeekStatus seek(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek() term=\" + term.utf8ToString());\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = protoTerm.createTerm(term.utf8ToString());\n\n      assert termEnum != null;\n\n      if (termEnum == null) {\n        termEnum = tis.terms(t0);\n      } else {\n        tis.seekEnum(termEnum, t0);\n      }\n\n      surrogateSeekUpto = 0;\n      surrogatesDance();\n\n      final Term t = termEnum.term();\n\n      final BytesRef tr;\n      if (t != null) {\n        tr = scratchBytesRef;\n        scratchBytesRef.copy(t.text());\n      } else {\n        tr = null;\n      }\n\n      if (t != null && t.field() == fieldInfo.name && term.bytesEquals(tr)) {\n        current = tr;\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != fieldInfo.name) {\n        current = null;\n        return SeekStatus.END;\n      } else {\n        current = tr;\n        return SeekStatus.NOT_FOUND;\n      }\n    }\n\n","sourceOld":"    @Override\n    public SeekStatus seek(BytesRef term, boolean useCache) throws IOException {\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = new Term(fieldInfo.name, term.utf8ToString());\n      if (termEnum == null) {\n        termEnum = tis.terms(t0);\n      } else {\n        tis.seekEnum(termEnum, t0);\n      }\n      final Term t = termEnum.term();\n\n      final BytesRef tr;\n      if (t != null) {\n        tr = scratchBytesRef;\n        scratchBytesRef.copy(t.text());\n      } else {\n        tr = null;\n      }\n\n      if (t != null && t.field() == fieldInfo.name && term.bytesEquals(tr)) {\n        current = tr;\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != fieldInfo.name) {\n        current = null;\n        return SeekStatus.END;\n      } else {\n        current = tr;\n        return SeekStatus.NOT_FOUND;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4f29ba80b723649f5feb7e37afe1a558dd2c1304","date":1278318805,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seek(BytesRef,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seek(BytesRef,boolean).mjava","sourceNew":"    @Override\n    public SeekStatus seek(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek() term=\" + term.utf8ToString());\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = protoTerm.createTerm(term);\n\n      assert termEnum != null;\n\n      if (termEnum == null) {\n        termEnum = tis.terms(t0);\n      } else {\n        tis.seekEnum(termEnum, t0);\n      }\n\n      surrogateSeekUpto = 0;\n      surrogatesDance();\n\n      final Term t = termEnum.term();\n\n      final BytesRef tr = t == null ? null : t.bytes();\n\n      if (t != null && t.field() == fieldInfo.name && term.bytesEquals(tr)) {\n        current = tr;\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != fieldInfo.name) {\n        current = null;\n        return SeekStatus.END;\n      } else {\n        current = tr;\n        return SeekStatus.NOT_FOUND;\n      }\n    }\n\n","sourceOld":"    @Override\n    public SeekStatus seek(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek() term=\" + term.utf8ToString());\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = protoTerm.createTerm(term.utf8ToString());\n\n      assert termEnum != null;\n\n      if (termEnum == null) {\n        termEnum = tis.terms(t0);\n      } else {\n        tis.seekEnum(termEnum, t0);\n      }\n\n      surrogateSeekUpto = 0;\n      surrogatesDance();\n\n      final Term t = termEnum.term();\n\n      final BytesRef tr;\n      if (t != null) {\n        tr = scratchBytesRef;\n        scratchBytesRef.copy(t.text());\n      } else {\n        tr = null;\n      }\n\n      if (t != null && t.field() == fieldInfo.name && term.bytesEquals(tr)) {\n        current = tr;\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != fieldInfo.name) {\n        current = null;\n        return SeekStatus.END;\n      } else {\n        current = tr;\n        return SeekStatus.NOT_FOUND;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seek(BytesRef,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seek(BytesRef,boolean).mjava","sourceNew":"    @Override\n    public SeekStatus seek(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek() term=\" + term.utf8ToString());\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = protoTerm.createTerm(term);\n\n      assert termEnum != null;\n\n      if (termEnum == null) {\n        termEnum = tis.terms(t0);\n      } else {\n        tis.seekEnum(termEnum, t0);\n      }\n\n      surrogateSeekUpto = 0;\n      surrogatesDance();\n\n      final Term t = termEnum.term();\n\n      final BytesRef tr = t == null ? null : t.bytes();\n\n      if (t != null && t.field() == fieldInfo.name && term.bytesEquals(tr)) {\n        current = tr;\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != fieldInfo.name) {\n        current = null;\n        return SeekStatus.END;\n      } else {\n        current = tr;\n        return SeekStatus.NOT_FOUND;\n      }\n    }\n\n","sourceOld":"    @Override\n    public SeekStatus seek(BytesRef term, boolean useCache) throws IOException {\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = new Term(fieldInfo.name, term.utf8ToString());\n      if (termEnum == null) {\n        termEnum = tis.terms(t0);\n      } else {\n        tis.seekEnum(termEnum, t0);\n      }\n      final Term t = termEnum.term();\n\n      final BytesRef tr;\n      if (t != null) {\n        tr = scratchBytesRef;\n        scratchBytesRef.copy(t.text());\n      } else {\n        tr = null;\n      }\n\n      if (t != null && t.field() == fieldInfo.name && term.bytesEquals(tr)) {\n        current = tr;\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != fieldInfo.name) {\n        current = null;\n        return SeekStatus.END;\n      } else {\n        current = tr;\n        return SeekStatus.NOT_FOUND;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"163fe85a71d778fd2b7747f65ca27b54829e2e57","date":1279898785,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seek(BytesRef,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seek(BytesRef,boolean).mjava","sourceNew":"    @Override\n    public SeekStatus seek(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek target=\" + UnicodeUtil.toHexString(term.utf8ToString()));\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = protoTerm.createTerm(term);\n\n      assert termEnum != null;\n\n      tis.seekEnum(termEnum, t0);\n\n      final Term t = termEnum.term();\n\n      if (t != null && t.field() == fieldInfo.name && term.bytesEquals(t.bytes())) {\n        // If we found an exact match, no need to do the\n        // surrogate dance\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek exact match\");\n        }\n        current = t.bytes();\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != fieldInfo.name) {\n\n        // nocommit -- why can't we handle this like the\n        // next() into null?  set term as prevTerm then dance?\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit EOF\");\n        }\n\n        // We hit EOF; try end-case surrogate dance: if we\n        // find an E, try swapping in S, backwards:\n        scratchTerm.copy(term);\n\n        assert scratchTerm.offset == 0;\n\n        for(int i=scratchTerm.length-1;i>=0;i--) {\n          if (isHighBMPChar(scratchTerm.bytes, i)) {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"    found E pos=\" + i + \"; try seek\");\n            }\n\n            if (seekToNonBMP(seekTermEnum, scratchTerm, i)) {\n\n              scratchTerm.copy(seekTermEnum.term().bytes());\n              getTermsDict().seekEnum(termEnum, seekTermEnum.term());\n\n              newSuffixStart = 1+i;\n\n              doPushes();\n\n              // Found a match\n              // TODO: faster seek?\n              current = termEnum.term().bytes();\n              return SeekStatus.NOT_FOUND;\n            }\n          }\n        }\n        \n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek END\");\n        }\n\n        current = null;\n        return SeekStatus.END;\n      } else {\n\n        // We found a non-exact but non-null term; this one\n        // is fun -- just treat it like next, by pretending\n        // requested term was prev:\n        prevTerm.copy(term);\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit non-exact term=\" + UnicodeUtil.toHexString(t.text()));\n        }\n\n        final BytesRef br = t.bytes();\n        assert br.offset == 0;\n\n        setNewSuffixStart(term, br);\n\n        surrogateDance();\n\n        final Term t2 = termEnum.term();\n        if (t2 == null || t2.field() != fieldInfo.name) {\n          assert t2 == null || !t2.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          current = null;\n          return SeekStatus.END;\n        } else {\n          current = t2.bytes();\n          assert !unicodeSortOrder || term.compareTo(current) < 0 : \"term=\" + UnicodeUtil.toHexString(term.utf8ToString()) + \" vs current=\" + UnicodeUtil.toHexString(current.utf8ToString());\n          return SeekStatus.NOT_FOUND;\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public SeekStatus seek(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek() term=\" + term.utf8ToString());\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = protoTerm.createTerm(term);\n\n      assert termEnum != null;\n\n      if (termEnum == null) {\n        termEnum = tis.terms(t0);\n      } else {\n        tis.seekEnum(termEnum, t0);\n      }\n\n      surrogateSeekUpto = 0;\n      surrogatesDance();\n\n      final Term t = termEnum.term();\n\n      final BytesRef tr = t == null ? null : t.bytes();\n\n      if (t != null && t.field() == fieldInfo.name && term.bytesEquals(tr)) {\n        current = tr;\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != fieldInfo.name) {\n        current = null;\n        return SeekStatus.END;\n      } else {\n        current = tr;\n        return SeekStatus.NOT_FOUND;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9f6bb0c3d7b1c1dd8aeab43a34a89f050069e97","date":1280158618,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seek(BytesRef,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seek(BytesRef,boolean).mjava","sourceNew":"    @Override\n    public SeekStatus seek(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek target=\" + UnicodeUtil.toHexString(term.utf8ToString()));\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = protoTerm.createTerm(term);\n\n      assert termEnum != null;\n\n      tis.seekEnum(termEnum, t0);\n\n      final Term t = termEnum.term();\n\n      if (t != null && t.field() == fieldInfo.name && term.bytesEquals(t.bytes())) {\n        // If we found an exact match, no need to do the\n        // surrogate dance\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek exact match\");\n        }\n        current = t.bytes();\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != fieldInfo.name) {\n\n        // TODO: maybe we can handle this like the next()\n        // into null?  set term as prevTerm then dance?\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit EOF\");\n        }\n\n        // We hit EOF; try end-case surrogate dance: if we\n        // find an E, try swapping in S, backwards:\n        scratchTerm.copy(term);\n\n        assert scratchTerm.offset == 0;\n\n        for(int i=scratchTerm.length-1;i>=0;i--) {\n          if (isHighBMPChar(scratchTerm.bytes, i)) {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"    found E pos=\" + i + \"; try seek\");\n            }\n\n            if (seekToNonBMP(seekTermEnum, scratchTerm, i)) {\n\n              scratchTerm.copy(seekTermEnum.term().bytes());\n              getTermsDict().seekEnum(termEnum, seekTermEnum.term());\n\n              newSuffixStart = 1+i;\n\n              doPushes();\n\n              // Found a match\n              // TODO: faster seek?\n              current = termEnum.term().bytes();\n              return SeekStatus.NOT_FOUND;\n            }\n          }\n        }\n        \n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek END\");\n        }\n\n        current = null;\n        return SeekStatus.END;\n      } else {\n\n        // We found a non-exact but non-null term; this one\n        // is fun -- just treat it like next, by pretending\n        // requested term was prev:\n        prevTerm.copy(term);\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit non-exact term=\" + UnicodeUtil.toHexString(t.text()));\n        }\n\n        final BytesRef br = t.bytes();\n        assert br.offset == 0;\n\n        setNewSuffixStart(term, br);\n\n        surrogateDance();\n\n        final Term t2 = termEnum.term();\n        if (t2 == null || t2.field() != fieldInfo.name) {\n          assert t2 == null || !t2.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          current = null;\n          return SeekStatus.END;\n        } else {\n          current = t2.bytes();\n          assert !unicodeSortOrder || term.compareTo(current) < 0 : \"term=\" + UnicodeUtil.toHexString(term.utf8ToString()) + \" vs current=\" + UnicodeUtil.toHexString(current.utf8ToString());\n          return SeekStatus.NOT_FOUND;\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public SeekStatus seek(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek target=\" + UnicodeUtil.toHexString(term.utf8ToString()));\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = protoTerm.createTerm(term);\n\n      assert termEnum != null;\n\n      tis.seekEnum(termEnum, t0);\n\n      final Term t = termEnum.term();\n\n      if (t != null && t.field() == fieldInfo.name && term.bytesEquals(t.bytes())) {\n        // If we found an exact match, no need to do the\n        // surrogate dance\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek exact match\");\n        }\n        current = t.bytes();\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != fieldInfo.name) {\n\n        // nocommit -- why can't we handle this like the\n        // next() into null?  set term as prevTerm then dance?\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit EOF\");\n        }\n\n        // We hit EOF; try end-case surrogate dance: if we\n        // find an E, try swapping in S, backwards:\n        scratchTerm.copy(term);\n\n        assert scratchTerm.offset == 0;\n\n        for(int i=scratchTerm.length-1;i>=0;i--) {\n          if (isHighBMPChar(scratchTerm.bytes, i)) {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"    found E pos=\" + i + \"; try seek\");\n            }\n\n            if (seekToNonBMP(seekTermEnum, scratchTerm, i)) {\n\n              scratchTerm.copy(seekTermEnum.term().bytes());\n              getTermsDict().seekEnum(termEnum, seekTermEnum.term());\n\n              newSuffixStart = 1+i;\n\n              doPushes();\n\n              // Found a match\n              // TODO: faster seek?\n              current = termEnum.term().bytes();\n              return SeekStatus.NOT_FOUND;\n            }\n          }\n        }\n        \n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek END\");\n        }\n\n        current = null;\n        return SeekStatus.END;\n      } else {\n\n        // We found a non-exact but non-null term; this one\n        // is fun -- just treat it like next, by pretending\n        // requested term was prev:\n        prevTerm.copy(term);\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit non-exact term=\" + UnicodeUtil.toHexString(t.text()));\n        }\n\n        final BytesRef br = t.bytes();\n        assert br.offset == 0;\n\n        setNewSuffixStart(term, br);\n\n        surrogateDance();\n\n        final Term t2 = termEnum.term();\n        if (t2 == null || t2.field() != fieldInfo.name) {\n          assert t2 == null || !t2.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          current = null;\n          return SeekStatus.END;\n        } else {\n          current = t2.bytes();\n          assert !unicodeSortOrder || term.compareTo(current) < 0 : \"term=\" + UnicodeUtil.toHexString(term.utf8ToString()) + \" vs current=\" + UnicodeUtil.toHexString(current.utf8ToString());\n          return SeekStatus.NOT_FOUND;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b103252dee6afa1b6d7a622c773d178788eb85a","date":1280180143,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seek(BytesRef,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seek(BytesRef,boolean).mjava","sourceNew":"    @Override\n    public SeekStatus seek(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek target=\" + UnicodeUtil.toHexString(term.utf8ToString()));\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = protoTerm.createTerm(term);\n\n      assert termEnum != null;\n\n      tis.seekEnum(termEnum, t0);\n\n      final Term t = termEnum.term();\n\n      if (t != null && t.field() == fieldInfo.name && term.bytesEquals(t.bytes())) {\n        // If we found an exact match, no need to do the\n        // surrogate dance\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek exact match\");\n        }\n        current = t.bytes();\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != fieldInfo.name) {\n\n        // TODO: maybe we can handle this like the next()\n        // into null?  set term as prevTerm then dance?\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit EOF\");\n        }\n\n        // We hit EOF; try end-case surrogate dance: if we\n        // find an E, try swapping in S, backwards:\n        scratchTerm.copy(term);\n\n        assert scratchTerm.offset == 0;\n\n        for(int i=scratchTerm.length-1;i>=0;i--) {\n          if (isHighBMPChar(scratchTerm.bytes, i)) {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"    found E pos=\" + i + \"; try seek\");\n            }\n\n            if (seekToNonBMP(seekTermEnum, scratchTerm, i)) {\n\n              scratchTerm.copy(seekTermEnum.term().bytes());\n              getTermsDict().seekEnum(termEnum, seekTermEnum.term());\n\n              newSuffixStart = 1+i;\n\n              doPushes();\n\n              // Found a match\n              // TODO: faster seek?\n              current = termEnum.term().bytes();\n              return SeekStatus.NOT_FOUND;\n            }\n          }\n        }\n        \n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek END\");\n        }\n\n        current = null;\n        return SeekStatus.END;\n      } else {\n\n        // We found a non-exact but non-null term; this one\n        // is fun -- just treat it like next, by pretending\n        // requested term was prev:\n        prevTerm.copy(term);\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit non-exact term=\" + UnicodeUtil.toHexString(t.text()));\n        }\n\n        final BytesRef br = t.bytes();\n        assert br.offset == 0;\n\n        setNewSuffixStart(term, br);\n\n        surrogateDance();\n\n        final Term t2 = termEnum.term();\n        if (t2 == null || t2.field() != fieldInfo.name) {\n          assert t2 == null || !t2.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          current = null;\n          return SeekStatus.END;\n        } else {\n          current = t2.bytes();\n          assert !unicodeSortOrder || term.compareTo(current) < 0 : \"term=\" + UnicodeUtil.toHexString(term.utf8ToString()) + \" vs current=\" + UnicodeUtil.toHexString(current.utf8ToString());\n          return SeekStatus.NOT_FOUND;\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public SeekStatus seek(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek() term=\" + term.utf8ToString());\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = protoTerm.createTerm(term);\n\n      assert termEnum != null;\n\n      if (termEnum == null) {\n        termEnum = tis.terms(t0);\n      } else {\n        tis.seekEnum(termEnum, t0);\n      }\n\n      surrogateSeekUpto = 0;\n      surrogatesDance();\n\n      final Term t = termEnum.term();\n\n      final BytesRef tr = t == null ? null : t.bytes();\n\n      if (t != null && t.field() == fieldInfo.name && term.bytesEquals(tr)) {\n        current = tr;\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != fieldInfo.name) {\n        current = null;\n        return SeekStatus.END;\n      } else {\n        current = tr;\n        return SeekStatus.NOT_FOUND;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3242a09f703274d3b9283f2064a1a33064b53a1b","date":1280263474,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seek(BytesRef,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seek(BytesRef,boolean).mjava","sourceNew":"    @Override\n    public SeekStatus seek(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek target=\" + UnicodeUtil.toHexString(term.utf8ToString()));\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = protoTerm.createTerm(term);\n\n      assert termEnum != null;\n\n      tis.seekEnum(termEnum, t0);\n\n      final Term t = termEnum.term();\n\n      if (t != null && t.field() == fieldInfo.name && term.bytesEquals(t.bytes())) {\n        // If we found an exact match, no need to do the\n        // surrogate dance\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek exact match\");\n        }\n        current = t.bytes();\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != fieldInfo.name) {\n\n        // TODO: maybe we can handle this like the next()\n        // into null?  set term as prevTerm then dance?\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit EOF\");\n        }\n\n        // We hit EOF; try end-case surrogate dance: if we\n        // find an E, try swapping in S, backwards:\n        scratchTerm.copy(term);\n\n        assert scratchTerm.offset == 0;\n\n        for(int i=scratchTerm.length-1;i>=0;i--) {\n          if (isHighBMPChar(scratchTerm.bytes, i)) {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"    found E pos=\" + i + \"; try seek\");\n            }\n\n            if (seekToNonBMP(seekTermEnum, scratchTerm, i)) {\n\n              scratchTerm.copy(seekTermEnum.term().bytes());\n              getTermsDict().seekEnum(termEnum, seekTermEnum.term());\n\n              newSuffixStart = 1+i;\n\n              doPushes();\n\n              // Found a match\n              // TODO: faster seek?\n              current = termEnum.term().bytes();\n              return SeekStatus.NOT_FOUND;\n            }\n          }\n        }\n        \n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek END\");\n        }\n\n        current = null;\n        return SeekStatus.END;\n      } else {\n\n        // We found a non-exact but non-null term; this one\n        // is fun -- just treat it like next, by pretending\n        // requested term was prev:\n        prevTerm.copy(term);\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit non-exact term=\" + UnicodeUtil.toHexString(t.text()));\n        }\n\n        final BytesRef br = t.bytes();\n        assert br.offset == 0;\n\n        setNewSuffixStart(term, br);\n\n        surrogateDance();\n\n        final Term t2 = termEnum.term();\n        if (t2 == null || t2.field() != fieldInfo.name) {\n          assert t2 == null || !t2.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          current = null;\n          return SeekStatus.END;\n        } else {\n          current = t2.bytes();\n          assert !unicodeSortOrder || term.compareTo(current) < 0 : \"term=\" + UnicodeUtil.toHexString(term.utf8ToString()) + \" vs current=\" + UnicodeUtil.toHexString(current.utf8ToString());\n          return SeekStatus.NOT_FOUND;\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public SeekStatus seek(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek() term=\" + term.utf8ToString());\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = protoTerm.createTerm(term);\n\n      assert termEnum != null;\n\n      if (termEnum == null) {\n        termEnum = tis.terms(t0);\n      } else {\n        tis.seekEnum(termEnum, t0);\n      }\n\n      surrogateSeekUpto = 0;\n      surrogatesDance();\n\n      final Term t = termEnum.term();\n\n      final BytesRef tr = t == null ? null : t.bytes();\n\n      if (t != null && t.field() == fieldInfo.name && term.bytesEquals(tr)) {\n        current = tr;\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != fieldInfo.name) {\n        current = null;\n        return SeekStatus.END;\n      } else {\n        current = tr;\n        return SeekStatus.NOT_FOUND;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"825bcb488bc228d1fb6a19c1f441a2181f7d766d","date":1285691504,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seek(BytesRef,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seek(BytesRef,boolean).mjava","sourceNew":"    @Override\n    public SeekStatus seek(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek target=\" + UnicodeUtil.toHexString(term.utf8ToString()));\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = protoTerm.createTerm(term);\n\n      assert termEnum != null;\n\n      tis.seekEnum(termEnum, t0, useCache);\n\n      final Term t = termEnum.term();\n\n      if (t != null && t.field() == fieldInfo.name && term.bytesEquals(t.bytes())) {\n        // If we found an exact match, no need to do the\n        // surrogate dance\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek exact match\");\n        }\n        current = t.bytes();\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != fieldInfo.name) {\n\n        // TODO: maybe we can handle this like the next()\n        // into null?  set term as prevTerm then dance?\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit EOF\");\n        }\n\n        // We hit EOF; try end-case surrogate dance: if we\n        // find an E, try swapping in S, backwards:\n        scratchTerm.copy(term);\n\n        assert scratchTerm.offset == 0;\n\n        for(int i=scratchTerm.length-1;i>=0;i--) {\n          if (isHighBMPChar(scratchTerm.bytes, i)) {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"    found E pos=\" + i + \"; try seek\");\n            }\n\n            if (seekToNonBMP(seekTermEnum, scratchTerm, i)) {\n\n              scratchTerm.copy(seekTermEnum.term().bytes());\n              getTermsDict().seekEnum(termEnum, seekTermEnum.term(), useCache);\n\n              newSuffixStart = 1+i;\n\n              doPushes();\n\n              // Found a match\n              // TODO: faster seek?\n              current = termEnum.term().bytes();\n              return SeekStatus.NOT_FOUND;\n            }\n          }\n        }\n        \n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek END\");\n        }\n\n        current = null;\n        return SeekStatus.END;\n      } else {\n\n        // We found a non-exact but non-null term; this one\n        // is fun -- just treat it like next, by pretending\n        // requested term was prev:\n        prevTerm.copy(term);\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit non-exact term=\" + UnicodeUtil.toHexString(t.text()));\n        }\n\n        final BytesRef br = t.bytes();\n        assert br.offset == 0;\n\n        setNewSuffixStart(term, br);\n\n        surrogateDance();\n\n        final Term t2 = termEnum.term();\n        if (t2 == null || t2.field() != fieldInfo.name) {\n          assert t2 == null || !t2.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          current = null;\n          return SeekStatus.END;\n        } else {\n          current = t2.bytes();\n          assert !unicodeSortOrder || term.compareTo(current) < 0 : \"term=\" + UnicodeUtil.toHexString(term.utf8ToString()) + \" vs current=\" + UnicodeUtil.toHexString(current.utf8ToString());\n          return SeekStatus.NOT_FOUND;\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public SeekStatus seek(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek target=\" + UnicodeUtil.toHexString(term.utf8ToString()));\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = protoTerm.createTerm(term);\n\n      assert termEnum != null;\n\n      tis.seekEnum(termEnum, t0);\n\n      final Term t = termEnum.term();\n\n      if (t != null && t.field() == fieldInfo.name && term.bytesEquals(t.bytes())) {\n        // If we found an exact match, no need to do the\n        // surrogate dance\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek exact match\");\n        }\n        current = t.bytes();\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != fieldInfo.name) {\n\n        // TODO: maybe we can handle this like the next()\n        // into null?  set term as prevTerm then dance?\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit EOF\");\n        }\n\n        // We hit EOF; try end-case surrogate dance: if we\n        // find an E, try swapping in S, backwards:\n        scratchTerm.copy(term);\n\n        assert scratchTerm.offset == 0;\n\n        for(int i=scratchTerm.length-1;i>=0;i--) {\n          if (isHighBMPChar(scratchTerm.bytes, i)) {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"    found E pos=\" + i + \"; try seek\");\n            }\n\n            if (seekToNonBMP(seekTermEnum, scratchTerm, i)) {\n\n              scratchTerm.copy(seekTermEnum.term().bytes());\n              getTermsDict().seekEnum(termEnum, seekTermEnum.term());\n\n              newSuffixStart = 1+i;\n\n              doPushes();\n\n              // Found a match\n              // TODO: faster seek?\n              current = termEnum.term().bytes();\n              return SeekStatus.NOT_FOUND;\n            }\n          }\n        }\n        \n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek END\");\n        }\n\n        current = null;\n        return SeekStatus.END;\n      } else {\n\n        // We found a non-exact but non-null term; this one\n        // is fun -- just treat it like next, by pretending\n        // requested term was prev:\n        prevTerm.copy(term);\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit non-exact term=\" + UnicodeUtil.toHexString(t.text()));\n        }\n\n        final BytesRef br = t.bytes();\n        assert br.offset == 0;\n\n        setNewSuffixStart(term, br);\n\n        surrogateDance();\n\n        final Term t2 = termEnum.term();\n        if (t2 == null || t2.field() != fieldInfo.name) {\n          assert t2 == null || !t2.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          current = null;\n          return SeekStatus.END;\n        } else {\n          current = t2.bytes();\n          assert !unicodeSortOrder || term.compareTo(current) < 0 : \"term=\" + UnicodeUtil.toHexString(term.utf8ToString()) + \" vs current=\" + UnicodeUtil.toHexString(current.utf8ToString());\n          return SeekStatus.NOT_FOUND;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seek(BytesRef,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seek(BytesRef,boolean).mjava","sourceNew":"    @Override\n    public SeekStatus seek(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek target=\" + UnicodeUtil.toHexString(term.utf8ToString()));\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = protoTerm.createTerm(term);\n\n      assert termEnum != null;\n\n      tis.seekEnum(termEnum, t0, useCache);\n\n      final Term t = termEnum.term();\n\n      if (t != null && t.field() == fieldInfo.name && term.bytesEquals(t.bytes())) {\n        // If we found an exact match, no need to do the\n        // surrogate dance\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek exact match\");\n        }\n        current = t.bytes();\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != fieldInfo.name) {\n\n        // TODO: maybe we can handle this like the next()\n        // into null?  set term as prevTerm then dance?\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit EOF\");\n        }\n\n        // We hit EOF; try end-case surrogate dance: if we\n        // find an E, try swapping in S, backwards:\n        scratchTerm.copy(term);\n\n        assert scratchTerm.offset == 0;\n\n        for(int i=scratchTerm.length-1;i>=0;i--) {\n          if (isHighBMPChar(scratchTerm.bytes, i)) {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"    found E pos=\" + i + \"; try seek\");\n            }\n\n            if (seekToNonBMP(seekTermEnum, scratchTerm, i)) {\n\n              scratchTerm.copy(seekTermEnum.term().bytes());\n              getTermsDict().seekEnum(termEnum, seekTermEnum.term(), useCache);\n\n              newSuffixStart = 1+i;\n\n              doPushes();\n\n              // Found a match\n              // TODO: faster seek?\n              current = termEnum.term().bytes();\n              return SeekStatus.NOT_FOUND;\n            }\n          }\n        }\n        \n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek END\");\n        }\n\n        current = null;\n        return SeekStatus.END;\n      } else {\n\n        // We found a non-exact but non-null term; this one\n        // is fun -- just treat it like next, by pretending\n        // requested term was prev:\n        prevTerm.copy(term);\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit non-exact term=\" + UnicodeUtil.toHexString(t.text()));\n        }\n\n        final BytesRef br = t.bytes();\n        assert br.offset == 0;\n\n        setNewSuffixStart(term, br);\n\n        surrogateDance();\n\n        final Term t2 = termEnum.term();\n        if (t2 == null || t2.field() != fieldInfo.name) {\n          assert t2 == null || !t2.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          current = null;\n          return SeekStatus.END;\n        } else {\n          current = t2.bytes();\n          assert !unicodeSortOrder || term.compareTo(current) < 0 : \"term=\" + UnicodeUtil.toHexString(term.utf8ToString()) + \" vs current=\" + UnicodeUtil.toHexString(current.utf8ToString());\n          return SeekStatus.NOT_FOUND;\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public SeekStatus seek(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek target=\" + UnicodeUtil.toHexString(term.utf8ToString()));\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = protoTerm.createTerm(term);\n\n      assert termEnum != null;\n\n      tis.seekEnum(termEnum, t0);\n\n      final Term t = termEnum.term();\n\n      if (t != null && t.field() == fieldInfo.name && term.bytesEquals(t.bytes())) {\n        // If we found an exact match, no need to do the\n        // surrogate dance\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek exact match\");\n        }\n        current = t.bytes();\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != fieldInfo.name) {\n\n        // TODO: maybe we can handle this like the next()\n        // into null?  set term as prevTerm then dance?\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit EOF\");\n        }\n\n        // We hit EOF; try end-case surrogate dance: if we\n        // find an E, try swapping in S, backwards:\n        scratchTerm.copy(term);\n\n        assert scratchTerm.offset == 0;\n\n        for(int i=scratchTerm.length-1;i>=0;i--) {\n          if (isHighBMPChar(scratchTerm.bytes, i)) {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"    found E pos=\" + i + \"; try seek\");\n            }\n\n            if (seekToNonBMP(seekTermEnum, scratchTerm, i)) {\n\n              scratchTerm.copy(seekTermEnum.term().bytes());\n              getTermsDict().seekEnum(termEnum, seekTermEnum.term());\n\n              newSuffixStart = 1+i;\n\n              doPushes();\n\n              // Found a match\n              // TODO: faster seek?\n              current = termEnum.term().bytes();\n              return SeekStatus.NOT_FOUND;\n            }\n          }\n        }\n        \n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek END\");\n        }\n\n        current = null;\n        return SeekStatus.END;\n      } else {\n\n        // We found a non-exact but non-null term; this one\n        // is fun -- just treat it like next, by pretending\n        // requested term was prev:\n        prevTerm.copy(term);\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit non-exact term=\" + UnicodeUtil.toHexString(t.text()));\n        }\n\n        final BytesRef br = t.bytes();\n        assert br.offset == 0;\n\n        setNewSuffixStart(term, br);\n\n        surrogateDance();\n\n        final Term t2 = termEnum.term();\n        if (t2 == null || t2.field() != fieldInfo.name) {\n          assert t2 == null || !t2.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          current = null;\n          return SeekStatus.END;\n        } else {\n          current = t2.bytes();\n          assert !unicodeSortOrder || term.compareTo(current) < 0 : \"term=\" + UnicodeUtil.toHexString(term.utf8ToString()) + \" vs current=\" + UnicodeUtil.toHexString(current.utf8ToString());\n          return SeekStatus.NOT_FOUND;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fafef7c83fe8e0b3ca9298d5d75d6b943dc28153","date":1308670974,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seek(BytesRef,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seek(BytesRef,boolean).mjava","sourceNew":"    @Override\n    public SeekStatus seek(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek target=\" + UnicodeUtil.toHexString(term.utf8ToString()));\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = new Term(fieldInfo.name, term);\n\n      assert termEnum != null;\n\n      tis.seekEnum(termEnum, t0, useCache);\n\n      final Term t = termEnum.term();\n\n      if (t != null && t.field() == internedFieldName && term.bytesEquals(t.bytes())) {\n        // If we found an exact match, no need to do the\n        // surrogate dance\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek exact match\");\n        }\n        current = t.bytes();\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != internedFieldName) {\n\n        // TODO: maybe we can handle this like the next()\n        // into null?  set term as prevTerm then dance?\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit EOF\");\n        }\n\n        // We hit EOF; try end-case surrogate dance: if we\n        // find an E, try swapping in S, backwards:\n        scratchTerm.copy(term);\n\n        assert scratchTerm.offset == 0;\n\n        for(int i=scratchTerm.length-1;i>=0;i--) {\n          if (isHighBMPChar(scratchTerm.bytes, i)) {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"    found E pos=\" + i + \"; try seek\");\n            }\n\n            if (seekToNonBMP(seekTermEnum, scratchTerm, i)) {\n\n              scratchTerm.copy(seekTermEnum.term().bytes());\n              getTermsDict().seekEnum(termEnum, seekTermEnum.term(), useCache);\n\n              newSuffixStart = 1+i;\n\n              doPushes();\n\n              // Found a match\n              // TODO: faster seek?\n              current = termEnum.term().bytes();\n              return SeekStatus.NOT_FOUND;\n            }\n          }\n        }\n        \n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek END\");\n        }\n\n        current = null;\n        return SeekStatus.END;\n      } else {\n\n        // We found a non-exact but non-null term; this one\n        // is fun -- just treat it like next, by pretending\n        // requested term was prev:\n        prevTerm.copy(term);\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit non-exact term=\" + UnicodeUtil.toHexString(t.text()));\n        }\n\n        final BytesRef br = t.bytes();\n        assert br.offset == 0;\n\n        setNewSuffixStart(term, br);\n\n        surrogateDance();\n\n        final Term t2 = termEnum.term();\n        if (t2 == null || t2.field() != internedFieldName) {\n          // PreFlex codec interns field names; verify:\n          assert t2 == null || !t2.field().equals(internedFieldName);\n          current = null;\n          return SeekStatus.END;\n        } else {\n          current = t2.bytes();\n          assert !unicodeSortOrder || term.compareTo(current) < 0 : \"term=\" + UnicodeUtil.toHexString(term.utf8ToString()) + \" vs current=\" + UnicodeUtil.toHexString(current.utf8ToString());\n          return SeekStatus.NOT_FOUND;\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public SeekStatus seek(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek target=\" + UnicodeUtil.toHexString(term.utf8ToString()));\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = protoTerm.createTerm(term);\n\n      assert termEnum != null;\n\n      tis.seekEnum(termEnum, t0, useCache);\n\n      final Term t = termEnum.term();\n\n      if (t != null && t.field() == fieldInfo.name && term.bytesEquals(t.bytes())) {\n        // If we found an exact match, no need to do the\n        // surrogate dance\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek exact match\");\n        }\n        current = t.bytes();\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != fieldInfo.name) {\n\n        // TODO: maybe we can handle this like the next()\n        // into null?  set term as prevTerm then dance?\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit EOF\");\n        }\n\n        // We hit EOF; try end-case surrogate dance: if we\n        // find an E, try swapping in S, backwards:\n        scratchTerm.copy(term);\n\n        assert scratchTerm.offset == 0;\n\n        for(int i=scratchTerm.length-1;i>=0;i--) {\n          if (isHighBMPChar(scratchTerm.bytes, i)) {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"    found E pos=\" + i + \"; try seek\");\n            }\n\n            if (seekToNonBMP(seekTermEnum, scratchTerm, i)) {\n\n              scratchTerm.copy(seekTermEnum.term().bytes());\n              getTermsDict().seekEnum(termEnum, seekTermEnum.term(), useCache);\n\n              newSuffixStart = 1+i;\n\n              doPushes();\n\n              // Found a match\n              // TODO: faster seek?\n              current = termEnum.term().bytes();\n              return SeekStatus.NOT_FOUND;\n            }\n          }\n        }\n        \n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek END\");\n        }\n\n        current = null;\n        return SeekStatus.END;\n      } else {\n\n        // We found a non-exact but non-null term; this one\n        // is fun -- just treat it like next, by pretending\n        // requested term was prev:\n        prevTerm.copy(term);\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit non-exact term=\" + UnicodeUtil.toHexString(t.text()));\n        }\n\n        final BytesRef br = t.bytes();\n        assert br.offset == 0;\n\n        setNewSuffixStart(term, br);\n\n        surrogateDance();\n\n        final Term t2 = termEnum.term();\n        if (t2 == null || t2.field() != fieldInfo.name) {\n          assert t2 == null || !t2.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          current = null;\n          return SeekStatus.END;\n        } else {\n          current = t2.bytes();\n          assert !unicodeSortOrder || term.compareTo(current) < 0 : \"term=\" + UnicodeUtil.toHexString(term.utf8ToString()) + \" vs current=\" + UnicodeUtil.toHexString(current.utf8ToString());\n          return SeekStatus.NOT_FOUND;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd9cc9d77712aba3662f24632df7539ab75e3667","date":1309095238,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seekCeil(BytesRef,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seek(BytesRef,boolean).mjava","sourceNew":"    @Override\n    public SeekStatus seekCeil(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek target=\" + UnicodeUtil.toHexString(term.utf8ToString()));\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = new Term(fieldInfo.name, term);\n\n      assert termEnum != null;\n\n      tis.seekEnum(termEnum, t0, useCache);\n\n      final Term t = termEnum.term();\n\n      if (t != null && t.field() == internedFieldName && term.bytesEquals(t.bytes())) {\n        // If we found an exact match, no need to do the\n        // surrogate dance\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek exact match\");\n        }\n        current = t.bytes();\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != internedFieldName) {\n\n        // TODO: maybe we can handle this like the next()\n        // into null?  set term as prevTerm then dance?\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit EOF\");\n        }\n\n        // We hit EOF; try end-case surrogate dance: if we\n        // find an E, try swapping in S, backwards:\n        scratchTerm.copy(term);\n\n        assert scratchTerm.offset == 0;\n\n        for(int i=scratchTerm.length-1;i>=0;i--) {\n          if (isHighBMPChar(scratchTerm.bytes, i)) {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"    found E pos=\" + i + \"; try seek\");\n            }\n\n            if (seekToNonBMP(seekTermEnum, scratchTerm, i)) {\n\n              scratchTerm.copy(seekTermEnum.term().bytes());\n              getTermsDict().seekEnum(termEnum, seekTermEnum.term(), useCache);\n\n              newSuffixStart = 1+i;\n\n              doPushes();\n\n              // Found a match\n              // TODO: faster seek?\n              current = termEnum.term().bytes();\n              return SeekStatus.NOT_FOUND;\n            }\n          }\n        }\n        \n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek END\");\n        }\n\n        current = null;\n        return SeekStatus.END;\n      } else {\n\n        // We found a non-exact but non-null term; this one\n        // is fun -- just treat it like next, by pretending\n        // requested term was prev:\n        prevTerm.copy(term);\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit non-exact term=\" + UnicodeUtil.toHexString(t.text()));\n        }\n\n        final BytesRef br = t.bytes();\n        assert br.offset == 0;\n\n        setNewSuffixStart(term, br);\n\n        surrogateDance();\n\n        final Term t2 = termEnum.term();\n        if (t2 == null || t2.field() != internedFieldName) {\n          // PreFlex codec interns field names; verify:\n          assert t2 == null || !t2.field().equals(internedFieldName);\n          current = null;\n          return SeekStatus.END;\n        } else {\n          current = t2.bytes();\n          assert !unicodeSortOrder || term.compareTo(current) < 0 : \"term=\" + UnicodeUtil.toHexString(term.utf8ToString()) + \" vs current=\" + UnicodeUtil.toHexString(current.utf8ToString());\n          return SeekStatus.NOT_FOUND;\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public SeekStatus seek(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek target=\" + UnicodeUtil.toHexString(term.utf8ToString()));\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = new Term(fieldInfo.name, term);\n\n      assert termEnum != null;\n\n      tis.seekEnum(termEnum, t0, useCache);\n\n      final Term t = termEnum.term();\n\n      if (t != null && t.field() == internedFieldName && term.bytesEquals(t.bytes())) {\n        // If we found an exact match, no need to do the\n        // surrogate dance\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek exact match\");\n        }\n        current = t.bytes();\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != internedFieldName) {\n\n        // TODO: maybe we can handle this like the next()\n        // into null?  set term as prevTerm then dance?\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit EOF\");\n        }\n\n        // We hit EOF; try end-case surrogate dance: if we\n        // find an E, try swapping in S, backwards:\n        scratchTerm.copy(term);\n\n        assert scratchTerm.offset == 0;\n\n        for(int i=scratchTerm.length-1;i>=0;i--) {\n          if (isHighBMPChar(scratchTerm.bytes, i)) {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"    found E pos=\" + i + \"; try seek\");\n            }\n\n            if (seekToNonBMP(seekTermEnum, scratchTerm, i)) {\n\n              scratchTerm.copy(seekTermEnum.term().bytes());\n              getTermsDict().seekEnum(termEnum, seekTermEnum.term(), useCache);\n\n              newSuffixStart = 1+i;\n\n              doPushes();\n\n              // Found a match\n              // TODO: faster seek?\n              current = termEnum.term().bytes();\n              return SeekStatus.NOT_FOUND;\n            }\n          }\n        }\n        \n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek END\");\n        }\n\n        current = null;\n        return SeekStatus.END;\n      } else {\n\n        // We found a non-exact but non-null term; this one\n        // is fun -- just treat it like next, by pretending\n        // requested term was prev:\n        prevTerm.copy(term);\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit non-exact term=\" + UnicodeUtil.toHexString(t.text()));\n        }\n\n        final BytesRef br = t.bytes();\n        assert br.offset == 0;\n\n        setNewSuffixStart(term, br);\n\n        surrogateDance();\n\n        final Term t2 = termEnum.term();\n        if (t2 == null || t2.field() != internedFieldName) {\n          // PreFlex codec interns field names; verify:\n          assert t2 == null || !t2.field().equals(internedFieldName);\n          current = null;\n          return SeekStatus.END;\n        } else {\n          current = t2.bytes();\n          assert !unicodeSortOrder || term.compareTo(current) < 0 : \"term=\" + UnicodeUtil.toHexString(term.utf8ToString()) + \" vs current=\" + UnicodeUtil.toHexString(current.utf8ToString());\n          return SeekStatus.NOT_FOUND;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2553b00f699380c64959ccb27991289aae87be2e","date":1309290151,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seekCeil(BytesRef,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seek(BytesRef,boolean).mjava","sourceNew":"    @Override\n    public SeekStatus seekCeil(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek target=\" + UnicodeUtil.toHexString(term.utf8ToString()));\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = new Term(fieldInfo.name, term);\n\n      assert termEnum != null;\n\n      tis.seekEnum(termEnum, t0, useCache);\n\n      final Term t = termEnum.term();\n\n      if (t != null && t.field() == internedFieldName && term.bytesEquals(t.bytes())) {\n        // If we found an exact match, no need to do the\n        // surrogate dance\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek exact match\");\n        }\n        current = t.bytes();\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != internedFieldName) {\n\n        // TODO: maybe we can handle this like the next()\n        // into null?  set term as prevTerm then dance?\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit EOF\");\n        }\n\n        // We hit EOF; try end-case surrogate dance: if we\n        // find an E, try swapping in S, backwards:\n        scratchTerm.copy(term);\n\n        assert scratchTerm.offset == 0;\n\n        for(int i=scratchTerm.length-1;i>=0;i--) {\n          if (isHighBMPChar(scratchTerm.bytes, i)) {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"    found E pos=\" + i + \"; try seek\");\n            }\n\n            if (seekToNonBMP(seekTermEnum, scratchTerm, i)) {\n\n              scratchTerm.copy(seekTermEnum.term().bytes());\n              getTermsDict().seekEnum(termEnum, seekTermEnum.term(), useCache);\n\n              newSuffixStart = 1+i;\n\n              doPushes();\n\n              // Found a match\n              // TODO: faster seek?\n              current = termEnum.term().bytes();\n              return SeekStatus.NOT_FOUND;\n            }\n          }\n        }\n        \n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek END\");\n        }\n\n        current = null;\n        return SeekStatus.END;\n      } else {\n\n        // We found a non-exact but non-null term; this one\n        // is fun -- just treat it like next, by pretending\n        // requested term was prev:\n        prevTerm.copy(term);\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit non-exact term=\" + UnicodeUtil.toHexString(t.text()));\n        }\n\n        final BytesRef br = t.bytes();\n        assert br.offset == 0;\n\n        setNewSuffixStart(term, br);\n\n        surrogateDance();\n\n        final Term t2 = termEnum.term();\n        if (t2 == null || t2.field() != internedFieldName) {\n          // PreFlex codec interns field names; verify:\n          assert t2 == null || !t2.field().equals(internedFieldName);\n          current = null;\n          return SeekStatus.END;\n        } else {\n          current = t2.bytes();\n          assert !unicodeSortOrder || term.compareTo(current) < 0 : \"term=\" + UnicodeUtil.toHexString(term.utf8ToString()) + \" vs current=\" + UnicodeUtil.toHexString(current.utf8ToString());\n          return SeekStatus.NOT_FOUND;\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public SeekStatus seek(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek target=\" + UnicodeUtil.toHexString(term.utf8ToString()));\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = protoTerm.createTerm(term);\n\n      assert termEnum != null;\n\n      tis.seekEnum(termEnum, t0, useCache);\n\n      final Term t = termEnum.term();\n\n      if (t != null && t.field() == fieldInfo.name && term.bytesEquals(t.bytes())) {\n        // If we found an exact match, no need to do the\n        // surrogate dance\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek exact match\");\n        }\n        current = t.bytes();\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != fieldInfo.name) {\n\n        // TODO: maybe we can handle this like the next()\n        // into null?  set term as prevTerm then dance?\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit EOF\");\n        }\n\n        // We hit EOF; try end-case surrogate dance: if we\n        // find an E, try swapping in S, backwards:\n        scratchTerm.copy(term);\n\n        assert scratchTerm.offset == 0;\n\n        for(int i=scratchTerm.length-1;i>=0;i--) {\n          if (isHighBMPChar(scratchTerm.bytes, i)) {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"    found E pos=\" + i + \"; try seek\");\n            }\n\n            if (seekToNonBMP(seekTermEnum, scratchTerm, i)) {\n\n              scratchTerm.copy(seekTermEnum.term().bytes());\n              getTermsDict().seekEnum(termEnum, seekTermEnum.term(), useCache);\n\n              newSuffixStart = 1+i;\n\n              doPushes();\n\n              // Found a match\n              // TODO: faster seek?\n              current = termEnum.term().bytes();\n              return SeekStatus.NOT_FOUND;\n            }\n          }\n        }\n        \n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek END\");\n        }\n\n        current = null;\n        return SeekStatus.END;\n      } else {\n\n        // We found a non-exact but non-null term; this one\n        // is fun -- just treat it like next, by pretending\n        // requested term was prev:\n        prevTerm.copy(term);\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit non-exact term=\" + UnicodeUtil.toHexString(t.text()));\n        }\n\n        final BytesRef br = t.bytes();\n        assert br.offset == 0;\n\n        setNewSuffixStart(term, br);\n\n        surrogateDance();\n\n        final Term t2 = termEnum.term();\n        if (t2 == null || t2.field() != fieldInfo.name) {\n          assert t2 == null || !t2.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          current = null;\n          return SeekStatus.END;\n        } else {\n          current = t2.bytes();\n          assert !unicodeSortOrder || term.compareTo(current) < 0 : \"term=\" + UnicodeUtil.toHexString(term.utf8ToString()) + \" vs current=\" + UnicodeUtil.toHexString(current.utf8ToString());\n          return SeekStatus.NOT_FOUND;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":4,"author":"Simon Willnauer","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#seek(BytesRef,boolean).mjava","sourceNew":null,"sourceOld":"    @Override\n    public SeekStatus seek(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek target=\" + UnicodeUtil.toHexString(term.utf8ToString()));\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = protoTerm.createTerm(term);\n\n      assert termEnum != null;\n\n      tis.seekEnum(termEnum, t0, useCache);\n\n      final Term t = termEnum.term();\n\n      if (t != null && t.field() == fieldInfo.name && term.bytesEquals(t.bytes())) {\n        // If we found an exact match, no need to do the\n        // surrogate dance\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek exact match\");\n        }\n        current = t.bytes();\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != fieldInfo.name) {\n\n        // TODO: maybe we can handle this like the next()\n        // into null?  set term as prevTerm then dance?\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit EOF\");\n        }\n\n        // We hit EOF; try end-case surrogate dance: if we\n        // find an E, try swapping in S, backwards:\n        scratchTerm.copy(term);\n\n        assert scratchTerm.offset == 0;\n\n        for(int i=scratchTerm.length-1;i>=0;i--) {\n          if (isHighBMPChar(scratchTerm.bytes, i)) {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"    found E pos=\" + i + \"; try seek\");\n            }\n\n            if (seekToNonBMP(seekTermEnum, scratchTerm, i)) {\n\n              scratchTerm.copy(seekTermEnum.term().bytes());\n              getTermsDict().seekEnum(termEnum, seekTermEnum.term(), useCache);\n\n              newSuffixStart = 1+i;\n\n              doPushes();\n\n              // Found a match\n              // TODO: faster seek?\n              current = termEnum.term().bytes();\n              return SeekStatus.NOT_FOUND;\n            }\n          }\n        }\n        \n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek END\");\n        }\n\n        current = null;\n        return SeekStatus.END;\n      } else {\n\n        // We found a non-exact but non-null term; this one\n        // is fun -- just treat it like next, by pretending\n        // requested term was prev:\n        prevTerm.copy(term);\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit non-exact term=\" + UnicodeUtil.toHexString(t.text()));\n        }\n\n        final BytesRef br = t.bytes();\n        assert br.offset == 0;\n\n        setNewSuffixStart(term, br);\n\n        surrogateDance();\n\n        final Term t2 = termEnum.term();\n        if (t2 == null || t2.field() != fieldInfo.name) {\n          assert t2 == null || !t2.field().equals(fieldInfo.name); // make sure fields are in fact interned\n          current = null;\n          return SeekStatus.END;\n        } else {\n          current = t2.bytes();\n          assert !unicodeSortOrder || term.compareTo(current) < 0 : \"term=\" + UnicodeUtil.toHexString(term.utf8ToString()) + \" vs current=\" + UnicodeUtil.toHexString(current.utf8ToString());\n          return SeekStatus.NOT_FOUND;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4f29ba80b723649f5feb7e37afe1a558dd2c1304":["08932c793647a36953d1816b1060121f48820d3f"],"3242a09f703274d3b9283f2064a1a33064b53a1b":["5f4e87790277826a2aea119328600dfb07761f32","4b103252dee6afa1b6d7a622c773d178788eb85a"],"4b103252dee6afa1b6d7a622c773d178788eb85a":["4f29ba80b723649f5feb7e37afe1a558dd2c1304","c9f6bb0c3d7b1c1dd8aeab43a34a89f050069e97"],"163fe85a71d778fd2b7747f65ca27b54829e2e57":["4f29ba80b723649f5feb7e37afe1a558dd2c1304"],"825bcb488bc228d1fb6a19c1f441a2181f7d766d":["4b103252dee6afa1b6d7a622c773d178788eb85a"],"fafef7c83fe8e0b3ca9298d5d75d6b943dc28153":["825bcb488bc228d1fb6a19c1f441a2181f7d766d"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5f4e87790277826a2aea119328600dfb07761f32":["955c32f886db6f6356c9fcdea6b1f1cb4effda24","4f29ba80b723649f5feb7e37afe1a558dd2c1304"],"2553b00f699380c64959ccb27991289aae87be2e":["825bcb488bc228d1fb6a19c1f441a2181f7d766d","fd9cc9d77712aba3662f24632df7539ab75e3667"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["3242a09f703274d3b9283f2064a1a33064b53a1b","825bcb488bc228d1fb6a19c1f441a2181f7d766d"],"c9f6bb0c3d7b1c1dd8aeab43a34a89f050069e97":["163fe85a71d778fd2b7747f65ca27b54829e2e57"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["825bcb488bc228d1fb6a19c1f441a2181f7d766d","fd9cc9d77712aba3662f24632df7539ab75e3667"],"08932c793647a36953d1816b1060121f48820d3f":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fd9cc9d77712aba3662f24632df7539ab75e3667":["fafef7c83fe8e0b3ca9298d5d75d6b943dc28153"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fd9cc9d77712aba3662f24632df7539ab75e3667"]},"commit2Childs":{"4f29ba80b723649f5feb7e37afe1a558dd2c1304":["4b103252dee6afa1b6d7a622c773d178788eb85a","163fe85a71d778fd2b7747f65ca27b54829e2e57","5f4e87790277826a2aea119328600dfb07761f32"],"3242a09f703274d3b9283f2064a1a33064b53a1b":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"4b103252dee6afa1b6d7a622c773d178788eb85a":["3242a09f703274d3b9283f2064a1a33064b53a1b","825bcb488bc228d1fb6a19c1f441a2181f7d766d"],"163fe85a71d778fd2b7747f65ca27b54829e2e57":["c9f6bb0c3d7b1c1dd8aeab43a34a89f050069e97"],"825bcb488bc228d1fb6a19c1f441a2181f7d766d":["fafef7c83fe8e0b3ca9298d5d75d6b943dc28153","2553b00f699380c64959ccb27991289aae87be2e","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"fafef7c83fe8e0b3ca9298d5d75d6b943dc28153":["fd9cc9d77712aba3662f24632df7539ab75e3667"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["5f4e87790277826a2aea119328600dfb07761f32","08932c793647a36953d1816b1060121f48820d3f"],"5f4e87790277826a2aea119328600dfb07761f32":["3242a09f703274d3b9283f2064a1a33064b53a1b"],"2553b00f699380c64959ccb27991289aae87be2e":[],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"c9f6bb0c3d7b1c1dd8aeab43a34a89f050069e97":["4b103252dee6afa1b6d7a622c773d178788eb85a"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"08932c793647a36953d1816b1060121f48820d3f":["4f29ba80b723649f5feb7e37afe1a558dd2c1304"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"fd9cc9d77712aba3662f24632df7539ab75e3667":["2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["2553b00f699380c64959ccb27991289aae87be2e","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","d083e83f225b11e5fdd900e83d26ddb385b6955c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}