{"path":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decodeDVField(int,LeafReader,String).mjava","commits":[{"id":"55ac9ae04c11f9e36330ee2448ef214c4fdbfc79","date":1509089658,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decodeDVField(int,LeafReader,String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Decode value from DV field for a document\n   * @return null if DV field is not exist or can not decodable\n   */\n  private Object decodeDVField(int localId, LeafReader leafReader, String fieldName) throws IOException {\n    final SchemaField schemaField = searcher.getSchema().getFieldOrNull(fieldName);\n    FieldInfo fi = searcher.getFieldInfos().fieldInfo(fieldName);\n    if (schemaField == null || !schemaField.hasDocValues() || fi == null) {\n      return null; // Searcher doesn't have info about this field, hence ignore it.\n    }\n\n    final DocValuesType dvType = fi.getDocValuesType();\n    switch (dvType) {\n      case NUMERIC:\n        final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n        if (ndv == null) {\n          return null;\n        }\n        if (!ndv.advanceExact(localId)) {\n          return null;\n        }\n        Long val = ndv.longValue();\n        return decodeNumberFromDV(schemaField, val, false);\n      case BINARY:\n        BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n        if (bdv != null && bdv.advanceExact(localId)) {\n          return BytesRef.deepCopyOf(bdv.binaryValue());\n        }\n        return null;\n      case SORTED:\n        SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n        if (sdv != null && sdv.advanceExact(localId)) {\n          final BytesRef bRef = sdv.binaryValue();\n          // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n          if (schemaField.getType() instanceof BoolField) {\n            return schemaField.getType().toObject(schemaField, bRef);\n          } else {\n            return bRef.utf8ToString();\n          }\n        }\n        return null;\n      case SORTED_NUMERIC:\n        final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n        if (numericDv != null && numericDv.advance(localId) == localId) {\n          final List<Object> outValues = new ArrayList<>(numericDv.docValueCount());\n          for (int i = 0; i < numericDv.docValueCount(); i++) {\n            long number = numericDv.nextValue();\n            Object value = decodeNumberFromDV(schemaField, number, true);\n            // return immediately if the number is not decodable, hence won't return an empty list.\n            if (value == null) return null;\n            else outValues.add(value);\n          }\n          assert outValues.size() > 0;\n          return outValues;\n        }\n        return null;\n      case SORTED_SET:\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0 && values.advance(localId) == localId) {\n          final List<Object> outValues = new LinkedList<>();\n          for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n            BytesRef value = values.lookupOrd(ord);\n            outValues.add(schemaField.getType().toObject(schemaField, value));\n          }\n          assert outValues.size() > 0;\n          return outValues;\n        }\n        return null;\n      default:\n        return null;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8e664487f12f836ec07e7c44c5ddc682388a15cf","date":1521303713,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decodeDVField(int,LeafReader,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decodeDVField(int,LeafReader,String).mjava","sourceNew":"  /**\n   * Decode value from DV field for a document\n   * @return null if DV field is not exist or can not decodable\n   */\n  private Object decodeDVField(int localId, LeafReader leafReader, String fieldName) throws IOException {\n    final SchemaField schemaField = searcher.getSchema().getFieldOrNull(fieldName);\n    FieldInfo fi = searcher.getFieldInfos().fieldInfo(fieldName);\n    if (schemaField == null || !schemaField.hasDocValues() || fi == null) {\n      return null; // Searcher doesn't have info about this field, hence ignore it.\n    }\n\n    final DocValuesType dvType = fi.getDocValuesType();\n    switch (dvType) {\n      case NUMERIC:\n        final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n        if (ndv == null) {\n          return null;\n        }\n        if (!ndv.advanceExact(localId)) {\n          return null;\n        }\n        Long val = ndv.longValue();\n        return decodeNumberFromDV(schemaField, val, false);\n      case BINARY:\n        BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n        if (bdv != null && bdv.advanceExact(localId)) {\n          return BytesRef.deepCopyOf(bdv.binaryValue());\n        }\n        return null;\n      case SORTED:\n        SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n        if (sdv != null && sdv.advanceExact(localId)) {\n          final BytesRef bRef = sdv.binaryValue();\n          // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n          if (schemaField.getType() instanceof BoolField) {\n            return schemaField.getType().toObject(schemaField, bRef);\n          } else {\n            return bRef.utf8ToString();\n          }\n        }\n        return null;\n      case SORTED_NUMERIC:\n        final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n        if (numericDv != null && numericDv.advance(localId) == localId) {\n          final List<Object> outValues = new ArrayList<>(numericDv.docValueCount());\n          for (int i = 0; i < numericDv.docValueCount(); i++) {\n            long number = numericDv.nextValue();\n            Object value = decodeNumberFromDV(schemaField, number, true);\n            // return immediately if the number is not decodable, hence won't return an empty list.\n            if (value == null) {\n              return null;\n            }\n            // normally never true but LatLonPointSpatialField uses SORTED_NUMERIC even when single valued\n            else if (schemaField.multiValued() == false) {\n              return value;\n            }\n            else {\n              outValues.add(value);\n            }\n          }\n          assert outValues.size() > 0;\n          return outValues;\n        }\n        return null;\n      case SORTED_SET:\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0 && values.advance(localId) == localId) {\n          final List<Object> outValues = new LinkedList<>();\n          for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n            BytesRef value = values.lookupOrd(ord);\n            outValues.add(schemaField.getType().toObject(schemaField, value));\n          }\n          assert outValues.size() > 0;\n          return outValues;\n        }\n        return null;\n      default:\n        return null;\n    }\n  }\n\n","sourceOld":"  /**\n   * Decode value from DV field for a document\n   * @return null if DV field is not exist or can not decodable\n   */\n  private Object decodeDVField(int localId, LeafReader leafReader, String fieldName) throws IOException {\n    final SchemaField schemaField = searcher.getSchema().getFieldOrNull(fieldName);\n    FieldInfo fi = searcher.getFieldInfos().fieldInfo(fieldName);\n    if (schemaField == null || !schemaField.hasDocValues() || fi == null) {\n      return null; // Searcher doesn't have info about this field, hence ignore it.\n    }\n\n    final DocValuesType dvType = fi.getDocValuesType();\n    switch (dvType) {\n      case NUMERIC:\n        final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n        if (ndv == null) {\n          return null;\n        }\n        if (!ndv.advanceExact(localId)) {\n          return null;\n        }\n        Long val = ndv.longValue();\n        return decodeNumberFromDV(schemaField, val, false);\n      case BINARY:\n        BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n        if (bdv != null && bdv.advanceExact(localId)) {\n          return BytesRef.deepCopyOf(bdv.binaryValue());\n        }\n        return null;\n      case SORTED:\n        SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n        if (sdv != null && sdv.advanceExact(localId)) {\n          final BytesRef bRef = sdv.binaryValue();\n          // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n          if (schemaField.getType() instanceof BoolField) {\n            return schemaField.getType().toObject(schemaField, bRef);\n          } else {\n            return bRef.utf8ToString();\n          }\n        }\n        return null;\n      case SORTED_NUMERIC:\n        final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n        if (numericDv != null && numericDv.advance(localId) == localId) {\n          final List<Object> outValues = new ArrayList<>(numericDv.docValueCount());\n          for (int i = 0; i < numericDv.docValueCount(); i++) {\n            long number = numericDv.nextValue();\n            Object value = decodeNumberFromDV(schemaField, number, true);\n            // return immediately if the number is not decodable, hence won't return an empty list.\n            if (value == null) return null;\n            else outValues.add(value);\n          }\n          assert outValues.size() > 0;\n          return outValues;\n        }\n        return null;\n      case SORTED_SET:\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0 && values.advance(localId) == localId) {\n          final List<Object> outValues = new LinkedList<>();\n          for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n            BytesRef value = values.lookupOrd(ord);\n            outValues.add(schemaField.getType().toObject(schemaField, value));\n          }\n          assert outValues.size() > 0;\n          return outValues;\n        }\n        return null;\n      default:\n        return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"203e3fcf513c02ee2c07015f2ce277e26dc60907","date":1521404157,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decodeDVField(int,LeafReader,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decodeDVField(int,LeafReader,String).mjava","sourceNew":"  /**\n   * Decode value from DV field for a document\n   * @return null if DV field is not exist or can not decodable\n   */\n  private Object decodeDVField(int localId, LeafReader leafReader, String fieldName) throws IOException {\n    final SchemaField schemaField = searcher.getSchema().getFieldOrNull(fieldName);\n    FieldInfo fi = searcher.getFieldInfos().fieldInfo(fieldName);\n    if (schemaField == null || !schemaField.hasDocValues() || fi == null) {\n      return null; // Searcher doesn't have info about this field, hence ignore it.\n    }\n\n    final DocValuesType dvType = fi.getDocValuesType();\n    switch (dvType) {\n      case NUMERIC:\n        final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n        if (ndv == null) {\n          return null;\n        }\n        if (!ndv.advanceExact(localId)) {\n          return null;\n        }\n        Long val = ndv.longValue();\n        return decodeNumberFromDV(schemaField, val, false);\n      case BINARY:\n        BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n        if (bdv != null && bdv.advanceExact(localId)) {\n          return BytesRef.deepCopyOf(bdv.binaryValue());\n        }\n        return null;\n      case SORTED:\n        SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n        if (sdv != null && sdv.advanceExact(localId)) {\n          final BytesRef bRef = sdv.binaryValue();\n          // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n          if (schemaField.getType() instanceof BoolField) {\n            return schemaField.getType().toObject(schemaField, bRef);\n          } else {\n            return bRef.utf8ToString();\n          }\n        }\n        return null;\n      case SORTED_NUMERIC:\n        final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n        if (numericDv != null && numericDv.advance(localId) == localId) {\n          final List<Object> outValues = new ArrayList<>(numericDv.docValueCount());\n          for (int i = 0; i < numericDv.docValueCount(); i++) {\n            long number = numericDv.nextValue();\n            Object value = decodeNumberFromDV(schemaField, number, true);\n            // return immediately if the number is not decodable, hence won't return an empty list.\n            if (value == null) {\n              return null;\n            }\n            // normally never true but LatLonPointSpatialField uses SORTED_NUMERIC even when single valued\n            else if (schemaField.multiValued() == false) {\n              return value;\n            }\n            else {\n              outValues.add(value);\n            }\n          }\n          assert outValues.size() > 0;\n          return outValues;\n        }\n        return null;\n      case SORTED_SET:\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0 && values.advance(localId) == localId) {\n          final List<Object> outValues = new LinkedList<>();\n          for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n            BytesRef value = values.lookupOrd(ord);\n            outValues.add(schemaField.getType().toObject(schemaField, value));\n          }\n          assert outValues.size() > 0;\n          return outValues;\n        }\n        return null;\n      default:\n        return null;\n    }\n  }\n\n","sourceOld":"  /**\n   * Decode value from DV field for a document\n   * @return null if DV field is not exist or can not decodable\n   */\n  private Object decodeDVField(int localId, LeafReader leafReader, String fieldName) throws IOException {\n    final SchemaField schemaField = searcher.getSchema().getFieldOrNull(fieldName);\n    FieldInfo fi = searcher.getFieldInfos().fieldInfo(fieldName);\n    if (schemaField == null || !schemaField.hasDocValues() || fi == null) {\n      return null; // Searcher doesn't have info about this field, hence ignore it.\n    }\n\n    final DocValuesType dvType = fi.getDocValuesType();\n    switch (dvType) {\n      case NUMERIC:\n        final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n        if (ndv == null) {\n          return null;\n        }\n        if (!ndv.advanceExact(localId)) {\n          return null;\n        }\n        Long val = ndv.longValue();\n        return decodeNumberFromDV(schemaField, val, false);\n      case BINARY:\n        BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n        if (bdv != null && bdv.advanceExact(localId)) {\n          return BytesRef.deepCopyOf(bdv.binaryValue());\n        }\n        return null;\n      case SORTED:\n        SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n        if (sdv != null && sdv.advanceExact(localId)) {\n          final BytesRef bRef = sdv.binaryValue();\n          // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n          if (schemaField.getType() instanceof BoolField) {\n            return schemaField.getType().toObject(schemaField, bRef);\n          } else {\n            return bRef.utf8ToString();\n          }\n        }\n        return null;\n      case SORTED_NUMERIC:\n        final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n        if (numericDv != null && numericDv.advance(localId) == localId) {\n          final List<Object> outValues = new ArrayList<>(numericDv.docValueCount());\n          for (int i = 0; i < numericDv.docValueCount(); i++) {\n            long number = numericDv.nextValue();\n            Object value = decodeNumberFromDV(schemaField, number, true);\n            // return immediately if the number is not decodable, hence won't return an empty list.\n            if (value == null) return null;\n            else outValues.add(value);\n          }\n          assert outValues.size() > 0;\n          return outValues;\n        }\n        return null;\n      case SORTED_SET:\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0 && values.advance(localId) == localId) {\n          final List<Object> outValues = new LinkedList<>();\n          for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n            BytesRef value = values.lookupOrd(ord);\n            outValues.add(schemaField.getType().toObject(schemaField, value));\n          }\n          assert outValues.size() > 0;\n          return outValues;\n        }\n        return null;\n      default:\n        return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"96ecd141e96e7a7a65822d7fada5ddc585b21149","date":1534786652,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decodeDVField(int,LeafReader,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decodeDVField(int,LeafReader,String).mjava","sourceNew":"  /**\n   * Decode value from DV field for a document\n   * @return null if DV field is not exist or can not decodable\n   */\n  private Object decodeDVField(int localId, LeafReader leafReader, String fieldName) throws IOException {\n    final SchemaField schemaField = searcher.getSchema().getFieldOrNull(fieldName);\n    FieldInfo fi = searcher.getFieldInfos().fieldInfo(fieldName);\n    if (schemaField == null || !schemaField.hasDocValues() || fi == null) {\n      return null; // Searcher doesn't have info about this field, hence ignore it.\n    }\n\n    final DocValuesType dvType = fi.getDocValuesType();\n    switch (dvType) {\n      case NUMERIC:\n        final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n        if (ndv == null) {\n          return null;\n        }\n        if (!ndv.advanceExact(localId)) {\n          return null;\n        }\n        Long val = ndv.longValue();\n        return decodeNumberFromDV(schemaField, val, false);\n      case BINARY:\n        BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n        if (bdv != null && bdv.advanceExact(localId)) {\n          return BytesRef.deepCopyOf(bdv.binaryValue());\n        }\n        return null;\n      case SORTED:\n        SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n        if (sdv != null && sdv.advanceExact(localId)) {\n          final BytesRef bRef = sdv.binaryValue();\n          // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n          if (schemaField.getType() instanceof BoolField) {\n            return schemaField.getType().toObject(schemaField, bRef);\n          } else {\n            return bRef.utf8ToString();\n          }\n        }\n        return null;\n      case SORTED_NUMERIC:\n        final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n        if (numericDv != null && numericDv.advance(localId) == localId) {\n          final List<Object> outValues = new ArrayList<>(numericDv.docValueCount());\n          for (int i = 0; i < numericDv.docValueCount(); i++) {\n            long number = numericDv.nextValue();\n            Object value = decodeNumberFromDV(schemaField, number, true);\n            // return immediately if the number is not decodable, hence won't return an empty list.\n            if (value == null) {\n              return null;\n            }\n            // normally never true but LatLonPointSpatialField uses SORTED_NUMERIC even when single valued\n            else if (schemaField.multiValued() == false) {\n              return value;\n            } else {\n              outValues.add(value);\n            }\n          }\n          assert outValues.size() > 0;\n          return outValues;\n        }\n        return null;\n      case SORTED_SET:\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0 && values.advance(localId) == localId) {\n          final List<Object> outValues = new LinkedList<>();\n          for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n            BytesRef value = values.lookupOrd(ord);\n            outValues.add(schemaField.getType().toObject(schemaField, value));\n          }\n          assert outValues.size() > 0;\n          return outValues;\n        }\n        return null;\n      default:\n        return null;\n    }\n  }\n\n","sourceOld":"  /**\n   * Decode value from DV field for a document\n   * @return null if DV field is not exist or can not decodable\n   */\n  private Object decodeDVField(int localId, LeafReader leafReader, String fieldName) throws IOException {\n    final SchemaField schemaField = searcher.getSchema().getFieldOrNull(fieldName);\n    FieldInfo fi = searcher.getFieldInfos().fieldInfo(fieldName);\n    if (schemaField == null || !schemaField.hasDocValues() || fi == null) {\n      return null; // Searcher doesn't have info about this field, hence ignore it.\n    }\n\n    final DocValuesType dvType = fi.getDocValuesType();\n    switch (dvType) {\n      case NUMERIC:\n        final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n        if (ndv == null) {\n          return null;\n        }\n        if (!ndv.advanceExact(localId)) {\n          return null;\n        }\n        Long val = ndv.longValue();\n        return decodeNumberFromDV(schemaField, val, false);\n      case BINARY:\n        BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n        if (bdv != null && bdv.advanceExact(localId)) {\n          return BytesRef.deepCopyOf(bdv.binaryValue());\n        }\n        return null;\n      case SORTED:\n        SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n        if (sdv != null && sdv.advanceExact(localId)) {\n          final BytesRef bRef = sdv.binaryValue();\n          // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n          if (schemaField.getType() instanceof BoolField) {\n            return schemaField.getType().toObject(schemaField, bRef);\n          } else {\n            return bRef.utf8ToString();\n          }\n        }\n        return null;\n      case SORTED_NUMERIC:\n        final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n        if (numericDv != null && numericDv.advance(localId) == localId) {\n          final List<Object> outValues = new ArrayList<>(numericDv.docValueCount());\n          for (int i = 0; i < numericDv.docValueCount(); i++) {\n            long number = numericDv.nextValue();\n            Object value = decodeNumberFromDV(schemaField, number, true);\n            // return immediately if the number is not decodable, hence won't return an empty list.\n            if (value == null) {\n              return null;\n            }\n            // normally never true but LatLonPointSpatialField uses SORTED_NUMERIC even when single valued\n            else if (schemaField.multiValued() == false) {\n              return value;\n            }\n            else {\n              outValues.add(value);\n            }\n          }\n          assert outValues.size() > 0;\n          return outValues;\n        }\n        return null;\n      case SORTED_SET:\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0 && values.advance(localId) == localId) {\n          final List<Object> outValues = new LinkedList<>();\n          for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n            BytesRef value = values.lookupOrd(ord);\n            outValues.add(schemaField.getType().toObject(schemaField, value));\n          }\n          assert outValues.size() > 0;\n          return outValues;\n        }\n        return null;\n      default:\n        return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"95904004e26fe5b84dcda2fa112ebf7cc9721a60","date":1560149781,"type":3,"author":"Tim Underwood","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decodeDVField(int,LeafReader,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decodeDVField(int,LeafReader,String).mjava","sourceNew":"  /**\n   * Decode value from DV field for a document\n   * @return null if DV field is not exist or can not decodable\n   */\n  private Object decodeDVField(int localId, LeafReader leafReader, String fieldName) throws IOException {\n    final SchemaField schemaField = searcher.getSchema().getFieldOrNull(fieldName);\n    FieldInfo fi = searcher.getFieldInfos().fieldInfo(fieldName);\n    if (schemaField == null || !schemaField.hasDocValues() || fi == null) {\n      return null; // Searcher doesn't have info about this field, hence ignore it.\n    }\n\n    final DocValuesType dvType = fi.getDocValuesType();\n    switch (dvType) {\n      case NUMERIC:\n        final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n        if (ndv == null) {\n          return null;\n        }\n        if (!ndv.advanceExact(localId)) {\n          return null;\n        }\n        Long val = ndv.longValue();\n        return decodeNumberFromDV(schemaField, val, false);\n      case BINARY:\n        BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n        if (bdv != null && bdv.advanceExact(localId)) {\n          return BytesRef.deepCopyOf(bdv.binaryValue());\n        }\n        return null;\n      case SORTED:\n        SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n        if (sdv != null && sdv.advanceExact(localId)) {\n          final BytesRef bRef = sdv.binaryValue();\n          // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n          if (schemaField.getType() instanceof BoolField) {\n            return schemaField.getType().toObject(schemaField, bRef);\n          } else {\n            return bRef.utf8ToString();\n          }\n        }\n        return null;\n      case SORTED_NUMERIC:\n        final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n        if (numericDv != null && numericDv.advance(localId) == localId) {\n          final int docValueCount = numericDv.docValueCount();\n          final List<Object> outValues = new ArrayList<>(docValueCount);\n          for (int i = 0; i < docValueCount; i++) {\n            long number = numericDv.nextValue();\n            Object value = decodeNumberFromDV(schemaField, number, true);\n            // return immediately if the number is not decodable, hence won't return an empty list.\n            if (value == null) {\n              return null;\n            }\n            // normally never true but LatLonPointSpatialField uses SORTED_NUMERIC even when single valued\n            else if (schemaField.multiValued() == false) {\n              return value;\n            } else {\n              outValues.add(value);\n            }\n          }\n          assert outValues.size() > 0;\n          return outValues;\n        }\n        return null;\n      case SORTED_SET:\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0 && values.advance(localId) == localId) {\n          final List<Object> outValues = new LinkedList<>();\n          for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n            BytesRef value = values.lookupOrd(ord);\n            outValues.add(schemaField.getType().toObject(schemaField, value));\n          }\n          assert outValues.size() > 0;\n          return outValues;\n        }\n        return null;\n      default:\n        return null;\n    }\n  }\n\n","sourceOld":"  /**\n   * Decode value from DV field for a document\n   * @return null if DV field is not exist or can not decodable\n   */\n  private Object decodeDVField(int localId, LeafReader leafReader, String fieldName) throws IOException {\n    final SchemaField schemaField = searcher.getSchema().getFieldOrNull(fieldName);\n    FieldInfo fi = searcher.getFieldInfos().fieldInfo(fieldName);\n    if (schemaField == null || !schemaField.hasDocValues() || fi == null) {\n      return null; // Searcher doesn't have info about this field, hence ignore it.\n    }\n\n    final DocValuesType dvType = fi.getDocValuesType();\n    switch (dvType) {\n      case NUMERIC:\n        final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n        if (ndv == null) {\n          return null;\n        }\n        if (!ndv.advanceExact(localId)) {\n          return null;\n        }\n        Long val = ndv.longValue();\n        return decodeNumberFromDV(schemaField, val, false);\n      case BINARY:\n        BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n        if (bdv != null && bdv.advanceExact(localId)) {\n          return BytesRef.deepCopyOf(bdv.binaryValue());\n        }\n        return null;\n      case SORTED:\n        SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n        if (sdv != null && sdv.advanceExact(localId)) {\n          final BytesRef bRef = sdv.binaryValue();\n          // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n          if (schemaField.getType() instanceof BoolField) {\n            return schemaField.getType().toObject(schemaField, bRef);\n          } else {\n            return bRef.utf8ToString();\n          }\n        }\n        return null;\n      case SORTED_NUMERIC:\n        final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n        if (numericDv != null && numericDv.advance(localId) == localId) {\n          final List<Object> outValues = new ArrayList<>(numericDv.docValueCount());\n          for (int i = 0; i < numericDv.docValueCount(); i++) {\n            long number = numericDv.nextValue();\n            Object value = decodeNumberFromDV(schemaField, number, true);\n            // return immediately if the number is not decodable, hence won't return an empty list.\n            if (value == null) {\n              return null;\n            }\n            // normally never true but LatLonPointSpatialField uses SORTED_NUMERIC even when single valued\n            else if (schemaField.multiValued() == false) {\n              return value;\n            } else {\n              outValues.add(value);\n            }\n          }\n          assert outValues.size() > 0;\n          return outValues;\n        }\n        return null;\n      case SORTED_SET:\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0 && values.advance(localId) == localId) {\n          final List<Object> outValues = new LinkedList<>();\n          for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n            BytesRef value = values.lookupOrd(ord);\n            outValues.add(schemaField.getType().toObject(schemaField, value));\n          }\n          assert outValues.size() > 0;\n          return outValues;\n        }\n        return null;\n      default:\n        return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"96ecd141e96e7a7a65822d7fada5ddc585b21149":["203e3fcf513c02ee2c07015f2ce277e26dc60907"],"55ac9ae04c11f9e36330ee2448ef214c4fdbfc79":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"95904004e26fe5b84dcda2fa112ebf7cc9721a60":["96ecd141e96e7a7a65822d7fada5ddc585b21149"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"203e3fcf513c02ee2c07015f2ce277e26dc60907":["55ac9ae04c11f9e36330ee2448ef214c4fdbfc79","8e664487f12f836ec07e7c44c5ddc682388a15cf"],"8e664487f12f836ec07e7c44c5ddc682388a15cf":["55ac9ae04c11f9e36330ee2448ef214c4fdbfc79"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["95904004e26fe5b84dcda2fa112ebf7cc9721a60"]},"commit2Childs":{"96ecd141e96e7a7a65822d7fada5ddc585b21149":["95904004e26fe5b84dcda2fa112ebf7cc9721a60"],"55ac9ae04c11f9e36330ee2448ef214c4fdbfc79":["203e3fcf513c02ee2c07015f2ce277e26dc60907","8e664487f12f836ec07e7c44c5ddc682388a15cf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["55ac9ae04c11f9e36330ee2448ef214c4fdbfc79"],"95904004e26fe5b84dcda2fa112ebf7cc9721a60":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"203e3fcf513c02ee2c07015f2ce277e26dc60907":["96ecd141e96e7a7a65822d7fada5ddc585b21149"],"8e664487f12f836ec07e7c44c5ddc682388a15cf":["203e3fcf513c02ee2c07015f2ce277e26dc60907"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}