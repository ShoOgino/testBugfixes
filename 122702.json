{"path":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#abort().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#abort().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriterPerThread#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  void abort() throws IOException {\n    hasAborted = aborting = true;\n    try {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"now abort\");\n      }\n      try {\n        consumer.abort();\n      } catch (Throwable t) {\n      }\n\n      pendingDeletes.clear();\n      deleteSlice = deleteQueue.newSlice();\n      // Reset all postings data\n      doAfterFlush();\n\n    } finally {\n      aborting = false;\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"done abort\");\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  void abort() throws IOException {\n    hasAborted = aborting = true;\n    try {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"now abort\");\n      }\n      try {\n        consumer.abort();\n      } catch (Throwable t) {\n      }\n\n      pendingDeletes.clear();\n      deleteSlice = deleteQueue.newSlice();\n      // Reset all postings data\n      doAfterFlush();\n\n    } finally {\n      aborting = false;\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"done abort\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#abort().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  void abort() {\n    hasAborted = aborting = true;\n    try {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"now abort\");\n      }\n      try {\n        consumer.abort();\n      } catch (Throwable t) {\n      }\n\n      pendingDeletes.clear();\n      deleteSlice = deleteQueue.newSlice();\n      // Reset all postings data\n      doAfterFlush();\n\n    } finally {\n      aborting = false;\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"done abort\");\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  void abort() throws IOException {\n    hasAborted = aborting = true;\n    try {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"now abort\");\n      }\n      try {\n        consumer.abort();\n      } catch (Throwable t) {\n      }\n\n      pendingDeletes.clear();\n      deleteSlice = deleteQueue.newSlice();\n      // Reset all postings data\n      doAfterFlush();\n\n    } finally {\n      aborting = false;\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"done abort\");\n      }\n    }\n  }\n\n","bugFix":["6c18273ea5b3974d2f30117f46f1ae416c28f727"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#abort().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  void abort() {\n    hasAborted = aborting = true;\n    try {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"now abort\");\n      }\n      try {\n        consumer.abort();\n      } catch (Throwable t) {\n      }\n\n      pendingDeletes.clear();\n      deleteSlice = deleteQueue.newSlice();\n      // Reset all postings data\n      doAfterFlush();\n\n    } finally {\n      aborting = false;\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"done abort\");\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  void abort() throws IOException {\n    hasAborted = aborting = true;\n    try {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"now abort\");\n      }\n      try {\n        consumer.abort();\n      } catch (Throwable t) {\n      }\n\n      pendingDeletes.clear();\n      deleteSlice = deleteQueue.newSlice();\n      // Reset all postings data\n      doAfterFlush();\n\n    } finally {\n      aborting = false;\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"done abort\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9eae2a56dc810a17cf807d831f720dec931a03de","date":1349262073,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#abort().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  void abort() {\n    //System.out.println(Thread.currentThread().getName() + \": now abort seg=\" + segmentInfo.name);\n    hasAborted = aborting = true;\n    try {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"now abort\");\n      }\n      try {\n        consumer.abort();\n      } catch (Throwable t) {\n      }\n\n      pendingDeletes.clear();\n      deleteSlice = deleteQueue.newSlice();\n      // Reset all postings data\n      doAfterFlush();\n\n    } finally {\n      aborting = false;\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"done abort\");\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  void abort() {\n    hasAborted = aborting = true;\n    try {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"now abort\");\n      }\n      try {\n        consumer.abort();\n      } catch (Throwable t) {\n      }\n\n      pendingDeletes.clear();\n      deleteSlice = deleteQueue.newSlice();\n      // Reset all postings data\n      doAfterFlush();\n\n    } finally {\n      aborting = false;\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"done abort\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7af110b00ea8df9429309d83e38e0533d82e144f","date":1376924768,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#abort(Set[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  void abort(Set<String> createdFiles) {\n    //System.out.println(Thread.currentThread().getName() + \": now abort seg=\" + segmentInfo.name);\n    hasAborted = aborting = true;\n    try {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"now abort\");\n      }\n      try {\n        consumer.abort();\n      } catch (Throwable t) {\n      }\n\n      pendingDeletes.clear();\n      createdFiles.addAll(directory.getCreatedFiles());\n    } finally {\n      aborting = false;\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"done abort\");\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  void abort() {\n    //System.out.println(Thread.currentThread().getName() + \": now abort seg=\" + segmentInfo.name);\n    hasAborted = aborting = true;\n    try {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"now abort\");\n      }\n      try {\n        consumer.abort();\n      } catch (Throwable t) {\n      }\n\n      pendingDeletes.clear();\n      deleteSlice = deleteQueue.newSlice();\n      // Reset all postings data\n      doAfterFlush();\n\n    } finally {\n      aborting = false;\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"done abort\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31d4861802ca404d78ca1d15f4550eec415b9199","date":1376947894,"type":5,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#abort(Set[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  void abort(Set<String> createdFiles) {\n    //System.out.println(Thread.currentThread().getName() + \": now abort seg=\" + segmentInfo.name);\n    hasAborted = aborting = true;\n    try {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"now abort\");\n      }\n      try {\n        consumer.abort();\n      } catch (Throwable t) {\n      }\n\n      pendingDeletes.clear();\n      createdFiles.addAll(directory.getCreatedFiles());\n    } finally {\n      aborting = false;\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"done abort\");\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  void abort() {\n    //System.out.println(Thread.currentThread().getName() + \": now abort seg=\" + segmentInfo.name);\n    hasAborted = aborting = true;\n    try {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"now abort\");\n      }\n      try {\n        consumer.abort();\n      } catch (Throwable t) {\n      }\n\n      pendingDeletes.clear();\n      deleteSlice = deleteQueue.newSlice();\n      // Reset all postings data\n      doAfterFlush();\n\n    } finally {\n      aborting = false;\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"done abort\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":4,"author":"Han Jiang","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#abort().mjava","sourceNew":null,"sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  void abort() {\n    //System.out.println(Thread.currentThread().getName() + \": now abort seg=\" + segmentInfo.name);\n    hasAborted = aborting = true;\n    try {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"now abort\");\n      }\n      try {\n        consumer.abort();\n      } catch (Throwable t) {\n      }\n\n      pendingDeletes.clear();\n      deleteSlice = deleteQueue.newSlice();\n      // Reset all postings data\n      doAfterFlush();\n\n    } finally {\n      aborting = false;\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"done abort\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9299079153fd7895bf3cf6835cf7019af2ba89b3","date":1417813477,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#abort().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#abort(Set[String]).mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  void abort() {\n    //System.out.println(Thread.currentThread().getName() + \": now abort seg=\" + segmentInfo.name);\n    aborted = true;\n    try {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"now abort\");\n      }\n      try {\n        consumer.abort();\n      } catch (Throwable t) {\n      }\n\n      pendingUpdates.clear();\n    } finally {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"done abort\");\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  void abort(Set<String> createdFiles) {\n    //System.out.println(Thread.currentThread().getName() + \": now abort seg=\" + segmentInfo.name);\n    hasAborted = aborting = true;\n    try {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"now abort\");\n      }\n      try {\n        consumer.abort();\n      } catch (Throwable t) {\n      }\n\n      pendingUpdates.clear();\n      createdFiles.addAll(directory.getCreatedFiles());\n    } finally {\n      aborting = false;\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"done abort\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef","date":1512420564,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#abort().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  void abort() {\n    //System.out.println(Thread.currentThread().getName() + \": now abort seg=\" + segmentInfo.name);\n    aborted = true;\n    pendingNumDocs.addAndGet(-numDocsInRAM);\n    try {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"now abort\");\n      }\n      try {\n        consumer.abort();\n      } catch (Throwable t) {\n      }\n\n      pendingUpdates.clear();\n    } finally {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"done abort\");\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  void abort() {\n    //System.out.println(Thread.currentThread().getName() + \": now abort seg=\" + segmentInfo.name);\n    aborted = true;\n    try {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"now abort\");\n      }\n      try {\n        consumer.abort();\n      } catch (Throwable t) {\n      }\n\n      pendingUpdates.clear();\n    } finally {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"done abort\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"845b760a99e5f369fcd0a5d723a87b8def6a3f56","date":1521117993,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#abort().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  void abort() {\n    //System.out.println(Thread.currentThread().getName() + \": now abort seg=\" + segmentInfo.name);\n    aborted = true;\n    pendingNumDocs.addAndGet(-numDocsInRAM);\n    try {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"now abort\");\n      }\n      try {\n        consumer.abort();\n      } finally {\n        pendingUpdates.clear();\n      }\n    } finally {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"done abort\");\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  void abort() {\n    //System.out.println(Thread.currentThread().getName() + \": now abort seg=\" + segmentInfo.name);\n    aborted = true;\n    pendingNumDocs.addAndGet(-numDocsInRAM);\n    try {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"now abort\");\n      }\n      try {\n        consumer.abort();\n      } catch (Throwable t) {\n      }\n\n      pendingUpdates.clear();\n    } finally {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"done abort\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab08f09eb919a4eea12a75333606380199db57b1","date":1521493705,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#abort().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  void abort() throws IOException{\n    aborted = true;\n    pendingNumDocs.addAndGet(-numDocsInRAM);\n    try {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"now abort\");\n      }\n      try {\n        consumer.abort();\n      } finally {\n        pendingUpdates.clear();\n      }\n    } finally {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"done abort\");\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  void abort() {\n    //System.out.println(Thread.currentThread().getName() + \": now abort seg=\" + segmentInfo.name);\n    aborted = true;\n    pendingNumDocs.addAndGet(-numDocsInRAM);\n    try {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"now abort\");\n      }\n      try {\n        consumer.abort();\n      } finally {\n        pendingUpdates.clear();\n      }\n    } finally {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"done abort\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43","date":1521731438,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#abort().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  void abort() throws IOException{\n    aborted = true;\n    pendingNumDocs.addAndGet(-numDocsInRAM);\n    try {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"now abort\");\n      }\n      try {\n        consumer.abort();\n      } finally {\n        pendingUpdates.clear();\n      }\n    } finally {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"done abort\");\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  void abort() {\n    //System.out.println(Thread.currentThread().getName() + \": now abort seg=\" + segmentInfo.name);\n    aborted = true;\n    pendingNumDocs.addAndGet(-numDocsInRAM);\n    try {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"now abort\");\n      }\n      try {\n        consumer.abort();\n      } finally {\n        pendingUpdates.clear();\n      }\n    } finally {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"done abort\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a6f8af01d9b3067b143bbdc0a492720e2af97cf","date":1600157724,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#abort().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  void abort() throws IOException{\n    aborted = true;\n    pendingNumDocs.addAndGet(-numDocsInRAM);\n    try {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"now abort\");\n      }\n      try {\n        indexingChain.abort();\n      } finally {\n        pendingUpdates.clear();\n      }\n    } finally {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"done abort\");\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  void abort() throws IOException{\n    aborted = true;\n    pendingNumDocs.addAndGet(-numDocsInRAM);\n    try {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"now abort\");\n      }\n      try {\n        consumer.abort();\n      } finally {\n        pendingUpdates.clear();\n      }\n    } finally {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"done abort\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"680b6449f09827f58fe987aff279e014c311d966","date":1600247985,"type":3,"author":"noblepaul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#abort().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread#abort().mjava","sourceNew":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  void abort() throws IOException{\n    aborted = true;\n    pendingNumDocs.addAndGet(-numDocsInRAM);\n    try {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"now abort\");\n      }\n      try {\n        indexingChain.abort();\n      } finally {\n        pendingUpdates.clear();\n      }\n    } finally {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"done abort\");\n      }\n    }\n  }\n\n","sourceOld":"  /** Called if we hit an exception at a bad time (when\n   *  updating the index files) and must discard all\n   *  currently buffered docs.  This resets our state,\n   *  discarding any docs added since last flush. */\n  void abort() throws IOException{\n    aborted = true;\n    pendingNumDocs.addAndGet(-numDocsInRAM);\n    try {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"now abort\");\n      }\n      try {\n        consumer.abort();\n      } finally {\n        pendingUpdates.clear();\n      }\n    } finally {\n      if (infoStream.isEnabled(\"DWPT\")) {\n        infoStream.message(\"DWPT\", \"done abort\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43":["845b760a99e5f369fcd0a5d723a87b8def6a3f56","ab08f09eb919a4eea12a75333606380199db57b1"],"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef"],"7af110b00ea8df9429309d83e38e0533d82e144f":["9eae2a56dc810a17cf807d831f720dec931a03de"],"7a6f8af01d9b3067b143bbdc0a492720e2af97cf":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43"],"9eae2a56dc810a17cf807d831f720dec931a03de":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"ab08f09eb919a4eea12a75333606380199db57b1":["845b760a99e5f369fcd0a5d723a87b8def6a3f56"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["9eae2a56dc810a17cf807d831f720dec931a03de","7af110b00ea8df9429309d83e38e0533d82e144f"],"31d4861802ca404d78ca1d15f4550eec415b9199":["9eae2a56dc810a17cf807d831f720dec931a03de","7af110b00ea8df9429309d83e38e0533d82e144f"],"680b6449f09827f58fe987aff279e014c311d966":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43","7a6f8af01d9b3067b143bbdc0a492720e2af97cf"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9299079153fd7895bf3cf6835cf7019af2ba89b3":["7af110b00ea8df9429309d83e38e0533d82e144f"],"fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef":["9299079153fd7895bf3cf6835cf7019af2ba89b3"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["680b6449f09827f58fe987aff279e014c311d966"]},"commit2Childs":{"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43":["7a6f8af01d9b3067b143bbdc0a492720e2af97cf","680b6449f09827f58fe987aff279e014c311d966"],"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43","ab08f09eb919a4eea12a75333606380199db57b1"],"7af110b00ea8df9429309d83e38e0533d82e144f":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199","9299079153fd7895bf3cf6835cf7019af2ba89b3"],"7a6f8af01d9b3067b143bbdc0a492720e2af97cf":["680b6449f09827f58fe987aff279e014c311d966"],"ab08f09eb919a4eea12a75333606380199db57b1":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43"],"9eae2a56dc810a17cf807d831f720dec931a03de":["7af110b00ea8df9429309d83e38e0533d82e144f","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["fe33227f6805edab2036cbb80645cc4e2d1fa424","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"31d4861802ca404d78ca1d15f4550eec415b9199":[],"680b6449f09827f58fe987aff279e014c311d966":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"9299079153fd7895bf3cf6835cf7019af2ba89b3":["fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef"],"fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef":["845b760a99e5f369fcd0a5d723a87b8def6a3f56"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["9eae2a56dc810a17cf807d831f720dec931a03de","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}