{"path":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","commits":[{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","pathOld":"solr/contrib/clustering/src/main/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","sourceNew":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleField = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetField = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleField);\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary == true) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = Maps.newHashMap();\n        snippetFieldAry = new String[]{snippetField};\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<Document>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = getValue(sdoc, snippetField);\n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {//should only be one value given our setup\n          //should only be one document with one field\n          @SuppressWarnings(\"unchecked\")\n\t\t\t\t\tNamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          String [] highlt = tmp.get(snippetField);\n          if (highlt != null && highlt.length == 1) {\n            snippet = highlt[0];\n          }\n        }\n      }\n      Document carrotDocument = new Document(getValue(sdoc, titleField),\n              snippet, (String)sdoc.getFieldValue(urlField));\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleField = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetField = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleField);\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary == true) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = Maps.newHashMap();\n        snippetFieldAry = new String[]{snippetField};\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<Document>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = getValue(sdoc, snippetField);\n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {//should only be one value given our setup\n          //should only be one document with one field\n          @SuppressWarnings(\"unchecked\")\n\t\t\t\t\tNamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          String [] highlt = tmp.get(snippetField);\n          if (highlt != null && highlt.length == 1) {\n            snippet = highlt[0];\n          }\n        }\n      }\n      Document carrotDocument = new Document(getValue(sdoc, titleField),\n              snippet, (String)sdoc.getFieldValue(urlField));\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","pathOld":"solr/contrib/clustering/src/main/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","sourceNew":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleField = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetField = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleField);\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary == true) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = Maps.newHashMap();\n        snippetFieldAry = new String[]{snippetField};\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<Document>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = getValue(sdoc, snippetField);\n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {//should only be one value given our setup\n          //should only be one document with one field\n          @SuppressWarnings(\"unchecked\")\n\t\t\t\t\tNamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          String [] highlt = tmp.get(snippetField);\n          if (highlt != null && highlt.length == 1) {\n            snippet = highlt[0];\n          }\n        }\n      }\n      Document carrotDocument = new Document(getValue(sdoc, titleField),\n              snippet, (String)sdoc.getFieldValue(urlField));\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleField = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetField = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleField);\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary == true) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = Maps.newHashMap();\n        snippetFieldAry = new String[]{snippetField};\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<Document>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = getValue(sdoc, snippetField);\n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {//should only be one value given our setup\n          //should only be one document with one field\n          @SuppressWarnings(\"unchecked\")\n\t\t\t\t\tNamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          String [] highlt = tmp.get(snippetField);\n          if (highlt != null && highlt.length == 1) {\n            snippet = highlt[0];\n          }\n        }\n      }\n      Document carrotDocument = new Document(getValue(sdoc, titleField),\n              snippet, (String)sdoc.getFieldValue(urlField));\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c5b0f07c6835b1a381980a03c88fbb4e41c4532","date":1312362519,"type":3,"author":"Stanisław Osiński","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","sourceNew":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleField = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetField = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleField);\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = Maps.newHashMap();\n        snippetFieldAry = new String[]{snippetField};\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<Document>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = getValue(sdoc, snippetField);\n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {//should only be one value given our setup\n          //should only be one document with one field\n          @SuppressWarnings(\"unchecked\")\n\t\t\t\t\tNamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          String [] highlt = tmp.get(snippetField);\n          if (highlt != null && highlt.length == 1) {\n            snippet = highlt[0];\n          }\n        }\n      }\n      Document carrotDocument = new Document(getValue(sdoc, titleField),\n              snippet, (String)sdoc.getFieldValue(urlField));\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleField = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetField = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleField);\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary == true) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = Maps.newHashMap();\n        snippetFieldAry = new String[]{snippetField};\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<Document>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = getValue(sdoc, snippetField);\n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {//should only be one value given our setup\n          //should only be one document with one field\n          @SuppressWarnings(\"unchecked\")\n\t\t\t\t\tNamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          String [] highlt = tmp.get(snippetField);\n          if (highlt != null && highlt.length == 1) {\n            snippet = highlt[0];\n          }\n        }\n      }\n      Document carrotDocument = new Document(getValue(sdoc, titleField),\n              snippet, (String)sdoc.getFieldValue(urlField));\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","bugFix":["d2771e5f68dda632a1044fdfecbc7bffae0a4ea8"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ef9e7ba08c124ce913ef60415c21ae1ca833d211","date":1323446079,"type":3,"author":"Stanisław Osiński","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","sourceNew":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleField = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetField = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleField);\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = Maps.newHashMap();\n        snippetFieldAry = new String[]{snippetField};\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<Document>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = getValue(sdoc, snippetField);\n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {//should only be one value given our setup\n          //should only be one document with one field\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          String [] highlt = tmp.get(snippetField);\n          if (highlt != null && highlt.length == 1) {\n            snippet = highlt[0];\n          }\n        }\n      }\n      Document carrotDocument = new Document(getValue(sdoc, titleField),\n              snippet, (String)sdoc.getFieldValue(urlField));\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleField = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetField = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleField);\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = Maps.newHashMap();\n        snippetFieldAry = new String[]{snippetField};\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<Document>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = getValue(sdoc, snippetField);\n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {//should only be one value given our setup\n          //should only be one document with one field\n          @SuppressWarnings(\"unchecked\")\n\t\t\t\t\tNamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          String [] highlt = tmp.get(snippetField);\n          if (highlt != null && highlt.length == 1) {\n            snippet = highlt[0];\n          }\n        }\n      }\n      Document carrotDocument = new Document(getValue(sdoc, titleField),\n              snippet, (String)sdoc.getFieldValue(urlField));\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3b0bf71278457cb04b0666bf73b8aa71d36be8c4","date":1323446256,"type":3,"author":"Stanisław Osiński","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","sourceNew":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleField = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetField = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleField);\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = Maps.newHashMap();\n        snippetFieldAry = new String[]{snippetField};\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        args.put(HighlightParams.SNIPPETS, solrParams.getInt(CarrotParams.SUMMARY_SNIPPETS, solrParams.getInt(HighlightParams.SNIPPETS, 1)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<Document>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = getValue(sdoc, snippetField);\n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {//should only be one value given our setup\n          //should only be one document with one field\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          String [] highlt = tmp.get(snippetField);\n          \n          // Join fragments with a period, so that Carrot2 does not create\n          // cross-fragment phrases, such phrases rarely make sense.\n          if (highlt != null && highlt.length > 0) {\n            final StringBuilder sb = new StringBuilder(highlt[0]);\n            for (int i = 1; i < highlt.length; i++) {\n              sb.append(\" . \");\n              sb.append(highlt[i]);\n            }\n            snippet = sb.toString();\n          }\n        }\n      }\n      Document carrotDocument = new Document(getValue(sdoc, titleField),\n              snippet, (String)sdoc.getFieldValue(urlField));\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleField = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetField = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleField);\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = Maps.newHashMap();\n        snippetFieldAry = new String[]{snippetField};\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<Document>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = getValue(sdoc, snippetField);\n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {//should only be one value given our setup\n          //should only be one document with one field\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          String [] highlt = tmp.get(snippetField);\n          if (highlt != null && highlt.length == 1) {\n            snippet = highlt[0];\n          }\n        }\n      }\n      Document carrotDocument = new Document(getValue(sdoc, titleField),\n              snippet, (String)sdoc.getFieldValue(urlField));\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f25fe5576647e3bdd2a797a9900982532d5e2e97","date":1323446322,"type":3,"author":"Stanisław Osiński","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","sourceNew":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleFieldSpec = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetFieldSpec = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleFieldSpec);\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = Maps.newHashMap();\n        snippetFieldAry = snippetFieldSpec.split(\"[, ]\");\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        args.put(HighlightParams.SNIPPETS, solrParams.getInt(CarrotParams.SUMMARY_SNIPPETS, solrParams.getInt(HighlightParams.SNIPPETS, 1)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<Document>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = null;\n      \n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {//should only be one value given our setup\n          //should only be one document\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          \n          final StringBuilder sb = new StringBuilder();\n          for (int j = 0; j < snippetFieldAry.length; j++) {\n            // Join fragments with a period, so that Carrot2 does not create\n            // cross-fragment phrases, such phrases rarely make sense.\n            String [] highlt = tmp.get(snippetFieldAry[j]);\n            if (highlt != null && highlt.length > 0) {\n              for (int i = 0; i < highlt.length; i++) {\n                sb.append(highlt[i]);\n                sb.append(\" . \");\n              }\n            }\n          }\n          snippet = sb.toString();\n        }\n      }\n      \n      // If summaries not enabled or summary generation failed, use full content.\n      if (snippet == null) {\n        snippet = getConcatenated(sdoc, snippetFieldSpec);\n      }\n      \n      Document carrotDocument = new Document(getConcatenated(sdoc, titleFieldSpec),\n              snippet, (String)sdoc.getFieldValue(urlField));\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleField = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetField = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleField);\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = Maps.newHashMap();\n        snippetFieldAry = new String[]{snippetField};\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        args.put(HighlightParams.SNIPPETS, solrParams.getInt(CarrotParams.SUMMARY_SNIPPETS, solrParams.getInt(HighlightParams.SNIPPETS, 1)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<Document>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = getValue(sdoc, snippetField);\n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {//should only be one value given our setup\n          //should only be one document with one field\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          String [] highlt = tmp.get(snippetField);\n          \n          // Join fragments with a period, so that Carrot2 does not create\n          // cross-fragment phrases, such phrases rarely make sense.\n          if (highlt != null && highlt.length > 0) {\n            final StringBuilder sb = new StringBuilder(highlt[0]);\n            for (int i = 1; i < highlt.length; i++) {\n              sb.append(\" . \");\n              sb.append(highlt[i]);\n            }\n            snippet = sb.toString();\n          }\n        }\n      }\n      Document carrotDocument = new Document(getValue(sdoc, titleField),\n              snippet, (String)sdoc.getFieldValue(urlField));\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"57123f858a48ace813624f9da70ca12bd803571f","date":1323446440,"type":3,"author":"Stanisław Osiński","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","sourceNew":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleFieldSpec = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetFieldSpec = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleFieldSpec);\n    String languageField = solrParams.get(CarrotParams.LANGUAGE_FIELD_NAME, null);\n\n    // Parse language code map string into a map\n    Map<String, String> languageCodeMap = Maps.newHashMap();\n    if (StringUtils.isNotBlank(languageField)) {\n      for (String pair : solrParams.get(CarrotParams.LANGUAGE_CODE_MAP, \"\")\n          .split(\"[, ]\")) {\n        final String[] split = pair.split(\":\");\n        if (split.length == 2 && StringUtils.isNotBlank(split[0]) && StringUtils.isNotBlank(split[1])) {\n          languageCodeMap.put(split[0], split[1]);\n        } else {\n          log.warn(\"Unsupported format for \" + CarrotParams.LANGUAGE_CODE_MAP\n              + \": '\" + pair + \"'. Skipping this mapping.\");\n        }\n      }\n    }\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = Maps.newHashMap();\n        snippetFieldAry = snippetFieldSpec.split(\"[, ]\");\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        args.put(HighlightParams.SNIPPETS, solrParams.getInt(CarrotParams.SUMMARY_SNIPPETS, solrParams.getInt(HighlightParams.SNIPPETS, 1)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<Document>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = null;\n      \n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {//should only be one value given our setup\n          //should only be one document\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          \n          final StringBuilder sb = new StringBuilder();\n          for (int j = 0; j < snippetFieldAry.length; j++) {\n            // Join fragments with a period, so that Carrot2 does not create\n            // cross-fragment phrases, such phrases rarely make sense.\n            String [] highlt = tmp.get(snippetFieldAry[j]);\n            if (highlt != null && highlt.length > 0) {\n              for (int i = 0; i < highlt.length; i++) {\n                sb.append(highlt[i]);\n                sb.append(\" . \");\n              }\n            }\n          }\n          snippet = sb.toString();\n        }\n      }\n      \n      // If summaries not enabled or summary generation failed, use full content.\n      if (snippet == null) {\n        snippet = getConcatenated(sdoc, snippetFieldSpec);\n      }\n      \n      // Create a Carrot2 document\n      Document carrotDocument = new Document(getConcatenated(sdoc, titleFieldSpec),\n              snippet, (String)sdoc.getFieldValue(urlField));\n      \n      // Store Solr id of the document, we need it to map document instances \n      // found in clusters back to identifiers.\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      \n      // Set language\n      if (StringUtils.isNotBlank(languageField)) {\n        Collection<Object> languages = sdoc.getFieldValues(languageField);\n        if (languages != null) {\n          \n          // Use the first Carrot2-supported language\n          for (Object l : languages) {\n            String lang = ObjectUtils.toString(l, \"\");\n            \n            if (languageCodeMap.containsKey(lang)) {\n              lang = languageCodeMap.get(lang);\n            }\n            \n            // Language detection Library for Java uses dashes to separate\n            // language variants, such as 'zh-cn', but Carrot2 uses underscores.\n            if (lang.indexOf('-') > 0) {\n              lang = lang.replace('-', '_');\n            }\n            \n            // If the language is supported by Carrot2, we'll get a non-null value\n            final LanguageCode carrot2Language = LanguageCode.forISOCode(lang);\n            if (carrot2Language != null) {\n              carrotDocument.setLanguage(carrot2Language);\n              break;\n            }\n          }\n        }\n      }\n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleFieldSpec = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetFieldSpec = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleFieldSpec);\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = Maps.newHashMap();\n        snippetFieldAry = snippetFieldSpec.split(\"[, ]\");\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        args.put(HighlightParams.SNIPPETS, solrParams.getInt(CarrotParams.SUMMARY_SNIPPETS, solrParams.getInt(HighlightParams.SNIPPETS, 1)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<Document>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = null;\n      \n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {//should only be one value given our setup\n          //should only be one document\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          \n          final StringBuilder sb = new StringBuilder();\n          for (int j = 0; j < snippetFieldAry.length; j++) {\n            // Join fragments with a period, so that Carrot2 does not create\n            // cross-fragment phrases, such phrases rarely make sense.\n            String [] highlt = tmp.get(snippetFieldAry[j]);\n            if (highlt != null && highlt.length > 0) {\n              for (int i = 0; i < highlt.length; i++) {\n                sb.append(highlt[i]);\n                sb.append(\" . \");\n              }\n            }\n          }\n          snippet = sb.toString();\n        }\n      }\n      \n      // If summaries not enabled or summary generation failed, use full content.\n      if (snippet == null) {\n        snippet = getConcatenated(sdoc, snippetFieldSpec);\n      }\n      \n      Document carrotDocument = new Document(getConcatenated(sdoc, titleFieldSpec),\n              snippet, (String)sdoc.getFieldValue(urlField));\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74acabcbc6eae18c349c56bd385f9e42433afca3","date":1323446529,"type":3,"author":"Stanisław Osiński","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","sourceNew":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleFieldSpec = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetFieldSpec = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleFieldSpec);\n    String languageField = solrParams.get(CarrotParams.LANGUAGE_FIELD_NAME, null);\n    \n    // Maps Solr field names to Carrot2 custom field names\n    Map<String, String> customFields = null;\n    String [] customFieldsSpec = solrParams.getParams(CarrotParams.CUSTOM_FIELD_NAME);\n    if (customFieldsSpec != null) {\n      customFields = Maps.newHashMap();\n      for (String customFieldSpec : customFieldsSpec) {\n        String [] split = customFieldSpec.split(\":\"); \n        if (split.length == 2 && StringUtils.isNotBlank(split[0]) && StringUtils.isNotBlank(split[1])) {\n          customFields.put(split[0], split[1]);\n        } else {\n          log.warn(\"Unsupported format for \" + CarrotParams.CUSTOM_FIELD_NAME\n              + \": '\" + customFieldSpec + \"'. Skipping this field definition.\");\n        }\n      }\n    }\n\n    // Parse language code map string into a map\n    Map<String, String> languageCodeMap = Maps.newHashMap();\n    if (StringUtils.isNotBlank(languageField)) {\n      for (String pair : solrParams.get(CarrotParams.LANGUAGE_CODE_MAP, \"\")\n          .split(\"[, ]\")) {\n        final String[] split = pair.split(\":\");\n        if (split.length == 2 && StringUtils.isNotBlank(split[0]) && StringUtils.isNotBlank(split[1])) {\n          languageCodeMap.put(split[0], split[1]);\n        } else {\n          log.warn(\"Unsupported format for \" + CarrotParams.LANGUAGE_CODE_MAP\n              + \": '\" + pair + \"'. Skipping this mapping.\");\n        }\n      }\n    }\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = Maps.newHashMap();\n        snippetFieldAry = snippetFieldSpec.split(\"[, ]\");\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        args.put(HighlightParams.SNIPPETS, solrParams.getInt(CarrotParams.SUMMARY_SNIPPETS, solrParams.getInt(HighlightParams.SNIPPETS, 1)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<Document>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = null;\n      \n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {//should only be one value given our setup\n          //should only be one document\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          \n          final StringBuilder sb = new StringBuilder();\n          for (int j = 0; j < snippetFieldAry.length; j++) {\n            // Join fragments with a period, so that Carrot2 does not create\n            // cross-fragment phrases, such phrases rarely make sense.\n            String [] highlt = tmp.get(snippetFieldAry[j]);\n            if (highlt != null && highlt.length > 0) {\n              for (int i = 0; i < highlt.length; i++) {\n                sb.append(highlt[i]);\n                sb.append(\" . \");\n              }\n            }\n          }\n          snippet = sb.toString();\n        }\n      }\n      \n      // If summaries not enabled or summary generation failed, use full content.\n      if (snippet == null) {\n        snippet = getConcatenated(sdoc, snippetFieldSpec);\n      }\n      \n      // Create a Carrot2 document\n      Document carrotDocument = new Document(getConcatenated(sdoc, titleFieldSpec),\n              snippet, (String)sdoc.getFieldValue(urlField));\n      \n      // Store Solr id of the document, we need it to map document instances \n      // found in clusters back to identifiers.\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      \n      // Set language\n      if (StringUtils.isNotBlank(languageField)) {\n        Collection<Object> languages = sdoc.getFieldValues(languageField);\n        if (languages != null) {\n          \n          // Use the first Carrot2-supported language\n          for (Object l : languages) {\n            String lang = ObjectUtils.toString(l, \"\");\n            \n            if (languageCodeMap.containsKey(lang)) {\n              lang = languageCodeMap.get(lang);\n            }\n            \n            // Language detection Library for Java uses dashes to separate\n            // language variants, such as 'zh-cn', but Carrot2 uses underscores.\n            if (lang.indexOf('-') > 0) {\n              lang = lang.replace('-', '_');\n            }\n            \n            // If the language is supported by Carrot2, we'll get a non-null value\n            final LanguageCode carrot2Language = LanguageCode.forISOCode(lang);\n            if (carrot2Language != null) {\n              carrotDocument.setLanguage(carrot2Language);\n              break;\n            }\n          }\n        }\n      }\n      \n      // Add custom fields\n      if (customFields != null) {\n        for (Entry<String, String> entry : customFields.entrySet()) {\n          carrotDocument.setField(entry.getValue(), sdoc.getFieldValue(entry.getKey()));\n        }\n      }\n      \n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleFieldSpec = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetFieldSpec = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleFieldSpec);\n    String languageField = solrParams.get(CarrotParams.LANGUAGE_FIELD_NAME, null);\n\n    // Parse language code map string into a map\n    Map<String, String> languageCodeMap = Maps.newHashMap();\n    if (StringUtils.isNotBlank(languageField)) {\n      for (String pair : solrParams.get(CarrotParams.LANGUAGE_CODE_MAP, \"\")\n          .split(\"[, ]\")) {\n        final String[] split = pair.split(\":\");\n        if (split.length == 2 && StringUtils.isNotBlank(split[0]) && StringUtils.isNotBlank(split[1])) {\n          languageCodeMap.put(split[0], split[1]);\n        } else {\n          log.warn(\"Unsupported format for \" + CarrotParams.LANGUAGE_CODE_MAP\n              + \": '\" + pair + \"'. Skipping this mapping.\");\n        }\n      }\n    }\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = Maps.newHashMap();\n        snippetFieldAry = snippetFieldSpec.split(\"[, ]\");\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        args.put(HighlightParams.SNIPPETS, solrParams.getInt(CarrotParams.SUMMARY_SNIPPETS, solrParams.getInt(HighlightParams.SNIPPETS, 1)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<Document>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = null;\n      \n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {//should only be one value given our setup\n          //should only be one document\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          \n          final StringBuilder sb = new StringBuilder();\n          for (int j = 0; j < snippetFieldAry.length; j++) {\n            // Join fragments with a period, so that Carrot2 does not create\n            // cross-fragment phrases, such phrases rarely make sense.\n            String [] highlt = tmp.get(snippetFieldAry[j]);\n            if (highlt != null && highlt.length > 0) {\n              for (int i = 0; i < highlt.length; i++) {\n                sb.append(highlt[i]);\n                sb.append(\" . \");\n              }\n            }\n          }\n          snippet = sb.toString();\n        }\n      }\n      \n      // If summaries not enabled or summary generation failed, use full content.\n      if (snippet == null) {\n        snippet = getConcatenated(sdoc, snippetFieldSpec);\n      }\n      \n      // Create a Carrot2 document\n      Document carrotDocument = new Document(getConcatenated(sdoc, titleFieldSpec),\n              snippet, (String)sdoc.getFieldValue(urlField));\n      \n      // Store Solr id of the document, we need it to map document instances \n      // found in clusters back to identifiers.\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      \n      // Set language\n      if (StringUtils.isNotBlank(languageField)) {\n        Collection<Object> languages = sdoc.getFieldValues(languageField);\n        if (languages != null) {\n          \n          // Use the first Carrot2-supported language\n          for (Object l : languages) {\n            String lang = ObjectUtils.toString(l, \"\");\n            \n            if (languageCodeMap.containsKey(lang)) {\n              lang = languageCodeMap.get(lang);\n            }\n            \n            // Language detection Library for Java uses dashes to separate\n            // language variants, such as 'zh-cn', but Carrot2 uses underscores.\n            if (lang.indexOf('-') > 0) {\n              lang = lang.replace('-', '_');\n            }\n            \n            // If the language is supported by Carrot2, we'll get a non-null value\n            final LanguageCode carrot2Language = LanguageCode.forISOCode(lang);\n            if (carrot2Language != null) {\n              carrotDocument.setLanguage(carrot2Language);\n              break;\n            }\n          }\n        }\n      }\n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e6d9348a7814f90f24c043aa0d0109adc467a48a","date":1323446657,"type":3,"author":"Stanisław Osiński","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","sourceNew":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleFieldSpec = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetFieldSpec = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleFieldSpec);\n    String languageField = solrParams.get(CarrotParams.LANGUAGE_FIELD_NAME, null);\n    \n    // Maps Solr field names to Carrot2 custom field names\n    Map<String, String> customFields = getCustomFieldsMap(solrParams);\n\n    // Parse language code map string into a map\n    Map<String, String> languageCodeMap = Maps.newHashMap();\n    if (StringUtils.isNotBlank(languageField)) {\n      for (String pair : solrParams.get(CarrotParams.LANGUAGE_CODE_MAP, \"\")\n          .split(\"[, ]\")) {\n        final String[] split = pair.split(\":\");\n        if (split.length == 2 && StringUtils.isNotBlank(split[0]) && StringUtils.isNotBlank(split[1])) {\n          languageCodeMap.put(split[0], split[1]);\n        } else {\n          log.warn(\"Unsupported format for \" + CarrotParams.LANGUAGE_CODE_MAP\n              + \": '\" + pair + \"'. Skipping this mapping.\");\n        }\n      }\n    }\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = Maps.newHashMap();\n        snippetFieldAry = snippetFieldSpec.split(\"[, ]\");\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        args.put(HighlightParams.SNIPPETS, solrParams.getInt(CarrotParams.SUMMARY_SNIPPETS, solrParams.getInt(HighlightParams.SNIPPETS, 1)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<Document>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = null;\n      \n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {//should only be one value given our setup\n          //should only be one document\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          \n          final StringBuilder sb = new StringBuilder();\n          for (int j = 0; j < snippetFieldAry.length; j++) {\n            // Join fragments with a period, so that Carrot2 does not create\n            // cross-fragment phrases, such phrases rarely make sense.\n            String [] highlt = tmp.get(snippetFieldAry[j]);\n            if (highlt != null && highlt.length > 0) {\n              for (int i = 0; i < highlt.length; i++) {\n                sb.append(highlt[i]);\n                sb.append(\" . \");\n              }\n            }\n          }\n          snippet = sb.toString();\n        }\n      }\n      \n      // If summaries not enabled or summary generation failed, use full content.\n      if (snippet == null) {\n        snippet = getConcatenated(sdoc, snippetFieldSpec);\n      }\n      \n      // Create a Carrot2 document\n      Document carrotDocument = new Document(getConcatenated(sdoc, titleFieldSpec),\n              snippet, (String)sdoc.getFieldValue(urlField));\n      \n      // Store Solr id of the document, we need it to map document instances \n      // found in clusters back to identifiers.\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      \n      // Set language\n      if (StringUtils.isNotBlank(languageField)) {\n        Collection<Object> languages = sdoc.getFieldValues(languageField);\n        if (languages != null) {\n          \n          // Use the first Carrot2-supported language\n          for (Object l : languages) {\n            String lang = ObjectUtils.toString(l, \"\");\n            \n            if (languageCodeMap.containsKey(lang)) {\n              lang = languageCodeMap.get(lang);\n            }\n            \n            // Language detection Library for Java uses dashes to separate\n            // language variants, such as 'zh-cn', but Carrot2 uses underscores.\n            if (lang.indexOf('-') > 0) {\n              lang = lang.replace('-', '_');\n            }\n            \n            // If the language is supported by Carrot2, we'll get a non-null value\n            final LanguageCode carrot2Language = LanguageCode.forISOCode(lang);\n            if (carrot2Language != null) {\n              carrotDocument.setLanguage(carrot2Language);\n              break;\n            }\n          }\n        }\n      }\n      \n      // Add custom fields\n      if (customFields != null) {\n        for (Entry<String, String> entry : customFields.entrySet()) {\n          carrotDocument.setField(entry.getValue(), sdoc.getFieldValue(entry.getKey()));\n        }\n      }\n      \n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleFieldSpec = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetFieldSpec = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleFieldSpec);\n    String languageField = solrParams.get(CarrotParams.LANGUAGE_FIELD_NAME, null);\n    \n    // Maps Solr field names to Carrot2 custom field names\n    Map<String, String> customFields = null;\n    String [] customFieldsSpec = solrParams.getParams(CarrotParams.CUSTOM_FIELD_NAME);\n    if (customFieldsSpec != null) {\n      customFields = Maps.newHashMap();\n      for (String customFieldSpec : customFieldsSpec) {\n        String [] split = customFieldSpec.split(\":\"); \n        if (split.length == 2 && StringUtils.isNotBlank(split[0]) && StringUtils.isNotBlank(split[1])) {\n          customFields.put(split[0], split[1]);\n        } else {\n          log.warn(\"Unsupported format for \" + CarrotParams.CUSTOM_FIELD_NAME\n              + \": '\" + customFieldSpec + \"'. Skipping this field definition.\");\n        }\n      }\n    }\n\n    // Parse language code map string into a map\n    Map<String, String> languageCodeMap = Maps.newHashMap();\n    if (StringUtils.isNotBlank(languageField)) {\n      for (String pair : solrParams.get(CarrotParams.LANGUAGE_CODE_MAP, \"\")\n          .split(\"[, ]\")) {\n        final String[] split = pair.split(\":\");\n        if (split.length == 2 && StringUtils.isNotBlank(split[0]) && StringUtils.isNotBlank(split[1])) {\n          languageCodeMap.put(split[0], split[1]);\n        } else {\n          log.warn(\"Unsupported format for \" + CarrotParams.LANGUAGE_CODE_MAP\n              + \": '\" + pair + \"'. Skipping this mapping.\");\n        }\n      }\n    }\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = Maps.newHashMap();\n        snippetFieldAry = snippetFieldSpec.split(\"[, ]\");\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        args.put(HighlightParams.SNIPPETS, solrParams.getInt(CarrotParams.SUMMARY_SNIPPETS, solrParams.getInt(HighlightParams.SNIPPETS, 1)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<Document>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = null;\n      \n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {//should only be one value given our setup\n          //should only be one document\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          \n          final StringBuilder sb = new StringBuilder();\n          for (int j = 0; j < snippetFieldAry.length; j++) {\n            // Join fragments with a period, so that Carrot2 does not create\n            // cross-fragment phrases, such phrases rarely make sense.\n            String [] highlt = tmp.get(snippetFieldAry[j]);\n            if (highlt != null && highlt.length > 0) {\n              for (int i = 0; i < highlt.length; i++) {\n                sb.append(highlt[i]);\n                sb.append(\" . \");\n              }\n            }\n          }\n          snippet = sb.toString();\n        }\n      }\n      \n      // If summaries not enabled or summary generation failed, use full content.\n      if (snippet == null) {\n        snippet = getConcatenated(sdoc, snippetFieldSpec);\n      }\n      \n      // Create a Carrot2 document\n      Document carrotDocument = new Document(getConcatenated(sdoc, titleFieldSpec),\n              snippet, (String)sdoc.getFieldValue(urlField));\n      \n      // Store Solr id of the document, we need it to map document instances \n      // found in clusters back to identifiers.\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      \n      // Set language\n      if (StringUtils.isNotBlank(languageField)) {\n        Collection<Object> languages = sdoc.getFieldValues(languageField);\n        if (languages != null) {\n          \n          // Use the first Carrot2-supported language\n          for (Object l : languages) {\n            String lang = ObjectUtils.toString(l, \"\");\n            \n            if (languageCodeMap.containsKey(lang)) {\n              lang = languageCodeMap.get(lang);\n            }\n            \n            // Language detection Library for Java uses dashes to separate\n            // language variants, such as 'zh-cn', but Carrot2 uses underscores.\n            if (lang.indexOf('-') > 0) {\n              lang = lang.replace('-', '_');\n            }\n            \n            // If the language is supported by Carrot2, we'll get a non-null value\n            final LanguageCode carrot2Language = LanguageCode.forISOCode(lang);\n            if (carrot2Language != null) {\n              carrotDocument.setLanguage(carrot2Language);\n              break;\n            }\n          }\n        }\n      }\n      \n      // Add custom fields\n      if (customFields != null) {\n        for (Entry<String, String> entry : customFields.entrySet()) {\n          carrotDocument.setField(entry.getValue(), sdoc.getFieldValue(entry.getKey()));\n        }\n      }\n      \n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3c89f80265f6c2148bf8702b01724ca046efdf07","date":1323446698,"type":3,"author":"Stanisław Osiński","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","sourceNew":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleFieldSpec = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetFieldSpec = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleFieldSpec);\n    String languageField = solrParams.get(CarrotParams.LANGUAGE_FIELD_NAME, null);\n    \n    // Maps Solr field names to Carrot2 custom field names\n    Map<String, String> customFields = getCustomFieldsMap(solrParams);\n\n    // Parse language code map string into a map\n    Map<String, String> languageCodeMap = Maps.newHashMap();\n    if (StringUtils.isNotBlank(languageField)) {\n      for (String pair : solrParams.get(CarrotParams.LANGUAGE_CODE_MAP, \"\")\n          .split(\"[, ]\")) {\n        final String[] split = pair.split(\":\");\n        if (split.length == 2 && StringUtils.isNotBlank(split[0]) && StringUtils.isNotBlank(split[1])) {\n          languageCodeMap.put(split[0], split[1]);\n        } else {\n          log.warn(\"Unsupported format for \" + CarrotParams.LANGUAGE_CODE_MAP\n              + \": '\" + pair + \"'. Skipping this mapping.\");\n        }\n      }\n    }\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = Maps.newHashMap();\n        snippetFieldAry = snippetFieldSpec.split(\"[, ]\");\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        args.put(HighlightParams.SNIPPETS, solrParams.getInt(CarrotParams.SUMMARY_SNIPPETS, solrParams.getInt(HighlightParams.SNIPPETS, 1)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<Document>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = null;\n      \n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {//should only be one value given our setup\n          //should only be one document\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          \n          final StringBuilder sb = new StringBuilder();\n          for (int j = 0; j < snippetFieldAry.length; j++) {\n            // Join fragments with a period, so that Carrot2 does not create\n            // cross-fragment phrases, such phrases rarely make sense.\n            String [] highlt = tmp.get(snippetFieldAry[j]);\n            if (highlt != null && highlt.length > 0) {\n              for (int i = 0; i < highlt.length; i++) {\n                sb.append(highlt[i]);\n                sb.append(\" . \");\n              }\n            }\n          }\n          snippet = sb.toString();\n        }\n      }\n      \n      // If summaries not enabled or summary generation failed, use full content.\n      if (snippet == null) {\n        snippet = getConcatenated(sdoc, snippetFieldSpec);\n      }\n      \n      // Create a Carrot2 document\n      Document carrotDocument = new Document(getConcatenated(sdoc, titleFieldSpec),\n              snippet, ObjectUtils.toString(sdoc.getFieldValue(urlField), \"\"));\n      \n      // Store Solr id of the document, we need it to map document instances \n      // found in clusters back to identifiers.\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      \n      // Set language\n      if (StringUtils.isNotBlank(languageField)) {\n        Collection<Object> languages = sdoc.getFieldValues(languageField);\n        if (languages != null) {\n          \n          // Use the first Carrot2-supported language\n          for (Object l : languages) {\n            String lang = ObjectUtils.toString(l, \"\");\n            \n            if (languageCodeMap.containsKey(lang)) {\n              lang = languageCodeMap.get(lang);\n            }\n            \n            // Language detection Library for Java uses dashes to separate\n            // language variants, such as 'zh-cn', but Carrot2 uses underscores.\n            if (lang.indexOf('-') > 0) {\n              lang = lang.replace('-', '_');\n            }\n            \n            // If the language is supported by Carrot2, we'll get a non-null value\n            final LanguageCode carrot2Language = LanguageCode.forISOCode(lang);\n            if (carrot2Language != null) {\n              carrotDocument.setLanguage(carrot2Language);\n              break;\n            }\n          }\n        }\n      }\n      \n      // Add custom fields\n      if (customFields != null) {\n        for (Entry<String, String> entry : customFields.entrySet()) {\n          carrotDocument.setField(entry.getValue(), sdoc.getFieldValue(entry.getKey()));\n        }\n      }\n      \n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleFieldSpec = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetFieldSpec = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleFieldSpec);\n    String languageField = solrParams.get(CarrotParams.LANGUAGE_FIELD_NAME, null);\n    \n    // Maps Solr field names to Carrot2 custom field names\n    Map<String, String> customFields = getCustomFieldsMap(solrParams);\n\n    // Parse language code map string into a map\n    Map<String, String> languageCodeMap = Maps.newHashMap();\n    if (StringUtils.isNotBlank(languageField)) {\n      for (String pair : solrParams.get(CarrotParams.LANGUAGE_CODE_MAP, \"\")\n          .split(\"[, ]\")) {\n        final String[] split = pair.split(\":\");\n        if (split.length == 2 && StringUtils.isNotBlank(split[0]) && StringUtils.isNotBlank(split[1])) {\n          languageCodeMap.put(split[0], split[1]);\n        } else {\n          log.warn(\"Unsupported format for \" + CarrotParams.LANGUAGE_CODE_MAP\n              + \": '\" + pair + \"'. Skipping this mapping.\");\n        }\n      }\n    }\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = Maps.newHashMap();\n        snippetFieldAry = snippetFieldSpec.split(\"[, ]\");\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        args.put(HighlightParams.SNIPPETS, solrParams.getInt(CarrotParams.SUMMARY_SNIPPETS, solrParams.getInt(HighlightParams.SNIPPETS, 1)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<Document>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = null;\n      \n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {//should only be one value given our setup\n          //should only be one document\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          \n          final StringBuilder sb = new StringBuilder();\n          for (int j = 0; j < snippetFieldAry.length; j++) {\n            // Join fragments with a period, so that Carrot2 does not create\n            // cross-fragment phrases, such phrases rarely make sense.\n            String [] highlt = tmp.get(snippetFieldAry[j]);\n            if (highlt != null && highlt.length > 0) {\n              for (int i = 0; i < highlt.length; i++) {\n                sb.append(highlt[i]);\n                sb.append(\" . \");\n              }\n            }\n          }\n          snippet = sb.toString();\n        }\n      }\n      \n      // If summaries not enabled or summary generation failed, use full content.\n      if (snippet == null) {\n        snippet = getConcatenated(sdoc, snippetFieldSpec);\n      }\n      \n      // Create a Carrot2 document\n      Document carrotDocument = new Document(getConcatenated(sdoc, titleFieldSpec),\n              snippet, (String)sdoc.getFieldValue(urlField));\n      \n      // Store Solr id of the document, we need it to map document instances \n      // found in clusters back to identifiers.\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      \n      // Set language\n      if (StringUtils.isNotBlank(languageField)) {\n        Collection<Object> languages = sdoc.getFieldValues(languageField);\n        if (languages != null) {\n          \n          // Use the first Carrot2-supported language\n          for (Object l : languages) {\n            String lang = ObjectUtils.toString(l, \"\");\n            \n            if (languageCodeMap.containsKey(lang)) {\n              lang = languageCodeMap.get(lang);\n            }\n            \n            // Language detection Library for Java uses dashes to separate\n            // language variants, such as 'zh-cn', but Carrot2 uses underscores.\n            if (lang.indexOf('-') > 0) {\n              lang = lang.replace('-', '_');\n            }\n            \n            // If the language is supported by Carrot2, we'll get a non-null value\n            final LanguageCode carrot2Language = LanguageCode.forISOCode(lang);\n            if (carrot2Language != null) {\n              carrotDocument.setLanguage(carrot2Language);\n              break;\n            }\n          }\n        }\n      }\n      \n      // Add custom fields\n      if (customFields != null) {\n        for (Entry<String, String> entry : customFields.entrySet()) {\n          carrotDocument.setField(entry.getValue(), sdoc.getFieldValue(entry.getKey()));\n        }\n      }\n      \n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","bugFix":["a5684446f7742dfb07c42296decc5e4d6515a0fe"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ff99371bc1f34bf1a2ccdb754940ee5fe5cc2565","date":1323540308,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","sourceNew":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleFieldSpec = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetFieldSpec = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleFieldSpec);\n    String languageField = solrParams.get(CarrotParams.LANGUAGE_FIELD_NAME, null);\n    \n    // Maps Solr field names to Carrot2 custom field names\n    Map<String, String> customFields = getCustomFieldsMap(solrParams);\n\n    // Parse language code map string into a map\n    Map<String, String> languageCodeMap = Maps.newHashMap();\n    if (StringUtils.isNotBlank(languageField)) {\n      for (String pair : solrParams.get(CarrotParams.LANGUAGE_CODE_MAP, \"\")\n          .split(\"[, ]\")) {\n        final String[] split = pair.split(\":\");\n        if (split.length == 2 && StringUtils.isNotBlank(split[0]) && StringUtils.isNotBlank(split[1])) {\n          languageCodeMap.put(split[0], split[1]);\n        } else {\n          log.warn(\"Unsupported format for \" + CarrotParams.LANGUAGE_CODE_MAP\n              + \": '\" + pair + \"'. Skipping this mapping.\");\n        }\n      }\n    }\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = Maps.newHashMap();\n        snippetFieldAry = snippetFieldSpec.split(\"[, ]\");\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        args.put(HighlightParams.SNIPPETS, solrParams.getInt(CarrotParams.SUMMARY_SNIPPETS, solrParams.getInt(HighlightParams.SNIPPETS, 1)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<Document>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = null;\n      \n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {//should only be one value given our setup\n          //should only be one document\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          \n          final StringBuilder sb = new StringBuilder();\n          for (int j = 0; j < snippetFieldAry.length; j++) {\n            // Join fragments with a period, so that Carrot2 does not create\n            // cross-fragment phrases, such phrases rarely make sense.\n            String [] highlt = tmp.get(snippetFieldAry[j]);\n            if (highlt != null && highlt.length > 0) {\n              for (int i = 0; i < highlt.length; i++) {\n                sb.append(highlt[i]);\n                sb.append(\" . \");\n              }\n            }\n          }\n          snippet = sb.toString();\n        }\n      }\n      \n      // If summaries not enabled or summary generation failed, use full content.\n      if (snippet == null) {\n        snippet = getConcatenated(sdoc, snippetFieldSpec);\n      }\n      \n      // Create a Carrot2 document\n      Document carrotDocument = new Document(getConcatenated(sdoc, titleFieldSpec),\n              snippet, ObjectUtils.toString(sdoc.getFieldValue(urlField), \"\"));\n      \n      // Store Solr id of the document, we need it to map document instances \n      // found in clusters back to identifiers.\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      \n      // Set language\n      if (StringUtils.isNotBlank(languageField)) {\n        Collection<Object> languages = sdoc.getFieldValues(languageField);\n        if (languages != null) {\n          \n          // Use the first Carrot2-supported language\n          for (Object l : languages) {\n            String lang = ObjectUtils.toString(l, \"\");\n            \n            if (languageCodeMap.containsKey(lang)) {\n              lang = languageCodeMap.get(lang);\n            }\n            \n            // Language detection Library for Java uses dashes to separate\n            // language variants, such as 'zh-cn', but Carrot2 uses underscores.\n            if (lang.indexOf('-') > 0) {\n              lang = lang.replace('-', '_');\n            }\n            \n            // If the language is supported by Carrot2, we'll get a non-null value\n            final LanguageCode carrot2Language = LanguageCode.forISOCode(lang);\n            if (carrot2Language != null) {\n              carrotDocument.setLanguage(carrot2Language);\n              break;\n            }\n          }\n        }\n      }\n      \n      // Add custom fields\n      if (customFields != null) {\n        for (Entry<String, String> entry : customFields.entrySet()) {\n          carrotDocument.setField(entry.getValue(), sdoc.getFieldValue(entry.getKey()));\n        }\n      }\n      \n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleField = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetField = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleField);\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = Maps.newHashMap();\n        snippetFieldAry = new String[]{snippetField};\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<Document>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = getValue(sdoc, snippetField);\n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {//should only be one value given our setup\n          //should only be one document with one field\n          @SuppressWarnings(\"unchecked\")\n\t\t\t\t\tNamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          String [] highlt = tmp.get(snippetField);\n          if (highlt != null && highlt.length == 1) {\n            snippet = highlt[0];\n          }\n        }\n      }\n      Document carrotDocument = new Document(getValue(sdoc, titleField),\n              snippet, (String)sdoc.getFieldValue(urlField));\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e9ad156d6e96d7d7b6d8015f686c50b1142760a","date":1378497777,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","sourceNew":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleFieldSpec = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetFieldSpec = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleFieldSpec);\n    String languageField = solrParams.get(CarrotParams.LANGUAGE_FIELD_NAME, null);\n    \n    // Maps Solr field names to Carrot2 custom field names\n    Map<String, String> customFields = getCustomFieldsMap(solrParams);\n\n    // Parse language code map string into a map\n    Map<String, String> languageCodeMap = Maps.newHashMap();\n    if (StringUtils.isNotBlank(languageField)) {\n      for (String pair : solrParams.get(CarrotParams.LANGUAGE_CODE_MAP, \"\")\n          .split(\"[, ]\")) {\n        final String[] split = pair.split(\":\");\n        if (split.length == 2 && StringUtils.isNotBlank(split[0]) && StringUtils.isNotBlank(split[1])) {\n          languageCodeMap.put(split[0], split[1]);\n        } else {\n          log.warn(\"Unsupported format for \" + CarrotParams.LANGUAGE_CODE_MAP\n              + \": '\" + pair + \"'. Skipping this mapping.\");\n        }\n      }\n    }\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = Maps.newHashMap();\n        snippetFieldAry = snippetFieldSpec.split(\"[, ]\");\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        args.put(HighlightParams.SNIPPETS, solrParams.getInt(CarrotParams.SUMMARY_SNIPPETS, solrParams.getInt(HighlightParams.SNIPPETS, 1)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<Document>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = null;\n      \n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {\n          // should only be one value given our setup\n          // should only be one document\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          \n          final StringBuilder sb = new StringBuilder();\n          for (int j = 0; j < snippetFieldAry.length; j++) {\n            // Join fragments with a period, so that Carrot2 does not create\n            // cross-fragment phrases, such phrases rarely make sense.\n            String [] highlt = tmp.get(snippetFieldAry[j]);\n            if (highlt != null && highlt.length > 0) {\n              for (int i = 0; i < highlt.length; i++) {\n                sb.append(highlt[i]);\n                sb.append(\" . \");\n              }\n            }\n          }\n          snippet = sb.toString();\n        }\n      }\n      \n      // If summaries not enabled or summary generation failed, use full content.\n      if (snippet == null) {\n        snippet = getConcatenated(sdoc, snippetFieldSpec);\n      }\n      \n      // Create a Carrot2 document\n      Document carrotDocument = new Document(getConcatenated(sdoc, titleFieldSpec),\n              snippet, ObjectUtils.toString(sdoc.getFieldValue(urlField), \"\"));\n      \n      // Store Solr id of the document, we need it to map document instances \n      // found in clusters back to identifiers.\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      \n      // Set language\n      if (StringUtils.isNotBlank(languageField)) {\n        Collection<Object> languages = sdoc.getFieldValues(languageField);\n        if (languages != null) {\n          \n          // Use the first Carrot2-supported language\n          for (Object l : languages) {\n            String lang = ObjectUtils.toString(l, \"\");\n            \n            if (languageCodeMap.containsKey(lang)) {\n              lang = languageCodeMap.get(lang);\n            }\n            \n            // Language detection Library for Java uses dashes to separate\n            // language variants, such as 'zh-cn', but Carrot2 uses underscores.\n            if (lang.indexOf('-') > 0) {\n              lang = lang.replace('-', '_');\n            }\n            \n            // If the language is supported by Carrot2, we'll get a non-null value\n            final LanguageCode carrot2Language = LanguageCode.forISOCode(lang);\n            if (carrot2Language != null) {\n              carrotDocument.setLanguage(carrot2Language);\n              break;\n            }\n          }\n        }\n      }\n      \n      // Add custom fields\n      if (customFields != null) {\n        for (Entry<String, String> entry : customFields.entrySet()) {\n          carrotDocument.setField(entry.getValue(), sdoc.getFieldValue(entry.getKey()));\n        }\n      }\n      \n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleFieldSpec = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetFieldSpec = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleFieldSpec);\n    String languageField = solrParams.get(CarrotParams.LANGUAGE_FIELD_NAME, null);\n    \n    // Maps Solr field names to Carrot2 custom field names\n    Map<String, String> customFields = getCustomFieldsMap(solrParams);\n\n    // Parse language code map string into a map\n    Map<String, String> languageCodeMap = Maps.newHashMap();\n    if (StringUtils.isNotBlank(languageField)) {\n      for (String pair : solrParams.get(CarrotParams.LANGUAGE_CODE_MAP, \"\")\n          .split(\"[, ]\")) {\n        final String[] split = pair.split(\":\");\n        if (split.length == 2 && StringUtils.isNotBlank(split[0]) && StringUtils.isNotBlank(split[1])) {\n          languageCodeMap.put(split[0], split[1]);\n        } else {\n          log.warn(\"Unsupported format for \" + CarrotParams.LANGUAGE_CODE_MAP\n              + \": '\" + pair + \"'. Skipping this mapping.\");\n        }\n      }\n    }\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = Maps.newHashMap();\n        snippetFieldAry = snippetFieldSpec.split(\"[, ]\");\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        args.put(HighlightParams.SNIPPETS, solrParams.getInt(CarrotParams.SUMMARY_SNIPPETS, solrParams.getInt(HighlightParams.SNIPPETS, 1)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<Document>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = null;\n      \n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {//should only be one value given our setup\n          //should only be one document\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          \n          final StringBuilder sb = new StringBuilder();\n          for (int j = 0; j < snippetFieldAry.length; j++) {\n            // Join fragments with a period, so that Carrot2 does not create\n            // cross-fragment phrases, such phrases rarely make sense.\n            String [] highlt = tmp.get(snippetFieldAry[j]);\n            if (highlt != null && highlt.length > 0) {\n              for (int i = 0; i < highlt.length; i++) {\n                sb.append(highlt[i]);\n                sb.append(\" . \");\n              }\n            }\n          }\n          snippet = sb.toString();\n        }\n      }\n      \n      // If summaries not enabled or summary generation failed, use full content.\n      if (snippet == null) {\n        snippet = getConcatenated(sdoc, snippetFieldSpec);\n      }\n      \n      // Create a Carrot2 document\n      Document carrotDocument = new Document(getConcatenated(sdoc, titleFieldSpec),\n              snippet, ObjectUtils.toString(sdoc.getFieldValue(urlField), \"\"));\n      \n      // Store Solr id of the document, we need it to map document instances \n      // found in clusters back to identifiers.\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      \n      // Set language\n      if (StringUtils.isNotBlank(languageField)) {\n        Collection<Object> languages = sdoc.getFieldValues(languageField);\n        if (languages != null) {\n          \n          // Use the first Carrot2-supported language\n          for (Object l : languages) {\n            String lang = ObjectUtils.toString(l, \"\");\n            \n            if (languageCodeMap.containsKey(lang)) {\n              lang = languageCodeMap.get(lang);\n            }\n            \n            // Language detection Library for Java uses dashes to separate\n            // language variants, such as 'zh-cn', but Carrot2 uses underscores.\n            if (lang.indexOf('-') > 0) {\n              lang = lang.replace('-', '_');\n            }\n            \n            // If the language is supported by Carrot2, we'll get a non-null value\n            final LanguageCode carrot2Language = LanguageCode.forISOCode(lang);\n            if (carrot2Language != null) {\n              carrotDocument.setLanguage(carrot2Language);\n              break;\n            }\n          }\n        }\n      }\n      \n      // Add custom fields\n      if (customFields != null) {\n        for (Entry<String, String> entry : customFields.entrySet()) {\n          carrotDocument.setField(entry.getValue(), sdoc.getFieldValue(entry.getKey()));\n        }\n      }\n      \n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c2f15ce56e25538825682a41ccb854c1d82e0e95","date":1378972163,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","sourceNew":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleFieldSpec = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetFieldSpec = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleFieldSpec);\n    String languageField = solrParams.get(CarrotParams.LANGUAGE_FIELD_NAME, null);\n    \n    // Maps Solr field names to Carrot2 custom field names\n    Map<String, String> customFields = getCustomFieldsMap(solrParams);\n\n    // Parse language code map string into a map\n    Map<String, String> languageCodeMap = Maps.newHashMap();\n    if (StringUtils.isNotBlank(languageField)) {\n      for (String pair : solrParams.get(CarrotParams.LANGUAGE_CODE_MAP, \"\").split(\"[, ]\")) {\n        final String[] split = pair.split(\":\");\n        if (split.length == 2 && StringUtils.isNotBlank(split[0]) && StringUtils.isNotBlank(split[1])) {\n          languageCodeMap.put(split[0], split[1]);\n        } else {\n          log.warn(\"Unsupported format for \" + CarrotParams.LANGUAGE_CODE_MAP\n              + \": '\" + pair + \"'. Skipping this mapping.\");\n        }\n      }\n    }\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = Maps.newHashMap();\n        snippetFieldAry = snippetFieldSpec.split(\"[, ]\");\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        args.put(HighlightParams.SNIPPETS, solrParams.getInt(CarrotParams.SUMMARY_SNIPPETS, solrParams.getInt(HighlightParams.SNIPPETS, 1)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<Document>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = null;\n      \n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {\n          // should only be one value given our setup\n          // should only be one document\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          \n          final StringBuilder sb = new StringBuilder();\n          for (int j = 0; j < snippetFieldAry.length; j++) {\n            // Join fragments with a period, so that Carrot2 does not create\n            // cross-fragment phrases, such phrases rarely make sense.\n            String [] highlt = tmp.get(snippetFieldAry[j]);\n            if (highlt != null && highlt.length > 0) {\n              for (int i = 0; i < highlt.length; i++) {\n                sb.append(highlt[i]);\n                sb.append(\" . \");\n              }\n            }\n          }\n          snippet = sb.toString();\n        }\n      }\n      \n      // If summaries not enabled or summary generation failed, use full content.\n      if (snippet == null) {\n        snippet = getConcatenated(sdoc, snippetFieldSpec);\n      }\n      \n      // Create a Carrot2 document\n      Document carrotDocument = new Document(getConcatenated(sdoc, titleFieldSpec),\n              snippet, ObjectUtils.toString(sdoc.getFieldValue(urlField), \"\"));\n      \n      // Store Solr id of the document, we need it to map document instances \n      // found in clusters back to identifiers.\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      \n      // Set language\n      if (StringUtils.isNotBlank(languageField)) {\n        Collection<Object> languages = sdoc.getFieldValues(languageField);\n        if (languages != null) {\n          \n          // Use the first Carrot2-supported language\n          for (Object l : languages) {\n            String lang = ObjectUtils.toString(l, \"\");\n            \n            if (languageCodeMap.containsKey(lang)) {\n              lang = languageCodeMap.get(lang);\n            }\n            \n            // Language detection Library for Java uses dashes to separate\n            // language variants, such as 'zh-cn', but Carrot2 uses underscores.\n            if (lang.indexOf('-') > 0) {\n              lang = lang.replace('-', '_');\n            }\n            \n            // If the language is supported by Carrot2, we'll get a non-null value\n            final LanguageCode carrot2Language = LanguageCode.forISOCode(lang);\n            if (carrot2Language != null) {\n              carrotDocument.setLanguage(carrot2Language);\n              break;\n            }\n          }\n        }\n      }\n      \n      // Add custom fields\n      if (customFields != null) {\n        for (Entry<String, String> entry : customFields.entrySet()) {\n          carrotDocument.setField(entry.getValue(), sdoc.getFieldValue(entry.getKey()));\n        }\n      }\n      \n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleFieldSpec = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetFieldSpec = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleFieldSpec);\n    String languageField = solrParams.get(CarrotParams.LANGUAGE_FIELD_NAME, null);\n    \n    // Maps Solr field names to Carrot2 custom field names\n    Map<String, String> customFields = getCustomFieldsMap(solrParams);\n\n    // Parse language code map string into a map\n    Map<String, String> languageCodeMap = Maps.newHashMap();\n    if (StringUtils.isNotBlank(languageField)) {\n      for (String pair : solrParams.get(CarrotParams.LANGUAGE_CODE_MAP, \"\")\n          .split(\"[, ]\")) {\n        final String[] split = pair.split(\":\");\n        if (split.length == 2 && StringUtils.isNotBlank(split[0]) && StringUtils.isNotBlank(split[1])) {\n          languageCodeMap.put(split[0], split[1]);\n        } else {\n          log.warn(\"Unsupported format for \" + CarrotParams.LANGUAGE_CODE_MAP\n              + \": '\" + pair + \"'. Skipping this mapping.\");\n        }\n      }\n    }\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = Maps.newHashMap();\n        snippetFieldAry = snippetFieldSpec.split(\"[, ]\");\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        args.put(HighlightParams.SNIPPETS, solrParams.getInt(CarrotParams.SUMMARY_SNIPPETS, solrParams.getInt(HighlightParams.SNIPPETS, 1)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<Document>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = null;\n      \n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {\n          // should only be one value given our setup\n          // should only be one document\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          \n          final StringBuilder sb = new StringBuilder();\n          for (int j = 0; j < snippetFieldAry.length; j++) {\n            // Join fragments with a period, so that Carrot2 does not create\n            // cross-fragment phrases, such phrases rarely make sense.\n            String [] highlt = tmp.get(snippetFieldAry[j]);\n            if (highlt != null && highlt.length > 0) {\n              for (int i = 0; i < highlt.length; i++) {\n                sb.append(highlt[i]);\n                sb.append(\" . \");\n              }\n            }\n          }\n          snippet = sb.toString();\n        }\n      }\n      \n      // If summaries not enabled or summary generation failed, use full content.\n      if (snippet == null) {\n        snippet = getConcatenated(sdoc, snippetFieldSpec);\n      }\n      \n      // Create a Carrot2 document\n      Document carrotDocument = new Document(getConcatenated(sdoc, titleFieldSpec),\n              snippet, ObjectUtils.toString(sdoc.getFieldValue(urlField), \"\"));\n      \n      // Store Solr id of the document, we need it to map document instances \n      // found in clusters back to identifiers.\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      \n      // Set language\n      if (StringUtils.isNotBlank(languageField)) {\n        Collection<Object> languages = sdoc.getFieldValues(languageField);\n        if (languages != null) {\n          \n          // Use the first Carrot2-supported language\n          for (Object l : languages) {\n            String lang = ObjectUtils.toString(l, \"\");\n            \n            if (languageCodeMap.containsKey(lang)) {\n              lang = languageCodeMap.get(lang);\n            }\n            \n            // Language detection Library for Java uses dashes to separate\n            // language variants, such as 'zh-cn', but Carrot2 uses underscores.\n            if (lang.indexOf('-') > 0) {\n              lang = lang.replace('-', '_');\n            }\n            \n            // If the language is supported by Carrot2, we'll get a non-null value\n            final LanguageCode carrot2Language = LanguageCode.forISOCode(lang);\n            if (carrot2Language != null) {\n              carrotDocument.setLanguage(carrot2Language);\n              break;\n            }\n          }\n        }\n      }\n      \n      // Add custom fields\n      if (customFields != null) {\n        for (Entry<String, String> entry : customFields.entrySet()) {\n          carrotDocument.setField(entry.getValue(), sdoc.getFieldValue(entry.getKey()));\n        }\n      }\n      \n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","sourceNew":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleFieldSpec = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetFieldSpec = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleFieldSpec);\n    String languageField = solrParams.get(CarrotParams.LANGUAGE_FIELD_NAME, null);\n    \n    // Maps Solr field names to Carrot2 custom field names\n    Map<String, String> customFields = getCustomFieldsMap(solrParams);\n\n    // Parse language code map string into a map\n    Map<String, String> languageCodeMap = Maps.newHashMap();\n    if (StringUtils.isNotBlank(languageField)) {\n      for (String pair : solrParams.get(CarrotParams.LANGUAGE_CODE_MAP, \"\").split(\"[, ]\")) {\n        final String[] split = pair.split(\":\");\n        if (split.length == 2 && StringUtils.isNotBlank(split[0]) && StringUtils.isNotBlank(split[1])) {\n          languageCodeMap.put(split[0], split[1]);\n        } else {\n          log.warn(\"Unsupported format for \" + CarrotParams.LANGUAGE_CODE_MAP\n              + \": '\" + pair + \"'. Skipping this mapping.\");\n        }\n      }\n    }\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = Maps.newHashMap();\n        snippetFieldAry = snippetFieldSpec.split(\"[, ]\");\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        args.put(HighlightParams.SNIPPETS, solrParams.getInt(CarrotParams.SUMMARY_SNIPPETS, solrParams.getInt(HighlightParams.SNIPPETS, 1)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = null;\n      \n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {\n          // should only be one value given our setup\n          // should only be one document\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          \n          final StringBuilder sb = new StringBuilder();\n          for (int j = 0; j < snippetFieldAry.length; j++) {\n            // Join fragments with a period, so that Carrot2 does not create\n            // cross-fragment phrases, such phrases rarely make sense.\n            String [] highlt = tmp.get(snippetFieldAry[j]);\n            if (highlt != null && highlt.length > 0) {\n              for (int i = 0; i < highlt.length; i++) {\n                sb.append(highlt[i]);\n                sb.append(\" . \");\n              }\n            }\n          }\n          snippet = sb.toString();\n        }\n      }\n      \n      // If summaries not enabled or summary generation failed, use full content.\n      if (snippet == null) {\n        snippet = getConcatenated(sdoc, snippetFieldSpec);\n      }\n      \n      // Create a Carrot2 document\n      Document carrotDocument = new Document(getConcatenated(sdoc, titleFieldSpec),\n              snippet, ObjectUtils.toString(sdoc.getFieldValue(urlField), \"\"));\n      \n      // Store Solr id of the document, we need it to map document instances \n      // found in clusters back to identifiers.\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      \n      // Set language\n      if (StringUtils.isNotBlank(languageField)) {\n        Collection<Object> languages = sdoc.getFieldValues(languageField);\n        if (languages != null) {\n          \n          // Use the first Carrot2-supported language\n          for (Object l : languages) {\n            String lang = ObjectUtils.toString(l, \"\");\n            \n            if (languageCodeMap.containsKey(lang)) {\n              lang = languageCodeMap.get(lang);\n            }\n            \n            // Language detection Library for Java uses dashes to separate\n            // language variants, such as 'zh-cn', but Carrot2 uses underscores.\n            if (lang.indexOf('-') > 0) {\n              lang = lang.replace('-', '_');\n            }\n            \n            // If the language is supported by Carrot2, we'll get a non-null value\n            final LanguageCode carrot2Language = LanguageCode.forISOCode(lang);\n            if (carrot2Language != null) {\n              carrotDocument.setLanguage(carrot2Language);\n              break;\n            }\n          }\n        }\n      }\n      \n      // Add custom fields\n      if (customFields != null) {\n        for (Entry<String, String> entry : customFields.entrySet()) {\n          carrotDocument.setField(entry.getValue(), sdoc.getFieldValue(entry.getKey()));\n        }\n      }\n      \n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleFieldSpec = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetFieldSpec = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleFieldSpec);\n    String languageField = solrParams.get(CarrotParams.LANGUAGE_FIELD_NAME, null);\n    \n    // Maps Solr field names to Carrot2 custom field names\n    Map<String, String> customFields = getCustomFieldsMap(solrParams);\n\n    // Parse language code map string into a map\n    Map<String, String> languageCodeMap = Maps.newHashMap();\n    if (StringUtils.isNotBlank(languageField)) {\n      for (String pair : solrParams.get(CarrotParams.LANGUAGE_CODE_MAP, \"\").split(\"[, ]\")) {\n        final String[] split = pair.split(\":\");\n        if (split.length == 2 && StringUtils.isNotBlank(split[0]) && StringUtils.isNotBlank(split[1])) {\n          languageCodeMap.put(split[0], split[1]);\n        } else {\n          log.warn(\"Unsupported format for \" + CarrotParams.LANGUAGE_CODE_MAP\n              + \": '\" + pair + \"'. Skipping this mapping.\");\n        }\n      }\n    }\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = Maps.newHashMap();\n        snippetFieldAry = snippetFieldSpec.split(\"[, ]\");\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        args.put(HighlightParams.SNIPPETS, solrParams.getInt(CarrotParams.SUMMARY_SNIPPETS, solrParams.getInt(HighlightParams.SNIPPETS, 1)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<Document>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = null;\n      \n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {\n          // should only be one value given our setup\n          // should only be one document\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          \n          final StringBuilder sb = new StringBuilder();\n          for (int j = 0; j < snippetFieldAry.length; j++) {\n            // Join fragments with a period, so that Carrot2 does not create\n            // cross-fragment phrases, such phrases rarely make sense.\n            String [] highlt = tmp.get(snippetFieldAry[j]);\n            if (highlt != null && highlt.length > 0) {\n              for (int i = 0; i < highlt.length; i++) {\n                sb.append(highlt[i]);\n                sb.append(\" . \");\n              }\n            }\n          }\n          snippet = sb.toString();\n        }\n      }\n      \n      // If summaries not enabled or summary generation failed, use full content.\n      if (snippet == null) {\n        snippet = getConcatenated(sdoc, snippetFieldSpec);\n      }\n      \n      // Create a Carrot2 document\n      Document carrotDocument = new Document(getConcatenated(sdoc, titleFieldSpec),\n              snippet, ObjectUtils.toString(sdoc.getFieldValue(urlField), \"\"));\n      \n      // Store Solr id of the document, we need it to map document instances \n      // found in clusters back to identifiers.\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      \n      // Set language\n      if (StringUtils.isNotBlank(languageField)) {\n        Collection<Object> languages = sdoc.getFieldValues(languageField);\n        if (languages != null) {\n          \n          // Use the first Carrot2-supported language\n          for (Object l : languages) {\n            String lang = ObjectUtils.toString(l, \"\");\n            \n            if (languageCodeMap.containsKey(lang)) {\n              lang = languageCodeMap.get(lang);\n            }\n            \n            // Language detection Library for Java uses dashes to separate\n            // language variants, such as 'zh-cn', but Carrot2 uses underscores.\n            if (lang.indexOf('-') > 0) {\n              lang = lang.replace('-', '_');\n            }\n            \n            // If the language is supported by Carrot2, we'll get a non-null value\n            final LanguageCode carrot2Language = LanguageCode.forISOCode(lang);\n            if (carrot2Language != null) {\n              carrotDocument.setLanguage(carrot2Language);\n              break;\n            }\n          }\n        }\n      }\n      \n      // Add custom fields\n      if (customFields != null) {\n        for (Entry<String, String> entry : customFields.entrySet()) {\n          carrotDocument.setField(entry.getValue(), sdoc.getFieldValue(entry.getKey()));\n        }\n      }\n      \n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7290fa7ae2cc2a80abb6aecc0b0dd90cbfde2b7f","date":1478271720,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","sourceNew":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleFieldSpec = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetFieldSpec = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleFieldSpec);\n    String languageField = solrParams.get(CarrotParams.LANGUAGE_FIELD_NAME, null);\n    \n    // Maps Solr field names to Carrot2 custom field names\n    Map<String, String> customFields = getCustomFieldsMap(solrParams);\n\n    // Parse language code map string into a map\n    Map<String, String> languageCodeMap = new HashMap<>();\n    if (StringUtils.isNotBlank(languageField)) {\n      for (String pair : solrParams.get(CarrotParams.LANGUAGE_CODE_MAP, \"\").split(\"[, ]\")) {\n        final String[] split = pair.split(\":\");\n        if (split.length == 2 && StringUtils.isNotBlank(split[0]) && StringUtils.isNotBlank(split[1])) {\n          languageCodeMap.put(split[0], split[1]);\n        } else {\n          log.warn(\"Unsupported format for \" + CarrotParams.LANGUAGE_CODE_MAP\n              + \": '\" + pair + \"'. Skipping this mapping.\");\n        }\n      }\n    }\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = new HashMap<>();\n        snippetFieldAry = snippetFieldSpec.split(\"[, ]\");\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        args.put(HighlightParams.SNIPPETS, solrParams.getInt(CarrotParams.SUMMARY_SNIPPETS, solrParams.getInt(HighlightParams.SNIPPETS, 1)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = null;\n      \n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {\n          // should only be one value given our setup\n          // should only be one document\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          \n          final StringBuilder sb = new StringBuilder();\n          for (int j = 0; j < snippetFieldAry.length; j++) {\n            // Join fragments with a period, so that Carrot2 does not create\n            // cross-fragment phrases, such phrases rarely make sense.\n            String [] highlt = tmp.get(snippetFieldAry[j]);\n            if (highlt != null && highlt.length > 0) {\n              for (int i = 0; i < highlt.length; i++) {\n                sb.append(highlt[i]);\n                sb.append(\" . \");\n              }\n            }\n          }\n          snippet = sb.toString();\n        }\n      }\n      \n      // If summaries not enabled or summary generation failed, use full content.\n      if (snippet == null) {\n        snippet = getConcatenated(sdoc, snippetFieldSpec);\n      }\n      \n      // Create a Carrot2 document\n      Document carrotDocument = new Document(getConcatenated(sdoc, titleFieldSpec),\n              snippet, ObjectUtils.toString(sdoc.getFieldValue(urlField), \"\"));\n      \n      // Store Solr id of the document, we need it to map document instances \n      // found in clusters back to identifiers.\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      \n      // Set language\n      if (StringUtils.isNotBlank(languageField)) {\n        Collection<Object> languages = sdoc.getFieldValues(languageField);\n        if (languages != null) {\n          \n          // Use the first Carrot2-supported language\n          for (Object l : languages) {\n            String lang = ObjectUtils.toString(l, \"\");\n            \n            if (languageCodeMap.containsKey(lang)) {\n              lang = languageCodeMap.get(lang);\n            }\n            \n            // Language detection Library for Java uses dashes to separate\n            // language variants, such as 'zh-cn', but Carrot2 uses underscores.\n            if (lang.indexOf('-') > 0) {\n              lang = lang.replace('-', '_');\n            }\n            \n            // If the language is supported by Carrot2, we'll get a non-null value\n            final LanguageCode carrot2Language = LanguageCode.forISOCode(lang);\n            if (carrot2Language != null) {\n              carrotDocument.setLanguage(carrot2Language);\n              break;\n            }\n          }\n        }\n      }\n      \n      // Add custom fields\n      if (customFields != null) {\n        for (Entry<String, String> entry : customFields.entrySet()) {\n          carrotDocument.setField(entry.getValue(), sdoc.getFieldValue(entry.getKey()));\n        }\n      }\n      \n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleFieldSpec = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetFieldSpec = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleFieldSpec);\n    String languageField = solrParams.get(CarrotParams.LANGUAGE_FIELD_NAME, null);\n    \n    // Maps Solr field names to Carrot2 custom field names\n    Map<String, String> customFields = getCustomFieldsMap(solrParams);\n\n    // Parse language code map string into a map\n    Map<String, String> languageCodeMap = Maps.newHashMap();\n    if (StringUtils.isNotBlank(languageField)) {\n      for (String pair : solrParams.get(CarrotParams.LANGUAGE_CODE_MAP, \"\").split(\"[, ]\")) {\n        final String[] split = pair.split(\":\");\n        if (split.length == 2 && StringUtils.isNotBlank(split[0]) && StringUtils.isNotBlank(split[1])) {\n          languageCodeMap.put(split[0], split[1]);\n        } else {\n          log.warn(\"Unsupported format for \" + CarrotParams.LANGUAGE_CODE_MAP\n              + \": '\" + pair + \"'. Skipping this mapping.\");\n        }\n      }\n    }\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = Maps.newHashMap();\n        snippetFieldAry = snippetFieldSpec.split(\"[, ]\");\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        args.put(HighlightParams.SNIPPETS, solrParams.getInt(CarrotParams.SUMMARY_SNIPPETS, solrParams.getInt(HighlightParams.SNIPPETS, 1)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = null;\n      \n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {\n          // should only be one value given our setup\n          // should only be one document\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          \n          final StringBuilder sb = new StringBuilder();\n          for (int j = 0; j < snippetFieldAry.length; j++) {\n            // Join fragments with a period, so that Carrot2 does not create\n            // cross-fragment phrases, such phrases rarely make sense.\n            String [] highlt = tmp.get(snippetFieldAry[j]);\n            if (highlt != null && highlt.length > 0) {\n              for (int i = 0; i < highlt.length; i++) {\n                sb.append(highlt[i]);\n                sb.append(\" . \");\n              }\n            }\n          }\n          snippet = sb.toString();\n        }\n      }\n      \n      // If summaries not enabled or summary generation failed, use full content.\n      if (snippet == null) {\n        snippet = getConcatenated(sdoc, snippetFieldSpec);\n      }\n      \n      // Create a Carrot2 document\n      Document carrotDocument = new Document(getConcatenated(sdoc, titleFieldSpec),\n              snippet, ObjectUtils.toString(sdoc.getFieldValue(urlField), \"\"));\n      \n      // Store Solr id of the document, we need it to map document instances \n      // found in clusters back to identifiers.\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      \n      // Set language\n      if (StringUtils.isNotBlank(languageField)) {\n        Collection<Object> languages = sdoc.getFieldValues(languageField);\n        if (languages != null) {\n          \n          // Use the first Carrot2-supported language\n          for (Object l : languages) {\n            String lang = ObjectUtils.toString(l, \"\");\n            \n            if (languageCodeMap.containsKey(lang)) {\n              lang = languageCodeMap.get(lang);\n            }\n            \n            // Language detection Library for Java uses dashes to separate\n            // language variants, such as 'zh-cn', but Carrot2 uses underscores.\n            if (lang.indexOf('-') > 0) {\n              lang = lang.replace('-', '_');\n            }\n            \n            // If the language is supported by Carrot2, we'll get a non-null value\n            final LanguageCode carrot2Language = LanguageCode.forISOCode(lang);\n            if (carrot2Language != null) {\n              carrotDocument.setLanguage(carrot2Language);\n              break;\n            }\n          }\n        }\n      }\n      \n      // Add custom fields\n      if (customFields != null) {\n        for (Entry<String, String> entry : customFields.entrySet()) {\n          carrotDocument.setField(entry.getValue(), sdoc.getFieldValue(entry.getKey()));\n        }\n      }\n      \n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"199dfa410f1fdbfd3294106b04096cce5ed34b21","date":1478812506,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","sourceNew":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleFieldSpec = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetFieldSpec = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleFieldSpec);\n    String languageField = solrParams.get(CarrotParams.LANGUAGE_FIELD_NAME, null);\n    \n    // Maps Solr field names to Carrot2 custom field names\n    Map<String, String> customFields = getCustomFieldsMap(solrParams);\n\n    // Parse language code map string into a map\n    Map<String, String> languageCodeMap = new HashMap<>();\n    if (StringUtils.isNotBlank(languageField)) {\n      for (String pair : solrParams.get(CarrotParams.LANGUAGE_CODE_MAP, \"\").split(\"[, ]\")) {\n        final String[] split = pair.split(\":\");\n        if (split.length == 2 && StringUtils.isNotBlank(split[0]) && StringUtils.isNotBlank(split[1])) {\n          languageCodeMap.put(split[0], split[1]);\n        } else {\n          log.warn(\"Unsupported format for \" + CarrotParams.LANGUAGE_CODE_MAP\n              + \": '\" + pair + \"'. Skipping this mapping.\");\n        }\n      }\n    }\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = new HashMap<>();\n        snippetFieldAry = snippetFieldSpec.split(\"[, ]\");\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        args.put(HighlightParams.SNIPPETS, solrParams.getInt(CarrotParams.SUMMARY_SNIPPETS, solrParams.getInt(HighlightParams.SNIPPETS, 1)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = null;\n      \n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {\n          // should only be one value given our setup\n          // should only be one document\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          \n          final StringBuilder sb = new StringBuilder();\n          for (int j = 0; j < snippetFieldAry.length; j++) {\n            // Join fragments with a period, so that Carrot2 does not create\n            // cross-fragment phrases, such phrases rarely make sense.\n            String [] highlt = tmp.get(snippetFieldAry[j]);\n            if (highlt != null && highlt.length > 0) {\n              for (int i = 0; i < highlt.length; i++) {\n                sb.append(highlt[i]);\n                sb.append(\" . \");\n              }\n            }\n          }\n          snippet = sb.toString();\n        }\n      }\n      \n      // If summaries not enabled or summary generation failed, use full content.\n      if (snippet == null) {\n        snippet = getConcatenated(sdoc, snippetFieldSpec);\n      }\n      \n      // Create a Carrot2 document\n      Document carrotDocument = new Document(getConcatenated(sdoc, titleFieldSpec),\n              snippet, ObjectUtils.toString(sdoc.getFieldValue(urlField), \"\"));\n      \n      // Store Solr id of the document, we need it to map document instances \n      // found in clusters back to identifiers.\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      \n      // Set language\n      if (StringUtils.isNotBlank(languageField)) {\n        Collection<Object> languages = sdoc.getFieldValues(languageField);\n        if (languages != null) {\n          \n          // Use the first Carrot2-supported language\n          for (Object l : languages) {\n            String lang = ObjectUtils.toString(l, \"\");\n            \n            if (languageCodeMap.containsKey(lang)) {\n              lang = languageCodeMap.get(lang);\n            }\n            \n            // Language detection Library for Java uses dashes to separate\n            // language variants, such as 'zh-cn', but Carrot2 uses underscores.\n            if (lang.indexOf('-') > 0) {\n              lang = lang.replace('-', '_');\n            }\n            \n            // If the language is supported by Carrot2, we'll get a non-null value\n            final LanguageCode carrot2Language = LanguageCode.forISOCode(lang);\n            if (carrot2Language != null) {\n              carrotDocument.setLanguage(carrot2Language);\n              break;\n            }\n          }\n        }\n      }\n      \n      // Add custom fields\n      if (customFields != null) {\n        for (Entry<String, String> entry : customFields.entrySet()) {\n          carrotDocument.setField(entry.getValue(), sdoc.getFieldValue(entry.getKey()));\n        }\n      }\n      \n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleFieldSpec = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetFieldSpec = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleFieldSpec);\n    String languageField = solrParams.get(CarrotParams.LANGUAGE_FIELD_NAME, null);\n    \n    // Maps Solr field names to Carrot2 custom field names\n    Map<String, String> customFields = getCustomFieldsMap(solrParams);\n\n    // Parse language code map string into a map\n    Map<String, String> languageCodeMap = Maps.newHashMap();\n    if (StringUtils.isNotBlank(languageField)) {\n      for (String pair : solrParams.get(CarrotParams.LANGUAGE_CODE_MAP, \"\").split(\"[, ]\")) {\n        final String[] split = pair.split(\":\");\n        if (split.length == 2 && StringUtils.isNotBlank(split[0]) && StringUtils.isNotBlank(split[1])) {\n          languageCodeMap.put(split[0], split[1]);\n        } else {\n          log.warn(\"Unsupported format for \" + CarrotParams.LANGUAGE_CODE_MAP\n              + \": '\" + pair + \"'. Skipping this mapping.\");\n        }\n      }\n    }\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = Maps.newHashMap();\n        snippetFieldAry = snippetFieldSpec.split(\"[, ]\");\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        args.put(HighlightParams.SNIPPETS, solrParams.getInt(CarrotParams.SUMMARY_SNIPPETS, solrParams.getInt(HighlightParams.SNIPPETS, 1)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = null;\n      \n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {\n          // should only be one value given our setup\n          // should only be one document\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          \n          final StringBuilder sb = new StringBuilder();\n          for (int j = 0; j < snippetFieldAry.length; j++) {\n            // Join fragments with a period, so that Carrot2 does not create\n            // cross-fragment phrases, such phrases rarely make sense.\n            String [] highlt = tmp.get(snippetFieldAry[j]);\n            if (highlt != null && highlt.length > 0) {\n              for (int i = 0; i < highlt.length; i++) {\n                sb.append(highlt[i]);\n                sb.append(\" . \");\n              }\n            }\n          }\n          snippet = sb.toString();\n        }\n      }\n      \n      // If summaries not enabled or summary generation failed, use full content.\n      if (snippet == null) {\n        snippet = getConcatenated(sdoc, snippetFieldSpec);\n      }\n      \n      // Create a Carrot2 document\n      Document carrotDocument = new Document(getConcatenated(sdoc, titleFieldSpec),\n              snippet, ObjectUtils.toString(sdoc.getFieldValue(urlField), \"\"));\n      \n      // Store Solr id of the document, we need it to map document instances \n      // found in clusters back to identifiers.\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      \n      // Set language\n      if (StringUtils.isNotBlank(languageField)) {\n        Collection<Object> languages = sdoc.getFieldValues(languageField);\n        if (languages != null) {\n          \n          // Use the first Carrot2-supported language\n          for (Object l : languages) {\n            String lang = ObjectUtils.toString(l, \"\");\n            \n            if (languageCodeMap.containsKey(lang)) {\n              lang = languageCodeMap.get(lang);\n            }\n            \n            // Language detection Library for Java uses dashes to separate\n            // language variants, such as 'zh-cn', but Carrot2 uses underscores.\n            if (lang.indexOf('-') > 0) {\n              lang = lang.replace('-', '_');\n            }\n            \n            // If the language is supported by Carrot2, we'll get a non-null value\n            final LanguageCode carrot2Language = LanguageCode.forISOCode(lang);\n            if (carrot2Language != null) {\n              carrotDocument.setLanguage(carrot2Language);\n              break;\n            }\n          }\n        }\n      }\n      \n      // Add custom fields\n      if (customFields != null) {\n        for (Entry<String, String> entry : customFields.entrySet()) {\n          carrotDocument.setField(entry.getValue(), sdoc.getFieldValue(entry.getKey()));\n        }\n      }\n      \n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ac6494315d04f68950d2f00f5436b4861bcd467","date":1553125039,"type":3,"author":"Kevin Risden","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","sourceNew":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleFieldSpec = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetFieldSpec = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleFieldSpec);\n    String languageField = solrParams.get(CarrotParams.LANGUAGE_FIELD_NAME, null);\n    \n    // Maps Solr field names to Carrot2 custom field names\n    Map<String, String> customFields = getCustomFieldsMap(solrParams);\n\n    // Parse language code map string into a map\n    Map<String, String> languageCodeMap = new HashMap<>();\n    if (StringUtils.isNotBlank(languageField)) {\n      for (String pair : solrParams.get(CarrotParams.LANGUAGE_CODE_MAP, \"\").split(\"[, ]\")) {\n        final String[] split = pair.split(\":\");\n        if (split.length == 2 && StringUtils.isNotBlank(split[0]) && StringUtils.isNotBlank(split[1])) {\n          languageCodeMap.put(split[0], split[1]);\n        } else {\n          log.warn(\"Unsupported format for \" + CarrotParams.LANGUAGE_CODE_MAP\n              + \": '\" + pair + \"'. Skipping this mapping.\");\n        }\n      }\n    }\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = new HashMap<>();\n        snippetFieldAry = snippetFieldSpec.split(\"[, ]\");\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        args.put(HighlightParams.SNIPPETS, solrParams.getInt(CarrotParams.SUMMARY_SNIPPETS, solrParams.getInt(HighlightParams.SNIPPETS, 1)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = null;\n      \n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {\n          // should only be one value given our setup\n          // should only be one document\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          \n          final StringBuilder sb = new StringBuilder();\n          for (int j = 0; j < snippetFieldAry.length; j++) {\n            // Join fragments with a period, so that Carrot2 does not create\n            // cross-fragment phrases, such phrases rarely make sense.\n            String [] highlt = tmp.get(snippetFieldAry[j]);\n            if (highlt != null && highlt.length > 0) {\n              for (int i = 0; i < highlt.length; i++) {\n                sb.append(highlt[i]);\n                sb.append(\" . \");\n              }\n            }\n          }\n          snippet = sb.toString();\n        }\n      }\n      \n      // If summaries not enabled or summary generation failed, use full content.\n      if (snippet == null) {\n        snippet = getConcatenated(sdoc, snippetFieldSpec);\n      }\n      \n      // Create a Carrot2 document\n      Document carrotDocument = new Document(getConcatenated(sdoc, titleFieldSpec),\n              snippet, Objects.toString(sdoc.getFieldValue(urlField), \"\"));\n      \n      // Store Solr id of the document, we need it to map document instances \n      // found in clusters back to identifiers.\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      \n      // Set language\n      if (StringUtils.isNotBlank(languageField)) {\n        Collection<Object> languages = sdoc.getFieldValues(languageField);\n        if (languages != null) {\n          \n          // Use the first Carrot2-supported language\n          for (Object l : languages) {\n            String lang = Objects.toString(l, \"\");\n            \n            if (languageCodeMap.containsKey(lang)) {\n              lang = languageCodeMap.get(lang);\n            }\n            \n            // Language detection Library for Java uses dashes to separate\n            // language variants, such as 'zh-cn', but Carrot2 uses underscores.\n            if (lang.indexOf('-') > 0) {\n              lang = lang.replace('-', '_');\n            }\n            \n            // If the language is supported by Carrot2, we'll get a non-null value\n            final LanguageCode carrot2Language = LanguageCode.forISOCode(lang);\n            if (carrot2Language != null) {\n              carrotDocument.setLanguage(carrot2Language);\n              break;\n            }\n          }\n        }\n      }\n      \n      // Add custom fields\n      if (customFields != null) {\n        for (Entry<String, String> entry : customFields.entrySet()) {\n          carrotDocument.setField(entry.getValue(), sdoc.getFieldValue(entry.getKey()));\n        }\n      }\n      \n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleFieldSpec = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetFieldSpec = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleFieldSpec);\n    String languageField = solrParams.get(CarrotParams.LANGUAGE_FIELD_NAME, null);\n    \n    // Maps Solr field names to Carrot2 custom field names\n    Map<String, String> customFields = getCustomFieldsMap(solrParams);\n\n    // Parse language code map string into a map\n    Map<String, String> languageCodeMap = new HashMap<>();\n    if (StringUtils.isNotBlank(languageField)) {\n      for (String pair : solrParams.get(CarrotParams.LANGUAGE_CODE_MAP, \"\").split(\"[, ]\")) {\n        final String[] split = pair.split(\":\");\n        if (split.length == 2 && StringUtils.isNotBlank(split[0]) && StringUtils.isNotBlank(split[1])) {\n          languageCodeMap.put(split[0], split[1]);\n        } else {\n          log.warn(\"Unsupported format for \" + CarrotParams.LANGUAGE_CODE_MAP\n              + \": '\" + pair + \"'. Skipping this mapping.\");\n        }\n      }\n    }\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = new HashMap<>();\n        snippetFieldAry = snippetFieldSpec.split(\"[, ]\");\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        args.put(HighlightParams.SNIPPETS, solrParams.getInt(CarrotParams.SUMMARY_SNIPPETS, solrParams.getInt(HighlightParams.SNIPPETS, 1)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = null;\n      \n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {\n          // should only be one value given our setup\n          // should only be one document\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          \n          final StringBuilder sb = new StringBuilder();\n          for (int j = 0; j < snippetFieldAry.length; j++) {\n            // Join fragments with a period, so that Carrot2 does not create\n            // cross-fragment phrases, such phrases rarely make sense.\n            String [] highlt = tmp.get(snippetFieldAry[j]);\n            if (highlt != null && highlt.length > 0) {\n              for (int i = 0; i < highlt.length; i++) {\n                sb.append(highlt[i]);\n                sb.append(\" . \");\n              }\n            }\n          }\n          snippet = sb.toString();\n        }\n      }\n      \n      // If summaries not enabled or summary generation failed, use full content.\n      if (snippet == null) {\n        snippet = getConcatenated(sdoc, snippetFieldSpec);\n      }\n      \n      // Create a Carrot2 document\n      Document carrotDocument = new Document(getConcatenated(sdoc, titleFieldSpec),\n              snippet, ObjectUtils.toString(sdoc.getFieldValue(urlField), \"\"));\n      \n      // Store Solr id of the document, we need it to map document instances \n      // found in clusters back to identifiers.\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      \n      // Set language\n      if (StringUtils.isNotBlank(languageField)) {\n        Collection<Object> languages = sdoc.getFieldValues(languageField);\n        if (languages != null) {\n          \n          // Use the first Carrot2-supported language\n          for (Object l : languages) {\n            String lang = ObjectUtils.toString(l, \"\");\n            \n            if (languageCodeMap.containsKey(lang)) {\n              lang = languageCodeMap.get(lang);\n            }\n            \n            // Language detection Library for Java uses dashes to separate\n            // language variants, such as 'zh-cn', but Carrot2 uses underscores.\n            if (lang.indexOf('-') > 0) {\n              lang = lang.replace('-', '_');\n            }\n            \n            // If the language is supported by Carrot2, we'll get a non-null value\n            final LanguageCode carrot2Language = LanguageCode.forISOCode(lang);\n            if (carrot2Language != null) {\n              carrotDocument.setLanguage(carrot2Language);\n              break;\n            }\n          }\n        }\n      }\n      \n      // Add custom fields\n      if (customFields != null) {\n        for (Entry<String, String> entry : customFields.entrySet()) {\n          carrotDocument.setField(entry.getValue(), sdoc.getFieldValue(entry.getKey()));\n        }\n      }\n      \n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9","date":1574619880,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","sourceNew":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  @SuppressWarnings(\"deprecation\")\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleFieldSpec = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetFieldSpec = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleFieldSpec);\n    String languageField = solrParams.get(CarrotParams.LANGUAGE_FIELD_NAME, null);\n    \n    // Maps Solr field names to Carrot2 custom field names\n    Map<String, String> customFields = getCustomFieldsMap(solrParams);\n\n    // Parse language code map string into a map\n    Map<String, String> languageCodeMap = new HashMap<>();\n    if (StringUtils.isNotBlank(languageField)) {\n      for (String pair : solrParams.get(CarrotParams.LANGUAGE_CODE_MAP, \"\").split(\"[, ]\")) {\n        final String[] split = pair.split(\":\");\n        if (split.length == 2 && StringUtils.isNotBlank(split[0]) && StringUtils.isNotBlank(split[1])) {\n          languageCodeMap.put(split[0], split[1]);\n        } else {\n          log.warn(\"Unsupported format for \" + CarrotParams.LANGUAGE_CODE_MAP\n              + \": '\" + pair + \"'. Skipping this mapping.\");\n        }\n      }\n    }\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = new HashMap<>();\n        snippetFieldAry = snippetFieldSpec.split(\"[, ]\");\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        args.put(HighlightParams.SNIPPETS, solrParams.getInt(CarrotParams.SUMMARY_SNIPPETS, solrParams.getInt(HighlightParams.SNIPPETS, 1)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = null;\n      \n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {\n          // should only be one value given our setup\n          // should only be one document\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          \n          final StringBuilder sb = new StringBuilder();\n          for (int j = 0; j < snippetFieldAry.length; j++) {\n            // Join fragments with a period, so that Carrot2 does not create\n            // cross-fragment phrases, such phrases rarely make sense.\n            String [] highlt = tmp.get(snippetFieldAry[j]);\n            if (highlt != null && highlt.length > 0) {\n              for (int i = 0; i < highlt.length; i++) {\n                sb.append(highlt[i]);\n                sb.append(\" . \");\n              }\n            }\n          }\n          snippet = sb.toString();\n        }\n      }\n      \n      // If summaries not enabled or summary generation failed, use full content.\n      if (snippet == null) {\n        snippet = getConcatenated(sdoc, snippetFieldSpec);\n      }\n      \n      // Create a Carrot2 document\n      Document carrotDocument = new Document(getConcatenated(sdoc, titleFieldSpec),\n              snippet, Objects.toString(sdoc.getFieldValue(urlField), \"\"));\n      \n      // Store Solr id of the document, we need it to map document instances \n      // found in clusters back to identifiers.\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      \n      // Set language\n      if (StringUtils.isNotBlank(languageField)) {\n        Collection<Object> languages = sdoc.getFieldValues(languageField);\n        if (languages != null) {\n          \n          // Use the first Carrot2-supported language\n          for (Object l : languages) {\n            String lang = Objects.toString(l, \"\");\n            \n            if (languageCodeMap.containsKey(lang)) {\n              lang = languageCodeMap.get(lang);\n            }\n            \n            // Language detection Library for Java uses dashes to separate\n            // language variants, such as 'zh-cn', but Carrot2 uses underscores.\n            if (lang.indexOf('-') > 0) {\n              lang = lang.replace('-', '_');\n            }\n            \n            // If the language is supported by Carrot2, we'll get a non-null value\n            final LanguageCode carrot2Language = LanguageCode.forISOCode(lang);\n            if (carrot2Language != null) {\n              carrotDocument.setLanguage(carrot2Language);\n              break;\n            }\n          }\n        }\n      }\n      \n      // Add custom fields\n      if (customFields != null) {\n        for (Entry<String, String> entry : customFields.entrySet()) {\n          carrotDocument.setField(entry.getValue(), sdoc.getFieldValue(entry.getKey()));\n        }\n      }\n      \n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleFieldSpec = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetFieldSpec = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleFieldSpec);\n    String languageField = solrParams.get(CarrotParams.LANGUAGE_FIELD_NAME, null);\n    \n    // Maps Solr field names to Carrot2 custom field names\n    Map<String, String> customFields = getCustomFieldsMap(solrParams);\n\n    // Parse language code map string into a map\n    Map<String, String> languageCodeMap = new HashMap<>();\n    if (StringUtils.isNotBlank(languageField)) {\n      for (String pair : solrParams.get(CarrotParams.LANGUAGE_CODE_MAP, \"\").split(\"[, ]\")) {\n        final String[] split = pair.split(\":\");\n        if (split.length == 2 && StringUtils.isNotBlank(split[0]) && StringUtils.isNotBlank(split[1])) {\n          languageCodeMap.put(split[0], split[1]);\n        } else {\n          log.warn(\"Unsupported format for \" + CarrotParams.LANGUAGE_CODE_MAP\n              + \": '\" + pair + \"'. Skipping this mapping.\");\n        }\n      }\n    }\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = new HashMap<>();\n        snippetFieldAry = snippetFieldSpec.split(\"[, ]\");\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        args.put(HighlightParams.SNIPPETS, solrParams.getInt(CarrotParams.SUMMARY_SNIPPETS, solrParams.getInt(HighlightParams.SNIPPETS, 1)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = null;\n      \n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {\n          // should only be one value given our setup\n          // should only be one document\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          \n          final StringBuilder sb = new StringBuilder();\n          for (int j = 0; j < snippetFieldAry.length; j++) {\n            // Join fragments with a period, so that Carrot2 does not create\n            // cross-fragment phrases, such phrases rarely make sense.\n            String [] highlt = tmp.get(snippetFieldAry[j]);\n            if (highlt != null && highlt.length > 0) {\n              for (int i = 0; i < highlt.length; i++) {\n                sb.append(highlt[i]);\n                sb.append(\" . \");\n              }\n            }\n          }\n          snippet = sb.toString();\n        }\n      }\n      \n      // If summaries not enabled or summary generation failed, use full content.\n      if (snippet == null) {\n        snippet = getConcatenated(sdoc, snippetFieldSpec);\n      }\n      \n      // Create a Carrot2 document\n      Document carrotDocument = new Document(getConcatenated(sdoc, titleFieldSpec),\n              snippet, Objects.toString(sdoc.getFieldValue(urlField), \"\"));\n      \n      // Store Solr id of the document, we need it to map document instances \n      // found in clusters back to identifiers.\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      \n      // Set language\n      if (StringUtils.isNotBlank(languageField)) {\n        Collection<Object> languages = sdoc.getFieldValues(languageField);\n        if (languages != null) {\n          \n          // Use the first Carrot2-supported language\n          for (Object l : languages) {\n            String lang = Objects.toString(l, \"\");\n            \n            if (languageCodeMap.containsKey(lang)) {\n              lang = languageCodeMap.get(lang);\n            }\n            \n            // Language detection Library for Java uses dashes to separate\n            // language variants, such as 'zh-cn', but Carrot2 uses underscores.\n            if (lang.indexOf('-') > 0) {\n              lang = lang.replace('-', '_');\n            }\n            \n            // If the language is supported by Carrot2, we'll get a non-null value\n            final LanguageCode carrot2Language = LanguageCode.forISOCode(lang);\n            if (carrot2Language != null) {\n              carrotDocument.setLanguage(carrot2Language);\n              break;\n            }\n          }\n        }\n      }\n      \n      // Add custom fields\n      if (customFields != null) {\n        for (Entry<String, String> entry : customFields.entrySet()) {\n          carrotDocument.setField(entry.getValue(), sdoc.getFieldValue(entry.getKey()));\n        }\n      }\n      \n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb9c3baacabd473e8ecd6c4948aabacead49b88e","date":1574700980,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","sourceNew":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleFieldSpec = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetFieldSpec = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleFieldSpec);\n    String languageField = solrParams.get(CarrotParams.LANGUAGE_FIELD_NAME, null);\n    \n    // Maps Solr field names to Carrot2 custom field names\n    Map<String, String> customFields = getCustomFieldsMap(solrParams);\n\n    // Parse language code map string into a map\n    Map<String, String> languageCodeMap = new HashMap<>();\n    if (StringUtils.isNotBlank(languageField)) {\n      for (String pair : solrParams.get(CarrotParams.LANGUAGE_CODE_MAP, \"\").split(\"[, ]\")) {\n        final String[] split = pair.split(\":\");\n        if (split.length == 2 && StringUtils.isNotBlank(split[0]) && StringUtils.isNotBlank(split[1])) {\n          languageCodeMap.put(split[0], split[1]);\n        } else {\n          log.warn(\"Unsupported format for \" + CarrotParams.LANGUAGE_CODE_MAP\n              + \": '\" + pair + \"'. Skipping this mapping.\");\n        }\n      }\n    }\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = new HashMap<>();\n        snippetFieldAry = snippetFieldSpec.split(\"[, ]\");\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        args.put(HighlightParams.SNIPPETS, solrParams.getInt(CarrotParams.SUMMARY_SNIPPETS, solrParams.getInt(HighlightParams.SNIPPETS, 1)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = null;\n      \n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {\n          // should only be one value given our setup\n          // should only be one document\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          \n          final StringBuilder sb = new StringBuilder();\n          for (int j = 0; j < snippetFieldAry.length; j++) {\n            // Join fragments with a period, so that Carrot2 does not create\n            // cross-fragment phrases, such phrases rarely make sense.\n            String [] highlt = tmp.get(snippetFieldAry[j]);\n            if (highlt != null && highlt.length > 0) {\n              for (int i = 0; i < highlt.length; i++) {\n                sb.append(highlt[i]);\n                sb.append(\" . \");\n              }\n            }\n          }\n          snippet = sb.toString();\n        }\n      }\n      \n      // If summaries not enabled or summary generation failed, use full content.\n      if (snippet == null) {\n        snippet = getConcatenated(sdoc, snippetFieldSpec);\n      }\n      \n      // Create a Carrot2 document\n      Document carrotDocument = new Document(getConcatenated(sdoc, titleFieldSpec),\n              snippet, Objects.toString(sdoc.getFieldValue(urlField), \"\"));\n      \n      // Store Solr id of the document, we need it to map document instances \n      // found in clusters back to identifiers.\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      \n      // Set language\n      if (StringUtils.isNotBlank(languageField)) {\n        Collection<Object> languages = sdoc.getFieldValues(languageField);\n        if (languages != null) {\n          \n          // Use the first Carrot2-supported language\n          for (Object l : languages) {\n            String lang = Objects.toString(l, \"\");\n            \n            if (languageCodeMap.containsKey(lang)) {\n              lang = languageCodeMap.get(lang);\n            }\n            \n            // Language detection Library for Java uses dashes to separate\n            // language variants, such as 'zh-cn', but Carrot2 uses underscores.\n            if (lang.indexOf('-') > 0) {\n              lang = lang.replace('-', '_');\n            }\n            \n            // If the language is supported by Carrot2, we'll get a non-null value\n            final LanguageCode carrot2Language = LanguageCode.forISOCode(lang);\n            if (carrot2Language != null) {\n              carrotDocument.setLanguage(carrot2Language);\n              break;\n            }\n          }\n        }\n      }\n      \n      // Add custom fields\n      if (customFields != null) {\n        for (Entry<String, String> entry : customFields.entrySet()) {\n          carrotDocument.setField(entry.getValue(), sdoc.getFieldValue(entry.getKey()));\n        }\n      }\n      \n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  @SuppressWarnings(\"deprecation\")\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleFieldSpec = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetFieldSpec = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleFieldSpec);\n    String languageField = solrParams.get(CarrotParams.LANGUAGE_FIELD_NAME, null);\n    \n    // Maps Solr field names to Carrot2 custom field names\n    Map<String, String> customFields = getCustomFieldsMap(solrParams);\n\n    // Parse language code map string into a map\n    Map<String, String> languageCodeMap = new HashMap<>();\n    if (StringUtils.isNotBlank(languageField)) {\n      for (String pair : solrParams.get(CarrotParams.LANGUAGE_CODE_MAP, \"\").split(\"[, ]\")) {\n        final String[] split = pair.split(\":\");\n        if (split.length == 2 && StringUtils.isNotBlank(split[0]) && StringUtils.isNotBlank(split[1])) {\n          languageCodeMap.put(split[0], split[1]);\n        } else {\n          log.warn(\"Unsupported format for \" + CarrotParams.LANGUAGE_CODE_MAP\n              + \": '\" + pair + \"'. Skipping this mapping.\");\n        }\n      }\n    }\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = new HashMap<>();\n        snippetFieldAry = snippetFieldSpec.split(\"[, ]\");\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        args.put(HighlightParams.SNIPPETS, solrParams.getInt(CarrotParams.SUMMARY_SNIPPETS, solrParams.getInt(HighlightParams.SNIPPETS, 1)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = null;\n      \n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {\n          // should only be one value given our setup\n          // should only be one document\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          \n          final StringBuilder sb = new StringBuilder();\n          for (int j = 0; j < snippetFieldAry.length; j++) {\n            // Join fragments with a period, so that Carrot2 does not create\n            // cross-fragment phrases, such phrases rarely make sense.\n            String [] highlt = tmp.get(snippetFieldAry[j]);\n            if (highlt != null && highlt.length > 0) {\n              for (int i = 0; i < highlt.length; i++) {\n                sb.append(highlt[i]);\n                sb.append(\" . \");\n              }\n            }\n          }\n          snippet = sb.toString();\n        }\n      }\n      \n      // If summaries not enabled or summary generation failed, use full content.\n      if (snippet == null) {\n        snippet = getConcatenated(sdoc, snippetFieldSpec);\n      }\n      \n      // Create a Carrot2 document\n      Document carrotDocument = new Document(getConcatenated(sdoc, titleFieldSpec),\n              snippet, Objects.toString(sdoc.getFieldValue(urlField), \"\"));\n      \n      // Store Solr id of the document, we need it to map document instances \n      // found in clusters back to identifiers.\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      \n      // Set language\n      if (StringUtils.isNotBlank(languageField)) {\n        Collection<Object> languages = sdoc.getFieldValues(languageField);\n        if (languages != null) {\n          \n          // Use the first Carrot2-supported language\n          for (Object l : languages) {\n            String lang = Objects.toString(l, \"\");\n            \n            if (languageCodeMap.containsKey(lang)) {\n              lang = languageCodeMap.get(lang);\n            }\n            \n            // Language detection Library for Java uses dashes to separate\n            // language variants, such as 'zh-cn', but Carrot2 uses underscores.\n            if (lang.indexOf('-') > 0) {\n              lang = lang.replace('-', '_');\n            }\n            \n            // If the language is supported by Carrot2, we'll get a non-null value\n            final LanguageCode carrot2Language = LanguageCode.forISOCode(lang);\n            if (carrot2Language != null) {\n              carrotDocument.setLanguage(carrot2Language);\n              break;\n            }\n          }\n        }\n      }\n      \n      // Add custom fields\n      if (customFields != null) {\n        for (Entry<String, String> entry : customFields.entrySet()) {\n          carrotDocument.setField(entry.getValue(), sdoc.getFieldValue(entry.getKey()));\n        }\n      }\n      \n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","sourceNew":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleFieldSpec = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetFieldSpec = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleFieldSpec);\n    String languageField = solrParams.get(CarrotParams.LANGUAGE_FIELD_NAME, null);\n    \n    // Maps Solr field names to Carrot2 custom field names\n    Map<String, String> customFields = getCustomFieldsMap(solrParams);\n\n    // Parse language code map string into a map\n    Map<String, String> languageCodeMap = new HashMap<>();\n    if (StringUtils.isNotBlank(languageField)) {\n      for (String pair : solrParams.get(CarrotParams.LANGUAGE_CODE_MAP, \"\").split(\"[, ]\")) {\n        final String[] split = pair.split(\":\");\n        if (split.length == 2 && StringUtils.isNotBlank(split[0]) && StringUtils.isNotBlank(split[1])) {\n          languageCodeMap.put(split[0], split[1]);\n        } else {\n          log.warn(\"Unsupported format for {}: '{}'. Skipping this mapping.\"\n              , CarrotParams.LANGUAGE_CODE_MAP, pair);\n        }\n      }\n    }\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = new HashMap<>();\n        snippetFieldAry = snippetFieldSpec.split(\"[, ]\");\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        args.put(HighlightParams.SNIPPETS, solrParams.getInt(CarrotParams.SUMMARY_SNIPPETS, solrParams.getInt(HighlightParams.SNIPPETS, 1)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = null;\n      \n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {\n          // should only be one value given our setup\n          // should only be one document\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          \n          final StringBuilder sb = new StringBuilder();\n          for (int j = 0; j < snippetFieldAry.length; j++) {\n            // Join fragments with a period, so that Carrot2 does not create\n            // cross-fragment phrases, such phrases rarely make sense.\n            String [] highlt = tmp.get(snippetFieldAry[j]);\n            if (highlt != null && highlt.length > 0) {\n              for (int i = 0; i < highlt.length; i++) {\n                sb.append(highlt[i]);\n                sb.append(\" . \");\n              }\n            }\n          }\n          snippet = sb.toString();\n        }\n      }\n      \n      // If summaries not enabled or summary generation failed, use full content.\n      if (snippet == null) {\n        snippet = getConcatenated(sdoc, snippetFieldSpec);\n      }\n      \n      // Create a Carrot2 document\n      Document carrotDocument = new Document(getConcatenated(sdoc, titleFieldSpec),\n              snippet, Objects.toString(sdoc.getFieldValue(urlField), \"\"));\n      \n      // Store Solr id of the document, we need it to map document instances \n      // found in clusters back to identifiers.\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      \n      // Set language\n      if (StringUtils.isNotBlank(languageField)) {\n        Collection<Object> languages = sdoc.getFieldValues(languageField);\n        if (languages != null) {\n          \n          // Use the first Carrot2-supported language\n          for (Object l : languages) {\n            String lang = Objects.toString(l, \"\");\n            \n            if (languageCodeMap.containsKey(lang)) {\n              lang = languageCodeMap.get(lang);\n            }\n            \n            // Language detection Library for Java uses dashes to separate\n            // language variants, such as 'zh-cn', but Carrot2 uses underscores.\n            if (lang.indexOf('-') > 0) {\n              lang = lang.replace('-', '_');\n            }\n            \n            // If the language is supported by Carrot2, we'll get a non-null value\n            final LanguageCode carrot2Language = LanguageCode.forISOCode(lang);\n            if (carrot2Language != null) {\n              carrotDocument.setLanguage(carrot2Language);\n              break;\n            }\n          }\n        }\n      }\n      \n      // Add custom fields\n      if (customFields != null) {\n        for (Entry<String, String> entry : customFields.entrySet()) {\n          carrotDocument.setField(entry.getValue(), sdoc.getFieldValue(entry.getKey()));\n        }\n      }\n      \n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleFieldSpec = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetFieldSpec = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleFieldSpec);\n    String languageField = solrParams.get(CarrotParams.LANGUAGE_FIELD_NAME, null);\n    \n    // Maps Solr field names to Carrot2 custom field names\n    Map<String, String> customFields = getCustomFieldsMap(solrParams);\n\n    // Parse language code map string into a map\n    Map<String, String> languageCodeMap = new HashMap<>();\n    if (StringUtils.isNotBlank(languageField)) {\n      for (String pair : solrParams.get(CarrotParams.LANGUAGE_CODE_MAP, \"\").split(\"[, ]\")) {\n        final String[] split = pair.split(\":\");\n        if (split.length == 2 && StringUtils.isNotBlank(split[0]) && StringUtils.isNotBlank(split[1])) {\n          languageCodeMap.put(split[0], split[1]);\n        } else {\n          log.warn(\"Unsupported format for \" + CarrotParams.LANGUAGE_CODE_MAP\n              + \": '\" + pair + \"'. Skipping this mapping.\");\n        }\n      }\n    }\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = new HashMap<>();\n        snippetFieldAry = snippetFieldSpec.split(\"[, ]\");\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        args.put(HighlightParams.SNIPPETS, solrParams.getInt(CarrotParams.SUMMARY_SNIPPETS, solrParams.getInt(HighlightParams.SNIPPETS, 1)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = null;\n      \n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {\n          // should only be one value given our setup\n          // should only be one document\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          \n          final StringBuilder sb = new StringBuilder();\n          for (int j = 0; j < snippetFieldAry.length; j++) {\n            // Join fragments with a period, so that Carrot2 does not create\n            // cross-fragment phrases, such phrases rarely make sense.\n            String [] highlt = tmp.get(snippetFieldAry[j]);\n            if (highlt != null && highlt.length > 0) {\n              for (int i = 0; i < highlt.length; i++) {\n                sb.append(highlt[i]);\n                sb.append(\" . \");\n              }\n            }\n          }\n          snippet = sb.toString();\n        }\n      }\n      \n      // If summaries not enabled or summary generation failed, use full content.\n      if (snippet == null) {\n        snippet = getConcatenated(sdoc, snippetFieldSpec);\n      }\n      \n      // Create a Carrot2 document\n      Document carrotDocument = new Document(getConcatenated(sdoc, titleFieldSpec),\n              snippet, Objects.toString(sdoc.getFieldValue(urlField), \"\"));\n      \n      // Store Solr id of the document, we need it to map document instances \n      // found in clusters back to identifiers.\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      \n      // Set language\n      if (StringUtils.isNotBlank(languageField)) {\n        Collection<Object> languages = sdoc.getFieldValues(languageField);\n        if (languages != null) {\n          \n          // Use the first Carrot2-supported language\n          for (Object l : languages) {\n            String lang = Objects.toString(l, \"\");\n            \n            if (languageCodeMap.containsKey(lang)) {\n              lang = languageCodeMap.get(lang);\n            }\n            \n            // Language detection Library for Java uses dashes to separate\n            // language variants, such as 'zh-cn', but Carrot2 uses underscores.\n            if (lang.indexOf('-') > 0) {\n              lang = lang.replace('-', '_');\n            }\n            \n            // If the language is supported by Carrot2, we'll get a non-null value\n            final LanguageCode carrot2Language = LanguageCode.forISOCode(lang);\n            if (carrot2Language != null) {\n              carrotDocument.setLanguage(carrot2Language);\n              break;\n            }\n          }\n        }\n      }\n      \n      // Add custom fields\n      if (customFields != null) {\n        for (Entry<String, String> entry : customFields.entrySet()) {\n          carrotDocument.setField(entry.getValue(), sdoc.getFieldValue(entry.getKey()));\n        }\n      }\n      \n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"640ded7811e1b7d29236a5e2934ec3cd266a8199","date":1588973147,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#getDocuments(SolrDocumentList,Map[SolrDocument,Integer],Query,SolrQueryRequest).mjava","sourceNew":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleFieldSpec = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetFieldSpec = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleFieldSpec);\n    String languageField = solrParams.get(CarrotParams.LANGUAGE_FIELD_NAME, null);\n    \n    // Maps Solr field names to Carrot2 custom field names\n    Map<String, String> customFields = getCustomFieldsMap(solrParams);\n\n    // Parse language code map string into a map\n    Map<String, String> languageCodeMap = new HashMap<>();\n    if (StringUtils.isNotBlank(languageField)) {\n      for (String pair : solrParams.get(CarrotParams.LANGUAGE_CODE_MAP, \"\").split(\"[, ]\")) {\n        final String[] split = pair.split(\":\");\n        if (split.length == 2 && StringUtils.isNotBlank(split[0]) && StringUtils.isNotBlank(split[1])) {\n          languageCodeMap.put(split[0], split[1]);\n        } else {\n          log.warn(\"Unsupported format for {}: '{}'. Skipping this mapping.\"\n              , CarrotParams.LANGUAGE_CODE_MAP, pair);\n        }\n      }\n    }\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = new HashMap<>();\n        snippetFieldAry = snippetFieldSpec.split(\"[, ]\");\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        args.put(HighlightParams.SNIPPETS, solrParams.getInt(CarrotParams.SUMMARY_SNIPPETS, solrParams.getInt(HighlightParams.SNIPPETS, 1)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = null;\n      \n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f, TotalHits.Relation.EQUAL_TO);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {\n          // should only be one value given our setup\n          // should only be one document\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          \n          final StringBuilder sb = new StringBuilder();\n          for (int j = 0; j < snippetFieldAry.length; j++) {\n            // Join fragments with a period, so that Carrot2 does not create\n            // cross-fragment phrases, such phrases rarely make sense.\n            String [] highlt = tmp.get(snippetFieldAry[j]);\n            if (highlt != null && highlt.length > 0) {\n              for (int i = 0; i < highlt.length; i++) {\n                sb.append(highlt[i]);\n                sb.append(\" . \");\n              }\n            }\n          }\n          snippet = sb.toString();\n        }\n      }\n      \n      // If summaries not enabled or summary generation failed, use full content.\n      if (snippet == null) {\n        snippet = getConcatenated(sdoc, snippetFieldSpec);\n      }\n      \n      // Create a Carrot2 document\n      Document carrotDocument = new Document(getConcatenated(sdoc, titleFieldSpec),\n              snippet, Objects.toString(sdoc.getFieldValue(urlField), \"\"));\n      \n      // Store Solr id of the document, we need it to map document instances \n      // found in clusters back to identifiers.\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      \n      // Set language\n      if (StringUtils.isNotBlank(languageField)) {\n        Collection<Object> languages = sdoc.getFieldValues(languageField);\n        if (languages != null) {\n          \n          // Use the first Carrot2-supported language\n          for (Object l : languages) {\n            String lang = Objects.toString(l, \"\");\n            \n            if (languageCodeMap.containsKey(lang)) {\n              lang = languageCodeMap.get(lang);\n            }\n            \n            // Language detection Library for Java uses dashes to separate\n            // language variants, such as 'zh-cn', but Carrot2 uses underscores.\n            if (lang.indexOf('-') > 0) {\n              lang = lang.replace('-', '_');\n            }\n            \n            // If the language is supported by Carrot2, we'll get a non-null value\n            final LanguageCode carrot2Language = LanguageCode.forISOCode(lang);\n            if (carrot2Language != null) {\n              carrotDocument.setLanguage(carrot2Language);\n              break;\n            }\n          }\n        }\n      }\n      \n      // Add custom fields\n      if (customFields != null) {\n        for (Entry<String, String> entry : customFields.entrySet()) {\n          carrotDocument.setField(entry.getValue(), sdoc.getFieldValue(entry.getKey()));\n        }\n      }\n      \n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Prepares Carrot2 documents for clustering.\n   */\n  private List<Document> getDocuments(SolrDocumentList solrDocList, Map<SolrDocument, Integer> docIds,\n                                      Query query, final SolrQueryRequest sreq) throws IOException {\n    SolrHighlighter highlighter = null;\n    SolrParams solrParams = sreq.getParams();\n    SolrCore core = sreq.getCore();\n\n    String urlField = solrParams.get(CarrotParams.URL_FIELD_NAME, \"url\");\n    String titleFieldSpec = solrParams.get(CarrotParams.TITLE_FIELD_NAME, \"title\");\n    String snippetFieldSpec = solrParams.get(CarrotParams.SNIPPET_FIELD_NAME, titleFieldSpec);\n    String languageField = solrParams.get(CarrotParams.LANGUAGE_FIELD_NAME, null);\n    \n    // Maps Solr field names to Carrot2 custom field names\n    Map<String, String> customFields = getCustomFieldsMap(solrParams);\n\n    // Parse language code map string into a map\n    Map<String, String> languageCodeMap = new HashMap<>();\n    if (StringUtils.isNotBlank(languageField)) {\n      for (String pair : solrParams.get(CarrotParams.LANGUAGE_CODE_MAP, \"\").split(\"[, ]\")) {\n        final String[] split = pair.split(\":\");\n        if (split.length == 2 && StringUtils.isNotBlank(split[0]) && StringUtils.isNotBlank(split[1])) {\n          languageCodeMap.put(split[0], split[1]);\n        } else {\n          log.warn(\"Unsupported format for {}: '{}'. Skipping this mapping.\"\n              , CarrotParams.LANGUAGE_CODE_MAP, pair);\n        }\n      }\n    }\n    \n    // Get the documents\n    boolean produceSummary = solrParams.getBool(CarrotParams.PRODUCE_SUMMARY, false);\n\n    SolrQueryRequest req = null;\n    String[] snippetFieldAry = null;\n    if (produceSummary) {\n      highlighter = HighlightComponent.getHighlighter(core);\n      if (highlighter != null){\n        Map<String, Object> args = new HashMap<>();\n        snippetFieldAry = snippetFieldSpec.split(\"[, ]\");\n        args.put(HighlightParams.FIELDS, snippetFieldAry);\n        args.put(HighlightParams.HIGHLIGHT, \"true\");\n        args.put(HighlightParams.SIMPLE_PRE, \"\"); //we don't care about actually highlighting the area\n        args.put(HighlightParams.SIMPLE_POST, \"\");\n        args.put(HighlightParams.FRAGSIZE, solrParams.getInt(CarrotParams.SUMMARY_FRAGSIZE, solrParams.getInt(HighlightParams.FRAGSIZE, 100)));\n        args.put(HighlightParams.SNIPPETS, solrParams.getInt(CarrotParams.SUMMARY_SNIPPETS, solrParams.getInt(HighlightParams.SNIPPETS, 1)));\n        req = new LocalSolrQueryRequest(core, query.toString(), \"\", 0, 1, args) {\n          @Override\n          public SolrIndexSearcher getSearcher() {\n            return sreq.getSearcher();\n          }\n        };\n      } else {\n        log.warn(\"No highlighter configured, cannot produce summary\");\n        produceSummary = false;\n      }\n    }\n\n    Iterator<SolrDocument> docsIter = solrDocList.iterator();\n    List<Document> result = new ArrayList<>(solrDocList.size());\n\n    float[] scores = {1.0f};\n    int[] docsHolder = new int[1];\n    Query theQuery = query;\n\n    while (docsIter.hasNext()) {\n      SolrDocument sdoc = docsIter.next();\n      String snippet = null;\n      \n      // TODO: docIds will be null when running distributed search.\n      // See comment in ClusteringComponent#finishStage().\n      if (produceSummary && docIds != null) {\n        docsHolder[0] = docIds.get(sdoc).intValue();\n        DocList docAsList = new DocSlice(0, 1, docsHolder, scores, 1, 1.0f);\n        NamedList<Object> highlights = highlighter.doHighlighting(docAsList, theQuery, req, snippetFieldAry);\n        if (highlights != null && highlights.size() == 1) {\n          // should only be one value given our setup\n          // should only be one document\n          @SuppressWarnings(\"unchecked\")\n          NamedList<String []> tmp = (NamedList<String[]>) highlights.getVal(0);\n          \n          final StringBuilder sb = new StringBuilder();\n          for (int j = 0; j < snippetFieldAry.length; j++) {\n            // Join fragments with a period, so that Carrot2 does not create\n            // cross-fragment phrases, such phrases rarely make sense.\n            String [] highlt = tmp.get(snippetFieldAry[j]);\n            if (highlt != null && highlt.length > 0) {\n              for (int i = 0; i < highlt.length; i++) {\n                sb.append(highlt[i]);\n                sb.append(\" . \");\n              }\n            }\n          }\n          snippet = sb.toString();\n        }\n      }\n      \n      // If summaries not enabled or summary generation failed, use full content.\n      if (snippet == null) {\n        snippet = getConcatenated(sdoc, snippetFieldSpec);\n      }\n      \n      // Create a Carrot2 document\n      Document carrotDocument = new Document(getConcatenated(sdoc, titleFieldSpec),\n              snippet, Objects.toString(sdoc.getFieldValue(urlField), \"\"));\n      \n      // Store Solr id of the document, we need it to map document instances \n      // found in clusters back to identifiers.\n      carrotDocument.setField(SOLR_DOCUMENT_ID, sdoc.getFieldValue(idFieldName));\n      \n      // Set language\n      if (StringUtils.isNotBlank(languageField)) {\n        Collection<Object> languages = sdoc.getFieldValues(languageField);\n        if (languages != null) {\n          \n          // Use the first Carrot2-supported language\n          for (Object l : languages) {\n            String lang = Objects.toString(l, \"\");\n            \n            if (languageCodeMap.containsKey(lang)) {\n              lang = languageCodeMap.get(lang);\n            }\n            \n            // Language detection Library for Java uses dashes to separate\n            // language variants, such as 'zh-cn', but Carrot2 uses underscores.\n            if (lang.indexOf('-') > 0) {\n              lang = lang.replace('-', '_');\n            }\n            \n            // If the language is supported by Carrot2, we'll get a non-null value\n            final LanguageCode carrot2Language = LanguageCode.forISOCode(lang);\n            if (carrot2Language != null) {\n              carrotDocument.setLanguage(carrot2Language);\n              break;\n            }\n          }\n        }\n      }\n      \n      // Add custom fields\n      if (customFields != null) {\n        for (Entry<String, String> entry : customFields.entrySet()) {\n          carrotDocument.setField(entry.getValue(), sdoc.getFieldValue(entry.getKey()));\n        }\n      }\n      \n      result.add(carrotDocument);\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["c2f15ce56e25538825682a41ccb854c1d82e0e95"],"640ded7811e1b7d29236a5e2934ec3cd266a8199":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9":["0ac6494315d04f68950d2f00f5436b4861bcd467"],"57123f858a48ace813624f9da70ca12bd803571f":["f25fe5576647e3bdd2a797a9900982532d5e2e97"],"5c5b0f07c6835b1a381980a03c88fbb4e41c4532":["c26f00b574427b55127e869b935845554afde1fa"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91"],"3b0bf71278457cb04b0666bf73b8aa71d36be8c4":["ef9e7ba08c124ce913ef60415c21ae1ca833d211"],"3c89f80265f6c2148bf8702b01724ca046efdf07":["e6d9348a7814f90f24c043aa0d0109adc467a48a"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","7290fa7ae2cc2a80abb6aecc0b0dd90cbfde2b7f"],"ef9e7ba08c124ce913ef60415c21ae1ca833d211":["5c5b0f07c6835b1a381980a03c88fbb4e41c4532"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["bb9c3baacabd473e8ecd6c4948aabacead49b88e"],"7e9ad156d6e96d7d7b6d8015f686c50b1142760a":["3c89f80265f6c2148bf8702b01724ca046efdf07"],"0ac6494315d04f68950d2f00f5436b4861bcd467":["7290fa7ae2cc2a80abb6aecc0b0dd90cbfde2b7f"],"74acabcbc6eae18c349c56bd385f9e42433afca3":["57123f858a48ace813624f9da70ca12bd803571f"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7290fa7ae2cc2a80abb6aecc0b0dd90cbfde2b7f":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"c2f15ce56e25538825682a41ccb854c1d82e0e95":["7e9ad156d6e96d7d7b6d8015f686c50b1142760a"],"e6d9348a7814f90f24c043aa0d0109adc467a48a":["74acabcbc6eae18c349c56bd385f9e42433afca3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bb9c3baacabd473e8ecd6c4948aabacead49b88e":["a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9"],"ff99371bc1f34bf1a2ccdb754940ee5fe5cc2565":["5c5b0f07c6835b1a381980a03c88fbb4e41c4532","3c89f80265f6c2148bf8702b01724ca046efdf07"],"f25fe5576647e3bdd2a797a9900982532d5e2e97":["3b0bf71278457cb04b0666bf73b8aa71d36be8c4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["640ded7811e1b7d29236a5e2934ec3cd266a8199"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["199dfa410f1fdbfd3294106b04096cce5ed34b21","7290fa7ae2cc2a80abb6aecc0b0dd90cbfde2b7f"],"640ded7811e1b7d29236a5e2934ec3cd266a8199":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9":["bb9c3baacabd473e8ecd6c4948aabacead49b88e"],"57123f858a48ace813624f9da70ca12bd803571f":["74acabcbc6eae18c349c56bd385f9e42433afca3"],"5c5b0f07c6835b1a381980a03c88fbb4e41c4532":["ef9e7ba08c124ce913ef60415c21ae1ca833d211","ff99371bc1f34bf1a2ccdb754940ee5fe5cc2565"],"c26f00b574427b55127e869b935845554afde1fa":["5c5b0f07c6835b1a381980a03c88fbb4e41c4532"],"3b0bf71278457cb04b0666bf73b8aa71d36be8c4":["f25fe5576647e3bdd2a797a9900982532d5e2e97"],"3c89f80265f6c2148bf8702b01724ca046efdf07":["7e9ad156d6e96d7d7b6d8015f686c50b1142760a","ff99371bc1f34bf1a2ccdb754940ee5fe5cc2565"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":[],"ef9e7ba08c124ce913ef60415c21ae1ca833d211":["3b0bf71278457cb04b0666bf73b8aa71d36be8c4"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["640ded7811e1b7d29236a5e2934ec3cd266a8199"],"7e9ad156d6e96d7d7b6d8015f686c50b1142760a":["c2f15ce56e25538825682a41ccb854c1d82e0e95"],"0ac6494315d04f68950d2f00f5436b4861bcd467":["a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["c26f00b574427b55127e869b935845554afde1fa"],"74acabcbc6eae18c349c56bd385f9e42433afca3":["e6d9348a7814f90f24c043aa0d0109adc467a48a"],"c2f15ce56e25538825682a41ccb854c1d82e0e95":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"e6d9348a7814f90f24c043aa0d0109adc467a48a":["3c89f80265f6c2148bf8702b01724ca046efdf07"],"7290fa7ae2cc2a80abb6aecc0b0dd90cbfde2b7f":["199dfa410f1fdbfd3294106b04096cce5ed34b21","0ac6494315d04f68950d2f00f5436b4861bcd467"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91"],"bb9c3baacabd473e8ecd6c4948aabacead49b88e":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"ff99371bc1f34bf1a2ccdb754940ee5fe5cc2565":[],"f25fe5576647e3bdd2a797a9900982532d5e2e97":["57123f858a48ace813624f9da70ca12bd803571f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["199dfa410f1fdbfd3294106b04096cce5ed34b21","ff99371bc1f34bf1a2ccdb754940ee5fe5cc2565","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}