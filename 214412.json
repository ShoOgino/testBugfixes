{"path":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    if (usually()) {\n      if (maybeWrap && rarely()) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getTopReaderContext());\n      ret.setSimilarity(similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getTopReaderContext(), ex);\n      ret.setSimilarity(similarity);\n      return ret;\n    }\n  }\n\n","sourceOld":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    if (usually()) {\n      if (maybeWrap && rarely()) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getTopReaderContext());\n      ret.setSimilarity(similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getTopReaderContext(), ex);\n      ret.setSimilarity(similarity);\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d5fa50cf85f44146aaf58d5bf20a4ab83e160025","date":1329493648,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    if (usually()) {\n      if (maybeWrap && rarely()) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      }\n      if (maybeWrap && rarely()) {\n        // just wrap as MultiReader/ParallelXReader with one subreader\n        if (random.nextBoolean()) {\n          r = (r instanceof AtomicReader) ?\n            new ParallelAtomicReader((AtomicReader) r) :\n            new ParallelCompositeReader((CompositeReader) r);\n        } else {\n          r = new MultiReader(r);\n        }\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getTopReaderContext());\n      ret.setSimilarity(similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getTopReaderContext(), ex);\n      ret.setSimilarity(similarity);\n      return ret;\n    }\n  }\n\n","sourceOld":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    if (usually()) {\n      if (maybeWrap && rarely()) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getTopReaderContext());\n      ret.setSimilarity(similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getTopReaderContext(), ex);\n      ret.setSimilarity(similarity);\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a77fa8c2b5887473eb7ca708c3eddd5e213584da","date":1329494333,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    if (usually()) {\n      if (maybeWrap && rarely()) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      }\n      if (maybeWrap && rarely()) {\n        // just wrap as MultiReader/ParallelXReader with one subreader\n        if (random.nextBoolean()) {\n          r = (r instanceof AtomicReader) ?\n            new ParallelAtomicReader((AtomicReader) r) :\n            new ParallelCompositeReader((CompositeReader) r);\n        } else if (r instanceof CompositeReader) { // only wrap if not already atomic (some tests may fail)\n          r = new MultiReader(r);\n        }\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getTopReaderContext());\n      ret.setSimilarity(similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getTopReaderContext(), ex);\n      ret.setSimilarity(similarity);\n      return ret;\n    }\n  }\n\n","sourceOld":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    if (usually()) {\n      if (maybeWrap && rarely()) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      }\n      if (maybeWrap && rarely()) {\n        // just wrap as MultiReader/ParallelXReader with one subreader\n        if (random.nextBoolean()) {\n          r = (r instanceof AtomicReader) ?\n            new ParallelAtomicReader((AtomicReader) r) :\n            new ParallelCompositeReader((CompositeReader) r);\n        } else {\n          r = new MultiReader(r);\n        }\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getTopReaderContext());\n      ret.setSimilarity(similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getTopReaderContext(), ex);\n      ret.setSimilarity(similarity);\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"80cd0f7ec59ba200084712154a4a6fb3460344ca","date":1329830963,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    if (usually()) {\n      if (maybeWrap) {\n        r = maybeWrapReader(r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getTopReaderContext());\n      ret.setSimilarity(similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getTopReaderContext(), ex);\n      ret.setSimilarity(similarity);\n      return ret;\n    }\n  }\n\n","sourceOld":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    if (usually()) {\n      if (maybeWrap && rarely()) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      }\n      if (maybeWrap && rarely()) {\n        // just wrap as MultiReader/ParallelXReader with one subreader\n        if (random.nextBoolean()) {\n          r = (r instanceof AtomicReader) ?\n            new ParallelAtomicReader((AtomicReader) r) :\n            new ParallelCompositeReader((CompositeReader) r);\n        } else if (r instanceof CompositeReader) { // only wrap if not already atomic (some tests may fail)\n          r = new MultiReader(r);\n        }\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getTopReaderContext());\n      ret.setSimilarity(similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getTopReaderContext(), ex);\n      ret.setSimilarity(similarity);\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2b88fbe31791235129ae4bfe8eab95a88c21bd05","date":1330683833,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    if (usually()) {\n      if (maybeWrap) {\n        r = maybeWrapReader(r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getTopReaderContext());\n      ret.setSimilarity(similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = _TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getTopReaderContext(), ex);\n      ret.setSimilarity(similarity);\n      return ret;\n    }\n  }\n\n","sourceOld":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    if (usually()) {\n      if (maybeWrap) {\n        r = maybeWrapReader(r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getTopReaderContext());\n      ret.setSimilarity(similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getTopReaderContext(), ex);\n      ret.setSimilarity(similarity);\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b517591934c8ccdb47fbb1d0a56995838567b052","date":1330695089,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    if (usually()) {\n      if (maybeWrap) {\n        r = maybeWrapReader(r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getTopReaderContext());\n      ret.setSimilarity(similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = _TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getTopReaderContext(), ex);\n      ret.setSimilarity(similarity);\n      return ret;\n    }\n  }\n\n","sourceOld":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    if (usually()) {\n      if (maybeWrap) {\n        r = maybeWrapReader(r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getTopReaderContext());\n      ret.setSimilarity(similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = _TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getTopReaderContext(), ex);\n      ret.setSimilarity(similarity);\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    if (usually()) {\n      if (maybeWrap) {\n        r = maybeWrapReader(r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getTopReaderContext());\n      ret.setSimilarity(similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = _TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getTopReaderContext(), ex);\n      ret.setSimilarity(similarity);\n      return ret;\n    }\n  }\n\n","sourceOld":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    if (usually()) {\n      if (maybeWrap && rarely()) {\n        r = SlowCompositeReaderWrapper.wrap(r);\n      }\n      if (maybeWrap && rarely()) {\n        // just wrap as MultiReader/ParallelXReader with one subreader\n        if (random.nextBoolean()) {\n          r = (r instanceof AtomicReader) ?\n            new ParallelAtomicReader((AtomicReader) r) :\n            new ParallelCompositeReader((CompositeReader) r);\n        } else if (r instanceof CompositeReader) { // only wrap if not already atomic (some tests may fail)\n          r = new MultiReader(r);\n        }\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getTopReaderContext());\n      ret.setSimilarity(similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ExecutorService ex = (random.nextBoolean()) ? null\n          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),\n                      new NamedThreadFactory(\"LuceneTestCase\"));\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getTopReaderContext(), ex);\n      ret.setSimilarity(similarity);\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        r = maybeWrapReader(r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getTopReaderContext());\n      ret.setSimilarity(similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = _TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getTopReaderContext(), ex);\n      ret.setSimilarity(similarity);\n      return ret;\n    }\n  }\n\n","sourceOld":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    if (usually()) {\n      if (maybeWrap) {\n        r = maybeWrapReader(r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getTopReaderContext());\n      ret.setSimilarity(similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = _TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getTopReaderContext(), ex);\n      ret.setSimilarity(similarity);\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5da0b42730b6b99b31389ef94cb97384e83b9ede","date":1337107665,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        r = maybeWrapReader(r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getTopReaderContext());\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = _TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           _TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getTopReaderContext(), ex);\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","sourceOld":"  /** create a new searcher over the reader.\n   * This searcher might randomly use threads.\n   * if <code>maybeWrap</code> is true, this searcher might wrap the reader\n   * with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        r = maybeWrapReader(r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getTopReaderContext());\n      ret.setSimilarity(similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = _TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getTopReaderContext(), ex);\n      ret.setSimilarity(similarity);\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"211b1506e56f7860762fbd4698f6d1d1b57f672c","date":1344976996,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        r = maybeWrapReader(r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = _TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           _TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getContext(), ex);\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        r = maybeWrapReader(r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getTopReaderContext());\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = _TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           _TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getTopReaderContext(), ex);\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","date":1345029782,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        r = maybeWrapReader(r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = _TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           _TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getContext(), ex);\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        r = maybeWrapReader(r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getTopReaderContext());\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = _TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           _TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getTopReaderContext(), ex);\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b05c56a41b733e02a189c48895922b5bd8c7f3d1","date":1345033322,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        r = maybeWrapReader(r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = _TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           _TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getContext(), ex);\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        r = maybeWrapReader(r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getTopReaderContext());\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = _TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           _TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getTopReaderContext(), ex);\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e99275efa2c9c9ae3bdba986218af82f2bf3dc30","date":1354658499,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        r = maybeWrapReader(r);\n      }\n      if (r instanceof AtomicReader) {\n        _TestUtil.checkReader((AtomicReader)r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = _TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           _TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getContext(), ex);\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        r = maybeWrapReader(r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = _TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           _TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getContext(), ex);\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        r = maybeWrapReader(r);\n      }\n      if (r instanceof AtomicReader) {\n        _TestUtil.checkReader((AtomicReader)r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = _TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           _TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getContext(), ex);\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        r = maybeWrapReader(r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = _TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           _TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getContext(), ex);\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ead75a6fad90e51d49af77033e3ad42b9826811c","date":1361119356,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        r = maybeWrapReader(r);\n      }\n      if (rarely() && r instanceof AtomicReader) {\n        // TODO: not useful to check DirectoryReader (redundant with checkindex)\n        // but maybe sometimes run this on the other crazy readers maybeWrapReader creates?\n        _TestUtil.checkReader(r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = _TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           _TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getContext(), ex);\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        r = maybeWrapReader(r);\n      }\n      if (r instanceof AtomicReader) {\n        _TestUtil.checkReader((AtomicReader)r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = _TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           _TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getContext(), ex);\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09c8567c25c02eeeb3e719841606a1269f3538ca","date":1361155063,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        r = maybeWrapReader(r);\n      }\n      if (rarely() && r instanceof AtomicReader) {\n        // TODO: not useful to check DirectoryReader (redundant with checkindex)\n        // but maybe sometimes run this on the other crazy readers maybeWrapReader creates?\n        _TestUtil.checkReader(r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = _TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           _TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getContext(), ex);\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        r = maybeWrapReader(r);\n      }\n      if (r instanceof AtomicReader) {\n        _TestUtil.checkReader((AtomicReader)r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = _TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           _TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getContext(), ex);\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d66cbc1d37e7a8a930f74cdcbe65662247601f17","date":1363808772,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        r = maybeWrapReader(r);\n      }\n      // TODO: this whole check is a coverage hack, we should move it to tests for various filterreaders.\n      // ultimately whatever you do will be checkIndex'd at the end anyway. \n      if (random.nextInt(500) == 0 && r instanceof AtomicReader) {\n        // TODO: not useful to check DirectoryReader (redundant with checkindex)\n        // but maybe sometimes run this on the other crazy readers maybeWrapReader creates?\n        _TestUtil.checkReader(r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = _TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           _TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getContext(), ex);\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        r = maybeWrapReader(r);\n      }\n      if (rarely() && r instanceof AtomicReader) {\n        // TODO: not useful to check DirectoryReader (redundant with checkindex)\n        // but maybe sometimes run this on the other crazy readers maybeWrapReader creates?\n        _TestUtil.checkReader(r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = _TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           _TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getContext(), ex);\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b0e8c39ca08b5a02de6edcd33d6f3b90b865173","date":1365631993,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        try {\n          r = maybeWrapReader(r);\n        } catch (IOException e) {\n          throw new AssertionError(e);\n        }\n      }\n      // TODO: this whole check is a coverage hack, we should move it to tests for various filterreaders.\n      // ultimately whatever you do will be checkIndex'd at the end anyway. \n      if (random.nextInt(500) == 0 && r instanceof AtomicReader) {\n        // TODO: not useful to check DirectoryReader (redundant with checkindex)\n        // but maybe sometimes run this on the other crazy readers maybeWrapReader creates?\n        try {\n          _TestUtil.checkReader(r);\n        } catch (IOException e) {\n          throw new AssertionError(e);\n        }\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = _TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           _TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getContext(), ex);\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        r = maybeWrapReader(r);\n      }\n      // TODO: this whole check is a coverage hack, we should move it to tests for various filterreaders.\n      // ultimately whatever you do will be checkIndex'd at the end anyway. \n      if (random.nextInt(500) == 0 && r instanceof AtomicReader) {\n        // TODO: not useful to check DirectoryReader (redundant with checkindex)\n        // but maybe sometimes run this on the other crazy readers maybeWrapReader creates?\n        _TestUtil.checkReader(r);\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = _TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           _TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getContext(), ex);\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        try {\n          r = maybeWrapReader(r);\n        } catch (IOException e) {\n          throw new AssertionError(e);\n        }\n      }\n      // TODO: this whole check is a coverage hack, we should move it to tests for various filterreaders.\n      // ultimately whatever you do will be checkIndex'd at the end anyway. \n      if (random.nextInt(500) == 0 && r instanceof AtomicReader) {\n        // TODO: not useful to check DirectoryReader (redundant with checkindex)\n        // but maybe sometimes run this on the other crazy readers maybeWrapReader creates?\n        try {\n          TestUtil.checkReader(r);\n        } catch (IOException e) {\n          throw new AssertionError(e);\n        }\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getContext(), ex);\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        try {\n          r = maybeWrapReader(r);\n        } catch (IOException e) {\n          throw new AssertionError(e);\n        }\n      }\n      // TODO: this whole check is a coverage hack, we should move it to tests for various filterreaders.\n      // ultimately whatever you do will be checkIndex'd at the end anyway. \n      if (random.nextInt(500) == 0 && r instanceof AtomicReader) {\n        // TODO: not useful to check DirectoryReader (redundant with checkindex)\n        // but maybe sometimes run this on the other crazy readers maybeWrapReader creates?\n        try {\n          _TestUtil.checkReader(r);\n        } catch (IOException e) {\n          throw new AssertionError(e);\n        }\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = _TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           _TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getContext(), ex);\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"658a1d7b74c99b3d845fb1f852331a1c4623368e","date":1396631281,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) {\n    return newSearcher(r, maybeWrap, true);\n  }\n\n","sourceOld":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        try {\n          r = maybeWrapReader(r);\n        } catch (IOException e) {\n          throw new AssertionError(e);\n        }\n      }\n      // TODO: this whole check is a coverage hack, we should move it to tests for various filterreaders.\n      // ultimately whatever you do will be checkIndex'd at the end anyway. \n      if (random.nextInt(500) == 0 && r instanceof AtomicReader) {\n        // TODO: not useful to check DirectoryReader (redundant with checkindex)\n        // but maybe sometimes run this on the other crazy readers maybeWrapReader creates?\n        try {\n          TestUtil.checkReader(r);\n        } catch (IOException e) {\n          throw new AssertionError(e);\n        }\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getContext(), ex);\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15e323346eac5e4685c0a9f2df85eb96b4239bbb","date":1396688577,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newSearcher(IndexReader,boolean).mjava","sourceNew":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) {\n    return newSearcher(r, maybeWrap, true);\n  }\n\n","sourceOld":"  /**\n   * Create a new searcher over the reader. This searcher might randomly use\n   * threads. if <code>maybeWrap</code> is true, this searcher might wrap the\n   * reader with one that returns null for getSequentialSubReaders.\n   */\n  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) {\n    Random random = random();\n    if (usually()) {\n      if (maybeWrap) {\n        try {\n          r = maybeWrapReader(r);\n        } catch (IOException e) {\n          throw new AssertionError(e);\n        }\n      }\n      // TODO: this whole check is a coverage hack, we should move it to tests for various filterreaders.\n      // ultimately whatever you do will be checkIndex'd at the end anyway. \n      if (random.nextInt(500) == 0 && r instanceof AtomicReader) {\n        // TODO: not useful to check DirectoryReader (redundant with checkindex)\n        // but maybe sometimes run this on the other crazy readers maybeWrapReader creates?\n        try {\n          TestUtil.checkReader(r);\n        } catch (IOException e) {\n          throw new AssertionError(e);\n        }\n      }\n      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getContext());\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    } else {\n      int threads = 0;\n      final ThreadPoolExecutor ex;\n      if (random.nextBoolean()) {\n        ex = null;\n      } else {\n        threads = TestUtil.nextInt(random, 1, 8);\n        ex = new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(),\n            new NamedThreadFactory(\"LuceneTestCase\"));\n        // uncomment to intensify LUCENE-3840\n        // ex.prestartAllCoreThreads();\n      }\n      if (ex != null) {\n       if (VERBOSE) {\n        System.out.println(\"NOTE: newSearcher using ExecutorService with \" + threads + \" threads\");\n       }\n       r.addReaderClosedListener(new ReaderClosedListener() {\n         @Override\n         public void onClose(IndexReader reader) {\n           TestUtil.shutdownExecutorService(ex);\n         }\n       });\n      }\n      IndexSearcher ret = random.nextBoolean() \n          ? new AssertingIndexSearcher(random, r, ex)\n          : new AssertingIndexSearcher(random, r.getContext(), ex);\n      ret.setSimilarity(classEnvRule.similarity);\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["a77fa8c2b5887473eb7ca708c3eddd5e213584da","b517591934c8ccdb47fbb1d0a56995838567b052"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":["5da0b42730b6b99b31389ef94cb97384e83b9ede","211b1506e56f7860762fbd4698f6d1d1b57f672c"],"6613659748fe4411a7dcf85266e55db1f95f7315":["3b0e8c39ca08b5a02de6edcd33d6f3b90b865173"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ead75a6fad90e51d49af77033e3ad42b9826811c":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"a77fa8c2b5887473eb7ca708c3eddd5e213584da":["d5fa50cf85f44146aaf58d5bf20a4ab83e160025"],"e99275efa2c9c9ae3bdba986218af82f2bf3dc30":["211b1506e56f7860762fbd4698f6d1d1b57f672c"],"211b1506e56f7860762fbd4698f6d1d1b57f672c":["5da0b42730b6b99b31389ef94cb97384e83b9ede"],"2b88fbe31791235129ae4bfe8eab95a88c21bd05":["80cd0f7ec59ba200084712154a4a6fb3460344ca"],"d5fa50cf85f44146aaf58d5bf20a4ab83e160025":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["5da0b42730b6b99b31389ef94cb97384e83b9ede","211b1506e56f7860762fbd4698f6d1d1b57f672c"],"658a1d7b74c99b3d845fb1f852331a1c4623368e":["6613659748fe4411a7dcf85266e55db1f95f7315"],"3b0e8c39ca08b5a02de6edcd33d6f3b90b865173":["d66cbc1d37e7a8a930f74cdcbe65662247601f17"],"09c8567c25c02eeeb3e719841606a1269f3538ca":["d4d69c535930b5cce125cff868d40f6373dc27d4","ead75a6fad90e51d49af77033e3ad42b9826811c"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["211b1506e56f7860762fbd4698f6d1d1b57f672c","e99275efa2c9c9ae3bdba986218af82f2bf3dc30"],"5da0b42730b6b99b31389ef94cb97384e83b9ede":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":["6613659748fe4411a7dcf85266e55db1f95f7315","658a1d7b74c99b3d845fb1f852331a1c4623368e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b517591934c8ccdb47fbb1d0a56995838567b052":["2b88fbe31791235129ae4bfe8eab95a88c21bd05"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["b517591934c8ccdb47fbb1d0a56995838567b052"],"80cd0f7ec59ba200084712154a4a6fb3460344ca":["a77fa8c2b5887473eb7ca708c3eddd5e213584da"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["658a1d7b74c99b3d845fb1f852331a1c4623368e"],"d66cbc1d37e7a8a930f74cdcbe65662247601f17":["ead75a6fad90e51d49af77033e3ad42b9826811c"]},"commit2Childs":{"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":[],"6613659748fe4411a7dcf85266e55db1f95f7315":["658a1d7b74c99b3d845fb1f852331a1c4623368e","15e323346eac5e4685c0a9f2df85eb96b4239bbb"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["d5fa50cf85f44146aaf58d5bf20a4ab83e160025"],"a77fa8c2b5887473eb7ca708c3eddd5e213584da":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","80cd0f7ec59ba200084712154a4a6fb3460344ca"],"ead75a6fad90e51d49af77033e3ad42b9826811c":["09c8567c25c02eeeb3e719841606a1269f3538ca","d66cbc1d37e7a8a930f74cdcbe65662247601f17"],"e99275efa2c9c9ae3bdba986218af82f2bf3dc30":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"211b1506e56f7860762fbd4698f6d1d1b57f672c":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","e99275efa2c9c9ae3bdba986218af82f2bf3dc30","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","d4d69c535930b5cce125cff868d40f6373dc27d4"],"d5fa50cf85f44146aaf58d5bf20a4ab83e160025":["a77fa8c2b5887473eb7ca708c3eddd5e213584da"],"2b88fbe31791235129ae4bfe8eab95a88c21bd05":["b517591934c8ccdb47fbb1d0a56995838567b052"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":[],"3b0e8c39ca08b5a02de6edcd33d6f3b90b865173":["6613659748fe4411a7dcf85266e55db1f95f7315"],"658a1d7b74c99b3d845fb1f852331a1c4623368e":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"09c8567c25c02eeeb3e719841606a1269f3538ca":[],"d4d69c535930b5cce125cff868d40f6373dc27d4":["ead75a6fad90e51d49af77033e3ad42b9826811c","09c8567c25c02eeeb3e719841606a1269f3538ca"],"5da0b42730b6b99b31389ef94cb97384e83b9ede":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","211b1506e56f7860762fbd4698f6d1d1b57f672c","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"b517591934c8ccdb47fbb1d0a56995838567b052":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["5da0b42730b6b99b31389ef94cb97384e83b9ede"],"80cd0f7ec59ba200084712154a4a6fb3460344ca":["2b88fbe31791235129ae4bfe8eab95a88c21bd05"],"d66cbc1d37e7a8a930f74cdcbe65662247601f17":["3b0e8c39ca08b5a02de6edcd33d6f3b90b865173"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","09c8567c25c02eeeb3e719841606a1269f3538ca","15e323346eac5e4685c0a9f2df85eb96b4239bbb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}