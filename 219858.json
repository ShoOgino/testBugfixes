{"path":"lucene/codecs/src/test/org/apache/lucene/codecs/autoprefix/TestAutoPrefixTerms#testTermRange().mjava","commits":[{"id":"17a677e88529303e630fb314d1506ea0cdb40f00","date":1432211402,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/test/org/apache/lucene/codecs/autoprefix/TestAutoPrefixTerms#testTermRange().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestTermRangeQuery#testAutoPrefixTermsKickIn().mjava","sourceNew":"  /** Make sure auto prefix terms are used with TermRangeQuery */\n  public void testTermRange() throws Exception {\n\n    List<String> prefixes = new ArrayList<>();\n    for(int i=1;i<5;i++) {\n      char[] chars = new char[i];\n      Arrays.fill(chars, 'a');\n      prefixes.add(new String(chars));\n    }\n\n    Set<String> randomTerms = new HashSet<>();\n    int numTerms = atLeast(10000);\n    while (randomTerms.size() < numTerms) {\n      for(String prefix : prefixes) {\n        randomTerms.add(prefix + TestUtil.randomSimpleString(random()));\n      }\n    }\n\n    // We make term range aa<start> - aa<end>\n    char start;\n    char end;\n\n    int actualCount;\n    boolean startInclusive = random().nextBoolean();\n    boolean endInclusive = random().nextBoolean();\n    String startTerm;\n    String endTerm;\n\n    while (true) {\n      start = (char) TestUtil.nextInt(random(), 'a', 'm');\n      end = (char) TestUtil.nextInt(random(), start+1, 'z');\n\n      actualCount = 0;\n\n      startTerm = \"aa\" + start;\n      endTerm = \"aa\" + end;\n\n      for(String term : randomTerms) {\n        int cmpStart = startTerm.compareTo(term);\n        int cmpEnd = endTerm.compareTo(term);\n        if ((cmpStart < 0 || (startInclusive && cmpStart == 0)) &&\n            (cmpEnd > 0 || (endInclusive && cmpEnd == 0))) {\n          actualCount++;\n        }\n      }\n\n      if (actualCount > 2000) {\n        break;\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"start \" + startTerm + \" inclusive? \" + startInclusive);\n      System.out.println(\"end \" + endTerm + \" inclusive? \" + endInclusive);\n      System.out.println(\"actual count \" + actualCount);\n    }\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    int minTermsInBlock = TestUtil.nextInt(random(), 2, 100);\n    int maxTermsInBlock = Math.max(2, (minTermsInBlock-1)*2 + random().nextInt(100));\n\n    int minTermsAutoPrefix = TestUtil.nextInt(random(), 2, 100);\n    int maxTermsAutoPrefix = random().nextBoolean() ? Math.max(2, (minTermsAutoPrefix-1)*2 + random().nextInt(100)) : Integer.MAX_VALUE;\n\n    if (VERBOSE) {\n      System.out.println(\"minTermsAutoPrefix \" + minTermsAutoPrefix);\n      System.out.println(\"maxTermsAutoPrefix \" + maxTermsAutoPrefix);\n    }\n\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new AutoPrefixPostingsFormat(minTermsInBlock, maxTermsInBlock,\n                                                                            minTermsAutoPrefix, maxTermsAutoPrefix)));\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: index terms\");\n    }\n    for (String term : randomTerms) {\n      Document doc = new Document();\n      doc.add(new StringField(\"field\", term, Field.Store.NO));\n      w.addDocument(doc);\n      if (VERBOSE) {\n        System.out.println(\"  \" + term);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now force merge\");\n    }\n\n    w.forceMerge(1);\n    IndexReader r = w.getReader();\n    final Terms terms = MultiFields.getTerms(r, \"field\");\n    IndexSearcher s = new IndexSearcher(r);\n    final int finalActualCount = actualCount;\n    if (VERBOSE) {\n      System.out.println(\"start=\" + startTerm + \" end=\" + endTerm + \" startIncl=\" + startInclusive + \" endIncl=\" + endInclusive);\n    }\n    TermRangeQuery q = new TermRangeQuery(\"field\", new BytesRef(startTerm), new BytesRef(endTerm), startInclusive, endInclusive) {\n      public TermRangeQuery checkTerms() throws IOException {\n        TermsEnum termsEnum = getTermsEnum(terms, new AttributeSource());\n        int count = 0;\n        while (termsEnum.next() != null) {\n          if (VERBOSE) {\n            System.out.println(\"got term: \" + termsEnum.term().utf8ToString());\n          }\n          count++;\n        }\n        if (VERBOSE) {\n          System.out.println(\"count \" + count + \" vs finalActualCount=\" + finalActualCount);\n        }\n\n        // Auto-prefix term(s) should have kicked in, so we should have visited fewer than the total number of aa* terms:\n        assertTrue(count < finalActualCount);\n\n        return this;\n      }\n    }.checkTerms();\n\n    int maxClauseCount = BooleanQuery.getMaxClauseCount();\n\n    try {\n\n      // TODO test with boolean rewrite as well once we can create term\n      // queries on fake terms\n      /*if (random().nextBoolean()) {\n        q.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n        BooleanQuery.setMaxClauseCount(actualCount);\n      } else if (random().nextBoolean()) {\n        q.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_BOOLEAN_REWRITE);\n        BooleanQuery.setMaxClauseCount(actualCount);\n      }*/\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: use rewrite method \" + q.getRewriteMethod());\n      }\n      assertEquals(actualCount, s.search(q, 1).totalHits);\n    } finally {\n      BooleanQuery.setMaxClauseCount(maxClauseCount);\n    }\n\n    // Test when min == max:\n    List<String> randomTermsList = new ArrayList<>(randomTerms);\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n      String term = randomTermsList.get(random().nextInt(randomTermsList.size()));\n      q = new TermRangeQuery(\"field\", new BytesRef(term), new BytesRef(term), true, true);\n      assertEquals(1, s.search(q, 1).totalHits);\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  /** Make sure auto prefix terms are used with TermRangeQuery */\n  public void testAutoPrefixTermsKickIn() throws Exception {\n\n    List<String> prefixes = new ArrayList<>();\n    for(int i=1;i<5;i++) {\n      char[] chars = new char[i];\n      Arrays.fill(chars, 'a');\n      prefixes.add(new String(chars));\n    }\n\n    Set<String> randomTerms = new HashSet<>();\n    int numTerms = atLeast(10000);\n    while (randomTerms.size() < numTerms) {\n      for(String prefix : prefixes) {\n        randomTerms.add(prefix + TestUtil.randomSimpleString(random()));\n      }\n    }\n\n    // We make term range aa<start> - aa<end>\n    char start;\n    char end;\n\n    int actualCount;\n    boolean startInclusive = random().nextBoolean();\n    boolean endInclusive = random().nextBoolean();\n    String startTerm;\n    String endTerm;\n\n    while (true) {\n      start = (char) TestUtil.nextInt(random(), 'a', 'm');\n      end = (char) TestUtil.nextInt(random(), start+1, 'z');\n\n      actualCount = 0;\n\n      startTerm = \"aa\" + start;\n      endTerm = \"aa\" + end;\n\n      for(String term : randomTerms) {\n        int cmpStart = startTerm.compareTo(term);\n        int cmpEnd = endTerm.compareTo(term);\n        if ((cmpStart < 0 || (startInclusive && cmpStart == 0)) &&\n            (cmpEnd > 0 || (endInclusive && cmpEnd == 0))) {\n          actualCount++;\n        }\n      }\n\n      if (actualCount > 2000) {\n        break;\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"start \" + startTerm + \" inclusive? \" + startInclusive);\n      System.out.println(\"end \" + endTerm + \" inclusive? \" + endInclusive);\n      System.out.println(\"actual count \" + actualCount);\n    }\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    int minTermsInBlock = TestUtil.nextInt(random(), 2, 100);\n    int maxTermsInBlock = Math.max(2, (minTermsInBlock-1)*2 + random().nextInt(100));\n\n    int minTermsAutoPrefix = TestUtil.nextInt(random(), 2, 100);\n    int maxTermsAutoPrefix = random().nextBoolean() ? Math.max(2, (minTermsAutoPrefix-1)*2 + random().nextInt(100)) : Integer.MAX_VALUE;\n\n    if (VERBOSE) {\n      System.out.println(\"minTermsAutoPrefix \" + minTermsAutoPrefix);\n      System.out.println(\"maxTermsAutoPrefix \" + maxTermsAutoPrefix);\n    }\n\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new AutoPrefixPostingsFormat(minTermsInBlock, maxTermsInBlock,\n                                                                            minTermsAutoPrefix, maxTermsAutoPrefix)));\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: index terms\");\n    }\n    for (String term : randomTerms) {\n      Document doc = new Document();\n      doc.add(new StringField(\"field\", term, Field.Store.NO));\n      w.addDocument(doc);\n      if (VERBOSE) {\n        System.out.println(\"  \" + term);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now force merge\");\n    }\n\n    w.forceMerge(1);\n    IndexReader r = w.getReader();\n    final Terms terms = MultiFields.getTerms(r, \"field\");\n    IndexSearcher s = new IndexSearcher(r);\n    final int finalActualCount = actualCount;\n    if (VERBOSE) {\n      System.out.println(\"start=\" + startTerm + \" end=\" + endTerm + \" startIncl=\" + startInclusive + \" endIncl=\" + endInclusive);\n    }\n    TermRangeQuery q = new TermRangeQuery(\"field\", new BytesRef(startTerm), new BytesRef(endTerm), startInclusive, endInclusive) {\n      public TermRangeQuery checkTerms() throws IOException {\n        TermsEnum termsEnum = getTermsEnum(terms, new AttributeSource());\n        int count = 0;\n        while (termsEnum.next() != null) {\n          if (VERBOSE) {\n            System.out.println(\"got term: \" + termsEnum.term().utf8ToString());\n          }\n          count++;\n        }\n        if (VERBOSE) {\n          System.out.println(\"count \" + count + \" vs finalActualCount=\" + finalActualCount);\n        }\n\n        // Auto-prefix term(s) should have kicked in, so we should have visited fewer than the total number of aa* terms:\n        assertTrue(count < finalActualCount);\n\n        return this;\n      }\n    }.checkTerms();\n\n    int maxClauseCount = BooleanQuery.getMaxClauseCount();\n\n    try {\n\n      if (random().nextBoolean()) {\n        q.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n        BooleanQuery.setMaxClauseCount(actualCount);\n      } else if (random().nextBoolean()) {\n        q.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_BOOLEAN_REWRITE);\n        BooleanQuery.setMaxClauseCount(actualCount);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: use rewrite method \" + q.getRewriteMethod());\n      }\n      assertEquals(actualCount, s.search(q, 1).totalHits);\n    } finally {\n      BooleanQuery.setMaxClauseCount(maxClauseCount);\n    }\n\n    // Test when min == max:\n    List<String> randomTermsList = new ArrayList<>(randomTerms);\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n      String term = randomTermsList.get(random().nextInt(randomTermsList.size()));\n      q = new TermRangeQuery(\"field\", new BytesRef(term), new BytesRef(term), true, true);\n      assertEquals(1, s.search(q, 1).totalHits);\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"25b8a027ba57951e63075a2ae9647c5c4a8c5c5f","date":1466407389,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/codecs/src/test/org/apache/lucene/codecs/autoprefix/TestAutoPrefixTerms#testTermRange().mjava","sourceNew":null,"sourceOld":"  /** Make sure auto prefix terms are used with TermRangeQuery */\n  public void testTermRange() throws Exception {\n\n    List<String> prefixes = new ArrayList<>();\n    for(int i=1;i<5;i++) {\n      char[] chars = new char[i];\n      Arrays.fill(chars, 'a');\n      prefixes.add(new String(chars));\n    }\n\n    Set<String> randomTerms = new HashSet<>();\n    int numTerms = atLeast(10000);\n    while (randomTerms.size() < numTerms) {\n      for(String prefix : prefixes) {\n        randomTerms.add(prefix + TestUtil.randomSimpleString(random()));\n      }\n    }\n\n    // We make term range aa<start> - aa<end>\n    char start;\n    char end;\n\n    int actualCount;\n    boolean startInclusive = random().nextBoolean();\n    boolean endInclusive = random().nextBoolean();\n    String startTerm;\n    String endTerm;\n\n    while (true) {\n      start = (char) TestUtil.nextInt(random(), 'a', 'm');\n      end = (char) TestUtil.nextInt(random(), start+1, 'z');\n\n      actualCount = 0;\n\n      startTerm = \"aa\" + start;\n      endTerm = \"aa\" + end;\n\n      for(String term : randomTerms) {\n        int cmpStart = startTerm.compareTo(term);\n        int cmpEnd = endTerm.compareTo(term);\n        if ((cmpStart < 0 || (startInclusive && cmpStart == 0)) &&\n            (cmpEnd > 0 || (endInclusive && cmpEnd == 0))) {\n          actualCount++;\n        }\n      }\n\n      if (actualCount > 2000) {\n        break;\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"start \" + startTerm + \" inclusive? \" + startInclusive);\n      System.out.println(\"end \" + endTerm + \" inclusive? \" + endInclusive);\n      System.out.println(\"actual count \" + actualCount);\n    }\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    int minTermsInBlock = TestUtil.nextInt(random(), 2, 100);\n    int maxTermsInBlock = Math.max(2, (minTermsInBlock-1)*2 + random().nextInt(100));\n\n    int minTermsAutoPrefix = TestUtil.nextInt(random(), 2, 100);\n    int maxTermsAutoPrefix = random().nextBoolean() ? Math.max(2, (minTermsAutoPrefix-1)*2 + random().nextInt(100)) : Integer.MAX_VALUE;\n\n    if (VERBOSE) {\n      System.out.println(\"minTermsAutoPrefix \" + minTermsAutoPrefix);\n      System.out.println(\"maxTermsAutoPrefix \" + maxTermsAutoPrefix);\n    }\n\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new AutoPrefixPostingsFormat(minTermsInBlock, maxTermsInBlock,\n                                                                            minTermsAutoPrefix, maxTermsAutoPrefix)));\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: index terms\");\n    }\n    for (String term : randomTerms) {\n      Document doc = new Document();\n      doc.add(new StringField(\"field\", term, Field.Store.NO));\n      w.addDocument(doc);\n      if (VERBOSE) {\n        System.out.println(\"  \" + term);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now force merge\");\n    }\n\n    w.forceMerge(1);\n    IndexReader r = w.getReader();\n    final Terms terms = MultiFields.getTerms(r, \"field\");\n    IndexSearcher s = new IndexSearcher(r);\n    final int finalActualCount = actualCount;\n    if (VERBOSE) {\n      System.out.println(\"start=\" + startTerm + \" end=\" + endTerm + \" startIncl=\" + startInclusive + \" endIncl=\" + endInclusive);\n    }\n    TermRangeQuery q = new TermRangeQuery(\"field\", new BytesRef(startTerm), new BytesRef(endTerm), startInclusive, endInclusive) {\n      public TermRangeQuery checkTerms() throws IOException {\n        TermsEnum termsEnum = getTermsEnum(terms, new AttributeSource());\n        int count = 0;\n        while (termsEnum.next() != null) {\n          if (VERBOSE) {\n            System.out.println(\"got term: \" + termsEnum.term().utf8ToString());\n          }\n          count++;\n        }\n        if (VERBOSE) {\n          System.out.println(\"count \" + count + \" vs finalActualCount=\" + finalActualCount);\n        }\n\n        // Auto-prefix term(s) should have kicked in, so we should have visited fewer than the total number of aa* terms:\n        assertTrue(count < finalActualCount);\n\n        return this;\n      }\n    }.checkTerms();\n\n    int maxClauseCount = BooleanQuery.getMaxClauseCount();\n\n    try {\n\n      // TODO test with boolean rewrite as well once we can create term\n      // queries on fake terms\n      /*if (random().nextBoolean()) {\n        q.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n        BooleanQuery.setMaxClauseCount(actualCount);\n      } else if (random().nextBoolean()) {\n        q.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_BOOLEAN_REWRITE);\n        BooleanQuery.setMaxClauseCount(actualCount);\n      }*/\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: use rewrite method \" + q.getRewriteMethod());\n      }\n      assertEquals(actualCount, s.search(q, 1).totalHits);\n    } finally {\n      BooleanQuery.setMaxClauseCount(maxClauseCount);\n    }\n\n    // Test when min == max:\n    List<String> randomTermsList = new ArrayList<>(randomTerms);\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n      String term = randomTermsList.get(random().nextInt(randomTermsList.size()));\n      q = new TermRangeQuery(\"field\", new BytesRef(term), new BytesRef(term), true, true);\n      assertEquals(1, s.search(q, 1).totalHits);\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6aaba221b22442bdf0ef28770c25fe259dfb3f55","date":1466496193,"type":4,"author":"Noble Paul","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/codecs/src/test/org/apache/lucene/codecs/autoprefix/TestAutoPrefixTerms#testTermRange().mjava","sourceNew":null,"sourceOld":"  /** Make sure auto prefix terms are used with TermRangeQuery */\n  public void testTermRange() throws Exception {\n\n    List<String> prefixes = new ArrayList<>();\n    for(int i=1;i<5;i++) {\n      char[] chars = new char[i];\n      Arrays.fill(chars, 'a');\n      prefixes.add(new String(chars));\n    }\n\n    Set<String> randomTerms = new HashSet<>();\n    int numTerms = atLeast(10000);\n    while (randomTerms.size() < numTerms) {\n      for(String prefix : prefixes) {\n        randomTerms.add(prefix + TestUtil.randomSimpleString(random()));\n      }\n    }\n\n    // We make term range aa<start> - aa<end>\n    char start;\n    char end;\n\n    int actualCount;\n    boolean startInclusive = random().nextBoolean();\n    boolean endInclusive = random().nextBoolean();\n    String startTerm;\n    String endTerm;\n\n    while (true) {\n      start = (char) TestUtil.nextInt(random(), 'a', 'm');\n      end = (char) TestUtil.nextInt(random(), start+1, 'z');\n\n      actualCount = 0;\n\n      startTerm = \"aa\" + start;\n      endTerm = \"aa\" + end;\n\n      for(String term : randomTerms) {\n        int cmpStart = startTerm.compareTo(term);\n        int cmpEnd = endTerm.compareTo(term);\n        if ((cmpStart < 0 || (startInclusive && cmpStart == 0)) &&\n            (cmpEnd > 0 || (endInclusive && cmpEnd == 0))) {\n          actualCount++;\n        }\n      }\n\n      if (actualCount > 2000) {\n        break;\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"start \" + startTerm + \" inclusive? \" + startInclusive);\n      System.out.println(\"end \" + endTerm + \" inclusive? \" + endInclusive);\n      System.out.println(\"actual count \" + actualCount);\n    }\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    int minTermsInBlock = TestUtil.nextInt(random(), 2, 100);\n    int maxTermsInBlock = Math.max(2, (minTermsInBlock-1)*2 + random().nextInt(100));\n\n    int minTermsAutoPrefix = TestUtil.nextInt(random(), 2, 100);\n    int maxTermsAutoPrefix = random().nextBoolean() ? Math.max(2, (minTermsAutoPrefix-1)*2 + random().nextInt(100)) : Integer.MAX_VALUE;\n\n    if (VERBOSE) {\n      System.out.println(\"minTermsAutoPrefix \" + minTermsAutoPrefix);\n      System.out.println(\"maxTermsAutoPrefix \" + maxTermsAutoPrefix);\n    }\n\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new AutoPrefixPostingsFormat(minTermsInBlock, maxTermsInBlock,\n                                                                            minTermsAutoPrefix, maxTermsAutoPrefix)));\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: index terms\");\n    }\n    for (String term : randomTerms) {\n      Document doc = new Document();\n      doc.add(new StringField(\"field\", term, Field.Store.NO));\n      w.addDocument(doc);\n      if (VERBOSE) {\n        System.out.println(\"  \" + term);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now force merge\");\n    }\n\n    w.forceMerge(1);\n    IndexReader r = w.getReader();\n    final Terms terms = MultiFields.getTerms(r, \"field\");\n    IndexSearcher s = new IndexSearcher(r);\n    final int finalActualCount = actualCount;\n    if (VERBOSE) {\n      System.out.println(\"start=\" + startTerm + \" end=\" + endTerm + \" startIncl=\" + startInclusive + \" endIncl=\" + endInclusive);\n    }\n    TermRangeQuery q = new TermRangeQuery(\"field\", new BytesRef(startTerm), new BytesRef(endTerm), startInclusive, endInclusive) {\n      public TermRangeQuery checkTerms() throws IOException {\n        TermsEnum termsEnum = getTermsEnum(terms, new AttributeSource());\n        int count = 0;\n        while (termsEnum.next() != null) {\n          if (VERBOSE) {\n            System.out.println(\"got term: \" + termsEnum.term().utf8ToString());\n          }\n          count++;\n        }\n        if (VERBOSE) {\n          System.out.println(\"count \" + count + \" vs finalActualCount=\" + finalActualCount);\n        }\n\n        // Auto-prefix term(s) should have kicked in, so we should have visited fewer than the total number of aa* terms:\n        assertTrue(count < finalActualCount);\n\n        return this;\n      }\n    }.checkTerms();\n\n    int maxClauseCount = BooleanQuery.getMaxClauseCount();\n\n    try {\n\n      // TODO test with boolean rewrite as well once we can create term\n      // queries on fake terms\n      /*if (random().nextBoolean()) {\n        q.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n        BooleanQuery.setMaxClauseCount(actualCount);\n      } else if (random().nextBoolean()) {\n        q.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_BOOLEAN_REWRITE);\n        BooleanQuery.setMaxClauseCount(actualCount);\n      }*/\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: use rewrite method \" + q.getRewriteMethod());\n      }\n      assertEquals(actualCount, s.search(q, 1).totalHits);\n    } finally {\n      BooleanQuery.setMaxClauseCount(maxClauseCount);\n    }\n\n    // Test when min == max:\n    List<String> randomTermsList = new ArrayList<>(randomTerms);\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n      String term = randomTermsList.get(random().nextInt(randomTermsList.size()));\n      q = new TermRangeQuery(\"field\", new BytesRef(term), new BytesRef(term), true, true);\n      assertEquals(1, s.search(q, 1).totalHits);\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":4,"author":"Kevin Risden","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/codecs/src/test/org/apache/lucene/codecs/autoprefix/TestAutoPrefixTerms#testTermRange().mjava","sourceNew":null,"sourceOld":"  /** Make sure auto prefix terms are used with TermRangeQuery */\n  public void testTermRange() throws Exception {\n\n    List<String> prefixes = new ArrayList<>();\n    for(int i=1;i<5;i++) {\n      char[] chars = new char[i];\n      Arrays.fill(chars, 'a');\n      prefixes.add(new String(chars));\n    }\n\n    Set<String> randomTerms = new HashSet<>();\n    int numTerms = atLeast(10000);\n    while (randomTerms.size() < numTerms) {\n      for(String prefix : prefixes) {\n        randomTerms.add(prefix + TestUtil.randomSimpleString(random()));\n      }\n    }\n\n    // We make term range aa<start> - aa<end>\n    char start;\n    char end;\n\n    int actualCount;\n    boolean startInclusive = random().nextBoolean();\n    boolean endInclusive = random().nextBoolean();\n    String startTerm;\n    String endTerm;\n\n    while (true) {\n      start = (char) TestUtil.nextInt(random(), 'a', 'm');\n      end = (char) TestUtil.nextInt(random(), start+1, 'z');\n\n      actualCount = 0;\n\n      startTerm = \"aa\" + start;\n      endTerm = \"aa\" + end;\n\n      for(String term : randomTerms) {\n        int cmpStart = startTerm.compareTo(term);\n        int cmpEnd = endTerm.compareTo(term);\n        if ((cmpStart < 0 || (startInclusive && cmpStart == 0)) &&\n            (cmpEnd > 0 || (endInclusive && cmpEnd == 0))) {\n          actualCount++;\n        }\n      }\n\n      if (actualCount > 2000) {\n        break;\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"start \" + startTerm + \" inclusive? \" + startInclusive);\n      System.out.println(\"end \" + endTerm + \" inclusive? \" + endInclusive);\n      System.out.println(\"actual count \" + actualCount);\n    }\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n    int minTermsInBlock = TestUtil.nextInt(random(), 2, 100);\n    int maxTermsInBlock = Math.max(2, (minTermsInBlock-1)*2 + random().nextInt(100));\n\n    int minTermsAutoPrefix = TestUtil.nextInt(random(), 2, 100);\n    int maxTermsAutoPrefix = random().nextBoolean() ? Math.max(2, (minTermsAutoPrefix-1)*2 + random().nextInt(100)) : Integer.MAX_VALUE;\n\n    if (VERBOSE) {\n      System.out.println(\"minTermsAutoPrefix \" + minTermsAutoPrefix);\n      System.out.println(\"maxTermsAutoPrefix \" + maxTermsAutoPrefix);\n    }\n\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new AutoPrefixPostingsFormat(minTermsInBlock, maxTermsInBlock,\n                                                                            minTermsAutoPrefix, maxTermsAutoPrefix)));\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: index terms\");\n    }\n    for (String term : randomTerms) {\n      Document doc = new Document();\n      doc.add(new StringField(\"field\", term, Field.Store.NO));\n      w.addDocument(doc);\n      if (VERBOSE) {\n        System.out.println(\"  \" + term);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now force merge\");\n    }\n\n    w.forceMerge(1);\n    IndexReader r = w.getReader();\n    final Terms terms = MultiFields.getTerms(r, \"field\");\n    IndexSearcher s = new IndexSearcher(r);\n    final int finalActualCount = actualCount;\n    if (VERBOSE) {\n      System.out.println(\"start=\" + startTerm + \" end=\" + endTerm + \" startIncl=\" + startInclusive + \" endIncl=\" + endInclusive);\n    }\n    TermRangeQuery q = new TermRangeQuery(\"field\", new BytesRef(startTerm), new BytesRef(endTerm), startInclusive, endInclusive) {\n      public TermRangeQuery checkTerms() throws IOException {\n        TermsEnum termsEnum = getTermsEnum(terms, new AttributeSource());\n        int count = 0;\n        while (termsEnum.next() != null) {\n          if (VERBOSE) {\n            System.out.println(\"got term: \" + termsEnum.term().utf8ToString());\n          }\n          count++;\n        }\n        if (VERBOSE) {\n          System.out.println(\"count \" + count + \" vs finalActualCount=\" + finalActualCount);\n        }\n\n        // Auto-prefix term(s) should have kicked in, so we should have visited fewer than the total number of aa* terms:\n        assertTrue(count < finalActualCount);\n\n        return this;\n      }\n    }.checkTerms();\n\n    int maxClauseCount = BooleanQuery.getMaxClauseCount();\n\n    try {\n\n      // TODO test with boolean rewrite as well once we can create term\n      // queries on fake terms\n      /*if (random().nextBoolean()) {\n        q.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_REWRITE);\n        BooleanQuery.setMaxClauseCount(actualCount);\n      } else if (random().nextBoolean()) {\n        q.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_BOOLEAN_REWRITE);\n        BooleanQuery.setMaxClauseCount(actualCount);\n      }*/\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: use rewrite method \" + q.getRewriteMethod());\n      }\n      assertEquals(actualCount, s.search(q, 1).totalHits);\n    } finally {\n      BooleanQuery.setMaxClauseCount(maxClauseCount);\n    }\n\n    // Test when min == max:\n    List<String> randomTermsList = new ArrayList<>(randomTerms);\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n      String term = randomTermsList.get(random().nextInt(randomTermsList.size()));\n      q = new TermRangeQuery(\"field\", new BytesRef(term), new BytesRef(term), true, true);\n      assertEquals(1, s.search(q, 1).totalHits);\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6aaba221b22442bdf0ef28770c25fe259dfb3f55":["17a677e88529303e630fb314d1506ea0cdb40f00","25b8a027ba57951e63075a2ae9647c5c4a8c5c5f"],"25b8a027ba57951e63075a2ae9647c5c4a8c5c5f":["17a677e88529303e630fb314d1506ea0cdb40f00"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17a677e88529303e630fb314d1506ea0cdb40f00":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["17a677e88529303e630fb314d1506ea0cdb40f00","6aaba221b22442bdf0ef28770c25fe259dfb3f55"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6aaba221b22442bdf0ef28770c25fe259dfb3f55"]},"commit2Childs":{"6aaba221b22442bdf0ef28770c25fe259dfb3f55":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"25b8a027ba57951e63075a2ae9647c5c4a8c5c5f":["6aaba221b22442bdf0ef28770c25fe259dfb3f55"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["17a677e88529303e630fb314d1506ea0cdb40f00"],"17a677e88529303e630fb314d1506ea0cdb40f00":["6aaba221b22442bdf0ef28770c25fe259dfb3f55","25b8a027ba57951e63075a2ae9647c5c4a8c5c5f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}