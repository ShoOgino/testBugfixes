{"path":"solr/core/src/java/org/apache/solr/cloud/ZkShardTerms.Terms#increaseTerms(String,Set[String]).mjava","commits":[{"id":"84f20f331d8001864545c7021812d8c6509c7593","date":1517216128,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkShardTerms.Terms#increaseTerms(String,Set[String]).mjava","pathOld":"/dev/null","sourceNew":"    /**\r\n     * Return a new {@link Terms} in which term of {@code leader} is higher than {@code replicasNeedingRecovery}\r\n     * @param leader coreNodeName of leader\r\n     * @param replicasNeedingRecovery set of replicas in which their terms should be lower than leader's term\r\n     * @return null if term of {@code leader} is already higher than {@code replicasNeedingRecovery}\r\n     */\r\n    Terms increaseTerms(String leader, Set<String> replicasNeedingRecovery) {\r\n      if (!values.containsKey(leader)) {\r\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Can not find leader's term \" + leader);\r\n      }\r\n\r\n      boolean changed = false;\r\n      boolean foundReplicasInLowerTerms = false;\r\n\r\n      HashMap<String, Long> newValues = new HashMap<>(values);\r\n      long leaderTerm = newValues.get(leader);\r\n      for (String replica : newValues.keySet()) {\r\n        if (replicasNeedingRecovery.contains(replica)) foundReplicasInLowerTerms = true;\r\n        if (Objects.equals(newValues.get(replica), leaderTerm)) {\r\n          if(replicasNeedingRecovery.contains(replica)) {\r\n            changed = true;\r\n          } else {\r\n            newValues.put(replica, leaderTerm+1);\r\n          }\r\n        }\r\n      }\r\n\r\n      // We should skip the optimization if there are no replicasNeedingRecovery present in local terms,\r\n      // this may indicate that the current value is stale\r\n      if (!changed && foundReplicasInLowerTerms) return null;\r\n      return new Terms(newValues, version);\r\n    }\r\n\n","sourceOld":null,"bugFix":null,"bugIntro":["058ff60cb31d722dd3cb7e252dacbd74faf4e544"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"058ff60cb31d722dd3cb7e252dacbd74faf4e544","date":1527819790,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkShardTerms.Terms#increaseTerms(String,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkShardTerms.Terms#increaseTerms(String,Set[String]).mjava","sourceNew":"    /**\r\n     * Return a new {@link Terms} in which term of {@code leader} is higher than {@code replicasNeedingRecovery}\r\n     * @param leader coreNodeName of leader\r\n     * @param replicasNeedingRecovery set of replicas in which their terms should be lower than leader's term\r\n     * @return null if term of {@code leader} is already higher than {@code replicasNeedingRecovery}\r\n     */\r\n    Terms increaseTerms(String leader, Set<String> replicasNeedingRecovery) {\r\n      if (!values.containsKey(leader)) {\r\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Can not find leader's term \" + leader);\r\n      }\r\n\r\n      boolean changed = false;\r\n      boolean foundReplicasInLowerTerms = false;\r\n\r\n      HashMap<String, Long> newValues = new HashMap<>(values);\r\n      long leaderTerm = newValues.get(leader);\r\n      for (String key : newValues.keySet()) {\r\n        if (replicasNeedingRecovery.contains(key)) foundReplicasInLowerTerms = true;\r\n        if (Objects.equals(newValues.get(key), leaderTerm)) {\r\n          if(skipIncreaseTermOf(key, replicasNeedingRecovery)) {\r\n            changed = true;\r\n          } else {\r\n            newValues.put(key, leaderTerm+1);\r\n          }\r\n        }\r\n      }\r\n\r\n      // We should skip the optimization if there are no replicasNeedingRecovery present in local terms,\r\n      // this may indicate that the current value is stale\r\n      if (!changed && foundReplicasInLowerTerms) return null;\r\n      return new Terms(newValues, version);\r\n    }\r\n\n","sourceOld":"    /**\r\n     * Return a new {@link Terms} in which term of {@code leader} is higher than {@code replicasNeedingRecovery}\r\n     * @param leader coreNodeName of leader\r\n     * @param replicasNeedingRecovery set of replicas in which their terms should be lower than leader's term\r\n     * @return null if term of {@code leader} is already higher than {@code replicasNeedingRecovery}\r\n     */\r\n    Terms increaseTerms(String leader, Set<String> replicasNeedingRecovery) {\r\n      if (!values.containsKey(leader)) {\r\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Can not find leader's term \" + leader);\r\n      }\r\n\r\n      boolean changed = false;\r\n      boolean foundReplicasInLowerTerms = false;\r\n\r\n      HashMap<String, Long> newValues = new HashMap<>(values);\r\n      long leaderTerm = newValues.get(leader);\r\n      for (String replica : newValues.keySet()) {\r\n        if (replicasNeedingRecovery.contains(replica)) foundReplicasInLowerTerms = true;\r\n        if (Objects.equals(newValues.get(replica), leaderTerm)) {\r\n          if(replicasNeedingRecovery.contains(replica)) {\r\n            changed = true;\r\n          } else {\r\n            newValues.put(replica, leaderTerm+1);\r\n          }\r\n        }\r\n      }\r\n\r\n      // We should skip the optimization if there are no replicasNeedingRecovery present in local terms,\r\n      // this may indicate that the current value is stale\r\n      if (!changed && foundReplicasInLowerTerms) return null;\r\n      return new Terms(newValues, version);\r\n    }\r\n\n","bugFix":["84f20f331d8001864545c7021812d8c6509c7593"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0","date":1571070979,"type":3,"author":"Koen De Groote","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkShardTerms.Terms#increaseTerms(String,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkShardTerms.Terms#increaseTerms(String,Set[String]).mjava","sourceNew":"    /**\r\n     * Return a new {@link Terms} in which term of {@code leader} is higher than {@code replicasNeedingRecovery}\r\n     * @param leader coreNodeName of leader\r\n     * @param replicasNeedingRecovery set of replicas in which their terms should be lower than leader's term\r\n     * @return null if term of {@code leader} is already higher than {@code replicasNeedingRecovery}\r\n     */\r\n    Terms increaseTerms(String leader, Set<String> replicasNeedingRecovery) {\r\n      if (!values.containsKey(leader)) {\r\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Can not find leader's term \" + leader);\r\n      }\r\n\r\n      boolean changed = false;\r\n      boolean foundReplicasInLowerTerms = false;\r\n\r\n      HashMap<String, Long> newValues = new HashMap<>(values);\r\n      long leaderTerm = newValues.get(leader);\r\n      for (Map.Entry<String, Long> entry : newValues.entrySet()) {\r\n        String key = entry.getKey();\r\n        if (replicasNeedingRecovery.contains(key)) foundReplicasInLowerTerms = true;\r\n        if (Objects.equals(entry.getValue(), leaderTerm)) {\r\n          if(skipIncreaseTermOf(key, replicasNeedingRecovery)) {\r\n            changed = true;\r\n          } else {\r\n            newValues.put(key, leaderTerm+1);\r\n          }\r\n        }\r\n      }\r\n\r\n      // We should skip the optimization if there are no replicasNeedingRecovery present in local terms,\r\n      // this may indicate that the current value is stale\r\n      if (!changed && foundReplicasInLowerTerms) return null;\r\n      return new Terms(newValues, version);\r\n    }\r\n\n","sourceOld":"    /**\r\n     * Return a new {@link Terms} in which term of {@code leader} is higher than {@code replicasNeedingRecovery}\r\n     * @param leader coreNodeName of leader\r\n     * @param replicasNeedingRecovery set of replicas in which their terms should be lower than leader's term\r\n     * @return null if term of {@code leader} is already higher than {@code replicasNeedingRecovery}\r\n     */\r\n    Terms increaseTerms(String leader, Set<String> replicasNeedingRecovery) {\r\n      if (!values.containsKey(leader)) {\r\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Can not find leader's term \" + leader);\r\n      }\r\n\r\n      boolean changed = false;\r\n      boolean foundReplicasInLowerTerms = false;\r\n\r\n      HashMap<String, Long> newValues = new HashMap<>(values);\r\n      long leaderTerm = newValues.get(leader);\r\n      for (String key : newValues.keySet()) {\r\n        if (replicasNeedingRecovery.contains(key)) foundReplicasInLowerTerms = true;\r\n        if (Objects.equals(newValues.get(key), leaderTerm)) {\r\n          if(skipIncreaseTermOf(key, replicasNeedingRecovery)) {\r\n            changed = true;\r\n          } else {\r\n            newValues.put(key, leaderTerm+1);\r\n          }\r\n        }\r\n      }\r\n\r\n      // We should skip the optimization if there are no replicasNeedingRecovery present in local terms,\r\n      // this may indicate that the current value is stale\r\n      if (!changed && foundReplicasInLowerTerms) return null;\r\n      return new Terms(newValues, version);\r\n    }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkShardTerms.Terms#increaseTerms(String,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkShardTerms.Terms#increaseTerms(String,Set[String]).mjava","sourceNew":"    /**\r\n     * Return a new {@link Terms} in which term of {@code leader} is higher than {@code replicasNeedingRecovery}\r\n     * @param leader coreNodeName of leader\r\n     * @param replicasNeedingRecovery set of replicas in which their terms should be lower than leader's term\r\n     * @return null if term of {@code leader} is already higher than {@code replicasNeedingRecovery}\r\n     */\r\n    Terms increaseTerms(String leader, Set<String> replicasNeedingRecovery) {\r\n      if (!values.containsKey(leader)) {\r\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Can not find leader's term \" + leader);\r\n      }\r\n\r\n      boolean changed = false;\r\n      boolean foundReplicasInLowerTerms = false;\r\n\r\n      HashMap<String, Long> newValues = new HashMap<>(values);\r\n      long leaderTerm = newValues.get(leader);\r\n      for (Map.Entry<String, Long> entry : newValues.entrySet()) {\r\n        String key = entry.getKey();\r\n        if (replicasNeedingRecovery.contains(key)) foundReplicasInLowerTerms = true;\r\n        if (Objects.equals(entry.getValue(), leaderTerm)) {\r\n          if(skipIncreaseTermOf(key, replicasNeedingRecovery)) {\r\n            changed = true;\r\n          } else {\r\n            newValues.put(key, leaderTerm+1);\r\n          }\r\n        }\r\n      }\r\n\r\n      // We should skip the optimization if there are no replicasNeedingRecovery present in local terms,\r\n      // this may indicate that the current value is stale\r\n      if (!changed && foundReplicasInLowerTerms) return null;\r\n      return new Terms(newValues, version);\r\n    }\r\n\n","sourceOld":"    /**\r\n     * Return a new {@link Terms} in which term of {@code leader} is higher than {@code replicasNeedingRecovery}\r\n     * @param leader coreNodeName of leader\r\n     * @param replicasNeedingRecovery set of replicas in which their terms should be lower than leader's term\r\n     * @return null if term of {@code leader} is already higher than {@code replicasNeedingRecovery}\r\n     */\r\n    Terms increaseTerms(String leader, Set<String> replicasNeedingRecovery) {\r\n      if (!values.containsKey(leader)) {\r\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Can not find leader's term \" + leader);\r\n      }\r\n\r\n      boolean changed = false;\r\n      boolean foundReplicasInLowerTerms = false;\r\n\r\n      HashMap<String, Long> newValues = new HashMap<>(values);\r\n      long leaderTerm = newValues.get(leader);\r\n      for (String key : newValues.keySet()) {\r\n        if (replicasNeedingRecovery.contains(key)) foundReplicasInLowerTerms = true;\r\n        if (Objects.equals(newValues.get(key), leaderTerm)) {\r\n          if(skipIncreaseTermOf(key, replicasNeedingRecovery)) {\r\n            changed = true;\r\n          } else {\r\n            newValues.put(key, leaderTerm+1);\r\n          }\r\n        }\r\n      }\r\n\r\n      // We should skip the optimization if there are no replicasNeedingRecovery present in local terms,\r\n      // this may indicate that the current value is stale\r\n      if (!changed && foundReplicasInLowerTerms) return null;\r\n      return new Terms(newValues, version);\r\n    }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b6cc501b75cbd5d0319284563cdd20aff857ee6","date":1575346594,"type":4,"author":"noble","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkShardTerms.Terms#increaseTerms(String,Set[String]).mjava","sourceNew":null,"sourceOld":"    /**\r\n     * Return a new {@link Terms} in which term of {@code leader} is higher than {@code replicasNeedingRecovery}\r\n     * @param leader coreNodeName of leader\r\n     * @param replicasNeedingRecovery set of replicas in which their terms should be lower than leader's term\r\n     * @return null if term of {@code leader} is already higher than {@code replicasNeedingRecovery}\r\n     */\r\n    Terms increaseTerms(String leader, Set<String> replicasNeedingRecovery) {\r\n      if (!values.containsKey(leader)) {\r\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Can not find leader's term \" + leader);\r\n      }\r\n\r\n      boolean changed = false;\r\n      boolean foundReplicasInLowerTerms = false;\r\n\r\n      HashMap<String, Long> newValues = new HashMap<>(values);\r\n      long leaderTerm = newValues.get(leader);\r\n      for (Map.Entry<String, Long> entry : newValues.entrySet()) {\r\n        String key = entry.getKey();\r\n        if (replicasNeedingRecovery.contains(key)) foundReplicasInLowerTerms = true;\r\n        if (Objects.equals(entry.getValue(), leaderTerm)) {\r\n          if(skipIncreaseTermOf(key, replicasNeedingRecovery)) {\r\n            changed = true;\r\n          } else {\r\n            newValues.put(key, leaderTerm+1);\r\n          }\r\n        }\r\n      }\r\n\r\n      // We should skip the optimization if there are no replicasNeedingRecovery present in local terms,\r\n      // this may indicate that the current value is stale\r\n      if (!changed && foundReplicasInLowerTerms) return null;\r\n      return new Terms(newValues, version);\r\n    }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3aa683bba99315838c968fefedf3d74f44aa993","date":1575395112,"type":4,"author":"Dawid Weiss","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkShardTerms.Terms#increaseTerms(String,Set[String]).mjava","sourceNew":null,"sourceOld":"    /**\r\n     * Return a new {@link Terms} in which term of {@code leader} is higher than {@code replicasNeedingRecovery}\r\n     * @param leader coreNodeName of leader\r\n     * @param replicasNeedingRecovery set of replicas in which their terms should be lower than leader's term\r\n     * @return null if term of {@code leader} is already higher than {@code replicasNeedingRecovery}\r\n     */\r\n    Terms increaseTerms(String leader, Set<String> replicasNeedingRecovery) {\r\n      if (!values.containsKey(leader)) {\r\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Can not find leader's term \" + leader);\r\n      }\r\n\r\n      boolean changed = false;\r\n      boolean foundReplicasInLowerTerms = false;\r\n\r\n      HashMap<String, Long> newValues = new HashMap<>(values);\r\n      long leaderTerm = newValues.get(leader);\r\n      for (Map.Entry<String, Long> entry : newValues.entrySet()) {\r\n        String key = entry.getKey();\r\n        if (replicasNeedingRecovery.contains(key)) foundReplicasInLowerTerms = true;\r\n        if (Objects.equals(entry.getValue(), leaderTerm)) {\r\n          if(skipIncreaseTermOf(key, replicasNeedingRecovery)) {\r\n            changed = true;\r\n          } else {\r\n            newValues.put(key, leaderTerm+1);\r\n          }\r\n        }\r\n      }\r\n\r\n      // We should skip the optimization if there are no replicasNeedingRecovery present in local terms,\r\n      // this may indicate that the current value is stale\r\n      if (!changed && foundReplicasInLowerTerms) return null;\r\n      return new Terms(newValues, version);\r\n    }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3aa683bba99315838c968fefedf3d74f44aa993":["7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0","5b6cc501b75cbd5d0319284563cdd20aff857ee6"],"7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0":["058ff60cb31d722dd3cb7e252dacbd74faf4e544"],"5b6cc501b75cbd5d0319284563cdd20aff857ee6":["7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"058ff60cb31d722dd3cb7e252dacbd74faf4e544":["84f20f331d8001864545c7021812d8c6509c7593"],"84f20f331d8001864545c7021812d8c6509c7593":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5b6cc501b75cbd5d0319284563cdd20aff857ee6"],"b0b597c65628ca9e73913a07e81691f8229bae35":["058ff60cb31d722dd3cb7e252dacbd74faf4e544","7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0"]},"commit2Childs":{"d3aa683bba99315838c968fefedf3d74f44aa993":[],"7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0":["d3aa683bba99315838c968fefedf3d74f44aa993","5b6cc501b75cbd5d0319284563cdd20aff857ee6","b0b597c65628ca9e73913a07e81691f8229bae35"],"5b6cc501b75cbd5d0319284563cdd20aff857ee6":["d3aa683bba99315838c968fefedf3d74f44aa993","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["84f20f331d8001864545c7021812d8c6509c7593"],"058ff60cb31d722dd3cb7e252dacbd74faf4e544":["7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0","b0b597c65628ca9e73913a07e81691f8229bae35"],"84f20f331d8001864545c7021812d8c6509c7593":["058ff60cb31d722dd3cb7e252dacbd74faf4e544"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["d3aa683bba99315838c968fefedf3d74f44aa993","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}