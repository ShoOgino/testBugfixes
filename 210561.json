{"path":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/ConcurrentSortedSetDocValuesFacetCounts#count(List[MatchingDocs]).mjava","commits":[{"id":"8cfd1df435f04d4287925cca73cf22120f723892","date":1493925365,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/ConcurrentSortedSetDocValuesFacetCounts#count(List[MatchingDocs]).mjava","pathOld":"/dev/null","sourceNew":"  /** Does all the \"real work\" of tallying up the counts. */\n  private final void count(List<MatchingDocs> matchingDocs) throws IOException, InterruptedException {\n\n    MultiDocValues.OrdinalMap ordinalMap;\n\n    // TODO: is this right?  really, we need a way to\n    // verify that this ordinalMap \"matches\" the leaves in\n    // matchingDocs...\n    if (dv instanceof MultiDocValues.MultiSortedSetDocValues && matchingDocs.size() > 1) {\n      ordinalMap = ((MultiSortedSetDocValues) dv).mapping;\n    } else {\n      ordinalMap = null;\n    }\n    \n    IndexReader reader = state.getReader();\n    List<Future<Void>> results = new ArrayList<>();\n\n    for (MatchingDocs hits : matchingDocs) {\n      // LUCENE-5090: make sure the provided reader context \"matches\"\n      // the top-level reader passed to the\n      // SortedSetDocValuesReaderState, else cryptic\n      // AIOOBE can happen:\n      if (ReaderUtil.getTopLevelContext(hits.context).reader() != reader) {\n        throw new IllegalStateException(\"the SortedSetDocValuesReaderState provided to this class does not match the reader being searched; you must create a new SortedSetDocValuesReaderState every time you open a new IndexReader\");\n      }\n      \n      results.add(exec.submit(new CountOneSegment(hits.context.reader(), hits, ordinalMap, hits.context.ord)));\n    }\n\n    for (Future<Void> result : results) {\n      try {\n        result.get();\n      } catch (ExecutionException ee) {\n        // Theoretically cause can be null; guard against that.\n        Throwable cause = ee.getCause();\n        throw IOUtils.rethrowAlways(cause != null ? cause : ee);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/ConcurrentSortedSetDocValuesFacetCounts#count(List[MatchingDocs]).mjava","pathOld":"/dev/null","sourceNew":"  /** Does all the \"real work\" of tallying up the counts. */\n  private final void count(List<MatchingDocs> matchingDocs) throws IOException, InterruptedException {\n\n    MultiDocValues.OrdinalMap ordinalMap;\n\n    // TODO: is this right?  really, we need a way to\n    // verify that this ordinalMap \"matches\" the leaves in\n    // matchingDocs...\n    if (dv instanceof MultiDocValues.MultiSortedSetDocValues && matchingDocs.size() > 1) {\n      ordinalMap = ((MultiSortedSetDocValues) dv).mapping;\n    } else {\n      ordinalMap = null;\n    }\n    \n    IndexReader reader = state.getReader();\n    List<Future<Void>> results = new ArrayList<>();\n\n    for (MatchingDocs hits : matchingDocs) {\n      // LUCENE-5090: make sure the provided reader context \"matches\"\n      // the top-level reader passed to the\n      // SortedSetDocValuesReaderState, else cryptic\n      // AIOOBE can happen:\n      if (ReaderUtil.getTopLevelContext(hits.context).reader() != reader) {\n        throw new IllegalStateException(\"the SortedSetDocValuesReaderState provided to this class does not match the reader being searched; you must create a new SortedSetDocValuesReaderState every time you open a new IndexReader\");\n      }\n      \n      results.add(exec.submit(new CountOneSegment(hits.context.reader(), hits, ordinalMap, hits.context.ord)));\n    }\n\n    for (Future<Void> result : results) {\n      try {\n        result.get();\n      } catch (ExecutionException ee) {\n        // Theoretically cause can be null; guard against that.\n        Throwable cause = ee.getCause();\n        throw IOUtils.rethrowAlways(cause != null ? cause : ee);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"957c610636f393a85a38f1af670540028db13e6b","date":1500044517,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/ConcurrentSortedSetDocValuesFacetCounts#count(List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/ConcurrentSortedSetDocValuesFacetCounts#count(List[MatchingDocs]).mjava","sourceNew":"  /** Does all the \"real work\" of tallying up the counts. */\n  private final void count(List<MatchingDocs> matchingDocs) throws IOException, InterruptedException {\n\n    OrdinalMap ordinalMap;\n\n    // TODO: is this right?  really, we need a way to\n    // verify that this ordinalMap \"matches\" the leaves in\n    // matchingDocs...\n    if (dv instanceof MultiDocValues.MultiSortedSetDocValues && matchingDocs.size() > 1) {\n      ordinalMap = ((MultiSortedSetDocValues) dv).mapping;\n    } else {\n      ordinalMap = null;\n    }\n    \n    IndexReader reader = state.getReader();\n    List<Future<Void>> results = new ArrayList<>();\n\n    for (MatchingDocs hits : matchingDocs) {\n      // LUCENE-5090: make sure the provided reader context \"matches\"\n      // the top-level reader passed to the\n      // SortedSetDocValuesReaderState, else cryptic\n      // AIOOBE can happen:\n      if (ReaderUtil.getTopLevelContext(hits.context).reader() != reader) {\n        throw new IllegalStateException(\"the SortedSetDocValuesReaderState provided to this class does not match the reader being searched; you must create a new SortedSetDocValuesReaderState every time you open a new IndexReader\");\n      }\n      \n      results.add(exec.submit(new CountOneSegment(hits.context.reader(), hits, ordinalMap, hits.context.ord)));\n    }\n\n    for (Future<Void> result : results) {\n      try {\n        result.get();\n      } catch (ExecutionException ee) {\n        // Theoretically cause can be null; guard against that.\n        Throwable cause = ee.getCause();\n        throw IOUtils.rethrowAlways(cause != null ? cause : ee);\n      }\n    }\n  }\n\n","sourceOld":"  /** Does all the \"real work\" of tallying up the counts. */\n  private final void count(List<MatchingDocs> matchingDocs) throws IOException, InterruptedException {\n\n    MultiDocValues.OrdinalMap ordinalMap;\n\n    // TODO: is this right?  really, we need a way to\n    // verify that this ordinalMap \"matches\" the leaves in\n    // matchingDocs...\n    if (dv instanceof MultiDocValues.MultiSortedSetDocValues && matchingDocs.size() > 1) {\n      ordinalMap = ((MultiSortedSetDocValues) dv).mapping;\n    } else {\n      ordinalMap = null;\n    }\n    \n    IndexReader reader = state.getReader();\n    List<Future<Void>> results = new ArrayList<>();\n\n    for (MatchingDocs hits : matchingDocs) {\n      // LUCENE-5090: make sure the provided reader context \"matches\"\n      // the top-level reader passed to the\n      // SortedSetDocValuesReaderState, else cryptic\n      // AIOOBE can happen:\n      if (ReaderUtil.getTopLevelContext(hits.context).reader() != reader) {\n        throw new IllegalStateException(\"the SortedSetDocValuesReaderState provided to this class does not match the reader being searched; you must create a new SortedSetDocValuesReaderState every time you open a new IndexReader\");\n      }\n      \n      results.add(exec.submit(new CountOneSegment(hits.context.reader(), hits, ordinalMap, hits.context.ord)));\n    }\n\n    for (Future<Void> result : results) {\n      try {\n        result.get();\n      } catch (ExecutionException ee) {\n        // Theoretically cause can be null; guard against that.\n        Throwable cause = ee.getCause();\n        throw IOUtils.rethrowAlways(cause != null ? cause : ee);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aaf90fc29510e72665ac7934f34c3d1c25efad64","date":1500354819,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/ConcurrentSortedSetDocValuesFacetCounts#count(List[MatchingDocs]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/ConcurrentSortedSetDocValuesFacetCounts#count(List[MatchingDocs]).mjava","sourceNew":"  /** Does all the \"real work\" of tallying up the counts. */\n  private final void count(List<MatchingDocs> matchingDocs) throws IOException, InterruptedException {\n\n    OrdinalMap ordinalMap;\n\n    // TODO: is this right?  really, we need a way to\n    // verify that this ordinalMap \"matches\" the leaves in\n    // matchingDocs...\n    if (dv instanceof MultiDocValues.MultiSortedSetDocValues && matchingDocs.size() > 1) {\n      ordinalMap = ((MultiSortedSetDocValues) dv).mapping;\n    } else {\n      ordinalMap = null;\n    }\n    \n    IndexReader reader = state.getReader();\n    List<Future<Void>> results = new ArrayList<>();\n\n    for (MatchingDocs hits : matchingDocs) {\n      // LUCENE-5090: make sure the provided reader context \"matches\"\n      // the top-level reader passed to the\n      // SortedSetDocValuesReaderState, else cryptic\n      // AIOOBE can happen:\n      if (ReaderUtil.getTopLevelContext(hits.context).reader() != reader) {\n        throw new IllegalStateException(\"the SortedSetDocValuesReaderState provided to this class does not match the reader being searched; you must create a new SortedSetDocValuesReaderState every time you open a new IndexReader\");\n      }\n      \n      results.add(exec.submit(new CountOneSegment(hits.context.reader(), hits, ordinalMap, hits.context.ord)));\n    }\n\n    for (Future<Void> result : results) {\n      try {\n        result.get();\n      } catch (ExecutionException ee) {\n        // Theoretically cause can be null; guard against that.\n        Throwable cause = ee.getCause();\n        throw IOUtils.rethrowAlways(cause != null ? cause : ee);\n      }\n    }\n  }\n\n","sourceOld":"  /** Does all the \"real work\" of tallying up the counts. */\n  private final void count(List<MatchingDocs> matchingDocs) throws IOException, InterruptedException {\n\n    MultiDocValues.OrdinalMap ordinalMap;\n\n    // TODO: is this right?  really, we need a way to\n    // verify that this ordinalMap \"matches\" the leaves in\n    // matchingDocs...\n    if (dv instanceof MultiDocValues.MultiSortedSetDocValues && matchingDocs.size() > 1) {\n      ordinalMap = ((MultiSortedSetDocValues) dv).mapping;\n    } else {\n      ordinalMap = null;\n    }\n    \n    IndexReader reader = state.getReader();\n    List<Future<Void>> results = new ArrayList<>();\n\n    for (MatchingDocs hits : matchingDocs) {\n      // LUCENE-5090: make sure the provided reader context \"matches\"\n      // the top-level reader passed to the\n      // SortedSetDocValuesReaderState, else cryptic\n      // AIOOBE can happen:\n      if (ReaderUtil.getTopLevelContext(hits.context).reader() != reader) {\n        throw new IllegalStateException(\"the SortedSetDocValuesReaderState provided to this class does not match the reader being searched; you must create a new SortedSetDocValuesReaderState every time you open a new IndexReader\");\n      }\n      \n      results.add(exec.submit(new CountOneSegment(hits.context.reader(), hits, ordinalMap, hits.context.ord)));\n    }\n\n    for (Future<Void> result : results) {\n      try {\n        result.get();\n      } catch (ExecutionException ee) {\n        // Theoretically cause can be null; guard against that.\n        Throwable cause = ee.getCause();\n        throw IOUtils.rethrowAlways(cause != null ? cause : ee);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8cfd1df435f04d4287925cca73cf22120f723892":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","8cfd1df435f04d4287925cca73cf22120f723892"],"957c610636f393a85a38f1af670540028db13e6b":["8cfd1df435f04d4287925cca73cf22120f723892"],"aaf90fc29510e72665ac7934f34c3d1c25efad64":["e9017cf144952056066919f1ebc7897ff9bd71b1","957c610636f393a85a38f1af670540028db13e6b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["957c610636f393a85a38f1af670540028db13e6b"]},"commit2Childs":{"8cfd1df435f04d4287925cca73cf22120f723892":["e9017cf144952056066919f1ebc7897ff9bd71b1","957c610636f393a85a38f1af670540028db13e6b"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["aaf90fc29510e72665ac7934f34c3d1c25efad64"],"957c610636f393a85a38f1af670540028db13e6b":["aaf90fc29510e72665ac7934f34c3d1c25efad64","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"aaf90fc29510e72665ac7934f34c3d1c25efad64":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8cfd1df435f04d4287925cca73cf22120f723892","e9017cf144952056066919f1ebc7897ff9bd71b1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["aaf90fc29510e72665ac7934f34c3d1c25efad64","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}