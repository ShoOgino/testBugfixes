{"path":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/kuromoji/KuromojiTokenizer#incrementToken().mjava","commits":[{"id":"0984ad47974c2d5d354519ddb2aa8358973a6271","date":1330868053,"type":0,"author":"Christian Moen","isMerge":false,"pathNew":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/kuromoji/KuromojiTokenizer#incrementToken().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public boolean incrementToken() throws IOException {\n\n    // parse() is able to return w/o producing any new\n    // tokens, when the tokens it had produced were entirely\n    // punctuation.  So we loop here until we get a real\n    // token or we end:\n    while (pending.size() == 0) {\n      if (end) {\n        return false;\n      }\n\n      // Push Viterbi forward some more:\n      parse();\n    }\n\n    final Token token = pending.remove(pending.size()-1);\n\n    int position = token.getPosition();\n    int length = token.getLength();\n    clearAttributes();\n    assert length > 0;\n    //System.out.println(\"off=\" + token.getOffset() + \" len=\" + length + \" vs \" + token.getSurfaceForm().length);\n    termAtt.copyBuffer(token.getSurfaceForm(), token.getOffset(), length);\n    offsetAtt.setOffset(correctOffset(position), correctOffset(position+length));\n    basicFormAtt.setToken(token);\n    posAtt.setToken(token);\n    readingAtt.setToken(token);\n    inflectionAtt.setToken(token);\n    if (token.getPosition() == lastTokenPos) {\n      posIncAtt.setPositionIncrement(0);\n      posLengthAtt.setPositionLength(token.getPositionLength());\n    } else {\n      assert token.getPosition() > lastTokenPos;\n      posIncAtt.setPositionIncrement(1);\n      posLengthAtt.setPositionLength(1);\n    }\n    if (VERBOSE) {\n      System.out.println(Thread.currentThread().getName() + \":    incToken: return token=\" + token);\n    }\n    lastTokenPos = token.getPosition();\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":0,"author":"Ryan McKinley","isMerge":true,"pathNew":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/kuromoji/KuromojiTokenizer#incrementToken().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public boolean incrementToken() throws IOException {\n\n    // parse() is able to return w/o producing any new\n    // tokens, when the tokens it had produced were entirely\n    // punctuation.  So we loop here until we get a real\n    // token or we end:\n    while (pending.size() == 0) {\n      if (end) {\n        return false;\n      }\n\n      // Push Viterbi forward some more:\n      parse();\n    }\n\n    final Token token = pending.remove(pending.size()-1);\n\n    int position = token.getPosition();\n    int length = token.getLength();\n    clearAttributes();\n    assert length > 0;\n    //System.out.println(\"off=\" + token.getOffset() + \" len=\" + length + \" vs \" + token.getSurfaceForm().length);\n    termAtt.copyBuffer(token.getSurfaceForm(), token.getOffset(), length);\n    offsetAtt.setOffset(correctOffset(position), correctOffset(position+length));\n    basicFormAtt.setToken(token);\n    posAtt.setToken(token);\n    readingAtt.setToken(token);\n    inflectionAtt.setToken(token);\n    if (token.getPosition() == lastTokenPos) {\n      posIncAtt.setPositionIncrement(0);\n      posLengthAtt.setPositionLength(token.getPositionLength());\n    } else {\n      assert token.getPosition() > lastTokenPos;\n      posIncAtt.setPositionIncrement(1);\n      posLengthAtt.setPositionLength(1);\n    }\n    if (VERBOSE) {\n      System.out.println(Thread.currentThread().getName() + \":    incToken: return token=\" + token);\n    }\n    lastTokenPos = token.getPosition();\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98d45c1ff2c99694b6de2201175f9b8b8b27b597","date":1332757908,"type":5,"author":"Christian Moen","isMerge":false,"pathNew":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/JapaneseTokenizer#incrementToken().mjava","pathOld":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/kuromoji/KuromojiTokenizer#incrementToken().mjava","sourceNew":"  @Override\n  public boolean incrementToken() throws IOException {\n\n    // parse() is able to return w/o producing any new\n    // tokens, when the tokens it had produced were entirely\n    // punctuation.  So we loop here until we get a real\n    // token or we end:\n    while (pending.size() == 0) {\n      if (end) {\n        return false;\n      }\n\n      // Push Viterbi forward some more:\n      parse();\n    }\n\n    final Token token = pending.remove(pending.size()-1);\n\n    int position = token.getPosition();\n    int length = token.getLength();\n    clearAttributes();\n    assert length > 0;\n    //System.out.println(\"off=\" + token.getOffset() + \" len=\" + length + \" vs \" + token.getSurfaceForm().length);\n    termAtt.copyBuffer(token.getSurfaceForm(), token.getOffset(), length);\n    offsetAtt.setOffset(correctOffset(position), correctOffset(position+length));\n    basicFormAtt.setToken(token);\n    posAtt.setToken(token);\n    readingAtt.setToken(token);\n    inflectionAtt.setToken(token);\n    if (token.getPosition() == lastTokenPos) {\n      posIncAtt.setPositionIncrement(0);\n      posLengthAtt.setPositionLength(token.getPositionLength());\n    } else {\n      assert token.getPosition() > lastTokenPos;\n      posIncAtt.setPositionIncrement(1);\n      posLengthAtt.setPositionLength(1);\n    }\n    if (VERBOSE) {\n      System.out.println(Thread.currentThread().getName() + \":    incToken: return token=\" + token);\n    }\n    lastTokenPos = token.getPosition();\n    return true;\n  }\n\n","sourceOld":"  @Override\n  public boolean incrementToken() throws IOException {\n\n    // parse() is able to return w/o producing any new\n    // tokens, when the tokens it had produced were entirely\n    // punctuation.  So we loop here until we get a real\n    // token or we end:\n    while (pending.size() == 0) {\n      if (end) {\n        return false;\n      }\n\n      // Push Viterbi forward some more:\n      parse();\n    }\n\n    final Token token = pending.remove(pending.size()-1);\n\n    int position = token.getPosition();\n    int length = token.getLength();\n    clearAttributes();\n    assert length > 0;\n    //System.out.println(\"off=\" + token.getOffset() + \" len=\" + length + \" vs \" + token.getSurfaceForm().length);\n    termAtt.copyBuffer(token.getSurfaceForm(), token.getOffset(), length);\n    offsetAtt.setOffset(correctOffset(position), correctOffset(position+length));\n    basicFormAtt.setToken(token);\n    posAtt.setToken(token);\n    readingAtt.setToken(token);\n    inflectionAtt.setToken(token);\n    if (token.getPosition() == lastTokenPos) {\n      posIncAtt.setPositionIncrement(0);\n      posLengthAtt.setPositionLength(token.getPositionLength());\n    } else {\n      assert token.getPosition() > lastTokenPos;\n      posIncAtt.setPositionIncrement(1);\n      posLengthAtt.setPositionLength(1);\n    }\n    if (VERBOSE) {\n      System.out.println(Thread.currentThread().getName() + \":    incToken: return token=\" + token);\n    }\n    lastTokenPos = token.getPosition();\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0984ad47974c2d5d354519ddb2aa8358973a6271"],"0984ad47974c2d5d354519ddb2aa8358973a6271":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"98d45c1ff2c99694b6de2201175f9b8b8b27b597":["0984ad47974c2d5d354519ddb2aa8358973a6271"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["98d45c1ff2c99694b6de2201175f9b8b8b27b597"]},"commit2Childs":{"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"0984ad47974c2d5d354519ddb2aa8358973a6271":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","98d45c1ff2c99694b6de2201175f9b8b8b27b597"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","0984ad47974c2d5d354519ddb2aa8358973a6271"],"98d45c1ff2c99694b6de2201175f9b8b8b27b597":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}