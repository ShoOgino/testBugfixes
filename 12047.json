{"path":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#slowDrillSidewaysSearch(IndexSearcher,List[Doc],String,String[][],String[][],Query).mjava","commits":[{"id":"d52e48927ca4ef3655a261f2230b968b6fdf3608","date":1444652107,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#slowDrillSidewaysSearch(IndexSearcher,List[Doc],String,String[][],String[][],Query).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#slowDrillSidewaysSearch(IndexSearcher,List[Doc],String,String[][],String[][],Filter).mjava","sourceNew":"  private TestFacetResult slowDrillSidewaysSearch(IndexSearcher s, List<Doc> docs,\n                                                        String contentToken, String[][] drillDowns,\n                                                        String[][] dimValues, Query onlyEven) throws Exception {\n    int numDims = dimValues.length;\n\n    List<Doc> hits = new ArrayList<>();\n    Counters drillDownCounts = new Counters(dimValues);\n    Counters[] drillSidewaysCounts = new Counters[dimValues.length];\n    for(int dim=0;dim<numDims;dim++) {\n      drillSidewaysCounts[dim] = new Counters(dimValues);\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"  compute expected\");\n    }\n\n    nextDoc: for(Doc doc : docs) {\n      if (doc.deleted) {\n        continue;\n      }\n      if (onlyEven != null & (Integer.parseInt(doc.id) & 1) != 0) {\n        continue;\n      }\n      if (contentToken == null || doc.contentToken.equals(contentToken)) {\n        int failDim = -1;\n        for(int dim=0;dim<numDims;dim++) {\n          if (drillDowns[dim] != null) {\n            String docValue = doc.dims[dim] == -1 ? null : dimValues[dim][doc.dims[dim]];\n            String docValue2 = doc.dims2[dim] == -1 ? null : dimValues[dim][doc.dims2[dim]];\n            boolean matches = false;\n            for(String value : drillDowns[dim]) {\n              if (value.equals(docValue) || value.equals(docValue2)) {\n                matches = true;\n                break;\n              }\n            }\n            if (!matches) {\n              if (failDim == -1) {\n                // Doc could be a near-miss, if no other dim fails\n                failDim = dim;\n              } else {\n                // Doc isn't a hit nor a near-miss\n                continue nextDoc;\n              }\n            }\n          }\n        }\n\n        if (failDim == -1) {\n          if (VERBOSE) {\n            System.out.println(\"    exp: id=\" + doc.id + \" is a hit\");\n          }\n          // Hit:\n          hits.add(doc);\n          drillDownCounts.inc(doc.dims, doc.dims2);\n          for(int dim=0;dim<dimValues.length;dim++) {\n            drillSidewaysCounts[dim].inc(doc.dims, doc.dims2);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"    exp: id=\" + doc.id + \" is a near-miss on dim=\" + failDim);\n          }\n          drillSidewaysCounts[failDim].inc(doc.dims, doc.dims2, failDim);\n        }\n      }\n    }\n\n    Map<String,Integer> idToDocID = new HashMap<>();\n    for(int i=0;i<s.getIndexReader().maxDoc();i++) {\n      idToDocID.put(s.doc(i).get(\"id\"), i);\n    }\n\n    Collections.sort(hits);\n\n    TestFacetResult res = new TestFacetResult();\n    res.hits = hits;\n    res.counts = new int[numDims][];\n    res.uniqueCounts = new int[numDims];\n    for (int dim = 0; dim < numDims; dim++) {\n      if (drillDowns[dim] != null) {\n        res.counts[dim] = drillSidewaysCounts[dim].counts[dim];\n      } else {\n        res.counts[dim] = drillDownCounts.counts[dim];\n      }\n      int uniqueCount = 0;\n      for (int j = 0; j < res.counts[dim].length; j++) {\n        if (res.counts[dim][j] != 0) {\n          uniqueCount++;\n        }\n      }\n      res.uniqueCounts[dim] = uniqueCount;\n    }\n\n    return res;\n  }\n\n","sourceOld":"  private TestFacetResult slowDrillSidewaysSearch(IndexSearcher s, List<Doc> docs,\n                                                        String contentToken, String[][] drillDowns,\n                                                        String[][] dimValues, Filter onlyEven) throws Exception {\n    int numDims = dimValues.length;\n\n    List<Doc> hits = new ArrayList<>();\n    Counters drillDownCounts = new Counters(dimValues);\n    Counters[] drillSidewaysCounts = new Counters[dimValues.length];\n    for(int dim=0;dim<numDims;dim++) {\n      drillSidewaysCounts[dim] = new Counters(dimValues);\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"  compute expected\");\n    }\n\n    nextDoc: for(Doc doc : docs) {\n      if (doc.deleted) {\n        continue;\n      }\n      if (onlyEven != null & (Integer.parseInt(doc.id) & 1) != 0) {\n        continue;\n      }\n      if (contentToken == null || doc.contentToken.equals(contentToken)) {\n        int failDim = -1;\n        for(int dim=0;dim<numDims;dim++) {\n          if (drillDowns[dim] != null) {\n            String docValue = doc.dims[dim] == -1 ? null : dimValues[dim][doc.dims[dim]];\n            String docValue2 = doc.dims2[dim] == -1 ? null : dimValues[dim][doc.dims2[dim]];\n            boolean matches = false;\n            for(String value : drillDowns[dim]) {\n              if (value.equals(docValue) || value.equals(docValue2)) {\n                matches = true;\n                break;\n              }\n            }\n            if (!matches) {\n              if (failDim == -1) {\n                // Doc could be a near-miss, if no other dim fails\n                failDim = dim;\n              } else {\n                // Doc isn't a hit nor a near-miss\n                continue nextDoc;\n              }\n            }\n          }\n        }\n\n        if (failDim == -1) {\n          if (VERBOSE) {\n            System.out.println(\"    exp: id=\" + doc.id + \" is a hit\");\n          }\n          // Hit:\n          hits.add(doc);\n          drillDownCounts.inc(doc.dims, doc.dims2);\n          for(int dim=0;dim<dimValues.length;dim++) {\n            drillSidewaysCounts[dim].inc(doc.dims, doc.dims2);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"    exp: id=\" + doc.id + \" is a near-miss on dim=\" + failDim);\n          }\n          drillSidewaysCounts[failDim].inc(doc.dims, doc.dims2, failDim);\n        }\n      }\n    }\n\n    Map<String,Integer> idToDocID = new HashMap<>();\n    for(int i=0;i<s.getIndexReader().maxDoc();i++) {\n      idToDocID.put(s.doc(i).get(\"id\"), i);\n    }\n\n    Collections.sort(hits);\n\n    TestFacetResult res = new TestFacetResult();\n    res.hits = hits;\n    res.counts = new int[numDims][];\n    res.uniqueCounts = new int[numDims];\n    for (int dim = 0; dim < numDims; dim++) {\n      if (drillDowns[dim] != null) {\n        res.counts[dim] = drillSidewaysCounts[dim].counts[dim];\n      } else {\n        res.counts[dim] = drillDownCounts.counts[dim];\n      }\n      int uniqueCount = 0;\n      for (int j = 0; j < res.counts[dim].length; j++) {\n        if (res.counts[dim][j] != 0) {\n          uniqueCount++;\n        }\n      }\n      res.uniqueCounts[dim] = uniqueCount;\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"91eb857a56b1a3a6659c666f88e2398347fc1c5a","date":1483442809,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#slowDrillSidewaysSearch(IndexSearcher,List[Doc],String,String[][],String[][],Query).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#slowDrillSidewaysSearch(IndexSearcher,List[Doc],String,String[][],String[][],Query).mjava","sourceNew":"  private TestFacetResult slowDrillSidewaysSearch(IndexSearcher s, List<Doc> docs, String contentToken,\n          String[][] drillDowns, String[][] dimValues, Query onlyEven) throws Exception {\n    int numDims = dimValues.length;\n\n    List<Doc> hits = new ArrayList<>();\n    Counters drillDownCounts = new Counters(dimValues);\n    Counters[] drillSidewaysCounts = new Counters[dimValues.length];\n    for (int dim = 0; dim < numDims; dim++) {\n      drillSidewaysCounts[dim] = new Counters(dimValues);\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"  compute expected\");\n    }\n\n    nextDoc:\n    for (Doc doc : docs) {\n      if (doc.deleted) {\n        continue;\n      }\n      if (onlyEven != null & (Integer.parseInt(doc.id) & 1) != 0) {\n        continue;\n      }\n      if (contentToken == null || doc.contentToken.equals(contentToken)) {\n        int failDim = -1;\n        for (int dim = 0; dim < numDims; dim++) {\n          if (drillDowns[dim] != null) {\n            String docValue = doc.dims[dim] == -1 ? null : dimValues[dim][doc.dims[dim]];\n            String docValue2 = doc.dims2[dim] == -1 ? null : dimValues[dim][doc.dims2[dim]];\n            boolean matches = false;\n            for (String value : drillDowns[dim]) {\n              if (value.equals(docValue) || value.equals(docValue2)) {\n                matches = true;\n                break;\n              }\n            }\n            if (!matches) {\n              if (failDim == -1) {\n                // Doc could be a near-miss, if no other dim fails\n                failDim = dim;\n              } else {\n                // Doc isn't a hit nor a near-miss\n                continue nextDoc;\n              }\n            }\n          }\n        }\n\n        if (failDim == -1) {\n          if (VERBOSE) {\n            System.out.println(\"    exp: id=\" + doc.id + \" is a hit\");\n          }\n          // Hit:\n          hits.add(doc);\n          drillDownCounts.inc(doc.dims, doc.dims2);\n          for (int dim = 0; dim < dimValues.length; dim++) {\n            drillSidewaysCounts[dim].inc(doc.dims, doc.dims2);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"    exp: id=\" + doc.id + \" is a near-miss on dim=\" + failDim);\n          }\n          drillSidewaysCounts[failDim].inc(doc.dims, doc.dims2, failDim);\n        }\n      }\n    }\n\n    Map<String, Integer> idToDocID = new HashMap<>();\n    for (int i = 0; i < s.getIndexReader().maxDoc(); i++) {\n      idToDocID.put(s.doc(i).get(\"id\"), i);\n    }\n\n    Collections.sort(hits);\n\n    TestFacetResult res = new TestFacetResult();\n    res.hits = hits;\n    res.counts = new int[numDims][];\n    res.uniqueCounts = new int[numDims];\n    for (int dim = 0; dim < numDims; dim++) {\n      if (drillDowns[dim] != null) {\n        res.counts[dim] = drillSidewaysCounts[dim].counts[dim];\n      } else {\n        res.counts[dim] = drillDownCounts.counts[dim];\n      }\n      int uniqueCount = 0;\n      for (int j = 0; j < res.counts[dim].length; j++) {\n        if (res.counts[dim][j] != 0) {\n          uniqueCount++;\n        }\n      }\n      res.uniqueCounts[dim] = uniqueCount;\n    }\n\n    return res;\n  }\n\n","sourceOld":"  private TestFacetResult slowDrillSidewaysSearch(IndexSearcher s, List<Doc> docs,\n                                                        String contentToken, String[][] drillDowns,\n                                                        String[][] dimValues, Query onlyEven) throws Exception {\n    int numDims = dimValues.length;\n\n    List<Doc> hits = new ArrayList<>();\n    Counters drillDownCounts = new Counters(dimValues);\n    Counters[] drillSidewaysCounts = new Counters[dimValues.length];\n    for(int dim=0;dim<numDims;dim++) {\n      drillSidewaysCounts[dim] = new Counters(dimValues);\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"  compute expected\");\n    }\n\n    nextDoc: for(Doc doc : docs) {\n      if (doc.deleted) {\n        continue;\n      }\n      if (onlyEven != null & (Integer.parseInt(doc.id) & 1) != 0) {\n        continue;\n      }\n      if (contentToken == null || doc.contentToken.equals(contentToken)) {\n        int failDim = -1;\n        for(int dim=0;dim<numDims;dim++) {\n          if (drillDowns[dim] != null) {\n            String docValue = doc.dims[dim] == -1 ? null : dimValues[dim][doc.dims[dim]];\n            String docValue2 = doc.dims2[dim] == -1 ? null : dimValues[dim][doc.dims2[dim]];\n            boolean matches = false;\n            for(String value : drillDowns[dim]) {\n              if (value.equals(docValue) || value.equals(docValue2)) {\n                matches = true;\n                break;\n              }\n            }\n            if (!matches) {\n              if (failDim == -1) {\n                // Doc could be a near-miss, if no other dim fails\n                failDim = dim;\n              } else {\n                // Doc isn't a hit nor a near-miss\n                continue nextDoc;\n              }\n            }\n          }\n        }\n\n        if (failDim == -1) {\n          if (VERBOSE) {\n            System.out.println(\"    exp: id=\" + doc.id + \" is a hit\");\n          }\n          // Hit:\n          hits.add(doc);\n          drillDownCounts.inc(doc.dims, doc.dims2);\n          for(int dim=0;dim<dimValues.length;dim++) {\n            drillSidewaysCounts[dim].inc(doc.dims, doc.dims2);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"    exp: id=\" + doc.id + \" is a near-miss on dim=\" + failDim);\n          }\n          drillSidewaysCounts[failDim].inc(doc.dims, doc.dims2, failDim);\n        }\n      }\n    }\n\n    Map<String,Integer> idToDocID = new HashMap<>();\n    for(int i=0;i<s.getIndexReader().maxDoc();i++) {\n      idToDocID.put(s.doc(i).get(\"id\"), i);\n    }\n\n    Collections.sort(hits);\n\n    TestFacetResult res = new TestFacetResult();\n    res.hits = hits;\n    res.counts = new int[numDims][];\n    res.uniqueCounts = new int[numDims];\n    for (int dim = 0; dim < numDims; dim++) {\n      if (drillDowns[dim] != null) {\n        res.counts[dim] = drillSidewaysCounts[dim].counts[dim];\n      } else {\n        res.counts[dim] = drillDownCounts.counts[dim];\n      }\n      int uniqueCount = 0;\n      for (int j = 0; j < res.counts[dim].length; j++) {\n        if (res.counts[dim][j] != 0) {\n          uniqueCount++;\n        }\n      }\n      res.uniqueCounts[dim] = uniqueCount;\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#slowDrillSidewaysSearch(IndexSearcher,List[Doc],String,String[][],String[][],Query).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#slowDrillSidewaysSearch(IndexSearcher,List[Doc],String,String[][],String[][],Query).mjava","sourceNew":"  private TestFacetResult slowDrillSidewaysSearch(IndexSearcher s, List<Doc> docs, String contentToken,\n          String[][] drillDowns, String[][] dimValues, Query onlyEven) throws Exception {\n    int numDims = dimValues.length;\n\n    List<Doc> hits = new ArrayList<>();\n    Counters drillDownCounts = new Counters(dimValues);\n    Counters[] drillSidewaysCounts = new Counters[dimValues.length];\n    for (int dim = 0; dim < numDims; dim++) {\n      drillSidewaysCounts[dim] = new Counters(dimValues);\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"  compute expected\");\n    }\n\n    nextDoc:\n    for (Doc doc : docs) {\n      if (doc.deleted) {\n        continue;\n      }\n      if (onlyEven != null & (Integer.parseInt(doc.id) & 1) != 0) {\n        continue;\n      }\n      if (contentToken == null || doc.contentToken.equals(contentToken)) {\n        int failDim = -1;\n        for (int dim = 0; dim < numDims; dim++) {\n          if (drillDowns[dim] != null) {\n            String docValue = doc.dims[dim] == -1 ? null : dimValues[dim][doc.dims[dim]];\n            String docValue2 = doc.dims2[dim] == -1 ? null : dimValues[dim][doc.dims2[dim]];\n            boolean matches = false;\n            for (String value : drillDowns[dim]) {\n              if (value.equals(docValue) || value.equals(docValue2)) {\n                matches = true;\n                break;\n              }\n            }\n            if (!matches) {\n              if (failDim == -1) {\n                // Doc could be a near-miss, if no other dim fails\n                failDim = dim;\n              } else {\n                // Doc isn't a hit nor a near-miss\n                continue nextDoc;\n              }\n            }\n          }\n        }\n\n        if (failDim == -1) {\n          if (VERBOSE) {\n            System.out.println(\"    exp: id=\" + doc.id + \" is a hit\");\n          }\n          // Hit:\n          hits.add(doc);\n          drillDownCounts.inc(doc.dims, doc.dims2);\n          for (int dim = 0; dim < dimValues.length; dim++) {\n            drillSidewaysCounts[dim].inc(doc.dims, doc.dims2);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"    exp: id=\" + doc.id + \" is a near-miss on dim=\" + failDim);\n          }\n          drillSidewaysCounts[failDim].inc(doc.dims, doc.dims2, failDim);\n        }\n      }\n    }\n\n    Map<String, Integer> idToDocID = new HashMap<>();\n    for (int i = 0; i < s.getIndexReader().maxDoc(); i++) {\n      idToDocID.put(s.doc(i).get(\"id\"), i);\n    }\n\n    Collections.sort(hits);\n\n    TestFacetResult res = new TestFacetResult();\n    res.hits = hits;\n    res.counts = new int[numDims][];\n    res.uniqueCounts = new int[numDims];\n    for (int dim = 0; dim < numDims; dim++) {\n      if (drillDowns[dim] != null) {\n        res.counts[dim] = drillSidewaysCounts[dim].counts[dim];\n      } else {\n        res.counts[dim] = drillDownCounts.counts[dim];\n      }\n      int uniqueCount = 0;\n      for (int j = 0; j < res.counts[dim].length; j++) {\n        if (res.counts[dim][j] != 0) {\n          uniqueCount++;\n        }\n      }\n      res.uniqueCounts[dim] = uniqueCount;\n    }\n\n    return res;\n  }\n\n","sourceOld":"  private TestFacetResult slowDrillSidewaysSearch(IndexSearcher s, List<Doc> docs,\n                                                        String contentToken, String[][] drillDowns,\n                                                        String[][] dimValues, Query onlyEven) throws Exception {\n    int numDims = dimValues.length;\n\n    List<Doc> hits = new ArrayList<>();\n    Counters drillDownCounts = new Counters(dimValues);\n    Counters[] drillSidewaysCounts = new Counters[dimValues.length];\n    for(int dim=0;dim<numDims;dim++) {\n      drillSidewaysCounts[dim] = new Counters(dimValues);\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"  compute expected\");\n    }\n\n    nextDoc: for(Doc doc : docs) {\n      if (doc.deleted) {\n        continue;\n      }\n      if (onlyEven != null & (Integer.parseInt(doc.id) & 1) != 0) {\n        continue;\n      }\n      if (contentToken == null || doc.contentToken.equals(contentToken)) {\n        int failDim = -1;\n        for(int dim=0;dim<numDims;dim++) {\n          if (drillDowns[dim] != null) {\n            String docValue = doc.dims[dim] == -1 ? null : dimValues[dim][doc.dims[dim]];\n            String docValue2 = doc.dims2[dim] == -1 ? null : dimValues[dim][doc.dims2[dim]];\n            boolean matches = false;\n            for(String value : drillDowns[dim]) {\n              if (value.equals(docValue) || value.equals(docValue2)) {\n                matches = true;\n                break;\n              }\n            }\n            if (!matches) {\n              if (failDim == -1) {\n                // Doc could be a near-miss, if no other dim fails\n                failDim = dim;\n              } else {\n                // Doc isn't a hit nor a near-miss\n                continue nextDoc;\n              }\n            }\n          }\n        }\n\n        if (failDim == -1) {\n          if (VERBOSE) {\n            System.out.println(\"    exp: id=\" + doc.id + \" is a hit\");\n          }\n          // Hit:\n          hits.add(doc);\n          drillDownCounts.inc(doc.dims, doc.dims2);\n          for(int dim=0;dim<dimValues.length;dim++) {\n            drillSidewaysCounts[dim].inc(doc.dims, doc.dims2);\n          }\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"    exp: id=\" + doc.id + \" is a near-miss on dim=\" + failDim);\n          }\n          drillSidewaysCounts[failDim].inc(doc.dims, doc.dims2, failDim);\n        }\n      }\n    }\n\n    Map<String,Integer> idToDocID = new HashMap<>();\n    for(int i=0;i<s.getIndexReader().maxDoc();i++) {\n      idToDocID.put(s.doc(i).get(\"id\"), i);\n    }\n\n    Collections.sort(hits);\n\n    TestFacetResult res = new TestFacetResult();\n    res.hits = hits;\n    res.counts = new int[numDims][];\n    res.uniqueCounts = new int[numDims];\n    for (int dim = 0; dim < numDims; dim++) {\n      if (drillDowns[dim] != null) {\n        res.counts[dim] = drillSidewaysCounts[dim].counts[dim];\n      } else {\n        res.counts[dim] = drillDownCounts.counts[dim];\n      }\n      int uniqueCount = 0;\n      for (int j = 0; j < res.counts[dim].length; j++) {\n        if (res.counts[dim][j] != 0) {\n          uniqueCount++;\n        }\n      }\n      res.uniqueCounts[dim] = uniqueCount;\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d52e48927ca4ef3655a261f2230b968b6fdf3608":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"91eb857a56b1a3a6659c666f88e2398347fc1c5a":["d52e48927ca4ef3655a261f2230b968b6fdf3608"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["91eb857a56b1a3a6659c666f88e2398347fc1c5a"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["d52e48927ca4ef3655a261f2230b968b6fdf3608","91eb857a56b1a3a6659c666f88e2398347fc1c5a"]},"commit2Childs":{"d52e48927ca4ef3655a261f2230b968b6fdf3608":["91eb857a56b1a3a6659c666f88e2398347fc1c5a","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d52e48927ca4ef3655a261f2230b968b6fdf3608"],"91eb857a56b1a3a6659c666f88e2398347fc1c5a":["cd5edd1f2b162a5cfa08efd17851a07373a96817","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"f03e4bed5023ec3ef93a771b8888cae991cf448d":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}