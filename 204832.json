{"path":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","sourceNew":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers (using {@link\n   *  Gather}) and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader r) throws IOException {\n    if (r instanceof AtomicReader) {\n      // already an atomic reader\n      return ((AtomicReader) r).fields();\n    }\n    assert r instanceof CompositeReader;\n    final IndexReader[] subs = ((CompositeReader) r).getSequentialSubReaders();\n    if (subs.length == 0) {\n      // no fields\n      return null;\n    } else {\n      final List<Fields> fields = new ArrayList<Fields>();\n      final List<ReaderUtil.Slice> slices = new ArrayList<ReaderUtil.Slice>();\n\n      new ReaderUtil.Gather(r) {\n        @Override\n        protected void add(int base, AtomicReader r) throws IOException {\n          final Fields f = r.fields();\n          if (f != null) {\n            fields.add(f);\n            slices.add(new ReaderUtil.Slice(base, r.maxDoc(), fields.size()-1));\n          }\n        }\n      }.run();\n\n      if (fields.isEmpty()) {\n        return null;\n      } else if (fields.size() == 1) {\n        return fields.get(0);\n      } else {\n        return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                       slices.toArray(ReaderUtil.Slice.EMPTY_ARRAY));\n      }\n    }\n  }\n\n","sourceOld":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers (using {@link\n   *  Gather}) and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader r) throws IOException {\n    if (r instanceof AtomicReader) {\n      // already an atomic reader\n      return ((AtomicReader) r).fields();\n    }\n    assert r instanceof CompositeReader;\n    final IndexReader[] subs = ((CompositeReader) r).getSequentialSubReaders();\n    if (subs.length == 0) {\n      // no fields\n      return null;\n    } else {\n      final List<Fields> fields = new ArrayList<Fields>();\n      final List<ReaderUtil.Slice> slices = new ArrayList<ReaderUtil.Slice>();\n\n      new ReaderUtil.Gather(r) {\n        @Override\n        protected void add(int base, AtomicReader r) throws IOException {\n          final Fields f = r.fields();\n          if (f != null) {\n            fields.add(f);\n            slices.add(new ReaderUtil.Slice(base, r.maxDoc(), fields.size()-1));\n          }\n        }\n      }.run();\n\n      if (fields.isEmpty()) {\n        return null;\n      } else if (fields.size() == 1) {\n        return fields.get(0);\n      } else {\n        return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                       slices.toArray(ReaderUtil.Slice.EMPTY_ARRAY));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d08eba3d52b63561ebf936481ce73e6b6a14aa03","date":1333879759,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","sourceNew":"  /** Returns a single {@link InvertedFields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers (using {@link\n   *  Gather}) and iterate through them\n   *  yourself. */\n  public static InvertedFields getFields(IndexReader r) throws IOException {\n    if (r instanceof AtomicReader) {\n      // already an atomic reader\n      return ((AtomicReader) r).fields();\n    }\n    assert r instanceof CompositeReader;\n    final IndexReader[] subs = ((CompositeReader) r).getSequentialSubReaders();\n    if (subs.length == 0) {\n      // no fields\n      return null;\n    } else {\n      final List<InvertedFields> fields = new ArrayList<InvertedFields>();\n      final List<ReaderUtil.Slice> slices = new ArrayList<ReaderUtil.Slice>();\n\n      new ReaderUtil.Gather(r) {\n        @Override\n        protected void add(int base, AtomicReader r) throws IOException {\n          final InvertedFields f = r.fields();\n          if (f != null) {\n            fields.add(f);\n            slices.add(new ReaderUtil.Slice(base, r.maxDoc(), fields.size()-1));\n          }\n        }\n      }.run();\n\n      if (fields.isEmpty()) {\n        return null;\n      } else if (fields.size() == 1) {\n        return fields.get(0);\n      } else {\n        return new MultiFields(fields.toArray(InvertedFields.EMPTY_ARRAY),\n                                       slices.toArray(ReaderUtil.Slice.EMPTY_ARRAY));\n      }\n    }\n  }\n\n","sourceOld":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers (using {@link\n   *  Gather}) and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader r) throws IOException {\n    if (r instanceof AtomicReader) {\n      // already an atomic reader\n      return ((AtomicReader) r).fields();\n    }\n    assert r instanceof CompositeReader;\n    final IndexReader[] subs = ((CompositeReader) r).getSequentialSubReaders();\n    if (subs.length == 0) {\n      // no fields\n      return null;\n    } else {\n      final List<Fields> fields = new ArrayList<Fields>();\n      final List<ReaderUtil.Slice> slices = new ArrayList<ReaderUtil.Slice>();\n\n      new ReaderUtil.Gather(r) {\n        @Override\n        protected void add(int base, AtomicReader r) throws IOException {\n          final Fields f = r.fields();\n          if (f != null) {\n            fields.add(f);\n            slices.add(new ReaderUtil.Slice(base, r.maxDoc(), fields.size()-1));\n          }\n        }\n      }.run();\n\n      if (fields.isEmpty()) {\n        return null;\n      } else if (fields.size() == 1) {\n        return fields.get(0);\n      } else {\n        return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                       slices.toArray(ReaderUtil.Slice.EMPTY_ARRAY));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf","date":1333892281,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","sourceNew":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers (using {@link\n   *  Gather}) and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader r) throws IOException {\n    if (r instanceof AtomicReader) {\n      // already an atomic reader\n      return ((AtomicReader) r).fields();\n    }\n    assert r instanceof CompositeReader;\n    final IndexReader[] subs = ((CompositeReader) r).getSequentialSubReaders();\n    if (subs.length == 0) {\n      // no fields\n      return null;\n    } else {\n      final List<Fields> fields = new ArrayList<Fields>();\n      final List<ReaderUtil.Slice> slices = new ArrayList<ReaderUtil.Slice>();\n\n      new ReaderUtil.Gather(r) {\n        @Override\n        protected void add(int base, AtomicReader r) throws IOException {\n          final Fields f = r.fields();\n          if (f != null) {\n            fields.add(f);\n            slices.add(new ReaderUtil.Slice(base, r.maxDoc(), fields.size()-1));\n          }\n        }\n      }.run();\n\n      if (fields.isEmpty()) {\n        return null;\n      } else if (fields.size() == 1) {\n        return fields.get(0);\n      } else {\n        return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                       slices.toArray(ReaderUtil.Slice.EMPTY_ARRAY));\n      }\n    }\n  }\n\n","sourceOld":"  /** Returns a single {@link InvertedFields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers (using {@link\n   *  Gather}) and iterate through them\n   *  yourself. */\n  public static InvertedFields getFields(IndexReader r) throws IOException {\n    if (r instanceof AtomicReader) {\n      // already an atomic reader\n      return ((AtomicReader) r).fields();\n    }\n    assert r instanceof CompositeReader;\n    final IndexReader[] subs = ((CompositeReader) r).getSequentialSubReaders();\n    if (subs.length == 0) {\n      // no fields\n      return null;\n    } else {\n      final List<InvertedFields> fields = new ArrayList<InvertedFields>();\n      final List<ReaderUtil.Slice> slices = new ArrayList<ReaderUtil.Slice>();\n\n      new ReaderUtil.Gather(r) {\n        @Override\n        protected void add(int base, AtomicReader r) throws IOException {\n          final InvertedFields f = r.fields();\n          if (f != null) {\n            fields.add(f);\n            slices.add(new ReaderUtil.Slice(base, r.maxDoc(), fields.size()-1));\n          }\n        }\n      }.run();\n\n      if (fields.isEmpty()) {\n        return null;\n      } else if (fields.size() == 1) {\n        return fields.get(0);\n      } else {\n        return new MultiFields(fields.toArray(InvertedFields.EMPTY_ARRAY),\n                                       slices.toArray(ReaderUtil.Slice.EMPTY_ARRAY));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","date":1340090669,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","sourceNew":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader reader) throws IOException {\n    final List<AtomicReaderContext> leaves = reader.getTopReaderContext().leaves();\n    switch (leaves.size()) {\n      case 0:\n        // no fields\n        return null;\n      case 1:\n        // already an atomic reader / reader with one leave\n        return leaves.get(0).reader().fields();\n      default:\n        final List<Fields> fields = new ArrayList<Fields>();\n        final List<ReaderSlice> slices = new ArrayList<ReaderSlice>();\n        for (final AtomicReaderContext ctx : leaves) {\n          final AtomicReader r = ctx.reader();\n          final Fields f = r.fields();\n          if (f != null) {\n            fields.add(f);\n            slices.add(new ReaderSlice(ctx.docBase, r.maxDoc(), fields.size()-1));\n          }\n        }\n        if (fields.isEmpty()) {\n          return null;\n        } else if (fields.size() == 1) {\n          return fields.get(0);\n        } else {\n          return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                         slices.toArray(ReaderSlice.EMPTY_ARRAY));\n        }\n    }\n  }\n\n","sourceOld":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers (using {@link\n   *  Gather}) and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader r) throws IOException {\n    if (r instanceof AtomicReader) {\n      // already an atomic reader\n      return ((AtomicReader) r).fields();\n    }\n    assert r instanceof CompositeReader;\n    final IndexReader[] subs = ((CompositeReader) r).getSequentialSubReaders();\n    if (subs.length == 0) {\n      // no fields\n      return null;\n    } else {\n      final List<Fields> fields = new ArrayList<Fields>();\n      final List<ReaderUtil.Slice> slices = new ArrayList<ReaderUtil.Slice>();\n\n      new ReaderUtil.Gather(r) {\n        @Override\n        protected void add(int base, AtomicReader r) throws IOException {\n          final Fields f = r.fields();\n          if (f != null) {\n            fields.add(f);\n            slices.add(new ReaderUtil.Slice(base, r.maxDoc(), fields.size()-1));\n          }\n        }\n      }.run();\n\n      if (fields.isEmpty()) {\n        return null;\n      } else if (fields.size() == 1) {\n        return fields.get(0);\n      } else {\n        return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                       slices.toArray(ReaderUtil.Slice.EMPTY_ARRAY));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["8028ab7a24273833d53d35eb160dba5b57283cf5","d743dbdc40bef0a47a5d54d99623ef0c2eb5923e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d743dbdc40bef0a47a5d54d99623ef0c2eb5923e","date":1344896544,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","sourceNew":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader reader) throws IOException {\n    final List<AtomicReaderContext> leaves = reader.leaves();\n    switch (leaves.size()) {\n      case 0:\n        // no fields\n        return null;\n      case 1:\n        // already an atomic reader / reader with one leave\n        return leaves.get(0).reader().fields();\n      default:\n        final List<Fields> fields = new ArrayList<Fields>();\n        final List<ReaderSlice> slices = new ArrayList<ReaderSlice>();\n        for (final AtomicReaderContext ctx : leaves) {\n          final AtomicReader r = ctx.reader();\n          final Fields f = r.fields();\n          if (f != null) {\n            fields.add(f);\n            slices.add(new ReaderSlice(ctx.docBase, r.maxDoc(), fields.size()-1));\n          }\n        }\n        if (fields.isEmpty()) {\n          return null;\n        } else if (fields.size() == 1) {\n          return fields.get(0);\n        } else {\n          return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                         slices.toArray(ReaderSlice.EMPTY_ARRAY));\n        }\n    }\n  }\n\n","sourceOld":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader reader) throws IOException {\n    final List<AtomicReaderContext> leaves = reader.getTopReaderContext().leaves();\n    switch (leaves.size()) {\n      case 0:\n        // no fields\n        return null;\n      case 1:\n        // already an atomic reader / reader with one leave\n        return leaves.get(0).reader().fields();\n      default:\n        final List<Fields> fields = new ArrayList<Fields>();\n        final List<ReaderSlice> slices = new ArrayList<ReaderSlice>();\n        for (final AtomicReaderContext ctx : leaves) {\n          final AtomicReader r = ctx.reader();\n          final Fields f = r.fields();\n          if (f != null) {\n            fields.add(f);\n            slices.add(new ReaderSlice(ctx.docBase, r.maxDoc(), fields.size()-1));\n          }\n        }\n        if (fields.isEmpty()) {\n          return null;\n        } else if (fields.size() == 1) {\n          return fields.get(0);\n        } else {\n          return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                         slices.toArray(ReaderSlice.EMPTY_ARRAY));\n        }\n    }\n  }\n\n","bugFix":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","date":1345029782,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","sourceNew":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader reader) throws IOException {\n    final List<AtomicReaderContext> leaves = reader.leaves();\n    switch (leaves.size()) {\n      case 0:\n        // no fields\n        return null;\n      case 1:\n        // already an atomic reader / reader with one leave\n        return leaves.get(0).reader().fields();\n      default:\n        final List<Fields> fields = new ArrayList<Fields>();\n        final List<ReaderSlice> slices = new ArrayList<ReaderSlice>();\n        for (final AtomicReaderContext ctx : leaves) {\n          final AtomicReader r = ctx.reader();\n          final Fields f = r.fields();\n          if (f != null) {\n            fields.add(f);\n            slices.add(new ReaderSlice(ctx.docBase, r.maxDoc(), fields.size()-1));\n          }\n        }\n        if (fields.isEmpty()) {\n          return null;\n        } else if (fields.size() == 1) {\n          return fields.get(0);\n        } else {\n          return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                         slices.toArray(ReaderSlice.EMPTY_ARRAY));\n        }\n    }\n  }\n\n","sourceOld":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader reader) throws IOException {\n    final List<AtomicReaderContext> leaves = reader.getTopReaderContext().leaves();\n    switch (leaves.size()) {\n      case 0:\n        // no fields\n        return null;\n      case 1:\n        // already an atomic reader / reader with one leave\n        return leaves.get(0).reader().fields();\n      default:\n        final List<Fields> fields = new ArrayList<Fields>();\n        final List<ReaderSlice> slices = new ArrayList<ReaderSlice>();\n        for (final AtomicReaderContext ctx : leaves) {\n          final AtomicReader r = ctx.reader();\n          final Fields f = r.fields();\n          if (f != null) {\n            fields.add(f);\n            slices.add(new ReaderSlice(ctx.docBase, r.maxDoc(), fields.size()-1));\n          }\n        }\n        if (fields.isEmpty()) {\n          return null;\n        } else if (fields.size() == 1) {\n          return fields.get(0);\n        } else {\n          return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                         slices.toArray(ReaderSlice.EMPTY_ARRAY));\n        }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3c188105a9aae04f56c24996f98f8333fc825d2e","date":1345031914,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","sourceNew":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader reader) throws IOException {\n    final List<AtomicReaderContext> leaves = reader.leaves();\n    switch (leaves.size()) {\n      case 0:\n        // no fields\n        return null;\n      case 1:\n        // already an atomic reader / reader with one leave\n        return leaves.get(0).reader().fields();\n      default:\n        final List<Fields> fields = new ArrayList<Fields>();\n        final List<ReaderSlice> slices = new ArrayList<ReaderSlice>();\n        for (final AtomicReaderContext ctx : leaves) {\n          final AtomicReader r = ctx.reader();\n          final Fields f = r.fields();\n          if (f != null) {\n            fields.add(f);\n            slices.add(new ReaderSlice(ctx.docBase, r.maxDoc(), fields.size()-1));\n          }\n        }\n        if (fields.isEmpty()) {\n          return null;\n        } else if (fields.size() == 1) {\n          return fields.get(0);\n        } else {\n          return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                         slices.toArray(ReaderSlice.EMPTY_ARRAY));\n        }\n    }\n  }\n\n","sourceOld":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader reader) throws IOException {\n    final List<AtomicReaderContext> leaves = reader.getTopReaderContext().leaves();\n    switch (leaves.size()) {\n      case 0:\n        // no fields\n        return null;\n      case 1:\n        // already an atomic reader / reader with one leave\n        return leaves.get(0).reader().fields();\n      default:\n        final List<Fields> fields = new ArrayList<Fields>();\n        final List<ReaderSlice> slices = new ArrayList<ReaderSlice>();\n        for (final AtomicReaderContext ctx : leaves) {\n          final AtomicReader r = ctx.reader();\n          final Fields f = r.fields();\n          if (f != null) {\n            fields.add(f);\n            slices.add(new ReaderSlice(ctx.docBase, r.maxDoc(), fields.size()-1));\n          }\n        }\n        if (fields.isEmpty()) {\n          return null;\n        } else if (fields.size() == 1) {\n          return fields.get(0);\n        } else {\n          return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                         slices.toArray(ReaderSlice.EMPTY_ARRAY));\n        }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1c93396a1df03720cb20e2c2f513a6fa59b21e4c","date":1345032673,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","sourceNew":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader reader) throws IOException {\n    final List<AtomicReaderContext> leaves = reader.getTopReaderContext().leaves();\n    switch (leaves.size()) {\n      case 0:\n        // no fields\n        return null;\n      case 1:\n        // already an atomic reader / reader with one leave\n        return leaves.get(0).reader().fields();\n      default:\n        final List<Fields> fields = new ArrayList<Fields>();\n        final List<ReaderSlice> slices = new ArrayList<ReaderSlice>();\n        for (final AtomicReaderContext ctx : leaves) {\n          final AtomicReader r = ctx.reader();\n          final Fields f = r.fields();\n          if (f != null) {\n            fields.add(f);\n            slices.add(new ReaderSlice(ctx.docBase, r.maxDoc(), fields.size()-1));\n          }\n        }\n        if (fields.isEmpty()) {\n          return null;\n        } else if (fields.size() == 1) {\n          return fields.get(0);\n        } else {\n          return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                         slices.toArray(ReaderSlice.EMPTY_ARRAY));\n        }\n    }\n  }\n\n","sourceOld":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader reader) throws IOException {\n    final List<AtomicReaderContext> leaves = reader.leaves();\n    switch (leaves.size()) {\n      case 0:\n        // no fields\n        return null;\n      case 1:\n        // already an atomic reader / reader with one leave\n        return leaves.get(0).reader().fields();\n      default:\n        final List<Fields> fields = new ArrayList<Fields>();\n        final List<ReaderSlice> slices = new ArrayList<ReaderSlice>();\n        for (final AtomicReaderContext ctx : leaves) {\n          final AtomicReader r = ctx.reader();\n          final Fields f = r.fields();\n          if (f != null) {\n            fields.add(f);\n            slices.add(new ReaderSlice(ctx.docBase, r.maxDoc(), fields.size()-1));\n          }\n        }\n        if (fields.isEmpty()) {\n          return null;\n        } else if (fields.size() == 1) {\n          return fields.get(0);\n        } else {\n          return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                         slices.toArray(ReaderSlice.EMPTY_ARRAY));\n        }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b05c56a41b733e02a189c48895922b5bd8c7f3d1","date":1345033322,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","sourceNew":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader reader) throws IOException {\n    final List<AtomicReaderContext> leaves = reader.leaves();\n    switch (leaves.size()) {\n      case 0:\n        // no fields\n        return null;\n      case 1:\n        // already an atomic reader / reader with one leave\n        return leaves.get(0).reader().fields();\n      default:\n        final List<Fields> fields = new ArrayList<Fields>();\n        final List<ReaderSlice> slices = new ArrayList<ReaderSlice>();\n        for (final AtomicReaderContext ctx : leaves) {\n          final AtomicReader r = ctx.reader();\n          final Fields f = r.fields();\n          if (f != null) {\n            fields.add(f);\n            slices.add(new ReaderSlice(ctx.docBase, r.maxDoc(), fields.size()-1));\n          }\n        }\n        if (fields.isEmpty()) {\n          return null;\n        } else if (fields.size() == 1) {\n          return fields.get(0);\n        } else {\n          return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                         slices.toArray(ReaderSlice.EMPTY_ARRAY));\n        }\n    }\n  }\n\n","sourceOld":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader reader) throws IOException {\n    final List<AtomicReaderContext> leaves = reader.getTopReaderContext().leaves();\n    switch (leaves.size()) {\n      case 0:\n        // no fields\n        return null;\n      case 1:\n        // already an atomic reader / reader with one leave\n        return leaves.get(0).reader().fields();\n      default:\n        final List<Fields> fields = new ArrayList<Fields>();\n        final List<ReaderSlice> slices = new ArrayList<ReaderSlice>();\n        for (final AtomicReaderContext ctx : leaves) {\n          final AtomicReader r = ctx.reader();\n          final Fields f = r.fields();\n          if (f != null) {\n            fields.add(f);\n            slices.add(new ReaderSlice(ctx.docBase, r.maxDoc(), fields.size()-1));\n          }\n        }\n        if (fields.isEmpty()) {\n          return null;\n        } else if (fields.size() == 1) {\n          return fields.get(0);\n        } else {\n          return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                         slices.toArray(ReaderSlice.EMPTY_ARRAY));\n        }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","sourceNew":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader reader) throws IOException {\n    final List<AtomicReaderContext> leaves = reader.leaves();\n    switch (leaves.size()) {\n      case 0:\n        // no fields\n        return null;\n      case 1:\n        // already an atomic reader / reader with one leave\n        return leaves.get(0).reader().fields();\n      default:\n        final List<Fields> fields = new ArrayList<>();\n        final List<ReaderSlice> slices = new ArrayList<>();\n        for (final AtomicReaderContext ctx : leaves) {\n          final AtomicReader r = ctx.reader();\n          final Fields f = r.fields();\n          if (f != null) {\n            fields.add(f);\n            slices.add(new ReaderSlice(ctx.docBase, r.maxDoc(), fields.size()-1));\n          }\n        }\n        if (fields.isEmpty()) {\n          return null;\n        } else if (fields.size() == 1) {\n          return fields.get(0);\n        } else {\n          return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                         slices.toArray(ReaderSlice.EMPTY_ARRAY));\n        }\n    }\n  }\n\n","sourceOld":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader reader) throws IOException {\n    final List<AtomicReaderContext> leaves = reader.leaves();\n    switch (leaves.size()) {\n      case 0:\n        // no fields\n        return null;\n      case 1:\n        // already an atomic reader / reader with one leave\n        return leaves.get(0).reader().fields();\n      default:\n        final List<Fields> fields = new ArrayList<Fields>();\n        final List<ReaderSlice> slices = new ArrayList<ReaderSlice>();\n        for (final AtomicReaderContext ctx : leaves) {\n          final AtomicReader r = ctx.reader();\n          final Fields f = r.fields();\n          if (f != null) {\n            fields.add(f);\n            slices.add(new ReaderSlice(ctx.docBase, r.maxDoc(), fields.size()-1));\n          }\n        }\n        if (fields.isEmpty()) {\n          return null;\n        } else if (fields.size() == 1) {\n          return fields.get(0);\n        } else {\n          return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                         slices.toArray(ReaderSlice.EMPTY_ARRAY));\n        }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","sourceNew":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader reader) throws IOException {\n    final List<LeafReaderContext> leaves = reader.leaves();\n    switch (leaves.size()) {\n      case 0:\n        // no fields\n        return null;\n      case 1:\n        // already an atomic reader / reader with one leave\n        return leaves.get(0).reader().fields();\n      default:\n        final List<Fields> fields = new ArrayList<>();\n        final List<ReaderSlice> slices = new ArrayList<>();\n        for (final LeafReaderContext ctx : leaves) {\n          final LeafReader r = ctx.reader();\n          final Fields f = r.fields();\n          if (f != null) {\n            fields.add(f);\n            slices.add(new ReaderSlice(ctx.docBase, r.maxDoc(), fields.size()-1));\n          }\n        }\n        if (fields.isEmpty()) {\n          return null;\n        } else if (fields.size() == 1) {\n          return fields.get(0);\n        } else {\n          return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                         slices.toArray(ReaderSlice.EMPTY_ARRAY));\n        }\n    }\n  }\n\n","sourceOld":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader reader) throws IOException {\n    final List<AtomicReaderContext> leaves = reader.leaves();\n    switch (leaves.size()) {\n      case 0:\n        // no fields\n        return null;\n      case 1:\n        // already an atomic reader / reader with one leave\n        return leaves.get(0).reader().fields();\n      default:\n        final List<Fields> fields = new ArrayList<>();\n        final List<ReaderSlice> slices = new ArrayList<>();\n        for (final AtomicReaderContext ctx : leaves) {\n          final AtomicReader r = ctx.reader();\n          final Fields f = r.fields();\n          if (f != null) {\n            fields.add(f);\n            slices.add(new ReaderSlice(ctx.docBase, r.maxDoc(), fields.size()-1));\n          }\n        }\n        if (fields.isEmpty()) {\n          return null;\n        } else if (fields.size() == 1) {\n          return fields.get(0);\n        } else {\n          return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                         slices.toArray(ReaderSlice.EMPTY_ARRAY));\n        }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8028ab7a24273833d53d35eb160dba5b57283cf5","date":1416767720,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","sourceNew":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader reader) throws IOException {\n    final List<LeafReaderContext> leaves = reader.leaves();\n    switch (leaves.size()) {\n      case 1:\n        // already an atomic reader / reader with one leave\n        return leaves.get(0).reader().fields();\n      default:\n        final List<Fields> fields = new ArrayList<>();\n        final List<ReaderSlice> slices = new ArrayList<>();\n        for (final LeafReaderContext ctx : leaves) {\n          final LeafReader r = ctx.reader();\n          final Fields f = r.fields();\n          fields.add(f);\n          slices.add(new ReaderSlice(ctx.docBase, r.maxDoc(), fields.size()-1));\n        }\n        if (fields.size() == 1) {\n          return fields.get(0);\n        } else {\n          return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                         slices.toArray(ReaderSlice.EMPTY_ARRAY));\n        }\n    }\n  }\n\n","sourceOld":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader reader) throws IOException {\n    final List<LeafReaderContext> leaves = reader.leaves();\n    switch (leaves.size()) {\n      case 0:\n        // no fields\n        return null;\n      case 1:\n        // already an atomic reader / reader with one leave\n        return leaves.get(0).reader().fields();\n      default:\n        final List<Fields> fields = new ArrayList<>();\n        final List<ReaderSlice> slices = new ArrayList<>();\n        for (final LeafReaderContext ctx : leaves) {\n          final LeafReader r = ctx.reader();\n          final Fields f = r.fields();\n          if (f != null) {\n            fields.add(f);\n            slices.add(new ReaderSlice(ctx.docBase, r.maxDoc(), fields.size()-1));\n          }\n        }\n        if (fields.isEmpty()) {\n          return null;\n        } else if (fields.size() == 1) {\n          return fields.get(0);\n        } else {\n          return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                         slices.toArray(ReaderSlice.EMPTY_ARRAY));\n        }\n    }\n  }\n\n","bugFix":["2725b2d479964ea5aaea0ba4ae2634716f3ec26c","955c32f886db6f6356c9fcdea6b1f1cb4effda24","4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7277addaa5100a3b464703b0a0efb5a993ff5999","date":1447264320,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","sourceNew":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader reader) throws IOException {\n    final List<LeafReaderContext> leaves = reader.leaves();\n    switch (leaves.size()) {\n      case 1:\n        // already an atomic reader / reader with one leave\n        return leaves.get(0).reader().fields();\n      default:\n        final List<Fields> fields = new ArrayList<>(leaves.size());\n        final List<ReaderSlice> slices = new ArrayList<>(leaves.size());\n        for (final LeafReaderContext ctx : leaves) {\n          final LeafReader r = ctx.reader();\n          final Fields f = r.fields();\n          fields.add(f);\n          slices.add(new ReaderSlice(ctx.docBase, r.maxDoc(), fields.size()-1));\n        }\n        if (fields.size() == 1) {\n          return fields.get(0);\n        } else {\n          return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                         slices.toArray(ReaderSlice.EMPTY_ARRAY));\n        }\n    }\n  }\n\n","sourceOld":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader reader) throws IOException {\n    final List<LeafReaderContext> leaves = reader.leaves();\n    switch (leaves.size()) {\n      case 1:\n        // already an atomic reader / reader with one leave\n        return leaves.get(0).reader().fields();\n      default:\n        final List<Fields> fields = new ArrayList<>();\n        final List<ReaderSlice> slices = new ArrayList<>();\n        for (final LeafReaderContext ctx : leaves) {\n          final LeafReader r = ctx.reader();\n          final Fields f = r.fields();\n          fields.add(f);\n          slices.add(new ReaderSlice(ctx.docBase, r.maxDoc(), fields.size()-1));\n        }\n        if (fields.size() == 1) {\n          return fields.get(0);\n        } else {\n          return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                         slices.toArray(ReaderSlice.EMPTY_ARRAY));\n        }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"22aab7a3b640b0dba26cc5e9416bc7af93614b46","date":1462575761,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","sourceNew":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader reader) throws IOException {\n    final List<LeafReaderContext> leaves = reader.leaves();\n    switch (leaves.size()) {\n      case 1:\n        // already an atomic reader / reader with one leave\n        return leaves.get(0).reader().fields();\n      default:\n        final List<Fields> fields = new ArrayList<>(leaves.size());\n        final List<ReaderSlice> slices = new ArrayList<>(leaves.size());\n        for (final LeafReaderContext ctx : leaves) {\n          final LeafReader r = ctx.reader();\n          if (r.getIndexSort() != null) {\n            throw new IllegalArgumentException(\"cannot handle index sort: reader=\" + r);\n          }\n          final Fields f = r.fields();\n          fields.add(f);\n          slices.add(new ReaderSlice(ctx.docBase, r.maxDoc(), fields.size()-1));\n        }\n        if (fields.size() == 1) {\n          return fields.get(0);\n        } else {\n          return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                         slices.toArray(ReaderSlice.EMPTY_ARRAY));\n        }\n    }\n  }\n\n","sourceOld":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader reader) throws IOException {\n    final List<LeafReaderContext> leaves = reader.leaves();\n    switch (leaves.size()) {\n      case 1:\n        // already an atomic reader / reader with one leave\n        return leaves.get(0).reader().fields();\n      default:\n        final List<Fields> fields = new ArrayList<>(leaves.size());\n        final List<ReaderSlice> slices = new ArrayList<>(leaves.size());\n        for (final LeafReaderContext ctx : leaves) {\n          final LeafReader r = ctx.reader();\n          final Fields f = r.fields();\n          fields.add(f);\n          slices.add(new ReaderSlice(ctx.docBase, r.maxDoc(), fields.size()-1));\n        }\n        if (fields.size() == 1) {\n          return fields.get(0);\n        } else {\n          return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                         slices.toArray(ReaderSlice.EMPTY_ARRAY));\n        }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"815972da4a13279b8e975d2e32ca450649d6c295","date":1462635959,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","sourceNew":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader reader) throws IOException {\n    final List<LeafReaderContext> leaves = reader.leaves();\n    switch (leaves.size()) {\n      case 1:\n        // already an atomic reader / reader with one leave\n        return leaves.get(0).reader().fields();\n      default:\n        final List<Fields> fields = new ArrayList<>(leaves.size());\n        final List<ReaderSlice> slices = new ArrayList<>(leaves.size());\n        for (final LeafReaderContext ctx : leaves) {\n          final LeafReader r = ctx.reader();\n          final Fields f = r.fields();\n          fields.add(f);\n          slices.add(new ReaderSlice(ctx.docBase, r.maxDoc(), fields.size()-1));\n        }\n        if (fields.size() == 1) {\n          return fields.get(0);\n        } else {\n          return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                         slices.toArray(ReaderSlice.EMPTY_ARRAY));\n        }\n    }\n  }\n\n","sourceOld":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader reader) throws IOException {\n    final List<LeafReaderContext> leaves = reader.leaves();\n    switch (leaves.size()) {\n      case 1:\n        // already an atomic reader / reader with one leave\n        return leaves.get(0).reader().fields();\n      default:\n        final List<Fields> fields = new ArrayList<>(leaves.size());\n        final List<ReaderSlice> slices = new ArrayList<>(leaves.size());\n        for (final LeafReaderContext ctx : leaves) {\n          final LeafReader r = ctx.reader();\n          if (r.getIndexSort() != null) {\n            throw new IllegalArgumentException(\"cannot handle index sort: reader=\" + r);\n          }\n          final Fields f = r.fields();\n          fields.add(f);\n          slices.add(new ReaderSlice(ctx.docBase, r.maxDoc(), fields.size()-1));\n        }\n        if (fields.size() == 1) {\n          return fields.get(0);\n        } else {\n          return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                         slices.toArray(ReaderSlice.EMPTY_ARRAY));\n        }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2b6f36bb733c575dd04fdfa785127ebf82b0033f","date":1497502741,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","sourceNew":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader reader) throws IOException {\n    final List<LeafReaderContext> leaves = reader.leaves();\n    switch (leaves.size()) {\n      case 1:\n        // already an atomic reader / reader with one leave\n        return new LeafReaderFields(leaves.get(0).reader());\n      default:\n        final List<Fields> fields = new ArrayList<>(leaves.size());\n        final List<ReaderSlice> slices = new ArrayList<>(leaves.size());\n        for (final LeafReaderContext ctx : leaves) {\n          final LeafReader r = ctx.reader();\n          final Fields f = new LeafReaderFields(r);\n          fields.add(f);\n          slices.add(new ReaderSlice(ctx.docBase, r.maxDoc(), fields.size()-1));\n        }\n        if (fields.size() == 1) {\n          return fields.get(0);\n        } else {\n          return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                         slices.toArray(ReaderSlice.EMPTY_ARRAY));\n        }\n    }\n  }\n\n","sourceOld":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader reader) throws IOException {\n    final List<LeafReaderContext> leaves = reader.leaves();\n    switch (leaves.size()) {\n      case 1:\n        // already an atomic reader / reader with one leave\n        return leaves.get(0).reader().fields();\n      default:\n        final List<Fields> fields = new ArrayList<>(leaves.size());\n        final List<ReaderSlice> slices = new ArrayList<>(leaves.size());\n        for (final LeafReaderContext ctx : leaves) {\n          final LeafReader r = ctx.reader();\n          final Fields f = r.fields();\n          fields.add(f);\n          slices.add(new ReaderSlice(ctx.docBase, r.maxDoc(), fields.size()-1));\n        }\n        if (fields.size() == 1) {\n          return fields.get(0);\n        } else {\n          return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                         slices.toArray(ReaderSlice.EMPTY_ARRAY));\n        }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","sourceNew":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader reader) throws IOException {\n    final List<LeafReaderContext> leaves = reader.leaves();\n    switch (leaves.size()) {\n      case 1:\n        // already an atomic reader / reader with one leave\n        return new LeafReaderFields(leaves.get(0).reader());\n      default:\n        final List<Fields> fields = new ArrayList<>(leaves.size());\n        final List<ReaderSlice> slices = new ArrayList<>(leaves.size());\n        for (final LeafReaderContext ctx : leaves) {\n          final LeafReader r = ctx.reader();\n          final Fields f = new LeafReaderFields(r);\n          fields.add(f);\n          slices.add(new ReaderSlice(ctx.docBase, r.maxDoc(), fields.size()-1));\n        }\n        if (fields.size() == 1) {\n          return fields.get(0);\n        } else {\n          return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                         slices.toArray(ReaderSlice.EMPTY_ARRAY));\n        }\n    }\n  }\n\n","sourceOld":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader reader) throws IOException {\n    final List<LeafReaderContext> leaves = reader.leaves();\n    switch (leaves.size()) {\n      case 1:\n        // already an atomic reader / reader with one leave\n        return leaves.get(0).reader().fields();\n      default:\n        final List<Fields> fields = new ArrayList<>(leaves.size());\n        final List<ReaderSlice> slices = new ArrayList<>(leaves.size());\n        for (final LeafReaderContext ctx : leaves) {\n          final LeafReader r = ctx.reader();\n          final Fields f = r.fields();\n          fields.add(f);\n          slices.add(new ReaderSlice(ctx.docBase, r.maxDoc(), fields.size()-1));\n        }\n        if (fields.size() == 1) {\n          return fields.get(0);\n        } else {\n          return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                         slices.toArray(ReaderSlice.EMPTY_ARRAY));\n        }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","sourceNew":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader reader) throws IOException {\n    final List<LeafReaderContext> leaves = reader.leaves();\n    switch (leaves.size()) {\n      case 1:\n        // already an atomic reader / reader with one leave\n        return new LeafReaderFields(leaves.get(0).reader());\n      default:\n        final List<Fields> fields = new ArrayList<>(leaves.size());\n        final List<ReaderSlice> slices = new ArrayList<>(leaves.size());\n        for (final LeafReaderContext ctx : leaves) {\n          final LeafReader r = ctx.reader();\n          final Fields f = new LeafReaderFields(r);\n          fields.add(f);\n          slices.add(new ReaderSlice(ctx.docBase, r.maxDoc(), fields.size()-1));\n        }\n        if (fields.size() == 1) {\n          return fields.get(0);\n        } else {\n          return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                         slices.toArray(ReaderSlice.EMPTY_ARRAY));\n        }\n    }\n  }\n\n","sourceOld":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader reader) throws IOException {\n    final List<LeafReaderContext> leaves = reader.leaves();\n    switch (leaves.size()) {\n      case 1:\n        // already an atomic reader / reader with one leave\n        return leaves.get(0).reader().fields();\n      default:\n        final List<Fields> fields = new ArrayList<>(leaves.size());\n        final List<ReaderSlice> slices = new ArrayList<>(leaves.size());\n        for (final LeafReaderContext ctx : leaves) {\n          final LeafReader r = ctx.reader();\n          final Fields f = r.fields();\n          fields.add(f);\n          slices.add(new ReaderSlice(ctx.docBase, r.maxDoc(), fields.size()-1));\n        }\n        if (fields.size() == 1) {\n          return fields.get(0);\n        } else {\n          return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                         slices.toArray(ReaderSlice.EMPTY_ARRAY));\n        }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ddad75c20492a8ce36565647b4eaf7b6f3fd1f7","date":1538404752,"type":4,"author":"David Smiley","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiFields#getFields(IndexReader).mjava","sourceNew":null,"sourceOld":"  /** Returns a single {@link Fields} instance for this\n   *  reader, merging fields/terms/docs/positions on the\n   *  fly.  This method will return null if the reader \n   *  has no postings.\n   *\n   *  <p><b>NOTE</b>: this is a slow way to access postings.\n   *  It's better to get the sub-readers and iterate through them\n   *  yourself. */\n  public static Fields getFields(IndexReader reader) throws IOException {\n    final List<LeafReaderContext> leaves = reader.leaves();\n    switch (leaves.size()) {\n      case 1:\n        // already an atomic reader / reader with one leave\n        return new LeafReaderFields(leaves.get(0).reader());\n      default:\n        final List<Fields> fields = new ArrayList<>(leaves.size());\n        final List<ReaderSlice> slices = new ArrayList<>(leaves.size());\n        for (final LeafReaderContext ctx : leaves) {\n          final LeafReader r = ctx.reader();\n          final Fields f = new LeafReaderFields(r);\n          fields.add(f);\n          slices.add(new ReaderSlice(ctx.docBase, r.maxDoc(), fields.size()-1));\n        }\n        if (fields.size() == 1) {\n          return fields.get(0);\n        } else {\n          return new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),\n                                         slices.toArray(ReaderSlice.EMPTY_ARRAY));\n        }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["d743dbdc40bef0a47a5d54d99623ef0c2eb5923e"],"7277addaa5100a3b464703b0a0efb5a993ff5999":["8028ab7a24273833d53d35eb160dba5b57283cf5"],"3c188105a9aae04f56c24996f98f8333fc825d2e":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":["1c93396a1df03720cb20e2c2f513a6fa59b21e4c","d743dbdc40bef0a47a5d54d99623ef0c2eb5923e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2b6f36bb733c575dd04fdfa785127ebf82b0033f":["7277addaa5100a3b464703b0a0efb5a993ff5999"],"1c93396a1df03720cb20e2c2f513a6fa59b21e4c":["3c188105a9aae04f56c24996f98f8333fc825d2e"],"9ddad75c20492a8ce36565647b4eaf7b6f3fd1f7":["28288370235ed02234a64753cdbf0c6ec096304a"],"d08eba3d52b63561ebf936481ce73e6b6a14aa03":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","d743dbdc40bef0a47a5d54d99623ef0c2eb5923e"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"28288370235ed02234a64753cdbf0c6ec096304a":["7277addaa5100a3b464703b0a0efb5a993ff5999","2b6f36bb733c575dd04fdfa785127ebf82b0033f"],"22aab7a3b640b0dba26cc5e9416bc7af93614b46":["7277addaa5100a3b464703b0a0efb5a993ff5999"],"8028ab7a24273833d53d35eb160dba5b57283cf5":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf":["d08eba3d52b63561ebf936481ce73e6b6a14aa03"],"d743dbdc40bef0a47a5d54d99623ef0c2eb5923e":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"815972da4a13279b8e975d2e32ca450649d6c295":["22aab7a3b640b0dba26cc5e9416bc7af93614b46"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["7277addaa5100a3b464703b0a0efb5a993ff5999","2b6f36bb733c575dd04fdfa785127ebf82b0033f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9ddad75c20492a8ce36565647b4eaf7b6f3fd1f7"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"7277addaa5100a3b464703b0a0efb5a993ff5999":["2b6f36bb733c575dd04fdfa785127ebf82b0033f","28288370235ed02234a64753cdbf0c6ec096304a","22aab7a3b640b0dba26cc5e9416bc7af93614b46","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"3c188105a9aae04f56c24996f98f8333fc825d2e":["1c93396a1df03720cb20e2c2f513a6fa59b21e4c"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["3c188105a9aae04f56c24996f98f8333fc825d2e","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","d743dbdc40bef0a47a5d54d99623ef0c2eb5923e"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["d08eba3d52b63561ebf936481ce73e6b6a14aa03"],"2b6f36bb733c575dd04fdfa785127ebf82b0033f":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"1c93396a1df03720cb20e2c2f513a6fa59b21e4c":["b05c56a41b733e02a189c48895922b5bd8c7f3d1"],"9ddad75c20492a8ce36565647b4eaf7b6f3fd1f7":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d08eba3d52b63561ebf936481ce73e6b6a14aa03":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":[],"28288370235ed02234a64753cdbf0c6ec096304a":["9ddad75c20492a8ce36565647b4eaf7b6f3fd1f7"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["8028ab7a24273833d53d35eb160dba5b57283cf5"],"22aab7a3b640b0dba26cc5e9416bc7af93614b46":["815972da4a13279b8e975d2e32ca450649d6c295"],"8028ab7a24273833d53d35eb160dba5b57283cf5":["7277addaa5100a3b464703b0a0efb5a993ff5999"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"d743dbdc40bef0a47a5d54d99623ef0c2eb5923e":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198"],"815972da4a13279b8e975d2e32ca450649d6c295":[],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","815972da4a13279b8e975d2e32ca450649d6c295","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}