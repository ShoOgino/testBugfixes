{"path":"lucene/replicator/src/test/org/apache/lucene/replicator/ReplicatorTestCase#newHttpServer(Handler).mjava","commits":[{"id":"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4","date":1368446242,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/ReplicatorTestCase#newHttpServer(Handler).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Returns a new {@link Server HTTP Server} instance. To obtain its port, use\n   * {@link #serverPort(Server)}.\n   */\n  public static synchronized Server newHttpServer(Handler handler) throws Exception {\n    int port = lastPortUsed == -1 ? BASE_PORT : lastPortUsed + 1;\n    Server server = null;\n    while (true) {\n      try {\n        server = new Server(port);\n        \n        server.setHandler(handler);\n        \n        QueuedThreadPool threadPool = new QueuedThreadPool();\n        threadPool.setDaemon(true);\n        threadPool.setMaxIdleTimeMs(0);\n        server.setThreadPool(threadPool);\n        \n        // this will test the port\n        server.start();\n        \n        // if here, port is available\n        lastPortUsed = port;\n        return server;\n      } catch (SocketException e) {\n        stopHttpServer(server);\n        // this is ok, we'll try the next port until successful.\n        ++port;\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6fd7690db7212b99d407b3bde0b0813541923082","date":1368458534,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/ReplicatorTestCase#newHttpServer(Handler).mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/ReplicatorTestCase#newHttpServer(Handler).mjava","sourceNew":"  /**\n   * Returns a new {@link Server HTTP Server} instance. To obtain its port, use\n   * {@link #serverPort(Server)}.\n   */\n  public static synchronized Server newHttpServer(Handler handler) throws Exception {\n    int port = lastPortUsed == -1 ? BASE_PORT : lastPortUsed + 1;\n    Server server = null;\n    while (true) {\n      try {\n        server = new Server(port);\n        \n        server.setHandler(handler);\n        \n        final String connectorName = System.getProperty(\"tests.jettyConnector\", \"SelectChannel\");\n\n        // if this property is true, then jetty will be configured to use SSL\n        // leveraging the same system properties as java to specify\n        // the keystore/truststore if they are set\n        //\n        // This means we will use the same truststore, keystore (and keys) for\n        // the server as well as any client actions taken by this JVM in\n        // talking to that server, but for the purposes of testing that should \n        // be good enough\n        final boolean useSsl = Boolean.getBoolean(\"tests.jettySsl\");\n        final SslContextFactory sslcontext = new SslContextFactory(false);\n\n        if (useSsl) {\n          if (null != System.getProperty(\"javax.net.ssl.keyStore\")) {\n            sslcontext.setKeyStorePath\n              (System.getProperty(\"javax.net.ssl.keyStore\"));\n          }\n          if (null != System.getProperty(\"javax.net.ssl.keyStorePassword\")) {\n            sslcontext.setKeyStorePassword\n              (System.getProperty(\"javax.net.ssl.keyStorePassword\"));\n          }\n          if (null != System.getProperty(\"javax.net.ssl.trustStore\")) {\n            sslcontext.setTrustStore\n              (System.getProperty(\"javax.net.ssl.trustStore\"));\n          }\n          if (null != System.getProperty(\"javax.net.ssl.trustStorePassword\")) {\n            sslcontext.setTrustStorePassword\n              (System.getProperty(\"javax.net.ssl.trustStorePassword\"));\n          }\n          sslcontext.setNeedClientAuth(Boolean.getBoolean(\"tests.jettySsl.clientAuth\"));\n        }\n\n        final Connector connector;\n        final QueuedThreadPool threadPool;\n        if (\"SelectChannel\".equals(connectorName)) {\n          final SelectChannelConnector c = useSsl ? new SslSelectChannelConnector(sslcontext) : new SelectChannelConnector();\n          c.setReuseAddress(true);\n          c.setLowResourcesMaxIdleTime(1500);\n          connector = c;\n          threadPool = (QueuedThreadPool) c.getThreadPool();\n        } else if (\"Socket\".equals(connectorName)) {\n          final SocketConnector c = useSsl ? new SslSocketConnector(sslcontext) : new SocketConnector();\n          c.setReuseAddress(true);\n          connector = c;\n          threadPool = (QueuedThreadPool) c.getThreadPool();\n        } else {\n          throw new IllegalArgumentException(\"Illegal value for system property 'tests.jettyConnector': \" + connectorName);\n        }\n\n        connector.setPort(port);\n        connector.setHost(\"127.0.0.1\");\n        if (threadPool != null) {\n          threadPool.setDaemon(true);\n          threadPool.setMaxThreads(10000);\n          threadPool.setMaxIdleTimeMs(5000);\n          threadPool.setMaxStopTimeMs(30000);\n        }\n        \n        server.setConnectors(new Connector[] {connector});\n        server.setSessionIdManager(new HashSessionIdManager(new Random()));\n\n        // this will test the port\n        server.start();\n        \n        // if here, port is available\n        lastPortUsed = port;\n        return server;\n      } catch (SocketException e) {\n        stopHttpServer(server);\n        // this is ok, we'll try the next port until successful.\n        ++port;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a new {@link Server HTTP Server} instance. To obtain its port, use\n   * {@link #serverPort(Server)}.\n   */\n  public static synchronized Server newHttpServer(Handler handler) throws Exception {\n    int port = lastPortUsed == -1 ? BASE_PORT : lastPortUsed + 1;\n    Server server = null;\n    while (true) {\n      try {\n        server = new Server(port);\n        \n        server.setHandler(handler);\n        \n        QueuedThreadPool threadPool = new QueuedThreadPool();\n        threadPool.setDaemon(true);\n        threadPool.setMaxIdleTimeMs(0);\n        server.setThreadPool(threadPool);\n        \n        // this will test the port\n        server.start();\n        \n        // if here, port is available\n        lastPortUsed = port;\n        return server;\n      } catch (SocketException e) {\n        stopHttpServer(server);\n        // this is ok, we'll try the next port until successful.\n        ++port;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"49d13f9fe20e8eb6f81d320982b6f5937de74d92","date":1368460853,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/ReplicatorTestCase#newHttpServer(Handler).mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/ReplicatorTestCase#newHttpServer(Handler).mjava","sourceNew":"  /**\n   * Returns a new {@link Server HTTP Server} instance. To obtain its port, use\n   * {@link #serverPort(Server)}.\n   */\n  public static synchronized Server newHttpServer(Handler handler) throws Exception {\n    Server server = new Server(0);\n    \n    server.setHandler(handler);\n    \n    final String connectorName = System.getProperty(\"tests.jettyConnector\", \"SelectChannel\");\n    \n    // if this property is true, then jetty will be configured to use SSL\n    // leveraging the same system properties as java to specify\n    // the keystore/truststore if they are set\n    //\n    // This means we will use the same truststore, keystore (and keys) for\n    // the server as well as any client actions taken by this JVM in\n    // talking to that server, but for the purposes of testing that should \n    // be good enough\n    final boolean useSsl = Boolean.getBoolean(\"tests.jettySsl\");\n    final SslContextFactory sslcontext = new SslContextFactory(false);\n    \n    if (useSsl) {\n      if (null != System.getProperty(\"javax.net.ssl.keyStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.keyStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.keyStorePassword\")) {\n        sslcontext.setKeyStorePassword\n        (System.getProperty(\"javax.net.ssl.keyStorePassword\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStore\")) {\n        sslcontext.setTrustStore\n        (System.getProperty(\"javax.net.ssl.trustStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStorePassword\")) {\n        sslcontext.setTrustStorePassword\n        (System.getProperty(\"javax.net.ssl.trustStorePassword\"));\n      }\n      sslcontext.setNeedClientAuth(Boolean.getBoolean(\"tests.jettySsl.clientAuth\"));\n    }\n    \n    final Connector connector;\n    final QueuedThreadPool threadPool;\n    if (\"SelectChannel\".equals(connectorName)) {\n      final SelectChannelConnector c = useSsl ? new SslSelectChannelConnector(sslcontext) : new SelectChannelConnector();\n      c.setReuseAddress(true);\n      c.setLowResourcesMaxIdleTime(1500);\n      connector = c;\n      threadPool = (QueuedThreadPool) c.getThreadPool();\n    } else if (\"Socket\".equals(connectorName)) {\n      final SocketConnector c = useSsl ? new SslSocketConnector(sslcontext) : new SocketConnector();\n      c.setReuseAddress(true);\n      connector = c;\n      threadPool = (QueuedThreadPool) c.getThreadPool();\n    } else {\n      throw new IllegalArgumentException(\"Illegal value for system property 'tests.jettyConnector': \" + connectorName);\n    }\n    \n    connector.setPort(0);\n    connector.setHost(\"127.0.0.1\");\n    if (threadPool != null) {\n      threadPool.setDaemon(true);\n      threadPool.setMaxThreads(10000);\n      threadPool.setMaxIdleTimeMs(5000);\n      threadPool.setMaxStopTimeMs(30000);\n    }\n    \n    server.setConnectors(new Connector[] {connector});\n    server.setSessionIdManager(new HashSessionIdManager(new Random()));\n    \n    server.start();\n    \n    return server;\n  }\n\n","sourceOld":"  /**\n   * Returns a new {@link Server HTTP Server} instance. To obtain its port, use\n   * {@link #serverPort(Server)}.\n   */\n  public static synchronized Server newHttpServer(Handler handler) throws Exception {\n    int port = lastPortUsed == -1 ? BASE_PORT : lastPortUsed + 1;\n    Server server = null;\n    while (true) {\n      try {\n        server = new Server(port);\n        \n        server.setHandler(handler);\n        \n        final String connectorName = System.getProperty(\"tests.jettyConnector\", \"SelectChannel\");\n\n        // if this property is true, then jetty will be configured to use SSL\n        // leveraging the same system properties as java to specify\n        // the keystore/truststore if they are set\n        //\n        // This means we will use the same truststore, keystore (and keys) for\n        // the server as well as any client actions taken by this JVM in\n        // talking to that server, but for the purposes of testing that should \n        // be good enough\n        final boolean useSsl = Boolean.getBoolean(\"tests.jettySsl\");\n        final SslContextFactory sslcontext = new SslContextFactory(false);\n\n        if (useSsl) {\n          if (null != System.getProperty(\"javax.net.ssl.keyStore\")) {\n            sslcontext.setKeyStorePath\n              (System.getProperty(\"javax.net.ssl.keyStore\"));\n          }\n          if (null != System.getProperty(\"javax.net.ssl.keyStorePassword\")) {\n            sslcontext.setKeyStorePassword\n              (System.getProperty(\"javax.net.ssl.keyStorePassword\"));\n          }\n          if (null != System.getProperty(\"javax.net.ssl.trustStore\")) {\n            sslcontext.setTrustStore\n              (System.getProperty(\"javax.net.ssl.trustStore\"));\n          }\n          if (null != System.getProperty(\"javax.net.ssl.trustStorePassword\")) {\n            sslcontext.setTrustStorePassword\n              (System.getProperty(\"javax.net.ssl.trustStorePassword\"));\n          }\n          sslcontext.setNeedClientAuth(Boolean.getBoolean(\"tests.jettySsl.clientAuth\"));\n        }\n\n        final Connector connector;\n        final QueuedThreadPool threadPool;\n        if (\"SelectChannel\".equals(connectorName)) {\n          final SelectChannelConnector c = useSsl ? new SslSelectChannelConnector(sslcontext) : new SelectChannelConnector();\n          c.setReuseAddress(true);\n          c.setLowResourcesMaxIdleTime(1500);\n          connector = c;\n          threadPool = (QueuedThreadPool) c.getThreadPool();\n        } else if (\"Socket\".equals(connectorName)) {\n          final SocketConnector c = useSsl ? new SslSocketConnector(sslcontext) : new SocketConnector();\n          c.setReuseAddress(true);\n          connector = c;\n          threadPool = (QueuedThreadPool) c.getThreadPool();\n        } else {\n          throw new IllegalArgumentException(\"Illegal value for system property 'tests.jettyConnector': \" + connectorName);\n        }\n\n        connector.setPort(port);\n        connector.setHost(\"127.0.0.1\");\n        if (threadPool != null) {\n          threadPool.setDaemon(true);\n          threadPool.setMaxThreads(10000);\n          threadPool.setMaxIdleTimeMs(5000);\n          threadPool.setMaxStopTimeMs(30000);\n        }\n        \n        server.setConnectors(new Connector[] {connector});\n        server.setSessionIdManager(new HashSessionIdManager(new Random()));\n\n        // this will test the port\n        server.start();\n        \n        // if here, port is available\n        lastPortUsed = port;\n        return server;\n      } catch (SocketException e) {\n        stopHttpServer(server);\n        // this is ok, we'll try the next port until successful.\n        ++port;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["ea0f43f20834b3c8930e074b144aba27a935fee8"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6165e61f495a24c345d4faefc766b7366b4c9089","date":1368464630,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/ReplicatorTestCase#newHttpServer(Handler).mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/ReplicatorTestCase#newHttpServer(Handler).mjava","sourceNew":"  /**\n   * Returns a new {@link Server HTTP Server} instance. To obtain its port, use\n   * {@link #serverPort(Server)}.\n   */\n  public static synchronized Server newHttpServer(Handler handler) throws Exception {\n    Server server = new Server(0);\n    \n    server.setHandler(handler);\n    \n    final String connectorName = System.getProperty(\"tests.jettyConnector\", \"SelectChannel\");\n    \n    // if this property is true, then jetty will be configured to use SSL\n    // leveraging the same system properties as java to specify\n    // the keystore/truststore if they are set\n    //\n    // This means we will use the same truststore, keystore (and keys) for\n    // the server as well as any client actions taken by this JVM in\n    // talking to that server, but for the purposes of testing that should \n    // be good enough\n    final boolean useSsl = Boolean.getBoolean(\"tests.jettySsl\");\n    final SslContextFactory sslcontext = new SslContextFactory(false);\n    \n    if (useSsl) {\n      if (null != System.getProperty(\"javax.net.ssl.keyStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.keyStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.keyStorePassword\")) {\n        sslcontext.setKeyStorePassword\n        (System.getProperty(\"javax.net.ssl.keyStorePassword\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStore\")) {\n        sslcontext.setTrustStore\n        (System.getProperty(\"javax.net.ssl.trustStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStorePassword\")) {\n        sslcontext.setTrustStorePassword\n        (System.getProperty(\"javax.net.ssl.trustStorePassword\"));\n      }\n      sslcontext.setNeedClientAuth(Boolean.getBoolean(\"tests.jettySsl.clientAuth\"));\n    }\n    \n    final Connector connector;\n    final QueuedThreadPool threadPool;\n    if (\"SelectChannel\".equals(connectorName)) {\n      final SelectChannelConnector c = useSsl ? new SslSelectChannelConnector(sslcontext) : new SelectChannelConnector();\n      c.setReuseAddress(true);\n      c.setLowResourcesMaxIdleTime(1500);\n      connector = c;\n      threadPool = (QueuedThreadPool) c.getThreadPool();\n    } else if (\"Socket\".equals(connectorName)) {\n      final SocketConnector c = useSsl ? new SslSocketConnector(sslcontext) : new SocketConnector();\n      c.setReuseAddress(true);\n      connector = c;\n      threadPool = (QueuedThreadPool) c.getThreadPool();\n    } else {\n      throw new IllegalArgumentException(\"Illegal value for system property 'tests.jettyConnector': \" + connectorName);\n    }\n    \n    connector.setPort(0);\n    connector.setHost(\"127.0.0.1\");\n    if (threadPool != null) {\n      threadPool.setDaemon(true);\n      threadPool.setMaxThreads(10000);\n      threadPool.setMaxIdleTimeMs(5000);\n      threadPool.setMaxStopTimeMs(30000);\n    }\n    \n    server.setConnectors(new Connector[] {connector});\n    server.setSessionIdManager(new HashSessionIdManager(new Random(random().nextLong())));\n    \n    server.start();\n    \n    return server;\n  }\n\n","sourceOld":"  /**\n   * Returns a new {@link Server HTTP Server} instance. To obtain its port, use\n   * {@link #serverPort(Server)}.\n   */\n  public static synchronized Server newHttpServer(Handler handler) throws Exception {\n    Server server = new Server(0);\n    \n    server.setHandler(handler);\n    \n    final String connectorName = System.getProperty(\"tests.jettyConnector\", \"SelectChannel\");\n    \n    // if this property is true, then jetty will be configured to use SSL\n    // leveraging the same system properties as java to specify\n    // the keystore/truststore if they are set\n    //\n    // This means we will use the same truststore, keystore (and keys) for\n    // the server as well as any client actions taken by this JVM in\n    // talking to that server, but for the purposes of testing that should \n    // be good enough\n    final boolean useSsl = Boolean.getBoolean(\"tests.jettySsl\");\n    final SslContextFactory sslcontext = new SslContextFactory(false);\n    \n    if (useSsl) {\n      if (null != System.getProperty(\"javax.net.ssl.keyStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.keyStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.keyStorePassword\")) {\n        sslcontext.setKeyStorePassword\n        (System.getProperty(\"javax.net.ssl.keyStorePassword\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStore\")) {\n        sslcontext.setTrustStore\n        (System.getProperty(\"javax.net.ssl.trustStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStorePassword\")) {\n        sslcontext.setTrustStorePassword\n        (System.getProperty(\"javax.net.ssl.trustStorePassword\"));\n      }\n      sslcontext.setNeedClientAuth(Boolean.getBoolean(\"tests.jettySsl.clientAuth\"));\n    }\n    \n    final Connector connector;\n    final QueuedThreadPool threadPool;\n    if (\"SelectChannel\".equals(connectorName)) {\n      final SelectChannelConnector c = useSsl ? new SslSelectChannelConnector(sslcontext) : new SelectChannelConnector();\n      c.setReuseAddress(true);\n      c.setLowResourcesMaxIdleTime(1500);\n      connector = c;\n      threadPool = (QueuedThreadPool) c.getThreadPool();\n    } else if (\"Socket\".equals(connectorName)) {\n      final SocketConnector c = useSsl ? new SslSocketConnector(sslcontext) : new SocketConnector();\n      c.setReuseAddress(true);\n      connector = c;\n      threadPool = (QueuedThreadPool) c.getThreadPool();\n    } else {\n      throw new IllegalArgumentException(\"Illegal value for system property 'tests.jettyConnector': \" + connectorName);\n    }\n    \n    connector.setPort(0);\n    connector.setHost(\"127.0.0.1\");\n    if (threadPool != null) {\n      threadPool.setDaemon(true);\n      threadPool.setMaxThreads(10000);\n      threadPool.setMaxIdleTimeMs(5000);\n      threadPool.setMaxStopTimeMs(30000);\n    }\n    \n    server.setConnectors(new Connector[] {connector});\n    server.setSessionIdManager(new HashSessionIdManager(new Random()));\n    \n    server.start();\n    \n    return server;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"19275ba31e621f6da1b83bf13af75233876fd3d4","date":1374846698,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/ReplicatorTestCase#newHttpServer(Handler).mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/ReplicatorTestCase#newHttpServer(Handler).mjava","sourceNew":"  /**\n   * Returns a new {@link Server HTTP Server} instance. To obtain its port, use\n   * {@link #serverPort(Server)}.\n   */\n  public static synchronized Server newHttpServer(Handler handler) throws Exception {\n    Server server = new Server(0);\n    \n    server.setHandler(handler);\n    \n    final String connectorName = System.getProperty(\"tests.jettyConnector\", \"SelectChannel\");\n    \n    // if this property is true, then jetty will be configured to use SSL\n    // leveraging the same system properties as java to specify\n    // the keystore/truststore if they are set\n    //\n    // This means we will use the same truststore, keystore (and keys) for\n    // the server as well as any client actions taken by this JVM in\n    // talking to that server, but for the purposes of testing that should \n    // be good enough\n    final boolean useSsl = Boolean.getBoolean(\"tests.jettySsl\");\n    final SslContextFactory sslcontext = new SslContextFactory(false);\n    \n    if (useSsl) {\n      if (null != System.getProperty(\"javax.net.ssl.keyStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.keyStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.keyStorePassword\")) {\n        sslcontext.setKeyStorePassword\n        (System.getProperty(\"javax.net.ssl.keyStorePassword\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStore\")) {\n        sslcontext.setTrustStore\n        (System.getProperty(\"javax.net.ssl.trustStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStorePassword\")) {\n        sslcontext.setTrustStorePassword\n        (System.getProperty(\"javax.net.ssl.trustStorePassword\"));\n      }\n      sslcontext.setNeedClientAuth(Boolean.getBoolean(\"tests.jettySsl.clientAuth\"));\n    }\n    \n    final Connector connector;\n    final QueuedThreadPool threadPool;\n    if (\"SelectChannel\".equals(connectorName)) {\n      final SelectChannelConnector c = useSsl ? new SslSelectChannelConnector(sslcontext) : new SelectChannelConnector();\n      c.setReuseAddress(true);\n      c.setLowResourcesMaxIdleTime(1500);\n      connector = c;\n      threadPool = (QueuedThreadPool) c.getThreadPool();\n    } else if (\"Socket\".equals(connectorName)) {\n      final SocketConnector c = useSsl ? new SslSocketConnector(sslcontext) : new SocketConnector();\n      c.setReuseAddress(true);\n      connector = c;\n      threadPool = (QueuedThreadPool) c.getThreadPool();\n    } else {\n      throw new IllegalArgumentException(\"Illegal value for system property 'tests.jettyConnector': \" + connectorName);\n    }\n    \n    connector.setPort(0);\n    connector.setHost(\"127.0.0.1\");\n    if (threadPool != null) {\n      threadPool.setDaemon(true);\n      threadPool.setMaxThreads(10000);\n      threadPool.setMaxIdleTimeMs(5000);\n      threadPool.setMaxStopTimeMs(30000);\n    }\n    \n    server.setConnectors(new Connector[] {connector});\n    server.setSessionIdManager(new HashSessionIdManager(new Random(random().nextLong())));\n    \n    server.start();\n    \n    return server;\n  }\n\n","sourceOld":"  /**\n   * Returns a new {@link Server HTTP Server} instance. To obtain its port, use\n   * {@link #serverPort(Server)}.\n   */\n  public static synchronized Server newHttpServer(Handler handler) throws Exception {\n    Server server = new Server(0);\n    \n    server.setHandler(handler);\n    \n    final String connectorName = System.getProperty(\"tests.jettyConnector\", \"SelectChannel\");\n    \n    // if this property is true, then jetty will be configured to use SSL\n    // leveraging the same system properties as java to specify\n    // the keystore/truststore if they are set\n    //\n    // This means we will use the same truststore, keystore (and keys) for\n    // the server as well as any client actions taken by this JVM in\n    // talking to that server, but for the purposes of testing that should \n    // be good enough\n    final boolean useSsl = Boolean.getBoolean(\"tests.jettySsl\");\n    final SslContextFactory sslcontext = new SslContextFactory(false);\n    \n    if (useSsl) {\n      if (null != System.getProperty(\"javax.net.ssl.keyStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.keyStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.keyStorePassword\")) {\n        sslcontext.setKeyStorePassword\n        (System.getProperty(\"javax.net.ssl.keyStorePassword\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStore\")) {\n        sslcontext.setTrustStore\n        (System.getProperty(\"javax.net.ssl.trustStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStorePassword\")) {\n        sslcontext.setTrustStorePassword\n        (System.getProperty(\"javax.net.ssl.trustStorePassword\"));\n      }\n      sslcontext.setNeedClientAuth(Boolean.getBoolean(\"tests.jettySsl.clientAuth\"));\n    }\n    \n    final Connector connector;\n    final QueuedThreadPool threadPool;\n    if (\"SelectChannel\".equals(connectorName)) {\n      final SelectChannelConnector c = useSsl ? new SslSelectChannelConnector(sslcontext) : new SelectChannelConnector();\n      c.setReuseAddress(true);\n      c.setLowResourcesMaxIdleTime(1500);\n      connector = c;\n      threadPool = (QueuedThreadPool) c.getThreadPool();\n    } else if (\"Socket\".equals(connectorName)) {\n      final SocketConnector c = useSsl ? new SslSocketConnector(sslcontext) : new SocketConnector();\n      c.setReuseAddress(true);\n      connector = c;\n      threadPool = (QueuedThreadPool) c.getThreadPool();\n    } else {\n      throw new IllegalArgumentException(\"Illegal value for system property 'tests.jettyConnector': \" + connectorName);\n    }\n    \n    connector.setPort(0);\n    connector.setHost(\"127.0.0.1\");\n    if (threadPool != null) {\n      threadPool.setDaemon(true);\n      threadPool.setMaxThreads(10000);\n      threadPool.setMaxIdleTimeMs(5000);\n      threadPool.setMaxStopTimeMs(30000);\n    }\n    \n    server.setConnectors(new Connector[] {connector});\n    server.setSessionIdManager(new HashSessionIdManager(new Random(random().nextLong())));\n    \n    server.start();\n    \n    return server;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/ReplicatorTestCase#newHttpServer(Handler).mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/ReplicatorTestCase#newHttpServer(Handler).mjava","sourceNew":"  /**\n   * Returns a new {@link Server HTTP Server} instance. To obtain its port, use\n   * {@link #serverPort(Server)}.\n   */\n  public static synchronized Server newHttpServer(Handler handler) throws Exception {\n    Server server = new Server(0);\n    \n    server.setHandler(handler);\n    \n    final String connectorName = System.getProperty(\"tests.jettyConnector\", \"SelectChannel\");\n    \n    // if this property is true, then jetty will be configured to use SSL\n    // leveraging the same system properties as java to specify\n    // the keystore/truststore if they are set\n    //\n    // This means we will use the same truststore, keystore (and keys) for\n    // the server as well as any client actions taken by this JVM in\n    // talking to that server, but for the purposes of testing that should \n    // be good enough\n    final boolean useSsl = Boolean.getBoolean(\"tests.jettySsl\");\n    final SslContextFactory sslcontext = new SslContextFactory(false);\n    \n    if (useSsl) {\n      if (null != System.getProperty(\"javax.net.ssl.keyStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.keyStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.keyStorePassword\")) {\n        sslcontext.setKeyStorePassword\n        (System.getProperty(\"javax.net.ssl.keyStorePassword\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStore\")) {\n        sslcontext.setTrustStore\n        (System.getProperty(\"javax.net.ssl.trustStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStorePassword\")) {\n        sslcontext.setTrustStorePassword\n        (System.getProperty(\"javax.net.ssl.trustStorePassword\"));\n      }\n      sslcontext.setNeedClientAuth(Boolean.getBoolean(\"tests.jettySsl.clientAuth\"));\n    }\n    \n    final Connector connector;\n    final QueuedThreadPool threadPool;\n    if (\"SelectChannel\".equals(connectorName)) {\n      final SelectChannelConnector c = useSsl ? new SslSelectChannelConnector(sslcontext) : new SelectChannelConnector();\n      c.setReuseAddress(true);\n      c.setLowResourcesMaxIdleTime(1500);\n      connector = c;\n      threadPool = (QueuedThreadPool) c.getThreadPool();\n    } else if (\"Socket\".equals(connectorName)) {\n      final SocketConnector c = useSsl ? new SslSocketConnector(sslcontext) : new SocketConnector();\n      c.setReuseAddress(true);\n      connector = c;\n      threadPool = (QueuedThreadPool) c.getThreadPool();\n    } else {\n      throw new IllegalArgumentException(\"Illegal value for system property 'tests.jettyConnector': \" + connectorName);\n    }\n    \n    connector.setPort(0);\n    connector.setHost(\"127.0.0.1\");\n    if (threadPool != null) {\n      threadPool.setDaemon(true);\n      threadPool.setMaxThreads(10000);\n      threadPool.setMaxIdleTimeMs(5000);\n      threadPool.setMaxStopTimeMs(30000);\n    }\n    \n    server.setConnectors(new Connector[] {connector});\n    server.setSessionIdManager(new HashSessionIdManager(new Random(random().nextLong())));\n    \n    server.start();\n    \n    return server;\n  }\n\n","sourceOld":"  /**\n   * Returns a new {@link Server HTTP Server} instance. To obtain its port, use\n   * {@link #serverPort(Server)}.\n   */\n  public static synchronized Server newHttpServer(Handler handler) throws Exception {\n    Server server = new Server(0);\n    \n    server.setHandler(handler);\n    \n    final String connectorName = System.getProperty(\"tests.jettyConnector\", \"SelectChannel\");\n    \n    // if this property is true, then jetty will be configured to use SSL\n    // leveraging the same system properties as java to specify\n    // the keystore/truststore if they are set\n    //\n    // This means we will use the same truststore, keystore (and keys) for\n    // the server as well as any client actions taken by this JVM in\n    // talking to that server, but for the purposes of testing that should \n    // be good enough\n    final boolean useSsl = Boolean.getBoolean(\"tests.jettySsl\");\n    final SslContextFactory sslcontext = new SslContextFactory(false);\n    \n    if (useSsl) {\n      if (null != System.getProperty(\"javax.net.ssl.keyStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.keyStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.keyStorePassword\")) {\n        sslcontext.setKeyStorePassword\n        (System.getProperty(\"javax.net.ssl.keyStorePassword\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStore\")) {\n        sslcontext.setTrustStore\n        (System.getProperty(\"javax.net.ssl.trustStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStorePassword\")) {\n        sslcontext.setTrustStorePassword\n        (System.getProperty(\"javax.net.ssl.trustStorePassword\"));\n      }\n      sslcontext.setNeedClientAuth(Boolean.getBoolean(\"tests.jettySsl.clientAuth\"));\n    }\n    \n    final Connector connector;\n    final QueuedThreadPool threadPool;\n    if (\"SelectChannel\".equals(connectorName)) {\n      final SelectChannelConnector c = useSsl ? new SslSelectChannelConnector(sslcontext) : new SelectChannelConnector();\n      c.setReuseAddress(true);\n      c.setLowResourcesMaxIdleTime(1500);\n      connector = c;\n      threadPool = (QueuedThreadPool) c.getThreadPool();\n    } else if (\"Socket\".equals(connectorName)) {\n      final SocketConnector c = useSsl ? new SslSocketConnector(sslcontext) : new SocketConnector();\n      c.setReuseAddress(true);\n      connector = c;\n      threadPool = (QueuedThreadPool) c.getThreadPool();\n    } else {\n      throw new IllegalArgumentException(\"Illegal value for system property 'tests.jettyConnector': \" + connectorName);\n    }\n    \n    connector.setPort(0);\n    connector.setHost(\"127.0.0.1\");\n    if (threadPool != null) {\n      threadPool.setDaemon(true);\n      threadPool.setMaxThreads(10000);\n      threadPool.setMaxIdleTimeMs(5000);\n      threadPool.setMaxStopTimeMs(30000);\n    }\n    \n    server.setConnectors(new Connector[] {connector});\n    server.setSessionIdManager(new HashSessionIdManager(new Random(random().nextLong())));\n    \n    server.start();\n    \n    return server;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d5b778829b5b506ab02023b2f4ba58aef5d7f0fd","date":1420472758,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/ReplicatorTestCase#newHttpServer(Handler).mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/ReplicatorTestCase#newHttpServer(Handler).mjava","sourceNew":"  /**\n   * Returns a new {@link Server HTTP Server} instance. To obtain its port, use\n   * {@link #serverPort(Server)}.\n   */\n  public static synchronized Server newHttpServer(Handler handler) throws Exception {\n    // if this property is true, then jetty will be configured to use SSL\n    // leveraging the same system properties as java to specify\n    // the keystore/truststore if they are set\n    //\n    // This means we will use the same truststore, keystore (and keys) for\n    // the server as well as any client actions taken by this JVM in\n    // talking to that server, but for the purposes of testing that should \n    // be good enough\n    final boolean useSsl = Boolean.getBoolean(\"tests.jettySsl\");\n    final SslContextFactory sslcontext = new SslContextFactory(false);\n    \n    if (useSsl) {\n      if (null != System.getProperty(\"javax.net.ssl.keyStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.keyStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.keyStorePassword\")) {\n        sslcontext.setKeyStorePassword\n        (System.getProperty(\"javax.net.ssl.keyStorePassword\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.trustStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStorePassword\")) {\n        sslcontext.setTrustStorePassword\n        (System.getProperty(\"javax.net.ssl.trustStorePassword\"));\n      }\n      sslcontext.setNeedClientAuth(Boolean.getBoolean(\"tests.jettySsl.clientAuth\"));\n    }\n    \n    final QueuedThreadPool threadPool = new QueuedThreadPool();\n    threadPool.setDaemon(true);\n    threadPool.setMaxThreads(10000);\n    threadPool.setIdleTimeout(5000);\n    threadPool.setStopTimeout(30000);\n\n    Server server = new Server(threadPool);\n    server.setStopAtShutdown(true);\n    server.manage(threadPool);\n\n\n    final ServerConnector connector;\n    if (useSsl) {\n      HttpConfiguration configuration = new HttpConfiguration();\n      configuration.setSecureScheme(\"https\");\n      configuration.addCustomizer(new SecureRequestCustomizer());\n      ServerConnector c = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n          new HttpConnectionFactory(configuration));\n      connector = c;\n    } else {\n      ServerConnector c = new ServerConnector(server, new HttpConnectionFactory());\n      connector = c;\n    }\n    \n    connector.setPort(0);\n    connector.setHost(\"127.0.0.1\");\n\n    server.setConnectors(new Connector[] {connector});\n    server.setSessionIdManager(new HashSessionIdManager(new Random(random().nextLong())));\n    server.setHandler(handler);\n    \n    server.start();\n    \n    return server;\n  }\n\n","sourceOld":"  /**\n   * Returns a new {@link Server HTTP Server} instance. To obtain its port, use\n   * {@link #serverPort(Server)}.\n   */\n  public static synchronized Server newHttpServer(Handler handler) throws Exception {\n    Server server = new Server(0);\n    \n    server.setHandler(handler);\n    \n    final String connectorName = System.getProperty(\"tests.jettyConnector\", \"SelectChannel\");\n    \n    // if this property is true, then jetty will be configured to use SSL\n    // leveraging the same system properties as java to specify\n    // the keystore/truststore if they are set\n    //\n    // This means we will use the same truststore, keystore (and keys) for\n    // the server as well as any client actions taken by this JVM in\n    // talking to that server, but for the purposes of testing that should \n    // be good enough\n    final boolean useSsl = Boolean.getBoolean(\"tests.jettySsl\");\n    final SslContextFactory sslcontext = new SslContextFactory(false);\n    \n    if (useSsl) {\n      if (null != System.getProperty(\"javax.net.ssl.keyStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.keyStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.keyStorePassword\")) {\n        sslcontext.setKeyStorePassword\n        (System.getProperty(\"javax.net.ssl.keyStorePassword\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStore\")) {\n        sslcontext.setTrustStore\n        (System.getProperty(\"javax.net.ssl.trustStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStorePassword\")) {\n        sslcontext.setTrustStorePassword\n        (System.getProperty(\"javax.net.ssl.trustStorePassword\"));\n      }\n      sslcontext.setNeedClientAuth(Boolean.getBoolean(\"tests.jettySsl.clientAuth\"));\n    }\n    \n    final Connector connector;\n    final QueuedThreadPool threadPool;\n    if (\"SelectChannel\".equals(connectorName)) {\n      final SelectChannelConnector c = useSsl ? new SslSelectChannelConnector(sslcontext) : new SelectChannelConnector();\n      c.setReuseAddress(true);\n      c.setLowResourcesMaxIdleTime(1500);\n      connector = c;\n      threadPool = (QueuedThreadPool) c.getThreadPool();\n    } else if (\"Socket\".equals(connectorName)) {\n      final SocketConnector c = useSsl ? new SslSocketConnector(sslcontext) : new SocketConnector();\n      c.setReuseAddress(true);\n      connector = c;\n      threadPool = (QueuedThreadPool) c.getThreadPool();\n    } else {\n      throw new IllegalArgumentException(\"Illegal value for system property 'tests.jettyConnector': \" + connectorName);\n    }\n    \n    connector.setPort(0);\n    connector.setHost(\"127.0.0.1\");\n    if (threadPool != null) {\n      threadPool.setDaemon(true);\n      threadPool.setMaxThreads(10000);\n      threadPool.setMaxIdleTimeMs(5000);\n      threadPool.setMaxStopTimeMs(30000);\n    }\n    \n    server.setConnectors(new Connector[] {connector});\n    server.setSessionIdManager(new HashSessionIdManager(new Random(random().nextLong())));\n    \n    server.start();\n    \n    return server;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"269c5aee1e7702d512e3f45bf1f01afd15a2af5f","date":1516133643,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/ReplicatorTestCase#newHttpServer(Handler).mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/ReplicatorTestCase#newHttpServer(Handler).mjava","sourceNew":"  /**\n   * Returns a new {@link Server HTTP Server} instance. To obtain its port, use\n   * {@link #serverPort(Server)}.\n   */\n  public static synchronized Server newHttpServer(Handler handler) throws Exception {\n    // if this property is true, then jetty will be configured to use SSL\n    // leveraging the same system properties as java to specify\n    // the keystore/truststore if they are set\n    //\n    // This means we will use the same truststore, keystore (and keys) for\n    // the server as well as any client actions taken by this JVM in\n    // talking to that server, but for the purposes of testing that should \n    // be good enough\n    final boolean useSsl = Boolean.getBoolean(\"tests.jettySsl\");\n    final SslContextFactory sslcontext = new SslContextFactory(false);\n    \n    if (useSsl) {\n      if (null != System.getProperty(\"javax.net.ssl.keyStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.keyStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.keyStorePassword\")) {\n        sslcontext.setKeyStorePassword\n        (System.getProperty(\"javax.net.ssl.keyStorePassword\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.trustStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStorePassword\")) {\n        sslcontext.setTrustStorePassword\n        (System.getProperty(\"javax.net.ssl.trustStorePassword\"));\n      }\n      sslcontext.setNeedClientAuth(Boolean.getBoolean(\"tests.jettySsl.clientAuth\"));\n    }\n    \n    final QueuedThreadPool threadPool = new QueuedThreadPool();\n    threadPool.setDaemon(true);\n    threadPool.setMaxThreads(10000);\n    threadPool.setIdleTimeout(5000);\n    threadPool.setStopTimeout(30000);\n\n    Server server = new Server(threadPool);\n    server.setStopAtShutdown(true);\n    server.manage(threadPool);\n\n\n    final ServerConnector connector;\n    if (useSsl) {\n      HttpConfiguration configuration = new HttpConfiguration();\n      configuration.setSecureScheme(\"https\");\n      configuration.addCustomizer(new SecureRequestCustomizer());\n      ServerConnector c = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n          new HttpConnectionFactory(configuration));\n      connector = c;\n    } else {\n      ServerConnector c = new ServerConnector(server, new HttpConnectionFactory());\n      connector = c;\n    }\n    \n    connector.setPort(0);\n    connector.setHost(\"127.0.0.1\");\n\n    server.setConnectors(new Connector[] {connector});\n    server.setSessionIdManager(new DefaultSessionIdManager(server, new Random(random().nextLong())));\n    server.setHandler(handler);\n    \n    server.start();\n    \n    return server;\n  }\n\n","sourceOld":"  /**\n   * Returns a new {@link Server HTTP Server} instance. To obtain its port, use\n   * {@link #serverPort(Server)}.\n   */\n  public static synchronized Server newHttpServer(Handler handler) throws Exception {\n    // if this property is true, then jetty will be configured to use SSL\n    // leveraging the same system properties as java to specify\n    // the keystore/truststore if they are set\n    //\n    // This means we will use the same truststore, keystore (and keys) for\n    // the server as well as any client actions taken by this JVM in\n    // talking to that server, but for the purposes of testing that should \n    // be good enough\n    final boolean useSsl = Boolean.getBoolean(\"tests.jettySsl\");\n    final SslContextFactory sslcontext = new SslContextFactory(false);\n    \n    if (useSsl) {\n      if (null != System.getProperty(\"javax.net.ssl.keyStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.keyStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.keyStorePassword\")) {\n        sslcontext.setKeyStorePassword\n        (System.getProperty(\"javax.net.ssl.keyStorePassword\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.trustStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStorePassword\")) {\n        sslcontext.setTrustStorePassword\n        (System.getProperty(\"javax.net.ssl.trustStorePassword\"));\n      }\n      sslcontext.setNeedClientAuth(Boolean.getBoolean(\"tests.jettySsl.clientAuth\"));\n    }\n    \n    final QueuedThreadPool threadPool = new QueuedThreadPool();\n    threadPool.setDaemon(true);\n    threadPool.setMaxThreads(10000);\n    threadPool.setIdleTimeout(5000);\n    threadPool.setStopTimeout(30000);\n\n    Server server = new Server(threadPool);\n    server.setStopAtShutdown(true);\n    server.manage(threadPool);\n\n\n    final ServerConnector connector;\n    if (useSsl) {\n      HttpConfiguration configuration = new HttpConfiguration();\n      configuration.setSecureScheme(\"https\");\n      configuration.addCustomizer(new SecureRequestCustomizer());\n      ServerConnector c = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n          new HttpConnectionFactory(configuration));\n      connector = c;\n    } else {\n      ServerConnector c = new ServerConnector(server, new HttpConnectionFactory());\n      connector = c;\n    }\n    \n    connector.setPort(0);\n    connector.setHost(\"127.0.0.1\");\n\n    server.setConnectors(new Connector[] {connector});\n    server.setSessionIdManager(new HashSessionIdManager(new Random(random().nextLong())));\n    server.setHandler(handler);\n    \n    server.start();\n    \n    return server;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/ReplicatorTestCase#newHttpServer(Handler).mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/ReplicatorTestCase#newHttpServer(Handler).mjava","sourceNew":"  /**\n   * Returns a new {@link Server HTTP Server} instance. To obtain its port, use\n   * {@link #serverPort(Server)}.\n   */\n  public static synchronized Server newHttpServer(Handler handler) throws Exception {\n    // if this property is true, then jetty will be configured to use SSL\n    // leveraging the same system properties as java to specify\n    // the keystore/truststore if they are set\n    //\n    // This means we will use the same truststore, keystore (and keys) for\n    // the server as well as any client actions taken by this JVM in\n    // talking to that server, but for the purposes of testing that should \n    // be good enough\n    final boolean useSsl = Boolean.getBoolean(\"tests.jettySsl\");\n    final SslContextFactory sslcontext = new SslContextFactory(false);\n    \n    if (useSsl) {\n      if (null != System.getProperty(\"javax.net.ssl.keyStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.keyStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.keyStorePassword\")) {\n        sslcontext.setKeyStorePassword\n        (System.getProperty(\"javax.net.ssl.keyStorePassword\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.trustStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStorePassword\")) {\n        sslcontext.setTrustStorePassword\n        (System.getProperty(\"javax.net.ssl.trustStorePassword\"));\n      }\n      sslcontext.setNeedClientAuth(Boolean.getBoolean(\"tests.jettySsl.clientAuth\"));\n    }\n    \n    final QueuedThreadPool threadPool = new QueuedThreadPool();\n    threadPool.setDaemon(true);\n    threadPool.setMaxThreads(10000);\n    threadPool.setIdleTimeout(5000);\n    threadPool.setStopTimeout(30000);\n\n    Server server = new Server(threadPool);\n    server.setStopAtShutdown(true);\n    server.manage(threadPool);\n\n\n    final ServerConnector connector;\n    if (useSsl) {\n      HttpConfiguration configuration = new HttpConfiguration();\n      configuration.setSecureScheme(\"https\");\n      configuration.addCustomizer(new SecureRequestCustomizer());\n      ServerConnector c = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n          new HttpConnectionFactory(configuration));\n      connector = c;\n    } else {\n      ServerConnector c = new ServerConnector(server, new HttpConnectionFactory());\n      connector = c;\n    }\n    \n    connector.setPort(0);\n    connector.setHost(\"127.0.0.1\");\n\n    server.setConnectors(new Connector[] {connector});\n    server.setSessionIdManager(new DefaultSessionIdManager(server, new Random(random().nextLong())));\n    server.setHandler(handler);\n    \n    server.start();\n    \n    return server;\n  }\n\n","sourceOld":"  /**\n   * Returns a new {@link Server HTTP Server} instance. To obtain its port, use\n   * {@link #serverPort(Server)}.\n   */\n  public static synchronized Server newHttpServer(Handler handler) throws Exception {\n    // if this property is true, then jetty will be configured to use SSL\n    // leveraging the same system properties as java to specify\n    // the keystore/truststore if they are set\n    //\n    // This means we will use the same truststore, keystore (and keys) for\n    // the server as well as any client actions taken by this JVM in\n    // talking to that server, but for the purposes of testing that should \n    // be good enough\n    final boolean useSsl = Boolean.getBoolean(\"tests.jettySsl\");\n    final SslContextFactory sslcontext = new SslContextFactory(false);\n    \n    if (useSsl) {\n      if (null != System.getProperty(\"javax.net.ssl.keyStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.keyStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.keyStorePassword\")) {\n        sslcontext.setKeyStorePassword\n        (System.getProperty(\"javax.net.ssl.keyStorePassword\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.trustStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStorePassword\")) {\n        sslcontext.setTrustStorePassword\n        (System.getProperty(\"javax.net.ssl.trustStorePassword\"));\n      }\n      sslcontext.setNeedClientAuth(Boolean.getBoolean(\"tests.jettySsl.clientAuth\"));\n    }\n    \n    final QueuedThreadPool threadPool = new QueuedThreadPool();\n    threadPool.setDaemon(true);\n    threadPool.setMaxThreads(10000);\n    threadPool.setIdleTimeout(5000);\n    threadPool.setStopTimeout(30000);\n\n    Server server = new Server(threadPool);\n    server.setStopAtShutdown(true);\n    server.manage(threadPool);\n\n\n    final ServerConnector connector;\n    if (useSsl) {\n      HttpConfiguration configuration = new HttpConfiguration();\n      configuration.setSecureScheme(\"https\");\n      configuration.addCustomizer(new SecureRequestCustomizer());\n      ServerConnector c = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n          new HttpConnectionFactory(configuration));\n      connector = c;\n    } else {\n      ServerConnector c = new ServerConnector(server, new HttpConnectionFactory());\n      connector = c;\n    }\n    \n    connector.setPort(0);\n    connector.setHost(\"127.0.0.1\");\n\n    server.setConnectors(new Connector[] {connector});\n    server.setSessionIdManager(new HashSessionIdManager(new Random(random().nextLong())));\n    server.setHandler(handler);\n    \n    server.start();\n    \n    return server;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9","date":1574619880,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/ReplicatorTestCase#newHttpServer(Handler).mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/ReplicatorTestCase#newHttpServer(Handler).mjava","sourceNew":"  /**\n   * Returns a new {@link Server HTTP Server} instance. To obtain its port, use\n   * {@link #serverPort(Server)}.\n   */\n  @SuppressWarnings(\"deprecation\")\n  public static synchronized Server newHttpServer(Handler handler) throws Exception {\n    // if this property is true, then jetty will be configured to use SSL\n    // leveraging the same system properties as java to specify\n    // the keystore/truststore if they are set\n    //\n    // This means we will use the same truststore, keystore (and keys) for\n    // the server as well as any client actions taken by this JVM in\n    // talking to that server, but for the purposes of testing that should \n    // be good enough\n    final boolean useSsl = Boolean.getBoolean(\"tests.jettySsl\");\n    final SslContextFactory sslcontext = new SslContextFactory(false);\n    \n    if (useSsl) {\n      if (null != System.getProperty(\"javax.net.ssl.keyStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.keyStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.keyStorePassword\")) {\n        sslcontext.setKeyStorePassword\n        (System.getProperty(\"javax.net.ssl.keyStorePassword\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.trustStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStorePassword\")) {\n        sslcontext.setTrustStorePassword\n        (System.getProperty(\"javax.net.ssl.trustStorePassword\"));\n      }\n      sslcontext.setNeedClientAuth(Boolean.getBoolean(\"tests.jettySsl.clientAuth\"));\n    }\n    \n    final QueuedThreadPool threadPool = new QueuedThreadPool();\n    threadPool.setDaemon(true);\n    threadPool.setMaxThreads(10000);\n    threadPool.setIdleTimeout(5000);\n    threadPool.setStopTimeout(30000);\n\n    Server server = new Server(threadPool);\n    server.setStopAtShutdown(true);\n    server.manage(threadPool);\n\n\n    final ServerConnector connector;\n    if (useSsl) {\n      HttpConfiguration configuration = new HttpConfiguration();\n      configuration.setSecureScheme(\"https\");\n      configuration.addCustomizer(new SecureRequestCustomizer());\n      ServerConnector c = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n          new HttpConnectionFactory(configuration));\n      connector = c;\n    } else {\n      ServerConnector c = new ServerConnector(server, new HttpConnectionFactory());\n      connector = c;\n    }\n    \n    connector.setPort(0);\n    connector.setHost(\"127.0.0.1\");\n\n    server.setConnectors(new Connector[] {connector});\n    server.setSessionIdManager(new DefaultSessionIdManager(server, new Random(random().nextLong())));\n    server.setHandler(handler);\n    \n    server.start();\n    \n    return server;\n  }\n\n","sourceOld":"  /**\n   * Returns a new {@link Server HTTP Server} instance. To obtain its port, use\n   * {@link #serverPort(Server)}.\n   */\n  public static synchronized Server newHttpServer(Handler handler) throws Exception {\n    // if this property is true, then jetty will be configured to use SSL\n    // leveraging the same system properties as java to specify\n    // the keystore/truststore if they are set\n    //\n    // This means we will use the same truststore, keystore (and keys) for\n    // the server as well as any client actions taken by this JVM in\n    // talking to that server, but for the purposes of testing that should \n    // be good enough\n    final boolean useSsl = Boolean.getBoolean(\"tests.jettySsl\");\n    final SslContextFactory sslcontext = new SslContextFactory(false);\n    \n    if (useSsl) {\n      if (null != System.getProperty(\"javax.net.ssl.keyStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.keyStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.keyStorePassword\")) {\n        sslcontext.setKeyStorePassword\n        (System.getProperty(\"javax.net.ssl.keyStorePassword\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.trustStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStorePassword\")) {\n        sslcontext.setTrustStorePassword\n        (System.getProperty(\"javax.net.ssl.trustStorePassword\"));\n      }\n      sslcontext.setNeedClientAuth(Boolean.getBoolean(\"tests.jettySsl.clientAuth\"));\n    }\n    \n    final QueuedThreadPool threadPool = new QueuedThreadPool();\n    threadPool.setDaemon(true);\n    threadPool.setMaxThreads(10000);\n    threadPool.setIdleTimeout(5000);\n    threadPool.setStopTimeout(30000);\n\n    Server server = new Server(threadPool);\n    server.setStopAtShutdown(true);\n    server.manage(threadPool);\n\n\n    final ServerConnector connector;\n    if (useSsl) {\n      HttpConfiguration configuration = new HttpConfiguration();\n      configuration.setSecureScheme(\"https\");\n      configuration.addCustomizer(new SecureRequestCustomizer());\n      ServerConnector c = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n          new HttpConnectionFactory(configuration));\n      connector = c;\n    } else {\n      ServerConnector c = new ServerConnector(server, new HttpConnectionFactory());\n      connector = c;\n    }\n    \n    connector.setPort(0);\n    connector.setHost(\"127.0.0.1\");\n\n    server.setConnectors(new Connector[] {connector});\n    server.setSessionIdManager(new DefaultSessionIdManager(server, new Random(random().nextLong())));\n    server.setHandler(handler);\n    \n    server.start();\n    \n    return server;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb9c3baacabd473e8ecd6c4948aabacead49b88e","date":1574700980,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/ReplicatorTestCase#newHttpServer(Handler).mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/ReplicatorTestCase#newHttpServer(Handler).mjava","sourceNew":"  /**\n   * Returns a new {@link Server HTTP Server} instance. To obtain its port, use\n   * {@link #serverPort(Server)}.\n   */\n  public static synchronized Server newHttpServer(Handler handler) throws Exception {\n    // if this property is true, then jetty will be configured to use SSL\n    // leveraging the same system properties as java to specify\n    // the keystore/truststore if they are set\n    //\n    // This means we will use the same truststore, keystore (and keys) for\n    // the server as well as any client actions taken by this JVM in\n    // talking to that server, but for the purposes of testing that should \n    // be good enough\n    final boolean useSsl = Boolean.getBoolean(\"tests.jettySsl\");\n    final SslContextFactory sslcontext = new SslContextFactory(false);\n    \n    if (useSsl) {\n      if (null != System.getProperty(\"javax.net.ssl.keyStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.keyStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.keyStorePassword\")) {\n        sslcontext.setKeyStorePassword\n        (System.getProperty(\"javax.net.ssl.keyStorePassword\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.trustStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStorePassword\")) {\n        sslcontext.setTrustStorePassword\n        (System.getProperty(\"javax.net.ssl.trustStorePassword\"));\n      }\n      sslcontext.setNeedClientAuth(Boolean.getBoolean(\"tests.jettySsl.clientAuth\"));\n    }\n    \n    final QueuedThreadPool threadPool = new QueuedThreadPool();\n    threadPool.setDaemon(true);\n    threadPool.setMaxThreads(10000);\n    threadPool.setIdleTimeout(5000);\n    threadPool.setStopTimeout(30000);\n\n    Server server = new Server(threadPool);\n    server.setStopAtShutdown(true);\n    server.manage(threadPool);\n\n\n    final ServerConnector connector;\n    if (useSsl) {\n      HttpConfiguration configuration = new HttpConfiguration();\n      configuration.setSecureScheme(\"https\");\n      configuration.addCustomizer(new SecureRequestCustomizer());\n      ServerConnector c = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n          new HttpConnectionFactory(configuration));\n      connector = c;\n    } else {\n      ServerConnector c = new ServerConnector(server, new HttpConnectionFactory());\n      connector = c;\n    }\n    \n    connector.setPort(0);\n    connector.setHost(\"127.0.0.1\");\n\n    server.setConnectors(new Connector[] {connector});\n    server.setSessionIdManager(new DefaultSessionIdManager(server, new Random(random().nextLong())));\n    server.setHandler(handler);\n    \n    server.start();\n    \n    return server;\n  }\n\n","sourceOld":"  /**\n   * Returns a new {@link Server HTTP Server} instance. To obtain its port, use\n   * {@link #serverPort(Server)}.\n   */\n  @SuppressWarnings(\"deprecation\")\n  public static synchronized Server newHttpServer(Handler handler) throws Exception {\n    // if this property is true, then jetty will be configured to use SSL\n    // leveraging the same system properties as java to specify\n    // the keystore/truststore if they are set\n    //\n    // This means we will use the same truststore, keystore (and keys) for\n    // the server as well as any client actions taken by this JVM in\n    // talking to that server, but for the purposes of testing that should \n    // be good enough\n    final boolean useSsl = Boolean.getBoolean(\"tests.jettySsl\");\n    final SslContextFactory sslcontext = new SslContextFactory(false);\n    \n    if (useSsl) {\n      if (null != System.getProperty(\"javax.net.ssl.keyStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.keyStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.keyStorePassword\")) {\n        sslcontext.setKeyStorePassword\n        (System.getProperty(\"javax.net.ssl.keyStorePassword\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.trustStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStorePassword\")) {\n        sslcontext.setTrustStorePassword\n        (System.getProperty(\"javax.net.ssl.trustStorePassword\"));\n      }\n      sslcontext.setNeedClientAuth(Boolean.getBoolean(\"tests.jettySsl.clientAuth\"));\n    }\n    \n    final QueuedThreadPool threadPool = new QueuedThreadPool();\n    threadPool.setDaemon(true);\n    threadPool.setMaxThreads(10000);\n    threadPool.setIdleTimeout(5000);\n    threadPool.setStopTimeout(30000);\n\n    Server server = new Server(threadPool);\n    server.setStopAtShutdown(true);\n    server.manage(threadPool);\n\n\n    final ServerConnector connector;\n    if (useSsl) {\n      HttpConfiguration configuration = new HttpConfiguration();\n      configuration.setSecureScheme(\"https\");\n      configuration.addCustomizer(new SecureRequestCustomizer());\n      ServerConnector c = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n          new HttpConnectionFactory(configuration));\n      connector = c;\n    } else {\n      ServerConnector c = new ServerConnector(server, new HttpConnectionFactory());\n      connector = c;\n    }\n    \n    connector.setPort(0);\n    connector.setHost(\"127.0.0.1\");\n\n    server.setConnectors(new Connector[] {connector});\n    server.setSessionIdManager(new DefaultSessionIdManager(server, new Random(random().nextLong())));\n    server.setHandler(handler);\n    \n    server.start();\n    \n    return server;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ea0f43f20834b3c8930e074b144aba27a935fee8","date":1576814747,"type":3,"author":"Kevin Risden","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/ReplicatorTestCase#newHttpServer(Handler).mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/ReplicatorTestCase#newHttpServer(Handler).mjava","sourceNew":"  /**\n   * Returns a new {@link Server HTTP Server} instance. To obtain its port, use\n   * {@link #serverPort(Server)}.\n   */\n  public static synchronized Server newHttpServer(Handler handler) throws Exception {\n    // if this property is true, then jetty will be configured to use SSL\n    // leveraging the same system properties as java to specify\n    // the keystore/truststore if they are set\n    //\n    // This means we will use the same truststore, keystore (and keys) for\n    // the server as well as any client actions taken by this JVM in\n    // talking to that server, but for the purposes of testing that should \n    // be good enough\n    final boolean useSsl = Boolean.getBoolean(\"tests.jettySsl\");\n    final SslContextFactory.Server sslcontext = new SslContextFactory.Server();\n    \n    if (useSsl) {\n      if (null != System.getProperty(\"javax.net.ssl.keyStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.keyStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.keyStorePassword\")) {\n        sslcontext.setKeyStorePassword\n        (System.getProperty(\"javax.net.ssl.keyStorePassword\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.trustStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStorePassword\")) {\n        sslcontext.setTrustStorePassword\n        (System.getProperty(\"javax.net.ssl.trustStorePassword\"));\n      }\n      sslcontext.setNeedClientAuth(Boolean.getBoolean(\"tests.jettySsl.clientAuth\"));\n    }\n    \n    final QueuedThreadPool threadPool = new QueuedThreadPool();\n    threadPool.setDaemon(true);\n    threadPool.setMaxThreads(10000);\n    threadPool.setIdleTimeout(5000);\n    threadPool.setStopTimeout(30000);\n\n    Server server = new Server(threadPool);\n    server.setStopAtShutdown(true);\n    server.manage(threadPool);\n\n\n    final ServerConnector connector;\n    if (useSsl) {\n      HttpConfiguration configuration = new HttpConfiguration();\n      configuration.setSecureScheme(\"https\");\n      configuration.addCustomizer(new SecureRequestCustomizer());\n      ServerConnector c = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n          new HttpConnectionFactory(configuration));\n      connector = c;\n    } else {\n      ServerConnector c = new ServerConnector(server, new HttpConnectionFactory());\n      connector = c;\n    }\n    \n    connector.setPort(0);\n    connector.setHost(\"127.0.0.1\");\n\n    server.setConnectors(new Connector[] {connector});\n    server.setSessionIdManager(new DefaultSessionIdManager(server, new Random(random().nextLong())));\n    server.setHandler(handler);\n    \n    server.start();\n    \n    return server;\n  }\n\n","sourceOld":"  /**\n   * Returns a new {@link Server HTTP Server} instance. To obtain its port, use\n   * {@link #serverPort(Server)}.\n   */\n  public static synchronized Server newHttpServer(Handler handler) throws Exception {\n    // if this property is true, then jetty will be configured to use SSL\n    // leveraging the same system properties as java to specify\n    // the keystore/truststore if they are set\n    //\n    // This means we will use the same truststore, keystore (and keys) for\n    // the server as well as any client actions taken by this JVM in\n    // talking to that server, but for the purposes of testing that should \n    // be good enough\n    final boolean useSsl = Boolean.getBoolean(\"tests.jettySsl\");\n    final SslContextFactory sslcontext = new SslContextFactory(false);\n    \n    if (useSsl) {\n      if (null != System.getProperty(\"javax.net.ssl.keyStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.keyStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.keyStorePassword\")) {\n        sslcontext.setKeyStorePassword\n        (System.getProperty(\"javax.net.ssl.keyStorePassword\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.trustStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStorePassword\")) {\n        sslcontext.setTrustStorePassword\n        (System.getProperty(\"javax.net.ssl.trustStorePassword\"));\n      }\n      sslcontext.setNeedClientAuth(Boolean.getBoolean(\"tests.jettySsl.clientAuth\"));\n    }\n    \n    final QueuedThreadPool threadPool = new QueuedThreadPool();\n    threadPool.setDaemon(true);\n    threadPool.setMaxThreads(10000);\n    threadPool.setIdleTimeout(5000);\n    threadPool.setStopTimeout(30000);\n\n    Server server = new Server(threadPool);\n    server.setStopAtShutdown(true);\n    server.manage(threadPool);\n\n\n    final ServerConnector connector;\n    if (useSsl) {\n      HttpConfiguration configuration = new HttpConfiguration();\n      configuration.setSecureScheme(\"https\");\n      configuration.addCustomizer(new SecureRequestCustomizer());\n      ServerConnector c = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n          new HttpConnectionFactory(configuration));\n      connector = c;\n    } else {\n      ServerConnector c = new ServerConnector(server, new HttpConnectionFactory());\n      connector = c;\n    }\n    \n    connector.setPort(0);\n    connector.setHost(\"127.0.0.1\");\n\n    server.setConnectors(new Connector[] {connector});\n    server.setSessionIdManager(new DefaultSessionIdManager(server, new Random(random().nextLong())));\n    server.setHandler(handler);\n    \n    server.start();\n    \n    return server;\n  }\n\n","bugFix":["49d13f9fe20e8eb6f81d320982b6f5937de74d92"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c66470e527299cc148ad0b3441d08dfb7cb9e03","date":1576859740,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/ReplicatorTestCase#newHttpServer(Handler).mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/ReplicatorTestCase#newHttpServer(Handler).mjava","sourceNew":"  /**\n   * Returns a new {@link Server HTTP Server} instance. To obtain its port, use\n   * {@link #serverPort(Server)}.\n   */\n  public static synchronized Server newHttpServer(Handler handler) throws Exception {\n    // if this property is true, then jetty will be configured to use SSL\n    // leveraging the same system properties as java to specify\n    // the keystore/truststore if they are set\n    //\n    // This means we will use the same truststore, keystore (and keys) for\n    // the server as well as any client actions taken by this JVM in\n    // talking to that server, but for the purposes of testing that should \n    // be good enough\n    final boolean useSsl = Boolean.getBoolean(\"tests.jettySsl\");\n    final SslContextFactory.Server sslcontext = new SslContextFactory.Server();\n    \n    if (useSsl) {\n      if (null != System.getProperty(\"javax.net.ssl.keyStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.keyStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.keyStorePassword\")) {\n        sslcontext.setKeyStorePassword\n        (System.getProperty(\"javax.net.ssl.keyStorePassword\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.trustStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStorePassword\")) {\n        sslcontext.setTrustStorePassword\n        (System.getProperty(\"javax.net.ssl.trustStorePassword\"));\n      }\n      sslcontext.setNeedClientAuth(Boolean.getBoolean(\"tests.jettySsl.clientAuth\"));\n    }\n    \n    final QueuedThreadPool threadPool = new QueuedThreadPool();\n    threadPool.setDaemon(true);\n    threadPool.setMaxThreads(10000);\n    threadPool.setIdleTimeout(5000);\n    threadPool.setStopTimeout(30000);\n\n    Server server = new Server(threadPool);\n    server.setStopAtShutdown(true);\n    server.manage(threadPool);\n\n\n    final ServerConnector connector;\n    if (useSsl) {\n      HttpConfiguration configuration = new HttpConfiguration();\n      configuration.setSecureScheme(\"https\");\n      configuration.addCustomizer(new SecureRequestCustomizer());\n      ServerConnector c = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n          new HttpConnectionFactory(configuration));\n      connector = c;\n    } else {\n      ServerConnector c = new ServerConnector(server, new HttpConnectionFactory());\n      connector = c;\n    }\n    \n    connector.setPort(0);\n    connector.setHost(\"127.0.0.1\");\n\n    server.setConnectors(new Connector[] {connector});\n    server.setSessionIdManager(new DefaultSessionIdManager(server, new Random(random().nextLong())));\n    server.setHandler(handler);\n    \n    server.start();\n    \n    return server;\n  }\n\n","sourceOld":"  /**\n   * Returns a new {@link Server HTTP Server} instance. To obtain its port, use\n   * {@link #serverPort(Server)}.\n   */\n  public static synchronized Server newHttpServer(Handler handler) throws Exception {\n    // if this property is true, then jetty will be configured to use SSL\n    // leveraging the same system properties as java to specify\n    // the keystore/truststore if they are set\n    //\n    // This means we will use the same truststore, keystore (and keys) for\n    // the server as well as any client actions taken by this JVM in\n    // talking to that server, but for the purposes of testing that should \n    // be good enough\n    final boolean useSsl = Boolean.getBoolean(\"tests.jettySsl\");\n    final SslContextFactory sslcontext = new SslContextFactory(false);\n    \n    if (useSsl) {\n      if (null != System.getProperty(\"javax.net.ssl.keyStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.keyStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.keyStorePassword\")) {\n        sslcontext.setKeyStorePassword\n        (System.getProperty(\"javax.net.ssl.keyStorePassword\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.trustStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStorePassword\")) {\n        sslcontext.setTrustStorePassword\n        (System.getProperty(\"javax.net.ssl.trustStorePassword\"));\n      }\n      sslcontext.setNeedClientAuth(Boolean.getBoolean(\"tests.jettySsl.clientAuth\"));\n    }\n    \n    final QueuedThreadPool threadPool = new QueuedThreadPool();\n    threadPool.setDaemon(true);\n    threadPool.setMaxThreads(10000);\n    threadPool.setIdleTimeout(5000);\n    threadPool.setStopTimeout(30000);\n\n    Server server = new Server(threadPool);\n    server.setStopAtShutdown(true);\n    server.manage(threadPool);\n\n\n    final ServerConnector connector;\n    if (useSsl) {\n      HttpConfiguration configuration = new HttpConfiguration();\n      configuration.setSecureScheme(\"https\");\n      configuration.addCustomizer(new SecureRequestCustomizer());\n      ServerConnector c = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n          new HttpConnectionFactory(configuration));\n      connector = c;\n    } else {\n      ServerConnector c = new ServerConnector(server, new HttpConnectionFactory());\n      connector = c;\n    }\n    \n    connector.setPort(0);\n    connector.setHost(\"127.0.0.1\");\n\n    server.setConnectors(new Connector[] {connector});\n    server.setSessionIdManager(new DefaultSessionIdManager(server, new Random(random().nextLong())));\n    server.setHandler(handler);\n    \n    server.start();\n    \n    return server;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dede24fb16615594e9570fb29829cbffa1315a1f","date":1589579471,"type":3,"author":"erick","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/ReplicatorTestCase#newHttpServer(Handler).mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/ReplicatorTestCase#newHttpServer(Handler).mjava","sourceNew":"  /**\n   * Returns a new {@link Server HTTP Server} instance. To obtain its port, use\n   * {@link #serverPort(Server)}.\n   */\n  public static synchronized Server newHttpServer(Handler handler) throws Exception {\n    // if this property is true, then jetty will be configured to use SSL\n    // leveraging the same system properties as java to specify\n    // the keystore/truststore if they are set\n    //\n    // This means we will use the same truststore, keystore (and keys) for\n    // the server as well as any client actions taken by this JVM in\n    // talking to that server, but for the purposes of testing that should \n    // be good enough\n    final boolean useSsl = Boolean.getBoolean(\"tests.jettySsl\");\n    final SslContextFactory.Server sslcontext = new SslContextFactory.Server();\n    \n    if (useSsl) {\n      if (null != System.getProperty(\"javax.net.ssl.keyStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.keyStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.keyStorePassword\")) {\n        sslcontext.setKeyStorePassword\n        (System.getProperty(\"javax.net.ssl.keyStorePassword\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.trustStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStorePassword\")) {\n        sslcontext.setTrustStorePassword\n        (System.getProperty(\"javax.net.ssl.trustStorePassword\"));\n      }\n      sslcontext.setNeedClientAuth(Boolean.getBoolean(\"tests.jettySsl.clientAuth\"));\n    }\n    \n    final QueuedThreadPool threadPool = new QueuedThreadPool();\n    threadPool.setDaemon(true);\n    threadPool.setMaxThreads(10000);\n    threadPool.setIdleTimeout(5000);\n    threadPool.setStopTimeout(30000);\n\n    Server server = new Server(threadPool);\n    server.setStopAtShutdown(true);\n    server.manage(threadPool);\n\n\n    final ServerConnector connector;\n    if (useSsl) {\n      HttpConfiguration configuration = new HttpConfiguration();\n      configuration.setSecureScheme(\"https\");\n      configuration.addCustomizer(new SecureRequestCustomizer());\n      @SuppressWarnings(\"resource\")\n      ServerConnector c = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n          new HttpConnectionFactory(configuration));\n      connector = c;\n    } else {\n      @SuppressWarnings(\"resource\")\n      ServerConnector c = new ServerConnector(server, new HttpConnectionFactory());\n      connector = c;\n    }\n    \n    connector.setPort(0);\n    connector.setHost(\"127.0.0.1\");\n\n    server.setConnectors(new Connector[] {connector});\n    server.setSessionIdManager(new DefaultSessionIdManager(server, new Random(random().nextLong())));\n    server.setHandler(handler);\n    \n    server.start();\n    \n    return server;\n  }\n\n","sourceOld":"  /**\n   * Returns a new {@link Server HTTP Server} instance. To obtain its port, use\n   * {@link #serverPort(Server)}.\n   */\n  public static synchronized Server newHttpServer(Handler handler) throws Exception {\n    // if this property is true, then jetty will be configured to use SSL\n    // leveraging the same system properties as java to specify\n    // the keystore/truststore if they are set\n    //\n    // This means we will use the same truststore, keystore (and keys) for\n    // the server as well as any client actions taken by this JVM in\n    // talking to that server, but for the purposes of testing that should \n    // be good enough\n    final boolean useSsl = Boolean.getBoolean(\"tests.jettySsl\");\n    final SslContextFactory.Server sslcontext = new SslContextFactory.Server();\n    \n    if (useSsl) {\n      if (null != System.getProperty(\"javax.net.ssl.keyStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.keyStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.keyStorePassword\")) {\n        sslcontext.setKeyStorePassword\n        (System.getProperty(\"javax.net.ssl.keyStorePassword\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStore\")) {\n        sslcontext.setKeyStorePath\n        (System.getProperty(\"javax.net.ssl.trustStore\"));\n      }\n      if (null != System.getProperty(\"javax.net.ssl.trustStorePassword\")) {\n        sslcontext.setTrustStorePassword\n        (System.getProperty(\"javax.net.ssl.trustStorePassword\"));\n      }\n      sslcontext.setNeedClientAuth(Boolean.getBoolean(\"tests.jettySsl.clientAuth\"));\n    }\n    \n    final QueuedThreadPool threadPool = new QueuedThreadPool();\n    threadPool.setDaemon(true);\n    threadPool.setMaxThreads(10000);\n    threadPool.setIdleTimeout(5000);\n    threadPool.setStopTimeout(30000);\n\n    Server server = new Server(threadPool);\n    server.setStopAtShutdown(true);\n    server.manage(threadPool);\n\n\n    final ServerConnector connector;\n    if (useSsl) {\n      HttpConfiguration configuration = new HttpConfiguration();\n      configuration.setSecureScheme(\"https\");\n      configuration.addCustomizer(new SecureRequestCustomizer());\n      ServerConnector c = new ServerConnector(server, new SslConnectionFactory(sslcontext, \"http/1.1\"),\n          new HttpConnectionFactory(configuration));\n      connector = c;\n    } else {\n      ServerConnector c = new ServerConnector(server, new HttpConnectionFactory());\n      connector = c;\n    }\n    \n    connector.setPort(0);\n    connector.setHost(\"127.0.0.1\");\n\n    server.setConnectors(new Connector[] {connector});\n    server.setSessionIdManager(new DefaultSessionIdManager(server, new Random(random().nextLong())));\n    server.setHandler(handler);\n    \n    server.start();\n    \n    return server;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"49d13f9fe20e8eb6f81d320982b6f5937de74d92":["6fd7690db7212b99d407b3bde0b0813541923082"],"b94236357aaa22b76c10629851fe4e376e0cea82":["d5b778829b5b506ab02023b2f4ba58aef5d7f0fd","269c5aee1e7702d512e3f45bf1f01afd15a2af5f"],"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9":["b94236357aaa22b76c10629851fe4e376e0cea82"],"ea0f43f20834b3c8930e074b144aba27a935fee8":["bb9c3baacabd473e8ecd6c4948aabacead49b88e"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["6165e61f495a24c345d4faefc766b7366b4c9089"],"4c66470e527299cc148ad0b3441d08dfb7cb9e03":["bb9c3baacabd473e8ecd6c4948aabacead49b88e","ea0f43f20834b3c8930e074b144aba27a935fee8"],"dede24fb16615594e9570fb29829cbffa1315a1f":["ea0f43f20834b3c8930e074b144aba27a935fee8"],"d5b778829b5b506ab02023b2f4ba58aef5d7f0fd":["19275ba31e621f6da1b83bf13af75233876fd3d4"],"6165e61f495a24c345d4faefc766b7366b4c9089":["49d13f9fe20e8eb6f81d320982b6f5937de74d92"],"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"269c5aee1e7702d512e3f45bf1f01afd15a2af5f":["d5b778829b5b506ab02023b2f4ba58aef5d7f0fd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bb9c3baacabd473e8ecd6c4948aabacead49b88e":["a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["6165e61f495a24c345d4faefc766b7366b4c9089"],"6fd7690db7212b99d407b3bde0b0813541923082":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["dede24fb16615594e9570fb29829cbffa1315a1f"]},"commit2Childs":{"49d13f9fe20e8eb6f81d320982b6f5937de74d92":["6165e61f495a24c345d4faefc766b7366b4c9089"],"b94236357aaa22b76c10629851fe4e376e0cea82":["a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9"],"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9":["bb9c3baacabd473e8ecd6c4948aabacead49b88e"],"ea0f43f20834b3c8930e074b144aba27a935fee8":["4c66470e527299cc148ad0b3441d08dfb7cb9e03","dede24fb16615594e9570fb29829cbffa1315a1f"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["d5b778829b5b506ab02023b2f4ba58aef5d7f0fd"],"4c66470e527299cc148ad0b3441d08dfb7cb9e03":[],"dede24fb16615594e9570fb29829cbffa1315a1f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d5b778829b5b506ab02023b2f4ba58aef5d7f0fd":["b94236357aaa22b76c10629851fe4e376e0cea82","269c5aee1e7702d512e3f45bf1f01afd15a2af5f"],"6165e61f495a24c345d4faefc766b7366b4c9089":["19275ba31e621f6da1b83bf13af75233876fd3d4","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee"],"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4":["6fd7690db7212b99d407b3bde0b0813541923082"],"269c5aee1e7702d512e3f45bf1f01afd15a2af5f":["b94236357aaa22b76c10629851fe4e376e0cea82"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"bb9c3baacabd473e8ecd6c4948aabacead49b88e":["ea0f43f20834b3c8930e074b144aba27a935fee8","4c66470e527299cc148ad0b3441d08dfb7cb9e03"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"6fd7690db7212b99d407b3bde0b0813541923082":["49d13f9fe20e8eb6f81d320982b6f5937de74d92"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4c66470e527299cc148ad0b3441d08dfb7cb9e03","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}