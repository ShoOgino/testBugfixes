{"path":"src/java/org/apache/solr/request/StandardRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","commits":[{"id":"0c3e228bf650e96f3002a8fb73dd0c13d55af077","date":1138253849,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/request/StandardRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"/dev/null","sourceNew":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n\n\n    // TODO: test if lucene will accept an escaped ';', otherwise\n    // we need to un-escape them before we pass to QueryParser\n    try {\n      String sreq = req.getQueryString();\n      String debug = req.getParam(\"debugQuery\");\n\n      // find fieldnames to return (fieldlist)\n      String fl = req.getParam(\"fl\");\n      int flags=0;\n      if (fl != null) {\n        // TODO - this could become more efficient if widely used.\n        // TODO - should field order be maintained?\n        String[] flst = splitList.split(fl,0);\n        if (flst.length > 0 && !(flst.length==1 && flst[0].length()==0)) {\n          Set<String> set = new HashSet<String>();\n          for (String fname : flst) {\n            if (\"score\".equals(fname)) flags |= SolrIndexSearcher.GET_SCORES;\n            set.add(fname);\n          }\n          rsp.setReturnFields(set);\n        }\n      }\n\n      if (sreq==null) throw new SolrException(400,\"Missing queryString\");\n      List<String> commands = StrUtils.splitSmart(sreq,';');\n\n      String qs = commands.size() >= 1 ? commands.get(0) : \"\";\n      Query query = QueryParsing.parseQuery(qs, req.getSchema());\n\n      // If the first non-query, non-filter command is a simple sort on an indexed field, then\n      // we can use the Lucene sort ability.\n      Sort sort = null;\n      if (commands.size() >= 2) {\n        QueryParsing.SortSpec sortSpec = QueryParsing.parseSort(commands.get(1), req.getSchema());\n        if (sortSpec != null) {\n          sort = sortSpec.getSort();\n          // ignore the count for now... it's currently only controlled by start & limit on req\n          // count = sortSpec.getCount();\n        }\n      }\n\n      DocList results = req.getSearcher().getDocList(query, null, sort, req.getStart(), req.getLimit(), flags);\n      rsp.add(null,results);\n\n      if (debug!=null) {\n        NamedList dbg = new NamedList();\n        try {\n          dbg.add(\"querystring\",qs);\n          dbg.add(\"parsedquery\",QueryParsing.toString(query,req.getSchema()));\n          dbg.add(\"explain\", getExplainList(query, results, req.getSearcher(), req.getSchema()));\n          String otherQueryS = req.getParam(\"explainOther\");\n          if (otherQueryS != null && otherQueryS.length() > 0) {\n            DocList otherResults = doQuery(otherQueryS,req.getSearcher(), req.getSchema(),0,10);\n            dbg.add(\"otherQuery\",otherQueryS);\n            dbg.add(\"explainOther\", getExplainList(query, otherResults, req.getSearcher(), req.getSchema()));\n          }\n        } catch (Exception e) {\n          SolrException.logOnce(SolrCore.log,\"Exception during debug:\",e);\n          dbg.add(\"exception_during_debug\", SolrException.toStr(e));\n        }\n        rsp.add(\"debug\",dbg);\n      }\n\n    } catch (SolrException e) {\n      rsp.setException(e);\n      numErrors++;\n      return;\n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n      return;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9d6e41db27d65fefe44a81b13acf5a5097a166b","date":1144591501,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/java/org/apache/solr/request/StandardRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/request/StandardRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n\n\n    // TODO: test if lucene will accept an escaped ';', otherwise\n    // we need to un-escape them before we pass to QueryParser\n    try {\n      String sreq = req.getQueryString();\n      String debug = req.getParam(\"debugQuery\");\n      String defaultField = req.getParam(\"df\");\n\n      // find fieldnames to return (fieldlist)\n      String fl = req.getParam(\"fl\");\n      int flags=0;\n      if (fl != null) {\n        // TODO - this could become more efficient if widely used.\n        // TODO - should field order be maintained?\n        String[] flst = splitList.split(fl,0);\n        if (flst.length > 0 && !(flst.length==1 && flst[0].length()==0)) {\n          Set<String> set = new HashSet<String>();\n          for (String fname : flst) {\n            if (\"score\".equals(fname)) flags |= SolrIndexSearcher.GET_SCORES;\n            set.add(fname);\n          }\n          rsp.setReturnFields(set);\n        }\n      }\n\n      if (sreq==null) throw new SolrException(400,\"Missing queryString\");\n      List<String> commands = StrUtils.splitSmart(sreq,';');\n\n      String qs = commands.size() >= 1 ? commands.get(0) : \"\";\n      Query query = QueryParsing.parseQuery(qs, defaultField, req.getSchema());\n\n      // If the first non-query, non-filter command is a simple sort on an indexed field, then\n      // we can use the Lucene sort ability.\n      Sort sort = null;\n      if (commands.size() >= 2) {\n        QueryParsing.SortSpec sortSpec = QueryParsing.parseSort(commands.get(1), req.getSchema());\n        if (sortSpec != null) {\n          sort = sortSpec.getSort();\n          // ignore the count for now... it's currently only controlled by start & limit on req\n          // count = sortSpec.getCount();\n        }\n      }\n\n      DocList results = req.getSearcher().getDocList(query, null, sort, req.getStart(), req.getLimit(), flags);\n      rsp.add(null,results);\n\n      if (debug!=null) {\n        NamedList dbg = new NamedList();\n        try {\n          dbg.add(\"querystring\",qs);\n          dbg.add(\"parsedquery\",QueryParsing.toString(query,req.getSchema()));\n          dbg.add(\"explain\", getExplainList(query, results, req.getSearcher(), req.getSchema()));\n          String otherQueryS = req.getParam(\"explainOther\");\n          if (otherQueryS != null && otherQueryS.length() > 0) {\n            DocList otherResults = doQuery(otherQueryS,req.getSearcher(), req.getSchema(),0,10);\n            dbg.add(\"otherQuery\",otherQueryS);\n            dbg.add(\"explainOther\", getExplainList(query, otherResults, req.getSearcher(), req.getSchema()));\n          }\n        } catch (Exception e) {\n          SolrException.logOnce(SolrCore.log,\"Exception during debug:\",e);\n          dbg.add(\"exception_during_debug\", SolrException.toStr(e));\n        }\n        rsp.add(\"debug\",dbg);\n      }\n\n    } catch (SolrException e) {\n      rsp.setException(e);\n      numErrors++;\n      return;\n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n      return;\n    }\n  }\n\n","sourceOld":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n\n\n    // TODO: test if lucene will accept an escaped ';', otherwise\n    // we need to un-escape them before we pass to QueryParser\n    try {\n      String sreq = req.getQueryString();\n      String debug = req.getParam(\"debugQuery\");\n\n      // find fieldnames to return (fieldlist)\n      String fl = req.getParam(\"fl\");\n      int flags=0;\n      if (fl != null) {\n        // TODO - this could become more efficient if widely used.\n        // TODO - should field order be maintained?\n        String[] flst = splitList.split(fl,0);\n        if (flst.length > 0 && !(flst.length==1 && flst[0].length()==0)) {\n          Set<String> set = new HashSet<String>();\n          for (String fname : flst) {\n            if (\"score\".equals(fname)) flags |= SolrIndexSearcher.GET_SCORES;\n            set.add(fname);\n          }\n          rsp.setReturnFields(set);\n        }\n      }\n\n      if (sreq==null) throw new SolrException(400,\"Missing queryString\");\n      List<String> commands = StrUtils.splitSmart(sreq,';');\n\n      String qs = commands.size() >= 1 ? commands.get(0) : \"\";\n      Query query = QueryParsing.parseQuery(qs, req.getSchema());\n\n      // If the first non-query, non-filter command is a simple sort on an indexed field, then\n      // we can use the Lucene sort ability.\n      Sort sort = null;\n      if (commands.size() >= 2) {\n        QueryParsing.SortSpec sortSpec = QueryParsing.parseSort(commands.get(1), req.getSchema());\n        if (sortSpec != null) {\n          sort = sortSpec.getSort();\n          // ignore the count for now... it's currently only controlled by start & limit on req\n          // count = sortSpec.getCount();\n        }\n      }\n\n      DocList results = req.getSearcher().getDocList(query, null, sort, req.getStart(), req.getLimit(), flags);\n      rsp.add(null,results);\n\n      if (debug!=null) {\n        NamedList dbg = new NamedList();\n        try {\n          dbg.add(\"querystring\",qs);\n          dbg.add(\"parsedquery\",QueryParsing.toString(query,req.getSchema()));\n          dbg.add(\"explain\", getExplainList(query, results, req.getSearcher(), req.getSchema()));\n          String otherQueryS = req.getParam(\"explainOther\");\n          if (otherQueryS != null && otherQueryS.length() > 0) {\n            DocList otherResults = doQuery(otherQueryS,req.getSearcher(), req.getSchema(),0,10);\n            dbg.add(\"otherQuery\",otherQueryS);\n            dbg.add(\"explainOther\", getExplainList(query, otherResults, req.getSearcher(), req.getSchema()));\n          }\n        } catch (Exception e) {\n          SolrException.logOnce(SolrCore.log,\"Exception during debug:\",e);\n          dbg.add(\"exception_during_debug\", SolrException.toStr(e));\n        }\n        rsp.add(\"debug\",dbg);\n      }\n\n    } catch (SolrException e) {\n      rsp.setException(e);\n      numErrors++;\n      return;\n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n      return;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0452863ee588101738d341e6e97eb87eb010052a","date":1152814944,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/request/StandardRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/request/StandardRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n\n\n    // TODO: test if lucene will accept an escaped ';', otherwise\n    // we need to un-escape them before we pass to QueryParser\n    try {\n      String sreq = req.getQueryString();\n      String debug = U.getParam(req, params.DEBUG_QUERY, params.debugQuery);\n      String defaultField = U.getParam(req, params.DF, params.df);\n\n      // find fieldnames to return (fieldlist)\n      String fl = U.getParam(req, params.FL, params.fl);\n      int flags = 0; \n      if (fl != null) {\n        flags |= U.setReturnFields(fl, rsp);\n      }\n\n      if (sreq==null) throw new SolrException(400,\"Missing queryString\");\n      List<String> commands = StrUtils.splitSmart(sreq,';');\n\n      String qs = commands.size() >= 1 ? commands.get(0) : \"\";\n      Query query = QueryParsing.parseQuery(qs, defaultField, req.getSchema());\n\n      // If the first non-query, non-filter command is a simple sort on an indexed field, then\n      // we can use the Lucene sort ability.\n      Sort sort = null;\n      if (commands.size() >= 2) {\n        QueryParsing.SortSpec sortSpec = QueryParsing.parseSort(commands.get(1), req.getSchema());\n        if (sortSpec != null) {\n          sort = sortSpec.getSort();\n          // ignore the count for now... it's currently only controlled by start & limit on req\n          // count = sortSpec.getCount();\n        }\n      }\n\n      DocList results = req.getSearcher().getDocList(query, null, sort, req.getStart(), req.getLimit(), flags);\n      rsp.add(null,results);\n\n      try {\n        NamedList dbg = U.doStandardDebug(req, qs, query, results, params);\n        if (null != dbg) \n          rsp.add(\"debug\", dbg);\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log, \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      NamedList sumData = SolrPluginUtils.doStandardHighlighting(\n        results, query, req, params, new String[]{defaultField});\n      if(sumData != null)\n        rsp.add(\"highlighting\", sumData);\n\n    } catch (SolrException e) {\n      rsp.setException(e);\n      numErrors++;\n      return;\n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n      return;\n    }\n  }\n\n","sourceOld":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n\n\n    // TODO: test if lucene will accept an escaped ';', otherwise\n    // we need to un-escape them before we pass to QueryParser\n    try {\n      String sreq = req.getQueryString();\n      String debug = req.getParam(\"debugQuery\");\n      String defaultField = req.getParam(\"df\");\n\n      // find fieldnames to return (fieldlist)\n      String fl = req.getParam(\"fl\");\n      int flags=0;\n      if (fl != null) {\n        // TODO - this could become more efficient if widely used.\n        // TODO - should field order be maintained?\n        String[] flst = splitList.split(fl,0);\n        if (flst.length > 0 && !(flst.length==1 && flst[0].length()==0)) {\n          Set<String> set = new HashSet<String>();\n          for (String fname : flst) {\n            if (\"score\".equals(fname)) flags |= SolrIndexSearcher.GET_SCORES;\n            set.add(fname);\n          }\n          rsp.setReturnFields(set);\n        }\n      }\n\n      if (sreq==null) throw new SolrException(400,\"Missing queryString\");\n      List<String> commands = StrUtils.splitSmart(sreq,';');\n\n      String qs = commands.size() >= 1 ? commands.get(0) : \"\";\n      Query query = QueryParsing.parseQuery(qs, defaultField, req.getSchema());\n\n      // If the first non-query, non-filter command is a simple sort on an indexed field, then\n      // we can use the Lucene sort ability.\n      Sort sort = null;\n      if (commands.size() >= 2) {\n        QueryParsing.SortSpec sortSpec = QueryParsing.parseSort(commands.get(1), req.getSchema());\n        if (sortSpec != null) {\n          sort = sortSpec.getSort();\n          // ignore the count for now... it's currently only controlled by start & limit on req\n          // count = sortSpec.getCount();\n        }\n      }\n\n      DocList results = req.getSearcher().getDocList(query, null, sort, req.getStart(), req.getLimit(), flags);\n      rsp.add(null,results);\n\n      if (debug!=null) {\n        NamedList dbg = new NamedList();\n        try {\n          dbg.add(\"querystring\",qs);\n          dbg.add(\"parsedquery\",QueryParsing.toString(query,req.getSchema()));\n          dbg.add(\"explain\", getExplainList(query, results, req.getSearcher(), req.getSchema()));\n          String otherQueryS = req.getParam(\"explainOther\");\n          if (otherQueryS != null && otherQueryS.length() > 0) {\n            DocList otherResults = doQuery(otherQueryS,req.getSearcher(), req.getSchema(),0,10);\n            dbg.add(\"otherQuery\",otherQueryS);\n            dbg.add(\"explainOther\", getExplainList(query, otherResults, req.getSearcher(), req.getSchema()));\n          }\n        } catch (Exception e) {\n          SolrException.logOnce(SolrCore.log,\"Exception during debug:\",e);\n          dbg.add(\"exception_during_debug\", SolrException.toStr(e));\n        }\n        rsp.add(\"debug\",dbg);\n      }\n\n    } catch (SolrException e) {\n      rsp.setException(e);\n      numErrors++;\n      return;\n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n      return;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d392d28bebeb57a7089ba3c9e8331920f7ab643a","date":1155927064,"type":3,"author":"Mike Klaas","isMerge":false,"pathNew":"src/java/org/apache/solr/request/StandardRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/request/StandardRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n\n    // TODO: test if lucene will accept an escaped ';', otherwise\n    // we need to un-escape them before we pass to QueryParser\n    try {\n      String sreq = req.getQueryString();\n      String debug = U.getParam(req, params.DEBUG_QUERY, params.debugQuery);\n      String defaultField = U.getParam(req, params.DF, params.df);\n\n      // find fieldnames to return (fieldlist)\n      String fl = U.getParam(req, params.FL, params.fl);\n      int flags = 0; \n      if (fl != null) {\n        flags |= U.setReturnFields(fl, rsp);\n      }\n\n      if (sreq==null) throw new SolrException(400,\"Missing queryString\");\n      List<String> commands = StrUtils.splitSmart(sreq,';');\n\n      String qs = commands.size() >= 1 ? commands.get(0) : \"\";\n      Query query = QueryParsing.parseQuery(qs, defaultField, req.getSchema());\n\n      // If the first non-query, non-filter command is a simple sort on an indexed field, then\n      // we can use the Lucene sort ability.\n      Sort sort = null;\n      if (commands.size() >= 2) {\n        QueryParsing.SortSpec sortSpec = QueryParsing.parseSort(commands.get(1), req.getSchema());\n        if (sortSpec != null) {\n          sort = sortSpec.getSort();\n          // ignore the count for now... it's currently only controlled by start & limit on req\n          // count = sortSpec.getCount();\n        }\n      }\n\n      DocList results = req.getSearcher().getDocList(query, null, sort, req.getStart(), req.getLimit(), flags);\n      rsp.add(null,results);\n\n      try {\n        NamedList dbg = U.doStandardDebug(req, qs, query, results, params);\n        if (null != dbg) \n          rsp.add(\"debug\", dbg);\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log, \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      NamedList sumData = SolrPluginUtils.doStandardHighlighting(\n        results, query, req, params, new String[]{defaultField});\n      if(sumData != null)\n        rsp.add(\"highlighting\", sumData);\n\n    } catch (SolrException e) {\n      rsp.setException(e);\n      numErrors++;\n      return;\n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n      return;\n    }\n  }\n\n","sourceOld":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n\n\n    // TODO: test if lucene will accept an escaped ';', otherwise\n    // we need to un-escape them before we pass to QueryParser\n    try {\n      String sreq = req.getQueryString();\n      String debug = U.getParam(req, params.DEBUG_QUERY, params.debugQuery);\n      String defaultField = U.getParam(req, params.DF, params.df);\n\n      // find fieldnames to return (fieldlist)\n      String fl = U.getParam(req, params.FL, params.fl);\n      int flags = 0; \n      if (fl != null) {\n        flags |= U.setReturnFields(fl, rsp);\n      }\n\n      if (sreq==null) throw new SolrException(400,\"Missing queryString\");\n      List<String> commands = StrUtils.splitSmart(sreq,';');\n\n      String qs = commands.size() >= 1 ? commands.get(0) : \"\";\n      Query query = QueryParsing.parseQuery(qs, defaultField, req.getSchema());\n\n      // If the first non-query, non-filter command is a simple sort on an indexed field, then\n      // we can use the Lucene sort ability.\n      Sort sort = null;\n      if (commands.size() >= 2) {\n        QueryParsing.SortSpec sortSpec = QueryParsing.parseSort(commands.get(1), req.getSchema());\n        if (sortSpec != null) {\n          sort = sortSpec.getSort();\n          // ignore the count for now... it's currently only controlled by start & limit on req\n          // count = sortSpec.getCount();\n        }\n      }\n\n      DocList results = req.getSearcher().getDocList(query, null, sort, req.getStart(), req.getLimit(), flags);\n      rsp.add(null,results);\n\n      try {\n        NamedList dbg = U.doStandardDebug(req, qs, query, results, params);\n        if (null != dbg) \n          rsp.add(\"debug\", dbg);\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log, \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      NamedList sumData = SolrPluginUtils.doStandardHighlighting(\n        results, query, req, params, new String[]{defaultField});\n      if(sumData != null)\n        rsp.add(\"highlighting\", sumData);\n\n    } catch (SolrException e) {\n      rsp.setException(e);\n      numErrors++;\n      return;\n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n      return;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"44f497c313977be641ddf24aab74b30e6de834d8","date":1156361697,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/request/StandardRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/request/StandardRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n\n    try {\n      U.setDefaults(req,defaults);\n      SolrParams p = req.getParams();\n      String sreq = p.get(Q);\n\n      String defaultField = p.get(DF);\n\n      // find fieldnames to return (fieldlist)\n      String fl = p.get(SolrParams.FL);\n      int flags = 0; \n      if (fl != null) {\n        flags |= U.setReturnFields(fl, rsp);\n      }\n\n      if (sreq==null) throw new SolrException(400,\"Missing queryString\");\n      List<String> commands = StrUtils.splitSmart(sreq,';');\n\n      String qs = commands.size() >= 1 ? commands.get(0) : \"\";\n      Query query = QueryParsing.parseQuery(qs, defaultField, req.getSchema());\n\n      // If the first non-query, non-filter command is a simple sort on an indexed field, then\n      // we can use the Lucene sort ability.\n      Sort sort = null;\n      if (commands.size() >= 2) {\n        QueryParsing.SortSpec sortSpec = QueryParsing.parseSort(commands.get(1), req.getSchema());\n        if (sortSpec != null) {\n          sort = sortSpec.getSort();\n          // ignore the count for now... it's currently only controlled by start & limit on req\n          // count = sortSpec.getCount();\n        }\n      }\n\n      DocList results = req.getSearcher().getDocList(query, null, sort, p.getInt(START,0), p.getInt(ROWS,10), flags);\n      rsp.add(null,results);\n\n      try {\n        NamedList dbg = U.doStandardDebug(req, qs, query, results);\n        if (null != dbg) \n          rsp.add(\"debug\", dbg);\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log, \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      NamedList sumData = SolrPluginUtils.doStandardHighlighting(\n        results, query, req, new String[]{defaultField});\n      if(sumData != null)\n        rsp.add(\"highlighting\", sumData);\n\n    } catch (SolrException e) {\n      rsp.setException(e);\n      numErrors++;\n      return;\n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n      return;\n    }\n  }\n\n","sourceOld":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n\n    // TODO: test if lucene will accept an escaped ';', otherwise\n    // we need to un-escape them before we pass to QueryParser\n    try {\n      String sreq = req.getQueryString();\n      String debug = U.getParam(req, params.DEBUG_QUERY, params.debugQuery);\n      String defaultField = U.getParam(req, params.DF, params.df);\n\n      // find fieldnames to return (fieldlist)\n      String fl = U.getParam(req, params.FL, params.fl);\n      int flags = 0; \n      if (fl != null) {\n        flags |= U.setReturnFields(fl, rsp);\n      }\n\n      if (sreq==null) throw new SolrException(400,\"Missing queryString\");\n      List<String> commands = StrUtils.splitSmart(sreq,';');\n\n      String qs = commands.size() >= 1 ? commands.get(0) : \"\";\n      Query query = QueryParsing.parseQuery(qs, defaultField, req.getSchema());\n\n      // If the first non-query, non-filter command is a simple sort on an indexed field, then\n      // we can use the Lucene sort ability.\n      Sort sort = null;\n      if (commands.size() >= 2) {\n        QueryParsing.SortSpec sortSpec = QueryParsing.parseSort(commands.get(1), req.getSchema());\n        if (sortSpec != null) {\n          sort = sortSpec.getSort();\n          // ignore the count for now... it's currently only controlled by start & limit on req\n          // count = sortSpec.getCount();\n        }\n      }\n\n      DocList results = req.getSearcher().getDocList(query, null, sort, req.getStart(), req.getLimit(), flags);\n      rsp.add(null,results);\n\n      try {\n        NamedList dbg = U.doStandardDebug(req, qs, query, results, params);\n        if (null != dbg) \n          rsp.add(\"debug\", dbg);\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log, \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      NamedList sumData = SolrPluginUtils.doStandardHighlighting(\n        results, query, req, params, new String[]{defaultField});\n      if(sumData != null)\n        rsp.add(\"highlighting\", sumData);\n\n    } catch (SolrException e) {\n      rsp.setException(e);\n      numErrors++;\n      return;\n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n      return;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af09a11446184597ca824554260a98704507f8a7","date":1157138567,"type":3,"author":"Mike Klaas","isMerge":false,"pathNew":"src/java/org/apache/solr/request/StandardRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/request/StandardRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n\n    try {\n      U.setDefaults(req,defaults);\n      SolrParams p = req.getParams();\n      String sreq = p.get(Q);\n\n      String defaultField = p.get(DF);\n\n      // find fieldnames to return (fieldlist)\n      String fl = p.get(SolrParams.FL);\n      int flags = 0; \n      if (fl != null) {\n        flags |= U.setReturnFields(fl, rsp);\n      }\n\n      if (sreq==null) throw new SolrException(400,\"Missing queryString\");\n      List<String> commands = StrUtils.splitSmart(sreq,';');\n\n      String qs = commands.size() >= 1 ? commands.get(0) : \"\";\n      Query query = QueryParsing.parseQuery(qs, defaultField, req.getSchema());\n\n      // If the first non-query, non-filter command is a simple sort on an indexed field, then\n      // we can use the Lucene sort ability.\n      Sort sort = null;\n      if (commands.size() >= 2) {\n        QueryParsing.SortSpec sortSpec = QueryParsing.parseSort(commands.get(1), req.getSchema());\n        if (sortSpec != null) {\n          sort = sortSpec.getSort();\n          // ignore the count for now... it's currently only controlled by start & limit on req\n          // count = sortSpec.getCount();\n        }\n      }\n\n      DocList results = req.getSearcher().getDocList(query, null, sort, p.getInt(START,0), p.getInt(ROWS,10), flags);\n      rsp.add(null,results);\n\n      try {\n        NamedList dbg = U.doStandardDebug(req, qs, query, results);\n        if (null != dbg) \n          rsp.add(\"debug\", dbg);\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log, \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      NamedList sumData = HighlightingUtils.doHighlighting(\n        results, query, req, new String[]{defaultField});\n      if(sumData != null)\n        rsp.add(\"highlighting\", sumData);\n\n    } catch (SolrException e) {\n      rsp.setException(e);\n      numErrors++;\n      return;\n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n      return;\n    }\n  }\n\n","sourceOld":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n\n    try {\n      U.setDefaults(req,defaults);\n      SolrParams p = req.getParams();\n      String sreq = p.get(Q);\n\n      String defaultField = p.get(DF);\n\n      // find fieldnames to return (fieldlist)\n      String fl = p.get(SolrParams.FL);\n      int flags = 0; \n      if (fl != null) {\n        flags |= U.setReturnFields(fl, rsp);\n      }\n\n      if (sreq==null) throw new SolrException(400,\"Missing queryString\");\n      List<String> commands = StrUtils.splitSmart(sreq,';');\n\n      String qs = commands.size() >= 1 ? commands.get(0) : \"\";\n      Query query = QueryParsing.parseQuery(qs, defaultField, req.getSchema());\n\n      // If the first non-query, non-filter command is a simple sort on an indexed field, then\n      // we can use the Lucene sort ability.\n      Sort sort = null;\n      if (commands.size() >= 2) {\n        QueryParsing.SortSpec sortSpec = QueryParsing.parseSort(commands.get(1), req.getSchema());\n        if (sortSpec != null) {\n          sort = sortSpec.getSort();\n          // ignore the count for now... it's currently only controlled by start & limit on req\n          // count = sortSpec.getCount();\n        }\n      }\n\n      DocList results = req.getSearcher().getDocList(query, null, sort, p.getInt(START,0), p.getInt(ROWS,10), flags);\n      rsp.add(null,results);\n\n      try {\n        NamedList dbg = U.doStandardDebug(req, qs, query, results);\n        if (null != dbg) \n          rsp.add(\"debug\", dbg);\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log, \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      NamedList sumData = SolrPluginUtils.doStandardHighlighting(\n        results, query, req, new String[]{defaultField});\n      if(sumData != null)\n        rsp.add(\"highlighting\", sumData);\n\n    } catch (SolrException e) {\n      rsp.setException(e);\n      numErrors++;\n      return;\n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n      return;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d1b4f9f023bf5098df34505adf1ed91daa67c239","date":1157655314,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/request/StandardRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/request/StandardRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n\n    try {\n      U.setDefaults(req,defaults);\n      SolrParams p = req.getParams();\n      String sreq = p.get(Q);\n\n      String defaultField = p.get(DF);\n\n      // find fieldnames to return (fieldlist)\n      String fl = p.get(SolrParams.FL);\n      int flags = 0; \n      if (fl != null) {\n        flags |= U.setReturnFields(fl, rsp);\n      }\n\n      if (sreq==null) throw new SolrException(400,\"Missing queryString\");\n      List<String> commands = StrUtils.splitSmart(sreq,';');\n\n      String qs = commands.size() >= 1 ? commands.get(0) : \"\";\n      Query query = QueryParsing.parseQuery(qs, defaultField, req.getSchema());\n\n      // If the first non-query, non-filter command is a simple sort on an indexed field, then\n      // we can use the Lucene sort ability.\n      Sort sort = null;\n      if (commands.size() >= 2) {\n        QueryParsing.SortSpec sortSpec = QueryParsing.parseSort(commands.get(1), req.getSchema());\n        if (sortSpec != null) {\n          sort = sortSpec.getSort();\n          // ignore the count for now... it's currently only controlled by start & limit on req\n          // count = sortSpec.getCount();\n        }\n      }\n\n      DocListAndSet results = new DocListAndSet();\n      NamedList facetInfo = null;\n      List<Query> filters = U.parseFilterQueries(req);\n      SolrIndexSearcher s = req.getSearcher();\n\n      if (p.getBool(FACET,false)) {\n        results = s.getDocListAndSet(query, filters, sort,\n                                     p.getInt(START,0), p.getInt(ROWS,10),\n                                     flags);\n        facetInfo = getFacetInfo(req, rsp, results.docSet);\n      } else {\n        results.docList = s.getDocList(query, filters, sort,\n                                       p.getInt(START,0), p.getInt(ROWS,10),\n                                       flags);\n      }\n      \n      rsp.add(null,results.docList);\n\n      if (null != facetInfo) rsp.add(\"facet_counts\", facetInfo);\n\n      try {\n        NamedList dbg = U.doStandardDebug(req, qs, query, results.docList);\n        if (null != dbg) {\n          if (null != filters) {\n            dbg.add(\"filter_queries\",req.getParams().getParams(FQ));\n            List<String> fqs = new ArrayList<String>(filters.size());\n            for (Query fq : filters) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            dbg.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", dbg);\n        }\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log, \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      NamedList sumData = HighlightingUtils.doHighlighting(\n        results.docList, query, req, new String[]{defaultField});\n      if(sumData != null)\n        rsp.add(\"highlighting\", sumData);\n\n    } catch (SolrException e) {\n      rsp.setException(e);\n      numErrors++;\n      return;\n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n      return;\n    }\n  }\n\n","sourceOld":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n\n    try {\n      U.setDefaults(req,defaults);\n      SolrParams p = req.getParams();\n      String sreq = p.get(Q);\n\n      String defaultField = p.get(DF);\n\n      // find fieldnames to return (fieldlist)\n      String fl = p.get(SolrParams.FL);\n      int flags = 0; \n      if (fl != null) {\n        flags |= U.setReturnFields(fl, rsp);\n      }\n\n      if (sreq==null) throw new SolrException(400,\"Missing queryString\");\n      List<String> commands = StrUtils.splitSmart(sreq,';');\n\n      String qs = commands.size() >= 1 ? commands.get(0) : \"\";\n      Query query = QueryParsing.parseQuery(qs, defaultField, req.getSchema());\n\n      // If the first non-query, non-filter command is a simple sort on an indexed field, then\n      // we can use the Lucene sort ability.\n      Sort sort = null;\n      if (commands.size() >= 2) {\n        QueryParsing.SortSpec sortSpec = QueryParsing.parseSort(commands.get(1), req.getSchema());\n        if (sortSpec != null) {\n          sort = sortSpec.getSort();\n          // ignore the count for now... it's currently only controlled by start & limit on req\n          // count = sortSpec.getCount();\n        }\n      }\n\n      DocList results = req.getSearcher().getDocList(query, null, sort, p.getInt(START,0), p.getInt(ROWS,10), flags);\n      rsp.add(null,results);\n\n      try {\n        NamedList dbg = U.doStandardDebug(req, qs, query, results);\n        if (null != dbg) \n          rsp.add(\"debug\", dbg);\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log, \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      NamedList sumData = HighlightingUtils.doHighlighting(\n        results, query, req, new String[]{defaultField});\n      if(sumData != null)\n        rsp.add(\"highlighting\", sumData);\n\n    } catch (SolrException e) {\n      rsp.setException(e);\n      numErrors++;\n      return;\n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n      return;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"48f9527d950de8054d6fd72b138e94bc70fd63b4","date":1158101406,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/request/StandardRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/request/StandardRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n\n    try {\n      U.setDefaults(req,defaults,appends,invariants);\n      SolrParams p = req.getParams();\n      String sreq = p.get(Q);\n\n      String defaultField = p.get(DF);\n\n      // find fieldnames to return (fieldlist)\n      String fl = p.get(SolrParams.FL);\n      int flags = 0; \n      if (fl != null) {\n        flags |= U.setReturnFields(fl, rsp);\n      }\n\n      if (sreq==null) throw new SolrException(400,\"Missing queryString\");\n      List<String> commands = StrUtils.splitSmart(sreq,';');\n\n      String qs = commands.size() >= 1 ? commands.get(0) : \"\";\n      Query query = QueryParsing.parseQuery(qs, defaultField, req.getSchema());\n\n      // If the first non-query, non-filter command is a simple sort on an indexed field, then\n      // we can use the Lucene sort ability.\n      Sort sort = null;\n      if (commands.size() >= 2) {\n        QueryParsing.SortSpec sortSpec = QueryParsing.parseSort(commands.get(1), req.getSchema());\n        if (sortSpec != null) {\n          sort = sortSpec.getSort();\n          // ignore the count for now... it's currently only controlled by start & limit on req\n          // count = sortSpec.getCount();\n        }\n      }\n\n      DocListAndSet results = new DocListAndSet();\n      NamedList facetInfo = null;\n      List<Query> filters = U.parseFilterQueries(req);\n      SolrIndexSearcher s = req.getSearcher();\n\n      if (p.getBool(FACET,false)) {\n        results = s.getDocListAndSet(query, filters, sort,\n                                     p.getInt(START,0), p.getInt(ROWS,10),\n                                     flags);\n        facetInfo = getFacetInfo(req, rsp, results.docSet);\n      } else {\n        results.docList = s.getDocList(query, filters, sort,\n                                       p.getInt(START,0), p.getInt(ROWS,10),\n                                       flags);\n      }\n      \n      rsp.add(null,results.docList);\n\n      if (null != facetInfo) rsp.add(\"facet_counts\", facetInfo);\n\n      try {\n        NamedList dbg = U.doStandardDebug(req, qs, query, results.docList);\n        if (null != dbg) {\n          if (null != filters) {\n            dbg.add(\"filter_queries\",req.getParams().getParams(FQ));\n            List<String> fqs = new ArrayList<String>(filters.size());\n            for (Query fq : filters) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            dbg.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", dbg);\n        }\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log, \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      NamedList sumData = HighlightingUtils.doHighlighting(\n        results.docList, query, req, new String[]{defaultField});\n      if(sumData != null)\n        rsp.add(\"highlighting\", sumData);\n\n    } catch (SolrException e) {\n      rsp.setException(e);\n      numErrors++;\n      return;\n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n      return;\n    }\n  }\n\n","sourceOld":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n\n    try {\n      U.setDefaults(req,defaults);\n      SolrParams p = req.getParams();\n      String sreq = p.get(Q);\n\n      String defaultField = p.get(DF);\n\n      // find fieldnames to return (fieldlist)\n      String fl = p.get(SolrParams.FL);\n      int flags = 0; \n      if (fl != null) {\n        flags |= U.setReturnFields(fl, rsp);\n      }\n\n      if (sreq==null) throw new SolrException(400,\"Missing queryString\");\n      List<String> commands = StrUtils.splitSmart(sreq,';');\n\n      String qs = commands.size() >= 1 ? commands.get(0) : \"\";\n      Query query = QueryParsing.parseQuery(qs, defaultField, req.getSchema());\n\n      // If the first non-query, non-filter command is a simple sort on an indexed field, then\n      // we can use the Lucene sort ability.\n      Sort sort = null;\n      if (commands.size() >= 2) {\n        QueryParsing.SortSpec sortSpec = QueryParsing.parseSort(commands.get(1), req.getSchema());\n        if (sortSpec != null) {\n          sort = sortSpec.getSort();\n          // ignore the count for now... it's currently only controlled by start & limit on req\n          // count = sortSpec.getCount();\n        }\n      }\n\n      DocListAndSet results = new DocListAndSet();\n      NamedList facetInfo = null;\n      List<Query> filters = U.parseFilterQueries(req);\n      SolrIndexSearcher s = req.getSearcher();\n\n      if (p.getBool(FACET,false)) {\n        results = s.getDocListAndSet(query, filters, sort,\n                                     p.getInt(START,0), p.getInt(ROWS,10),\n                                     flags);\n        facetInfo = getFacetInfo(req, rsp, results.docSet);\n      } else {\n        results.docList = s.getDocList(query, filters, sort,\n                                       p.getInt(START,0), p.getInt(ROWS,10),\n                                       flags);\n      }\n      \n      rsp.add(null,results.docList);\n\n      if (null != facetInfo) rsp.add(\"facet_counts\", facetInfo);\n\n      try {\n        NamedList dbg = U.doStandardDebug(req, qs, query, results.docList);\n        if (null != dbg) {\n          if (null != filters) {\n            dbg.add(\"filter_queries\",req.getParams().getParams(FQ));\n            List<String> fqs = new ArrayList<String>(filters.size());\n            for (Query fq : filters) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            dbg.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", dbg);\n        }\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log, \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      NamedList sumData = HighlightingUtils.doHighlighting(\n        results.docList, query, req, new String[]{defaultField});\n      if(sumData != null)\n        rsp.add(\"highlighting\", sumData);\n\n    } catch (SolrException e) {\n      rsp.setException(e);\n      numErrors++;\n      return;\n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n      return;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2ae0782f8714819fbf2b48737d98875f3cea82a9","date":1158171441,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/java/org/apache/solr/request/StandardRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/request/StandardRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n\n    try {\n      U.setDefaults(req,defaults,appends,invariants);\n      SolrParams p = req.getParams();\n      String sreq = p.get(Q);\n\n      String defaultField = p.get(DF);\n\n      // find fieldnames to return (fieldlist)\n      String fl = p.get(SolrParams.FL);\n      int flags = 0; \n      if (fl != null) {\n        flags |= U.setReturnFields(fl, rsp);\n      }\n\n      if (sreq==null) throw new SolrException(400,\"Missing queryString\");\n      List<String> commands = StrUtils.splitSmart(sreq,';');\n\n      String qs = commands.size() >= 1 ? commands.get(0) : \"\";\n      Query query = QueryParsing.parseQuery(qs, defaultField, p, req.getSchema());\n\n      // If the first non-query, non-filter command is a simple sort on an indexed field, then\n      // we can use the Lucene sort ability.\n      Sort sort = null;\n      if (commands.size() >= 2) {\n        QueryParsing.SortSpec sortSpec = QueryParsing.parseSort(commands.get(1), req.getSchema());\n        if (sortSpec != null) {\n          sort = sortSpec.getSort();\n          // ignore the count for now... it's currently only controlled by start & limit on req\n          // count = sortSpec.getCount();\n        }\n      }\n\n      DocListAndSet results = new DocListAndSet();\n      NamedList facetInfo = null;\n      List<Query> filters = U.parseFilterQueries(req);\n      SolrIndexSearcher s = req.getSearcher();\n\n      if (p.getBool(FACET,false)) {\n        results = s.getDocListAndSet(query, filters, sort,\n                                     p.getInt(START,0), p.getInt(ROWS,10),\n                                     flags);\n        facetInfo = getFacetInfo(req, rsp, results.docSet);\n      } else {\n        results.docList = s.getDocList(query, filters, sort,\n                                       p.getInt(START,0), p.getInt(ROWS,10),\n                                       flags);\n      }\n      \n      rsp.add(null,results.docList);\n\n      if (null != facetInfo) rsp.add(\"facet_counts\", facetInfo);\n\n      try {\n        NamedList dbg = U.doStandardDebug(req, qs, query, results.docList);\n        if (null != dbg) {\n          if (null != filters) {\n            dbg.add(\"filter_queries\",req.getParams().getParams(FQ));\n            List<String> fqs = new ArrayList<String>(filters.size());\n            for (Query fq : filters) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            dbg.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", dbg);\n        }\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log, \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      NamedList sumData = HighlightingUtils.doHighlighting(\n        results.docList, query, req, new String[]{defaultField});\n      if(sumData != null)\n        rsp.add(\"highlighting\", sumData);\n\n    } catch (SolrException e) {\n      rsp.setException(e);\n      numErrors++;\n      return;\n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n      return;\n    }\n  }\n\n","sourceOld":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n\n    try {\n      U.setDefaults(req,defaults,appends,invariants);\n      SolrParams p = req.getParams();\n      String sreq = p.get(Q);\n\n      String defaultField = p.get(DF);\n\n      // find fieldnames to return (fieldlist)\n      String fl = p.get(SolrParams.FL);\n      int flags = 0; \n      if (fl != null) {\n        flags |= U.setReturnFields(fl, rsp);\n      }\n\n      if (sreq==null) throw new SolrException(400,\"Missing queryString\");\n      List<String> commands = StrUtils.splitSmart(sreq,';');\n\n      String qs = commands.size() >= 1 ? commands.get(0) : \"\";\n      Query query = QueryParsing.parseQuery(qs, defaultField, req.getSchema());\n\n      // If the first non-query, non-filter command is a simple sort on an indexed field, then\n      // we can use the Lucene sort ability.\n      Sort sort = null;\n      if (commands.size() >= 2) {\n        QueryParsing.SortSpec sortSpec = QueryParsing.parseSort(commands.get(1), req.getSchema());\n        if (sortSpec != null) {\n          sort = sortSpec.getSort();\n          // ignore the count for now... it's currently only controlled by start & limit on req\n          // count = sortSpec.getCount();\n        }\n      }\n\n      DocListAndSet results = new DocListAndSet();\n      NamedList facetInfo = null;\n      List<Query> filters = U.parseFilterQueries(req);\n      SolrIndexSearcher s = req.getSearcher();\n\n      if (p.getBool(FACET,false)) {\n        results = s.getDocListAndSet(query, filters, sort,\n                                     p.getInt(START,0), p.getInt(ROWS,10),\n                                     flags);\n        facetInfo = getFacetInfo(req, rsp, results.docSet);\n      } else {\n        results.docList = s.getDocList(query, filters, sort,\n                                       p.getInt(START,0), p.getInt(ROWS,10),\n                                       flags);\n      }\n      \n      rsp.add(null,results.docList);\n\n      if (null != facetInfo) rsp.add(\"facet_counts\", facetInfo);\n\n      try {\n        NamedList dbg = U.doStandardDebug(req, qs, query, results.docList);\n        if (null != dbg) {\n          if (null != filters) {\n            dbg.add(\"filter_queries\",req.getParams().getParams(FQ));\n            List<String> fqs = new ArrayList<String>(filters.size());\n            for (Query fq : filters) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            dbg.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", dbg);\n        }\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log, \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      NamedList sumData = HighlightingUtils.doHighlighting(\n        results.docList, query, req, new String[]{defaultField});\n      if(sumData != null)\n        rsp.add(\"highlighting\", sumData);\n\n    } catch (SolrException e) {\n      rsp.setException(e);\n      numErrors++;\n      return;\n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n      return;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7276fb3ba9d75a3d0099bfd9a0df6b5b067fb12a","date":1164667221,"type":3,"author":"Mike Klaas","isMerge":false,"pathNew":"src/java/org/apache/solr/request/StandardRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/request/StandardRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n\n    try {\n      U.setDefaults(req,defaults,appends,invariants);\n      SolrParams p = req.getParams();\n      String sreq = p.get(Q);\n\n      String defaultField = p.get(DF);\n\n      // find fieldnames to return (fieldlist)\n      String fl = p.get(SolrParams.FL);\n      int flags = 0; \n      if (fl != null) {\n        flags |= U.setReturnFields(fl, rsp);\n      }\n\n      if (sreq==null) throw new SolrException(400,\"Missing queryString\");\n      List<String> commands = StrUtils.splitSmart(sreq,';');\n\n      String qs = commands.size() >= 1 ? commands.get(0) : \"\";\n      Query query = QueryParsing.parseQuery(qs, defaultField, p, req.getSchema());\n\n      // If the first non-query, non-filter command is a simple sort on an indexed field, then\n      // we can use the Lucene sort ability.\n      Sort sort = null;\n      if (commands.size() >= 2) {\n        QueryParsing.SortSpec sortSpec = QueryParsing.parseSort(commands.get(1), req.getSchema());\n        if (sortSpec != null) {\n          sort = sortSpec.getSort();\n          // ignore the count for now... it's currently only controlled by start & limit on req\n          // count = sortSpec.getCount();\n        }\n      }\n\n      DocListAndSet results = new DocListAndSet();\n      NamedList facetInfo = null;\n      List<Query> filters = U.parseFilterQueries(req);\n      SolrIndexSearcher s = req.getSearcher();\n\n      if (p.getBool(FACET,false)) {\n        results = s.getDocListAndSet(query, filters, sort,\n                                     p.getInt(START,0), p.getInt(ROWS,10),\n                                     flags);\n        facetInfo = getFacetInfo(req, rsp, results.docSet);\n      } else {\n        results.docList = s.getDocList(query, filters, sort,\n                                       p.getInt(START,0), p.getInt(ROWS,10),\n                                       flags);\n      }\n\n      // pre-fetch returned documents\n      U.optimizePreFetchDocs(results.docList, query, req, rsp);\n      \n      rsp.add(null,results.docList);\n\n      if (null != facetInfo) rsp.add(\"facet_counts\", facetInfo);\n\n      try {\n        NamedList dbg = U.doStandardDebug(req, qs, query, results.docList);\n        if (null != dbg) {\n          if (null != filters) {\n            dbg.add(\"filter_queries\",req.getParams().getParams(FQ));\n            List<String> fqs = new ArrayList<String>(filters.size());\n            for (Query fq : filters) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            dbg.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", dbg);\n        }\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log, \"Exception during debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      NamedList sumData = HighlightingUtils.doHighlighting(\n        results.docList, query, req, new String[]{defaultField});\n      if(sumData != null)\n        rsp.add(\"highlighting\", sumData);\n\n    } catch (SolrException e) {\n      rsp.setException(e);\n      numErrors++;\n      return;\n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n      return;\n    }\n  }\n\n","sourceOld":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n\n    try {\n      U.setDefaults(req,defaults,appends,invariants);\n      SolrParams p = req.getParams();\n      String sreq = p.get(Q);\n\n      String defaultField = p.get(DF);\n\n      // find fieldnames to return (fieldlist)\n      String fl = p.get(SolrParams.FL);\n      int flags = 0; \n      if (fl != null) {\n        flags |= U.setReturnFields(fl, rsp);\n      }\n\n      if (sreq==null) throw new SolrException(400,\"Missing queryString\");\n      List<String> commands = StrUtils.splitSmart(sreq,';');\n\n      String qs = commands.size() >= 1 ? commands.get(0) : \"\";\n      Query query = QueryParsing.parseQuery(qs, defaultField, p, req.getSchema());\n\n      // If the first non-query, non-filter command is a simple sort on an indexed field, then\n      // we can use the Lucene sort ability.\n      Sort sort = null;\n      if (commands.size() >= 2) {\n        QueryParsing.SortSpec sortSpec = QueryParsing.parseSort(commands.get(1), req.getSchema());\n        if (sortSpec != null) {\n          sort = sortSpec.getSort();\n          // ignore the count for now... it's currently only controlled by start & limit on req\n          // count = sortSpec.getCount();\n        }\n      }\n\n      DocListAndSet results = new DocListAndSet();\n      NamedList facetInfo = null;\n      List<Query> filters = U.parseFilterQueries(req);\n      SolrIndexSearcher s = req.getSearcher();\n\n      if (p.getBool(FACET,false)) {\n        results = s.getDocListAndSet(query, filters, sort,\n                                     p.getInt(START,0), p.getInt(ROWS,10),\n                                     flags);\n        facetInfo = getFacetInfo(req, rsp, results.docSet);\n      } else {\n        results.docList = s.getDocList(query, filters, sort,\n                                       p.getInt(START,0), p.getInt(ROWS,10),\n                                       flags);\n      }\n      \n      rsp.add(null,results.docList);\n\n      if (null != facetInfo) rsp.add(\"facet_counts\", facetInfo);\n\n      try {\n        NamedList dbg = U.doStandardDebug(req, qs, query, results.docList);\n        if (null != dbg) {\n          if (null != filters) {\n            dbg.add(\"filter_queries\",req.getParams().getParams(FQ));\n            List<String> fqs = new ArrayList<String>(filters.size());\n            for (Query fq : filters) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            dbg.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", dbg);\n        }\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log, \"Exception durring debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      NamedList sumData = HighlightingUtils.doHighlighting(\n        results.docList, query, req, new String[]{defaultField});\n      if(sumData != null)\n        rsp.add(\"highlighting\", sumData);\n\n    } catch (SolrException e) {\n      rsp.setException(e);\n      numErrors++;\n      return;\n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n      return;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7aef5adbca53f7820aa6289dda74f595ed816ac7","date":1166101420,"type":3,"author":"Bertrand Delacretaz","isMerge":false,"pathNew":"src/java/org/apache/solr/request/StandardRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/request/StandardRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n\n    try {\n      U.setDefaults(req,defaults,appends,invariants);\n      SolrParams p = req.getParams();\n      String sreq = p.get(Q);\n\n      String defaultField = p.get(DF);\n\n      // find fieldnames to return (fieldlist)\n      String fl = p.get(SolrParams.FL);\n      int flags = 0; \n      if (fl != null) {\n        flags |= U.setReturnFields(fl, rsp);\n      }\n\n      if (sreq==null) throw new SolrException(400,\"Missing queryString\");\n      List<String> commands = StrUtils.splitSmart(sreq,';');\n\n      String qs = commands.size() >= 1 ? commands.get(0) : \"\";\n      Query query = QueryParsing.parseQuery(qs, defaultField, p, req.getSchema());\n\n      // If the first non-query, non-filter command is a simple sort on an indexed field, then\n      // we can use the Lucene sort ability.\n      Sort sort = null;\n      if (commands.size() >= 2) {\n        QueryParsing.SortSpec sortSpec = QueryParsing.parseSort(commands.get(1), req.getSchema());\n        if (sortSpec != null) {\n          sort = sortSpec.getSort();\n          // ignore the count for now... it's currently only controlled by start & limit on req\n          // count = sortSpec.getCount();\n        }\n      }\n\n      DocListAndSet results = new DocListAndSet();\n      NamedList facetInfo = null;\n      List<Query> filters = U.parseFilterQueries(req);\n      SolrIndexSearcher s = req.getSearcher();\n\n      if (p.getBool(FACET,false)) {\n        results = s.getDocListAndSet(query, filters, sort,\n                                     p.getInt(START,0), p.getInt(ROWS,10),\n                                     flags);\n        facetInfo = getFacetInfo(req, rsp, results.docSet);\n      } else {\n        results.docList = s.getDocList(query, filters, sort,\n                                       p.getInt(START,0), p.getInt(ROWS,10),\n                                       flags);\n      }\n\n      // pre-fetch returned documents\n      U.optimizePreFetchDocs(results.docList, query, req, rsp);\n      \n      rsp.add(\"response\",results.docList);\n\n      if (null != facetInfo) rsp.add(\"facet_counts\", facetInfo);\n\n      try {\n        NamedList dbg = U.doStandardDebug(req, qs, query, results.docList);\n        if (null != dbg) {\n          if (null != filters) {\n            dbg.add(\"filter_queries\",req.getParams().getParams(FQ));\n            List<String> fqs = new ArrayList<String>(filters.size());\n            for (Query fq : filters) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            dbg.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", dbg);\n        }\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log, \"Exception during debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      NamedList sumData = HighlightingUtils.doHighlighting(\n        results.docList, query, req, new String[]{defaultField});\n      if(sumData != null)\n        rsp.add(\"highlighting\", sumData);\n\n    } catch (SolrException e) {\n      rsp.setException(e);\n      numErrors++;\n      return;\n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n      return;\n    }\n  }\n\n","sourceOld":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n\n    try {\n      U.setDefaults(req,defaults,appends,invariants);\n      SolrParams p = req.getParams();\n      String sreq = p.get(Q);\n\n      String defaultField = p.get(DF);\n\n      // find fieldnames to return (fieldlist)\n      String fl = p.get(SolrParams.FL);\n      int flags = 0; \n      if (fl != null) {\n        flags |= U.setReturnFields(fl, rsp);\n      }\n\n      if (sreq==null) throw new SolrException(400,\"Missing queryString\");\n      List<String> commands = StrUtils.splitSmart(sreq,';');\n\n      String qs = commands.size() >= 1 ? commands.get(0) : \"\";\n      Query query = QueryParsing.parseQuery(qs, defaultField, p, req.getSchema());\n\n      // If the first non-query, non-filter command is a simple sort on an indexed field, then\n      // we can use the Lucene sort ability.\n      Sort sort = null;\n      if (commands.size() >= 2) {\n        QueryParsing.SortSpec sortSpec = QueryParsing.parseSort(commands.get(1), req.getSchema());\n        if (sortSpec != null) {\n          sort = sortSpec.getSort();\n          // ignore the count for now... it's currently only controlled by start & limit on req\n          // count = sortSpec.getCount();\n        }\n      }\n\n      DocListAndSet results = new DocListAndSet();\n      NamedList facetInfo = null;\n      List<Query> filters = U.parseFilterQueries(req);\n      SolrIndexSearcher s = req.getSearcher();\n\n      if (p.getBool(FACET,false)) {\n        results = s.getDocListAndSet(query, filters, sort,\n                                     p.getInt(START,0), p.getInt(ROWS,10),\n                                     flags);\n        facetInfo = getFacetInfo(req, rsp, results.docSet);\n      } else {\n        results.docList = s.getDocList(query, filters, sort,\n                                       p.getInt(START,0), p.getInt(ROWS,10),\n                                       flags);\n      }\n\n      // pre-fetch returned documents\n      U.optimizePreFetchDocs(results.docList, query, req, rsp);\n      \n      rsp.add(null,results.docList);\n\n      if (null != facetInfo) rsp.add(\"facet_counts\", facetInfo);\n\n      try {\n        NamedList dbg = U.doStandardDebug(req, qs, query, results.docList);\n        if (null != dbg) {\n          if (null != filters) {\n            dbg.add(\"filter_queries\",req.getParams().getParams(FQ));\n            List<String> fqs = new ArrayList<String>(filters.size());\n            for (Query fq : filters) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            dbg.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", dbg);\n        }\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log, \"Exception during debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      NamedList sumData = HighlightingUtils.doHighlighting(\n        results.docList, query, req, new String[]{defaultField});\n      if(sumData != null)\n        rsp.add(\"highlighting\", sumData);\n\n    } catch (SolrException e) {\n      rsp.setException(e);\n      numErrors++;\n      return;\n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n      return;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d80013b5e260def972025c93a0b08524f9c38f49","date":1170102801,"type":5,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/request/StandardRequestHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"src/java/org/apache/solr/request/StandardRequestHandler#handleRequest(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception\n  {\n    \n      SolrParams p = req.getParams();\n      String sreq = p.get(Q);\n\n      String defaultField = p.get(DF);\n\n      // find fieldnames to return (fieldlist)\n      String fl = p.get(SolrParams.FL);\n      int flags = 0; \n      if (fl != null) {\n        flags |= U.setReturnFields(fl, rsp);\n      }\n\n      if (sreq==null) throw new SolrException(400,\"Missing queryString\");\n      List<String> commands = StrUtils.splitSmart(sreq,';');\n\n      String qs = commands.size() >= 1 ? commands.get(0) : \"\";\n      Query query = QueryParsing.parseQuery(qs, defaultField, p, req.getSchema());\n\n      // If the first non-query, non-filter command is a simple sort on an indexed field, then\n      // we can use the Lucene sort ability.\n      Sort sort = null;\n      if (commands.size() >= 2) {\n        QueryParsing.SortSpec sortSpec = QueryParsing.parseSort(commands.get(1), req.getSchema());\n        if (sortSpec != null) {\n          sort = sortSpec.getSort();\n          // ignore the count for now... it's currently only controlled by start & limit on req\n          // count = sortSpec.getCount();\n        }\n      }\n\n      DocListAndSet results = new DocListAndSet();\n      NamedList facetInfo = null;\n      List<Query> filters = U.parseFilterQueries(req);\n      SolrIndexSearcher s = req.getSearcher();\n\n      if (p.getBool(FACET,false)) {\n        results = s.getDocListAndSet(query, filters, sort,\n                                     p.getInt(START,0), p.getInt(ROWS,10),\n                                     flags);\n        facetInfo = getFacetInfo(req, rsp, results.docSet);\n      } else {\n        results.docList = s.getDocList(query, filters, sort,\n                                       p.getInt(START,0), p.getInt(ROWS,10),\n                                       flags);\n      }\n\n      // pre-fetch returned documents\n      U.optimizePreFetchDocs(results.docList, query, req, rsp);\n      \n      rsp.add(\"response\",results.docList);\n\n      if (null != facetInfo) rsp.add(\"facet_counts\", facetInfo);\n\n      try {\n        NamedList dbg = U.doStandardDebug(req, qs, query, results.docList);\n        if (null != dbg) {\n          if (null != filters) {\n            dbg.add(\"filter_queries\",req.getParams().getParams(FQ));\n            List<String> fqs = new ArrayList<String>(filters.size());\n            for (Query fq : filters) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            dbg.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", dbg);\n        }\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log, \"Exception during debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      NamedList sumData = HighlightingUtils.doHighlighting(\n        results.docList, query, req, new String[]{defaultField});\n      if(sumData != null)\n        rsp.add(\"highlighting\", sumData);\n  }\n\n","sourceOld":"  public void handleRequest(SolrQueryRequest req, SolrQueryResponse rsp) {\n    numRequests++;\n\n    try {\n      U.setDefaults(req,defaults,appends,invariants);\n      SolrParams p = req.getParams();\n      String sreq = p.get(Q);\n\n      String defaultField = p.get(DF);\n\n      // find fieldnames to return (fieldlist)\n      String fl = p.get(SolrParams.FL);\n      int flags = 0; \n      if (fl != null) {\n        flags |= U.setReturnFields(fl, rsp);\n      }\n\n      if (sreq==null) throw new SolrException(400,\"Missing queryString\");\n      List<String> commands = StrUtils.splitSmart(sreq,';');\n\n      String qs = commands.size() >= 1 ? commands.get(0) : \"\";\n      Query query = QueryParsing.parseQuery(qs, defaultField, p, req.getSchema());\n\n      // If the first non-query, non-filter command is a simple sort on an indexed field, then\n      // we can use the Lucene sort ability.\n      Sort sort = null;\n      if (commands.size() >= 2) {\n        QueryParsing.SortSpec sortSpec = QueryParsing.parseSort(commands.get(1), req.getSchema());\n        if (sortSpec != null) {\n          sort = sortSpec.getSort();\n          // ignore the count for now... it's currently only controlled by start & limit on req\n          // count = sortSpec.getCount();\n        }\n      }\n\n      DocListAndSet results = new DocListAndSet();\n      NamedList facetInfo = null;\n      List<Query> filters = U.parseFilterQueries(req);\n      SolrIndexSearcher s = req.getSearcher();\n\n      if (p.getBool(FACET,false)) {\n        results = s.getDocListAndSet(query, filters, sort,\n                                     p.getInt(START,0), p.getInt(ROWS,10),\n                                     flags);\n        facetInfo = getFacetInfo(req, rsp, results.docSet);\n      } else {\n        results.docList = s.getDocList(query, filters, sort,\n                                       p.getInt(START,0), p.getInt(ROWS,10),\n                                       flags);\n      }\n\n      // pre-fetch returned documents\n      U.optimizePreFetchDocs(results.docList, query, req, rsp);\n      \n      rsp.add(\"response\",results.docList);\n\n      if (null != facetInfo) rsp.add(\"facet_counts\", facetInfo);\n\n      try {\n        NamedList dbg = U.doStandardDebug(req, qs, query, results.docList);\n        if (null != dbg) {\n          if (null != filters) {\n            dbg.add(\"filter_queries\",req.getParams().getParams(FQ));\n            List<String> fqs = new ArrayList<String>(filters.size());\n            for (Query fq : filters) {\n              fqs.add(QueryParsing.toString(fq, req.getSchema()));\n            }\n            dbg.add(\"parsed_filter_queries\",fqs);\n          }\n          rsp.add(\"debug\", dbg);\n        }\n      } catch (Exception e) {\n        SolrException.logOnce(SolrCore.log, \"Exception during debug\", e);\n        rsp.add(\"exception_during_debug\", SolrException.toStr(e));\n      }\n\n      NamedList sumData = HighlightingUtils.doHighlighting(\n        results.docList, query, req, new String[]{defaultField});\n      if(sumData != null)\n        rsp.add(\"highlighting\", sumData);\n\n    } catch (SolrException e) {\n      rsp.setException(e);\n      numErrors++;\n      return;\n    } catch (Exception e) {\n      SolrException.log(SolrCore.log,e);\n      rsp.setException(e);\n      numErrors++;\n      return;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d1b4f9f023bf5098df34505adf1ed91daa67c239":["af09a11446184597ca824554260a98704507f8a7"],"44f497c313977be641ddf24aab74b30e6de834d8":["d392d28bebeb57a7089ba3c9e8331920f7ab643a"],"d392d28bebeb57a7089ba3c9e8331920f7ab643a":["0452863ee588101738d341e6e97eb87eb010052a"],"7276fb3ba9d75a3d0099bfd9a0df6b5b067fb12a":["2ae0782f8714819fbf2b48737d98875f3cea82a9"],"2ae0782f8714819fbf2b48737d98875f3cea82a9":["48f9527d950de8054d6fd72b138e94bc70fd63b4"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"af09a11446184597ca824554260a98704507f8a7":["44f497c313977be641ddf24aab74b30e6de834d8"],"c9d6e41db27d65fefe44a81b13acf5a5097a166b":["0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"d80013b5e260def972025c93a0b08524f9c38f49":["7aef5adbca53f7820aa6289dda74f595ed816ac7"],"0452863ee588101738d341e6e97eb87eb010052a":["c9d6e41db27d65fefe44a81b13acf5a5097a166b"],"0c3e228bf650e96f3002a8fb73dd0c13d55af077":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7aef5adbca53f7820aa6289dda74f595ed816ac7":["7276fb3ba9d75a3d0099bfd9a0df6b5b067fb12a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"48f9527d950de8054d6fd72b138e94bc70fd63b4":["d1b4f9f023bf5098df34505adf1ed91daa67c239"]},"commit2Childs":{"d1b4f9f023bf5098df34505adf1ed91daa67c239":["48f9527d950de8054d6fd72b138e94bc70fd63b4"],"44f497c313977be641ddf24aab74b30e6de834d8":["af09a11446184597ca824554260a98704507f8a7"],"d392d28bebeb57a7089ba3c9e8331920f7ab643a":["44f497c313977be641ddf24aab74b30e6de834d8"],"7276fb3ba9d75a3d0099bfd9a0df6b5b067fb12a":["7aef5adbca53f7820aa6289dda74f595ed816ac7"],"2ae0782f8714819fbf2b48737d98875f3cea82a9":["7276fb3ba9d75a3d0099bfd9a0df6b5b067fb12a"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"af09a11446184597ca824554260a98704507f8a7":["d1b4f9f023bf5098df34505adf1ed91daa67c239"],"c9d6e41db27d65fefe44a81b13acf5a5097a166b":["0452863ee588101738d341e6e97eb87eb010052a"],"d80013b5e260def972025c93a0b08524f9c38f49":[],"0452863ee588101738d341e6e97eb87eb010052a":["d392d28bebeb57a7089ba3c9e8331920f7ab643a"],"0c3e228bf650e96f3002a8fb73dd0c13d55af077":["c9d6e41db27d65fefe44a81b13acf5a5097a166b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7aef5adbca53f7820aa6289dda74f595ed816ac7":["d80013b5e260def972025c93a0b08524f9c38f49"],"48f9527d950de8054d6fd72b138e94bc70fd63b4":["2ae0782f8714819fbf2b48737d98875f3cea82a9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d80013b5e260def972025c93a0b08524f9c38f49","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}