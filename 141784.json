{"path":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","commits":[{"id":"054c04cf724f73ebdd3b16e3a86ce802c0ba5e37","date":1362545433,"type":0,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Get a map of property name -> value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<Object>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, normalizeSPIname(getClass().getName()));\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n          namedPropertyValues.add(key, fieldTypeArgs.get(key));\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<String>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n    \n    if (isExplicitAnalyzer()) {\n      String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getAnalyzer()));\n    } \n    if (isExplicitQueryAnalyzer()) {\n      String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n    if (null != getSimilarity()) {\n      namedPropertyValues.add(SIMILARITY, getSimilarityProperties());\n    }\n    if (null != getPostingsFormat()) {\n      namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n    }\n    if (null != getDocValuesFormat()) {\n      namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n    }\n    return namedPropertyValues;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["1e210ae1e604402eb4eeff2a52e56d189cd4f2f1","6220329a2333b59a34a9ecf29c003e005c861310"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d2fa053a06c9c158f82d8e8b53b9a95031f43ebd","date":1364185773,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","sourceNew":"  /**\n   * Get a map of property name -> value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<Object>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, normalizeSPIname(getClass().getName()));\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n          namedPropertyValues.add(key, fieldTypeArgs.get(key));\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<String>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n    \n    if (isExplicitAnalyzer()) {\n      String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getAnalyzer()));\n    } \n    if (isExplicitQueryAnalyzer()) {\n      String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n    if (null != getSimilarityFactory()) {\n      namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n    }\n    if (null != getPostingsFormat()) {\n      namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n    }\n    if (null != getDocValuesFormat()) {\n      namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n    }\n    return namedPropertyValues;\n  }\n\n","sourceOld":"  /**\n   * Get a map of property name -> value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<Object>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, normalizeSPIname(getClass().getName()));\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n          namedPropertyValues.add(key, fieldTypeArgs.get(key));\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<String>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n    \n    if (isExplicitAnalyzer()) {\n      String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getAnalyzer()));\n    } \n    if (isExplicitQueryAnalyzer()) {\n      String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n    if (null != getSimilarity()) {\n      namedPropertyValues.add(SIMILARITY, getSimilarityProperties());\n    }\n    if (null != getPostingsFormat()) {\n      namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n    }\n    if (null != getDocValuesFormat()) {\n      namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n    }\n    return namedPropertyValues;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ece367783f1064f12ed72eabac9cc1afeb402b3c","date":1364362226,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","sourceNew":"  /**\n   * Get a map of property name -> value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<Object>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getShortName(getClass().getName()));\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n          namedPropertyValues.add(key, fieldTypeArgs.get(key));\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<String>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n    \n    if (isExplicitAnalyzer()) {\n      String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getAnalyzer()));\n    } \n    if (isExplicitQueryAnalyzer()) {\n      String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n    if (null != getSimilarityFactory()) {\n      namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n    }\n    if (null != getPostingsFormat()) {\n      namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n    }\n    if (null != getDocValuesFormat()) {\n      namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n    }\n    return namedPropertyValues;\n  }\n\n","sourceOld":"  /**\n   * Get a map of property name -> value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<Object>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, normalizeSPIname(getClass().getName()));\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n          namedPropertyValues.add(key, fieldTypeArgs.get(key));\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<String>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n    \n    if (isExplicitAnalyzer()) {\n      String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getAnalyzer()));\n    } \n    if (isExplicitQueryAnalyzer()) {\n      String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n    if (null != getSimilarityFactory()) {\n      namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n    }\n    if (null != getPostingsFormat()) {\n      namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n    }\n    if (null != getDocValuesFormat()) {\n      namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n    }\n    return namedPropertyValues;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9b4b4d68085809ae840a099e4620e5a128509279","date":1365633379,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","sourceNew":"  /**\n   * Get a map of property name -> value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<Object>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<String>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n    \n    if (isExplicitAnalyzer()) {\n      String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getAnalyzer()));\n    } \n    if (isExplicitQueryAnalyzer()) {\n      String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n    if (null != getSimilarityFactory()) {\n      namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n    }\n    if (null != getPostingsFormat()) {\n      namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n    }\n    if (null != getDocValuesFormat()) {\n      namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n    }\n    return namedPropertyValues;\n  }\n\n","sourceOld":"  /**\n   * Get a map of property name -> value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<Object>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getShortName(getClass().getName()));\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n          namedPropertyValues.add(key, fieldTypeArgs.get(key));\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<String>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n    \n    if (isExplicitAnalyzer()) {\n      String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getAnalyzer()));\n    } \n    if (isExplicitQueryAnalyzer()) {\n      String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n    if (null != getSimilarityFactory()) {\n      namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n    }\n    if (null != getPostingsFormat()) {\n      namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n    }\n    if (null != getDocValuesFormat()) {\n      namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n    }\n    return namedPropertyValues;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d264f386d864b5751209060e8886ca9845f70469","date":1372172126,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","sourceNew":"  /**\n   * Get a map of property name -> value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<Object>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n      if (null != getSimilarityFactory()) {\n        namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n      }\n      if (null != getPostingsFormat()) {\n        namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n      }\n      if (null != getDocValuesFormat()) {\n        namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n      }\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<String>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n    \n    if (isExplicitAnalyzer()) {\n      String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getAnalyzer()));\n    } \n    if (isExplicitQueryAnalyzer()) {\n      String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n\n    return namedPropertyValues;\n  }\n\n","sourceOld":"  /**\n   * Get a map of property name -> value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<Object>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<String>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n    \n    if (isExplicitAnalyzer()) {\n      String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getAnalyzer()));\n    } \n    if (isExplicitQueryAnalyzer()) {\n      String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n    if (null != getSimilarityFactory()) {\n      namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n    }\n    if (null != getPostingsFormat()) {\n      namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n    }\n    if (null != getDocValuesFormat()) {\n      namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n    }\n    return namedPropertyValues;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"354983dcdf70c800bf2573d10b54a7391b1dc167","date":1372183171,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","sourceNew":"  /**\n   * Get a map of property name -> value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<Object>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<String>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n    \n    if (isExplicitAnalyzer()) {\n      String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getAnalyzer()));\n    } \n    if (isExplicitQueryAnalyzer()) {\n      String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n    if (null != getSimilarityFactory()) {\n      namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n    }\n    if (null != getPostingsFormat()) {\n      namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n    }\n    if (null != getDocValuesFormat()) {\n      namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n    }\n    return namedPropertyValues;\n  }\n\n","sourceOld":"  /**\n   * Get a map of property name -> value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<Object>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n      if (null != getSimilarityFactory()) {\n        namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n      }\n      if (null != getPostingsFormat()) {\n        namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n      }\n      if (null != getDocValuesFormat()) {\n        namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n      }\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<String>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n    \n    if (isExplicitAnalyzer()) {\n      String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getAnalyzer()));\n    } \n    if (isExplicitQueryAnalyzer()) {\n      String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n\n    return namedPropertyValues;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7116474e2e390259937401cf928323e0cbc75e60","date":1372780249,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","sourceNew":"  /**\n   * Get a map of property name -> value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<Object>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n      if (null != getSimilarityFactory()) {\n        namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n      }\n      if (null != getPostingsFormat()) {\n        namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n      }\n      if (null != getDocValuesFormat()) {\n        namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n      }\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<String>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n    \n    if (isExplicitAnalyzer()) {\n      String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getAnalyzer()));\n    } \n    if (isExplicitQueryAnalyzer()) {\n      String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n\n    return namedPropertyValues;\n  }\n\n","sourceOld":"  /**\n   * Get a map of property name -> value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<Object>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<String>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n    \n    if (isExplicitAnalyzer()) {\n      String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getAnalyzer()));\n    } \n    if (isExplicitQueryAnalyzer()) {\n      String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n    if (null != getSimilarityFactory()) {\n      namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n    }\n    if (null != getPostingsFormat()) {\n      namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n    }\n    if (null != getDocValuesFormat()) {\n      namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n    }\n    return namedPropertyValues;\n  }\n\n","bugFix":null,"bugIntro":["9a4cf8d543027e3357024f7005523976bd6a0dfc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","sourceNew":"  /**\n   * Get a map of property name -> value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<Object>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n      if (null != getSimilarityFactory()) {\n        namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n      }\n      if (null != getPostingsFormat()) {\n        namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n      }\n      if (null != getDocValuesFormat()) {\n        namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n      }\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<String>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n    \n    if (isExplicitAnalyzer()) {\n      String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getAnalyzer()));\n    } \n    if (isExplicitQueryAnalyzer()) {\n      String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n\n    return namedPropertyValues;\n  }\n\n","sourceOld":"  /**\n   * Get a map of property name -> value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<Object>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<String>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n    \n    if (isExplicitAnalyzer()) {\n      String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getAnalyzer()));\n    } \n    if (isExplicitQueryAnalyzer()) {\n      String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n    if (null != getSimilarityFactory()) {\n      namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n    }\n    if (null != getPostingsFormat()) {\n      namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n    }\n    if (null != getDocValuesFormat()) {\n      namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n    }\n    return namedPropertyValues;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","sourceNew":"  /**\n   * Get a map of property name -> value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n      if (null != getSimilarityFactory()) {\n        namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n      }\n      if (null != getPostingsFormat()) {\n        namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n      }\n      if (null != getDocValuesFormat()) {\n        namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n      }\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n    \n    if (isExplicitAnalyzer()) {\n      String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getAnalyzer()));\n    } \n    if (isExplicitQueryAnalyzer()) {\n      String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n\n    return namedPropertyValues;\n  }\n\n","sourceOld":"  /**\n   * Get a map of property name -> value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<Object>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n      if (null != getSimilarityFactory()) {\n        namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n      }\n      if (null != getPostingsFormat()) {\n        namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n      }\n      if (null != getDocValuesFormat()) {\n        namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n      }\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<String>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n    \n    if (isExplicitAnalyzer()) {\n      String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getAnalyzer()));\n    } \n    if (isExplicitQueryAnalyzer()) {\n      String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n\n    return namedPropertyValues;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"123698fbe83b595f9e084f0019cd35ab4a01d7f7","date":1399070065,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","sourceNew":"  /**\n   * Get a map of property name -> value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n      if (null != getSimilarityFactory()) {\n        namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n      }\n      if (null != getPostingsFormat()) {\n        namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n      }\n      if (null != getDocValuesFormat()) {\n        namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n      }\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n    \n    if (isExplicitAnalyzer()) {\n      String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getIndexAnalyzer()));\n    } \n    if (isExplicitQueryAnalyzer()) {\n      String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n\n    return namedPropertyValues;\n  }\n\n","sourceOld":"  /**\n   * Get a map of property name -> value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n      if (null != getSimilarityFactory()) {\n        namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n      }\n      if (null != getPostingsFormat()) {\n        namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n      }\n      if (null != getDocValuesFormat()) {\n        namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n      }\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n    \n    if (isExplicitAnalyzer()) {\n      String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getAnalyzer()));\n    } \n    if (isExplicitQueryAnalyzer()) {\n      String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n\n    return namedPropertyValues;\n  }\n\n","bugFix":null,"bugIntro":["6220329a2333b59a34a9ecf29c003e005c861310"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bdf16ebe435fc9daea90a73b8683ff001c6d3523","date":1409931231,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","sourceNew":"  /**\n   * Get a map of property name -> value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n      if (null != getSimilarityFactory()) {\n        namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n      }\n      if (null != getPostingsFormat()) {\n        namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n      }\n      if (null != getDocValuesFormat()) {\n        namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n      }\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if (!CLASS_NAME.equals(key) && !TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n    \n    if (isExplicitAnalyzer()) {\n      String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getIndexAnalyzer()));\n    } \n    if (isExplicitQueryAnalyzer()) {\n      String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n\n    return namedPropertyValues;\n  }\n\n","sourceOld":"  /**\n   * Get a map of property name -> value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n      if (null != getSimilarityFactory()) {\n        namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n      }\n      if (null != getPostingsFormat()) {\n        namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n      }\n      if (null != getDocValuesFormat()) {\n        namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n      }\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n    \n    if (isExplicitAnalyzer()) {\n      String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getIndexAnalyzer()));\n    } \n    if (isExplicitQueryAnalyzer()) {\n      String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n\n    return namedPropertyValues;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1e210ae1e604402eb4eeff2a52e56d189cd4f2f1","date":1423508552,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","sourceNew":"  /**\n   * Get a map of property name -&gt; value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n      if (null != getSimilarityFactory()) {\n        namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n      }\n      if (null != getPostingsFormat()) {\n        namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n      }\n      if (null != getDocValuesFormat()) {\n        namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n      }\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if (!CLASS_NAME.equals(key) && !TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n    \n    if (isExplicitAnalyzer()) {\n      String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getIndexAnalyzer()));\n    } \n    if (isExplicitQueryAnalyzer()) {\n      String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n\n    return namedPropertyValues;\n  }\n\n","sourceOld":"  /**\n   * Get a map of property name -> value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n      if (null != getSimilarityFactory()) {\n        namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n      }\n      if (null != getPostingsFormat()) {\n        namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n      }\n      if (null != getDocValuesFormat()) {\n        namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n      }\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if (!CLASS_NAME.equals(key) && !TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n    \n    if (isExplicitAnalyzer()) {\n      String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getIndexAnalyzer()));\n    } \n    if (isExplicitQueryAnalyzer()) {\n      String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n\n    return namedPropertyValues;\n  }\n\n","bugFix":["054c04cf724f73ebdd3b16e3a86ce802c0ba5e37"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9a4cf8d543027e3357024f7005523976bd6a0dfc","date":1434743090,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","sourceNew":"  /**\n   * Get a map of property name -&gt; value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n      if (null != getPostingsFormat()) {\n        namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n      }\n      if (null != getDocValuesFormat()) {\n        namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n      }\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if (!CLASS_NAME.equals(key) && !TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n\n    if (null != getSimilarityFactory()) {\n      namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n    }\n    \n    if (isExplicitAnalyzer()) {\n      String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getIndexAnalyzer()));\n    } \n    if (isExplicitQueryAnalyzer()) {\n      String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n\n    return namedPropertyValues;\n  }\n\n","sourceOld":"  /**\n   * Get a map of property name -&gt; value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n      if (null != getSimilarityFactory()) {\n        namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n      }\n      if (null != getPostingsFormat()) {\n        namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n      }\n      if (null != getDocValuesFormat()) {\n        namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n      }\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if (!CLASS_NAME.equals(key) && !TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n    \n    if (isExplicitAnalyzer()) {\n      String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getIndexAnalyzer()));\n    } \n    if (isExplicitQueryAnalyzer()) {\n      String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n\n    return namedPropertyValues;\n  }\n\n","bugFix":["7116474e2e390259937401cf928323e0cbc75e60"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6220329a2333b59a34a9ecf29c003e005c861310","date":1479169077,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","sourceNew":"  /**\n   * Get a map of property name -&gt; value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n      if (null != getPostingsFormat()) {\n        namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n      }\n      if (null != getDocValuesFormat()) {\n        namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n      }\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if (!CLASS_NAME.equals(key) && !TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n\n    if (null != getSimilarityFactory()) {\n      namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n    }\n    \n    if (this instanceof HasImplicitIndexAnalyzer) {\n      if (isExplicitQueryAnalyzer()) {\n        namedPropertyValues.add(QUERY_ANALYZER, getAnalyzerProperties(getQueryAnalyzer()));\n      }\n    } else {\n      if (isExplicitAnalyzer()) {\n        String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n        namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getIndexAnalyzer()));\n      }\n      if (isExplicitQueryAnalyzer()) {\n        String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n        namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n      }\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n\n    return namedPropertyValues;\n  }\n\n","sourceOld":"  /**\n   * Get a map of property name -&gt; value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n      if (null != getPostingsFormat()) {\n        namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n      }\n      if (null != getDocValuesFormat()) {\n        namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n      }\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if (!CLASS_NAME.equals(key) && !TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n\n    if (null != getSimilarityFactory()) {\n      namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n    }\n    \n    if (isExplicitAnalyzer()) {\n      String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getIndexAnalyzer()));\n    } \n    if (isExplicitQueryAnalyzer()) {\n      String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n\n    return namedPropertyValues;\n  }\n\n","bugFix":["054c04cf724f73ebdd3b16e3a86ce802c0ba5e37","123698fbe83b595f9e084f0019cd35ab4a01d7f7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"21019aa828c8c9b0153877543a8b3f200bf2ca19","date":1479224450,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","sourceNew":"  /**\n   * Get a map of property name -&gt; value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n      if (null != getPostingsFormat()) {\n        namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n      }\n      if (null != getDocValuesFormat()) {\n        namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n      }\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if (!CLASS_NAME.equals(key) && !TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n\n    if (null != getSimilarityFactory()) {\n      namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n    }\n    \n    if (this instanceof HasImplicitIndexAnalyzer) {\n      if (isExplicitQueryAnalyzer()) {\n        namedPropertyValues.add(QUERY_ANALYZER, getAnalyzerProperties(getQueryAnalyzer()));\n      }\n    } else {\n      if (isExplicitAnalyzer()) {\n        String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n        namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getIndexAnalyzer()));\n      }\n      if (isExplicitQueryAnalyzer()) {\n        String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n        namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n      }\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n\n    return namedPropertyValues;\n  }\n\n","sourceOld":"  /**\n   * Get a map of property name -&gt; value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n      if (null != getPostingsFormat()) {\n        namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n      }\n      if (null != getDocValuesFormat()) {\n        namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n      }\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if (!CLASS_NAME.equals(key) && !TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n\n    if (null != getSimilarityFactory()) {\n      namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n    }\n    \n    if (isExplicitAnalyzer()) {\n      String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getIndexAnalyzer()));\n    } \n    if (isExplicitQueryAnalyzer()) {\n      String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n      namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n\n    return namedPropertyValues;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d1728ac6bfc0cea61f3e27436b418295d9982a3","date":1491423806,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","sourceNew":"  /**\n   * Get a map of property name -&gt; value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n        namedPropertyValues.add(ENABLE_GRAPH_QUERIES, ((TextField) this).getEnableGraphQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n      if (null != getPostingsFormat()) {\n        namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n      }\n      if (null != getDocValuesFormat()) {\n        namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n      }\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if (!CLASS_NAME.equals(key) && !TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n\n    if (null != getSimilarityFactory()) {\n      namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n    }\n    \n    if (this instanceof HasImplicitIndexAnalyzer) {\n      if (isExplicitQueryAnalyzer()) {\n        namedPropertyValues.add(QUERY_ANALYZER, getAnalyzerProperties(getQueryAnalyzer()));\n      }\n    } else {\n      if (isExplicitAnalyzer()) {\n        String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n        namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getIndexAnalyzer()));\n      }\n      if (isExplicitQueryAnalyzer()) {\n        String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n        namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n      }\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n\n    return namedPropertyValues;\n  }\n\n","sourceOld":"  /**\n   * Get a map of property name -&gt; value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n      if (null != getPostingsFormat()) {\n        namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n      }\n      if (null != getDocValuesFormat()) {\n        namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n      }\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if (!CLASS_NAME.equals(key) && !TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n\n    if (null != getSimilarityFactory()) {\n      namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n    }\n    \n    if (this instanceof HasImplicitIndexAnalyzer) {\n      if (isExplicitQueryAnalyzer()) {\n        namedPropertyValues.add(QUERY_ANALYZER, getAnalyzerProperties(getQueryAnalyzer()));\n      }\n    } else {\n      if (isExplicitAnalyzer()) {\n        String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n        namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getIndexAnalyzer()));\n      }\n      if (isExplicitQueryAnalyzer()) {\n        String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n        namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n      }\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n\n    return namedPropertyValues;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","sourceNew":"  /**\n   * Get a map of property name -&gt; value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n        namedPropertyValues.add(ENABLE_GRAPH_QUERIES, ((TextField) this).getEnableGraphQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n      if (null != getPostingsFormat()) {\n        namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n      }\n      if (null != getDocValuesFormat()) {\n        namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n      }\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if (!CLASS_NAME.equals(key) && !TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n\n    if (null != getSimilarityFactory()) {\n      namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n    }\n    \n    if (this instanceof HasImplicitIndexAnalyzer) {\n      if (isExplicitQueryAnalyzer()) {\n        namedPropertyValues.add(QUERY_ANALYZER, getAnalyzerProperties(getQueryAnalyzer()));\n      }\n    } else {\n      if (isExplicitAnalyzer()) {\n        String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n        namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getIndexAnalyzer()));\n      }\n      if (isExplicitQueryAnalyzer()) {\n        String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n        namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n      }\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n\n    return namedPropertyValues;\n  }\n\n","sourceOld":"  /**\n   * Get a map of property name -&gt; value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n      if (null != getPostingsFormat()) {\n        namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n      }\n      if (null != getDocValuesFormat()) {\n        namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n      }\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if (!CLASS_NAME.equals(key) && !TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n\n    if (null != getSimilarityFactory()) {\n      namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n    }\n    \n    if (this instanceof HasImplicitIndexAnalyzer) {\n      if (isExplicitQueryAnalyzer()) {\n        namedPropertyValues.add(QUERY_ANALYZER, getAnalyzerProperties(getQueryAnalyzer()));\n      }\n    } else {\n      if (isExplicitAnalyzer()) {\n        String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n        namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getIndexAnalyzer()));\n      }\n      if (isExplicitQueryAnalyzer()) {\n        String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n        namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n      }\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n\n    return namedPropertyValues;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b851ef3570d909ec1fb99f9d35a616d8500b83c0","date":1493818234,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","sourceNew":"  /**\n   * Get a map of property name -&gt; value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n        namedPropertyValues.add(ENABLE_GRAPH_QUERIES, ((TextField) this).getEnableGraphQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      namedPropertyValues.add(getPropertyName(LARGE_FIELD), hasProperty(LARGE_FIELD));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n      if (null != getPostingsFormat()) {\n        namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n      }\n      if (null != getDocValuesFormat()) {\n        namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n      }\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if (!CLASS_NAME.equals(key) && !TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n\n    if (null != getSimilarityFactory()) {\n      namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n    }\n    \n    if (this instanceof HasImplicitIndexAnalyzer) {\n      if (isExplicitQueryAnalyzer()) {\n        namedPropertyValues.add(QUERY_ANALYZER, getAnalyzerProperties(getQueryAnalyzer()));\n      }\n    } else {\n      if (isExplicitAnalyzer()) {\n        String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n        namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getIndexAnalyzer()));\n      }\n      if (isExplicitQueryAnalyzer()) {\n        String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n        namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n      }\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n\n    return namedPropertyValues;\n  }\n\n","sourceOld":"  /**\n   * Get a map of property name -&gt; value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n        namedPropertyValues.add(ENABLE_GRAPH_QUERIES, ((TextField) this).getEnableGraphQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n      if (null != getPostingsFormat()) {\n        namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n      }\n      if (null != getDocValuesFormat()) {\n        namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n      }\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if (!CLASS_NAME.equals(key) && !TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n\n    if (null != getSimilarityFactory()) {\n      namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n    }\n    \n    if (this instanceof HasImplicitIndexAnalyzer) {\n      if (isExplicitQueryAnalyzer()) {\n        namedPropertyValues.add(QUERY_ANALYZER, getAnalyzerProperties(getQueryAnalyzer()));\n      }\n    } else {\n      if (isExplicitAnalyzer()) {\n        String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n        namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getIndexAnalyzer()));\n      }\n      if (isExplicitQueryAnalyzer()) {\n        String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n        namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n      }\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n\n    return namedPropertyValues;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","sourceNew":"  /**\n   * Get a map of property name -&gt; value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n        namedPropertyValues.add(ENABLE_GRAPH_QUERIES, ((TextField) this).getEnableGraphQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      namedPropertyValues.add(getPropertyName(LARGE_FIELD), hasProperty(LARGE_FIELD));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n      if (null != getPostingsFormat()) {\n        namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n      }\n      if (null != getDocValuesFormat()) {\n        namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n      }\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if (!CLASS_NAME.equals(key) && !TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n\n    if (null != getSimilarityFactory()) {\n      namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n    }\n    \n    if (this instanceof HasImplicitIndexAnalyzer) {\n      if (isExplicitQueryAnalyzer()) {\n        namedPropertyValues.add(QUERY_ANALYZER, getAnalyzerProperties(getQueryAnalyzer()));\n      }\n    } else {\n      if (isExplicitAnalyzer()) {\n        String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n        namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getIndexAnalyzer()));\n      }\n      if (isExplicitQueryAnalyzer()) {\n        String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n        namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n      }\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n\n    return namedPropertyValues;\n  }\n\n","sourceOld":"  /**\n   * Get a map of property name -&gt; value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n        namedPropertyValues.add(ENABLE_GRAPH_QUERIES, ((TextField) this).getEnableGraphQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n      if (null != getPostingsFormat()) {\n        namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n      }\n      if (null != getDocValuesFormat()) {\n        namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n      }\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if (!CLASS_NAME.equals(key) && !TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n\n    if (null != getSimilarityFactory()) {\n      namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n    }\n    \n    if (this instanceof HasImplicitIndexAnalyzer) {\n      if (isExplicitQueryAnalyzer()) {\n        namedPropertyValues.add(QUERY_ANALYZER, getAnalyzerProperties(getQueryAnalyzer()));\n      }\n    } else {\n      if (isExplicitAnalyzer()) {\n        String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n        namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getIndexAnalyzer()));\n      }\n      if (isExplicitQueryAnalyzer()) {\n        String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n        namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n      }\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n\n    return namedPropertyValues;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"47d74fab5d64854ddafa81b65ed399b192f2d947","date":1512411916,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","sourceNew":"  /**\n   * Get a map of property name -&gt; value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n        namedPropertyValues.add(ENABLE_GRAPH_QUERIES, ((TextField) this).getEnableGraphQueries());\n        namedPropertyValues.add(SYNONYM_QUERY_STYLE, ((TextField) this).getSynonymQueryStyle());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      namedPropertyValues.add(getPropertyName(LARGE_FIELD), hasProperty(LARGE_FIELD));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n      if (null != getPostingsFormat()) {\n        namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n      }\n      if (null != getDocValuesFormat()) {\n        namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n      }\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if (!CLASS_NAME.equals(key) && !TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n\n    if (null != getSimilarityFactory()) {\n      namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n    }\n    \n    if (this instanceof HasImplicitIndexAnalyzer) {\n      if (isExplicitQueryAnalyzer()) {\n        namedPropertyValues.add(QUERY_ANALYZER, getAnalyzerProperties(getQueryAnalyzer()));\n      }\n    } else {\n      if (isExplicitAnalyzer()) {\n        String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n        namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getIndexAnalyzer()));\n      }\n      if (isExplicitQueryAnalyzer()) {\n        String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n        namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n      }\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n\n    return namedPropertyValues;\n  }\n\n","sourceOld":"  /**\n   * Get a map of property name -&gt; value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n        namedPropertyValues.add(ENABLE_GRAPH_QUERIES, ((TextField) this).getEnableGraphQueries());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      namedPropertyValues.add(getPropertyName(LARGE_FIELD), hasProperty(LARGE_FIELD));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n      if (null != getPostingsFormat()) {\n        namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n      }\n      if (null != getDocValuesFormat()) {\n        namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n      }\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if (!CLASS_NAME.equals(key) && !TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n\n    if (null != getSimilarityFactory()) {\n      namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n    }\n    \n    if (this instanceof HasImplicitIndexAnalyzer) {\n      if (isExplicitQueryAnalyzer()) {\n        namedPropertyValues.add(QUERY_ANALYZER, getAnalyzerProperties(getQueryAnalyzer()));\n      }\n    } else {\n      if (isExplicitAnalyzer()) {\n        String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n        namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getIndexAnalyzer()));\n      }\n      if (isExplicitQueryAnalyzer()) {\n        String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n        namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n      }\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n\n    return namedPropertyValues;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d0da5c396448d1d4e5ffbd66baa3df981d3dd5e","date":1541777404,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","sourceNew":"  /**\n   * Get a map of property name -&gt; value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n        namedPropertyValues.add(ENABLE_GRAPH_QUERIES, ((TextField) this).getEnableGraphQueries());\n        namedPropertyValues.add(SYNONYM_QUERY_STYLE, ((TextField) this).getSynonymQueryStyle());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      namedPropertyValues.add(getPropertyName(LARGE_FIELD), hasProperty(LARGE_FIELD));\n      namedPropertyValues.add(getPropertyName(UNINVERTIBLE), hasProperty(UNINVERTIBLE));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n      if (null != getPostingsFormat()) {\n        namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n      }\n      if (null != getDocValuesFormat()) {\n        namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n      }\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if (!CLASS_NAME.equals(key) && !TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n\n    if (null != getSimilarityFactory()) {\n      namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n    }\n    \n    if (this instanceof HasImplicitIndexAnalyzer) {\n      if (isExplicitQueryAnalyzer()) {\n        namedPropertyValues.add(QUERY_ANALYZER, getAnalyzerProperties(getQueryAnalyzer()));\n      }\n    } else {\n      if (isExplicitAnalyzer()) {\n        String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n        namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getIndexAnalyzer()));\n      }\n      if (isExplicitQueryAnalyzer()) {\n        String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n        namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n      }\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n\n    return namedPropertyValues;\n  }\n\n","sourceOld":"  /**\n   * Get a map of property name -&gt; value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n        namedPropertyValues.add(ENABLE_GRAPH_QUERIES, ((TextField) this).getEnableGraphQueries());\n        namedPropertyValues.add(SYNONYM_QUERY_STYLE, ((TextField) this).getSynonymQueryStyle());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      namedPropertyValues.add(getPropertyName(LARGE_FIELD), hasProperty(LARGE_FIELD));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n      if (null != getPostingsFormat()) {\n        namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n      }\n      if (null != getDocValuesFormat()) {\n        namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n      }\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if (!CLASS_NAME.equals(key) && !TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n\n    if (null != getSimilarityFactory()) {\n      namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n    }\n    \n    if (this instanceof HasImplicitIndexAnalyzer) {\n      if (isExplicitQueryAnalyzer()) {\n        namedPropertyValues.add(QUERY_ANALYZER, getAnalyzerProperties(getQueryAnalyzer()));\n      }\n    } else {\n      if (isExplicitAnalyzer()) {\n        String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n        namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getIndexAnalyzer()));\n      }\n      if (isExplicitQueryAnalyzer()) {\n        String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n        namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n      }\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n\n    return namedPropertyValues;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f97fc3d287be2a8d7f513f0de3249b50dda47299","date":1568378558,"type":3,"author":"Koen De Groote","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getNamedPropertyValues(boolean).mjava","sourceNew":"  /**\n   * Get a map of property name -&gt; value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (Map.Entry<String, String> entry : fieldTypeArgs.entrySet()) {\n          String key = entry.getKey();\n          if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, entry.getValue());\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n        namedPropertyValues.add(ENABLE_GRAPH_QUERIES, ((TextField) this).getEnableGraphQueries());\n        namedPropertyValues.add(SYNONYM_QUERY_STYLE, ((TextField) this).getSynonymQueryStyle());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      namedPropertyValues.add(getPropertyName(LARGE_FIELD), hasProperty(LARGE_FIELD));\n      namedPropertyValues.add(getPropertyName(UNINVERTIBLE), hasProperty(UNINVERTIBLE));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n      if (null != getPostingsFormat()) {\n        namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n      }\n      if (null != getDocValuesFormat()) {\n        namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n      }\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n\n      for (Map.Entry<String, String> entry : args.entrySet()) {\n        String key = entry.getKey();\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(entry.getValue()));\n        } else if (!CLASS_NAME.equals(key) && !TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, entry.getValue());\n        }\n      }\n    }\n\n    if (null != getSimilarityFactory()) {\n      namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n    }\n    \n    if (this instanceof HasImplicitIndexAnalyzer) {\n      if (isExplicitQueryAnalyzer()) {\n        namedPropertyValues.add(QUERY_ANALYZER, getAnalyzerProperties(getQueryAnalyzer()));\n      }\n    } else {\n      if (isExplicitAnalyzer()) {\n        String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n        namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getIndexAnalyzer()));\n      }\n      if (isExplicitQueryAnalyzer()) {\n        String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n        namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n      }\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n\n    return namedPropertyValues;\n  }\n\n","sourceOld":"  /**\n   * Get a map of property name -&gt; value for this field type. \n   * @param showDefaults if true, include default properties.\n   */\n  public SimpleOrderedMap<Object> getNamedPropertyValues(boolean showDefaults) {\n    SimpleOrderedMap<Object> namedPropertyValues = new SimpleOrderedMap<>();\n    namedPropertyValues.add(TYPE_NAME, getTypeName());\n    namedPropertyValues.add(CLASS_NAME, getClassArg());\n    if (showDefaults) {\n      Map<String,String> fieldTypeArgs = getNonFieldPropertyArgs();\n      if (null != fieldTypeArgs) {\n        for (String key : fieldTypeArgs.keySet()) {\n        if ( ! CLASS_NAME.equals(key) && ! TYPE_NAME.equals(key)) {\n            namedPropertyValues.add(key, fieldTypeArgs.get(key));\n          }\n        }\n      }\n      if (this instanceof TextField) {\n        namedPropertyValues.add(AUTO_GENERATE_PHRASE_QUERIES, ((TextField) this).getAutoGeneratePhraseQueries());\n        namedPropertyValues.add(ENABLE_GRAPH_QUERIES, ((TextField) this).getEnableGraphQueries());\n        namedPropertyValues.add(SYNONYM_QUERY_STYLE, ((TextField) this).getSynonymQueryStyle());\n      }\n      namedPropertyValues.add(getPropertyName(INDEXED), hasProperty(INDEXED));\n      namedPropertyValues.add(getPropertyName(STORED), hasProperty(STORED));\n      namedPropertyValues.add(getPropertyName(DOC_VALUES), hasProperty(DOC_VALUES));\n      namedPropertyValues.add(getPropertyName(STORE_TERMVECTORS), hasProperty(STORE_TERMVECTORS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMPOSITIONS), hasProperty(STORE_TERMPOSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_TERMOFFSETS), hasProperty(STORE_TERMOFFSETS));\n      namedPropertyValues.add(getPropertyName(OMIT_NORMS), hasProperty(OMIT_NORMS));\n      namedPropertyValues.add(getPropertyName(OMIT_TF_POSITIONS), hasProperty(OMIT_TF_POSITIONS));\n      namedPropertyValues.add(getPropertyName(OMIT_POSITIONS), hasProperty(OMIT_POSITIONS));\n      namedPropertyValues.add(getPropertyName(STORE_OFFSETS), hasProperty(STORE_OFFSETS));\n      namedPropertyValues.add(getPropertyName(MULTIVALUED), hasProperty(MULTIVALUED));\n      namedPropertyValues.add(getPropertyName(LARGE_FIELD), hasProperty(LARGE_FIELD));\n      namedPropertyValues.add(getPropertyName(UNINVERTIBLE), hasProperty(UNINVERTIBLE));\n      if (hasProperty(SORT_MISSING_FIRST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_FIRST), true);\n      } else if (hasProperty(SORT_MISSING_LAST)) {\n        namedPropertyValues.add(getPropertyName(SORT_MISSING_LAST), true);\n      }\n      namedPropertyValues.add(getPropertyName(TOKENIZED), isTokenized());\n      // The BINARY property is always false\n      // namedPropertyValues.add(getPropertyName(BINARY), hasProperty(BINARY));\n      if (null != getPostingsFormat()) {\n        namedPropertyValues.add(POSTINGS_FORMAT, getPostingsFormat());\n      }\n      if (null != getDocValuesFormat()) {\n        namedPropertyValues.add(DOC_VALUES_FORMAT, getDocValuesFormat());\n      }\n    } else { // Don't show defaults\n      Set<String> fieldProperties = new HashSet<>();\n      for (String propertyName : FieldProperties.propertyNames) {\n        fieldProperties.add(propertyName);\n      }\n\n      for (String key : args.keySet()) {\n        if (fieldProperties.contains(key)) {\n          namedPropertyValues.add(key, StrUtils.parseBool(args.get(key)));\n        } else if (!CLASS_NAME.equals(key) && !TYPE_NAME.equals(key)) {\n          namedPropertyValues.add(key, args.get(key));\n        }\n      }\n    }\n\n    if (null != getSimilarityFactory()) {\n      namedPropertyValues.add(SIMILARITY, getSimilarityFactory().getNamedPropertyValues());\n    }\n    \n    if (this instanceof HasImplicitIndexAnalyzer) {\n      if (isExplicitQueryAnalyzer()) {\n        namedPropertyValues.add(QUERY_ANALYZER, getAnalyzerProperties(getQueryAnalyzer()));\n      }\n    } else {\n      if (isExplicitAnalyzer()) {\n        String analyzerProperty = isExplicitQueryAnalyzer() ? INDEX_ANALYZER : ANALYZER;\n        namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getIndexAnalyzer()));\n      }\n      if (isExplicitQueryAnalyzer()) {\n        String analyzerProperty = isExplicitAnalyzer() ? QUERY_ANALYZER : ANALYZER;\n        namedPropertyValues.add(analyzerProperty, getAnalyzerProperties(getQueryAnalyzer()));\n      }\n    }\n    if (this instanceof TextField) {\n      if (((TextField)this).isExplicitMultiTermAnalyzer()) {\n        namedPropertyValues.add(MULTI_TERM_ANALYZER, getAnalyzerProperties(((TextField) this).getMultiTermAnalyzer()));\n      }\n    }\n\n    return namedPropertyValues;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["6220329a2333b59a34a9ecf29c003e005c861310"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["7116474e2e390259937401cf928323e0cbc75e60"],"7116474e2e390259937401cf928323e0cbc75e60":["354983dcdf70c800bf2573d10b54a7391b1dc167"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["9b4b4d68085809ae840a099e4620e5a128509279","7116474e2e390259937401cf928323e0cbc75e60"],"d2fa053a06c9c158f82d8e8b53b9a95031f43ebd":["054c04cf724f73ebdd3b16e3a86ce802c0ba5e37"],"21019aa828c8c9b0153877543a8b3f200bf2ca19":["9a4cf8d543027e3357024f7005523976bd6a0dfc","6220329a2333b59a34a9ecf29c003e005c861310"],"354983dcdf70c800bf2573d10b54a7391b1dc167":["d264f386d864b5751209060e8886ca9845f70469"],"9b4b4d68085809ae840a099e4620e5a128509279":["ece367783f1064f12ed72eabac9cc1afeb402b3c"],"d264f386d864b5751209060e8886ca9845f70469":["9b4b4d68085809ae840a099e4620e5a128509279"],"0d0da5c396448d1d4e5ffbd66baa3df981d3dd5e":["47d74fab5d64854ddafa81b65ed399b192f2d947"],"ece367783f1064f12ed72eabac9cc1afeb402b3c":["d2fa053a06c9c158f82d8e8b53b9a95031f43ebd"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","b851ef3570d909ec1fb99f9d35a616d8500b83c0"],"47d74fab5d64854ddafa81b65ed399b192f2d947":["b851ef3570d909ec1fb99f9d35a616d8500b83c0"],"0d1728ac6bfc0cea61f3e27436b418295d9982a3":["6220329a2333b59a34a9ecf29c003e005c861310"],"123698fbe83b595f9e084f0019cd35ab4a01d7f7":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"054c04cf724f73ebdd3b16e3a86ce802c0ba5e37":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f97fc3d287be2a8d7f513f0de3249b50dda47299":["0d0da5c396448d1d4e5ffbd66baa3df981d3dd5e"],"9a4cf8d543027e3357024f7005523976bd6a0dfc":["1e210ae1e604402eb4eeff2a52e56d189cd4f2f1"],"b851ef3570d909ec1fb99f9d35a616d8500b83c0":["0d1728ac6bfc0cea61f3e27436b418295d9982a3"],"6220329a2333b59a34a9ecf29c003e005c861310":["9a4cf8d543027e3357024f7005523976bd6a0dfc"],"1e210ae1e604402eb4eeff2a52e56d189cd4f2f1":["bdf16ebe435fc9daea90a73b8683ff001c6d3523"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f97fc3d287be2a8d7f513f0de3249b50dda47299"],"bdf16ebe435fc9daea90a73b8683ff001c6d3523":["123698fbe83b595f9e084f0019cd35ab4a01d7f7"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["123698fbe83b595f9e084f0019cd35ab4a01d7f7"],"7116474e2e390259937401cf928323e0cbc75e60":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","37a0f60745e53927c4c876cfe5b5a58170f0646c"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"d2fa053a06c9c158f82d8e8b53b9a95031f43ebd":["ece367783f1064f12ed72eabac9cc1afeb402b3c"],"21019aa828c8c9b0153877543a8b3f200bf2ca19":[],"354983dcdf70c800bf2573d10b54a7391b1dc167":["7116474e2e390259937401cf928323e0cbc75e60"],"9b4b4d68085809ae840a099e4620e5a128509279":["37a0f60745e53927c4c876cfe5b5a58170f0646c","d264f386d864b5751209060e8886ca9845f70469"],"d264f386d864b5751209060e8886ca9845f70469":["354983dcdf70c800bf2573d10b54a7391b1dc167"],"0d0da5c396448d1d4e5ffbd66baa3df981d3dd5e":["f97fc3d287be2a8d7f513f0de3249b50dda47299"],"ece367783f1064f12ed72eabac9cc1afeb402b3c":["9b4b4d68085809ae840a099e4620e5a128509279"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"47d74fab5d64854ddafa81b65ed399b192f2d947":["0d0da5c396448d1d4e5ffbd66baa3df981d3dd5e"],"0d1728ac6bfc0cea61f3e27436b418295d9982a3":["b851ef3570d909ec1fb99f9d35a616d8500b83c0"],"123698fbe83b595f9e084f0019cd35ab4a01d7f7":["bdf16ebe435fc9daea90a73b8683ff001c6d3523"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["054c04cf724f73ebdd3b16e3a86ce802c0ba5e37"],"054c04cf724f73ebdd3b16e3a86ce802c0ba5e37":["d2fa053a06c9c158f82d8e8b53b9a95031f43ebd"],"9a4cf8d543027e3357024f7005523976bd6a0dfc":["21019aa828c8c9b0153877543a8b3f200bf2ca19","6220329a2333b59a34a9ecf29c003e005c861310"],"f97fc3d287be2a8d7f513f0de3249b50dda47299":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b851ef3570d909ec1fb99f9d35a616d8500b83c0":["e9017cf144952056066919f1ebc7897ff9bd71b1","47d74fab5d64854ddafa81b65ed399b192f2d947"],"6220329a2333b59a34a9ecf29c003e005c861310":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","21019aa828c8c9b0153877543a8b3f200bf2ca19","0d1728ac6bfc0cea61f3e27436b418295d9982a3"],"1e210ae1e604402eb4eeff2a52e56d189cd4f2f1":["9a4cf8d543027e3357024f7005523976bd6a0dfc"],"bdf16ebe435fc9daea90a73b8683ff001c6d3523":["1e210ae1e604402eb4eeff2a52e56d189cd4f2f1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","21019aa828c8c9b0153877543a8b3f200bf2ca19","e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}