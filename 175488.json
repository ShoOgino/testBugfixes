{"path":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#writeIndexHeader(DataOutput,String,int,byte[],String).mjava","commits":[{"id":"3384e6013a93e4d11b7d75388693f8d0388602bf","date":1413951663,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#writeIndexHeader(DataOutput,String,int,byte[],String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#writeSegmentHeader(DataOutput,String,int,byte[],String).mjava","sourceNew":"  /**\n   * Writes a codec header for an index file, which records both a string to\n   * identify the format of the file, a version number, and data to identify\n   * the file instance (ID and auxiliary suffix such as generation).\n   * <p>\n   * This header can be parsed and validated with \n   * {@link #checkIndexHeader(DataInput, String, int, int, byte[], String) checkIndexHeader()}.\n   * <p>\n   * IndexHeader --&gt; CodecHeader,ObjectID,ObjectSuffix\n   * <ul>\n   *    <li>CodecHeader   --&gt; {@link #writeHeader}\n   *    <li>ObjectID     --&gt; {@link DataOutput#writeByte byte}<sup>16</sup>\n   *    <li>ObjectSuffix --&gt; SuffixLength,SuffixBytes\n   *    <li>SuffixLength  --&gt; {@link DataOutput#writeByte byte}\n   *    <li>SuffixBytes   --&gt; {@link DataOutput#writeByte byte}<sup>SuffixLength</sup>\n   * </ul>\n   * <p>\n   * Note that the length of an index header depends only upon the\n   * name of the codec and suffix, so this length can be computed at any time\n   * with {@link #indexHeaderLength(String,String)}.\n   * \n   * @param out Output stream\n   * @param codec String to identify the format of this file. It should be simple ASCII, \n   *              less than 128 characters in length.\n   * @param id Unique identifier for this particular file instance.\n   * @param suffix auxiliary suffix information for the file. It should be simple ASCII,\n   *              less than 256 characters in length.\n   * @param version Version number\n   * @throws IOException If there is an I/O error writing to the underlying medium.\n   * @throws IllegalArgumentException If the codec name is not simple ASCII, or \n   *         is more than 127 characters in length, or if id is invalid,\n   *         or if the suffix is not simple ASCII, or more than 255 characters\n   *         in length.\n   */\n  public static void writeIndexHeader(DataOutput out, String codec, int version, byte[] id, String suffix) throws IOException {\n    if (id.length != StringHelper.ID_LENGTH) {\n      throw new IllegalArgumentException(\"Invalid id: \" + StringHelper.idToString(id));\n    }\n    writeHeader(out, codec, version);\n    out.writeBytes(id, 0, id.length);\n    BytesRef suffixBytes = new BytesRef(suffix);\n    if (suffixBytes.length != suffix.length() || suffixBytes.length >= 256) {\n      throw new IllegalArgumentException(\"codec must be simple ASCII, less than 256 characters in length [got \" + suffix + \"]\");\n    }\n    out.writeByte((byte)suffixBytes.length);\n    out.writeBytes(suffixBytes.bytes, suffixBytes.offset, suffixBytes.length);\n  }\n\n","sourceOld":"  /**\n   * Writes a codec header for a per-segment, which records both a string to\n   * identify the file, a version number, and the unique ID of the segment. \n   * This header can be parsed and validated with \n   * {@link #checkSegmentHeader(DataInput, String, int, int, byte[], String) checkSegmentHeader()}.\n   * <p>\n   * CodecSegmentHeader --&gt; CodecHeader,SegmentID,SegmentSuffix\n   * <ul>\n   *    <li>CodecHeader   --&gt; {@link #writeHeader}\n   *    <li>SegmentID     --&gt; {@link DataOutput#writeByte byte}<sup>16</sup>\n   *    <li>SegmentSuffix --&gt; SuffixLength,SuffixBytes\n   *    <li>SuffixLength  --&gt; {@link DataOutput#writeByte byte}\n   *    <li>SuffixBytes   --&gt; {@link DataOutput#writeByte byte}<sup>SuffixLength</sup>\n   * </ul>\n   * <p>\n   * Note that the length of a segment header depends only upon the\n   * name of the codec and suffix, so this length can be computed at any time\n   * with {@link #segmentHeaderLength(String,String)}.\n   * \n   * @param out Output stream\n   * @param codec String to identify this file. It should be simple ASCII, \n   *              less than 128 characters in length.\n   * @param segmentID Unique identifier for the segment\n   * @param segmentSuffix auxiliary suffix for the file. It should be simple ASCII,\n   *              less than 256 characters in length.\n   * @param version Version number\n   * @throws IOException If there is an I/O error writing to the underlying medium.\n   * @throws IllegalArgumentException If the codec name is not simple ASCII, or \n   *         is more than 127 characters in length, or if segmentID is invalid,\n   *         or if the segmentSuffix is not simple ASCII, or more than 255 characters\n   *         in length.\n   */\n  public static void writeSegmentHeader(DataOutput out, String codec, int version, byte[] segmentID, String segmentSuffix) throws IOException {\n    if (segmentID.length != StringHelper.ID_LENGTH) {\n      throw new IllegalArgumentException(\"Invalid id: \" + StringHelper.idToString(segmentID));\n    }\n    writeHeader(out, codec, version);\n    out.writeBytes(segmentID, 0, segmentID.length);\n    BytesRef suffixBytes = new BytesRef(segmentSuffix);\n    if (suffixBytes.length != segmentSuffix.length() || suffixBytes.length >= 256) {\n      throw new IllegalArgumentException(\"codec must be simple ASCII, less than 256 characters in length [got \" + segmentSuffix + \"]\");\n    }\n    out.writeByte((byte)suffixBytes.length);\n    out.writeBytes(suffixBytes.bytes, suffixBytes.offset, suffixBytes.length);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db68c63cbfaa8698b9c4475f75ed2b9c9696d238","date":1414118621,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#writeIndexHeader(DataOutput,String,int,byte[],String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#writeSegmentHeader(DataOutput,String,int,byte[],String).mjava","sourceNew":"  /**\n   * Writes a codec header for an index file, which records both a string to\n   * identify the format of the file, a version number, and data to identify\n   * the file instance (ID and auxiliary suffix such as generation).\n   * <p>\n   * This header can be parsed and validated with \n   * {@link #checkIndexHeader(DataInput, String, int, int, byte[], String) checkIndexHeader()}.\n   * <p>\n   * IndexHeader --&gt; CodecHeader,ObjectID,ObjectSuffix\n   * <ul>\n   *    <li>CodecHeader   --&gt; {@link #writeHeader}\n   *    <li>ObjectID     --&gt; {@link DataOutput#writeByte byte}<sup>16</sup>\n   *    <li>ObjectSuffix --&gt; SuffixLength,SuffixBytes\n   *    <li>SuffixLength  --&gt; {@link DataOutput#writeByte byte}\n   *    <li>SuffixBytes   --&gt; {@link DataOutput#writeByte byte}<sup>SuffixLength</sup>\n   * </ul>\n   * <p>\n   * Note that the length of an index header depends only upon the\n   * name of the codec and suffix, so this length can be computed at any time\n   * with {@link #indexHeaderLength(String,String)}.\n   * \n   * @param out Output stream\n   * @param codec String to identify the format of this file. It should be simple ASCII, \n   *              less than 128 characters in length.\n   * @param id Unique identifier for this particular file instance.\n   * @param suffix auxiliary suffix information for the file. It should be simple ASCII,\n   *              less than 256 characters in length.\n   * @param version Version number\n   * @throws IOException If there is an I/O error writing to the underlying medium.\n   * @throws IllegalArgumentException If the codec name is not simple ASCII, or \n   *         is more than 127 characters in length, or if id is invalid,\n   *         or if the suffix is not simple ASCII, or more than 255 characters\n   *         in length.\n   */\n  public static void writeIndexHeader(DataOutput out, String codec, int version, byte[] id, String suffix) throws IOException {\n    if (id.length != StringHelper.ID_LENGTH) {\n      throw new IllegalArgumentException(\"Invalid id: \" + StringHelper.idToString(id));\n    }\n    writeHeader(out, codec, version);\n    out.writeBytes(id, 0, id.length);\n    BytesRef suffixBytes = new BytesRef(suffix);\n    if (suffixBytes.length != suffix.length() || suffixBytes.length >= 256) {\n      throw new IllegalArgumentException(\"codec must be simple ASCII, less than 256 characters in length [got \" + suffix + \"]\");\n    }\n    out.writeByte((byte)suffixBytes.length);\n    out.writeBytes(suffixBytes.bytes, suffixBytes.offset, suffixBytes.length);\n  }\n\n","sourceOld":"  /**\n   * Writes a codec header for a per-segment, which records both a string to\n   * identify the file, a version number, and the unique ID of the segment. \n   * This header can be parsed and validated with \n   * {@link #checkSegmentHeader(DataInput, String, int, int, byte[], String) checkSegmentHeader()}.\n   * <p>\n   * CodecSegmentHeader --&gt; CodecHeader,SegmentID,SegmentSuffix\n   * <ul>\n   *    <li>CodecHeader   --&gt; {@link #writeHeader}\n   *    <li>SegmentID     --&gt; {@link DataOutput#writeByte byte}<sup>16</sup>\n   *    <li>SegmentSuffix --&gt; SuffixLength,SuffixBytes\n   *    <li>SuffixLength  --&gt; {@link DataOutput#writeByte byte}\n   *    <li>SuffixBytes   --&gt; {@link DataOutput#writeByte byte}<sup>SuffixLength</sup>\n   * </ul>\n   * <p>\n   * Note that the length of a segment header depends only upon the\n   * name of the codec and suffix, so this length can be computed at any time\n   * with {@link #segmentHeaderLength(String,String)}.\n   * \n   * @param out Output stream\n   * @param codec String to identify this file. It should be simple ASCII, \n   *              less than 128 characters in length.\n   * @param segmentID Unique identifier for the segment\n   * @param segmentSuffix auxiliary suffix for the file. It should be simple ASCII,\n   *              less than 256 characters in length.\n   * @param version Version number\n   * @throws IOException If there is an I/O error writing to the underlying medium.\n   * @throws IllegalArgumentException If the codec name is not simple ASCII, or \n   *         is more than 127 characters in length, or if segmentID is invalid,\n   *         or if the segmentSuffix is not simple ASCII, or more than 255 characters\n   *         in length.\n   */\n  public static void writeSegmentHeader(DataOutput out, String codec, int version, byte[] segmentID, String segmentSuffix) throws IOException {\n    if (segmentID.length != StringHelper.ID_LENGTH) {\n      throw new IllegalArgumentException(\"Invalid id: \" + StringHelper.idToString(segmentID));\n    }\n    writeHeader(out, codec, version);\n    out.writeBytes(segmentID, 0, segmentID.length);\n    BytesRef suffixBytes = new BytesRef(segmentSuffix);\n    if (suffixBytes.length != segmentSuffix.length() || suffixBytes.length >= 256) {\n      throw new IllegalArgumentException(\"codec must be simple ASCII, less than 256 characters in length [got \" + segmentSuffix + \"]\");\n    }\n    out.writeByte((byte)suffixBytes.length);\n    out.writeBytes(suffixBytes.bytes, suffixBytes.offset, suffixBytes.length);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e8c9b351e5d925b0bda4518e5e6f824becba5515","date":1446735383,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#writeIndexHeader(DataOutput,String,int,byte[],String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#writeIndexHeader(DataOutput,String,int,byte[],String).mjava","sourceNew":"  /**\n   * Writes a codec header for an index file, which records both a string to\n   * identify the format of the file, a version number, and data to identify\n   * the file instance (ID and auxiliary suffix such as generation).\n   * <p>\n   * This header can be parsed and validated with \n   * {@link #checkIndexHeader(DataInput, String, int, int, byte[], String) checkIndexHeader()}.\n   * <p>\n   * IndexHeader --&gt; CodecHeader,ObjectID,ObjectSuffix\n   * <ul>\n   *    <li>CodecHeader   --&gt; {@link #writeHeader}\n   *    <li>ObjectID     --&gt; {@link DataOutput#writeByte byte}<sup>16</sup>\n   *    <li>ObjectSuffix --&gt; SuffixLength,SuffixBytes\n   *    <li>SuffixLength  --&gt; {@link DataOutput#writeByte byte}\n   *    <li>SuffixBytes   --&gt; {@link DataOutput#writeByte byte}<sup>SuffixLength</sup>\n   * </ul>\n   * <p>\n   * Note that the length of an index header depends only upon the\n   * name of the codec and suffix, so this length can be computed at any time\n   * with {@link #indexHeaderLength(String,String)}.\n   * \n   * @param out Output stream\n   * @param codec String to identify the format of this file. It should be simple ASCII, \n   *              less than 128 characters in length.\n   * @param id Unique identifier for this particular file instance.\n   * @param suffix auxiliary suffix information for the file. It should be simple ASCII,\n   *              less than 256 characters in length.\n   * @param version Version number\n   * @throws IOException If there is an I/O error writing to the underlying medium.\n   * @throws IllegalArgumentException If the codec name is not simple ASCII, or \n   *         is more than 127 characters in length, or if id is invalid,\n   *         or if the suffix is not simple ASCII, or more than 255 characters\n   *         in length.\n   */\n  public static void writeIndexHeader(DataOutput out, String codec, int version, byte[] id, String suffix) throws IOException {\n    if (id.length != StringHelper.ID_LENGTH) {\n      throw new IllegalArgumentException(\"Invalid id: \" + StringHelper.idToString(id));\n    }\n    writeHeader(out, codec, version);\n    out.writeBytes(id, 0, id.length);\n    BytesRef suffixBytes = new BytesRef(suffix);\n    if (suffixBytes.length != suffix.length() || suffixBytes.length >= 256) {\n      throw new IllegalArgumentException(\"suffix must be simple ASCII, less than 256 characters in length [got \" + suffix + \"]\");\n    }\n    out.writeByte((byte) suffixBytes.length);\n    out.writeBytes(suffixBytes.bytes, suffixBytes.offset, suffixBytes.length);\n  }\n\n","sourceOld":"  /**\n   * Writes a codec header for an index file, which records both a string to\n   * identify the format of the file, a version number, and data to identify\n   * the file instance (ID and auxiliary suffix such as generation).\n   * <p>\n   * This header can be parsed and validated with \n   * {@link #checkIndexHeader(DataInput, String, int, int, byte[], String) checkIndexHeader()}.\n   * <p>\n   * IndexHeader --&gt; CodecHeader,ObjectID,ObjectSuffix\n   * <ul>\n   *    <li>CodecHeader   --&gt; {@link #writeHeader}\n   *    <li>ObjectID     --&gt; {@link DataOutput#writeByte byte}<sup>16</sup>\n   *    <li>ObjectSuffix --&gt; SuffixLength,SuffixBytes\n   *    <li>SuffixLength  --&gt; {@link DataOutput#writeByte byte}\n   *    <li>SuffixBytes   --&gt; {@link DataOutput#writeByte byte}<sup>SuffixLength</sup>\n   * </ul>\n   * <p>\n   * Note that the length of an index header depends only upon the\n   * name of the codec and suffix, so this length can be computed at any time\n   * with {@link #indexHeaderLength(String,String)}.\n   * \n   * @param out Output stream\n   * @param codec String to identify the format of this file. It should be simple ASCII, \n   *              less than 128 characters in length.\n   * @param id Unique identifier for this particular file instance.\n   * @param suffix auxiliary suffix information for the file. It should be simple ASCII,\n   *              less than 256 characters in length.\n   * @param version Version number\n   * @throws IOException If there is an I/O error writing to the underlying medium.\n   * @throws IllegalArgumentException If the codec name is not simple ASCII, or \n   *         is more than 127 characters in length, or if id is invalid,\n   *         or if the suffix is not simple ASCII, or more than 255 characters\n   *         in length.\n   */\n  public static void writeIndexHeader(DataOutput out, String codec, int version, byte[] id, String suffix) throws IOException {\n    if (id.length != StringHelper.ID_LENGTH) {\n      throw new IllegalArgumentException(\"Invalid id: \" + StringHelper.idToString(id));\n    }\n    writeHeader(out, codec, version);\n    out.writeBytes(id, 0, id.length);\n    BytesRef suffixBytes = new BytesRef(suffix);\n    if (suffixBytes.length != suffix.length() || suffixBytes.length >= 256) {\n      throw new IllegalArgumentException(\"codec must be simple ASCII, less than 256 characters in length [got \" + suffix + \"]\");\n    }\n    out.writeByte((byte)suffixBytes.length);\n    out.writeBytes(suffixBytes.bytes, suffixBytes.offset, suffixBytes.length);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3384e6013a93e4d11b7d75388693f8d0388602bf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3384e6013a93e4d11b7d75388693f8d0388602bf"],"e8c9b351e5d925b0bda4518e5e6f824becba5515":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e8c9b351e5d925b0bda4518e5e6f824becba5515"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3384e6013a93e4d11b7d75388693f8d0388602bf","db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"3384e6013a93e4d11b7d75388693f8d0388602bf":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["e8c9b351e5d925b0bda4518e5e6f824becba5515"],"e8c9b351e5d925b0bda4518e5e6f824becba5515":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}