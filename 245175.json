{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/SplitShardCmd#cleanupAfterFailure(ZkStateReader,String,String,List[String],Set[String]).mjava","commits":[{"id":"20c968c14aace7cf49843bf2c1fafc7fd3845659","date":1533133859,"type":1,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/SplitShardCmd#cleanupAfterFailure(ZkStateReader,String,String,List[String],Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/SplitShardCmd#cleanupAfterFailure(ZkStateReader,String,String,List[String]).mjava","sourceNew":"  private void cleanupAfterFailure(ZkStateReader zkStateReader, String collectionName, String parentShard,\n                                   List<String> subSlices, Set<String> offlineSlices) {\n    log.info(\"Cleaning up after a failed split of \" + collectionName + \"/\" + parentShard);\n    // get the latest state\n    try {\n      zkStateReader.forceUpdateCollection(collectionName);\n    } catch (KeeperException | InterruptedException e) {\n      log.warn(\"Cleanup failed after failed split of \" + collectionName + \"/\" + parentShard + \": (force update collection)\", e);\n      return;\n    }\n    ClusterState clusterState = zkStateReader.getClusterState();\n    DocCollection coll = clusterState.getCollectionOrNull(collectionName);\n\n    if (coll == null) { // may have been deleted\n      return;\n    }\n\n    // set already created sub shards states to CONSTRUCTION - this prevents them\n    // from entering into RECOVERY or ACTIVE (SOLR-9455)\n    DistributedQueue inQueue = Overseer.getStateUpdateQueue(zkStateReader.getZkClient());\n    final Map<String, Object> propMap = new HashMap<>();\n    boolean sendUpdateState = false;\n    propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n    propMap.put(ZkStateReader.COLLECTION_PROP, collectionName);\n    for (Slice s : coll.getSlices()) {\n      if (!subSlices.contains(s.getName())) {\n        continue;\n      }\n      propMap.put(s.getName(), Slice.State.CONSTRUCTION.toString());\n      sendUpdateState = true;\n    }\n\n    // if parent is inactive activate it again\n    Slice parentSlice = coll.getSlice(parentShard);\n    if (parentSlice.getState() == Slice.State.INACTIVE) {\n      sendUpdateState = true;\n      propMap.put(parentShard, Slice.State.ACTIVE.toString());\n    }\n    // plus any other previously deactivated slices\n    for (String sliceName : offlineSlices) {\n      propMap.put(sliceName, Slice.State.ACTIVE.toString());\n      sendUpdateState = true;\n    }\n\n    if (sendUpdateState) {\n      try {\n        ZkNodeProps m = new ZkNodeProps(propMap);\n        inQueue.offer(Utils.toJSON(m));\n      } catch (Exception e) {\n        // don't give up yet - just log the error, we may still be able to clean up\n        log.warn(\"Cleanup failed after failed split of \" + collectionName + \"/\" + parentShard + \": (slice state changes)\", e);\n      }\n    }\n\n    // delete existing subShards\n    for (String subSlice : subSlices) {\n      Slice s = coll.getSlice(subSlice);\n      if (s == null) {\n        continue;\n      }\n      log.debug(\"- sub-shard: {} exists therefore requesting its deletion\", subSlice);\n      HashMap<String, Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"deleteshard\");\n      props.put(COLLECTION_PROP, collectionName);\n      props.put(SHARD_ID_PROP, subSlice);\n      ZkNodeProps m = new ZkNodeProps(props);\n      try {\n        ocmh.commandMap.get(DELETESHARD).call(clusterState, m, new NamedList());\n      } catch (Exception e) {\n        log.warn(\"Cleanup failed after failed split of \" + collectionName + \"/\" + parentShard + \": (deleting existing sub shard \" + subSlice + \")\", e);\n      }\n    }\n  }\n\n","sourceOld":"  private void cleanupAfterFailure(ZkStateReader zkStateReader, String collectionName, String parentShard, List<String> subSlices) {\n    log.debug(\"- cleanup after failed split of \" + collectionName + \"/\" + parentShard);\n    // get the latest state\n    try {\n      zkStateReader.forceUpdateCollection(collectionName);\n    } catch (KeeperException | InterruptedException e) {\n      log.warn(\"Cleanup after failed split of \" + collectionName + \"/\" + parentShard + \": (force update collection)\", e);\n      return;\n    }\n    ClusterState clusterState = zkStateReader.getClusterState();\n    DocCollection coll = clusterState.getCollectionOrNull(collectionName);\n\n    if (coll == null) { // may have been deleted\n      return;\n    }\n\n    // set already created sub shards states to CONSTRUCTION - this prevents them\n    // from entering into RECOVERY or ACTIVE (SOLR-9455)\n    DistributedQueue inQueue = Overseer.getStateUpdateQueue(zkStateReader.getZkClient());\n    Map<String, Object> propMap = new HashMap<>();\n    propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n    propMap.put(ZkStateReader.COLLECTION_PROP, collectionName);\n    for (Slice s : coll.getSlices()) {\n      if (!subSlices.contains(s.getName())) {\n        continue;\n      }\n      propMap.put(s.getName(), Slice.State.CONSTRUCTION.toString());\n    }\n\n    // if parent is inactive activate it again\n    Slice parentSlice = coll.getSlice(parentShard);\n    if (parentSlice.getState() == Slice.State.INACTIVE) {\n      propMap.put(parentShard, Slice.State.ACTIVE.toString());\n    }\n\n    try {\n      ZkNodeProps m = new ZkNodeProps(propMap);\n      inQueue.offer(Utils.toJSON(m));\n    } catch (Exception e) {\n      // don't give up yet - just log the error, we may still be able to clean up\n      log.warn(\"Cleanup after failed split of \" + collectionName + \"/\" + parentShard + \": (slice state changes)\", e);\n    }\n\n    // delete existing subShards\n    for (String subSlice : subSlices) {\n      Slice s = coll.getSlice(subSlice);\n      if (s == null) {\n        continue;\n      }\n      log.info(\"Sub-shard: {} already exists therefore requesting its deletion\", subSlice);\n      propMap = new HashMap<>();\n      propMap.put(Overseer.QUEUE_OPERATION, \"deleteshard\");\n      propMap.put(COLLECTION_PROP, collectionName);\n      propMap.put(SHARD_ID_PROP, subSlice);\n      ZkNodeProps m = new ZkNodeProps(propMap);\n      try {\n        ocmh.commandMap.get(DELETESHARD).call(clusterState, m, new NamedList());\n      } catch (Exception e) {\n        log.warn(\"Cleanup after failed split of \" + collectionName + \"/\" + parentShard + \": (deleting existing sub shard \" + subSlice + \")\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/SplitShardCmd#cleanupAfterFailure(ZkStateReader,String,String,List[String],Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/SplitShardCmd#cleanupAfterFailure(ZkStateReader,String,String,List[String],Set[String]).mjava","sourceNew":"  private void cleanupAfterFailure(ZkStateReader zkStateReader, String collectionName, String parentShard,\n                                   List<String> subSlices, Set<String> offlineSlices) {\n    log.info(\"Cleaning up after a failed split of \" + collectionName + \"/\" + parentShard);\n    // get the latest state\n    try {\n      zkStateReader.forceUpdateCollection(collectionName);\n    } catch (KeeperException | InterruptedException e) {\n      log.warn(\"Cleanup failed after failed split of \" + collectionName + \"/\" + parentShard + \": (force update collection)\", e);\n      return;\n    }\n    ClusterState clusterState = zkStateReader.getClusterState();\n    DocCollection coll = clusterState.getCollectionOrNull(collectionName);\n\n    if (coll == null) { // may have been deleted\n      return;\n    }\n\n    // set already created sub shards states to CONSTRUCTION - this prevents them\n    // from entering into RECOVERY or ACTIVE (SOLR-9455)\n    final Map<String, Object> propMap = new HashMap<>();\n    boolean sendUpdateState = false;\n    propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n    propMap.put(ZkStateReader.COLLECTION_PROP, collectionName);\n    for (Slice s : coll.getSlices()) {\n      if (!subSlices.contains(s.getName())) {\n        continue;\n      }\n      propMap.put(s.getName(), Slice.State.CONSTRUCTION.toString());\n      sendUpdateState = true;\n    }\n\n    // if parent is inactive activate it again\n    Slice parentSlice = coll.getSlice(parentShard);\n    if (parentSlice.getState() == Slice.State.INACTIVE) {\n      sendUpdateState = true;\n      propMap.put(parentShard, Slice.State.ACTIVE.toString());\n    }\n    // plus any other previously deactivated slices\n    for (String sliceName : offlineSlices) {\n      propMap.put(sliceName, Slice.State.ACTIVE.toString());\n      sendUpdateState = true;\n    }\n\n    if (sendUpdateState) {\n      try {\n        ZkNodeProps m = new ZkNodeProps(propMap);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n      } catch (Exception e) {\n        // don't give up yet - just log the error, we may still be able to clean up\n        log.warn(\"Cleanup failed after failed split of \" + collectionName + \"/\" + parentShard + \": (slice state changes)\", e);\n      }\n    }\n\n    // delete existing subShards\n    for (String subSlice : subSlices) {\n      Slice s = coll.getSlice(subSlice);\n      if (s == null) {\n        continue;\n      }\n      log.debug(\"- sub-shard: {} exists therefore requesting its deletion\", subSlice);\n      HashMap<String, Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"deleteshard\");\n      props.put(COLLECTION_PROP, collectionName);\n      props.put(SHARD_ID_PROP, subSlice);\n      ZkNodeProps m = new ZkNodeProps(props);\n      try {\n        ocmh.commandMap.get(DELETESHARD).call(clusterState, m, new NamedList());\n      } catch (Exception e) {\n        log.warn(\"Cleanup failed after failed split of \" + collectionName + \"/\" + parentShard + \": (deleting existing sub shard \" + subSlice + \")\", e);\n      }\n    }\n  }\n\n","sourceOld":"  private void cleanupAfterFailure(ZkStateReader zkStateReader, String collectionName, String parentShard,\n                                   List<String> subSlices, Set<String> offlineSlices) {\n    log.info(\"Cleaning up after a failed split of \" + collectionName + \"/\" + parentShard);\n    // get the latest state\n    try {\n      zkStateReader.forceUpdateCollection(collectionName);\n    } catch (KeeperException | InterruptedException e) {\n      log.warn(\"Cleanup failed after failed split of \" + collectionName + \"/\" + parentShard + \": (force update collection)\", e);\n      return;\n    }\n    ClusterState clusterState = zkStateReader.getClusterState();\n    DocCollection coll = clusterState.getCollectionOrNull(collectionName);\n\n    if (coll == null) { // may have been deleted\n      return;\n    }\n\n    // set already created sub shards states to CONSTRUCTION - this prevents them\n    // from entering into RECOVERY or ACTIVE (SOLR-9455)\n    DistributedQueue inQueue = Overseer.getStateUpdateQueue(zkStateReader.getZkClient());\n    final Map<String, Object> propMap = new HashMap<>();\n    boolean sendUpdateState = false;\n    propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n    propMap.put(ZkStateReader.COLLECTION_PROP, collectionName);\n    for (Slice s : coll.getSlices()) {\n      if (!subSlices.contains(s.getName())) {\n        continue;\n      }\n      propMap.put(s.getName(), Slice.State.CONSTRUCTION.toString());\n      sendUpdateState = true;\n    }\n\n    // if parent is inactive activate it again\n    Slice parentSlice = coll.getSlice(parentShard);\n    if (parentSlice.getState() == Slice.State.INACTIVE) {\n      sendUpdateState = true;\n      propMap.put(parentShard, Slice.State.ACTIVE.toString());\n    }\n    // plus any other previously deactivated slices\n    for (String sliceName : offlineSlices) {\n      propMap.put(sliceName, Slice.State.ACTIVE.toString());\n      sendUpdateState = true;\n    }\n\n    if (sendUpdateState) {\n      try {\n        ZkNodeProps m = new ZkNodeProps(propMap);\n        inQueue.offer(Utils.toJSON(m));\n      } catch (Exception e) {\n        // don't give up yet - just log the error, we may still be able to clean up\n        log.warn(\"Cleanup failed after failed split of \" + collectionName + \"/\" + parentShard + \": (slice state changes)\", e);\n      }\n    }\n\n    // delete existing subShards\n    for (String subSlice : subSlices) {\n      Slice s = coll.getSlice(subSlice);\n      if (s == null) {\n        continue;\n      }\n      log.debug(\"- sub-shard: {} exists therefore requesting its deletion\", subSlice);\n      HashMap<String, Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"deleteshard\");\n      props.put(COLLECTION_PROP, collectionName);\n      props.put(SHARD_ID_PROP, subSlice);\n      ZkNodeProps m = new ZkNodeProps(props);\n      try {\n        ocmh.commandMap.get(DELETESHARD).call(clusterState, m, new NamedList());\n      } catch (Exception e) {\n        log.warn(\"Cleanup failed after failed split of \" + collectionName + \"/\" + parentShard + \": (deleting existing sub shard \" + subSlice + \")\", e);\n      }\n    }\n  }\n\n","bugFix":["20c968c14aace7cf49843bf2c1fafc7fd3845659"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"69e6520a21709190413a63084ed135271aab1a7c","date":1556607462,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/SplitShardCmd#cleanupAfterFailure(ZkStateReader,String,String,List[String],Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/SplitShardCmd#cleanupAfterFailure(ZkStateReader,String,String,List[String],Set[String]).mjava","sourceNew":"  private void cleanupAfterFailure(ZkStateReader zkStateReader, String collectionName, String parentShard,\n                                   List<String> subSlices, Set<String> offlineSlices) {\n    log.info(\"Cleaning up after a failed split of \" + collectionName + \"/\" + parentShard);\n    // get the latest state\n    try {\n      zkStateReader.forceUpdateCollection(collectionName);\n    } catch (KeeperException | InterruptedException e) {\n      log.warn(\"Cleanup failed after failed split of \" + collectionName + \"/\" + parentShard + \": (force update collection)\", e);\n      return;\n    }\n    ClusterState clusterState = zkStateReader.getClusterState();\n    DocCollection coll = clusterState.getCollectionOrNull(collectionName);\n\n    if (coll == null) { // may have been deleted\n      return;\n    }\n\n    // set already created sub shards states to CONSTRUCTION - this prevents them\n    // from entering into RECOVERY or ACTIVE (SOLR-9455)\n    final Map<String, Object> propMap = new HashMap<>();\n    boolean sendUpdateState = false;\n    propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n    propMap.put(ZkStateReader.COLLECTION_PROP, collectionName);\n    for (Slice s : coll.getSlices()) {\n      if (!subSlices.contains(s.getName())) {\n        continue;\n      }\n      propMap.put(s.getName(), Slice.State.CONSTRUCTION.toString());\n      sendUpdateState = true;\n    }\n\n    // if parent is inactive activate it again\n    Slice parentSlice = coll.getSlice(parentShard);\n    if (parentSlice.getState() == Slice.State.INACTIVE) {\n      sendUpdateState = true;\n      propMap.put(parentShard, Slice.State.ACTIVE.toString());\n    }\n    // plus any other previously deactivated slices\n    for (String sliceName : offlineSlices) {\n      propMap.put(sliceName, Slice.State.ACTIVE.toString());\n      sendUpdateState = true;\n    }\n\n    if (sendUpdateState) {\n      try {\n        ZkNodeProps m = new ZkNodeProps(propMap);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n      } catch (Exception e) {\n        // don't give up yet - just log the error, we may still be able to clean up\n        log.warn(\"Cleanup failed after failed split of \" + collectionName + \"/\" + parentShard + \": (slice state changes)\", e);\n      }\n    }\n\n    // delete existing subShards\n    for (String subSlice : subSlices) {\n      Slice s = coll.getSlice(subSlice);\n      if (s == null) {\n        continue;\n      }\n      log.debug(\"- sub-shard: {} exists therefore requesting its deletion\", subSlice);\n      HashMap<String, Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"deleteshard\");\n      props.put(COLLECTION_PROP, collectionName);\n      props.put(SHARD_ID_PROP, subSlice);\n      ZkNodeProps m = new ZkNodeProps(props);\n      try {\n        ocmh.commandMap.get(DELETESHARD).call(clusterState, m, new NamedList<Object>());\n      } catch (Exception e) {\n        log.warn(\"Cleanup failed after failed split of \" + collectionName + \"/\" + parentShard + \": (deleting existing sub shard \" + subSlice + \")\", e);\n      }\n    }\n  }\n\n","sourceOld":"  private void cleanupAfterFailure(ZkStateReader zkStateReader, String collectionName, String parentShard,\n                                   List<String> subSlices, Set<String> offlineSlices) {\n    log.info(\"Cleaning up after a failed split of \" + collectionName + \"/\" + parentShard);\n    // get the latest state\n    try {\n      zkStateReader.forceUpdateCollection(collectionName);\n    } catch (KeeperException | InterruptedException e) {\n      log.warn(\"Cleanup failed after failed split of \" + collectionName + \"/\" + parentShard + \": (force update collection)\", e);\n      return;\n    }\n    ClusterState clusterState = zkStateReader.getClusterState();\n    DocCollection coll = clusterState.getCollectionOrNull(collectionName);\n\n    if (coll == null) { // may have been deleted\n      return;\n    }\n\n    // set already created sub shards states to CONSTRUCTION - this prevents them\n    // from entering into RECOVERY or ACTIVE (SOLR-9455)\n    final Map<String, Object> propMap = new HashMap<>();\n    boolean sendUpdateState = false;\n    propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n    propMap.put(ZkStateReader.COLLECTION_PROP, collectionName);\n    for (Slice s : coll.getSlices()) {\n      if (!subSlices.contains(s.getName())) {\n        continue;\n      }\n      propMap.put(s.getName(), Slice.State.CONSTRUCTION.toString());\n      sendUpdateState = true;\n    }\n\n    // if parent is inactive activate it again\n    Slice parentSlice = coll.getSlice(parentShard);\n    if (parentSlice.getState() == Slice.State.INACTIVE) {\n      sendUpdateState = true;\n      propMap.put(parentShard, Slice.State.ACTIVE.toString());\n    }\n    // plus any other previously deactivated slices\n    for (String sliceName : offlineSlices) {\n      propMap.put(sliceName, Slice.State.ACTIVE.toString());\n      sendUpdateState = true;\n    }\n\n    if (sendUpdateState) {\n      try {\n        ZkNodeProps m = new ZkNodeProps(propMap);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n      } catch (Exception e) {\n        // don't give up yet - just log the error, we may still be able to clean up\n        log.warn(\"Cleanup failed after failed split of \" + collectionName + \"/\" + parentShard + \": (slice state changes)\", e);\n      }\n    }\n\n    // delete existing subShards\n    for (String subSlice : subSlices) {\n      Slice s = coll.getSlice(subSlice);\n      if (s == null) {\n        continue;\n      }\n      log.debug(\"- sub-shard: {} exists therefore requesting its deletion\", subSlice);\n      HashMap<String, Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"deleteshard\");\n      props.put(COLLECTION_PROP, collectionName);\n      props.put(SHARD_ID_PROP, subSlice);\n      ZkNodeProps m = new ZkNodeProps(props);\n      try {\n        ocmh.commandMap.get(DELETESHARD).call(clusterState, m, new NamedList());\n      } catch (Exception e) {\n        log.warn(\"Cleanup failed after failed split of \" + collectionName + \"/\" + parentShard + \": (deleting existing sub shard \" + subSlice + \")\", e);\n      }\n    }\n  }\n\n","bugFix":["20c968c14aace7cf49843bf2c1fafc7fd3845659"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8a8f0700353755635a948651e84c152bff39d8dc","date":1576121314,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/SplitShardCmd#cleanupAfterFailure(ZkStateReader,String,String,List[String],Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/SplitShardCmd#cleanupAfterFailure(ZkStateReader,String,String,List[String],Set[String]).mjava","sourceNew":"  private void cleanupAfterFailure(ZkStateReader zkStateReader, String collectionName, String parentShard,\n                                   List<String> subSlices, Set<String> offlineSlices) {\n    log.info(\"Cleaning up after a failed split of \" + collectionName + \"/\" + parentShard);\n    // get the latest state\n    try {\n      zkStateReader.forceUpdateCollection(collectionName);\n    } catch (KeeperException | InterruptedException e) {\n      log.warn(\"Cleanup failed after failed split of \" + collectionName + \"/\" + parentShard + \": (force update collection)\", e);\n      return;\n    }\n    ClusterState clusterState = zkStateReader.getClusterState();\n    DocCollection coll = clusterState.getCollectionOrNull(collectionName);\n\n    if (coll == null) { // may have been deleted\n      return;\n    }\n\n    // If parent is inactive and all sub shards are active, then rolling back\n    // to make the parent active again will cause data loss.\n    if (coll.getSlice(parentShard).getState() == Slice.State.INACTIVE) {\n      boolean allSubSlicesActive = true;\n      for (String sub: subSlices) {\n        if (coll.getSlice(sub).getState() != Slice.State.ACTIVE) {\n          allSubSlicesActive = false;\n          break;\n        }\n      }\n      if (allSubSlicesActive) {\n        return;\n      }\n    }\n\n    // set already created sub shards states to CONSTRUCTION - this prevents them\n    // from entering into RECOVERY or ACTIVE (SOLR-9455)\n    final Map<String, Object> propMap = new HashMap<>();\n    boolean sendUpdateState = false;\n    propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n    propMap.put(ZkStateReader.COLLECTION_PROP, collectionName);\n    for (Slice s : coll.getSlices()) {\n      if (!subSlices.contains(s.getName())) {\n        continue;\n      }\n      propMap.put(s.getName(), Slice.State.CONSTRUCTION.toString());\n      sendUpdateState = true;\n    }\n\n    // if parent is inactive activate it again\n    Slice parentSlice = coll.getSlice(parentShard);\n    if (parentSlice.getState() == Slice.State.INACTIVE) {\n      sendUpdateState = true;\n      propMap.put(parentShard, Slice.State.ACTIVE.toString());\n    }\n    // plus any other previously deactivated slices\n    for (String sliceName : offlineSlices) {\n      propMap.put(sliceName, Slice.State.ACTIVE.toString());\n      sendUpdateState = true;\n    }\n\n    if (sendUpdateState) {\n      try {\n        ZkNodeProps m = new ZkNodeProps(propMap);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n      } catch (Exception e) {\n        // don't give up yet - just log the error, we may still be able to clean up\n        log.warn(\"Cleanup failed after failed split of \" + collectionName + \"/\" + parentShard + \": (slice state changes)\", e);\n      }\n    }\n\n    // delete existing subShards\n    for (String subSlice : subSlices) {\n      Slice s = coll.getSlice(subSlice);\n      if (s == null) {\n        continue;\n      }\n      log.debug(\"- sub-shard: {} exists therefore requesting its deletion\", subSlice);\n      HashMap<String, Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"deleteshard\");\n      props.put(COLLECTION_PROP, collectionName);\n      props.put(SHARD_ID_PROP, subSlice);\n      ZkNodeProps m = new ZkNodeProps(props);\n      try {\n        ocmh.commandMap.get(DELETESHARD).call(clusterState, m, new NamedList<Object>());\n      } catch (Exception e) {\n        log.warn(\"Cleanup failed after failed split of \" + collectionName + \"/\" + parentShard + \": (deleting existing sub shard \" + subSlice + \")\", e);\n      }\n    }\n  }\n\n","sourceOld":"  private void cleanupAfterFailure(ZkStateReader zkStateReader, String collectionName, String parentShard,\n                                   List<String> subSlices, Set<String> offlineSlices) {\n    log.info(\"Cleaning up after a failed split of \" + collectionName + \"/\" + parentShard);\n    // get the latest state\n    try {\n      zkStateReader.forceUpdateCollection(collectionName);\n    } catch (KeeperException | InterruptedException e) {\n      log.warn(\"Cleanup failed after failed split of \" + collectionName + \"/\" + parentShard + \": (force update collection)\", e);\n      return;\n    }\n    ClusterState clusterState = zkStateReader.getClusterState();\n    DocCollection coll = clusterState.getCollectionOrNull(collectionName);\n\n    if (coll == null) { // may have been deleted\n      return;\n    }\n\n    // set already created sub shards states to CONSTRUCTION - this prevents them\n    // from entering into RECOVERY or ACTIVE (SOLR-9455)\n    final Map<String, Object> propMap = new HashMap<>();\n    boolean sendUpdateState = false;\n    propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n    propMap.put(ZkStateReader.COLLECTION_PROP, collectionName);\n    for (Slice s : coll.getSlices()) {\n      if (!subSlices.contains(s.getName())) {\n        continue;\n      }\n      propMap.put(s.getName(), Slice.State.CONSTRUCTION.toString());\n      sendUpdateState = true;\n    }\n\n    // if parent is inactive activate it again\n    Slice parentSlice = coll.getSlice(parentShard);\n    if (parentSlice.getState() == Slice.State.INACTIVE) {\n      sendUpdateState = true;\n      propMap.put(parentShard, Slice.State.ACTIVE.toString());\n    }\n    // plus any other previously deactivated slices\n    for (String sliceName : offlineSlices) {\n      propMap.put(sliceName, Slice.State.ACTIVE.toString());\n      sendUpdateState = true;\n    }\n\n    if (sendUpdateState) {\n      try {\n        ZkNodeProps m = new ZkNodeProps(propMap);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n      } catch (Exception e) {\n        // don't give up yet - just log the error, we may still be able to clean up\n        log.warn(\"Cleanup failed after failed split of \" + collectionName + \"/\" + parentShard + \": (slice state changes)\", e);\n      }\n    }\n\n    // delete existing subShards\n    for (String subSlice : subSlices) {\n      Slice s = coll.getSlice(subSlice);\n      if (s == null) {\n        continue;\n      }\n      log.debug(\"- sub-shard: {} exists therefore requesting its deletion\", subSlice);\n      HashMap<String, Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"deleteshard\");\n      props.put(COLLECTION_PROP, collectionName);\n      props.put(SHARD_ID_PROP, subSlice);\n      ZkNodeProps m = new ZkNodeProps(props);\n      try {\n        ocmh.commandMap.get(DELETESHARD).call(clusterState, m, new NamedList<Object>());\n      } catch (Exception e) {\n        log.warn(\"Cleanup failed after failed split of \" + collectionName + \"/\" + parentShard + \": (deleting existing sub shard \" + subSlice + \")\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df724d84dab24a0cc54bec95a8680867adc7f171","date":1576156608,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/SplitShardCmd#cleanupAfterFailure(ZkStateReader,String,String,List[String],Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/SplitShardCmd#cleanupAfterFailure(ZkStateReader,String,String,List[String],Set[String]).mjava","sourceNew":"  private void cleanupAfterFailure(ZkStateReader zkStateReader, String collectionName, String parentShard,\n                                   List<String> subSlices, Set<String> offlineSlices) {\n    log.info(\"Cleaning up after a failed split of \" + collectionName + \"/\" + parentShard);\n    // get the latest state\n    try {\n      zkStateReader.forceUpdateCollection(collectionName);\n    } catch (KeeperException | InterruptedException e) {\n      log.warn(\"Cleanup failed after failed split of \" + collectionName + \"/\" + parentShard + \": (force update collection)\", e);\n      return;\n    }\n    ClusterState clusterState = zkStateReader.getClusterState();\n    DocCollection coll = clusterState.getCollectionOrNull(collectionName);\n\n    if (coll == null) { // may have been deleted\n      return;\n    }\n\n    // If parent is inactive and all sub shards are active, then rolling back\n    // to make the parent active again will cause data loss.\n    if (coll.getSlice(parentShard).getState() == Slice.State.INACTIVE) {\n      boolean allSubSlicesActive = true;\n      for (String sub: subSlices) {\n        if (coll.getSlice(sub).getState() != Slice.State.ACTIVE) {\n          allSubSlicesActive = false;\n          break;\n        }\n      }\n      if (allSubSlicesActive) {\n        return;\n      }\n    }\n\n    // set already created sub shards states to CONSTRUCTION - this prevents them\n    // from entering into RECOVERY or ACTIVE (SOLR-9455)\n    final Map<String, Object> propMap = new HashMap<>();\n    boolean sendUpdateState = false;\n    propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n    propMap.put(ZkStateReader.COLLECTION_PROP, collectionName);\n    for (Slice s : coll.getSlices()) {\n      if (!subSlices.contains(s.getName())) {\n        continue;\n      }\n      propMap.put(s.getName(), Slice.State.CONSTRUCTION.toString());\n      sendUpdateState = true;\n    }\n\n    // if parent is inactive activate it again\n    Slice parentSlice = coll.getSlice(parentShard);\n    if (parentSlice.getState() == Slice.State.INACTIVE) {\n      sendUpdateState = true;\n      propMap.put(parentShard, Slice.State.ACTIVE.toString());\n    }\n    // plus any other previously deactivated slices\n    for (String sliceName : offlineSlices) {\n      propMap.put(sliceName, Slice.State.ACTIVE.toString());\n      sendUpdateState = true;\n    }\n\n    if (sendUpdateState) {\n      try {\n        ZkNodeProps m = new ZkNodeProps(propMap);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n      } catch (Exception e) {\n        // don't give up yet - just log the error, we may still be able to clean up\n        log.warn(\"Cleanup failed after failed split of \" + collectionName + \"/\" + parentShard + \": (slice state changes)\", e);\n      }\n    }\n\n    // delete existing subShards\n    for (String subSlice : subSlices) {\n      Slice s = coll.getSlice(subSlice);\n      if (s == null) {\n        continue;\n      }\n      log.debug(\"- sub-shard: {} exists therefore requesting its deletion\", subSlice);\n      HashMap<String, Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"deleteshard\");\n      props.put(COLLECTION_PROP, collectionName);\n      props.put(SHARD_ID_PROP, subSlice);\n      ZkNodeProps m = new ZkNodeProps(props);\n      try {\n        ocmh.commandMap.get(DELETESHARD).call(clusterState, m, new NamedList<Object>());\n      } catch (Exception e) {\n        log.warn(\"Cleanup failed after failed split of \" + collectionName + \"/\" + parentShard + \": (deleting existing sub shard \" + subSlice + \")\", e);\n      }\n    }\n  }\n\n","sourceOld":"  private void cleanupAfterFailure(ZkStateReader zkStateReader, String collectionName, String parentShard,\n                                   List<String> subSlices, Set<String> offlineSlices) {\n    log.info(\"Cleaning up after a failed split of \" + collectionName + \"/\" + parentShard);\n    // get the latest state\n    try {\n      zkStateReader.forceUpdateCollection(collectionName);\n    } catch (KeeperException | InterruptedException e) {\n      log.warn(\"Cleanup failed after failed split of \" + collectionName + \"/\" + parentShard + \": (force update collection)\", e);\n      return;\n    }\n    ClusterState clusterState = zkStateReader.getClusterState();\n    DocCollection coll = clusterState.getCollectionOrNull(collectionName);\n\n    if (coll == null) { // may have been deleted\n      return;\n    }\n\n    // set already created sub shards states to CONSTRUCTION - this prevents them\n    // from entering into RECOVERY or ACTIVE (SOLR-9455)\n    final Map<String, Object> propMap = new HashMap<>();\n    boolean sendUpdateState = false;\n    propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n    propMap.put(ZkStateReader.COLLECTION_PROP, collectionName);\n    for (Slice s : coll.getSlices()) {\n      if (!subSlices.contains(s.getName())) {\n        continue;\n      }\n      propMap.put(s.getName(), Slice.State.CONSTRUCTION.toString());\n      sendUpdateState = true;\n    }\n\n    // if parent is inactive activate it again\n    Slice parentSlice = coll.getSlice(parentShard);\n    if (parentSlice.getState() == Slice.State.INACTIVE) {\n      sendUpdateState = true;\n      propMap.put(parentShard, Slice.State.ACTIVE.toString());\n    }\n    // plus any other previously deactivated slices\n    for (String sliceName : offlineSlices) {\n      propMap.put(sliceName, Slice.State.ACTIVE.toString());\n      sendUpdateState = true;\n    }\n\n    if (sendUpdateState) {\n      try {\n        ZkNodeProps m = new ZkNodeProps(propMap);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n      } catch (Exception e) {\n        // don't give up yet - just log the error, we may still be able to clean up\n        log.warn(\"Cleanup failed after failed split of \" + collectionName + \"/\" + parentShard + \": (slice state changes)\", e);\n      }\n    }\n\n    // delete existing subShards\n    for (String subSlice : subSlices) {\n      Slice s = coll.getSlice(subSlice);\n      if (s == null) {\n        continue;\n      }\n      log.debug(\"- sub-shard: {} exists therefore requesting its deletion\", subSlice);\n      HashMap<String, Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"deleteshard\");\n      props.put(COLLECTION_PROP, collectionName);\n      props.put(SHARD_ID_PROP, subSlice);\n      ZkNodeProps m = new ZkNodeProps(props);\n      try {\n        ocmh.commandMap.get(DELETESHARD).call(clusterState, m, new NamedList<Object>());\n      } catch (Exception e) {\n        log.warn(\"Cleanup failed after failed split of \" + collectionName + \"/\" + parentShard + \": (deleting existing sub shard \" + subSlice + \")\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4abf821a41a2fdca2a1dea148999931d22e20529","date":1587749643,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/SplitShardCmd#cleanupAfterFailure(ZkStateReader,String,String,List[String],Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/SplitShardCmd#cleanupAfterFailure(ZkStateReader,String,String,List[String],Set[String]).mjava","sourceNew":"  private void cleanupAfterFailure(ZkStateReader zkStateReader, String collectionName, String parentShard,\n                                   List<String> subSlices, Set<String> offlineSlices) {\n    log.info(\"Cleaning up after a failed split of {}/{}\", collectionName, parentShard);\n    // get the latest state\n    try {\n      zkStateReader.forceUpdateCollection(collectionName);\n    } catch (KeeperException | InterruptedException e) {\n      log.warn(\"Cleanup failed after failed split of {}/{} : (force update collection)\", collectionName, parentShard, e);\n      return;\n    }\n    ClusterState clusterState = zkStateReader.getClusterState();\n    DocCollection coll = clusterState.getCollectionOrNull(collectionName);\n\n    if (coll == null) { // may have been deleted\n      return;\n    }\n\n    // If parent is inactive and all sub shards are active, then rolling back\n    // to make the parent active again will cause data loss.\n    if (coll.getSlice(parentShard).getState() == Slice.State.INACTIVE) {\n      boolean allSubSlicesActive = true;\n      for (String sub: subSlices) {\n        if (coll.getSlice(sub).getState() != Slice.State.ACTIVE) {\n          allSubSlicesActive = false;\n          break;\n        }\n      }\n      if (allSubSlicesActive) {\n        return;\n      }\n    }\n\n    // set already created sub shards states to CONSTRUCTION - this prevents them\n    // from entering into RECOVERY or ACTIVE (SOLR-9455)\n    final Map<String, Object> propMap = new HashMap<>();\n    boolean sendUpdateState = false;\n    propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n    propMap.put(ZkStateReader.COLLECTION_PROP, collectionName);\n    for (Slice s : coll.getSlices()) {\n      if (!subSlices.contains(s.getName())) {\n        continue;\n      }\n      propMap.put(s.getName(), Slice.State.CONSTRUCTION.toString());\n      sendUpdateState = true;\n    }\n\n    // if parent is inactive activate it again\n    Slice parentSlice = coll.getSlice(parentShard);\n    if (parentSlice.getState() == Slice.State.INACTIVE) {\n      sendUpdateState = true;\n      propMap.put(parentShard, Slice.State.ACTIVE.toString());\n    }\n    // plus any other previously deactivated slices\n    for (String sliceName : offlineSlices) {\n      propMap.put(sliceName, Slice.State.ACTIVE.toString());\n      sendUpdateState = true;\n    }\n\n    if (sendUpdateState) {\n      try {\n        ZkNodeProps m = new ZkNodeProps(propMap);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n      } catch (Exception e) {\n        // don't give up yet - just log the error, we may still be able to clean up\n        log.warn(\"Cleanup failed after failed split of {}/{}: (slice state changes)\", collectionName, parentShard, e);\n      }\n    }\n\n    // delete existing subShards\n    for (String subSlice : subSlices) {\n      Slice s = coll.getSlice(subSlice);\n      if (s == null) {\n        continue;\n      }\n      log.debug(\"- sub-shard: {} exists therefore requesting its deletion\", subSlice);\n      HashMap<String, Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"deleteshard\");\n      props.put(COLLECTION_PROP, collectionName);\n      props.put(SHARD_ID_PROP, subSlice);\n      ZkNodeProps m = new ZkNodeProps(props);\n      try {\n        ocmh.commandMap.get(DELETESHARD).call(clusterState, m, new NamedList<Object>());\n      } catch (Exception e) {\n        log.warn(\"Cleanup failed after failed split of {}/{} : (deleting existing sub shard{})\", collectionName, parentShard, subSlice, e);\n      }\n    }\n  }\n\n","sourceOld":"  private void cleanupAfterFailure(ZkStateReader zkStateReader, String collectionName, String parentShard,\n                                   List<String> subSlices, Set<String> offlineSlices) {\n    log.info(\"Cleaning up after a failed split of \" + collectionName + \"/\" + parentShard);\n    // get the latest state\n    try {\n      zkStateReader.forceUpdateCollection(collectionName);\n    } catch (KeeperException | InterruptedException e) {\n      log.warn(\"Cleanup failed after failed split of \" + collectionName + \"/\" + parentShard + \": (force update collection)\", e);\n      return;\n    }\n    ClusterState clusterState = zkStateReader.getClusterState();\n    DocCollection coll = clusterState.getCollectionOrNull(collectionName);\n\n    if (coll == null) { // may have been deleted\n      return;\n    }\n\n    // If parent is inactive and all sub shards are active, then rolling back\n    // to make the parent active again will cause data loss.\n    if (coll.getSlice(parentShard).getState() == Slice.State.INACTIVE) {\n      boolean allSubSlicesActive = true;\n      for (String sub: subSlices) {\n        if (coll.getSlice(sub).getState() != Slice.State.ACTIVE) {\n          allSubSlicesActive = false;\n          break;\n        }\n      }\n      if (allSubSlicesActive) {\n        return;\n      }\n    }\n\n    // set already created sub shards states to CONSTRUCTION - this prevents them\n    // from entering into RECOVERY or ACTIVE (SOLR-9455)\n    final Map<String, Object> propMap = new HashMap<>();\n    boolean sendUpdateState = false;\n    propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n    propMap.put(ZkStateReader.COLLECTION_PROP, collectionName);\n    for (Slice s : coll.getSlices()) {\n      if (!subSlices.contains(s.getName())) {\n        continue;\n      }\n      propMap.put(s.getName(), Slice.State.CONSTRUCTION.toString());\n      sendUpdateState = true;\n    }\n\n    // if parent is inactive activate it again\n    Slice parentSlice = coll.getSlice(parentShard);\n    if (parentSlice.getState() == Slice.State.INACTIVE) {\n      sendUpdateState = true;\n      propMap.put(parentShard, Slice.State.ACTIVE.toString());\n    }\n    // plus any other previously deactivated slices\n    for (String sliceName : offlineSlices) {\n      propMap.put(sliceName, Slice.State.ACTIVE.toString());\n      sendUpdateState = true;\n    }\n\n    if (sendUpdateState) {\n      try {\n        ZkNodeProps m = new ZkNodeProps(propMap);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n      } catch (Exception e) {\n        // don't give up yet - just log the error, we may still be able to clean up\n        log.warn(\"Cleanup failed after failed split of \" + collectionName + \"/\" + parentShard + \": (slice state changes)\", e);\n      }\n    }\n\n    // delete existing subShards\n    for (String subSlice : subSlices) {\n      Slice s = coll.getSlice(subSlice);\n      if (s == null) {\n        continue;\n      }\n      log.debug(\"- sub-shard: {} exists therefore requesting its deletion\", subSlice);\n      HashMap<String, Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"deleteshard\");\n      props.put(COLLECTION_PROP, collectionName);\n      props.put(SHARD_ID_PROP, subSlice);\n      ZkNodeProps m = new ZkNodeProps(props);\n      try {\n        ocmh.commandMap.get(DELETESHARD).call(clusterState, m, new NamedList<Object>());\n      } catch (Exception e) {\n        log.warn(\"Cleanup failed after failed split of \" + collectionName + \"/\" + parentShard + \": (deleting existing sub shard \" + subSlice + \")\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c526352db87264a72a7a9ad68c1b769b81e54305","date":1598780188,"type":5,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/SplitShardCmd#cleanupAfterFailure(ZkStateReader,CloudConfig,String,String,List[String],Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/SplitShardCmd#cleanupAfterFailure(ZkStateReader,String,String,List[String],Set[String]).mjava","sourceNew":"  private void cleanupAfterFailure(ZkStateReader zkStateReader, CloudConfig cloudConfig, String collectionName, String parentShard,\n                                   List<String> subSlices, Set<String> offlineSlices) {\n    log.info(\"Cleaning up after a failed split of {}/{}\", collectionName, parentShard);\n    // get the latest state\n    try {\n      zkStateReader.forceUpdateCollection(collectionName);\n    } catch (KeeperException | InterruptedException e) {\n      log.warn(\"Cleanup failed after failed split of {}/{} : (force update collection)\", collectionName, parentShard, e);\n      return;\n    }\n    ClusterState clusterState = zkStateReader.getClusterState();\n    DocCollection coll = clusterState.getCollectionOrNull(collectionName);\n\n    if (coll == null) { // may have been deleted\n      return;\n    }\n\n    // If parent is inactive and all sub shards are active, then rolling back\n    // to make the parent active again will cause data loss.\n    if (coll.getSlice(parentShard).getState() == Slice.State.INACTIVE) {\n      boolean allSubSlicesActive = true;\n      for (String sub: subSlices) {\n        if (coll.getSlice(sub).getState() != Slice.State.ACTIVE) {\n          allSubSlicesActive = false;\n          break;\n        }\n      }\n      if (allSubSlicesActive) {\n        return;\n      }\n    }\n\n    // set already created sub shards states to CONSTRUCTION - this prevents them\n    // from entering into RECOVERY or ACTIVE (SOLR-9455)\n    final Map<String, Object> propMap = new HashMap<>();\n    boolean sendUpdateState = false;\n    propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n    propMap.put(ZkStateReader.COLLECTION_PROP, collectionName);\n    for (Slice s : coll.getSlices()) {\n      if (!subSlices.contains(s.getName())) {\n        continue;\n      }\n      propMap.put(s.getName(), Slice.State.CONSTRUCTION.toString());\n      sendUpdateState = true;\n    }\n\n    // if parent is inactive activate it again\n    Slice parentSlice = coll.getSlice(parentShard);\n    if (parentSlice.getState() == Slice.State.INACTIVE) {\n      sendUpdateState = true;\n      propMap.put(parentShard, Slice.State.ACTIVE.toString());\n    }\n    // plus any other previously deactivated slices\n    for (String sliceName : offlineSlices) {\n      propMap.put(sliceName, Slice.State.ACTIVE.toString());\n      sendUpdateState = true;\n    }\n\n    if (sendUpdateState) {\n      try {\n        ZkNodeProps m = new ZkNodeProps(propMap);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n      } catch (Exception e) {\n        // don't give up yet - just log the error, we may still be able to clean up\n        log.warn(\"Cleanup failed after failed split of {}/{}: (slice state changes)\", collectionName, parentShard, e);\n      }\n    }\n\n    // delete existing subShards\n    for (String subSlice : subSlices) {\n      Slice s = coll.getSlice(subSlice);\n      if (s == null) {\n        continue;\n      }\n      log.debug(\"- sub-shard: {} exists therefore requesting its deletion\", subSlice);\n      HashMap<String, Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"deleteshard\");\n      props.put(COLLECTION_PROP, collectionName);\n      props.put(SHARD_ID_PROP, subSlice);\n      ZkNodeProps m = new ZkNodeProps(props);\n      try {\n        ocmh.commandMap.get(DELETESHARD).call(clusterState, cloudConfig, m, new NamedList<Object>());\n      } catch (Exception e) {\n        log.warn(\"Cleanup failed after failed split of {}/{} : (deleting existing sub shard{})\", collectionName, parentShard, subSlice, e);\n      }\n    }\n  }\n\n","sourceOld":"  private void cleanupAfterFailure(ZkStateReader zkStateReader, String collectionName, String parentShard,\n                                   List<String> subSlices, Set<String> offlineSlices) {\n    log.info(\"Cleaning up after a failed split of {}/{}\", collectionName, parentShard);\n    // get the latest state\n    try {\n      zkStateReader.forceUpdateCollection(collectionName);\n    } catch (KeeperException | InterruptedException e) {\n      log.warn(\"Cleanup failed after failed split of {}/{} : (force update collection)\", collectionName, parentShard, e);\n      return;\n    }\n    ClusterState clusterState = zkStateReader.getClusterState();\n    DocCollection coll = clusterState.getCollectionOrNull(collectionName);\n\n    if (coll == null) { // may have been deleted\n      return;\n    }\n\n    // If parent is inactive and all sub shards are active, then rolling back\n    // to make the parent active again will cause data loss.\n    if (coll.getSlice(parentShard).getState() == Slice.State.INACTIVE) {\n      boolean allSubSlicesActive = true;\n      for (String sub: subSlices) {\n        if (coll.getSlice(sub).getState() != Slice.State.ACTIVE) {\n          allSubSlicesActive = false;\n          break;\n        }\n      }\n      if (allSubSlicesActive) {\n        return;\n      }\n    }\n\n    // set already created sub shards states to CONSTRUCTION - this prevents them\n    // from entering into RECOVERY or ACTIVE (SOLR-9455)\n    final Map<String, Object> propMap = new HashMap<>();\n    boolean sendUpdateState = false;\n    propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n    propMap.put(ZkStateReader.COLLECTION_PROP, collectionName);\n    for (Slice s : coll.getSlices()) {\n      if (!subSlices.contains(s.getName())) {\n        continue;\n      }\n      propMap.put(s.getName(), Slice.State.CONSTRUCTION.toString());\n      sendUpdateState = true;\n    }\n\n    // if parent is inactive activate it again\n    Slice parentSlice = coll.getSlice(parentShard);\n    if (parentSlice.getState() == Slice.State.INACTIVE) {\n      sendUpdateState = true;\n      propMap.put(parentShard, Slice.State.ACTIVE.toString());\n    }\n    // plus any other previously deactivated slices\n    for (String sliceName : offlineSlices) {\n      propMap.put(sliceName, Slice.State.ACTIVE.toString());\n      sendUpdateState = true;\n    }\n\n    if (sendUpdateState) {\n      try {\n        ZkNodeProps m = new ZkNodeProps(propMap);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n      } catch (Exception e) {\n        // don't give up yet - just log the error, we may still be able to clean up\n        log.warn(\"Cleanup failed after failed split of {}/{}: (slice state changes)\", collectionName, parentShard, e);\n      }\n    }\n\n    // delete existing subShards\n    for (String subSlice : subSlices) {\n      Slice s = coll.getSlice(subSlice);\n      if (s == null) {\n        continue;\n      }\n      log.debug(\"- sub-shard: {} exists therefore requesting its deletion\", subSlice);\n      HashMap<String, Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"deleteshard\");\n      props.put(COLLECTION_PROP, collectionName);\n      props.put(SHARD_ID_PROP, subSlice);\n      ZkNodeProps m = new ZkNodeProps(props);\n      try {\n        ocmh.commandMap.get(DELETESHARD).call(clusterState, m, new NamedList<Object>());\n      } catch (Exception e) {\n        log.warn(\"Cleanup failed after failed split of {}/{} : (deleting existing sub shard{})\", collectionName, parentShard, subSlice, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7b17e79a71117668ecbf8d3417c876e41396565","date":1598973672,"type":1,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/SplitShardCmd#cleanupAfterFailure(ZkStateReader,String,String,List[String],Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/SplitShardCmd#cleanupAfterFailure(ZkStateReader,CloudConfig,String,String,List[String],Set[String]).mjava","sourceNew":"  private void cleanupAfterFailure(ZkStateReader zkStateReader, String collectionName, String parentShard,\n                                   List<String> subSlices, Set<String> offlineSlices) {\n    log.info(\"Cleaning up after a failed split of {}/{}\", collectionName, parentShard);\n    // get the latest state\n    try {\n      zkStateReader.forceUpdateCollection(collectionName);\n    } catch (KeeperException | InterruptedException e) {\n      log.warn(\"Cleanup failed after failed split of {}/{} : (force update collection)\", collectionName, parentShard, e);\n      return;\n    }\n    ClusterState clusterState = zkStateReader.getClusterState();\n    DocCollection coll = clusterState.getCollectionOrNull(collectionName);\n\n    if (coll == null) { // may have been deleted\n      return;\n    }\n\n    // If parent is inactive and all sub shards are active, then rolling back\n    // to make the parent active again will cause data loss.\n    if (coll.getSlice(parentShard).getState() == Slice.State.INACTIVE) {\n      boolean allSubSlicesActive = true;\n      for (String sub: subSlices) {\n        if (coll.getSlice(sub).getState() != Slice.State.ACTIVE) {\n          allSubSlicesActive = false;\n          break;\n        }\n      }\n      if (allSubSlicesActive) {\n        return;\n      }\n    }\n\n    // set already created sub shards states to CONSTRUCTION - this prevents them\n    // from entering into RECOVERY or ACTIVE (SOLR-9455)\n    final Map<String, Object> propMap = new HashMap<>();\n    boolean sendUpdateState = false;\n    propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n    propMap.put(ZkStateReader.COLLECTION_PROP, collectionName);\n    for (Slice s : coll.getSlices()) {\n      if (!subSlices.contains(s.getName())) {\n        continue;\n      }\n      propMap.put(s.getName(), Slice.State.CONSTRUCTION.toString());\n      sendUpdateState = true;\n    }\n\n    // if parent is inactive activate it again\n    Slice parentSlice = coll.getSlice(parentShard);\n    if (parentSlice.getState() == Slice.State.INACTIVE) {\n      sendUpdateState = true;\n      propMap.put(parentShard, Slice.State.ACTIVE.toString());\n    }\n    // plus any other previously deactivated slices\n    for (String sliceName : offlineSlices) {\n      propMap.put(sliceName, Slice.State.ACTIVE.toString());\n      sendUpdateState = true;\n    }\n\n    if (sendUpdateState) {\n      try {\n        ZkNodeProps m = new ZkNodeProps(propMap);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n      } catch (Exception e) {\n        // don't give up yet - just log the error, we may still be able to clean up\n        log.warn(\"Cleanup failed after failed split of {}/{}: (slice state changes)\", collectionName, parentShard, e);\n      }\n    }\n\n    // delete existing subShards\n    for (String subSlice : subSlices) {\n      Slice s = coll.getSlice(subSlice);\n      if (s == null) {\n        continue;\n      }\n      log.debug(\"- sub-shard: {} exists therefore requesting its deletion\", subSlice);\n      HashMap<String, Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"deleteshard\");\n      props.put(COLLECTION_PROP, collectionName);\n      props.put(SHARD_ID_PROP, subSlice);\n      ZkNodeProps m = new ZkNodeProps(props);\n      try {\n        ocmh.commandMap.get(DELETESHARD).call(clusterState, m, new NamedList<Object>());\n      } catch (Exception e) {\n        log.warn(\"Cleanup failed after failed split of {}/{} : (deleting existing sub shard{})\", collectionName, parentShard, subSlice, e);\n      }\n    }\n  }\n\n","sourceOld":"  private void cleanupAfterFailure(ZkStateReader zkStateReader, CloudConfig cloudConfig, String collectionName, String parentShard,\n                                   List<String> subSlices, Set<String> offlineSlices) {\n    log.info(\"Cleaning up after a failed split of {}/{}\", collectionName, parentShard);\n    // get the latest state\n    try {\n      zkStateReader.forceUpdateCollection(collectionName);\n    } catch (KeeperException | InterruptedException e) {\n      log.warn(\"Cleanup failed after failed split of {}/{} : (force update collection)\", collectionName, parentShard, e);\n      return;\n    }\n    ClusterState clusterState = zkStateReader.getClusterState();\n    DocCollection coll = clusterState.getCollectionOrNull(collectionName);\n\n    if (coll == null) { // may have been deleted\n      return;\n    }\n\n    // If parent is inactive and all sub shards are active, then rolling back\n    // to make the parent active again will cause data loss.\n    if (coll.getSlice(parentShard).getState() == Slice.State.INACTIVE) {\n      boolean allSubSlicesActive = true;\n      for (String sub: subSlices) {\n        if (coll.getSlice(sub).getState() != Slice.State.ACTIVE) {\n          allSubSlicesActive = false;\n          break;\n        }\n      }\n      if (allSubSlicesActive) {\n        return;\n      }\n    }\n\n    // set already created sub shards states to CONSTRUCTION - this prevents them\n    // from entering into RECOVERY or ACTIVE (SOLR-9455)\n    final Map<String, Object> propMap = new HashMap<>();\n    boolean sendUpdateState = false;\n    propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n    propMap.put(ZkStateReader.COLLECTION_PROP, collectionName);\n    for (Slice s : coll.getSlices()) {\n      if (!subSlices.contains(s.getName())) {\n        continue;\n      }\n      propMap.put(s.getName(), Slice.State.CONSTRUCTION.toString());\n      sendUpdateState = true;\n    }\n\n    // if parent is inactive activate it again\n    Slice parentSlice = coll.getSlice(parentShard);\n    if (parentSlice.getState() == Slice.State.INACTIVE) {\n      sendUpdateState = true;\n      propMap.put(parentShard, Slice.State.ACTIVE.toString());\n    }\n    // plus any other previously deactivated slices\n    for (String sliceName : offlineSlices) {\n      propMap.put(sliceName, Slice.State.ACTIVE.toString());\n      sendUpdateState = true;\n    }\n\n    if (sendUpdateState) {\n      try {\n        ZkNodeProps m = new ZkNodeProps(propMap);\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n      } catch (Exception e) {\n        // don't give up yet - just log the error, we may still be able to clean up\n        log.warn(\"Cleanup failed after failed split of {}/{}: (slice state changes)\", collectionName, parentShard, e);\n      }\n    }\n\n    // delete existing subShards\n    for (String subSlice : subSlices) {\n      Slice s = coll.getSlice(subSlice);\n      if (s == null) {\n        continue;\n      }\n      log.debug(\"- sub-shard: {} exists therefore requesting its deletion\", subSlice);\n      HashMap<String, Object> props = new HashMap<>();\n      props.put(Overseer.QUEUE_OPERATION, \"deleteshard\");\n      props.put(COLLECTION_PROP, collectionName);\n      props.put(SHARD_ID_PROP, subSlice);\n      ZkNodeProps m = new ZkNodeProps(props);\n      try {\n        ocmh.commandMap.get(DELETESHARD).call(clusterState, cloudConfig, m, new NamedList<Object>());\n      } catch (Exception e) {\n        log.warn(\"Cleanup failed after failed split of {}/{} : (deleting existing sub shard{})\", collectionName, parentShard, subSlice, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"df724d84dab24a0cc54bec95a8680867adc7f171":["69e6520a21709190413a63084ed135271aab1a7c","8a8f0700353755635a948651e84c152bff39d8dc"],"e7b17e79a71117668ecbf8d3417c876e41396565":["c526352db87264a72a7a9ad68c1b769b81e54305"],"4abf821a41a2fdca2a1dea148999931d22e20529":["8a8f0700353755635a948651e84c152bff39d8dc"],"c526352db87264a72a7a9ad68c1b769b81e54305":["4abf821a41a2fdca2a1dea148999931d22e20529"],"69e6520a21709190413a63084ed135271aab1a7c":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["20c968c14aace7cf49843bf2c1fafc7fd3845659"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8a8f0700353755635a948651e84c152bff39d8dc":["69e6520a21709190413a63084ed135271aab1a7c"],"20c968c14aace7cf49843bf2c1fafc7fd3845659":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e7b17e79a71117668ecbf8d3417c876e41396565"]},"commit2Childs":{"df724d84dab24a0cc54bec95a8680867adc7f171":[],"e7b17e79a71117668ecbf8d3417c876e41396565":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4abf821a41a2fdca2a1dea148999931d22e20529":["c526352db87264a72a7a9ad68c1b769b81e54305"],"69e6520a21709190413a63084ed135271aab1a7c":["df724d84dab24a0cc54bec95a8680867adc7f171","8a8f0700353755635a948651e84c152bff39d8dc"],"c526352db87264a72a7a9ad68c1b769b81e54305":["e7b17e79a71117668ecbf8d3417c876e41396565"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["69e6520a21709190413a63084ed135271aab1a7c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["20c968c14aace7cf49843bf2c1fafc7fd3845659"],"8a8f0700353755635a948651e84c152bff39d8dc":["df724d84dab24a0cc54bec95a8680867adc7f171","4abf821a41a2fdca2a1dea148999931d22e20529"],"20c968c14aace7cf49843bf2c1fafc7fd3845659":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["df724d84dab24a0cc54bec95a8680867adc7f171","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}