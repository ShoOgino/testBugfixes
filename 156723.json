{"path":"lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/BaseFragListBuilder#createFieldFragList(FieldPhraseList,FieldFragList,int).mjava","commits":[{"id":"9f3f873f902c9e3821591809929b6f1283bc0298","date":1338822342,"type":0,"author":"Koji Sekiguchi","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/BaseFragListBuilder#createFieldFragList(FieldPhraseList,FieldFragList,int).mjava","pathOld":"/dev/null","sourceNew":"  protected FieldFragList createFieldFragList( FieldPhraseList fieldPhraseList, FieldFragList fieldFragList, int fragCharSize ){\n    \n    if( fragCharSize < minFragCharSize )\n      throw new IllegalArgumentException( \"fragCharSize(\" + fragCharSize + \") is too small. It must be \" + minFragCharSize + \" or higher.\" );\n    \n    List<WeightedPhraseInfo> wpil = new ArrayList<WeightedPhraseInfo>();\n    Iterator<WeightedPhraseInfo> ite = fieldPhraseList.getPhraseList().iterator();\n    WeightedPhraseInfo phraseInfo = null;\n    int startOffset = 0;\n    boolean taken = false;\n    while( true ){\n      if( !taken ){\n        if( !ite.hasNext() ) break;\n        phraseInfo = ite.next();\n      }\n      taken = false;\n      if( phraseInfo == null ) break;\n\n      // if the phrase violates the border of previous fragment, discard it and try next phrase\n      if( phraseInfo.getStartOffset() < startOffset ) continue;\n\n      wpil.clear();\n      wpil.add( phraseInfo );\n      int st = phraseInfo.getStartOffset() - margin < startOffset ?\n          startOffset : phraseInfo.getStartOffset() - margin;\n      int en = st + fragCharSize;\n      if( phraseInfo.getEndOffset() > en )\n        en = phraseInfo.getEndOffset();\n      startOffset = en;\n\n      while( true ){\n        if( ite.hasNext() ){\n          phraseInfo = ite.next();\n          taken = true;\n          if( phraseInfo == null ) break;\n        }\n        else\n          break;\n        if( phraseInfo.getEndOffset() <= en )\n          wpil.add( phraseInfo );\n        else\n          break;\n      }\n      fieldFragList.add( st, en, wpil );\n    }\n    return fieldFragList;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["4de9b9325d973e4bc4c97eb91fe119eafa6caa99"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"335fa85a41a431b929ff93a0eb831abfc7b91e63","date":1349750333,"type":3,"author":"Koji Sekiguchi","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/BaseFragListBuilder#createFieldFragList(FieldPhraseList,FieldFragList,int).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/BaseFragListBuilder#createFieldFragList(FieldPhraseList,FieldFragList,int).mjava","sourceNew":"  protected FieldFragList createFieldFragList( FieldPhraseList fieldPhraseList, FieldFragList fieldFragList, int fragCharSize ){\n    \n    if( fragCharSize < minFragCharSize )\n      throw new IllegalArgumentException( \"fragCharSize(\" + fragCharSize + \") is too small. It must be \" + minFragCharSize + \" or higher.\" );\n    \n    List<WeightedPhraseInfo> wpil = new ArrayList<WeightedPhraseInfo>();\n    Iterator<WeightedPhraseInfo> ite = fieldPhraseList.getPhraseList().iterator();\n    WeightedPhraseInfo phraseInfo = null;\n    int startOffset = 0;\n    boolean taken = false;\n    while( true ){\n      if( !taken ){\n        if( !ite.hasNext() ) break;\n        phraseInfo = ite.next();\n      }\n      taken = false;\n      if( phraseInfo == null ) break;\n\n      // if the phrase violates the border of previous fragment, discard it and try next phrase\n      if( phraseInfo.getStartOffset() < startOffset ) continue;\n\n      wpil.clear();\n      wpil.add( phraseInfo );\n      int firstOffset = phraseInfo.getStartOffset();\n      int st = phraseInfo.getStartOffset() - margin < startOffset ?\n          startOffset : phraseInfo.getStartOffset() - margin;\n      int en = st + fragCharSize;\n      if( phraseInfo.getEndOffset() > en )\n        en = phraseInfo.getEndOffset();\n\n      int lastEndOffset = phraseInfo.getEndOffset();\n      while( true ){\n        if( ite.hasNext() ){\n          phraseInfo = ite.next();\n          taken = true;\n          if( phraseInfo == null ) break;\n        }\n        else\n          break;\n        if( phraseInfo.getEndOffset() <= en ){\n          wpil.add( phraseInfo );\n          lastEndOffset = phraseInfo.getEndOffset();\n        }\n        else\n          break;\n      }\n      int matchLen = lastEndOffset - firstOffset;\n      //now recalculate the start and end position to \"center\" the result\n      int newMargin = (fragCharSize-matchLen)/2;\n      st = firstOffset - newMargin;\n      if(st<startOffset){\n        st = startOffset;\n      }\n      en = st+fragCharSize;\n      startOffset = en;\n      fieldFragList.add( st, en, wpil );\n    }\n    return fieldFragList;\n  }\n\n","sourceOld":"  protected FieldFragList createFieldFragList( FieldPhraseList fieldPhraseList, FieldFragList fieldFragList, int fragCharSize ){\n    \n    if( fragCharSize < minFragCharSize )\n      throw new IllegalArgumentException( \"fragCharSize(\" + fragCharSize + \") is too small. It must be \" + minFragCharSize + \" or higher.\" );\n    \n    List<WeightedPhraseInfo> wpil = new ArrayList<WeightedPhraseInfo>();\n    Iterator<WeightedPhraseInfo> ite = fieldPhraseList.getPhraseList().iterator();\n    WeightedPhraseInfo phraseInfo = null;\n    int startOffset = 0;\n    boolean taken = false;\n    while( true ){\n      if( !taken ){\n        if( !ite.hasNext() ) break;\n        phraseInfo = ite.next();\n      }\n      taken = false;\n      if( phraseInfo == null ) break;\n\n      // if the phrase violates the border of previous fragment, discard it and try next phrase\n      if( phraseInfo.getStartOffset() < startOffset ) continue;\n\n      wpil.clear();\n      wpil.add( phraseInfo );\n      int st = phraseInfo.getStartOffset() - margin < startOffset ?\n          startOffset : phraseInfo.getStartOffset() - margin;\n      int en = st + fragCharSize;\n      if( phraseInfo.getEndOffset() > en )\n        en = phraseInfo.getEndOffset();\n      startOffset = en;\n\n      while( true ){\n        if( ite.hasNext() ){\n          phraseInfo = ite.next();\n          taken = true;\n          if( phraseInfo == null ) break;\n        }\n        else\n          break;\n        if( phraseInfo.getEndOffset() <= en )\n          wpil.add( phraseInfo );\n        else\n          break;\n      }\n      fieldFragList.add( st, en, wpil );\n    }\n    return fieldFragList;\n  }\n\n","bugFix":null,"bugIntro":["4de9b9325d973e4bc4c97eb91fe119eafa6caa99"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4de9b9325d973e4bc4c97eb91fe119eafa6caa99","date":1365179986,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/BaseFragListBuilder#createFieldFragList(FieldPhraseList,FieldFragList,int).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/BaseFragListBuilder#createFieldFragList(FieldPhraseList,FieldFragList,int).mjava","sourceNew":" protected FieldFragList createFieldFragList( FieldPhraseList fieldPhraseList, FieldFragList fieldFragList, int fragCharSize ){\n    if( fragCharSize < minFragCharSize )\n      throw new IllegalArgumentException( \"fragCharSize(\" + fragCharSize + \") is too small. It must be \" + minFragCharSize + \" or higher.\" );\n    \n    List<WeightedPhraseInfo> wpil = new ArrayList<WeightedPhraseInfo>();\n    IteratorQueue<WeightedPhraseInfo> queue = new IteratorQueue<WeightedPhraseInfo>(fieldPhraseList.getPhraseList().iterator());\n    WeightedPhraseInfo phraseInfo = null;\n    int startOffset = 0;\n    while((phraseInfo = queue.top()) != null){\n      // if the phrase violates the border of previous fragment, discard it and try next phrase\n      if( phraseInfo.getStartOffset() < startOffset )  {\n        queue.removeTop();\n        continue;\n      }\n      \n      wpil.clear();\n      final int currentPhraseStartOffset = phraseInfo.getStartOffset();\n      int currentPhraseEndOffset = phraseInfo.getEndOffset();\n      int spanStart = Math.max(currentPhraseStartOffset - margin, startOffset);\n      int spanEnd = Math.max(currentPhraseEndOffset, spanStart + fragCharSize);\n      if (acceptPhrase(queue.removeTop(),  currentPhraseEndOffset - currentPhraseStartOffset, fragCharSize)) {\n        wpil.add(phraseInfo);\n      }\n      while((phraseInfo = queue.top()) != null) { // pull until we crossed the current spanEnd\n        if (phraseInfo.getEndOffset() <= spanEnd) {\n          currentPhraseEndOffset = phraseInfo.getEndOffset();\n          if (acceptPhrase(queue.removeTop(),  currentPhraseEndOffset - currentPhraseStartOffset, fragCharSize)) {\n            wpil.add(phraseInfo);\n          }\n        } else {\n          break;\n        }\n      }\n      if (wpil.isEmpty()) {\n        continue;\n      }\n      \n      final int matchLen = currentPhraseEndOffset - currentPhraseStartOffset;\n      // now recalculate the start and end position to \"center\" the result\n      final int newMargin = Math.max(0, (fragCharSize-matchLen)/2); // matchLen can be > fragCharSize prevent IAOOB here\n      spanStart = currentPhraseStartOffset - newMargin;\n      if (spanStart < startOffset) {\n        spanStart = startOffset;\n      }\n      // whatever is bigger here we grow this out\n      spanEnd = spanStart + Math.max(matchLen, fragCharSize);  \n      startOffset = spanEnd;\n      fieldFragList.add(spanStart, spanEnd, wpil);\n    }\n    return fieldFragList;\n  }\n\n","sourceOld":"  protected FieldFragList createFieldFragList( FieldPhraseList fieldPhraseList, FieldFragList fieldFragList, int fragCharSize ){\n    \n    if( fragCharSize < minFragCharSize )\n      throw new IllegalArgumentException( \"fragCharSize(\" + fragCharSize + \") is too small. It must be \" + minFragCharSize + \" or higher.\" );\n    \n    List<WeightedPhraseInfo> wpil = new ArrayList<WeightedPhraseInfo>();\n    Iterator<WeightedPhraseInfo> ite = fieldPhraseList.getPhraseList().iterator();\n    WeightedPhraseInfo phraseInfo = null;\n    int startOffset = 0;\n    boolean taken = false;\n    while( true ){\n      if( !taken ){\n        if( !ite.hasNext() ) break;\n        phraseInfo = ite.next();\n      }\n      taken = false;\n      if( phraseInfo == null ) break;\n\n      // if the phrase violates the border of previous fragment, discard it and try next phrase\n      if( phraseInfo.getStartOffset() < startOffset ) continue;\n\n      wpil.clear();\n      wpil.add( phraseInfo );\n      int firstOffset = phraseInfo.getStartOffset();\n      int st = phraseInfo.getStartOffset() - margin < startOffset ?\n          startOffset : phraseInfo.getStartOffset() - margin;\n      int en = st + fragCharSize;\n      if( phraseInfo.getEndOffset() > en )\n        en = phraseInfo.getEndOffset();\n\n      int lastEndOffset = phraseInfo.getEndOffset();\n      while( true ){\n        if( ite.hasNext() ){\n          phraseInfo = ite.next();\n          taken = true;\n          if( phraseInfo == null ) break;\n        }\n        else\n          break;\n        if( phraseInfo.getEndOffset() <= en ){\n          wpil.add( phraseInfo );\n          lastEndOffset = phraseInfo.getEndOffset();\n        }\n        else\n          break;\n      }\n      int matchLen = lastEndOffset - firstOffset;\n      //now recalculate the start and end position to \"center\" the result\n      int newMargin = (fragCharSize-matchLen)/2;\n      st = firstOffset - newMargin;\n      if(st<startOffset){\n        st = startOffset;\n      }\n      en = st+fragCharSize;\n      startOffset = en;\n      fieldFragList.add( st, en, wpil );\n    }\n    return fieldFragList;\n  }\n\n","bugFix":["9f3f873f902c9e3821591809929b6f1283bc0298","335fa85a41a431b929ff93a0eb831abfc7b91e63"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/BaseFragListBuilder#createFieldFragList(FieldPhraseList,FieldFragList,int).mjava","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/BaseFragListBuilder#createFieldFragList(FieldPhraseList,FieldFragList,int).mjava","sourceNew":" protected FieldFragList createFieldFragList( FieldPhraseList fieldPhraseList, FieldFragList fieldFragList, int fragCharSize ){\n    if( fragCharSize < minFragCharSize )\n      throw new IllegalArgumentException( \"fragCharSize(\" + fragCharSize + \") is too small. It must be \" + minFragCharSize + \" or higher.\" );\n    \n    List<WeightedPhraseInfo> wpil = new ArrayList<>();\n    IteratorQueue<WeightedPhraseInfo> queue = new IteratorQueue<>(fieldPhraseList.getPhraseList().iterator());\n    WeightedPhraseInfo phraseInfo = null;\n    int startOffset = 0;\n    while((phraseInfo = queue.top()) != null){\n      // if the phrase violates the border of previous fragment, discard it and try next phrase\n      if( phraseInfo.getStartOffset() < startOffset )  {\n        queue.removeTop();\n        continue;\n      }\n      \n      wpil.clear();\n      final int currentPhraseStartOffset = phraseInfo.getStartOffset();\n      int currentPhraseEndOffset = phraseInfo.getEndOffset();\n      int spanStart = Math.max(currentPhraseStartOffset - margin, startOffset);\n      int spanEnd = Math.max(currentPhraseEndOffset, spanStart + fragCharSize);\n      if (acceptPhrase(queue.removeTop(),  currentPhraseEndOffset - currentPhraseStartOffset, fragCharSize)) {\n        wpil.add(phraseInfo);\n      }\n      while((phraseInfo = queue.top()) != null) { // pull until we crossed the current spanEnd\n        if (phraseInfo.getEndOffset() <= spanEnd) {\n          currentPhraseEndOffset = phraseInfo.getEndOffset();\n          if (acceptPhrase(queue.removeTop(),  currentPhraseEndOffset - currentPhraseStartOffset, fragCharSize)) {\n            wpil.add(phraseInfo);\n          }\n        } else {\n          break;\n        }\n      }\n      if (wpil.isEmpty()) {\n        continue;\n      }\n      \n      final int matchLen = currentPhraseEndOffset - currentPhraseStartOffset;\n      // now recalculate the start and end position to \"center\" the result\n      final int newMargin = Math.max(0, (fragCharSize-matchLen)/2); // matchLen can be > fragCharSize prevent IAOOB here\n      spanStart = currentPhraseStartOffset - newMargin;\n      if (spanStart < startOffset) {\n        spanStart = startOffset;\n      }\n      // whatever is bigger here we grow this out\n      spanEnd = spanStart + Math.max(matchLen, fragCharSize);  \n      startOffset = spanEnd;\n      fieldFragList.add(spanStart, spanEnd, wpil);\n    }\n    return fieldFragList;\n  }\n\n","sourceOld":" protected FieldFragList createFieldFragList( FieldPhraseList fieldPhraseList, FieldFragList fieldFragList, int fragCharSize ){\n    if( fragCharSize < minFragCharSize )\n      throw new IllegalArgumentException( \"fragCharSize(\" + fragCharSize + \") is too small. It must be \" + minFragCharSize + \" or higher.\" );\n    \n    List<WeightedPhraseInfo> wpil = new ArrayList<WeightedPhraseInfo>();\n    IteratorQueue<WeightedPhraseInfo> queue = new IteratorQueue<WeightedPhraseInfo>(fieldPhraseList.getPhraseList().iterator());\n    WeightedPhraseInfo phraseInfo = null;\n    int startOffset = 0;\n    while((phraseInfo = queue.top()) != null){\n      // if the phrase violates the border of previous fragment, discard it and try next phrase\n      if( phraseInfo.getStartOffset() < startOffset )  {\n        queue.removeTop();\n        continue;\n      }\n      \n      wpil.clear();\n      final int currentPhraseStartOffset = phraseInfo.getStartOffset();\n      int currentPhraseEndOffset = phraseInfo.getEndOffset();\n      int spanStart = Math.max(currentPhraseStartOffset - margin, startOffset);\n      int spanEnd = Math.max(currentPhraseEndOffset, spanStart + fragCharSize);\n      if (acceptPhrase(queue.removeTop(),  currentPhraseEndOffset - currentPhraseStartOffset, fragCharSize)) {\n        wpil.add(phraseInfo);\n      }\n      while((phraseInfo = queue.top()) != null) { // pull until we crossed the current spanEnd\n        if (phraseInfo.getEndOffset() <= spanEnd) {\n          currentPhraseEndOffset = phraseInfo.getEndOffset();\n          if (acceptPhrase(queue.removeTop(),  currentPhraseEndOffset - currentPhraseStartOffset, fragCharSize)) {\n            wpil.add(phraseInfo);\n          }\n        } else {\n          break;\n        }\n      }\n      if (wpil.isEmpty()) {\n        continue;\n      }\n      \n      final int matchLen = currentPhraseEndOffset - currentPhraseStartOffset;\n      // now recalculate the start and end position to \"center\" the result\n      final int newMargin = Math.max(0, (fragCharSize-matchLen)/2); // matchLen can be > fragCharSize prevent IAOOB here\n      spanStart = currentPhraseStartOffset - newMargin;\n      if (spanStart < startOffset) {\n        spanStart = startOffset;\n      }\n      // whatever is bigger here we grow this out\n      spanEnd = spanStart + Math.max(matchLen, fragCharSize);  \n      startOffset = spanEnd;\n      fieldFragList.add(spanStart, spanEnd, wpil);\n    }\n    return fieldFragList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"335fa85a41a431b929ff93a0eb831abfc7b91e63":["9f3f873f902c9e3821591809929b6f1283bc0298"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["4de9b9325d973e4bc4c97eb91fe119eafa6caa99"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4de9b9325d973e4bc4c97eb91fe119eafa6caa99":["335fa85a41a431b929ff93a0eb831abfc7b91e63"],"9f3f873f902c9e3821591809929b6f1283bc0298":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"]},"commit2Childs":{"335fa85a41a431b929ff93a0eb831abfc7b91e63":["4de9b9325d973e4bc4c97eb91fe119eafa6caa99"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9f3f873f902c9e3821591809929b6f1283bc0298"],"4de9b9325d973e4bc4c97eb91fe119eafa6caa99":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"9f3f873f902c9e3821591809929b6f1283bc0298":["335fa85a41a431b929ff93a0eb831abfc7b91e63"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}