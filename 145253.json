{"path":"lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.FieldsWriter#addField(FieldInfo).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.FieldsWriter#addField(FieldInfo).mjava","pathOld":"lucene/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.FieldsWriter#addField(FieldInfo).mjava","sourceNew":"    @Override\n    public TermsConsumer addField(FieldInfo field) throws IOException {\n      final PostingsFormat format = getPostingsFormatForField(field.name);\n      if (format == null) {\n        throw new IllegalStateException(\"invalid null PostingsFormat for field=\\\"\" + field.name + \"\\\"\");\n      }\n\n      assert !fieldToFormat.containsKey(field.name);\n      fieldToFormat.put(field.name, format);\n\n      FieldsConsumerAndID consumerAndId = formats.get(format);\n      if (consumerAndId == null) {\n        // First time we are seeing this format; assign\n        // next id and init it:\n        final String segmentSuffix = getFullSegmentSuffix(field.name,\n                                                          segmentWriteState.segmentSuffix,\n                                                          \"\"+formats.size());\n        consumerAndId = new FieldsConsumerAndID(format.fieldsConsumer(new SegmentWriteState(segmentWriteState, segmentSuffix)),\n                                                segmentSuffix);\n        formats.put(format, consumerAndId);\n      }\n\n      return consumerAndId.fieldsConsumer.addField(field);\n    }\n\n","sourceOld":"    @Override\n    public TermsConsumer addField(FieldInfo field) throws IOException {\n      final PostingsFormat format = getPostingsFormatForField(field.name);\n      if (format == null) {\n        throw new IllegalStateException(\"invalid null PostingsFormat for field=\\\"\" + field.name + \"\\\"\");\n      }\n\n      assert !fieldToFormat.containsKey(field.name);\n      fieldToFormat.put(field.name, format);\n\n      FieldsConsumerAndID consumerAndId = formats.get(format);\n      if (consumerAndId == null) {\n        // First time we are seeing this format; assign\n        // next id and init it:\n        final String segmentSuffix = getFullSegmentSuffix(field.name,\n                                                          segmentWriteState.segmentSuffix,\n                                                          \"\"+formats.size());\n        consumerAndId = new FieldsConsumerAndID(format.fieldsConsumer(new SegmentWriteState(segmentWriteState, segmentSuffix)),\n                                                segmentSuffix);\n        formats.put(format, consumerAndId);\n      }\n\n      return consumerAndId.fieldsConsumer.addField(field);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4356000e349e38c9fb48034695b7c309abd54557","date":1337460341,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.FieldsWriter#addField(FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.FieldsWriter#addField(FieldInfo).mjava","sourceNew":"    @Override\n    public TermsConsumer addField(FieldInfo field) throws IOException {\n      final PostingsFormat format = getPostingsFormatForField(field.name);\n      if (format == null) {\n        throw new IllegalStateException(\"invalid null PostingsFormat for field=\\\"\" + field.name + \"\\\"\");\n      }\n\n      assert !fieldToFormat.containsKey(field.name);\n      fieldToFormat.put(field.name, format);\n\n      FieldsConsumerAndID consumerAndId = formats.get(format);\n      if (consumerAndId == null) {\n        // First time we are seeing this format; assign\n        // next id and init it:\n        final String segmentSuffix = getFullSegmentSuffix(field.name,\n                                                          segmentWriteState.segmentSuffix,\n                                                          \"\"+formats.size());\n        consumerAndId = new FieldsConsumerAndID(format.fieldsConsumer(new SegmentWriteState(segmentWriteState, segmentSuffix)),\n                                                segmentSuffix);\n        formats.put(format, consumerAndId);\n      }\n\n      // nocommit we should only provide the \"slice\" of FIS\n      // that this PF actually sees ... then stuff like\n      // .hasProx could work correctly?\n      return consumerAndId.fieldsConsumer.addField(field);\n    }\n\n","sourceOld":"    @Override\n    public TermsConsumer addField(FieldInfo field) throws IOException {\n      final PostingsFormat format = getPostingsFormatForField(field.name);\n      if (format == null) {\n        throw new IllegalStateException(\"invalid null PostingsFormat for field=\\\"\" + field.name + \"\\\"\");\n      }\n\n      assert !fieldToFormat.containsKey(field.name);\n      fieldToFormat.put(field.name, format);\n\n      FieldsConsumerAndID consumerAndId = formats.get(format);\n      if (consumerAndId == null) {\n        // First time we are seeing this format; assign\n        // next id and init it:\n        final String segmentSuffix = getFullSegmentSuffix(field.name,\n                                                          segmentWriteState.segmentSuffix,\n                                                          \"\"+formats.size());\n        consumerAndId = new FieldsConsumerAndID(format.fieldsConsumer(new SegmentWriteState(segmentWriteState, segmentSuffix)),\n                                                segmentSuffix);\n        formats.put(format, consumerAndId);\n      }\n\n      return consumerAndId.fieldsConsumer.addField(field);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2e816e693615395fd0e107b08e48caff42938190","date":1337635314,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.FieldsWriter#addField(FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.FieldsWriter#addField(FieldInfo).mjava","sourceNew":"    @Override\n    public TermsConsumer addField(FieldInfo field) throws IOException {\n      final PostingsFormat format = getPostingsFormatForField(field.name);\n      if (format == null) {\n        throw new IllegalStateException(\"invalid null PostingsFormat for field=\\\"\" + field.name + \"\\\"\");\n      }\n      \n      String previousValue = field.putAttribute(PER_FIELD_FORMAT_KEY, format.getName());\n      assert previousValue == null;\n\n      FieldsConsumer consumer = formats.get(format);\n      if (consumer == null) {\n        // First time we are seeing this format; create a new instance\n        final String segmentSuffix = getFullSegmentSuffix(field.name,\n                                                          segmentWriteState.segmentSuffix,\n                                                          format.getName());\n        consumer = format.fieldsConsumer(new SegmentWriteState(segmentWriteState, segmentSuffix));\n        formats.put(format, consumer);\n      }\n\n      // nocommit we should only provide the \"slice\" of FIS\n      // that this PF actually sees ... then stuff like\n      // .hasProx could work correctly?\n      return consumer.addField(field);\n    }\n\n","sourceOld":"    @Override\n    public TermsConsumer addField(FieldInfo field) throws IOException {\n      final PostingsFormat format = getPostingsFormatForField(field.name);\n      if (format == null) {\n        throw new IllegalStateException(\"invalid null PostingsFormat for field=\\\"\" + field.name + \"\\\"\");\n      }\n\n      assert !fieldToFormat.containsKey(field.name);\n      fieldToFormat.put(field.name, format);\n\n      FieldsConsumerAndID consumerAndId = formats.get(format);\n      if (consumerAndId == null) {\n        // First time we are seeing this format; assign\n        // next id and init it:\n        final String segmentSuffix = getFullSegmentSuffix(field.name,\n                                                          segmentWriteState.segmentSuffix,\n                                                          \"\"+formats.size());\n        consumerAndId = new FieldsConsumerAndID(format.fieldsConsumer(new SegmentWriteState(segmentWriteState, segmentSuffix)),\n                                                segmentSuffix);\n        formats.put(format, consumerAndId);\n      }\n\n      // nocommit we should only provide the \"slice\" of FIS\n      // that this PF actually sees ... then stuff like\n      // .hasProx could work correctly?\n      return consumerAndId.fieldsConsumer.addField(field);\n    }\n\n","bugFix":null,"bugIntro":["b0c99c9b095ebe88603d5dc33606fdfe7782cb2f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"818ed34f5bd799741cc36ac29a92dfcfce9c6950","date":1337699165,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.FieldsWriter#addField(FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.FieldsWriter#addField(FieldInfo).mjava","sourceNew":"    @Override\n    public TermsConsumer addField(FieldInfo field) throws IOException {\n      final PostingsFormat format = getPostingsFormatForField(field.name);\n      if (format == null) {\n        throw new IllegalStateException(\"invalid null PostingsFormat for field=\\\"\" + field.name + \"\\\"\");\n      }\n      \n      String previousValue = field.putAttribute(PER_FIELD_FORMAT_KEY, format.getName());\n      assert previousValue == null;\n\n      FieldsConsumer consumer = formats.get(format);\n      if (consumer == null) {\n        // First time we are seeing this format; create a new instance\n        final String segmentSuffix = getFullSegmentSuffix(field.name,\n                                                          segmentWriteState.segmentSuffix,\n                                                          format.getName());\n        consumer = format.fieldsConsumer(new SegmentWriteState(segmentWriteState, segmentSuffix));\n        formats.put(format, consumer);\n      }\n\n      // TODO: we should only provide the \"slice\" of FIS\n      // that this PF actually sees ... then stuff like\n      // .hasProx could work correctly?\n      // NOTE: .hasProx is already broken in the same way for the non-perfield case,\n      // if there is a fieldinfo with prox that has no postings, you get a 0 byte file.\n      return consumer.addField(field);\n    }\n\n","sourceOld":"    @Override\n    public TermsConsumer addField(FieldInfo field) throws IOException {\n      final PostingsFormat format = getPostingsFormatForField(field.name);\n      if (format == null) {\n        throw new IllegalStateException(\"invalid null PostingsFormat for field=\\\"\" + field.name + \"\\\"\");\n      }\n      \n      String previousValue = field.putAttribute(PER_FIELD_FORMAT_KEY, format.getName());\n      assert previousValue == null;\n\n      FieldsConsumer consumer = formats.get(format);\n      if (consumer == null) {\n        // First time we are seeing this format; create a new instance\n        final String segmentSuffix = getFullSegmentSuffix(field.name,\n                                                          segmentWriteState.segmentSuffix,\n                                                          format.getName());\n        consumer = format.fieldsConsumer(new SegmentWriteState(segmentWriteState, segmentSuffix));\n        formats.put(format, consumer);\n      }\n\n      // nocommit we should only provide the \"slice\" of FIS\n      // that this PF actually sees ... then stuff like\n      // .hasProx could work correctly?\n      return consumer.addField(field);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.FieldsWriter#addField(FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.FieldsWriter#addField(FieldInfo).mjava","sourceNew":"    @Override\n    public TermsConsumer addField(FieldInfo field) throws IOException {\n      final PostingsFormat format = getPostingsFormatForField(field.name);\n      if (format == null) {\n        throw new IllegalStateException(\"invalid null PostingsFormat for field=\\\"\" + field.name + \"\\\"\");\n      }\n      \n      String previousValue = field.putAttribute(PER_FIELD_FORMAT_KEY, format.getName());\n      assert previousValue == null;\n\n      FieldsConsumer consumer = formats.get(format);\n      if (consumer == null) {\n        // First time we are seeing this format; create a new instance\n        final String segmentSuffix = getFullSegmentSuffix(field.name,\n                                                          segmentWriteState.segmentSuffix,\n                                                          format.getName());\n        consumer = format.fieldsConsumer(new SegmentWriteState(segmentWriteState, segmentSuffix));\n        formats.put(format, consumer);\n      }\n\n      // TODO: we should only provide the \"slice\" of FIS\n      // that this PF actually sees ... then stuff like\n      // .hasProx could work correctly?\n      // NOTE: .hasProx is already broken in the same way for the non-perfield case,\n      // if there is a fieldinfo with prox that has no postings, you get a 0 byte file.\n      return consumer.addField(field);\n    }\n\n","sourceOld":"    @Override\n    public TermsConsumer addField(FieldInfo field) throws IOException {\n      final PostingsFormat format = getPostingsFormatForField(field.name);\n      if (format == null) {\n        throw new IllegalStateException(\"invalid null PostingsFormat for field=\\\"\" + field.name + \"\\\"\");\n      }\n\n      assert !fieldToFormat.containsKey(field.name);\n      fieldToFormat.put(field.name, format);\n\n      FieldsConsumerAndID consumerAndId = formats.get(format);\n      if (consumerAndId == null) {\n        // First time we are seeing this format; assign\n        // next id and init it:\n        final String segmentSuffix = getFullSegmentSuffix(field.name,\n                                                          segmentWriteState.segmentSuffix,\n                                                          \"\"+formats.size());\n        consumerAndId = new FieldsConsumerAndID(format.fieldsConsumer(new SegmentWriteState(segmentWriteState, segmentSuffix)),\n                                                segmentSuffix);\n        formats.put(format, consumerAndId);\n      }\n\n      return consumerAndId.fieldsConsumer.addField(field);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b0c99c9b095ebe88603d5dc33606fdfe7782cb2f","date":1338408958,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.FieldsWriter#addField(FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.FieldsWriter#addField(FieldInfo).mjava","sourceNew":"    @Override\n    public TermsConsumer addField(FieldInfo field) throws IOException {\n      final PostingsFormat format = getPostingsFormatForField(field.name);\n      if (format == null) {\n        throw new IllegalStateException(\"invalid null PostingsFormat for field=\\\"\" + field.name + \"\\\"\");\n      }\n      final String formatName = format.getName();\n      \n      String previousValue = field.putAttribute(PER_FIELD_FORMAT_KEY, formatName);\n      assert previousValue == null;\n      \n      Integer suffix;\n      \n      FieldsConsumerAndSuffix consumer = formats.get(format);\n      if (consumer == null) {\n        // First time we are seeing this format; create a new instance\n        \n        // bump the suffix\n        suffix = suffixes.get(formatName);\n        if (suffix == null) {\n          suffix = 0;\n        } else {\n          suffix = suffix + 1;\n        }\n        suffixes.put(formatName, suffix);\n        \n        final String segmentSuffix = getFullSegmentSuffix(field.name,\n                                                          segmentWriteState.segmentSuffix,\n                                                          getSuffix(formatName, Integer.toString(suffix)));\n        consumer = new FieldsConsumerAndSuffix();\n        consumer.consumer = format.fieldsConsumer(new SegmentWriteState(segmentWriteState, segmentSuffix));\n        consumer.suffix = suffix;\n        formats.put(format, consumer);\n      } else {\n        // we've already seen this format, so just grab its suffix\n        assert suffixes.containsKey(formatName);\n        suffix = consumer.suffix;\n      }\n      \n      previousValue = field.putAttribute(PER_FIELD_SUFFIX_KEY, Integer.toString(suffix));\n      assert previousValue == null;\n\n      // TODO: we should only provide the \"slice\" of FIS\n      // that this PF actually sees ... then stuff like\n      // .hasProx could work correctly?\n      // NOTE: .hasProx is already broken in the same way for the non-perfield case,\n      // if there is a fieldinfo with prox that has no postings, you get a 0 byte file.\n      return consumer.consumer.addField(field);\n    }\n\n","sourceOld":"    @Override\n    public TermsConsumer addField(FieldInfo field) throws IOException {\n      final PostingsFormat format = getPostingsFormatForField(field.name);\n      if (format == null) {\n        throw new IllegalStateException(\"invalid null PostingsFormat for field=\\\"\" + field.name + \"\\\"\");\n      }\n      \n      String previousValue = field.putAttribute(PER_FIELD_FORMAT_KEY, format.getName());\n      assert previousValue == null;\n\n      FieldsConsumer consumer = formats.get(format);\n      if (consumer == null) {\n        // First time we are seeing this format; create a new instance\n        final String segmentSuffix = getFullSegmentSuffix(field.name,\n                                                          segmentWriteState.segmentSuffix,\n                                                          format.getName());\n        consumer = format.fieldsConsumer(new SegmentWriteState(segmentWriteState, segmentSuffix));\n        formats.put(format, consumer);\n      }\n\n      // TODO: we should only provide the \"slice\" of FIS\n      // that this PF actually sees ... then stuff like\n      // .hasProx could work correctly?\n      // NOTE: .hasProx is already broken in the same way for the non-perfield case,\n      // if there is a fieldinfo with prox that has no postings, you get a 0 byte file.\n      return consumer.addField(field);\n    }\n\n","bugFix":["7b91922b55d15444d554721b352861d028eb8278","2e816e693615395fd0e107b08e48caff42938190"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5","date":1379624229,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.FieldsWriter#addField(FieldInfo).mjava","sourceNew":null,"sourceOld":"    @Override\n    public TermsConsumer addField(FieldInfo field) throws IOException {\n      final PostingsFormat format = getPostingsFormatForField(field.name);\n      if (format == null) {\n        throw new IllegalStateException(\"invalid null PostingsFormat for field=\\\"\" + field.name + \"\\\"\");\n      }\n      final String formatName = format.getName();\n      \n      String previousValue = field.putAttribute(PER_FIELD_FORMAT_KEY, formatName);\n      assert previousValue == null;\n      \n      Integer suffix;\n      \n      FieldsConsumerAndSuffix consumer = formats.get(format);\n      if (consumer == null) {\n        // First time we are seeing this format; create a new instance\n        \n        // bump the suffix\n        suffix = suffixes.get(formatName);\n        if (suffix == null) {\n          suffix = 0;\n        } else {\n          suffix = suffix + 1;\n        }\n        suffixes.put(formatName, suffix);\n        \n        final String segmentSuffix = getFullSegmentSuffix(field.name,\n                                                          segmentWriteState.segmentSuffix,\n                                                          getSuffix(formatName, Integer.toString(suffix)));\n        consumer = new FieldsConsumerAndSuffix();\n        consumer.consumer = format.fieldsConsumer(new SegmentWriteState(segmentWriteState, segmentSuffix));\n        consumer.suffix = suffix;\n        formats.put(format, consumer);\n      } else {\n        // we've already seen this format, so just grab its suffix\n        assert suffixes.containsKey(formatName);\n        suffix = consumer.suffix;\n      }\n      \n      previousValue = field.putAttribute(PER_FIELD_SUFFIX_KEY, Integer.toString(suffix));\n      assert previousValue == null;\n\n      // TODO: we should only provide the \"slice\" of FIS\n      // that this PF actually sees ... then stuff like\n      // .hasProx could work correctly?\n      // NOTE: .hasProx is already broken in the same way for the non-perfield case,\n      // if there is a fieldinfo with prox that has no postings, you get a 0 byte file.\n      return consumer.consumer.addField(field);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b0c99c9b095ebe88603d5dc33606fdfe7782cb2f":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"818ed34f5bd799741cc36ac29a92dfcfce9c6950":["2e816e693615395fd0e107b08e48caff42938190"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","818ed34f5bd799741cc36ac29a92dfcfce9c6950"],"4356000e349e38c9fb48034695b7c309abd54557":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5":["b0c99c9b095ebe88603d5dc33606fdfe7782cb2f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2e816e693615395fd0e107b08e48caff42938190":["4356000e349e38c9fb48034695b7c309abd54557"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5"]},"commit2Childs":{"b0c99c9b095ebe88603d5dc33606fdfe7782cb2f":["519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5"],"818ed34f5bd799741cc36ac29a92dfcfce9c6950":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["b0c99c9b095ebe88603d5dc33606fdfe7782cb2f"],"4356000e349e38c9fb48034695b7c309abd54557":["2e816e693615395fd0e107b08e48caff42938190"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","4356000e349e38c9fb48034695b7c309abd54557"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"519bac5f6a2dc1779d2fe8e51d9e1762ec94b4a5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2e816e693615395fd0e107b08e48caff42938190":["818ed34f5bd799741cc36ac29a92dfcfce9c6950"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}