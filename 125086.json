{"path":"lucene/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int).mjava","commits":[{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   * </p>\n   */\n  public Automaton toAutomaton(int n) {\n    if (n == 0)\n      return BasicAutomata.makeString(input);\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    State states[] = new State[description.size()];\n    // create all states, and mark as accept states if appropriate\n    for (int i = 0; i < states.length; i++) {\n      states[i] = new State();\n      states[i].setAccept(description.isAccept(i));\n    }\n    // create transitions from state to state\n    for (int k = 0; k < states.length; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final char ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0)\n          states[k].addTransition(new Transition(ch, states[dest]));\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0)\n        for (int r = 0; r < numRanges; r++)\n          states[k].addTransition(new Transition(rangeLower[r], rangeUpper[r], states[dest]));      \n    }\n\n    Automaton a = new Automaton();\n    a.setInitialState(states[0]);\n    a.setDeterministic(true);\n    // we need not trim transitions to dead states, as they are not created.\n    // a.restoreInvariant();\n    return a;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5acb0ee59cc50caf85402e92d148fdb2af61bc19","date":1272929037,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int).mjava","sourceNew":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   * </p>\n   */\n  public Automaton toAutomaton(int n) {\n    if (n == 0)\n      return BasicAutomata.makeString(input);\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    State states[] = new State[description.size()];\n    // create all states, and mark as accept states if appropriate\n    for (int i = 0; i < states.length; i++) {\n      states[i] = new State();\n      states[i].number = i;\n      states[i].setAccept(description.isAccept(i));\n    }\n    // create transitions from state to state\n    for (int k = 0; k < states.length; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0)\n          states[k].addTransition(new Transition(ch, states[dest]));\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0)\n        for (int r = 0; r < numRanges; r++)\n          states[k].addTransition(new Transition(rangeLower[r], rangeUpper[r], states[dest]));      \n      // reduce the state: this doesn't appear to help anything\n      //states[k].reduce();\n    }\n\n    Automaton a = new Automaton(states[0]);\n    a.setDeterministic(true);\n    a.setNumberedStates(states);\n    // we need not trim transitions to dead states, as they are not created.\n    //a.restoreInvariant();\n    return a;\n  }\n\n","sourceOld":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   * </p>\n   */\n  public Automaton toAutomaton(int n) {\n    if (n == 0)\n      return BasicAutomata.makeString(input);\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    State states[] = new State[description.size()];\n    // create all states, and mark as accept states if appropriate\n    for (int i = 0; i < states.length; i++) {\n      states[i] = new State();\n      states[i].setAccept(description.isAccept(i));\n    }\n    // create transitions from state to state\n    for (int k = 0; k < states.length; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final char ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0)\n          states[k].addTransition(new Transition(ch, states[dest]));\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0)\n        for (int r = 0; r < numRanges; r++)\n          states[k].addTransition(new Transition(rangeLower[r], rangeUpper[r], states[dest]));      \n    }\n\n    Automaton a = new Automaton();\n    a.setInitialState(states[0]);\n    a.setDeterministic(true);\n    // we need not trim transitions to dead states, as they are not created.\n    // a.restoreInvariant();\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"782d081ef8a29ca6f1b14a966d0c0bee4bd03ba2","date":1305314405,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int).mjava","sourceNew":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   * </p>\n   */\n  public Automaton toAutomaton(int n) {\n    if (n == 0)\n      return BasicAutomata.makeString(input);\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    State states[] = new State[description.size()];\n    // create all states, and mark as accept states if appropriate\n    for (int i = 0; i < states.length; i++) {\n      states[i] = new State();\n      states[i].number = i;\n      states[i].setAccept(description.isAccept(i));\n    }\n    // create transitions from state to state\n    for (int k = 0; k < states.length; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0)\n          states[k].addTransition(new Transition(ch, states[dest]));\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0)\n        for (int r = 0; r < numRanges; r++)\n          states[k].addTransition(new Transition(rangeLower[r], rangeUpper[r], states[dest]));      \n    }\n\n    Automaton a = new Automaton(states[0]);\n    a.setDeterministic(true);\n    // we create some useless unconnected states, and its a net-win overall to remove these,\n    // as well as to combine any adjacent transitions (it makes later algorithms more efficient).\n    // so, while we could set our numberedStates here, its actually best not to, and instead to\n    // force a traversal in reduce, pruning the unconnected states while we combine adjacent transitions.\n    //a.setNumberedStates(states);\n    a.reduce();\n    // we need not trim transitions to dead states, as they are not created.\n    //a.restoreInvariant();\n    return a;\n  }\n\n","sourceOld":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   * </p>\n   */\n  public Automaton toAutomaton(int n) {\n    if (n == 0)\n      return BasicAutomata.makeString(input);\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    State states[] = new State[description.size()];\n    // create all states, and mark as accept states if appropriate\n    for (int i = 0; i < states.length; i++) {\n      states[i] = new State();\n      states[i].number = i;\n      states[i].setAccept(description.isAccept(i));\n    }\n    // create transitions from state to state\n    for (int k = 0; k < states.length; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0)\n          states[k].addTransition(new Transition(ch, states[dest]));\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0)\n        for (int r = 0; r < numRanges; r++)\n          states[k].addTransition(new Transition(rangeLower[r], rangeUpper[r], states[dest]));      \n      // reduce the state: this doesn't appear to help anything\n      //states[k].reduce();\n    }\n\n    Automaton a = new Automaton(states[0]);\n    a.setDeterministic(true);\n    a.setNumberedStates(states);\n    // we need not trim transitions to dead states, as they are not created.\n    //a.restoreInvariant();\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c3a8a449466c1ff7ce2274fe73dab487256964b4","date":1305735867,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int).mjava","sourceNew":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   * </p>\n   */\n  public Automaton toAutomaton(int n) {\n    if (n == 0)\n      return BasicAutomata.makeString(input);\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    State states[] = new State[description.size()];\n    // create all states, and mark as accept states if appropriate\n    for (int i = 0; i < states.length; i++) {\n      states[i] = new State();\n      states[i].number = i;\n      states[i].setAccept(description.isAccept(i));\n    }\n    // create transitions from state to state\n    for (int k = 0; k < states.length; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0)\n          states[k].addTransition(new Transition(ch, states[dest]));\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0)\n        for (int r = 0; r < numRanges; r++)\n          states[k].addTransition(new Transition(rangeLower[r], rangeUpper[r], states[dest]));      \n    }\n\n    Automaton a = new Automaton(states[0]);\n    a.setDeterministic(true);\n    // we create some useless unconnected states, and its a net-win overall to remove these,\n    // as well as to combine any adjacent transitions (it makes later algorithms more efficient).\n    // so, while we could set our numberedStates here, its actually best not to, and instead to\n    // force a traversal in reduce, pruning the unconnected states while we combine adjacent transitions.\n    //a.setNumberedStates(states);\n    a.reduce();\n    // we need not trim transitions to dead states, as they are not created.\n    //a.restoreInvariant();\n    return a;\n  }\n\n","sourceOld":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   * </p>\n   */\n  public Automaton toAutomaton(int n) {\n    if (n == 0)\n      return BasicAutomata.makeString(input);\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    State states[] = new State[description.size()];\n    // create all states, and mark as accept states if appropriate\n    for (int i = 0; i < states.length; i++) {\n      states[i] = new State();\n      states[i].number = i;\n      states[i].setAccept(description.isAccept(i));\n    }\n    // create transitions from state to state\n    for (int k = 0; k < states.length; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0)\n          states[k].addTransition(new Transition(ch, states[dest]));\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0)\n        for (int r = 0; r < numRanges; r++)\n          states[k].addTransition(new Transition(rangeLower[r], rangeUpper[r], states[dest]));      \n      // reduce the state: this doesn't appear to help anything\n      //states[k].reduce();\n    }\n\n    Automaton a = new Automaton(states[0]);\n    a.setDeterministic(true);\n    a.setNumberedStates(states);\n    // we need not trim transitions to dead states, as they are not created.\n    //a.restoreInvariant();\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int).mjava","sourceNew":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   * </p>\n   */\n  public Automaton toAutomaton(int n) {\n    if (n == 0)\n      return BasicAutomata.makeString(input);\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    State states[] = new State[description.size()];\n    // create all states, and mark as accept states if appropriate\n    for (int i = 0; i < states.length; i++) {\n      states[i] = new State();\n      states[i].number = i;\n      states[i].setAccept(description.isAccept(i));\n    }\n    // create transitions from state to state\n    for (int k = 0; k < states.length; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0)\n          states[k].addTransition(new Transition(ch, states[dest]));\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0)\n        for (int r = 0; r < numRanges; r++)\n          states[k].addTransition(new Transition(rangeLower[r], rangeUpper[r], states[dest]));      \n    }\n\n    Automaton a = new Automaton(states[0]);\n    a.setDeterministic(true);\n    // we create some useless unconnected states, and its a net-win overall to remove these,\n    // as well as to combine any adjacent transitions (it makes later algorithms more efficient).\n    // so, while we could set our numberedStates here, its actually best not to, and instead to\n    // force a traversal in reduce, pruning the unconnected states while we combine adjacent transitions.\n    //a.setNumberedStates(states);\n    a.reduce();\n    // we need not trim transitions to dead states, as they are not created.\n    //a.restoreInvariant();\n    return a;\n  }\n\n","sourceOld":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   * </p>\n   */\n  public Automaton toAutomaton(int n) {\n    if (n == 0)\n      return BasicAutomata.makeString(input);\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    State states[] = new State[description.size()];\n    // create all states, and mark as accept states if appropriate\n    for (int i = 0; i < states.length; i++) {\n      states[i] = new State();\n      states[i].number = i;\n      states[i].setAccept(description.isAccept(i));\n    }\n    // create transitions from state to state\n    for (int k = 0; k < states.length; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0)\n          states[k].addTransition(new Transition(ch, states[dest]));\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0)\n        for (int r = 0; r < numRanges; r++)\n          states[k].addTransition(new Transition(rangeLower[r], rangeUpper[r], states[dest]));      \n      // reduce the state: this doesn't appear to help anything\n      //states[k].reduce();\n    }\n\n    Automaton a = new Automaton(states[0]);\n    a.setDeterministic(true);\n    a.setNumberedStates(states);\n    // we need not trim transitions to dead states, as they are not created.\n    //a.restoreInvariant();\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#toAutomaton(int).mjava","sourceNew":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   * </p>\n   */\n  public Automaton toAutomaton(int n) {\n    if (n == 0)\n      return BasicAutomata.makeString(input);\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    State states[] = new State[description.size()];\n    // create all states, and mark as accept states if appropriate\n    for (int i = 0; i < states.length; i++) {\n      states[i] = new State();\n      states[i].number = i;\n      states[i].setAccept(description.isAccept(i));\n    }\n    // create transitions from state to state\n    for (int k = 0; k < states.length; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0)\n          states[k].addTransition(new Transition(ch, states[dest]));\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0)\n        for (int r = 0; r < numRanges; r++)\n          states[k].addTransition(new Transition(rangeLower[r], rangeUpper[r], states[dest]));      \n    }\n\n    Automaton a = new Automaton(states[0]);\n    a.setDeterministic(true);\n    // we create some useless unconnected states, and its a net-win overall to remove these,\n    // as well as to combine any adjacent transitions (it makes later algorithms more efficient).\n    // so, while we could set our numberedStates here, its actually best not to, and instead to\n    // force a traversal in reduce, pruning the unconnected states while we combine adjacent transitions.\n    //a.setNumberedStates(states);\n    a.reduce();\n    // we need not trim transitions to dead states, as they are not created.\n    //a.restoreInvariant();\n    return a;\n  }\n\n","sourceOld":"  /**\n   * Compute a DFA that accepts all strings within an edit distance of <code>n</code>.\n   * <p>\n   * All automata have the following properties:\n   * <ul>\n   * <li>They are deterministic (DFA).\n   * <li>There are no transitions to dead states.\n   * <li>They are not minimal (some transitions could be combined).\n   * </ul>\n   * </p>\n   */\n  public Automaton toAutomaton(int n) {\n    if (n == 0)\n      return BasicAutomata.makeString(input);\n    \n    if (n >= descriptions.length)\n      return null;\n    \n    final int range = 2*n+1;\n    ParametricDescription description = descriptions[n];\n    // the number of states is based on the length of the word and n\n    State states[] = new State[description.size()];\n    // create all states, and mark as accept states if appropriate\n    for (int i = 0; i < states.length; i++) {\n      states[i] = new State();\n      states[i].number = i;\n      states[i].setAccept(description.isAccept(i));\n    }\n    // create transitions from state to state\n    for (int k = 0; k < states.length; k++) {\n      final int xpos = description.getPosition(k);\n      if (xpos < 0)\n        continue;\n      final int end = xpos + Math.min(word.length - xpos, range);\n      \n      for (int x = 0; x < alphabet.length; x++) {\n        final int ch = alphabet[x];\n        // get the characteristic vector at this position wrt ch\n        final int cvec = getVector(ch, xpos, end);\n        int dest = description.transition(k, xpos, cvec);\n        if (dest >= 0)\n          states[k].addTransition(new Transition(ch, states[dest]));\n      }\n      // add transitions for all other chars in unicode\n      // by definition, their characteristic vectors are always 0,\n      // because they do not exist in the input string.\n      int dest = description.transition(k, xpos, 0); // by definition\n      if (dest >= 0)\n        for (int r = 0; r < numRanges; r++)\n          states[k].addTransition(new Transition(rangeLower[r], rangeUpper[r], states[dest]));      \n    }\n\n    Automaton a = new Automaton(states[0]);\n    a.setDeterministic(true);\n    // we create some useless unconnected states, and its a net-win overall to remove these,\n    // as well as to combine any adjacent transitions (it makes later algorithms more efficient).\n    // so, while we could set our numberedStates here, its actually best not to, and instead to\n    // force a traversal in reduce, pruning the unconnected states while we combine adjacent transitions.\n    //a.setNumberedStates(states);\n    a.reduce();\n    // we need not trim transitions to dead states, as they are not created.\n    //a.restoreInvariant();\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c3a8a449466c1ff7ce2274fe73dab487256964b4":["5acb0ee59cc50caf85402e92d148fdb2af61bc19","782d081ef8a29ca6f1b14a966d0c0bee4bd03ba2"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["782d081ef8a29ca6f1b14a966d0c0bee4bd03ba2"],"a3776dccca01c11e7046323cfad46a3b4a471233":["5acb0ee59cc50caf85402e92d148fdb2af61bc19","782d081ef8a29ca6f1b14a966d0c0bee4bd03ba2"],"5acb0ee59cc50caf85402e92d148fdb2af61bc19":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"782d081ef8a29ca6f1b14a966d0c0bee4bd03ba2":["5acb0ee59cc50caf85402e92d148fdb2af61bc19"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"c3a8a449466c1ff7ce2274fe73dab487256964b4":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a3776dccca01c11e7046323cfad46a3b4a471233":[],"5acb0ee59cc50caf85402e92d148fdb2af61bc19":["c3a8a449466c1ff7ce2274fe73dab487256964b4","a3776dccca01c11e7046323cfad46a3b4a471233","782d081ef8a29ca6f1b14a966d0c0bee4bd03ba2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["5acb0ee59cc50caf85402e92d148fdb2af61bc19"],"782d081ef8a29ca6f1b14a966d0c0bee4bd03ba2":["c3a8a449466c1ff7ce2274fe73dab487256964b4","3a119bbc8703c10faa329ec201c654b3a35a1e3e","a3776dccca01c11e7046323cfad46a3b4a471233"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c3a8a449466c1ff7ce2274fe73dab487256964b4","a3776dccca01c11e7046323cfad46a3b4a471233","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}