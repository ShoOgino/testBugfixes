{"path":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUpgradeOldSingleSegmentIndexWithAdditions().mjava","commits":[{"id":"4cc45c615dbb82bf79d5f9550286098367874fbf","date":1409571423,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUpgradeOldSingleSegmentIndexWithAdditions().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUpgradeOldSingleSegmentIndexWithAdditions().mjava","sourceNew":"  public void testUpgradeOldSingleSegmentIndexWithAdditions() throws Exception {\n    for (String name : oldSingleSegmentNames) {\n      if (VERBOSE) {\n        System.out.println(\"testUpgradeOldSingleSegmentIndexWithAdditions: index=\" +name);\n      }\n      Directory dir = newDirectory(oldIndexDirs.get(name));\n      if (dir instanceof MockDirectoryWrapper) {\n        // we need to ensure we delete old commits for this test,\n        // otherwise IndexUpgrader gets angry\n        ((MockDirectoryWrapper)dir).setEnableVirusScanner(false);\n      }\n\n      assertEquals(\"Original index must be single segment\", 1, getNumberOfSegments(dir));\n\n      // create a bunch of dummy segments\n      int id = 40;\n      RAMDirectory ramDir = new RAMDirectory();\n      for (int i = 0; i < 3; i++) {\n        // only use Log- or TieredMergePolicy, to make document addition predictable and not suddenly merge:\n        MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n        IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()))\n          .setMergePolicy(mp).setCommitOnClose(false);\n        IndexWriter w = new IndexWriter(ramDir, iwc);\n        // add few more docs:\n        for(int j = 0; j < RANDOM_MULTIPLIER * random().nextInt(30); j++) {\n          addDoc(w, id++);\n        }\n        try {\n          w.commit();\n        } finally {\n          w.close();\n        }\n      }\n      \n      // add dummy segments (which are all in current\n      // version) to single segment index\n      MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n      IndexWriterConfig iwc = new IndexWriterConfig(null)\n        .setMergePolicy(mp).setCommitOnClose(false);\n      IndexWriter w = new IndexWriter(dir, iwc);\n      w.addIndexes(ramDir);\n      try {\n        w.commit();\n      } finally {\n        w.close();\n      }\n      \n      // determine count of segments in modified index\n      final int origSegCount = getNumberOfSegments(dir);\n      \n      // ensure there is only one commit\n      assertEquals(1, DirectoryReader.listCommits(dir).size());\n      newIndexUpgrader(dir).upgrade();\n\n      final int segCount = checkAllSegmentsUpgraded(dir);\n      assertEquals(\"Index must still contain the same number of segments, as only one segment was upgraded and nothing else merged\",\n        origSegCount, segCount);\n      \n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testUpgradeOldSingleSegmentIndexWithAdditions() throws Exception {\n    for (String name : oldSingleSegmentNames) {\n      if (VERBOSE) {\n        System.out.println(\"testUpgradeOldSingleSegmentIndexWithAdditions: index=\" +name);\n      }\n      Directory dir = newDirectory(oldIndexDirs.get(name));\n      if (dir instanceof MockDirectoryWrapper) {\n        // we need to ensure we delete old commits for this test,\n        // otherwise IndexUpgrader gets angry\n        ((MockDirectoryWrapper)dir).setEnableVirusScanner(false);\n      }\n\n      assertEquals(\"Original index must be single segment\", 1, getNumberOfSegments(dir));\n\n      // create a bunch of dummy segments\n      int id = 40;\n      RAMDirectory ramDir = new RAMDirectory();\n      for (int i = 0; i < 3; i++) {\n        // only use Log- or TieredMergePolicy, to make document addition predictable and not suddenly merge:\n        MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n        IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()))\n          .setMergePolicy(mp).setCommitOnClose(false);\n        IndexWriter w = new IndexWriter(ramDir, iwc);\n        // add few more docs:\n        for(int j = 0; j < RANDOM_MULTIPLIER * random().nextInt(30); j++) {\n          addDoc(w, id++);\n        }\n        try {\n          w.commit();\n        } finally {\n          w.close();\n        }\n      }\n      \n      // add dummy segments (which are all in current\n      // version) to single segment index\n      MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n      IndexWriterConfig iwc = new IndexWriterConfig(null)\n        .setMergePolicy(mp).setCommitOnClose(false);\n      IndexWriter w = new IndexWriter(dir, iwc);\n      w.addIndexes(ramDir);\n      try {\n        w.commit();\n      } finally {\n        w.close();\n      }\n      \n      // determine count of segments in modified index\n      final int origSegCount = getNumberOfSegments(dir);\n      \n      // ensure there is only one commit\n      assertEquals(1, DirectoryReader.listCommits(dir).size());\n      newIndexUpgrader(dir).upgrade();\n\n      final int segCount = checkAllSegmentsUpgraded(dir);\n      assertEquals(\"Index must still contain the same number of segments, as only one segment was upgraded and nothing else merged\",\n        origSegCount, segCount);\n      \n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"402ad3ddc9da7b70da1b167667a60ece6a1381fb","date":1409656478,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUpgradeOldSingleSegmentIndexWithAdditions().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUpgradeOldSingleSegmentIndexWithAdditions().mjava","sourceNew":"  public void testUpgradeOldSingleSegmentIndexWithAdditions() throws Exception {\n    for (String name : oldSingleSegmentNames) {\n      if (VERBOSE) {\n        System.out.println(\"testUpgradeOldSingleSegmentIndexWithAdditions: index=\" +name);\n      }\n      Directory dir = newDirectory(oldIndexDirs.get(name));\n      if (dir instanceof MockDirectoryWrapper) {\n        // we need to ensure we delete old commits for this test,\n        // otherwise IndexUpgrader gets angry\n        ((MockDirectoryWrapper)dir).setEnableVirusScanner(false);\n      }\n\n      assertEquals(\"Original index must be single segment\", 1, getNumberOfSegments(dir));\n\n      // create a bunch of dummy segments\n      int id = 40;\n      RAMDirectory ramDir = new RAMDirectory();\n      for (int i = 0; i < 3; i++) {\n        // only use Log- or TieredMergePolicy, to make document addition predictable and not suddenly merge:\n        MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n        IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()))\n          .setMergePolicy(mp).setCommitOnClose(false);\n        IndexWriter w = new IndexWriter(ramDir, iwc);\n        // add few more docs:\n        for(int j = 0; j < RANDOM_MULTIPLIER * random().nextInt(30); j++) {\n          addDoc(w, id++);\n        }\n        try {\n          w.commit();\n        } finally {\n          w.close();\n        }\n      }\n      \n      // add dummy segments (which are all in current\n      // version) to single segment index\n      MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n      IndexWriterConfig iwc = new IndexWriterConfig(null)\n        .setMergePolicy(mp).setCommitOnClose(false);\n      IndexWriter w = new IndexWriter(dir, iwc);\n      w.addIndexes(ramDir);\n      try {\n        w.commit();\n      } finally {\n        w.close();\n      }\n      \n      // determine count of segments in modified index\n      final int origSegCount = getNumberOfSegments(dir);\n      \n      // ensure there is only one commit\n      assertEquals(1, DirectoryReader.listCommits(dir).size());\n      newIndexUpgrader(dir).upgrade();\n\n      final int segCount = checkAllSegmentsUpgraded(dir);\n      assertEquals(\"Index must still contain the same number of segments, as only one segment was upgraded and nothing else merged\",\n        origSegCount, segCount);\n      \n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testUpgradeOldSingleSegmentIndexWithAdditions() throws Exception {\n    for (String name : oldSingleSegmentNames) {\n      if (VERBOSE) {\n        System.out.println(\"testUpgradeOldSingleSegmentIndexWithAdditions: index=\" +name);\n      }\n      Directory dir = newDirectory(oldIndexDirs.get(name));\n      if (dir instanceof MockDirectoryWrapper) {\n        // we need to ensure we delete old commits for this test,\n        // otherwise IndexUpgrader gets angry\n        ((MockDirectoryWrapper)dir).setEnableVirusScanner(false);\n      }\n\n      assertEquals(\"Original index must be single segment\", 1, getNumberOfSegments(dir));\n\n      // create a bunch of dummy segments\n      int id = 40;\n      RAMDirectory ramDir = new RAMDirectory();\n      for (int i = 0; i < 3; i++) {\n        // only use Log- or TieredMergePolicy, to make document addition predictable and not suddenly merge:\n        MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n        IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()))\n          .setMergePolicy(mp).setCommitOnClose(false);\n        IndexWriter w = new IndexWriter(ramDir, iwc);\n        // add few more docs:\n        for(int j = 0; j < RANDOM_MULTIPLIER * random().nextInt(30); j++) {\n          addDoc(w, id++);\n        }\n        try {\n          w.commit();\n        } finally {\n          w.close();\n        }\n      }\n      \n      // add dummy segments (which are all in current\n      // version) to single segment index\n      MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n      IndexWriterConfig iwc = new IndexWriterConfig(null)\n        .setMergePolicy(mp).setCommitOnClose(false);\n      IndexWriter w = new IndexWriter(dir, iwc);\n      w.addIndexes(ramDir);\n      try {\n        w.commit();\n      } finally {\n        w.close();\n      }\n      \n      // determine count of segments in modified index\n      final int origSegCount = getNumberOfSegments(dir);\n      \n      // ensure there is only one commit\n      assertEquals(1, DirectoryReader.listCommits(dir).size());\n      newIndexUpgrader(dir).upgrade();\n\n      final int segCount = checkAllSegmentsUpgraded(dir);\n      assertEquals(\"Index must still contain the same number of segments, as only one segment was upgraded and nothing else merged\",\n        origSegCount, segCount);\n      \n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a9ddc72fd2ccf17a2abfe0f267f506789a71ce47","date":1412199696,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUpgradeOldSingleSegmentIndexWithAdditions().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUpgradeOldSingleSegmentIndexWithAdditions().mjava","sourceNew":"  public void testUpgradeOldSingleSegmentIndexWithAdditions() throws Exception {\n    for (String name : oldSingleSegmentNames) {\n      if (VERBOSE) {\n        System.out.println(\"testUpgradeOldSingleSegmentIndexWithAdditions: index=\" +name);\n      }\n      Directory dir = newDirectory(oldIndexDirs.get(name));\n      if (dir instanceof MockDirectoryWrapper) {\n        // we need to ensure we delete old commits for this test,\n        // otherwise IndexUpgrader gets angry\n        ((MockDirectoryWrapper)dir).setEnableVirusScanner(false);\n      }\n\n      assertEquals(\"Original index must be single segment\", 1, getNumberOfSegments(dir));\n\n      // create a bunch of dummy segments\n      int id = 40;\n      RAMDirectory ramDir = new RAMDirectory();\n      for (int i = 0; i < 3; i++) {\n        // only use Log- or TieredMergePolicy, to make document addition predictable and not suddenly merge:\n        MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n        IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()))\n          .setMergePolicy(mp);\n        IndexWriter w = new IndexWriter(ramDir, iwc);\n        // add few more docs:\n        for(int j = 0; j < RANDOM_MULTIPLIER * random().nextInt(30); j++) {\n          addDoc(w, id++);\n        }\n        try {\n          w.commit();\n        } finally {\n          w.close();\n        }\n      }\n      \n      // add dummy segments (which are all in current\n      // version) to single segment index\n      MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n      IndexWriterConfig iwc = new IndexWriterConfig(null)\n        .setMergePolicy(mp);\n      IndexWriter w = new IndexWriter(dir, iwc);\n      w.addIndexes(ramDir);\n      try {\n        w.commit();\n      } finally {\n        w.close();\n      }\n      \n      // determine count of segments in modified index\n      final int origSegCount = getNumberOfSegments(dir);\n      \n      // ensure there is only one commit\n      assertEquals(1, DirectoryReader.listCommits(dir).size());\n      newIndexUpgrader(dir).upgrade();\n\n      final int segCount = checkAllSegmentsUpgraded(dir);\n      assertEquals(\"Index must still contain the same number of segments, as only one segment was upgraded and nothing else merged\",\n        origSegCount, segCount);\n      \n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testUpgradeOldSingleSegmentIndexWithAdditions() throws Exception {\n    for (String name : oldSingleSegmentNames) {\n      if (VERBOSE) {\n        System.out.println(\"testUpgradeOldSingleSegmentIndexWithAdditions: index=\" +name);\n      }\n      Directory dir = newDirectory(oldIndexDirs.get(name));\n      if (dir instanceof MockDirectoryWrapper) {\n        // we need to ensure we delete old commits for this test,\n        // otherwise IndexUpgrader gets angry\n        ((MockDirectoryWrapper)dir).setEnableVirusScanner(false);\n      }\n\n      assertEquals(\"Original index must be single segment\", 1, getNumberOfSegments(dir));\n\n      // create a bunch of dummy segments\n      int id = 40;\n      RAMDirectory ramDir = new RAMDirectory();\n      for (int i = 0; i < 3; i++) {\n        // only use Log- or TieredMergePolicy, to make document addition predictable and not suddenly merge:\n        MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n        IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()))\n          .setMergePolicy(mp).setCommitOnClose(false);\n        IndexWriter w = new IndexWriter(ramDir, iwc);\n        // add few more docs:\n        for(int j = 0; j < RANDOM_MULTIPLIER * random().nextInt(30); j++) {\n          addDoc(w, id++);\n        }\n        try {\n          w.commit();\n        } finally {\n          w.close();\n        }\n      }\n      \n      // add dummy segments (which are all in current\n      // version) to single segment index\n      MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n      IndexWriterConfig iwc = new IndexWriterConfig(null)\n        .setMergePolicy(mp).setCommitOnClose(false);\n      IndexWriter w = new IndexWriter(dir, iwc);\n      w.addIndexes(ramDir);\n      try {\n        w.commit();\n      } finally {\n        w.close();\n      }\n      \n      // determine count of segments in modified index\n      final int origSegCount = getNumberOfSegments(dir);\n      \n      // ensure there is only one commit\n      assertEquals(1, DirectoryReader.listCommits(dir).size());\n      newIndexUpgrader(dir).upgrade();\n\n      final int segCount = checkAllSegmentsUpgraded(dir);\n      assertEquals(\"Index must still contain the same number of segments, as only one segment was upgraded and nothing else merged\",\n        origSegCount, segCount);\n      \n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9a47902d6207303f5ed3e7aaca62ca33433af66","date":1412435312,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUpgradeOldSingleSegmentIndexWithAdditions().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUpgradeOldSingleSegmentIndexWithAdditions().mjava","sourceNew":"  public void testUpgradeOldSingleSegmentIndexWithAdditions() throws Exception {\n    for (String name : oldSingleSegmentNames) {\n      if (VERBOSE) {\n        System.out.println(\"testUpgradeOldSingleSegmentIndexWithAdditions: index=\" +name);\n      }\n      Directory dir = newDirectory(oldIndexDirs.get(name));\n      if (dir instanceof MockDirectoryWrapper) {\n        // we need to ensure we delete old commits for this test,\n        // otherwise IndexUpgrader gets angry\n        ((MockDirectoryWrapper)dir).setEnableVirusScanner(false);\n      }\n\n      assertEquals(\"Original index must be single segment\", 1, getNumberOfSegments(dir));\n\n      // create a bunch of dummy segments\n      int id = 40;\n      RAMDirectory ramDir = new RAMDirectory();\n      for (int i = 0; i < 3; i++) {\n        // only use Log- or TieredMergePolicy, to make document addition predictable and not suddenly merge:\n        MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n        IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()))\n          .setMergePolicy(mp);\n        IndexWriter w = new IndexWriter(ramDir, iwc);\n        // add few more docs:\n        for(int j = 0; j < RANDOM_MULTIPLIER * random().nextInt(30); j++) {\n          addDoc(w, id++);\n        }\n        try {\n          w.commit();\n        } finally {\n          w.close();\n        }\n      }\n      \n      // add dummy segments (which are all in current\n      // version) to single segment index\n      MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n      IndexWriterConfig iwc = new IndexWriterConfig(null)\n        .setMergePolicy(mp);\n      IndexWriter w = new IndexWriter(dir, iwc);\n      w.addIndexes(ramDir);\n      try {\n        w.commit();\n      } finally {\n        w.close();\n      }\n      \n      // determine count of segments in modified index\n      final int origSegCount = getNumberOfSegments(dir);\n      \n      // ensure there is only one commit\n      assertEquals(1, DirectoryReader.listCommits(dir).size());\n      newIndexUpgrader(dir).upgrade();\n\n      final int segCount = checkAllSegmentsUpgraded(dir);\n      assertEquals(\"Index must still contain the same number of segments, as only one segment was upgraded and nothing else merged\",\n        origSegCount, segCount);\n      \n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testUpgradeOldSingleSegmentIndexWithAdditions() throws Exception {\n    for (String name : oldSingleSegmentNames) {\n      if (VERBOSE) {\n        System.out.println(\"testUpgradeOldSingleSegmentIndexWithAdditions: index=\" +name);\n      }\n      Directory dir = newDirectory(oldIndexDirs.get(name));\n      if (dir instanceof MockDirectoryWrapper) {\n        // we need to ensure we delete old commits for this test,\n        // otherwise IndexUpgrader gets angry\n        ((MockDirectoryWrapper)dir).setEnableVirusScanner(false);\n      }\n\n      assertEquals(\"Original index must be single segment\", 1, getNumberOfSegments(dir));\n\n      // create a bunch of dummy segments\n      int id = 40;\n      RAMDirectory ramDir = new RAMDirectory();\n      for (int i = 0; i < 3; i++) {\n        // only use Log- or TieredMergePolicy, to make document addition predictable and not suddenly merge:\n        MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n        IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()))\n          .setMergePolicy(mp).setCommitOnClose(false);\n        IndexWriter w = new IndexWriter(ramDir, iwc);\n        // add few more docs:\n        for(int j = 0; j < RANDOM_MULTIPLIER * random().nextInt(30); j++) {\n          addDoc(w, id++);\n        }\n        try {\n          w.commit();\n        } finally {\n          w.close();\n        }\n      }\n      \n      // add dummy segments (which are all in current\n      // version) to single segment index\n      MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n      IndexWriterConfig iwc = new IndexWriterConfig(null)\n        .setMergePolicy(mp).setCommitOnClose(false);\n      IndexWriter w = new IndexWriter(dir, iwc);\n      w.addIndexes(ramDir);\n      try {\n        w.commit();\n      } finally {\n        w.close();\n      }\n      \n      // determine count of segments in modified index\n      final int origSegCount = getNumberOfSegments(dir);\n      \n      // ensure there is only one commit\n      assertEquals(1, DirectoryReader.listCommits(dir).size());\n      newIndexUpgrader(dir).upgrade();\n\n      final int segCount = checkAllSegmentsUpgraded(dir);\n      assertEquals(\"Index must still contain the same number of segments, as only one segment was upgraded and nothing else merged\",\n        origSegCount, segCount);\n      \n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bfe104fc023fadc9e709f8d17403d2cc61133fe","date":1454446396,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUpgradeOldSingleSegmentIndexWithAdditions().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUpgradeOldSingleSegmentIndexWithAdditions().mjava","sourceNew":"  public void testUpgradeOldSingleSegmentIndexWithAdditions() throws Exception {\n    for (String name : oldSingleSegmentNames) {\n      if (VERBOSE) {\n        System.out.println(\"testUpgradeOldSingleSegmentIndexWithAdditions: index=\" +name);\n      }\n      Directory dir = newDirectory(oldIndexDirs.get(name));\n      assertEquals(\"Original index must be single segment\", 1, getNumberOfSegments(dir));\n\n      // create a bunch of dummy segments\n      int id = 40;\n      RAMDirectory ramDir = new RAMDirectory();\n      for (int i = 0; i < 3; i++) {\n        // only use Log- or TieredMergePolicy, to make document addition predictable and not suddenly merge:\n        MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n        IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()))\n          .setMergePolicy(mp);\n        IndexWriter w = new IndexWriter(ramDir, iwc);\n        // add few more docs:\n        for(int j = 0; j < RANDOM_MULTIPLIER * random().nextInt(30); j++) {\n          addDoc(w, id++);\n        }\n        try {\n          w.commit();\n        } finally {\n          w.close();\n        }\n      }\n      \n      // add dummy segments (which are all in current\n      // version) to single segment index\n      MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n      IndexWriterConfig iwc = new IndexWriterConfig(null)\n        .setMergePolicy(mp);\n      IndexWriter w = new IndexWriter(dir, iwc);\n      w.addIndexes(ramDir);\n      try {\n        w.commit();\n      } finally {\n        w.close();\n      }\n      \n      // determine count of segments in modified index\n      final int origSegCount = getNumberOfSegments(dir);\n      \n      // ensure there is only one commit\n      assertEquals(1, DirectoryReader.listCommits(dir).size());\n      newIndexUpgrader(dir).upgrade();\n\n      final int segCount = checkAllSegmentsUpgraded(dir);\n      assertEquals(\"Index must still contain the same number of segments, as only one segment was upgraded and nothing else merged\",\n        origSegCount, segCount);\n      \n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testUpgradeOldSingleSegmentIndexWithAdditions() throws Exception {\n    for (String name : oldSingleSegmentNames) {\n      if (VERBOSE) {\n        System.out.println(\"testUpgradeOldSingleSegmentIndexWithAdditions: index=\" +name);\n      }\n      Directory dir = newDirectory(oldIndexDirs.get(name));\n      if (dir instanceof MockDirectoryWrapper) {\n        // we need to ensure we delete old commits for this test,\n        // otherwise IndexUpgrader gets angry\n        ((MockDirectoryWrapper)dir).setEnableVirusScanner(false);\n      }\n\n      assertEquals(\"Original index must be single segment\", 1, getNumberOfSegments(dir));\n\n      // create a bunch of dummy segments\n      int id = 40;\n      RAMDirectory ramDir = new RAMDirectory();\n      for (int i = 0; i < 3; i++) {\n        // only use Log- or TieredMergePolicy, to make document addition predictable and not suddenly merge:\n        MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n        IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()))\n          .setMergePolicy(mp);\n        IndexWriter w = new IndexWriter(ramDir, iwc);\n        // add few more docs:\n        for(int j = 0; j < RANDOM_MULTIPLIER * random().nextInt(30); j++) {\n          addDoc(w, id++);\n        }\n        try {\n          w.commit();\n        } finally {\n          w.close();\n        }\n      }\n      \n      // add dummy segments (which are all in current\n      // version) to single segment index\n      MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n      IndexWriterConfig iwc = new IndexWriterConfig(null)\n        .setMergePolicy(mp);\n      IndexWriter w = new IndexWriter(dir, iwc);\n      w.addIndexes(ramDir);\n      try {\n        w.commit();\n      } finally {\n        w.close();\n      }\n      \n      // determine count of segments in modified index\n      final int origSegCount = getNumberOfSegments(dir);\n      \n      // ensure there is only one commit\n      assertEquals(1, DirectoryReader.listCommits(dir).size());\n      newIndexUpgrader(dir).upgrade();\n\n      final int segCount = checkAllSegmentsUpgraded(dir);\n      assertEquals(\"Index must still contain the same number of segments, as only one segment was upgraded and nothing else merged\",\n        origSegCount, segCount);\n      \n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b470f36a9372c97283360b1304eacbde22df6c0d","date":1454765175,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUpgradeOldSingleSegmentIndexWithAdditions().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUpgradeOldSingleSegmentIndexWithAdditions().mjava","sourceNew":"  public void testUpgradeOldSingleSegmentIndexWithAdditions() throws Exception {\n    for (String name : oldSingleSegmentNames) {\n      if (VERBOSE) {\n        System.out.println(\"testUpgradeOldSingleSegmentIndexWithAdditions: index=\" +name);\n      }\n      Directory dir = newDirectory(oldIndexDirs.get(name));\n      assertEquals(\"Original index must be single segment\", 1, getNumberOfSegments(dir));\n\n      // create a bunch of dummy segments\n      int id = 40;\n      RAMDirectory ramDir = new RAMDirectory();\n      for (int i = 0; i < 3; i++) {\n        // only use Log- or TieredMergePolicy, to make document addition predictable and not suddenly merge:\n        MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n        IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()))\n          .setMergePolicy(mp);\n        IndexWriter w = new IndexWriter(ramDir, iwc);\n        // add few more docs:\n        for(int j = 0; j < RANDOM_MULTIPLIER * random().nextInt(30); j++) {\n          addDoc(w, id++);\n        }\n        try {\n          w.commit();\n        } finally {\n          w.close();\n        }\n      }\n      \n      // add dummy segments (which are all in current\n      // version) to single segment index\n      MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n      IndexWriterConfig iwc = new IndexWriterConfig(null)\n        .setMergePolicy(mp);\n      IndexWriter w = new IndexWriter(dir, iwc);\n      w.addIndexes(ramDir);\n      try {\n        w.commit();\n      } finally {\n        w.close();\n      }\n      \n      // determine count of segments in modified index\n      final int origSegCount = getNumberOfSegments(dir);\n      \n      // ensure there is only one commit\n      assertEquals(1, DirectoryReader.listCommits(dir).size());\n      newIndexUpgrader(dir).upgrade();\n\n      final int segCount = checkAllSegmentsUpgraded(dir);\n      assertEquals(\"Index must still contain the same number of segments, as only one segment was upgraded and nothing else merged\",\n        origSegCount, segCount);\n      \n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testUpgradeOldSingleSegmentIndexWithAdditions() throws Exception {\n    for (String name : oldSingleSegmentNames) {\n      if (VERBOSE) {\n        System.out.println(\"testUpgradeOldSingleSegmentIndexWithAdditions: index=\" +name);\n      }\n      Directory dir = newDirectory(oldIndexDirs.get(name));\n      if (dir instanceof MockDirectoryWrapper) {\n        // we need to ensure we delete old commits for this test,\n        // otherwise IndexUpgrader gets angry\n        ((MockDirectoryWrapper)dir).setEnableVirusScanner(false);\n      }\n\n      assertEquals(\"Original index must be single segment\", 1, getNumberOfSegments(dir));\n\n      // create a bunch of dummy segments\n      int id = 40;\n      RAMDirectory ramDir = new RAMDirectory();\n      for (int i = 0; i < 3; i++) {\n        // only use Log- or TieredMergePolicy, to make document addition predictable and not suddenly merge:\n        MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n        IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()))\n          .setMergePolicy(mp);\n        IndexWriter w = new IndexWriter(ramDir, iwc);\n        // add few more docs:\n        for(int j = 0; j < RANDOM_MULTIPLIER * random().nextInt(30); j++) {\n          addDoc(w, id++);\n        }\n        try {\n          w.commit();\n        } finally {\n          w.close();\n        }\n      }\n      \n      // add dummy segments (which are all in current\n      // version) to single segment index\n      MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n      IndexWriterConfig iwc = new IndexWriterConfig(null)\n        .setMergePolicy(mp);\n      IndexWriter w = new IndexWriter(dir, iwc);\n      w.addIndexes(ramDir);\n      try {\n        w.commit();\n      } finally {\n        w.close();\n      }\n      \n      // determine count of segments in modified index\n      final int origSegCount = getNumberOfSegments(dir);\n      \n      // ensure there is only one commit\n      assertEquals(1, DirectoryReader.listCommits(dir).size());\n      newIndexUpgrader(dir).upgrade();\n\n      final int segCount = checkAllSegmentsUpgraded(dir);\n      assertEquals(\"Index must still contain the same number of segments, as only one segment was upgraded and nothing else merged\",\n        origSegCount, segCount);\n      \n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUpgradeOldSingleSegmentIndexWithAdditions().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUpgradeOldSingleSegmentIndexWithAdditions().mjava","sourceNew":"  public void testUpgradeOldSingleSegmentIndexWithAdditions() throws Exception {\n    for (String name : oldSingleSegmentNames) {\n      if (VERBOSE) {\n        System.out.println(\"testUpgradeOldSingleSegmentIndexWithAdditions: index=\" +name);\n      }\n      Directory dir = newDirectory(oldIndexDirs.get(name));\n      assertEquals(\"Original index must be single segment\", 1, getNumberOfSegments(dir));\n\n      // create a bunch of dummy segments\n      int id = 40;\n      RAMDirectory ramDir = new RAMDirectory();\n      for (int i = 0; i < 3; i++) {\n        // only use Log- or TieredMergePolicy, to make document addition predictable and not suddenly merge:\n        MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n        IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()))\n          .setMergePolicy(mp);\n        IndexWriter w = new IndexWriter(ramDir, iwc);\n        // add few more docs:\n        for(int j = 0; j < RANDOM_MULTIPLIER * random().nextInt(30); j++) {\n          addDoc(w, id++);\n        }\n        try {\n          w.commit();\n        } finally {\n          w.close();\n        }\n      }\n      \n      // add dummy segments (which are all in current\n      // version) to single segment index\n      MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n      IndexWriterConfig iwc = new IndexWriterConfig(null)\n        .setMergePolicy(mp);\n      IndexWriter w = new IndexWriter(dir, iwc);\n      w.addIndexes(ramDir);\n      try {\n        w.commit();\n      } finally {\n        w.close();\n      }\n      \n      // determine count of segments in modified index\n      final int origSegCount = getNumberOfSegments(dir);\n      \n      // ensure there is only one commit\n      assertEquals(1, DirectoryReader.listCommits(dir).size());\n      newIndexUpgrader(dir).upgrade();\n\n      final int segCount = checkAllSegmentsUpgraded(dir);\n      assertEquals(\"Index must still contain the same number of segments, as only one segment was upgraded and nothing else merged\",\n        origSegCount, segCount);\n      \n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testUpgradeOldSingleSegmentIndexWithAdditions() throws Exception {\n    for (String name : oldSingleSegmentNames) {\n      if (VERBOSE) {\n        System.out.println(\"testUpgradeOldSingleSegmentIndexWithAdditions: index=\" +name);\n      }\n      Directory dir = newDirectory(oldIndexDirs.get(name));\n      if (dir instanceof MockDirectoryWrapper) {\n        // we need to ensure we delete old commits for this test,\n        // otherwise IndexUpgrader gets angry\n        ((MockDirectoryWrapper)dir).setEnableVirusScanner(false);\n      }\n\n      assertEquals(\"Original index must be single segment\", 1, getNumberOfSegments(dir));\n\n      // create a bunch of dummy segments\n      int id = 40;\n      RAMDirectory ramDir = new RAMDirectory();\n      for (int i = 0; i < 3; i++) {\n        // only use Log- or TieredMergePolicy, to make document addition predictable and not suddenly merge:\n        MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n        IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()))\n          .setMergePolicy(mp);\n        IndexWriter w = new IndexWriter(ramDir, iwc);\n        // add few more docs:\n        for(int j = 0; j < RANDOM_MULTIPLIER * random().nextInt(30); j++) {\n          addDoc(w, id++);\n        }\n        try {\n          w.commit();\n        } finally {\n          w.close();\n        }\n      }\n      \n      // add dummy segments (which are all in current\n      // version) to single segment index\n      MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n      IndexWriterConfig iwc = new IndexWriterConfig(null)\n        .setMergePolicy(mp);\n      IndexWriter w = new IndexWriter(dir, iwc);\n      w.addIndexes(ramDir);\n      try {\n        w.commit();\n      } finally {\n        w.close();\n      }\n      \n      // determine count of segments in modified index\n      final int origSegCount = getNumberOfSegments(dir);\n      \n      // ensure there is only one commit\n      assertEquals(1, DirectoryReader.listCommits(dir).size());\n      newIndexUpgrader(dir).upgrade();\n\n      final int segCount = checkAllSegmentsUpgraded(dir);\n      assertEquals(\"Index must still contain the same number of segments, as only one segment was upgraded and nothing else merged\",\n        origSegCount, segCount);\n      \n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a207d19eac354d649c3f0e2cce070017c78125e","date":1454776470,"type":3,"author":"Erick Erickson","isMerge":true,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUpgradeOldSingleSegmentIndexWithAdditions().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUpgradeOldSingleSegmentIndexWithAdditions().mjava","sourceNew":"  public void testUpgradeOldSingleSegmentIndexWithAdditions() throws Exception {\n    for (String name : oldSingleSegmentNames) {\n      if (VERBOSE) {\n        System.out.println(\"testUpgradeOldSingleSegmentIndexWithAdditions: index=\" +name);\n      }\n      Directory dir = newDirectory(oldIndexDirs.get(name));\n      assertEquals(\"Original index must be single segment\", 1, getNumberOfSegments(dir));\n\n      // create a bunch of dummy segments\n      int id = 40;\n      RAMDirectory ramDir = new RAMDirectory();\n      for (int i = 0; i < 3; i++) {\n        // only use Log- or TieredMergePolicy, to make document addition predictable and not suddenly merge:\n        MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n        IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()))\n          .setMergePolicy(mp);\n        IndexWriter w = new IndexWriter(ramDir, iwc);\n        // add few more docs:\n        for(int j = 0; j < RANDOM_MULTIPLIER * random().nextInt(30); j++) {\n          addDoc(w, id++);\n        }\n        try {\n          w.commit();\n        } finally {\n          w.close();\n        }\n      }\n      \n      // add dummy segments (which are all in current\n      // version) to single segment index\n      MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n      IndexWriterConfig iwc = new IndexWriterConfig(null)\n        .setMergePolicy(mp);\n      IndexWriter w = new IndexWriter(dir, iwc);\n      w.addIndexes(ramDir);\n      try {\n        w.commit();\n      } finally {\n        w.close();\n      }\n      \n      // determine count of segments in modified index\n      final int origSegCount = getNumberOfSegments(dir);\n      \n      // ensure there is only one commit\n      assertEquals(1, DirectoryReader.listCommits(dir).size());\n      newIndexUpgrader(dir).upgrade();\n\n      final int segCount = checkAllSegmentsUpgraded(dir);\n      assertEquals(\"Index must still contain the same number of segments, as only one segment was upgraded and nothing else merged\",\n        origSegCount, segCount);\n      \n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testUpgradeOldSingleSegmentIndexWithAdditions() throws Exception {\n    for (String name : oldSingleSegmentNames) {\n      if (VERBOSE) {\n        System.out.println(\"testUpgradeOldSingleSegmentIndexWithAdditions: index=\" +name);\n      }\n      Directory dir = newDirectory(oldIndexDirs.get(name));\n      if (dir instanceof MockDirectoryWrapper) {\n        // we need to ensure we delete old commits for this test,\n        // otherwise IndexUpgrader gets angry\n        ((MockDirectoryWrapper)dir).setEnableVirusScanner(false);\n      }\n\n      assertEquals(\"Original index must be single segment\", 1, getNumberOfSegments(dir));\n\n      // create a bunch of dummy segments\n      int id = 40;\n      RAMDirectory ramDir = new RAMDirectory();\n      for (int i = 0; i < 3; i++) {\n        // only use Log- or TieredMergePolicy, to make document addition predictable and not suddenly merge:\n        MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n        IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()))\n          .setMergePolicy(mp);\n        IndexWriter w = new IndexWriter(ramDir, iwc);\n        // add few more docs:\n        for(int j = 0; j < RANDOM_MULTIPLIER * random().nextInt(30); j++) {\n          addDoc(w, id++);\n        }\n        try {\n          w.commit();\n        } finally {\n          w.close();\n        }\n      }\n      \n      // add dummy segments (which are all in current\n      // version) to single segment index\n      MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n      IndexWriterConfig iwc = new IndexWriterConfig(null)\n        .setMergePolicy(mp);\n      IndexWriter w = new IndexWriter(dir, iwc);\n      w.addIndexes(ramDir);\n      try {\n        w.commit();\n      } finally {\n        w.close();\n      }\n      \n      // determine count of segments in modified index\n      final int origSegCount = getNumberOfSegments(dir);\n      \n      // ensure there is only one commit\n      assertEquals(1, DirectoryReader.listCommits(dir).size());\n      newIndexUpgrader(dir).upgrade();\n\n      final int segCount = checkAllSegmentsUpgraded(dir);\n      assertEquals(\"Index must still contain the same number of segments, as only one segment was upgraded and nothing else merged\",\n        origSegCount, segCount);\n      \n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d97ba94eef1fc33c5451259a7aa2ac682646c1af","date":1488285427,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUpgradeOldSingleSegmentIndexWithAdditions().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUpgradeOldSingleSegmentIndexWithAdditions().mjava","sourceNew":"  public void testUpgradeOldSingleSegmentIndexWithAdditions() throws Exception {\n    for (String name : oldSingleSegmentNames) {\n      if (VERBOSE) {\n        System.out.println(\"testUpgradeOldSingleSegmentIndexWithAdditions: index=\" +name);\n      }\n      Directory dir = newDirectory(oldIndexDirs.get(name));\n      assertEquals(\"Original index must be single segment\", 1, getNumberOfSegments(dir));\n      Version indexCreatedVersion = SegmentInfos.readLatestCommit(dir).getIndexCreatedVersion();\n\n      // create a bunch of dummy segments\n      int id = 40;\n      RAMDirectory ramDir = new RAMDirectory();\n      for (int i = 0; i < 3; i++) {\n        // only use Log- or TieredMergePolicy, to make document addition predictable and not suddenly merge:\n        MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n        IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()))\n          .setMergePolicy(mp);\n        IndexWriter w = new IndexWriter(ramDir, iwc);\n        // add few more docs:\n        for(int j = 0; j < RANDOM_MULTIPLIER * random().nextInt(30); j++) {\n          addDoc(w, id++);\n        }\n        try {\n          w.commit();\n        } finally {\n          w.close();\n        }\n      }\n      \n      // add dummy segments (which are all in current\n      // version) to single segment index\n      MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n      IndexWriterConfig iwc = new IndexWriterConfig(null)\n        .setMergePolicy(mp);\n      IndexWriter w = new IndexWriter(dir, iwc);\n      w.addIndexes(ramDir);\n      try {\n        w.commit();\n      } finally {\n        w.close();\n      }\n      \n      // determine count of segments in modified index\n      final int origSegCount = getNumberOfSegments(dir);\n      \n      // ensure there is only one commit\n      assertEquals(1, DirectoryReader.listCommits(dir).size());\n      newIndexUpgrader(dir).upgrade();\n\n      final int segCount = checkAllSegmentsUpgraded(dir, indexCreatedVersion);\n      assertEquals(\"Index must still contain the same number of segments, as only one segment was upgraded and nothing else merged\",\n        origSegCount, segCount);\n      \n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testUpgradeOldSingleSegmentIndexWithAdditions() throws Exception {\n    for (String name : oldSingleSegmentNames) {\n      if (VERBOSE) {\n        System.out.println(\"testUpgradeOldSingleSegmentIndexWithAdditions: index=\" +name);\n      }\n      Directory dir = newDirectory(oldIndexDirs.get(name));\n      assertEquals(\"Original index must be single segment\", 1, getNumberOfSegments(dir));\n\n      // create a bunch of dummy segments\n      int id = 40;\n      RAMDirectory ramDir = new RAMDirectory();\n      for (int i = 0; i < 3; i++) {\n        // only use Log- or TieredMergePolicy, to make document addition predictable and not suddenly merge:\n        MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n        IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()))\n          .setMergePolicy(mp);\n        IndexWriter w = new IndexWriter(ramDir, iwc);\n        // add few more docs:\n        for(int j = 0; j < RANDOM_MULTIPLIER * random().nextInt(30); j++) {\n          addDoc(w, id++);\n        }\n        try {\n          w.commit();\n        } finally {\n          w.close();\n        }\n      }\n      \n      // add dummy segments (which are all in current\n      // version) to single segment index\n      MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n      IndexWriterConfig iwc = new IndexWriterConfig(null)\n        .setMergePolicy(mp);\n      IndexWriter w = new IndexWriter(dir, iwc);\n      w.addIndexes(ramDir);\n      try {\n        w.commit();\n      } finally {\n        w.close();\n      }\n      \n      // determine count of segments in modified index\n      final int origSegCount = getNumberOfSegments(dir);\n      \n      // ensure there is only one commit\n      assertEquals(1, DirectoryReader.listCommits(dir).size());\n      newIndexUpgrader(dir).upgrade();\n\n      final int segCount = checkAllSegmentsUpgraded(dir);\n      assertEquals(\"Index must still contain the same number of segments, as only one segment was upgraded and nothing else merged\",\n        origSegCount, segCount);\n      \n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31741cf1390044e38a2ec3127cf302ba841bfd75","date":1491292636,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUpgradeOldSingleSegmentIndexWithAdditions().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUpgradeOldSingleSegmentIndexWithAdditions().mjava","sourceNew":"  public void testUpgradeOldSingleSegmentIndexWithAdditions() throws Exception {\n    for (String name : oldSingleSegmentNames) {\n      if (VERBOSE) {\n        System.out.println(\"testUpgradeOldSingleSegmentIndexWithAdditions: index=\" +name);\n      }\n      Directory dir = newDirectory(oldIndexDirs.get(name));\n      assertEquals(\"Original index must be single segment\", 1, getNumberOfSegments(dir));\n      int indexCreatedVersion = SegmentInfos.readLatestCommit(dir).getIndexCreatedVersionMajor();\n\n      // create a bunch of dummy segments\n      int id = 40;\n      RAMDirectory ramDir = new RAMDirectory();\n      for (int i = 0; i < 3; i++) {\n        // only use Log- or TieredMergePolicy, to make document addition predictable and not suddenly merge:\n        MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n        IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()))\n          .setMergePolicy(mp);\n        IndexWriter w = new IndexWriter(ramDir, iwc);\n        // add few more docs:\n        for(int j = 0; j < RANDOM_MULTIPLIER * random().nextInt(30); j++) {\n          addDoc(w, id++);\n        }\n        try {\n          w.commit();\n        } finally {\n          w.close();\n        }\n      }\n      \n      // add dummy segments (which are all in current\n      // version) to single segment index\n      MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n      IndexWriterConfig iwc = new IndexWriterConfig(null)\n        .setMergePolicy(mp);\n      IndexWriter w = new IndexWriter(dir, iwc);\n      w.addIndexes(ramDir);\n      try {\n        w.commit();\n      } finally {\n        w.close();\n      }\n      \n      // determine count of segments in modified index\n      final int origSegCount = getNumberOfSegments(dir);\n      \n      // ensure there is only one commit\n      assertEquals(1, DirectoryReader.listCommits(dir).size());\n      newIndexUpgrader(dir).upgrade();\n\n      final int segCount = checkAllSegmentsUpgraded(dir, indexCreatedVersion);\n      assertEquals(\"Index must still contain the same number of segments, as only one segment was upgraded and nothing else merged\",\n        origSegCount, segCount);\n      \n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testUpgradeOldSingleSegmentIndexWithAdditions() throws Exception {\n    for (String name : oldSingleSegmentNames) {\n      if (VERBOSE) {\n        System.out.println(\"testUpgradeOldSingleSegmentIndexWithAdditions: index=\" +name);\n      }\n      Directory dir = newDirectory(oldIndexDirs.get(name));\n      assertEquals(\"Original index must be single segment\", 1, getNumberOfSegments(dir));\n      Version indexCreatedVersion = SegmentInfos.readLatestCommit(dir).getIndexCreatedVersion();\n\n      // create a bunch of dummy segments\n      int id = 40;\n      RAMDirectory ramDir = new RAMDirectory();\n      for (int i = 0; i < 3; i++) {\n        // only use Log- or TieredMergePolicy, to make document addition predictable and not suddenly merge:\n        MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n        IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()))\n          .setMergePolicy(mp);\n        IndexWriter w = new IndexWriter(ramDir, iwc);\n        // add few more docs:\n        for(int j = 0; j < RANDOM_MULTIPLIER * random().nextInt(30); j++) {\n          addDoc(w, id++);\n        }\n        try {\n          w.commit();\n        } finally {\n          w.close();\n        }\n      }\n      \n      // add dummy segments (which are all in current\n      // version) to single segment index\n      MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n      IndexWriterConfig iwc = new IndexWriterConfig(null)\n        .setMergePolicy(mp);\n      IndexWriter w = new IndexWriter(dir, iwc);\n      w.addIndexes(ramDir);\n      try {\n        w.commit();\n      } finally {\n        w.close();\n      }\n      \n      // determine count of segments in modified index\n      final int origSegCount = getNumberOfSegments(dir);\n      \n      // ensure there is only one commit\n      assertEquals(1, DirectoryReader.listCommits(dir).size());\n      newIndexUpgrader(dir).upgrade();\n\n      final int segCount = checkAllSegmentsUpgraded(dir, indexCreatedVersion);\n      assertEquals(\"Index must still contain the same number of segments, as only one segment was upgraded and nothing else merged\",\n        origSegCount, segCount);\n      \n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"92212fd254551a0b1156aafc3a1a6ed1a43932ad","date":1491296431,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUpgradeOldSingleSegmentIndexWithAdditions().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUpgradeOldSingleSegmentIndexWithAdditions().mjava","sourceNew":"  public void testUpgradeOldSingleSegmentIndexWithAdditions() throws Exception {\n    for (String name : oldSingleSegmentNames) {\n      if (VERBOSE) {\n        System.out.println(\"testUpgradeOldSingleSegmentIndexWithAdditions: index=\" +name);\n      }\n      Directory dir = newDirectory(oldIndexDirs.get(name));\n      assertEquals(\"Original index must be single segment\", 1, getNumberOfSegments(dir));\n      int indexCreatedVersion = SegmentInfos.readLatestCommit(dir).getIndexCreatedVersionMajor();\n\n      // create a bunch of dummy segments\n      int id = 40;\n      RAMDirectory ramDir = new RAMDirectory();\n      for (int i = 0; i < 3; i++) {\n        // only use Log- or TieredMergePolicy, to make document addition predictable and not suddenly merge:\n        MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n        IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()))\n          .setMergePolicy(mp);\n        IndexWriter w = new IndexWriter(ramDir, iwc);\n        // add few more docs:\n        for(int j = 0; j < RANDOM_MULTIPLIER * random().nextInt(30); j++) {\n          addDoc(w, id++);\n        }\n        try {\n          w.commit();\n        } finally {\n          w.close();\n        }\n      }\n      \n      // add dummy segments (which are all in current\n      // version) to single segment index\n      MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n      IndexWriterConfig iwc = new IndexWriterConfig(null)\n        .setMergePolicy(mp);\n      IndexWriter w = new IndexWriter(dir, iwc);\n      w.addIndexes(ramDir);\n      try {\n        w.commit();\n      } finally {\n        w.close();\n      }\n      \n      // determine count of segments in modified index\n      final int origSegCount = getNumberOfSegments(dir);\n      \n      // ensure there is only one commit\n      assertEquals(1, DirectoryReader.listCommits(dir).size());\n      newIndexUpgrader(dir).upgrade();\n\n      final int segCount = checkAllSegmentsUpgraded(dir, indexCreatedVersion);\n      assertEquals(\"Index must still contain the same number of segments, as only one segment was upgraded and nothing else merged\",\n        origSegCount, segCount);\n      \n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testUpgradeOldSingleSegmentIndexWithAdditions() throws Exception {\n    for (String name : oldSingleSegmentNames) {\n      if (VERBOSE) {\n        System.out.println(\"testUpgradeOldSingleSegmentIndexWithAdditions: index=\" +name);\n      }\n      Directory dir = newDirectory(oldIndexDirs.get(name));\n      assertEquals(\"Original index must be single segment\", 1, getNumberOfSegments(dir));\n      Version indexCreatedVersion = SegmentInfos.readLatestCommit(dir).getIndexCreatedVersion();\n\n      // create a bunch of dummy segments\n      int id = 40;\n      RAMDirectory ramDir = new RAMDirectory();\n      for (int i = 0; i < 3; i++) {\n        // only use Log- or TieredMergePolicy, to make document addition predictable and not suddenly merge:\n        MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n        IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()))\n          .setMergePolicy(mp);\n        IndexWriter w = new IndexWriter(ramDir, iwc);\n        // add few more docs:\n        for(int j = 0; j < RANDOM_MULTIPLIER * random().nextInt(30); j++) {\n          addDoc(w, id++);\n        }\n        try {\n          w.commit();\n        } finally {\n          w.close();\n        }\n      }\n      \n      // add dummy segments (which are all in current\n      // version) to single segment index\n      MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n      IndexWriterConfig iwc = new IndexWriterConfig(null)\n        .setMergePolicy(mp);\n      IndexWriter w = new IndexWriter(dir, iwc);\n      w.addIndexes(ramDir);\n      try {\n        w.commit();\n      } finally {\n        w.close();\n      }\n      \n      // determine count of segments in modified index\n      final int origSegCount = getNumberOfSegments(dir);\n      \n      // ensure there is only one commit\n      assertEquals(1, DirectoryReader.listCommits(dir).size());\n      newIndexUpgrader(dir).upgrade();\n\n      final int segCount = checkAllSegmentsUpgraded(dir, indexCreatedVersion);\n      assertEquals(\"Index must still contain the same number of segments, as only one segment was upgraded and nothing else merged\",\n        origSegCount, segCount);\n      \n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d77dafd89756a5161d244985903e3487ca109182","date":1548679743,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUpgradeOldSingleSegmentIndexWithAdditions().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUpgradeOldSingleSegmentIndexWithAdditions().mjava","sourceNew":"  public void testUpgradeOldSingleSegmentIndexWithAdditions() throws Exception {\n    for (String name : oldSingleSegmentNames) {\n      if (VERBOSE) {\n        System.out.println(\"testUpgradeOldSingleSegmentIndexWithAdditions: index=\" +name);\n      }\n      Directory dir = newDirectory(oldIndexDirs.get(name));\n      assertEquals(\"Original index must be single segment\", 1, getNumberOfSegments(dir));\n      int indexCreatedVersion = SegmentInfos.readLatestCommit(dir).getIndexCreatedVersionMajor();\n\n      // create a bunch of dummy segments\n      int id = 40;\n      Directory ramDir = new ByteBuffersDirectory();\n      for (int i = 0; i < 3; i++) {\n        // only use Log- or TieredMergePolicy, to make document addition predictable and not suddenly merge:\n        MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n        IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()))\n          .setMergePolicy(mp);\n        IndexWriter w = new IndexWriter(ramDir, iwc);\n        // add few more docs:\n        for(int j = 0; j < RANDOM_MULTIPLIER * random().nextInt(30); j++) {\n          addDoc(w, id++);\n        }\n        try {\n          w.commit();\n        } finally {\n          w.close();\n        }\n      }\n      \n      // add dummy segments (which are all in current\n      // version) to single segment index\n      MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n      IndexWriterConfig iwc = new IndexWriterConfig(null)\n        .setMergePolicy(mp);\n      IndexWriter w = new IndexWriter(dir, iwc);\n      w.addIndexes(ramDir);\n      try {\n        w.commit();\n      } finally {\n        w.close();\n      }\n      \n      // determine count of segments in modified index\n      final int origSegCount = getNumberOfSegments(dir);\n      \n      // ensure there is only one commit\n      assertEquals(1, DirectoryReader.listCommits(dir).size());\n      newIndexUpgrader(dir).upgrade();\n\n      final int segCount = checkAllSegmentsUpgraded(dir, indexCreatedVersion);\n      assertEquals(\"Index must still contain the same number of segments, as only one segment was upgraded and nothing else merged\",\n        origSegCount, segCount);\n      \n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testUpgradeOldSingleSegmentIndexWithAdditions() throws Exception {\n    for (String name : oldSingleSegmentNames) {\n      if (VERBOSE) {\n        System.out.println(\"testUpgradeOldSingleSegmentIndexWithAdditions: index=\" +name);\n      }\n      Directory dir = newDirectory(oldIndexDirs.get(name));\n      assertEquals(\"Original index must be single segment\", 1, getNumberOfSegments(dir));\n      int indexCreatedVersion = SegmentInfos.readLatestCommit(dir).getIndexCreatedVersionMajor();\n\n      // create a bunch of dummy segments\n      int id = 40;\n      RAMDirectory ramDir = new RAMDirectory();\n      for (int i = 0; i < 3; i++) {\n        // only use Log- or TieredMergePolicy, to make document addition predictable and not suddenly merge:\n        MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n        IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()))\n          .setMergePolicy(mp);\n        IndexWriter w = new IndexWriter(ramDir, iwc);\n        // add few more docs:\n        for(int j = 0; j < RANDOM_MULTIPLIER * random().nextInt(30); j++) {\n          addDoc(w, id++);\n        }\n        try {\n          w.commit();\n        } finally {\n          w.close();\n        }\n      }\n      \n      // add dummy segments (which are all in current\n      // version) to single segment index\n      MergePolicy mp = random().nextBoolean() ? newLogMergePolicy() : newTieredMergePolicy();\n      IndexWriterConfig iwc = new IndexWriterConfig(null)\n        .setMergePolicy(mp);\n      IndexWriter w = new IndexWriter(dir, iwc);\n      w.addIndexes(ramDir);\n      try {\n        w.commit();\n      } finally {\n        w.close();\n      }\n      \n      // determine count of segments in modified index\n      final int origSegCount = getNumberOfSegments(dir);\n      \n      // ensure there is only one commit\n      assertEquals(1, DirectoryReader.listCommits(dir).size());\n      newIndexUpgrader(dir).upgrade();\n\n      final int segCount = checkAllSegmentsUpgraded(dir, indexCreatedVersion);\n      assertEquals(\"Index must still contain the same number of segments, as only one segment was upgraded and nothing else merged\",\n        origSegCount, segCount);\n      \n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5a207d19eac354d649c3f0e2cce070017c78125e":["a9ddc72fd2ccf17a2abfe0f267f506789a71ce47","b470f36a9372c97283360b1304eacbde22df6c0d"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["a9ddc72fd2ccf17a2abfe0f267f506789a71ce47","b470f36a9372c97283360b1304eacbde22df6c0d"],"d77dafd89756a5161d244985903e3487ca109182":["31741cf1390044e38a2ec3127cf302ba841bfd75"],"d9a47902d6207303f5ed3e7aaca62ca33433af66":["402ad3ddc9da7b70da1b167667a60ece6a1381fb","a9ddc72fd2ccf17a2abfe0f267f506789a71ce47"],"31741cf1390044e38a2ec3127cf302ba841bfd75":["d97ba94eef1fc33c5451259a7aa2ac682646c1af"],"402ad3ddc9da7b70da1b167667a60ece6a1381fb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4cc45c615dbb82bf79d5f9550286098367874fbf"],"a9ddc72fd2ccf17a2abfe0f267f506789a71ce47":["402ad3ddc9da7b70da1b167667a60ece6a1381fb"],"b470f36a9372c97283360b1304eacbde22df6c0d":["a9ddc72fd2ccf17a2abfe0f267f506789a71ce47","6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4cc45c615dbb82bf79d5f9550286098367874fbf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["a9ddc72fd2ccf17a2abfe0f267f506789a71ce47"],"d97ba94eef1fc33c5451259a7aa2ac682646c1af":["5a207d19eac354d649c3f0e2cce070017c78125e"],"92212fd254551a0b1156aafc3a1a6ed1a43932ad":["d97ba94eef1fc33c5451259a7aa2ac682646c1af"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d77dafd89756a5161d244985903e3487ca109182"]},"commit2Childs":{"5a207d19eac354d649c3f0e2cce070017c78125e":["d97ba94eef1fc33c5451259a7aa2ac682646c1af"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"d77dafd89756a5161d244985903e3487ca109182":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d9a47902d6207303f5ed3e7aaca62ca33433af66":[],"31741cf1390044e38a2ec3127cf302ba841bfd75":["d77dafd89756a5161d244985903e3487ca109182"],"402ad3ddc9da7b70da1b167667a60ece6a1381fb":["d9a47902d6207303f5ed3e7aaca62ca33433af66","a9ddc72fd2ccf17a2abfe0f267f506789a71ce47"],"a9ddc72fd2ccf17a2abfe0f267f506789a71ce47":["5a207d19eac354d649c3f0e2cce070017c78125e","1e6acbaae7af722f17204ceccf0f7db5753eccf3","d9a47902d6207303f5ed3e7aaca62ca33433af66","b470f36a9372c97283360b1304eacbde22df6c0d","6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"b470f36a9372c97283360b1304eacbde22df6c0d":["5a207d19eac354d649c3f0e2cce070017c78125e","1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["402ad3ddc9da7b70da1b167667a60ece6a1381fb","4cc45c615dbb82bf79d5f9550286098367874fbf"],"4cc45c615dbb82bf79d5f9550286098367874fbf":["402ad3ddc9da7b70da1b167667a60ece6a1381fb"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["b470f36a9372c97283360b1304eacbde22df6c0d"],"d97ba94eef1fc33c5451259a7aa2ac682646c1af":["31741cf1390044e38a2ec3127cf302ba841bfd75","92212fd254551a0b1156aafc3a1a6ed1a43932ad"],"92212fd254551a0b1156aafc3a1a6ed1a43932ad":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","d9a47902d6207303f5ed3e7aaca62ca33433af66","92212fd254551a0b1156aafc3a1a6ed1a43932ad","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}