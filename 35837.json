{"path":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#addOverseerRole2ExistingNodes().mjava","commits":[{"id":"44de42d869f7d8e5235d43c4ad9a99f520363a2f","date":1389871557,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#addOverseerRole2ExistingNodes().mjava","pathOld":"/dev/null","sourceNew":"  private void addOverseerRole2ExistingNodes() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    Set<String> nodes = client.getZkStateReader().getClusterState().getLiveNodes();\n\n    ArrayList<String> l = new ArrayList<>(nodes);\n    log.info(\"All nodes {}\", l);\n    String currentLeader = getLeaderNode(client);\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l);\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+10000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(getLeaderNode(client).equals(overseerDesignate)){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer\",leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l);\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      log.info(\" count {}\", System.currentTimeMillis());\n      List<String> seqs = client.getZkStateReader().getZkClient().getChildren(\"/overseer_elect/election\", null, true);\n      LeaderElector.sortSeqs(seqs);\n\n      log.info(\"seqs : {} \",seqs);\n//\n      if(LeaderElector.getNodeName(seqs.get(1)).equals(anotherOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner\", leaderchanged);\n\n\n    client.shutdown();\n\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["103857ec20f79f31c7a00310a91ed001b9a6ef17","103857ec20f79f31c7a00310a91ed001b9a6ef17","103857ec20f79f31c7a00310a91ed001b9a6ef17","103857ec20f79f31c7a00310a91ed001b9a6ef17"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"82ed10ec58814cd9841195fb52bcbc1c2402e2cc","date":1390222136,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#addOverseerRole2ExistingNodes().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#addOverseerRole2ExistingNodes().mjava","sourceNew":"  private void addOverseerRole2ExistingNodes() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    Set<String> nodes = client.getZkStateReader().getClusterState().getLiveNodes();\n\n    ArrayList<String> l = new ArrayList<>(nodes);\n    log.info(\"All nodes {}\", l);\n    String currentLeader = getLeaderNode(client);\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l);\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+10000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(getLeaderNode(client).equals(overseerDesignate)){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer\",leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l);\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n//      log.info(\" count {}\", System.currentTimeMillis());\n\n//\n      List<String> sortedNodeNames = OverseerCollectionProcessor.getSortedNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1) .equals(anotherOverseer) || sortedNodeNames.get(0).equals(anotherOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ OverseerCollectionProcessor.getSortedNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ anotherOverseer, leaderchanged);\n\n\n    client.shutdown();\n\n\n  }\n\n","sourceOld":"  private void addOverseerRole2ExistingNodes() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    Set<String> nodes = client.getZkStateReader().getClusterState().getLiveNodes();\n\n    ArrayList<String> l = new ArrayList<>(nodes);\n    log.info(\"All nodes {}\", l);\n    String currentLeader = getLeaderNode(client);\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l);\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+10000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(getLeaderNode(client).equals(overseerDesignate)){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer\",leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l);\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      log.info(\" count {}\", System.currentTimeMillis());\n      List<String> seqs = client.getZkStateReader().getZkClient().getChildren(\"/overseer_elect/election\", null, true);\n      LeaderElector.sortSeqs(seqs);\n\n      log.info(\"seqs : {} \",seqs);\n//\n      if(LeaderElector.getNodeName(seqs.get(1)).equals(anotherOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner\", leaderchanged);\n\n\n    client.shutdown();\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6a2931a06059ca229064c033a760f6ae279295e3","date":1390292457,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#addOverseerRole2ExistingNodes().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#addOverseerRole2ExistingNodes().mjava","sourceNew":"  private void addOverseerRole2ExistingNodes() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    Set<String> nodes = client.getZkStateReader().getClusterState().getLiveNodes();\n\n    ArrayList<String> l = new ArrayList<>(nodes);\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l);\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+10000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer\",leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l);\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n//      log.info(\" count {}\", System.currentTimeMillis());\n\n//\n      List<String> sortedNodeNames = OverseerCollectionProcessor.getSortedNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1) .equals(anotherOverseer) || sortedNodeNames.get(0).equals(anotherOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ OverseerCollectionProcessor.getSortedNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ anotherOverseer, leaderchanged);\n\n\n    client.shutdown();\n\n\n  }\n\n","sourceOld":"  private void addOverseerRole2ExistingNodes() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    Set<String> nodes = client.getZkStateReader().getClusterState().getLiveNodes();\n\n    ArrayList<String> l = new ArrayList<>(nodes);\n    log.info(\"All nodes {}\", l);\n    String currentLeader = getLeaderNode(client);\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l);\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+10000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(getLeaderNode(client).equals(overseerDesignate)){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer\",leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l);\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n//      log.info(\" count {}\", System.currentTimeMillis());\n\n//\n      List<String> sortedNodeNames = OverseerCollectionProcessor.getSortedNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1) .equals(anotherOverseer) || sortedNodeNames.get(0).equals(anotherOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ OverseerCollectionProcessor.getSortedNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ anotherOverseer, leaderchanged);\n\n\n    client.shutdown();\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0e17ab2be80de52a97a870438adf8ac15f574359","date":1390380110,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#addOverseerRole2ExistingNodes().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#addOverseerRole2ExistingNodes().mjava","sourceNew":"  private void addOverseerRole2ExistingNodes() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    List<String> l = OverseerCollectionProcessor.getSortedNodeNames(client.getZkStateReader().getZkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l);\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+15000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    if(!leaderchanged){\n      log.warn(\"expected {}, current order {}\",\n          overseerDesignate,\n          getSortedNodeNames(client.getZkStateReader().getZkClient())+ \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) );\n    }\n    assertTrue(\"could not set the new overseer\",leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l);\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      List<String> sortedNodeNames = getSortedNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1) .equals(anotherOverseer) || sortedNodeNames.get(0).equals(anotherOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ getSortedNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ anotherOverseer, leaderchanged);\n\n\n    client.shutdown();\n\n\n  }\n\n","sourceOld":"  private void addOverseerRole2ExistingNodes() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    Set<String> nodes = client.getZkStateReader().getClusterState().getLiveNodes();\n\n    ArrayList<String> l = new ArrayList<>(nodes);\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l);\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+10000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer\",leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l);\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n//      log.info(\" count {}\", System.currentTimeMillis());\n\n//\n      List<String> sortedNodeNames = OverseerCollectionProcessor.getSortedNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1) .equals(anotherOverseer) || sortedNodeNames.get(0).equals(anotherOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ OverseerCollectionProcessor.getSortedNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ anotherOverseer, leaderchanged);\n\n\n    client.shutdown();\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"702f9eb5f4d8ac6dea3945928de043b9d25fa87d","date":1391001447,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#addOverseerRole2ExistingNodes().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#addOverseerRole2ExistingNodes().mjava","sourceNew":"  private void addOverseerRole2ExistingNodes() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    List<String> l = OverseerCollectionProcessor.getSortedNodeNames(client.getZkStateReader().getZkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l);\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+15000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    /*if(!leaderchanged){\n\n      log.warn(\"expected {}, current order {}\",\n          overseerDesignate,\n          getSortedNodeNames(client.getZkStateReader().getZkClient())+ \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) );\n    }*/\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedNodeNames(client.getZkStateReader().getZkClient()) +\n        \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) ,leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l);\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      List<String> sortedNodeNames = getSortedNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1) .equals(anotherOverseer) || sortedNodeNames.get(0).equals(anotherOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ getSortedNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ anotherOverseer, leaderchanged);\n\n\n    client.shutdown();\n\n\n  }\n\n","sourceOld":"  private void addOverseerRole2ExistingNodes() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    List<String> l = OverseerCollectionProcessor.getSortedNodeNames(client.getZkStateReader().getZkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l);\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+15000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    if(!leaderchanged){\n      log.warn(\"expected {}, current order {}\",\n          overseerDesignate,\n          getSortedNodeNames(client.getZkStateReader().getZkClient())+ \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) );\n    }\n    assertTrue(\"could not set the new overseer\",leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l);\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      List<String> sortedNodeNames = getSortedNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1) .equals(anotherOverseer) || sortedNodeNames.get(0).equals(anotherOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ getSortedNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ anotherOverseer, leaderchanged);\n\n\n    client.shutdown();\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c3450936c79e35b466a4ec1d0234e1f5751e0f37","date":1392039525,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#addOverseerRole2ExistingNodes().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#addOverseerRole2ExistingNodes().mjava","sourceNew":"  private void addOverseerRole2ExistingNodes() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    List<String> l = OverseerCollectionProcessor.getSortedNodeNames(client.getZkStateReader().getZkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l);\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+15000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    /*if(!leaderchanged){\n\n      log.warn(\"expected {}, current order {}\",\n          overseerDesignate,\n          getSortedNodeNames(client.getZkStateReader().getZkClient())+ \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) );\n    }*/\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedNodeNames(client.getZkStateReader().getZkClient()) +\n        \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) ,leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l);\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      List<String> sortedNodeNames = getSortedNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1) .equals(anotherOverseer) || sortedNodeNames.get(0).equals(anotherOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ getSortedNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ anotherOverseer, leaderchanged);\n\n\n    String currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n\n    log.info(\"Current Overseer {}\", currentOverseer);\n    Pattern pattern = Pattern.compile(\"(.*):(\\\\d*)(.*)\");\n    Matcher m = pattern.matcher(currentOverseer);\n    if(m.matches()){\n      String hostPort =  m.group(1)+\":\"+m.group(2);\n\n      log.info(\"hostPort : {}\", hostPort);\n\n      for (JettySolrRunner jetty : jettys) {\n        String s = jetty.getBaseUrl().toString();\n        if(s.contains(hostPort)){\n          log.info(\"leader node {}\",s);\n          ChaosMonkey.stop(jetty);\n\n          timeout = System.currentTimeMillis()+10000;\n          leaderchanged = false;\n          for(;System.currentTimeMillis() < timeout;){\n            currentOverseer =  getLeaderNode(client.getZkStateReader().getZkClient());\n            if(anotherOverseer.equals(currentOverseer)){\n              leaderchanged =true;\n              break;\n            }\n            Thread.sleep(100);\n          }\n          assertTrue(\"New overseer designate has not become the overseer, expected : \"+ anotherOverseer + \"actual : \"+ currentOverseer, leaderchanged);\n        }\n\n      }\n\n    }\n\n    client.shutdown();\n\n\n  }\n\n","sourceOld":"  private void addOverseerRole2ExistingNodes() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    List<String> l = OverseerCollectionProcessor.getSortedNodeNames(client.getZkStateReader().getZkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l);\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+15000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    /*if(!leaderchanged){\n\n      log.warn(\"expected {}, current order {}\",\n          overseerDesignate,\n          getSortedNodeNames(client.getZkStateReader().getZkClient())+ \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) );\n    }*/\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedNodeNames(client.getZkStateReader().getZkClient()) +\n        \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) ,leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l);\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      List<String> sortedNodeNames = getSortedNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1) .equals(anotherOverseer) || sortedNodeNames.get(0).equals(anotherOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ getSortedNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ anotherOverseer, leaderchanged);\n\n\n    client.shutdown();\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7e66d99e5beccb546edd910c91f646fb7d831a94","date":1395391298,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#addOverseerRole2ExistingNodes().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#addOverseerRole2ExistingNodes().mjava","sourceNew":"  private void addOverseerRole2ExistingNodes() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    List<String> l = OverseerCollectionProcessor.getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l);\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+15000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) +\n        \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) ,leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l);\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      List<String> sortedNodeNames = getSortedOverseerNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1) .equals(anotherOverseer) || sortedNodeNames.get(0).equals(anotherOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ anotherOverseer, leaderchanged);\n\n\n    String currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n\n    String killedOverseer = currentOverseer;\n\n    log.info(\"Current Overseer {}\", currentOverseer);\n    Pattern pattern = Pattern.compile(\"(.*):(\\\\d*)(.*)\");\n    Matcher m = pattern.matcher(currentOverseer);\n    JettySolrRunner stoppedJetty =null;\n\n    if(m.matches()){\n      String hostPort =  m.group(1)+\":\"+m.group(2);\n\n      log.info(\"hostPort : {}\", hostPort);\n\n      for (JettySolrRunner jetty : jettys) {\n        String s = jetty.getBaseUrl().toString();\n        if(s.contains(hostPort)){\n          log.info(\"leader node {}\",s);\n          ChaosMonkey.stop(jetty);\n          stoppedJetty = jetty;\n          timeout = System.currentTimeMillis()+10000;\n          leaderchanged = false;\n          for(;System.currentTimeMillis() < timeout;){\n            currentOverseer =  getLeaderNode(client.getZkStateReader().getZkClient());\n            if(anotherOverseer.equals(currentOverseer)){\n              leaderchanged =true;\n              break;\n            }\n            Thread.sleep(100);\n          }\n          assertTrue(\"New overseer designate has not become the overseer, expected : \"+ anotherOverseer + \"actual : \"+ currentOverseer, leaderchanged);\n        }\n\n      }\n\n    }\n\n    ChaosMonkey.start(stoppedJetty);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      List<String> sortedNodeNames = getSortedOverseerNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1).equals(killedOverseer) || sortedNodeNames.get(0).equals(killedOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ killedOverseer, leaderchanged);\n\n\n\n\n\n    client.shutdown();\n\n\n  }\n\n","sourceOld":"  private void addOverseerRole2ExistingNodes() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    List<String> l = OverseerCollectionProcessor.getSortedNodeNames(client.getZkStateReader().getZkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l);\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+15000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    /*if(!leaderchanged){\n\n      log.warn(\"expected {}, current order {}\",\n          overseerDesignate,\n          getSortedNodeNames(client.getZkStateReader().getZkClient())+ \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) );\n    }*/\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedNodeNames(client.getZkStateReader().getZkClient()) +\n        \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) ,leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l);\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      List<String> sortedNodeNames = getSortedNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1) .equals(anotherOverseer) || sortedNodeNames.get(0).equals(anotherOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ getSortedNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ anotherOverseer, leaderchanged);\n\n\n    String currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n\n    log.info(\"Current Overseer {}\", currentOverseer);\n    Pattern pattern = Pattern.compile(\"(.*):(\\\\d*)(.*)\");\n    Matcher m = pattern.matcher(currentOverseer);\n    if(m.matches()){\n      String hostPort =  m.group(1)+\":\"+m.group(2);\n\n      log.info(\"hostPort : {}\", hostPort);\n\n      for (JettySolrRunner jetty : jettys) {\n        String s = jetty.getBaseUrl().toString();\n        if(s.contains(hostPort)){\n          log.info(\"leader node {}\",s);\n          ChaosMonkey.stop(jetty);\n\n          timeout = System.currentTimeMillis()+10000;\n          leaderchanged = false;\n          for(;System.currentTimeMillis() < timeout;){\n            currentOverseer =  getLeaderNode(client.getZkStateReader().getZkClient());\n            if(anotherOverseer.equals(currentOverseer)){\n              leaderchanged =true;\n              break;\n            }\n            Thread.sleep(100);\n          }\n          assertTrue(\"New overseer designate has not become the overseer, expected : \"+ anotherOverseer + \"actual : \"+ currentOverseer, leaderchanged);\n        }\n\n      }\n\n    }\n\n    client.shutdown();\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5b15576cafd8b5d06857055c28f26912321937e3","date":1396452121,"type":5,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#addOverseerRole2ExistingNodes().mjava","sourceNew":"  private void testOverseerRole() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    List<String> l = OverseerCollectionProcessor.getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l);\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+15000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) +\n        \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) ,leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l);\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      List<String> sortedNodeNames = getSortedOverseerNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1) .equals(anotherOverseer) || sortedNodeNames.get(0).equals(anotherOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ anotherOverseer, leaderchanged);\n\n\n    String currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n\n    String killedOverseer = currentOverseer;\n\n    log.info(\"Current Overseer {}\", currentOverseer);\n    Pattern pattern = Pattern.compile(\"(.*):(\\\\d*)(.*)\");\n    Matcher m = pattern.matcher(currentOverseer);\n    JettySolrRunner stoppedJetty =null;\n\n    if(m.matches()){\n      String hostPort =  m.group(1)+\":\"+m.group(2);\n\n      log.info(\"hostPort : {}\", hostPort);\n\n      for (JettySolrRunner jetty : jettys) {\n        String s = jetty.getBaseUrl().toString();\n        if(s.contains(hostPort)){\n          log.info(\"leader node {}\",s);\n          ChaosMonkey.stop(jetty);\n          stoppedJetty = jetty;\n          timeout = System.currentTimeMillis()+10000;\n          leaderchanged = false;\n          for(;System.currentTimeMillis() < timeout;){\n            currentOverseer =  getLeaderNode(client.getZkStateReader().getZkClient());\n            if(anotherOverseer.equals(currentOverseer)){\n              leaderchanged =true;\n              break;\n            }\n            Thread.sleep(100);\n          }\n          assertTrue(\"New overseer designate has not become the overseer, expected : \"+ anotherOverseer + \"actual : \"+ currentOverseer, leaderchanged);\n        }\n\n      }\n\n    }\n\n    ChaosMonkey.start(stoppedJetty);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      List<String> sortedNodeNames = getSortedOverseerNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1).equals(killedOverseer) || sortedNodeNames.get(0).equals(killedOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ killedOverseer, leaderchanged);\n\n  }\n\n","sourceOld":"  private void addOverseerRole2ExistingNodes() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    List<String> l = OverseerCollectionProcessor.getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l);\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+15000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) +\n        \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) ,leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l);\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      List<String> sortedNodeNames = getSortedOverseerNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1) .equals(anotherOverseer) || sortedNodeNames.get(0).equals(anotherOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ anotherOverseer, leaderchanged);\n\n\n    String currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n\n    String killedOverseer = currentOverseer;\n\n    log.info(\"Current Overseer {}\", currentOverseer);\n    Pattern pattern = Pattern.compile(\"(.*):(\\\\d*)(.*)\");\n    Matcher m = pattern.matcher(currentOverseer);\n    JettySolrRunner stoppedJetty =null;\n\n    if(m.matches()){\n      String hostPort =  m.group(1)+\":\"+m.group(2);\n\n      log.info(\"hostPort : {}\", hostPort);\n\n      for (JettySolrRunner jetty : jettys) {\n        String s = jetty.getBaseUrl().toString();\n        if(s.contains(hostPort)){\n          log.info(\"leader node {}\",s);\n          ChaosMonkey.stop(jetty);\n          stoppedJetty = jetty;\n          timeout = System.currentTimeMillis()+10000;\n          leaderchanged = false;\n          for(;System.currentTimeMillis() < timeout;){\n            currentOverseer =  getLeaderNode(client.getZkStateReader().getZkClient());\n            if(anotherOverseer.equals(currentOverseer)){\n              leaderchanged =true;\n              break;\n            }\n            Thread.sleep(100);\n          }\n          assertTrue(\"New overseer designate has not become the overseer, expected : \"+ anotherOverseer + \"actual : \"+ currentOverseer, leaderchanged);\n        }\n\n      }\n\n    }\n\n    ChaosMonkey.start(stoppedJetty);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      List<String> sortedNodeNames = getSortedOverseerNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1).equals(killedOverseer) || sortedNodeNames.get(0).equals(killedOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ killedOverseer, leaderchanged);\n\n\n\n\n\n    client.shutdown();\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":5,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#testOverseerRole().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest#addOverseerRole2ExistingNodes().mjava","sourceNew":"  private void testOverseerRole() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    List<String> l = OverseerCollectionProcessor.getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l);\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+15000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) +\n        \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) ,leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l);\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      List<String> sortedNodeNames = getSortedOverseerNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1) .equals(anotherOverseer) || sortedNodeNames.get(0).equals(anotherOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ anotherOverseer, leaderchanged);\n\n\n    String currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n\n    String killedOverseer = currentOverseer;\n\n    log.info(\"Current Overseer {}\", currentOverseer);\n    Pattern pattern = Pattern.compile(\"(.*):(\\\\d*)(.*)\");\n    Matcher m = pattern.matcher(currentOverseer);\n    JettySolrRunner stoppedJetty =null;\n\n    if(m.matches()){\n      String hostPort =  m.group(1)+\":\"+m.group(2);\n\n      log.info(\"hostPort : {}\", hostPort);\n\n      for (JettySolrRunner jetty : jettys) {\n        String s = jetty.getBaseUrl().toString();\n        if(s.contains(hostPort)){\n          log.info(\"leader node {}\",s);\n          ChaosMonkey.stop(jetty);\n          stoppedJetty = jetty;\n          timeout = System.currentTimeMillis()+10000;\n          leaderchanged = false;\n          for(;System.currentTimeMillis() < timeout;){\n            currentOverseer =  getLeaderNode(client.getZkStateReader().getZkClient());\n            if(anotherOverseer.equals(currentOverseer)){\n              leaderchanged =true;\n              break;\n            }\n            Thread.sleep(100);\n          }\n          assertTrue(\"New overseer designate has not become the overseer, expected : \"+ anotherOverseer + \"actual : \"+ currentOverseer, leaderchanged);\n        }\n\n      }\n\n    }\n\n    ChaosMonkey.start(stoppedJetty);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      List<String> sortedNodeNames = getSortedOverseerNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1).equals(killedOverseer) || sortedNodeNames.get(0).equals(killedOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ killedOverseer, leaderchanged);\n\n  }\n\n","sourceOld":"  private void addOverseerRole2ExistingNodes() throws Exception {\n    String collectionName = \"testOverseerCol\";\n\n    createCollection(collectionName, client);\n\n    waitForRecoveriesToFinish(collectionName, false);\n    List<String> l = OverseerCollectionProcessor.getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) ;\n\n    log.info(\"All nodes {}\", l);\n    String currentLeader = OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());\n    log.info(\"Current leader {} \", currentLeader);\n    l.remove(currentLeader);\n\n    Collections.shuffle(l);\n    String overseerDesignate = l.get(0);\n    log.info(\"overseerDesignate {}\",overseerDesignate);\n    setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);\n\n    long timeout = System.currentTimeMillis()+15000;\n\n    boolean leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      if(overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))){\n        log.info(\"overseer designate is the new overseer\");\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n    assertTrue(\"could not set the new overseer . expected \"+\n        overseerDesignate + \" current order : \" +\n        getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) +\n        \" ldr :\"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()) ,leaderchanged);\n\n\n\n    //add another node as overseer\n\n\n    l.remove(overseerDesignate);\n\n    Collections.shuffle(l);\n\n    String anotherOverseer = l.get(0);\n    log.info(\"Adding another overseer designate {}\", anotherOverseer);\n    setOverseerRole(CollectionAction.ADDROLE, anotherOverseer);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      List<String> sortedNodeNames = getSortedOverseerNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1) .equals(anotherOverseer) || sortedNodeNames.get(0).equals(anotherOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ anotherOverseer, leaderchanged);\n\n\n    String currentOverseer = getLeaderNode(client.getZkStateReader().getZkClient());\n\n    String killedOverseer = currentOverseer;\n\n    log.info(\"Current Overseer {}\", currentOverseer);\n    Pattern pattern = Pattern.compile(\"(.*):(\\\\d*)(.*)\");\n    Matcher m = pattern.matcher(currentOverseer);\n    JettySolrRunner stoppedJetty =null;\n\n    if(m.matches()){\n      String hostPort =  m.group(1)+\":\"+m.group(2);\n\n      log.info(\"hostPort : {}\", hostPort);\n\n      for (JettySolrRunner jetty : jettys) {\n        String s = jetty.getBaseUrl().toString();\n        if(s.contains(hostPort)){\n          log.info(\"leader node {}\",s);\n          ChaosMonkey.stop(jetty);\n          stoppedJetty = jetty;\n          timeout = System.currentTimeMillis()+10000;\n          leaderchanged = false;\n          for(;System.currentTimeMillis() < timeout;){\n            currentOverseer =  getLeaderNode(client.getZkStateReader().getZkClient());\n            if(anotherOverseer.equals(currentOverseer)){\n              leaderchanged =true;\n              break;\n            }\n            Thread.sleep(100);\n          }\n          assertTrue(\"New overseer designate has not become the overseer, expected : \"+ anotherOverseer + \"actual : \"+ currentOverseer, leaderchanged);\n        }\n\n      }\n\n    }\n\n    ChaosMonkey.start(stoppedJetty);\n\n    timeout = System.currentTimeMillis()+10000;\n    leaderchanged = false;\n    for(;System.currentTimeMillis() < timeout;){\n      List<String> sortedNodeNames = getSortedOverseerNodeNames(client.getZkStateReader().getZkClient());\n      if(sortedNodeNames.get(1).equals(killedOverseer) || sortedNodeNames.get(0).equals(killedOverseer)){\n        leaderchanged =true;\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    assertTrue(\"New overseer not the frontrunner : \"+ getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) + \" expected : \"+ killedOverseer, leaderchanged);\n\n\n\n\n\n    client.shutdown();\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5eb2511ababf862ea11e10761c70ee560cd84510":["7e66d99e5beccb546edd910c91f646fb7d831a94","5b15576cafd8b5d06857055c28f26912321937e3"],"702f9eb5f4d8ac6dea3945928de043b9d25fa87d":["0e17ab2be80de52a97a870438adf8ac15f574359"],"0e17ab2be80de52a97a870438adf8ac15f574359":["6a2931a06059ca229064c033a760f6ae279295e3"],"5b15576cafd8b5d06857055c28f26912321937e3":["7e66d99e5beccb546edd910c91f646fb7d831a94"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c3450936c79e35b466a4ec1d0234e1f5751e0f37":["702f9eb5f4d8ac6dea3945928de043b9d25fa87d"],"82ed10ec58814cd9841195fb52bcbc1c2402e2cc":["44de42d869f7d8e5235d43c4ad9a99f520363a2f"],"7e66d99e5beccb546edd910c91f646fb7d831a94":["c3450936c79e35b466a4ec1d0234e1f5751e0f37"],"6a2931a06059ca229064c033a760f6ae279295e3":["82ed10ec58814cd9841195fb52bcbc1c2402e2cc"],"44de42d869f7d8e5235d43c4ad9a99f520363a2f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5b15576cafd8b5d06857055c28f26912321937e3"]},"commit2Childs":{"5eb2511ababf862ea11e10761c70ee560cd84510":[],"702f9eb5f4d8ac6dea3945928de043b9d25fa87d":["c3450936c79e35b466a4ec1d0234e1f5751e0f37"],"0e17ab2be80de52a97a870438adf8ac15f574359":["702f9eb5f4d8ac6dea3945928de043b9d25fa87d"],"5b15576cafd8b5d06857055c28f26912321937e3":["5eb2511ababf862ea11e10761c70ee560cd84510","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["44de42d869f7d8e5235d43c4ad9a99f520363a2f"],"c3450936c79e35b466a4ec1d0234e1f5751e0f37":["7e66d99e5beccb546edd910c91f646fb7d831a94"],"82ed10ec58814cd9841195fb52bcbc1c2402e2cc":["6a2931a06059ca229064c033a760f6ae279295e3"],"7e66d99e5beccb546edd910c91f646fb7d831a94":["5eb2511ababf862ea11e10761c70ee560cd84510","5b15576cafd8b5d06857055c28f26912321937e3"],"6a2931a06059ca229064c033a760f6ae279295e3":["0e17ab2be80de52a97a870438adf8ac15f574359"],"44de42d869f7d8e5235d43c4ad9a99f520363a2f":["82ed10ec58814cd9841195fb52bcbc1c2402e2cc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5eb2511ababf862ea11e10761c70ee560cd84510","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}