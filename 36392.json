{"path":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Query,IndexSearcher,ScoreMode).mjava","commits":[{"id":"77855215e331ce146763531cb9b0c050726f6ae5","date":1338323851,"type":1,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Query,IndexSearcher,ScoreMode).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Query,IndexSearcher).mjava","sourceNew":"  /**\n   * Method for query time joining.\n   * <p/>\n   * Execute the returned query with a {@link IndexSearcher} to retrieve all documents that have the same terms in the\n   * to field that match with documents matching the specified fromQuery and have the same terms in the from field.\n   * <p/>\n   * In the case a single document relates to more than one document the <code>multipleValuesPerDocument</code> option\n   * should be set to true. When the <code>multipleValuesPerDocument</code> is set to <code>true</code> only the\n   * the score from the first encountered join value originating from the 'from' side is mapped into the 'to' side.\n   * Even in the case when a second join value related to a specific document yields a higher score. Obviously this\n   * doesn't apply in the case that {@link ScoreMode#None} is used, since no scores are computed at all.\n   * </p>\n   * Memory considerations: During joining all unique join values are kept in memory. On top of that when the scoreMode\n   * isn't set to {@link ScoreMode#None} a float value per unique join value is kept in memory for computing scores.\n   * When scoreMode is set to {@link ScoreMode#Avg} also an additional integer value is kept in memory per unique\n   * join value.\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   * @param toField                   The to field to join to\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    switch (scoreMode) {\n      case None:\n        TermsCollector termsCollector = TermsCollector.create(fromField, multipleValuesPerDocument);\n        fromSearcher.search(fromQuery, termsCollector);\n        return new TermsQuery(toField, termsCollector.getCollectorTerms());\n      case Total:\n      case Max:\n      case Avg:\n        TermsWithScoreCollector termsWithScoreCollector =\n            TermsWithScoreCollector.create(fromField, multipleValuesPerDocument, scoreMode);\n        fromSearcher.search(fromQuery, termsWithScoreCollector);\n        return new TermsIncludingScoreQuery(\n            toField,\n            multipleValuesPerDocument,\n            termsWithScoreCollector.getCollectedTerms(),\n            termsWithScoreCollector.getScoresPerTerm(),\n            fromQuery\n        );\n      default:\n        throw new IllegalArgumentException(String.format(\"Score mode %s isn't supported.\", scoreMode));\n    }\n  }\n\n","sourceOld":"  /**\n   * Method for query time joining.\n   * <p/>\n   * Execute the returned query with a {@link IndexSearcher} to retrieve all documents that have the same terms in the\n   * to field that match with documents matching the specified fromQuery and have the same terms in the from field.\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   * @param toField                   The to field to join to\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher) throws IOException {\n    TermsCollector termsCollector = TermsCollector.create(fromField, multipleValuesPerDocument);\n    fromSearcher.search(fromQuery, termsCollector);\n    return new TermsQuery(toField, termsCollector.getCollectorTerms());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9c70cdb81dc660d90f9d0664dd91b473b7e66563","date":1341679310,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Query,IndexSearcher,ScoreMode).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Query,IndexSearcher,ScoreMode).mjava","sourceNew":"  /**\n   * Method for query time joining.\n   * <p/>\n   * Execute the returned query with a {@link IndexSearcher} to retrieve all documents that have the same terms in the\n   * to field that match with documents matching the specified fromQuery and have the same terms in the from field.\n   * <p/>\n   * In the case a single document relates to more than one document the <code>multipleValuesPerDocument</code> option\n   * should be set to true. When the <code>multipleValuesPerDocument</code> is set to <code>true</code> only the\n   * the score from the first encountered join value originating from the 'from' side is mapped into the 'to' side.\n   * Even in the case when a second join value related to a specific document yields a higher score. Obviously this\n   * doesn't apply in the case that {@link ScoreMode#None} is used, since no scores are computed at all.\n   * </p>\n   * Memory considerations: During joining all unique join values are kept in memory. On top of that when the scoreMode\n   * isn't set to {@link ScoreMode#None} a float value per unique join value is kept in memory for computing scores.\n   * When scoreMode is set to {@link ScoreMode#Avg} also an additional integer value is kept in memory per unique\n   * join value.\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   * @param toField                   The to field to join to\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    switch (scoreMode) {\n      case None:\n        TermsCollector termsCollector = TermsCollector.create(fromField, multipleValuesPerDocument);\n        fromSearcher.search(fromQuery, termsCollector);\n        return new TermsQuery(toField, termsCollector.getCollectorTerms());\n      case Total:\n      case Max:\n      case Avg:\n        TermsWithScoreCollector termsWithScoreCollector =\n            TermsWithScoreCollector.create(fromField, multipleValuesPerDocument, scoreMode);\n        fromSearcher.search(fromQuery, termsWithScoreCollector);\n        return new TermsIncludingScoreQuery(\n            toField,\n            multipleValuesPerDocument,\n            termsWithScoreCollector.getCollectedTerms(),\n            termsWithScoreCollector.getScoresPerTerm(),\n            fromQuery\n        );\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n  }\n\n","sourceOld":"  /**\n   * Method for query time joining.\n   * <p/>\n   * Execute the returned query with a {@link IndexSearcher} to retrieve all documents that have the same terms in the\n   * to field that match with documents matching the specified fromQuery and have the same terms in the from field.\n   * <p/>\n   * In the case a single document relates to more than one document the <code>multipleValuesPerDocument</code> option\n   * should be set to true. When the <code>multipleValuesPerDocument</code> is set to <code>true</code> only the\n   * the score from the first encountered join value originating from the 'from' side is mapped into the 'to' side.\n   * Even in the case when a second join value related to a specific document yields a higher score. Obviously this\n   * doesn't apply in the case that {@link ScoreMode#None} is used, since no scores are computed at all.\n   * </p>\n   * Memory considerations: During joining all unique join values are kept in memory. On top of that when the scoreMode\n   * isn't set to {@link ScoreMode#None} a float value per unique join value is kept in memory for computing scores.\n   * When scoreMode is set to {@link ScoreMode#Avg} also an additional integer value is kept in memory per unique\n   * join value.\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   * @param toField                   The to field to join to\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    switch (scoreMode) {\n      case None:\n        TermsCollector termsCollector = TermsCollector.create(fromField, multipleValuesPerDocument);\n        fromSearcher.search(fromQuery, termsCollector);\n        return new TermsQuery(toField, termsCollector.getCollectorTerms());\n      case Total:\n      case Max:\n      case Avg:\n        TermsWithScoreCollector termsWithScoreCollector =\n            TermsWithScoreCollector.create(fromField, multipleValuesPerDocument, scoreMode);\n        fromSearcher.search(fromQuery, termsWithScoreCollector);\n        return new TermsIncludingScoreQuery(\n            toField,\n            multipleValuesPerDocument,\n            termsWithScoreCollector.getCollectedTerms(),\n            termsWithScoreCollector.getScoresPerTerm(),\n            fromQuery\n        );\n      default:\n        throw new IllegalArgumentException(String.format(\"Score mode %s isn't supported.\", scoreMode));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2acf500f78aa12b92e371fd89c719291986b6b90","date":1341846236,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Query,IndexSearcher,ScoreMode).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Query,IndexSearcher,ScoreMode).mjava","sourceNew":"  /**\n   * Method for query time joining.\n   * <p/>\n   * Execute the returned query with a {@link IndexSearcher} to retrieve all documents that have the same terms in the\n   * to field that match with documents matching the specified fromQuery and have the same terms in the from field.\n   * <p/>\n   * In the case a single document relates to more than one document the <code>multipleValuesPerDocument</code> option\n   * should be set to true. When the <code>multipleValuesPerDocument</code> is set to <code>true</code> only the\n   * the score from the first encountered join value originating from the 'from' side is mapped into the 'to' side.\n   * Even in the case when a second join value related to a specific document yields a higher score. Obviously this\n   * doesn't apply in the case that {@link ScoreMode#None} is used, since no scores are computed at all.\n   * </p>\n   * Memory considerations: During joining all unique join values are kept in memory. On top of that when the scoreMode\n   * isn't set to {@link ScoreMode#None} a float value per unique join value is kept in memory for computing scores.\n   * When scoreMode is set to {@link ScoreMode#Avg} also an additional integer value is kept in memory per unique\n   * join value.\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   * @param toField                   The to field to join to\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    switch (scoreMode) {\n      case None:\n        TermsCollector termsCollector = TermsCollector.create(fromField, multipleValuesPerDocument);\n        fromSearcher.search(fromQuery, termsCollector);\n        return new TermsQuery(toField, termsCollector.getCollectorTerms());\n      case Total:\n      case Max:\n      case Avg:\n        TermsWithScoreCollector termsWithScoreCollector =\n            TermsWithScoreCollector.create(fromField, multipleValuesPerDocument, scoreMode);\n        fromSearcher.search(fromQuery, termsWithScoreCollector);\n        return new TermsIncludingScoreQuery(\n            toField,\n            multipleValuesPerDocument,\n            termsWithScoreCollector.getCollectedTerms(),\n            termsWithScoreCollector.getScoresPerTerm(),\n            fromQuery\n        );\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n  }\n\n","sourceOld":"  /**\n   * Method for query time joining.\n   * <p/>\n   * Execute the returned query with a {@link IndexSearcher} to retrieve all documents that have the same terms in the\n   * to field that match with documents matching the specified fromQuery and have the same terms in the from field.\n   * <p/>\n   * In the case a single document relates to more than one document the <code>multipleValuesPerDocument</code> option\n   * should be set to true. When the <code>multipleValuesPerDocument</code> is set to <code>true</code> only the\n   * the score from the first encountered join value originating from the 'from' side is mapped into the 'to' side.\n   * Even in the case when a second join value related to a specific document yields a higher score. Obviously this\n   * doesn't apply in the case that {@link ScoreMode#None} is used, since no scores are computed at all.\n   * </p>\n   * Memory considerations: During joining all unique join values are kept in memory. On top of that when the scoreMode\n   * isn't set to {@link ScoreMode#None} a float value per unique join value is kept in memory for computing scores.\n   * When scoreMode is set to {@link ScoreMode#Avg} also an additional integer value is kept in memory per unique\n   * join value.\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   * @param toField                   The to field to join to\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    switch (scoreMode) {\n      case None:\n        TermsCollector termsCollector = TermsCollector.create(fromField, multipleValuesPerDocument);\n        fromSearcher.search(fromQuery, termsCollector);\n        return new TermsQuery(toField, termsCollector.getCollectorTerms());\n      case Total:\n      case Max:\n      case Avg:\n        TermsWithScoreCollector termsWithScoreCollector =\n            TermsWithScoreCollector.create(fromField, multipleValuesPerDocument, scoreMode);\n        fromSearcher.search(fromQuery, termsWithScoreCollector);\n        return new TermsIncludingScoreQuery(\n            toField,\n            multipleValuesPerDocument,\n            termsWithScoreCollector.getCollectedTerms(),\n            termsWithScoreCollector.getScoresPerTerm(),\n            fromQuery\n        );\n      default:\n        throw new IllegalArgumentException(String.format(\"Score mode %s isn't supported.\", scoreMode));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"46d8ada1fff8d18cb197c38c7983225162599948","date":1341853497,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Query,IndexSearcher,ScoreMode).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Query,IndexSearcher,ScoreMode).mjava","sourceNew":"  /**\n   * Method for query time joining.\n   * <p/>\n   * Execute the returned query with a {@link IndexSearcher} to retrieve all documents that have the same terms in the\n   * to field that match with documents matching the specified fromQuery and have the same terms in the from field.\n   * <p/>\n   * In the case a single document relates to more than one document the <code>multipleValuesPerDocument</code> option\n   * should be set to true. When the <code>multipleValuesPerDocument</code> is set to <code>true</code> only the\n   * the score from the first encountered join value originating from the 'from' side is mapped into the 'to' side.\n   * Even in the case when a second join value related to a specific document yields a higher score. Obviously this\n   * doesn't apply in the case that {@link ScoreMode#None} is used, since no scores are computed at all.\n   * </p>\n   * Memory considerations: During joining all unique join values are kept in memory. On top of that when the scoreMode\n   * isn't set to {@link ScoreMode#None} a float value per unique join value is kept in memory for computing scores.\n   * When scoreMode is set to {@link ScoreMode#Avg} also an additional integer value is kept in memory per unique\n   * join value.\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   * @param toField                   The to field to join to\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    switch (scoreMode) {\n      case None:\n        TermsCollector termsCollector = TermsCollector.create(fromField, multipleValuesPerDocument);\n        fromSearcher.search(fromQuery, termsCollector);\n        return new TermsQuery(toField, termsCollector.getCollectorTerms());\n      case Total:\n      case Max:\n      case Avg:\n        TermsWithScoreCollector termsWithScoreCollector =\n            TermsWithScoreCollector.create(fromField, multipleValuesPerDocument, scoreMode);\n        fromSearcher.search(fromQuery, termsWithScoreCollector);\n        return new TermsIncludingScoreQuery(\n            toField,\n            multipleValuesPerDocument,\n            termsWithScoreCollector.getCollectedTerms(),\n            termsWithScoreCollector.getScoresPerTerm(),\n            fromQuery\n        );\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n  }\n\n","sourceOld":"  /**\n   * Method for query time joining.\n   * <p/>\n   * Execute the returned query with a {@link IndexSearcher} to retrieve all documents that have the same terms in the\n   * to field that match with documents matching the specified fromQuery and have the same terms in the from field.\n   * <p/>\n   * In the case a single document relates to more than one document the <code>multipleValuesPerDocument</code> option\n   * should be set to true. When the <code>multipleValuesPerDocument</code> is set to <code>true</code> only the\n   * the score from the first encountered join value originating from the 'from' side is mapped into the 'to' side.\n   * Even in the case when a second join value related to a specific document yields a higher score. Obviously this\n   * doesn't apply in the case that {@link ScoreMode#None} is used, since no scores are computed at all.\n   * </p>\n   * Memory considerations: During joining all unique join values are kept in memory. On top of that when the scoreMode\n   * isn't set to {@link ScoreMode#None} a float value per unique join value is kept in memory for computing scores.\n   * When scoreMode is set to {@link ScoreMode#Avg} also an additional integer value is kept in memory per unique\n   * join value.\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   * @param toField                   The to field to join to\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    switch (scoreMode) {\n      case None:\n        TermsCollector termsCollector = TermsCollector.create(fromField, multipleValuesPerDocument);\n        fromSearcher.search(fromQuery, termsCollector);\n        return new TermsQuery(toField, termsCollector.getCollectorTerms());\n      case Total:\n      case Max:\n      case Avg:\n        TermsWithScoreCollector termsWithScoreCollector =\n            TermsWithScoreCollector.create(fromField, multipleValuesPerDocument, scoreMode);\n        fromSearcher.search(fromQuery, termsWithScoreCollector);\n        return new TermsIncludingScoreQuery(\n            toField,\n            multipleValuesPerDocument,\n            termsWithScoreCollector.getCollectedTerms(),\n            termsWithScoreCollector.getScoresPerTerm(),\n            fromQuery\n        );\n      default:\n        throw new IllegalArgumentException(String.format(\"Score mode %s isn't supported.\", scoreMode));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Query,IndexSearcher,ScoreMode).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Query,IndexSearcher,ScoreMode).mjava","sourceNew":"  /**\n   * Method for query time joining.\n   * <p/>\n   * Execute the returned query with a {@link IndexSearcher} to retrieve all documents that have the same terms in the\n   * to field that match with documents matching the specified fromQuery and have the same terms in the from field.\n   * <p/>\n   * In the case a single document relates to more than one document the <code>multipleValuesPerDocument</code> option\n   * should be set to true. When the <code>multipleValuesPerDocument</code> is set to <code>true</code> only the\n   * the score from the first encountered join value originating from the 'from' side is mapped into the 'to' side.\n   * Even in the case when a second join value related to a specific document yields a higher score. Obviously this\n   * doesn't apply in the case that {@link ScoreMode#None} is used, since no scores are computed at all.\n   * </p>\n   * Memory considerations: During joining all unique join values are kept in memory. On top of that when the scoreMode\n   * isn't set to {@link ScoreMode#None} a float value per unique join value is kept in memory for computing scores.\n   * When scoreMode is set to {@link ScoreMode#Avg} also an additional integer value is kept in memory per unique\n   * join value.\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   * @param toField                   The to field to join to\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    switch (scoreMode) {\n      case None:\n        TermsCollector termsCollector = TermsCollector.create(fromField, multipleValuesPerDocument);\n        fromSearcher.search(fromQuery, termsCollector);\n        return new TermsQuery(toField, termsCollector.getCollectorTerms());\n      case Total:\n      case Max:\n      case Avg:\n        TermsWithScoreCollector termsWithScoreCollector =\n            TermsWithScoreCollector.create(fromField, multipleValuesPerDocument, scoreMode);\n        fromSearcher.search(fromQuery, termsWithScoreCollector);\n        return new TermsIncludingScoreQuery(\n            toField,\n            multipleValuesPerDocument,\n            termsWithScoreCollector.getCollectedTerms(),\n            termsWithScoreCollector.getScoresPerTerm(),\n            fromQuery\n        );\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n  }\n\n","sourceOld":"  /**\n   * Method for query time joining.\n   * <p/>\n   * Execute the returned query with a {@link IndexSearcher} to retrieve all documents that have the same terms in the\n   * to field that match with documents matching the specified fromQuery and have the same terms in the from field.\n   * <p/>\n   * In the case a single document relates to more than one document the <code>multipleValuesPerDocument</code> option\n   * should be set to true. When the <code>multipleValuesPerDocument</code> is set to <code>true</code> only the\n   * the score from the first encountered join value originating from the 'from' side is mapped into the 'to' side.\n   * Even in the case when a second join value related to a specific document yields a higher score. Obviously this\n   * doesn't apply in the case that {@link ScoreMode#None} is used, since no scores are computed at all.\n   * </p>\n   * Memory considerations: During joining all unique join values are kept in memory. On top of that when the scoreMode\n   * isn't set to {@link ScoreMode#None} a float value per unique join value is kept in memory for computing scores.\n   * When scoreMode is set to {@link ScoreMode#Avg} also an additional integer value is kept in memory per unique\n   * join value.\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   * @param toField                   The to field to join to\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    switch (scoreMode) {\n      case None:\n        TermsCollector termsCollector = TermsCollector.create(fromField, multipleValuesPerDocument);\n        fromSearcher.search(fromQuery, termsCollector);\n        return new TermsQuery(toField, termsCollector.getCollectorTerms());\n      case Total:\n      case Max:\n      case Avg:\n        TermsWithScoreCollector termsWithScoreCollector =\n            TermsWithScoreCollector.create(fromField, multipleValuesPerDocument, scoreMode);\n        fromSearcher.search(fromQuery, termsWithScoreCollector);\n        return new TermsIncludingScoreQuery(\n            toField,\n            multipleValuesPerDocument,\n            termsWithScoreCollector.getCollectedTerms(),\n            termsWithScoreCollector.getScoresPerTerm(),\n            fromQuery\n        );\n      default:\n        throw new IllegalArgumentException(String.format(\"Score mode %s isn't supported.\", scoreMode));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4f4c1d6d595e9d4dc26250376376df0d41a79e32","date":1359317642,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Query,IndexSearcher,ScoreMode).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Query,IndexSearcher,ScoreMode).mjava","sourceNew":"  /**\n   * Method for query time joining.\n   * <p/>\n   * Execute the returned query with a {@link IndexSearcher} to retrieve all documents that have the same terms in the\n   * to field that match with documents matching the specified fromQuery and have the same terms in the from field.\n   * <p/>\n   * In the case a single document relates to more than one document the <code>multipleValuesPerDocument</code> option\n   * should be set to true. When the <code>multipleValuesPerDocument</code> is set to <code>true</code> only the\n   * the score from the first encountered join value originating from the 'from' side is mapped into the 'to' side.\n   * Even in the case when a second join value related to a specific document yields a higher score. Obviously this\n   * doesn't apply in the case that {@link ScoreMode#None} is used, since no scores are computed at all.\n   * </p>\n   * Memory considerations: During joining all unique join values are kept in memory. On top of that when the scoreMode\n   * isn't set to {@link ScoreMode#None} a float value per unique join value is kept in memory for computing scores.\n   * When scoreMode is set to {@link ScoreMode#Avg} also an additional integer value is kept in memory per unique\n   * join value.\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   * @param toField                   The to field to join to\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    switch (scoreMode) {\n      case None:\n        TermsCollector termsCollector = TermsCollector.create(fromField, multipleValuesPerDocument);\n        fromSearcher.search(fromQuery, termsCollector);\n        return new TermsQuery(toField, fromQuery, termsCollector.getCollectorTerms());\n      case Total:\n      case Max:\n      case Avg:\n        TermsWithScoreCollector termsWithScoreCollector =\n            TermsWithScoreCollector.create(fromField, multipleValuesPerDocument, scoreMode);\n        fromSearcher.search(fromQuery, termsWithScoreCollector);\n        return new TermsIncludingScoreQuery(\n            toField,\n            multipleValuesPerDocument,\n            termsWithScoreCollector.getCollectedTerms(),\n            termsWithScoreCollector.getScoresPerTerm(),\n            fromQuery\n        );\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n  }\n\n","sourceOld":"  /**\n   * Method for query time joining.\n   * <p/>\n   * Execute the returned query with a {@link IndexSearcher} to retrieve all documents that have the same terms in the\n   * to field that match with documents matching the specified fromQuery and have the same terms in the from field.\n   * <p/>\n   * In the case a single document relates to more than one document the <code>multipleValuesPerDocument</code> option\n   * should be set to true. When the <code>multipleValuesPerDocument</code> is set to <code>true</code> only the\n   * the score from the first encountered join value originating from the 'from' side is mapped into the 'to' side.\n   * Even in the case when a second join value related to a specific document yields a higher score. Obviously this\n   * doesn't apply in the case that {@link ScoreMode#None} is used, since no scores are computed at all.\n   * </p>\n   * Memory considerations: During joining all unique join values are kept in memory. On top of that when the scoreMode\n   * isn't set to {@link ScoreMode#None} a float value per unique join value is kept in memory for computing scores.\n   * When scoreMode is set to {@link ScoreMode#Avg} also an additional integer value is kept in memory per unique\n   * join value.\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   * @param toField                   The to field to join to\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    switch (scoreMode) {\n      case None:\n        TermsCollector termsCollector = TermsCollector.create(fromField, multipleValuesPerDocument);\n        fromSearcher.search(fromQuery, termsCollector);\n        return new TermsQuery(toField, termsCollector.getCollectorTerms());\n      case Total:\n      case Max:\n      case Avg:\n        TermsWithScoreCollector termsWithScoreCollector =\n            TermsWithScoreCollector.create(fromField, multipleValuesPerDocument, scoreMode);\n        fromSearcher.search(fromQuery, termsWithScoreCollector);\n        return new TermsIncludingScoreQuery(\n            toField,\n            multipleValuesPerDocument,\n            termsWithScoreCollector.getCollectedTerms(),\n            termsWithScoreCollector.getScoresPerTerm(),\n            fromQuery\n        );\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n  }\n\n","bugFix":["77855215e331ce146763531cb9b0c050726f6ae5"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"de522d9303bd67c8473a269a1319125d1f3700e0","date":1359477856,"type":3,"author":"Adrien Grand","isMerge":true,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Query,IndexSearcher,ScoreMode).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Query,IndexSearcher,ScoreMode).mjava","sourceNew":"  /**\n   * Method for query time joining.\n   * <p/>\n   * Execute the returned query with a {@link IndexSearcher} to retrieve all documents that have the same terms in the\n   * to field that match with documents matching the specified fromQuery and have the same terms in the from field.\n   * <p/>\n   * In the case a single document relates to more than one document the <code>multipleValuesPerDocument</code> option\n   * should be set to true. When the <code>multipleValuesPerDocument</code> is set to <code>true</code> only the\n   * the score from the first encountered join value originating from the 'from' side is mapped into the 'to' side.\n   * Even in the case when a second join value related to a specific document yields a higher score. Obviously this\n   * doesn't apply in the case that {@link ScoreMode#None} is used, since no scores are computed at all.\n   * </p>\n   * Memory considerations: During joining all unique join values are kept in memory. On top of that when the scoreMode\n   * isn't set to {@link ScoreMode#None} a float value per unique join value is kept in memory for computing scores.\n   * When scoreMode is set to {@link ScoreMode#Avg} also an additional integer value is kept in memory per unique\n   * join value.\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   * @param toField                   The to field to join to\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    switch (scoreMode) {\n      case None:\n        TermsCollector termsCollector = TermsCollector.create(fromField, multipleValuesPerDocument);\n        fromSearcher.search(fromQuery, termsCollector);\n        return new TermsQuery(toField, fromQuery, termsCollector.getCollectorTerms());\n      case Total:\n      case Max:\n      case Avg:\n        TermsWithScoreCollector termsWithScoreCollector =\n            TermsWithScoreCollector.create(fromField, multipleValuesPerDocument, scoreMode);\n        fromSearcher.search(fromQuery, termsWithScoreCollector);\n        return new TermsIncludingScoreQuery(\n            toField,\n            multipleValuesPerDocument,\n            termsWithScoreCollector.getCollectedTerms(),\n            termsWithScoreCollector.getScoresPerTerm(),\n            fromQuery\n        );\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n  }\n\n","sourceOld":"  /**\n   * Method for query time joining.\n   * <p/>\n   * Execute the returned query with a {@link IndexSearcher} to retrieve all documents that have the same terms in the\n   * to field that match with documents matching the specified fromQuery and have the same terms in the from field.\n   * <p/>\n   * In the case a single document relates to more than one document the <code>multipleValuesPerDocument</code> option\n   * should be set to true. When the <code>multipleValuesPerDocument</code> is set to <code>true</code> only the\n   * the score from the first encountered join value originating from the 'from' side is mapped into the 'to' side.\n   * Even in the case when a second join value related to a specific document yields a higher score. Obviously this\n   * doesn't apply in the case that {@link ScoreMode#None} is used, since no scores are computed at all.\n   * </p>\n   * Memory considerations: During joining all unique join values are kept in memory. On top of that when the scoreMode\n   * isn't set to {@link ScoreMode#None} a float value per unique join value is kept in memory for computing scores.\n   * When scoreMode is set to {@link ScoreMode#Avg} also an additional integer value is kept in memory per unique\n   * join value.\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   * @param toField                   The to field to join to\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    switch (scoreMode) {\n      case None:\n        TermsCollector termsCollector = TermsCollector.create(fromField, multipleValuesPerDocument);\n        fromSearcher.search(fromQuery, termsCollector);\n        return new TermsQuery(toField, termsCollector.getCollectorTerms());\n      case Total:\n      case Max:\n      case Avg:\n        TermsWithScoreCollector termsWithScoreCollector =\n            TermsWithScoreCollector.create(fromField, multipleValuesPerDocument, scoreMode);\n        fromSearcher.search(fromQuery, termsWithScoreCollector);\n        return new TermsIncludingScoreQuery(\n            toField,\n            multipleValuesPerDocument,\n            termsWithScoreCollector.getCollectedTerms(),\n            termsWithScoreCollector.getScoresPerTerm(),\n            fromQuery\n        );\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14600834a1fbc7c12faf344466e00cca8cc67de4","date":1423303834,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Query,IndexSearcher,ScoreMode).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Query,IndexSearcher,ScoreMode).mjava","sourceNew":"  /**\n   * Method for query time joining.\n   * <p>\n   * Execute the returned query with a {@link IndexSearcher} to retrieve all documents that have the same terms in the\n   * to field that match with documents matching the specified fromQuery and have the same terms in the from field.\n   * <p>\n   * In the case a single document relates to more than one document the <code>multipleValuesPerDocument</code> option\n   * should be set to true. When the <code>multipleValuesPerDocument</code> is set to <code>true</code> only the\n   * the score from the first encountered join value originating from the 'from' side is mapped into the 'to' side.\n   * Even in the case when a second join value related to a specific document yields a higher score. Obviously this\n   * doesn't apply in the case that {@link ScoreMode#None} is used, since no scores are computed at all.\n   * <p>\n   * Memory considerations: During joining all unique join values are kept in memory. On top of that when the scoreMode\n   * isn't set to {@link ScoreMode#None} a float value per unique join value is kept in memory for computing scores.\n   * When scoreMode is set to {@link ScoreMode#Avg} also an additional integer value is kept in memory per unique\n   * join value.\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   * @param toField                   The to field to join to\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    switch (scoreMode) {\n      case None:\n        TermsCollector termsCollector = TermsCollector.create(fromField, multipleValuesPerDocument);\n        fromSearcher.search(fromQuery, termsCollector);\n        return new TermsQuery(toField, fromQuery, termsCollector.getCollectorTerms());\n      case Total:\n      case Max:\n      case Avg:\n        TermsWithScoreCollector termsWithScoreCollector =\n            TermsWithScoreCollector.create(fromField, multipleValuesPerDocument, scoreMode);\n        fromSearcher.search(fromQuery, termsWithScoreCollector);\n        return new TermsIncludingScoreQuery(\n            toField,\n            multipleValuesPerDocument,\n            termsWithScoreCollector.getCollectedTerms(),\n            termsWithScoreCollector.getScoresPerTerm(),\n            fromQuery\n        );\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n  }\n\n","sourceOld":"  /**\n   * Method for query time joining.\n   * <p/>\n   * Execute the returned query with a {@link IndexSearcher} to retrieve all documents that have the same terms in the\n   * to field that match with documents matching the specified fromQuery and have the same terms in the from field.\n   * <p/>\n   * In the case a single document relates to more than one document the <code>multipleValuesPerDocument</code> option\n   * should be set to true. When the <code>multipleValuesPerDocument</code> is set to <code>true</code> only the\n   * the score from the first encountered join value originating from the 'from' side is mapped into the 'to' side.\n   * Even in the case when a second join value related to a specific document yields a higher score. Obviously this\n   * doesn't apply in the case that {@link ScoreMode#None} is used, since no scores are computed at all.\n   * </p>\n   * Memory considerations: During joining all unique join values are kept in memory. On top of that when the scoreMode\n   * isn't set to {@link ScoreMode#None} a float value per unique join value is kept in memory for computing scores.\n   * When scoreMode is set to {@link ScoreMode#Avg} also an additional integer value is kept in memory per unique\n   * join value.\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   * @param toField                   The to field to join to\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    switch (scoreMode) {\n      case None:\n        TermsCollector termsCollector = TermsCollector.create(fromField, multipleValuesPerDocument);\n        fromSearcher.search(fromQuery, termsCollector);\n        return new TermsQuery(toField, fromQuery, termsCollector.getCollectorTerms());\n      case Total:\n      case Max:\n      case Avg:\n        TermsWithScoreCollector termsWithScoreCollector =\n            TermsWithScoreCollector.create(fromField, multipleValuesPerDocument, scoreMode);\n        fromSearcher.search(fromQuery, termsWithScoreCollector);\n        return new TermsIncludingScoreQuery(\n            toField,\n            multipleValuesPerDocument,\n            termsWithScoreCollector.getCollectedTerms(),\n            termsWithScoreCollector.getScoresPerTerm(),\n            fromQuery\n        );\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe4b37941dda041ab19456b15412aacb9c657a26","date":1429449253,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Query,IndexSearcher,ScoreMode).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Query,IndexSearcher,ScoreMode).mjava","sourceNew":"  /**\n   * Method for query time joining.\n   * <p>\n   * Execute the returned query with a {@link IndexSearcher} to retrieve all documents that have the same terms in the\n   * to field that match with documents matching the specified fromQuery and have the same terms in the from field.\n   * <p>\n   * In the case a single document relates to more than one document the <code>multipleValuesPerDocument</code> option\n   * should be set to true. When the <code>multipleValuesPerDocument</code> is set to <code>true</code> only the\n   * the score from the first encountered join value originating from the 'from' side is mapped into the 'to' side.\n   * Even in the case when a second join value related to a specific document yields a higher score. Obviously this\n   * doesn't apply in the case that {@link ScoreMode#None} is used, since no scores are computed at all.\n   * <p>\n   * Memory considerations: During joining all unique join values are kept in memory. On top of that when the scoreMode\n   * isn't set to {@link ScoreMode#None} a float value per unique join value is kept in memory for computing scores.\n   * When scoreMode is set to {@link ScoreMode#Avg} also an additional integer value is kept in memory per unique\n   * join value.\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   * @param toField                   The to field to join to\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    switch (scoreMode) {\n      case None:\n        TermsCollector termsCollector = TermsCollector.create(fromField, multipleValuesPerDocument);\n        fromSearcher.search(fromQuery, termsCollector);\n        return new TermsQuery(toField, fromQuery, termsCollector.getCollectorTerms());\n      case Total:\n      case Max:\n      case Min:\n      case Avg:\n        TermsWithScoreCollector termsWithScoreCollector =\n            TermsWithScoreCollector.create(fromField, multipleValuesPerDocument, scoreMode);\n        fromSearcher.search(fromQuery, termsWithScoreCollector);\n        return new TermsIncludingScoreQuery(\n            toField,\n            multipleValuesPerDocument,\n            termsWithScoreCollector.getCollectedTerms(),\n            termsWithScoreCollector.getScoresPerTerm(),\n            fromQuery\n        );\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n  }\n\n","sourceOld":"  /**\n   * Method for query time joining.\n   * <p>\n   * Execute the returned query with a {@link IndexSearcher} to retrieve all documents that have the same terms in the\n   * to field that match with documents matching the specified fromQuery and have the same terms in the from field.\n   * <p>\n   * In the case a single document relates to more than one document the <code>multipleValuesPerDocument</code> option\n   * should be set to true. When the <code>multipleValuesPerDocument</code> is set to <code>true</code> only the\n   * the score from the first encountered join value originating from the 'from' side is mapped into the 'to' side.\n   * Even in the case when a second join value related to a specific document yields a higher score. Obviously this\n   * doesn't apply in the case that {@link ScoreMode#None} is used, since no scores are computed at all.\n   * <p>\n   * Memory considerations: During joining all unique join values are kept in memory. On top of that when the scoreMode\n   * isn't set to {@link ScoreMode#None} a float value per unique join value is kept in memory for computing scores.\n   * When scoreMode is set to {@link ScoreMode#Avg} also an additional integer value is kept in memory per unique\n   * join value.\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   * @param toField                   The to field to join to\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    switch (scoreMode) {\n      case None:\n        TermsCollector termsCollector = TermsCollector.create(fromField, multipleValuesPerDocument);\n        fromSearcher.search(fromQuery, termsCollector);\n        return new TermsQuery(toField, fromQuery, termsCollector.getCollectorTerms());\n      case Total:\n      case Max:\n      case Avg:\n        TermsWithScoreCollector termsWithScoreCollector =\n            TermsWithScoreCollector.create(fromField, multipleValuesPerDocument, scoreMode);\n        fromSearcher.search(fromQuery, termsWithScoreCollector);\n        return new TermsIncludingScoreQuery(\n            toField,\n            multipleValuesPerDocument,\n            termsWithScoreCollector.getCollectedTerms(),\n            termsWithScoreCollector.getScoresPerTerm(),\n            fromQuery\n        );\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af3f3d3f7a6a159ccf14d58544fd71ae72c89b10","date":1449514606,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Query,IndexSearcher,ScoreMode).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Query,IndexSearcher,ScoreMode).mjava","sourceNew":"  /**\n   * Method for query time joining.\n   * <p>\n   * Execute the returned query with a {@link IndexSearcher} to retrieve all documents that have the same terms in the\n   * to field that match with documents matching the specified fromQuery and have the same terms in the from field.\n   * <p>\n   * In the case a single document relates to more than one document the <code>multipleValuesPerDocument</code> option\n   * should be set to true. When the <code>multipleValuesPerDocument</code> is set to <code>true</code> only the\n   * the score from the first encountered join value originating from the 'from' side is mapped into the 'to' side.\n   * Even in the case when a second join value related to a specific document yields a higher score. Obviously this\n   * doesn't apply in the case that {@link ScoreMode#None} is used, since no scores are computed at all.\n   * <p>\n   * Memory considerations: During joining all unique join values are kept in memory. On top of that when the scoreMode\n   * isn't set to {@link ScoreMode#None} a float value per unique join value is kept in memory for computing scores.\n   * When scoreMode is set to {@link ScoreMode#Avg} also an additional integer value is kept in memory per unique\n   * join value.\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   * @param toField                   The to field to join to\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n      boolean multipleValuesPerDocument,\n      String toField,\n      Query fromQuery,\n      IndexSearcher fromSearcher,\n      ScoreMode scoreMode) throws IOException {\n    \n    final GenericTermsCollector termsWithScoreCollector;\n     \n    if (multipleValuesPerDocument) {\n      Function<SortedSetDocValues> mvFunction = DocValuesTermsCollector.sortedSetDocValues(fromField);\n      termsWithScoreCollector = GenericTermsCollector.createCollectorMV(mvFunction, scoreMode);\n    } else {\n      Function<BinaryDocValues> svFunction = DocValuesTermsCollector.binaryDocValues(fromField);\n      termsWithScoreCollector =  GenericTermsCollector.createCollectorSV(svFunction, scoreMode);\n    }\n    \n    return createJoinQuery(multipleValuesPerDocument, toField, fromQuery, fromSearcher, scoreMode,\n        termsWithScoreCollector);\n    \n  }\n\n","sourceOld":"  /**\n   * Method for query time joining.\n   * <p>\n   * Execute the returned query with a {@link IndexSearcher} to retrieve all documents that have the same terms in the\n   * to field that match with documents matching the specified fromQuery and have the same terms in the from field.\n   * <p>\n   * In the case a single document relates to more than one document the <code>multipleValuesPerDocument</code> option\n   * should be set to true. When the <code>multipleValuesPerDocument</code> is set to <code>true</code> only the\n   * the score from the first encountered join value originating from the 'from' side is mapped into the 'to' side.\n   * Even in the case when a second join value related to a specific document yields a higher score. Obviously this\n   * doesn't apply in the case that {@link ScoreMode#None} is used, since no scores are computed at all.\n   * <p>\n   * Memory considerations: During joining all unique join values are kept in memory. On top of that when the scoreMode\n   * isn't set to {@link ScoreMode#None} a float value per unique join value is kept in memory for computing scores.\n   * When scoreMode is set to {@link ScoreMode#Avg} also an additional integer value is kept in memory per unique\n   * join value.\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   * @param toField                   The to field to join to\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n                                      boolean multipleValuesPerDocument,\n                                      String toField,\n                                      Query fromQuery,\n                                      IndexSearcher fromSearcher,\n                                      ScoreMode scoreMode) throws IOException {\n    switch (scoreMode) {\n      case None:\n        TermsCollector termsCollector = TermsCollector.create(fromField, multipleValuesPerDocument);\n        fromSearcher.search(fromQuery, termsCollector);\n        return new TermsQuery(toField, fromQuery, termsCollector.getCollectorTerms());\n      case Total:\n      case Max:\n      case Min:\n      case Avg:\n        TermsWithScoreCollector termsWithScoreCollector =\n            TermsWithScoreCollector.create(fromField, multipleValuesPerDocument, scoreMode);\n        fromSearcher.search(fromQuery, termsWithScoreCollector);\n        return new TermsIncludingScoreQuery(\n            toField,\n            multipleValuesPerDocument,\n            termsWithScoreCollector.getCollectedTerms(),\n            termsWithScoreCollector.getScoresPerTerm(),\n            fromQuery\n        );\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6652c74b2358a0b13223817a6a793bf1c9d0749d","date":1474465301,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Query,IndexSearcher,ScoreMode).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Query,IndexSearcher,ScoreMode).mjava","sourceNew":"  /**\n   * Method for query time joining.\n   * <p>\n   * Execute the returned query with a {@link IndexSearcher} to retrieve all documents that have the same terms in the\n   * to field that match with documents matching the specified fromQuery and have the same terms in the from field.\n   * <p>\n   * In the case a single document relates to more than one document the <code>multipleValuesPerDocument</code> option\n   * should be set to true. When the <code>multipleValuesPerDocument</code> is set to <code>true</code> only the\n   * the score from the first encountered join value originating from the 'from' side is mapped into the 'to' side.\n   * Even in the case when a second join value related to a specific document yields a higher score. Obviously this\n   * doesn't apply in the case that {@link ScoreMode#None} is used, since no scores are computed at all.\n   * <p>\n   * Memory considerations: During joining all unique join values are kept in memory. On top of that when the scoreMode\n   * isn't set to {@link ScoreMode#None} a float value per unique join value is kept in memory for computing scores.\n   * When scoreMode is set to {@link ScoreMode#Avg} also an additional integer value is kept in memory per unique\n   * join value.\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   * @param toField                   The to field to join to\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n      boolean multipleValuesPerDocument,\n      String toField,\n      Query fromQuery,\n      IndexSearcher fromSearcher,\n      ScoreMode scoreMode) throws IOException {\n    \n    final GenericTermsCollector termsWithScoreCollector;\n     \n    if (multipleValuesPerDocument) {\n      Function<SortedSetDocValues> mvFunction = DocValuesTermsCollector.sortedSetDocValues(fromField);\n      termsWithScoreCollector = GenericTermsCollector.createCollectorMV(mvFunction, scoreMode);\n    } else {\n      Function<BinaryDocValues> svFunction = DocValuesTermsCollector.binaryDocValues(fromField);\n      termsWithScoreCollector = GenericTermsCollector.createCollectorSV(svFunction, scoreMode);\n    }\n    \n    return createJoinQuery(multipleValuesPerDocument, toField, fromQuery, fromSearcher, scoreMode, termsWithScoreCollector);\n  }\n\n","sourceOld":"  /**\n   * Method for query time joining.\n   * <p>\n   * Execute the returned query with a {@link IndexSearcher} to retrieve all documents that have the same terms in the\n   * to field that match with documents matching the specified fromQuery and have the same terms in the from field.\n   * <p>\n   * In the case a single document relates to more than one document the <code>multipleValuesPerDocument</code> option\n   * should be set to true. When the <code>multipleValuesPerDocument</code> is set to <code>true</code> only the\n   * the score from the first encountered join value originating from the 'from' side is mapped into the 'to' side.\n   * Even in the case when a second join value related to a specific document yields a higher score. Obviously this\n   * doesn't apply in the case that {@link ScoreMode#None} is used, since no scores are computed at all.\n   * <p>\n   * Memory considerations: During joining all unique join values are kept in memory. On top of that when the scoreMode\n   * isn't set to {@link ScoreMode#None} a float value per unique join value is kept in memory for computing scores.\n   * When scoreMode is set to {@link ScoreMode#Avg} also an additional integer value is kept in memory per unique\n   * join value.\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   * @param toField                   The to field to join to\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n      boolean multipleValuesPerDocument,\n      String toField,\n      Query fromQuery,\n      IndexSearcher fromSearcher,\n      ScoreMode scoreMode) throws IOException {\n    \n    final GenericTermsCollector termsWithScoreCollector;\n     \n    if (multipleValuesPerDocument) {\n      Function<SortedSetDocValues> mvFunction = DocValuesTermsCollector.sortedSetDocValues(fromField);\n      termsWithScoreCollector = GenericTermsCollector.createCollectorMV(mvFunction, scoreMode);\n    } else {\n      Function<BinaryDocValues> svFunction = DocValuesTermsCollector.binaryDocValues(fromField);\n      termsWithScoreCollector =  GenericTermsCollector.createCollectorSV(svFunction, scoreMode);\n    }\n    \n    return createJoinQuery(multipleValuesPerDocument, toField, fromQuery, fromSearcher, scoreMode,\n        termsWithScoreCollector);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Query,IndexSearcher,ScoreMode).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Query,IndexSearcher,ScoreMode).mjava","sourceNew":"  /**\n   * Method for query time joining.\n   * <p>\n   * Execute the returned query with a {@link IndexSearcher} to retrieve all documents that have the same terms in the\n   * to field that match with documents matching the specified fromQuery and have the same terms in the from field.\n   * <p>\n   * In the case a single document relates to more than one document the <code>multipleValuesPerDocument</code> option\n   * should be set to true. When the <code>multipleValuesPerDocument</code> is set to <code>true</code> only the\n   * the score from the first encountered join value originating from the 'from' side is mapped into the 'to' side.\n   * Even in the case when a second join value related to a specific document yields a higher score. Obviously this\n   * doesn't apply in the case that {@link ScoreMode#None} is used, since no scores are computed at all.\n   * <p>\n   * Memory considerations: During joining all unique join values are kept in memory. On top of that when the scoreMode\n   * isn't set to {@link ScoreMode#None} a float value per unique join value is kept in memory for computing scores.\n   * When scoreMode is set to {@link ScoreMode#Avg} also an additional integer value is kept in memory per unique\n   * join value.\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   * @param toField                   The to field to join to\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n      boolean multipleValuesPerDocument,\n      String toField,\n      Query fromQuery,\n      IndexSearcher fromSearcher,\n      ScoreMode scoreMode) throws IOException {\n    \n    final GenericTermsCollector termsWithScoreCollector;\n     \n    if (multipleValuesPerDocument) {\n      Function<SortedSetDocValues> mvFunction = DocValuesTermsCollector.sortedSetDocValues(fromField);\n      termsWithScoreCollector = GenericTermsCollector.createCollectorMV(mvFunction, scoreMode);\n    } else {\n      Function<BinaryDocValues> svFunction = DocValuesTermsCollector.binaryDocValues(fromField);\n      termsWithScoreCollector = GenericTermsCollector.createCollectorSV(svFunction, scoreMode);\n    }\n    \n    return createJoinQuery(multipleValuesPerDocument, toField, fromQuery, fromSearcher, scoreMode, termsWithScoreCollector);\n  }\n\n","sourceOld":"  /**\n   * Method for query time joining.\n   * <p>\n   * Execute the returned query with a {@link IndexSearcher} to retrieve all documents that have the same terms in the\n   * to field that match with documents matching the specified fromQuery and have the same terms in the from field.\n   * <p>\n   * In the case a single document relates to more than one document the <code>multipleValuesPerDocument</code> option\n   * should be set to true. When the <code>multipleValuesPerDocument</code> is set to <code>true</code> only the\n   * the score from the first encountered join value originating from the 'from' side is mapped into the 'to' side.\n   * Even in the case when a second join value related to a specific document yields a higher score. Obviously this\n   * doesn't apply in the case that {@link ScoreMode#None} is used, since no scores are computed at all.\n   * <p>\n   * Memory considerations: During joining all unique join values are kept in memory. On top of that when the scoreMode\n   * isn't set to {@link ScoreMode#None} a float value per unique join value is kept in memory for computing scores.\n   * When scoreMode is set to {@link ScoreMode#Avg} also an additional integer value is kept in memory per unique\n   * join value.\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   * @param toField                   The to field to join to\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n      boolean multipleValuesPerDocument,\n      String toField,\n      Query fromQuery,\n      IndexSearcher fromSearcher,\n      ScoreMode scoreMode) throws IOException {\n    \n    final GenericTermsCollector termsWithScoreCollector;\n     \n    if (multipleValuesPerDocument) {\n      Function<SortedSetDocValues> mvFunction = DocValuesTermsCollector.sortedSetDocValues(fromField);\n      termsWithScoreCollector = GenericTermsCollector.createCollectorMV(mvFunction, scoreMode);\n    } else {\n      Function<BinaryDocValues> svFunction = DocValuesTermsCollector.binaryDocValues(fromField);\n      termsWithScoreCollector =  GenericTermsCollector.createCollectorSV(svFunction, scoreMode);\n    }\n    \n    return createJoinQuery(multipleValuesPerDocument, toField, fromQuery, fromSearcher, scoreMode,\n        termsWithScoreCollector);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Query,IndexSearcher,ScoreMode).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Query,IndexSearcher,ScoreMode).mjava","sourceNew":"  /**\n   * Method for query time joining.\n   * <p>\n   * Execute the returned query with a {@link IndexSearcher} to retrieve all documents that have the same terms in the\n   * to field that match with documents matching the specified fromQuery and have the same terms in the from field.\n   * <p>\n   * In the case a single document relates to more than one document the <code>multipleValuesPerDocument</code> option\n   * should be set to true. When the <code>multipleValuesPerDocument</code> is set to <code>true</code> only the\n   * the score from the first encountered join value originating from the 'from' side is mapped into the 'to' side.\n   * Even in the case when a second join value related to a specific document yields a higher score. Obviously this\n   * doesn't apply in the case that {@link ScoreMode#None} is used, since no scores are computed at all.\n   * <p>\n   * Memory considerations: During joining all unique join values are kept in memory. On top of that when the scoreMode\n   * isn't set to {@link ScoreMode#None} a float value per unique join value is kept in memory for computing scores.\n   * When scoreMode is set to {@link ScoreMode#Avg} also an additional integer value is kept in memory per unique\n   * join value.\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   * @param toField                   The to field to join to\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n      boolean multipleValuesPerDocument,\n      String toField,\n      Query fromQuery,\n      IndexSearcher fromSearcher,\n      ScoreMode scoreMode) throws IOException {\n    \n    final GenericTermsCollector termsWithScoreCollector;\n     \n    if (multipleValuesPerDocument) {\n      Function<SortedSetDocValues> mvFunction = DocValuesTermsCollector.sortedSetDocValues(fromField);\n      termsWithScoreCollector = GenericTermsCollector.createCollectorMV(mvFunction, scoreMode);\n    } else {\n      Function<BinaryDocValues> svFunction = DocValuesTermsCollector.binaryDocValues(fromField);\n      termsWithScoreCollector = GenericTermsCollector.createCollectorSV(svFunction, scoreMode);\n    }\n    \n    return createJoinQuery(multipleValuesPerDocument, toField, fromQuery, fromSearcher, scoreMode, termsWithScoreCollector);\n  }\n\n","sourceOld":"  /**\n   * Method for query time joining.\n   * <p>\n   * Execute the returned query with a {@link IndexSearcher} to retrieve all documents that have the same terms in the\n   * to field that match with documents matching the specified fromQuery and have the same terms in the from field.\n   * <p>\n   * In the case a single document relates to more than one document the <code>multipleValuesPerDocument</code> option\n   * should be set to true. When the <code>multipleValuesPerDocument</code> is set to <code>true</code> only the\n   * the score from the first encountered join value originating from the 'from' side is mapped into the 'to' side.\n   * Even in the case when a second join value related to a specific document yields a higher score. Obviously this\n   * doesn't apply in the case that {@link ScoreMode#None} is used, since no scores are computed at all.\n   * <p>\n   * Memory considerations: During joining all unique join values are kept in memory. On top of that when the scoreMode\n   * isn't set to {@link ScoreMode#None} a float value per unique join value is kept in memory for computing scores.\n   * When scoreMode is set to {@link ScoreMode#Avg} also an additional integer value is kept in memory per unique\n   * join value.\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   * @param toField                   The to field to join to\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n      boolean multipleValuesPerDocument,\n      String toField,\n      Query fromQuery,\n      IndexSearcher fromSearcher,\n      ScoreMode scoreMode) throws IOException {\n    \n    final GenericTermsCollector termsWithScoreCollector;\n     \n    if (multipleValuesPerDocument) {\n      Function<SortedSetDocValues> mvFunction = DocValuesTermsCollector.sortedSetDocValues(fromField);\n      termsWithScoreCollector = GenericTermsCollector.createCollectorMV(mvFunction, scoreMode);\n    } else {\n      Function<BinaryDocValues> svFunction = DocValuesTermsCollector.binaryDocValues(fromField);\n      termsWithScoreCollector =  GenericTermsCollector.createCollectorSV(svFunction, scoreMode);\n    }\n    \n    return createJoinQuery(multipleValuesPerDocument, toField, fromQuery, fromSearcher, scoreMode,\n        termsWithScoreCollector);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"00b0e2840ecbd8db96919cdfcdf2f451aa9ddfe7","date":1495529154,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Query,IndexSearcher,ScoreMode).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Query,IndexSearcher,ScoreMode).mjava","sourceNew":"  /**\n   * Method for query time joining.\n   * <p>\n   * Execute the returned query with a {@link IndexSearcher} to retrieve all documents that have the same terms in the\n   * to field that match with documents matching the specified fromQuery and have the same terms in the from field.\n   * <p>\n   * In the case a single document relates to more than one document the <code>multipleValuesPerDocument</code> option\n   * should be set to true. When the <code>multipleValuesPerDocument</code> is set to <code>true</code> only the\n   * the score from the first encountered join value originating from the 'from' side is mapped into the 'to' side.\n   * Even in the case when a second join value related to a specific document yields a higher score. Obviously this\n   * doesn't apply in the case that {@link ScoreMode#None} is used, since no scores are computed at all.\n   * <p>\n   * Memory considerations: During joining all unique join values are kept in memory. On top of that when the scoreMode\n   * isn't set to {@link ScoreMode#None} a float value per unique join value is kept in memory for computing scores.\n   * When scoreMode is set to {@link ScoreMode#Avg} also an additional integer value is kept in memory per unique\n   * join value.\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   * @param toField                   The to field to join to\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n      boolean multipleValuesPerDocument,\n      String toField,\n      Query fromQuery,\n      IndexSearcher fromSearcher,\n      ScoreMode scoreMode) throws IOException {\n    \n    final GenericTermsCollector termsWithScoreCollector;\n     \n    if (multipleValuesPerDocument) {\n      Function<SortedSetDocValues> mvFunction = DocValuesTermsCollector.sortedSetDocValues(fromField);\n      termsWithScoreCollector = GenericTermsCollector.createCollectorMV(mvFunction, scoreMode);\n    } else {\n      Function<BinaryDocValues> svFunction = DocValuesTermsCollector.binaryDocValues(fromField);\n      termsWithScoreCollector = GenericTermsCollector.createCollectorSV(svFunction, scoreMode);\n    }\n    \n    return createJoinQuery(multipleValuesPerDocument, toField, fromQuery, fromField, fromSearcher, scoreMode, termsWithScoreCollector);\n  }\n\n","sourceOld":"  /**\n   * Method for query time joining.\n   * <p>\n   * Execute the returned query with a {@link IndexSearcher} to retrieve all documents that have the same terms in the\n   * to field that match with documents matching the specified fromQuery and have the same terms in the from field.\n   * <p>\n   * In the case a single document relates to more than one document the <code>multipleValuesPerDocument</code> option\n   * should be set to true. When the <code>multipleValuesPerDocument</code> is set to <code>true</code> only the\n   * the score from the first encountered join value originating from the 'from' side is mapped into the 'to' side.\n   * Even in the case when a second join value related to a specific document yields a higher score. Obviously this\n   * doesn't apply in the case that {@link ScoreMode#None} is used, since no scores are computed at all.\n   * <p>\n   * Memory considerations: During joining all unique join values are kept in memory. On top of that when the scoreMode\n   * isn't set to {@link ScoreMode#None} a float value per unique join value is kept in memory for computing scores.\n   * When scoreMode is set to {@link ScoreMode#Avg} also an additional integer value is kept in memory per unique\n   * join value.\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   * @param toField                   The to field to join to\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n      boolean multipleValuesPerDocument,\n      String toField,\n      Query fromQuery,\n      IndexSearcher fromSearcher,\n      ScoreMode scoreMode) throws IOException {\n    \n    final GenericTermsCollector termsWithScoreCollector;\n     \n    if (multipleValuesPerDocument) {\n      Function<SortedSetDocValues> mvFunction = DocValuesTermsCollector.sortedSetDocValues(fromField);\n      termsWithScoreCollector = GenericTermsCollector.createCollectorMV(mvFunction, scoreMode);\n    } else {\n      Function<BinaryDocValues> svFunction = DocValuesTermsCollector.binaryDocValues(fromField);\n      termsWithScoreCollector = GenericTermsCollector.createCollectorSV(svFunction, scoreMode);\n    }\n    \n    return createJoinQuery(multipleValuesPerDocument, toField, fromQuery, fromSearcher, scoreMode, termsWithScoreCollector);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Query,IndexSearcher,ScoreMode).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,boolean,String,Query,IndexSearcher,ScoreMode).mjava","sourceNew":"  /**\n   * Method for query time joining.\n   * <p>\n   * Execute the returned query with a {@link IndexSearcher} to retrieve all documents that have the same terms in the\n   * to field that match with documents matching the specified fromQuery and have the same terms in the from field.\n   * <p>\n   * In the case a single document relates to more than one document the <code>multipleValuesPerDocument</code> option\n   * should be set to true. When the <code>multipleValuesPerDocument</code> is set to <code>true</code> only the\n   * the score from the first encountered join value originating from the 'from' side is mapped into the 'to' side.\n   * Even in the case when a second join value related to a specific document yields a higher score. Obviously this\n   * doesn't apply in the case that {@link ScoreMode#None} is used, since no scores are computed at all.\n   * <p>\n   * Memory considerations: During joining all unique join values are kept in memory. On top of that when the scoreMode\n   * isn't set to {@link ScoreMode#None} a float value per unique join value is kept in memory for computing scores.\n   * When scoreMode is set to {@link ScoreMode#Avg} also an additional integer value is kept in memory per unique\n   * join value.\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   * @param toField                   The to field to join to\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n      boolean multipleValuesPerDocument,\n      String toField,\n      Query fromQuery,\n      IndexSearcher fromSearcher,\n      ScoreMode scoreMode) throws IOException {\n    \n    final GenericTermsCollector termsWithScoreCollector;\n     \n    if (multipleValuesPerDocument) {\n      Function<SortedSetDocValues> mvFunction = DocValuesTermsCollector.sortedSetDocValues(fromField);\n      termsWithScoreCollector = GenericTermsCollector.createCollectorMV(mvFunction, scoreMode);\n    } else {\n      Function<BinaryDocValues> svFunction = DocValuesTermsCollector.binaryDocValues(fromField);\n      termsWithScoreCollector = GenericTermsCollector.createCollectorSV(svFunction, scoreMode);\n    }\n    \n    return createJoinQuery(multipleValuesPerDocument, toField, fromQuery, fromField, fromSearcher, scoreMode, termsWithScoreCollector);\n  }\n\n","sourceOld":"  /**\n   * Method for query time joining.\n   * <p>\n   * Execute the returned query with a {@link IndexSearcher} to retrieve all documents that have the same terms in the\n   * to field that match with documents matching the specified fromQuery and have the same terms in the from field.\n   * <p>\n   * In the case a single document relates to more than one document the <code>multipleValuesPerDocument</code> option\n   * should be set to true. When the <code>multipleValuesPerDocument</code> is set to <code>true</code> only the\n   * the score from the first encountered join value originating from the 'from' side is mapped into the 'to' side.\n   * Even in the case when a second join value related to a specific document yields a higher score. Obviously this\n   * doesn't apply in the case that {@link ScoreMode#None} is used, since no scores are computed at all.\n   * <p>\n   * Memory considerations: During joining all unique join values are kept in memory. On top of that when the scoreMode\n   * isn't set to {@link ScoreMode#None} a float value per unique join value is kept in memory for computing scores.\n   * When scoreMode is set to {@link ScoreMode#Avg} also an additional integer value is kept in memory per unique\n   * join value.\n   *\n   * @param fromField                 The from field to join from\n   * @param multipleValuesPerDocument Whether the from field has multiple terms per document\n   * @param toField                   The to field to join to\n   * @param fromQuery                 The query to match documents on the from side\n   * @param fromSearcher              The searcher that executed the specified fromQuery\n   * @param scoreMode                 Instructs how scores from the fromQuery are mapped to the returned query\n   * @return a {@link Query} instance that can be used to join documents based on the\n   *         terms in the from and to field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String fromField,\n      boolean multipleValuesPerDocument,\n      String toField,\n      Query fromQuery,\n      IndexSearcher fromSearcher,\n      ScoreMode scoreMode) throws IOException {\n    \n    final GenericTermsCollector termsWithScoreCollector;\n     \n    if (multipleValuesPerDocument) {\n      Function<SortedSetDocValues> mvFunction = DocValuesTermsCollector.sortedSetDocValues(fromField);\n      termsWithScoreCollector = GenericTermsCollector.createCollectorMV(mvFunction, scoreMode);\n    } else {\n      Function<BinaryDocValues> svFunction = DocValuesTermsCollector.binaryDocValues(fromField);\n      termsWithScoreCollector = GenericTermsCollector.createCollectorSV(svFunction, scoreMode);\n    }\n    \n    return createJoinQuery(multipleValuesPerDocument, toField, fromQuery, fromSearcher, scoreMode, termsWithScoreCollector);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"14600834a1fbc7c12faf344466e00cca8cc67de4":["4f4c1d6d595e9d4dc26250376376df0d41a79e32"],"fe4b37941dda041ab19456b15412aacb9c657a26":["14600834a1fbc7c12faf344466e00cca8cc67de4"],"2acf500f78aa12b92e371fd89c719291986b6b90":["77855215e331ce146763531cb9b0c050726f6ae5","9c70cdb81dc660d90f9d0664dd91b473b7e66563"],"de522d9303bd67c8473a269a1319125d1f3700e0":["2acf500f78aa12b92e371fd89c719291986b6b90","4f4c1d6d595e9d4dc26250376376df0d41a79e32"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["af3f3d3f7a6a159ccf14d58544fd71ae72c89b10","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"9c70cdb81dc660d90f9d0664dd91b473b7e66563":["77855215e331ce146763531cb9b0c050726f6ae5"],"46d8ada1fff8d18cb197c38c7983225162599948":["77855215e331ce146763531cb9b0c050726f6ae5","2acf500f78aa12b92e371fd89c719291986b6b90"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","00b0e2840ecbd8db96919cdfcdf2f451aa9ddfe7"],"00b0e2840ecbd8db96919cdfcdf2f451aa9ddfe7":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["77855215e331ce146763531cb9b0c050726f6ae5","2acf500f78aa12b92e371fd89c719291986b6b90"],"af3f3d3f7a6a159ccf14d58544fd71ae72c89b10":["fe4b37941dda041ab19456b15412aacb9c657a26"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["af3f3d3f7a6a159ccf14d58544fd71ae72c89b10","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["af3f3d3f7a6a159ccf14d58544fd71ae72c89b10"],"77855215e331ce146763531cb9b0c050726f6ae5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["00b0e2840ecbd8db96919cdfcdf2f451aa9ddfe7"],"4f4c1d6d595e9d4dc26250376376df0d41a79e32":["2acf500f78aa12b92e371fd89c719291986b6b90"]},"commit2Childs":{"14600834a1fbc7c12faf344466e00cca8cc67de4":["fe4b37941dda041ab19456b15412aacb9c657a26"],"fe4b37941dda041ab19456b15412aacb9c657a26":["af3f3d3f7a6a159ccf14d58544fd71ae72c89b10"],"2acf500f78aa12b92e371fd89c719291986b6b90":["de522d9303bd67c8473a269a1319125d1f3700e0","46d8ada1fff8d18cb197c38c7983225162599948","fe33227f6805edab2036cbb80645cc4e2d1fa424","4f4c1d6d595e9d4dc26250376376df0d41a79e32"],"de522d9303bd67c8473a269a1319125d1f3700e0":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"9c70cdb81dc660d90f9d0664dd91b473b7e66563":["2acf500f78aa12b92e371fd89c719291986b6b90"],"46d8ada1fff8d18cb197c38c7983225162599948":[],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"00b0e2840ecbd8db96919cdfcdf2f451aa9ddfe7":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"af3f3d3f7a6a159ccf14d58544fd71ae72c89b10":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e9017cf144952056066919f1ebc7897ff9bd71b1","00b0e2840ecbd8db96919cdfcdf2f451aa9ddfe7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["77855215e331ce146763531cb9b0c050726f6ae5"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"77855215e331ce146763531cb9b0c050726f6ae5":["2acf500f78aa12b92e371fd89c719291986b6b90","9c70cdb81dc660d90f9d0664dd91b473b7e66563","46d8ada1fff8d18cb197c38c7983225162599948","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"4f4c1d6d595e9d4dc26250376376df0d41a79e32":["14600834a1fbc7c12faf344466e00cca8cc67de4","de522d9303bd67c8473a269a1319125d1f3700e0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["de522d9303bd67c8473a269a1319125d1f3700e0","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","46d8ada1fff8d18cb197c38c7983225162599948","e9017cf144952056066919f1ebc7897ff9bd71b1","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}