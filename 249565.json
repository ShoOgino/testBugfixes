{"path":"solr/core/src/java/org/apache/solr/util/hll/HLL#addRawSparseProbabilistic(long).mjava","commits":[{"id":"6d8714f9ceaaff94f0968d1c2d037978c3fde569","date":1437042727,"type":0,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/hll/HLL#addRawSparseProbabilistic(long).mjava","pathOld":"/dev/null","sourceNew":"    // ------------------------------------------------------------------------\n    // #addRaw(..) helpers\n    /**\n     * Adds the raw value to the {@link #sparseProbabilisticStorage}.\n     * {@link #type} must be {@link HLLType#SPARSE}.\n     *\n     * @param rawValue the raw value to add to the sparse storage.\n     */\n    private void addRawSparseProbabilistic(final long rawValue) {\n        // p(w): position of the least significant set bit (one-indexed)\n        // By contract: p(w) <= 2^(registerValueInBits) - 1 (the max register value)\n        //\n        // By construction of pwMaxMask (see #Constructor()),\n        //      lsb(pwMaxMask) = 2^(registerValueInBits) - 2,\n        // thus lsb(any_long | pwMaxMask) <= 2^(registerValueInBits) - 2,\n        // thus 1 + lsb(any_long | pwMaxMask) <= 2^(registerValueInBits) -1.\n        final long substreamValue = (rawValue >>> log2m);\n        final byte p_w;\n\n        if(substreamValue == 0L) {\n            // The paper does not cover p(0x0), so the special value 0 is used.\n            // 0 is the original initialization value of the registers, so by\n            // doing this the multiset simply ignores it. This is acceptable\n            // because the probability is 1/(2^(2^registerSizeInBits)).\n            p_w = 0;\n        } else {\n            p_w = (byte)(1 + BitUtil.leastSignificantBit(substreamValue| pwMaxMask));\n        }\n\n        // Short-circuit if the register is being set to zero, since algorithmically\n        // this corresponds to an \"unset\" register, and \"unset\" registers aren't\n        // stored to save memory. (The very reason this sparse implementation\n        // exists.) If a register is set to zero it will break the #algorithmCardinality\n        // code.\n        if(p_w == 0) {\n            return;\n        }\n\n        // NOTE:  no +1 as in paper since 0-based indexing\n        final int j = (int)(rawValue & mBitsMask);\n\n        final byte currentValue;\n        if (sparseProbabilisticStorage.containsKey(j)) {\n          currentValue = sparseProbabilisticStorage.lget();\n        } else {\n          currentValue = 0;\n        }\n\n        if(p_w > currentValue) {\n            sparseProbabilisticStorage.put(j, p_w);\n        }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b5ee4c66244bdfcc4796a114519d47701b2c026","date":1437132013,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/hll/HLL#addRawSparseProbabilistic(long).mjava","pathOld":"/dev/null","sourceNew":"    // ------------------------------------------------------------------------\n    // #addRaw(..) helpers\n    /**\n     * Adds the raw value to the {@link #sparseProbabilisticStorage}.\n     * {@link #type} must be {@link HLLType#SPARSE}.\n     *\n     * @param rawValue the raw value to add to the sparse storage.\n     */\n    private void addRawSparseProbabilistic(final long rawValue) {\n        // p(w): position of the least significant set bit (one-indexed)\n        // By contract: p(w) <= 2^(registerValueInBits) - 1 (the max register value)\n        //\n        // By construction of pwMaxMask (see #Constructor()),\n        //      lsb(pwMaxMask) = 2^(registerValueInBits) - 2,\n        // thus lsb(any_long | pwMaxMask) <= 2^(registerValueInBits) - 2,\n        // thus 1 + lsb(any_long | pwMaxMask) <= 2^(registerValueInBits) -1.\n        final long substreamValue = (rawValue >>> log2m);\n        final byte p_w;\n\n        if(substreamValue == 0L) {\n            // The paper does not cover p(0x0), so the special value 0 is used.\n            // 0 is the original initialization value of the registers, so by\n            // doing this the multiset simply ignores it. This is acceptable\n            // because the probability is 1/(2^(2^registerSizeInBits)).\n            p_w = 0;\n        } else {\n            p_w = (byte)(1 + BitUtil.leastSignificantBit(substreamValue| pwMaxMask));\n        }\n\n        // Short-circuit if the register is being set to zero, since algorithmically\n        // this corresponds to an \"unset\" register, and \"unset\" registers aren't\n        // stored to save memory. (The very reason this sparse implementation\n        // exists.) If a register is set to zero it will break the #algorithmCardinality\n        // code.\n        if(p_w == 0) {\n            return;\n        }\n\n        // NOTE:  no +1 as in paper since 0-based indexing\n        final int j = (int)(rawValue & mBitsMask);\n\n        final byte currentValue;\n        if (sparseProbabilisticStorage.containsKey(j)) {\n          currentValue = sparseProbabilisticStorage.lget();\n        } else {\n          currentValue = 0;\n        }\n\n        if(p_w > currentValue) {\n            sparseProbabilisticStorage.put(j, p_w);\n        }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1fcee2c3acd9aa64a73a3b441b3f6cb492af0b87","date":1440409984,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/hll/HLL#addRawSparseProbabilistic(long).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/hll/HLL#addRawSparseProbabilistic(long).mjava","sourceNew":"    // ------------------------------------------------------------------------\n    // #addRaw(..) helpers\n    /**\n     * Adds the raw value to the {@link #sparseProbabilisticStorage}.\n     * {@link #type} must be {@link HLLType#SPARSE}.\n     *\n     * @param rawValue the raw value to add to the sparse storage.\n     */\n    private void addRawSparseProbabilistic(final long rawValue) {\n        // p(w): position of the least significant set bit (one-indexed)\n        // By contract: p(w) <= 2^(registerValueInBits) - 1 (the max register value)\n        //\n        // By construction of pwMaxMask (see #Constructor()),\n        //      lsb(pwMaxMask) = 2^(registerValueInBits) - 2,\n        // thus lsb(any_long | pwMaxMask) <= 2^(registerValueInBits) - 2,\n        // thus 1 + lsb(any_long | pwMaxMask) <= 2^(registerValueInBits) -1.\n        final long substreamValue = (rawValue >>> log2m);\n        final byte p_w;\n\n        if(substreamValue == 0L) {\n            // The paper does not cover p(0x0), so the special value 0 is used.\n            // 0 is the original initialization value of the registers, so by\n            // doing this the multiset simply ignores it. This is acceptable\n            // because the probability is 1/(2^(2^registerSizeInBits)).\n            p_w = 0;\n        } else {\n            p_w = (byte)(1 + BitUtil.leastSignificantBit(substreamValue| pwMaxMask));\n        }\n\n        // Short-circuit if the register is being set to zero, since algorithmically\n        // this corresponds to an \"unset\" register, and \"unset\" registers aren't\n        // stored to save memory. (The very reason this sparse implementation\n        // exists.) If a register is set to zero it will break the #algorithmCardinality\n        // code.\n        if(p_w == 0) {\n            return;\n        }\n\n        // NOTE:  no +1 as in paper since 0-based indexing\n        final int j = (int)(rawValue & mBitsMask);\n\n        final byte currentValue;\n        final int index = sparseProbabilisticStorage.indexOf(j);\n        if (index >= 0) {\n          currentValue = sparseProbabilisticStorage.indexGet(index);\n        } else {\n          currentValue = 0;\n        }\n\n        if(p_w > currentValue) {\n            sparseProbabilisticStorage.put(j, p_w);\n        }\n    }\n\n","sourceOld":"    // ------------------------------------------------------------------------\n    // #addRaw(..) helpers\n    /**\n     * Adds the raw value to the {@link #sparseProbabilisticStorage}.\n     * {@link #type} must be {@link HLLType#SPARSE}.\n     *\n     * @param rawValue the raw value to add to the sparse storage.\n     */\n    private void addRawSparseProbabilistic(final long rawValue) {\n        // p(w): position of the least significant set bit (one-indexed)\n        // By contract: p(w) <= 2^(registerValueInBits) - 1 (the max register value)\n        //\n        // By construction of pwMaxMask (see #Constructor()),\n        //      lsb(pwMaxMask) = 2^(registerValueInBits) - 2,\n        // thus lsb(any_long | pwMaxMask) <= 2^(registerValueInBits) - 2,\n        // thus 1 + lsb(any_long | pwMaxMask) <= 2^(registerValueInBits) -1.\n        final long substreamValue = (rawValue >>> log2m);\n        final byte p_w;\n\n        if(substreamValue == 0L) {\n            // The paper does not cover p(0x0), so the special value 0 is used.\n            // 0 is the original initialization value of the registers, so by\n            // doing this the multiset simply ignores it. This is acceptable\n            // because the probability is 1/(2^(2^registerSizeInBits)).\n            p_w = 0;\n        } else {\n            p_w = (byte)(1 + BitUtil.leastSignificantBit(substreamValue| pwMaxMask));\n        }\n\n        // Short-circuit if the register is being set to zero, since algorithmically\n        // this corresponds to an \"unset\" register, and \"unset\" registers aren't\n        // stored to save memory. (The very reason this sparse implementation\n        // exists.) If a register is set to zero it will break the #algorithmCardinality\n        // code.\n        if(p_w == 0) {\n            return;\n        }\n\n        // NOTE:  no +1 as in paper since 0-based indexing\n        final int j = (int)(rawValue & mBitsMask);\n\n        final byte currentValue;\n        if (sparseProbabilisticStorage.containsKey(j)) {\n          currentValue = sparseProbabilisticStorage.lget();\n        } else {\n          currentValue = 0;\n        }\n\n        if(p_w > currentValue) {\n            sparseProbabilisticStorage.put(j, p_w);\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3b5ee4c66244bdfcc4796a114519d47701b2c026":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6d8714f9ceaaff94f0968d1c2d037978c3fde569"],"1fcee2c3acd9aa64a73a3b441b3f6cb492af0b87":["3b5ee4c66244bdfcc4796a114519d47701b2c026"],"6d8714f9ceaaff94f0968d1c2d037978c3fde569":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1fcee2c3acd9aa64a73a3b441b3f6cb492af0b87"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3b5ee4c66244bdfcc4796a114519d47701b2c026","6d8714f9ceaaff94f0968d1c2d037978c3fde569"],"3b5ee4c66244bdfcc4796a114519d47701b2c026":["1fcee2c3acd9aa64a73a3b441b3f6cb492af0b87"],"6d8714f9ceaaff94f0968d1c2d037978c3fde569":["3b5ee4c66244bdfcc4796a114519d47701b2c026"],"1fcee2c3acd9aa64a73a3b441b3f6cb492af0b87":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}