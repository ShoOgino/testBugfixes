{"path":"solr/core/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","pathOld":"solr/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","sourceNew":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ZERO_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random.nextBoolean();\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        int randomPercentage = random.nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\"\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","sourceOld":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ZERO_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random.nextBoolean();\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        int randomPercentage = random.nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\"\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","pathOld":"solr/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","sourceNew":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ZERO_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random.nextBoolean();\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        int randomPercentage = random.nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\"\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","sourceOld":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ZERO_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random.nextBoolean();\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        int randomPercentage = random.nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\"\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","pathOld":"solr/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","sourceNew":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ZERO_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random.nextBoolean();\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        int randomPercentage = random.nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\"\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","sourceOld":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ZERO_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random.nextBoolean();\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        int randomPercentage = random.nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\"\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3738f7d06920ae25ab2884f4efd80c42e95d6271","date":1312707753,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","sourceNew":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ONE_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList<Grp>(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random.nextBoolean();\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        boolean truncateGroups = random.nextBoolean();\n        Map<String, Integer> facetCounts = new TreeMap<String, Integer>();\n        if (truncateGroups) {\n          for (Grp grp : sortedGroups) {\n            Doc doc = grp.docs.get(0);\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            String key = doc.getFirstValue(FOO_STRING_FIELD).toString();\n            boolean exists = facetCounts.containsKey(key);\n            int count = exists ? facetCounts.get(key) : 0;\n            facetCounts.put(key, ++count);\n          }\n        } else {\n          for (Doc doc : model.values()) {\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            for (Comparable field : doc.getValues(FOO_STRING_FIELD)) {\n              String key = field.toString();\n              boolean exists = facetCounts.containsKey(key);\n              int count = exists ? facetCounts.get(key) : 0;\n              facetCounts.put(key, ++count);\n            }\n          }\n        }\n        List<Comparable> expectedFacetResponse = new ArrayList<Comparable>();\n        for (Map.Entry<String, Integer> stringIntegerEntry : facetCounts.entrySet()) {\n          expectedFacetResponse.add(stringIntegerEntry.getKey());\n          expectedFacetResponse.add(stringIntegerEntry.getValue());\n        }\n\n        int randomPercentage = random.nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr == null || groupSortStr == sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\",\n            \"facet\", \"true\", \"facet.sort\", \"index\", \"facet.limit\", \"-1\", \"facet.field\", FOO_STRING_FIELD,\n            GroupParams.GROUP_TRUNCATE, truncateGroups ? \"true\" : \"false\", \"facet.mincount\", \"1\", \"facet.method\", \"fcs\" // to avoid FC insanity\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\" + groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n\n        // assert post / pre grouping facets\n        err = JSONTestUtil.matchObj(\"/facet_counts/facet_fields/\"+FOO_STRING_FIELD, realResponse, expectedFacetResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(expectedFacetResponse)\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          h.query(req);\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","sourceOld":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ZERO_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random.nextBoolean();\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        int randomPercentage = random.nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr==null || groupSortStr==sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\"\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\"+groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8be580b58bcc650d428f3f22de81cadcf51d650a","date":1325279655,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","sourceNew":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=atLeast(10);  // make >0 to enable test\n    int queryIter=atLeast(50);\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ONE_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList<Grp>(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random.nextBoolean();\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        boolean truncateGroups = random.nextBoolean();\n        Map<String, Integer> facetCounts = new TreeMap<String, Integer>();\n        if (truncateGroups) {\n          for (Grp grp : sortedGroups) {\n            Doc doc = grp.docs.get(0);\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            String key = doc.getFirstValue(FOO_STRING_FIELD).toString();\n            boolean exists = facetCounts.containsKey(key);\n            int count = exists ? facetCounts.get(key) : 0;\n            facetCounts.put(key, ++count);\n          }\n        } else {\n          for (Doc doc : model.values()) {\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            for (Comparable field : doc.getValues(FOO_STRING_FIELD)) {\n              String key = field.toString();\n              boolean exists = facetCounts.containsKey(key);\n              int count = exists ? facetCounts.get(key) : 0;\n              facetCounts.put(key, ++count);\n            }\n          }\n        }\n        List<Comparable> expectedFacetResponse = new ArrayList<Comparable>();\n        for (Map.Entry<String, Integer> stringIntegerEntry : facetCounts.entrySet()) {\n          expectedFacetResponse.add(stringIntegerEntry.getKey());\n          expectedFacetResponse.add(stringIntegerEntry.getValue());\n        }\n\n        int randomPercentage = random.nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr == null || groupSortStr == sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\",\n            \"facet\", \"true\", \"facet.sort\", \"index\", \"facet.limit\", \"-1\", \"facet.field\", FOO_STRING_FIELD,\n            GroupParams.GROUP_TRUNCATE, truncateGroups ? \"true\" : \"false\", \"facet.mincount\", \"1\", \"facet.method\", \"fcs\" // to avoid FC insanity\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\" + groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n\n        // assert post / pre grouping facets\n        err = JSONTestUtil.matchObj(\"/facet_counts/facet_fields/\"+FOO_STRING_FIELD, realResponse, expectedFacetResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(expectedFacetResponse)\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          h.query(req);\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","sourceOld":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=50 * RANDOM_MULTIPLIER;  // make >0 to enable test\n    int queryIter=100 * RANDOM_MULTIPLIER;\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ONE_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList<Grp>(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random.nextBoolean();\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        boolean truncateGroups = random.nextBoolean();\n        Map<String, Integer> facetCounts = new TreeMap<String, Integer>();\n        if (truncateGroups) {\n          for (Grp grp : sortedGroups) {\n            Doc doc = grp.docs.get(0);\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            String key = doc.getFirstValue(FOO_STRING_FIELD).toString();\n            boolean exists = facetCounts.containsKey(key);\n            int count = exists ? facetCounts.get(key) : 0;\n            facetCounts.put(key, ++count);\n          }\n        } else {\n          for (Doc doc : model.values()) {\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            for (Comparable field : doc.getValues(FOO_STRING_FIELD)) {\n              String key = field.toString();\n              boolean exists = facetCounts.containsKey(key);\n              int count = exists ? facetCounts.get(key) : 0;\n              facetCounts.put(key, ++count);\n            }\n          }\n        }\n        List<Comparable> expectedFacetResponse = new ArrayList<Comparable>();\n        for (Map.Entry<String, Integer> stringIntegerEntry : facetCounts.entrySet()) {\n          expectedFacetResponse.add(stringIntegerEntry.getKey());\n          expectedFacetResponse.add(stringIntegerEntry.getValue());\n        }\n\n        int randomPercentage = random.nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr == null || groupSortStr == sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\",\n            \"facet\", \"true\", \"facet.sort\", \"index\", \"facet.limit\", \"-1\", \"facet.field\", FOO_STRING_FIELD,\n            GroupParams.GROUP_TRUNCATE, truncateGroups ? \"true\" : \"false\", \"facet.mincount\", \"1\", \"facet.method\", \"fcs\" // to avoid FC insanity\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\" + groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n\n        // assert post / pre grouping facets\n        err = JSONTestUtil.matchObj(\"/facet_counts/facet_fields/\"+FOO_STRING_FIELD, realResponse, expectedFacetResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(expectedFacetResponse)\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          h.query(req);\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","sourceNew":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=atLeast(10);  // make >0 to enable test\n    int queryIter=atLeast(50);\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random().nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ONE_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random().nextInt(types.size())).fname;\n\n        int rows = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;\n        int start = random().nextInt(5)==0 ? random().nextInt(model.size()+2) : random().nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;    \n        int group_offset = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random().nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList<Grp>(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random().nextBoolean();\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        boolean truncateGroups = random().nextBoolean();\n        Map<String, Integer> facetCounts = new TreeMap<String, Integer>();\n        if (truncateGroups) {\n          for (Grp grp : sortedGroups) {\n            Doc doc = grp.docs.get(0);\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            String key = doc.getFirstValue(FOO_STRING_FIELD).toString();\n            boolean exists = facetCounts.containsKey(key);\n            int count = exists ? facetCounts.get(key) : 0;\n            facetCounts.put(key, ++count);\n          }\n        } else {\n          for (Doc doc : model.values()) {\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            for (Comparable field : doc.getValues(FOO_STRING_FIELD)) {\n              String key = field.toString();\n              boolean exists = facetCounts.containsKey(key);\n              int count = exists ? facetCounts.get(key) : 0;\n              facetCounts.put(key, ++count);\n            }\n          }\n        }\n        List<Comparable> expectedFacetResponse = new ArrayList<Comparable>();\n        for (Map.Entry<String, Integer> stringIntegerEntry : facetCounts.entrySet()) {\n          expectedFacetResponse.add(stringIntegerEntry.getKey());\n          expectedFacetResponse.add(stringIntegerEntry.getValue());\n        }\n\n        int randomPercentage = random().nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr == null || groupSortStr == sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\",\n            \"facet\", \"true\", \"facet.sort\", \"index\", \"facet.limit\", \"-1\", \"facet.field\", FOO_STRING_FIELD,\n            GroupParams.GROUP_TRUNCATE, truncateGroups ? \"true\" : \"false\", \"facet.mincount\", \"1\", \"facet.method\", \"fcs\" // to avoid FC insanity\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\" + groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n\n        // assert post / pre grouping facets\n        err = JSONTestUtil.matchObj(\"/facet_counts/facet_fields/\"+FOO_STRING_FIELD, realResponse, expectedFacetResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(expectedFacetResponse)\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          h.query(req);\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","sourceOld":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=atLeast(10);  // make >0 to enable test\n    int queryIter=atLeast(50);\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random.nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ONE_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random.nextInt(types.size())).fname;\n\n        int rows = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;\n        int start = random.nextInt(5)==0 ? random.nextInt(model.size()+2) : random.nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(11)-1;    \n        int group_offset = random.nextInt(10)==0 ? random.nextInt(model.size()+2) : random.nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random.nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList<Grp>(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random.nextBoolean();\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        boolean truncateGroups = random.nextBoolean();\n        Map<String, Integer> facetCounts = new TreeMap<String, Integer>();\n        if (truncateGroups) {\n          for (Grp grp : sortedGroups) {\n            Doc doc = grp.docs.get(0);\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            String key = doc.getFirstValue(FOO_STRING_FIELD).toString();\n            boolean exists = facetCounts.containsKey(key);\n            int count = exists ? facetCounts.get(key) : 0;\n            facetCounts.put(key, ++count);\n          }\n        } else {\n          for (Doc doc : model.values()) {\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            for (Comparable field : doc.getValues(FOO_STRING_FIELD)) {\n              String key = field.toString();\n              boolean exists = facetCounts.containsKey(key);\n              int count = exists ? facetCounts.get(key) : 0;\n              facetCounts.put(key, ++count);\n            }\n          }\n        }\n        List<Comparable> expectedFacetResponse = new ArrayList<Comparable>();\n        for (Map.Entry<String, Integer> stringIntegerEntry : facetCounts.entrySet()) {\n          expectedFacetResponse.add(stringIntegerEntry.getKey());\n          expectedFacetResponse.add(stringIntegerEntry.getValue());\n        }\n\n        int randomPercentage = random.nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr == null || groupSortStr == sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\",\n            \"facet\", \"true\", \"facet.sort\", \"index\", \"facet.limit\", \"-1\", \"facet.field\", FOO_STRING_FIELD,\n            GroupParams.GROUP_TRUNCATE, truncateGroups ? \"true\" : \"false\", \"facet.mincount\", \"1\", \"facet.method\", \"fcs\" // to avoid FC insanity\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\" + groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n\n        // assert post / pre grouping facets\n        err = JSONTestUtil.matchObj(\"/facet_counts/facet_fields/\"+FOO_STRING_FIELD, realResponse, expectedFacetResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(expectedFacetResponse)\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          h.query(req);\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"08970e5b8411182a29412c177eff67ec1110095b","date":1366640815,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","sourceNew":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=atLeast(10);  // make >0 to enable test\n    int queryIter=atLeast(50);\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random().nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ONE_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random().nextInt(types.size())).fname;\n\n        int rows = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;\n        int start = random().nextInt(5)==0 ? random().nextInt(model.size()+2) : random().nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;    \n        int group_offset = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(2); // pick a small start normally for better coverage\n\n        IndexSchema schema = h.getCore().getLatestSchema();\n        \n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(schema, types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random().nextBoolean() ? sortComparator : createSort(schema, types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList<Grp>(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random().nextBoolean();\n        Object modelResponse = buildGroupedResult(schema, sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        boolean truncateGroups = random().nextBoolean();\n        Map<String, Integer> facetCounts = new TreeMap<String, Integer>();\n        if (truncateGroups) {\n          for (Grp grp : sortedGroups) {\n            Doc doc = grp.docs.get(0);\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            String key = doc.getFirstValue(FOO_STRING_FIELD).toString();\n            boolean exists = facetCounts.containsKey(key);\n            int count = exists ? facetCounts.get(key) : 0;\n            facetCounts.put(key, ++count);\n          }\n        } else {\n          for (Doc doc : model.values()) {\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            for (Comparable field : doc.getValues(FOO_STRING_FIELD)) {\n              String key = field.toString();\n              boolean exists = facetCounts.containsKey(key);\n              int count = exists ? facetCounts.get(key) : 0;\n              facetCounts.put(key, ++count);\n            }\n          }\n        }\n        List<Comparable> expectedFacetResponse = new ArrayList<Comparable>();\n        for (Map.Entry<String, Integer> stringIntegerEntry : facetCounts.entrySet()) {\n          expectedFacetResponse.add(stringIntegerEntry.getKey());\n          expectedFacetResponse.add(stringIntegerEntry.getValue());\n        }\n\n        int randomPercentage = random().nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr == null || groupSortStr == sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\",\n            \"facet\", \"true\", \"facet.sort\", \"index\", \"facet.limit\", \"-1\", \"facet.field\", FOO_STRING_FIELD,\n            GroupParams.GROUP_TRUNCATE, truncateGroups ? \"true\" : \"false\", \"facet.mincount\", \"1\", \"facet.method\", \"fcs\" // to avoid FC insanity\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\" + groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n\n        // assert post / pre grouping facets\n        err = JSONTestUtil.matchObj(\"/facet_counts/facet_fields/\"+FOO_STRING_FIELD, realResponse, expectedFacetResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(expectedFacetResponse)\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          h.query(req);\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","sourceOld":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=atLeast(10);  // make >0 to enable test\n    int queryIter=atLeast(50);\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random().nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ONE_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random().nextInt(types.size())).fname;\n\n        int rows = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;\n        int start = random().nextInt(5)==0 ? random().nextInt(model.size()+2) : random().nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;    \n        int group_offset = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(2); // pick a small start normally for better coverage\n\n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(h.getCore().getSchema(), types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random().nextBoolean() ? sortComparator : createSort(h.getCore().getSchema(), types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList<Grp>(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random().nextBoolean();\n        Object modelResponse = buildGroupedResult(h.getCore().getSchema(), sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        boolean truncateGroups = random().nextBoolean();\n        Map<String, Integer> facetCounts = new TreeMap<String, Integer>();\n        if (truncateGroups) {\n          for (Grp grp : sortedGroups) {\n            Doc doc = grp.docs.get(0);\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            String key = doc.getFirstValue(FOO_STRING_FIELD).toString();\n            boolean exists = facetCounts.containsKey(key);\n            int count = exists ? facetCounts.get(key) : 0;\n            facetCounts.put(key, ++count);\n          }\n        } else {\n          for (Doc doc : model.values()) {\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            for (Comparable field : doc.getValues(FOO_STRING_FIELD)) {\n              String key = field.toString();\n              boolean exists = facetCounts.containsKey(key);\n              int count = exists ? facetCounts.get(key) : 0;\n              facetCounts.put(key, ++count);\n            }\n          }\n        }\n        List<Comparable> expectedFacetResponse = new ArrayList<Comparable>();\n        for (Map.Entry<String, Integer> stringIntegerEntry : facetCounts.entrySet()) {\n          expectedFacetResponse.add(stringIntegerEntry.getKey());\n          expectedFacetResponse.add(stringIntegerEntry.getValue());\n        }\n\n        int randomPercentage = random().nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr == null || groupSortStr == sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\",\n            \"facet\", \"true\", \"facet.sort\", \"index\", \"facet.limit\", \"-1\", \"facet.field\", FOO_STRING_FIELD,\n            GroupParams.GROUP_TRUNCATE, truncateGroups ? \"true\" : \"false\", \"facet.mincount\", \"1\", \"facet.method\", \"fcs\" // to avoid FC insanity\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\" + groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n\n        // assert post / pre grouping facets\n        err = JSONTestUtil.matchObj(\"/facet_counts/facet_fields/\"+FOO_STRING_FIELD, realResponse, expectedFacetResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(expectedFacetResponse)\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          h.query(req);\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","sourceNew":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=atLeast(10);  // make >0 to enable test\n    int queryIter=atLeast(50);\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random().nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ONE_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random().nextInt(types.size())).fname;\n\n        int rows = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;\n        int start = random().nextInt(5)==0 ? random().nextInt(model.size()+2) : random().nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;    \n        int group_offset = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(2); // pick a small start normally for better coverage\n\n        IndexSchema schema = h.getCore().getLatestSchema();\n        \n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(schema, types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random().nextBoolean() ? sortComparator : createSort(schema, types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList<>(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random().nextBoolean();\n        Object modelResponse = buildGroupedResult(schema, sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        boolean truncateGroups = random().nextBoolean();\n        Map<String, Integer> facetCounts = new TreeMap<>();\n        if (truncateGroups) {\n          for (Grp grp : sortedGroups) {\n            Doc doc = grp.docs.get(0);\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            String key = doc.getFirstValue(FOO_STRING_FIELD).toString();\n            boolean exists = facetCounts.containsKey(key);\n            int count = exists ? facetCounts.get(key) : 0;\n            facetCounts.put(key, ++count);\n          }\n        } else {\n          for (Doc doc : model.values()) {\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            for (Comparable field : doc.getValues(FOO_STRING_FIELD)) {\n              String key = field.toString();\n              boolean exists = facetCounts.containsKey(key);\n              int count = exists ? facetCounts.get(key) : 0;\n              facetCounts.put(key, ++count);\n            }\n          }\n        }\n        List<Comparable> expectedFacetResponse = new ArrayList<>();\n        for (Map.Entry<String, Integer> stringIntegerEntry : facetCounts.entrySet()) {\n          expectedFacetResponse.add(stringIntegerEntry.getKey());\n          expectedFacetResponse.add(stringIntegerEntry.getValue());\n        }\n\n        int randomPercentage = random().nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr == null || groupSortStr == sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\",\n            \"facet\", \"true\", \"facet.sort\", \"index\", \"facet.limit\", \"-1\", \"facet.field\", FOO_STRING_FIELD,\n            GroupParams.GROUP_TRUNCATE, truncateGroups ? \"true\" : \"false\", \"facet.mincount\", \"1\", \"facet.method\", \"fcs\" // to avoid FC insanity\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\" + groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n\n        // assert post / pre grouping facets\n        err = JSONTestUtil.matchObj(\"/facet_counts/facet_fields/\"+FOO_STRING_FIELD, realResponse, expectedFacetResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(expectedFacetResponse)\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          h.query(req);\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","sourceOld":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=atLeast(10);  // make >0 to enable test\n    int queryIter=atLeast(50);\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random().nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<FldType>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ONE_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random().nextInt(types.size())).fname;\n\n        int rows = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;\n        int start = random().nextInt(5)==0 ? random().nextInt(model.size()+2) : random().nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;    \n        int group_offset = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(2); // pick a small start normally for better coverage\n\n        IndexSchema schema = h.getCore().getLatestSchema();\n        \n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(schema, types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random().nextBoolean() ? sortComparator : createSort(schema, types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList<Grp>(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random().nextBoolean();\n        Object modelResponse = buildGroupedResult(schema, sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        boolean truncateGroups = random().nextBoolean();\n        Map<String, Integer> facetCounts = new TreeMap<String, Integer>();\n        if (truncateGroups) {\n          for (Grp grp : sortedGroups) {\n            Doc doc = grp.docs.get(0);\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            String key = doc.getFirstValue(FOO_STRING_FIELD).toString();\n            boolean exists = facetCounts.containsKey(key);\n            int count = exists ? facetCounts.get(key) : 0;\n            facetCounts.put(key, ++count);\n          }\n        } else {\n          for (Doc doc : model.values()) {\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            for (Comparable field : doc.getValues(FOO_STRING_FIELD)) {\n              String key = field.toString();\n              boolean exists = facetCounts.containsKey(key);\n              int count = exists ? facetCounts.get(key) : 0;\n              facetCounts.put(key, ++count);\n            }\n          }\n        }\n        List<Comparable> expectedFacetResponse = new ArrayList<Comparable>();\n        for (Map.Entry<String, Integer> stringIntegerEntry : facetCounts.entrySet()) {\n          expectedFacetResponse.add(stringIntegerEntry.getKey());\n          expectedFacetResponse.add(stringIntegerEntry.getValue());\n        }\n\n        int randomPercentage = random().nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr == null || groupSortStr == sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\",\n            \"facet\", \"true\", \"facet.sort\", \"index\", \"facet.limit\", \"-1\", \"facet.field\", FOO_STRING_FIELD,\n            GroupParams.GROUP_TRUNCATE, truncateGroups ? \"true\" : \"false\", \"facet.mincount\", \"1\", \"facet.method\", \"fcs\" // to avoid FC insanity\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\" + groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n\n        // assert post / pre grouping facets\n        err = JSONTestUtil.matchObj(\"/facet_counts/facet_fields/\"+FOO_STRING_FIELD, realResponse, expectedFacetResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(expectedFacetResponse)\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          h.query(req);\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7ae958a739da1866696f442384393ba2f13e33e5","date":1491819018,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","sourceNew":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=atLeast(10);  // make >0 to enable test\n    int queryIter=atLeast(50);\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random().nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ONE_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random().nextInt(types.size())).fname;\n\n        int rows = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;\n        int start = random().nextInt(5)==0 ? random().nextInt(model.size()+2) : random().nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;    \n        int group_offset = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(2); // pick a small start normally for better coverage\n\n        IndexSchema schema = h.getCore().getLatestSchema();\n        \n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(schema, types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random().nextBoolean() ? sortComparator : createSort(schema, types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList<>(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random().nextBoolean();\n        Object modelResponse = buildGroupedResult(schema, sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        boolean truncateGroups = random().nextBoolean();\n        Map<String, Integer> facetCounts = new TreeMap<>();\n        if (truncateGroups) {\n          for (Grp grp : sortedGroups) {\n            Doc doc = grp.docs.get(0);\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            String key = doc.getFirstValue(FOO_STRING_FIELD).toString();\n            boolean exists = facetCounts.containsKey(key);\n            int count = exists ? facetCounts.get(key) : 0;\n            facetCounts.put(key, ++count);\n          }\n        } else {\n          for (Doc doc : model.values()) {\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            for (Comparable field : doc.getValues(FOO_STRING_FIELD)) {\n              String key = field.toString();\n              boolean exists = facetCounts.containsKey(key);\n              int count = exists ? facetCounts.get(key) : 0;\n              facetCounts.put(key, ++count);\n            }\n          }\n        }\n        List<Comparable> expectedFacetResponse = new ArrayList<>();\n        for (Map.Entry<String, Integer> stringIntegerEntry : facetCounts.entrySet()) {\n          expectedFacetResponse.add(stringIntegerEntry.getKey());\n          expectedFacetResponse.add(stringIntegerEntry.getValue());\n        }\n\n        int randomPercentage = random().nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr == null || groupSortStr == sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\",\n            \"facet\", \"true\", \"facet.sort\", \"index\", \"facet.limit\", \"-1\", \"facet.field\", FOO_STRING_FIELD,\n            GroupParams.GROUP_TRUNCATE, truncateGroups ? \"true\" : \"false\", \"facet.mincount\", \"1\", \"facet.method\", \"fcs\" // to avoid FC insanity\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\" + groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH (\" + queryIter + \"): \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n\n        // assert post / pre grouping facets\n        err = JSONTestUtil.matchObj(\"/facet_counts/facet_fields/\"+FOO_STRING_FIELD, realResponse, expectedFacetResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH (\" + queryIter + \"): \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(expectedFacetResponse)\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          h.query(req);\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","sourceOld":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=atLeast(10);  // make >0 to enable test\n    int queryIter=atLeast(50);\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random().nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ONE_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random().nextInt(types.size())).fname;\n\n        int rows = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;\n        int start = random().nextInt(5)==0 ? random().nextInt(model.size()+2) : random().nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;    \n        int group_offset = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(2); // pick a small start normally for better coverage\n\n        IndexSchema schema = h.getCore().getLatestSchema();\n        \n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(schema, types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random().nextBoolean() ? sortComparator : createSort(schema, types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList<>(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random().nextBoolean();\n        Object modelResponse = buildGroupedResult(schema, sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        boolean truncateGroups = random().nextBoolean();\n        Map<String, Integer> facetCounts = new TreeMap<>();\n        if (truncateGroups) {\n          for (Grp grp : sortedGroups) {\n            Doc doc = grp.docs.get(0);\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            String key = doc.getFirstValue(FOO_STRING_FIELD).toString();\n            boolean exists = facetCounts.containsKey(key);\n            int count = exists ? facetCounts.get(key) : 0;\n            facetCounts.put(key, ++count);\n          }\n        } else {\n          for (Doc doc : model.values()) {\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            for (Comparable field : doc.getValues(FOO_STRING_FIELD)) {\n              String key = field.toString();\n              boolean exists = facetCounts.containsKey(key);\n              int count = exists ? facetCounts.get(key) : 0;\n              facetCounts.put(key, ++count);\n            }\n          }\n        }\n        List<Comparable> expectedFacetResponse = new ArrayList<>();\n        for (Map.Entry<String, Integer> stringIntegerEntry : facetCounts.entrySet()) {\n          expectedFacetResponse.add(stringIntegerEntry.getKey());\n          expectedFacetResponse.add(stringIntegerEntry.getValue());\n        }\n\n        int randomPercentage = random().nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr == null || groupSortStr == sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\",\n            \"facet\", \"true\", \"facet.sort\", \"index\", \"facet.limit\", \"-1\", \"facet.field\", FOO_STRING_FIELD,\n            GroupParams.GROUP_TRUNCATE, truncateGroups ? \"true\" : \"false\", \"facet.mincount\", \"1\", \"facet.method\", \"fcs\" // to avoid FC insanity\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\" + groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n\n        // assert post / pre grouping facets\n        err = JSONTestUtil.matchObj(\"/facet_counts/facet_fields/\"+FOO_STRING_FIELD, realResponse, expectedFacetResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(expectedFacetResponse)\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          h.query(req);\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","sourceNew":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=atLeast(10);  // make >0 to enable test\n    int queryIter=atLeast(50);\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random().nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ONE_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random().nextInt(types.size())).fname;\n\n        int rows = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;\n        int start = random().nextInt(5)==0 ? random().nextInt(model.size()+2) : random().nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;    \n        int group_offset = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(2); // pick a small start normally for better coverage\n\n        IndexSchema schema = h.getCore().getLatestSchema();\n        \n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(schema, types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random().nextBoolean() ? sortComparator : createSort(schema, types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList<>(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random().nextBoolean();\n        Object modelResponse = buildGroupedResult(schema, sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        boolean truncateGroups = random().nextBoolean();\n        Map<String, Integer> facetCounts = new TreeMap<>();\n        if (truncateGroups) {\n          for (Grp grp : sortedGroups) {\n            Doc doc = grp.docs.get(0);\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            String key = doc.getFirstValue(FOO_STRING_FIELD).toString();\n            boolean exists = facetCounts.containsKey(key);\n            int count = exists ? facetCounts.get(key) : 0;\n            facetCounts.put(key, ++count);\n          }\n        } else {\n          for (Doc doc : model.values()) {\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            for (Comparable field : doc.getValues(FOO_STRING_FIELD)) {\n              String key = field.toString();\n              boolean exists = facetCounts.containsKey(key);\n              int count = exists ? facetCounts.get(key) : 0;\n              facetCounts.put(key, ++count);\n            }\n          }\n        }\n        List<Comparable> expectedFacetResponse = new ArrayList<>();\n        for (Map.Entry<String, Integer> stringIntegerEntry : facetCounts.entrySet()) {\n          expectedFacetResponse.add(stringIntegerEntry.getKey());\n          expectedFacetResponse.add(stringIntegerEntry.getValue());\n        }\n\n        int randomPercentage = random().nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr == null || groupSortStr == sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\",\n            \"facet\", \"true\", \"facet.sort\", \"index\", \"facet.limit\", \"-1\", \"facet.field\", FOO_STRING_FIELD,\n            GroupParams.GROUP_TRUNCATE, truncateGroups ? \"true\" : \"false\", \"facet.mincount\", \"1\", \"facet.method\", \"fcs\" // to avoid FC insanity\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\" + groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH (\" + queryIter + \"): \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n\n        // assert post / pre grouping facets\n        err = JSONTestUtil.matchObj(\"/facet_counts/facet_fields/\"+FOO_STRING_FIELD, realResponse, expectedFacetResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH (\" + queryIter + \"): \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(expectedFacetResponse)\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          h.query(req);\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","sourceOld":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=atLeast(10);  // make >0 to enable test\n    int queryIter=atLeast(50);\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random().nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ONE_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random().nextInt(types.size())).fname;\n\n        int rows = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;\n        int start = random().nextInt(5)==0 ? random().nextInt(model.size()+2) : random().nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;    \n        int group_offset = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(2); // pick a small start normally for better coverage\n\n        IndexSchema schema = h.getCore().getLatestSchema();\n        \n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(schema, types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random().nextBoolean() ? sortComparator : createSort(schema, types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList<>(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random().nextBoolean();\n        Object modelResponse = buildGroupedResult(schema, sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        boolean truncateGroups = random().nextBoolean();\n        Map<String, Integer> facetCounts = new TreeMap<>();\n        if (truncateGroups) {\n          for (Grp grp : sortedGroups) {\n            Doc doc = grp.docs.get(0);\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            String key = doc.getFirstValue(FOO_STRING_FIELD).toString();\n            boolean exists = facetCounts.containsKey(key);\n            int count = exists ? facetCounts.get(key) : 0;\n            facetCounts.put(key, ++count);\n          }\n        } else {\n          for (Doc doc : model.values()) {\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            for (Comparable field : doc.getValues(FOO_STRING_FIELD)) {\n              String key = field.toString();\n              boolean exists = facetCounts.containsKey(key);\n              int count = exists ? facetCounts.get(key) : 0;\n              facetCounts.put(key, ++count);\n            }\n          }\n        }\n        List<Comparable> expectedFacetResponse = new ArrayList<>();\n        for (Map.Entry<String, Integer> stringIntegerEntry : facetCounts.entrySet()) {\n          expectedFacetResponse.add(stringIntegerEntry.getKey());\n          expectedFacetResponse.add(stringIntegerEntry.getValue());\n        }\n\n        int randomPercentage = random().nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr == null || groupSortStr == sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\",\n            \"facet\", \"true\", \"facet.sort\", \"index\", \"facet.limit\", \"-1\", \"facet.field\", FOO_STRING_FIELD,\n            GroupParams.GROUP_TRUNCATE, truncateGroups ? \"true\" : \"false\", \"facet.mincount\", \"1\", \"facet.method\", \"fcs\" // to avoid FC insanity\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\" + groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n\n        // assert post / pre grouping facets\n        err = JSONTestUtil.matchObj(\"/facet_counts/facet_fields/\"+FOO_STRING_FIELD, realResponse, expectedFacetResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH: \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(expectedFacetResponse)\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          h.query(req);\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"286e1dbf267cac3961c3fc116b9069797ad7d1c2","date":1556472718,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","sourceNew":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=atLeast(10);  // make >0 to enable test\n    int queryIter=atLeast(50);\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random().nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ONE_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      // non-stored non-indexed docValue enabled fields\n      types.add(new FldType(\"score_ff\",ONE_ONE, new FVal(1,100)));\n      types.add(new FldType(\"foo_ii\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_DOCVAL_FIELD,ONE_ONE, new SVal('a','z',3,7)));\n      types.add(new FldType(\"foo_bdv\", ZERO_ONE, new BVal()));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random().nextInt(types.size())).fname;\n\n        int rows = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;\n        int start = random().nextInt(5)==0 ? random().nextInt(model.size()+2) : random().nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;    \n        int group_offset = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(2); // pick a small start normally for better coverage\n\n        IndexSchema schema = h.getCore().getLatestSchema();\n        \n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(schema, types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random().nextBoolean() ? sortComparator : createSort(schema, types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList<>(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random().nextBoolean();\n        Object modelResponse = buildGroupedResult(schema, sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        boolean truncateGroups = random().nextBoolean();\n        Map<String, Integer> facetCounts = new TreeMap<>();\n        if (truncateGroups) {\n          for (Grp grp : sortedGroups) {\n            Doc doc = grp.docs.get(0);\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            String key = doc.getFirstValue(FOO_STRING_FIELD).toString();\n            boolean exists = facetCounts.containsKey(key);\n            int count = exists ? facetCounts.get(key) : 0;\n            facetCounts.put(key, ++count);\n          }\n        } else {\n          for (Doc doc : model.values()) {\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            for (Comparable field : doc.getValues(FOO_STRING_FIELD)) {\n              String key = field.toString();\n              boolean exists = facetCounts.containsKey(key);\n              int count = exists ? facetCounts.get(key) : 0;\n              facetCounts.put(key, ++count);\n            }\n          }\n        }\n        List<Comparable> expectedFacetResponse = new ArrayList<>();\n        for (Map.Entry<String, Integer> stringIntegerEntry : facetCounts.entrySet()) {\n          expectedFacetResponse.add(stringIntegerEntry.getKey());\n          expectedFacetResponse.add(stringIntegerEntry.getValue());\n        }\n\n        int randomPercentage = random().nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr, \"fl\", \"*,score_ff,foo_ii,foo_bdv,\" + FOO_STRING_DOCVAL_FIELD // only docValued fields are not returned by default\n            ,(groupSortStr == null || groupSortStr == sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\",\n            \"facet\", \"true\", \"facet.sort\", \"index\", \"facet.limit\", \"-1\", \"facet.field\", FOO_STRING_FIELD,\n            GroupParams.GROUP_TRUNCATE, truncateGroups ? \"true\" : \"false\", \"facet.mincount\", \"1\", \"facet.method\", \"fcs\" // to avoid FC insanity\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\" + groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH (\" + queryIter + \"): \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n\n        // assert post / pre grouping facets\n        err = JSONTestUtil.matchObj(\"/facet_counts/facet_fields/\"+FOO_STRING_FIELD, realResponse, expectedFacetResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH (\" + queryIter + \"): \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(expectedFacetResponse)\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          h.query(req);\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","sourceOld":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=atLeast(10);  // make >0 to enable test\n    int queryIter=atLeast(50);\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random().nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ONE_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random().nextInt(types.size())).fname;\n\n        int rows = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;\n        int start = random().nextInt(5)==0 ? random().nextInt(model.size()+2) : random().nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;    \n        int group_offset = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(2); // pick a small start normally for better coverage\n\n        IndexSchema schema = h.getCore().getLatestSchema();\n        \n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(schema, types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random().nextBoolean() ? sortComparator : createSort(schema, types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList<>(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random().nextBoolean();\n        Object modelResponse = buildGroupedResult(schema, sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        boolean truncateGroups = random().nextBoolean();\n        Map<String, Integer> facetCounts = new TreeMap<>();\n        if (truncateGroups) {\n          for (Grp grp : sortedGroups) {\n            Doc doc = grp.docs.get(0);\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            String key = doc.getFirstValue(FOO_STRING_FIELD).toString();\n            boolean exists = facetCounts.containsKey(key);\n            int count = exists ? facetCounts.get(key) : 0;\n            facetCounts.put(key, ++count);\n          }\n        } else {\n          for (Doc doc : model.values()) {\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            for (Comparable field : doc.getValues(FOO_STRING_FIELD)) {\n              String key = field.toString();\n              boolean exists = facetCounts.containsKey(key);\n              int count = exists ? facetCounts.get(key) : 0;\n              facetCounts.put(key, ++count);\n            }\n          }\n        }\n        List<Comparable> expectedFacetResponse = new ArrayList<>();\n        for (Map.Entry<String, Integer> stringIntegerEntry : facetCounts.entrySet()) {\n          expectedFacetResponse.add(stringIntegerEntry.getKey());\n          expectedFacetResponse.add(stringIntegerEntry.getValue());\n        }\n\n        int randomPercentage = random().nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr\n            ,(groupSortStr == null || groupSortStr == sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\",\n            \"facet\", \"true\", \"facet.sort\", \"index\", \"facet.limit\", \"-1\", \"facet.field\", FOO_STRING_FIELD,\n            GroupParams.GROUP_TRUNCATE, truncateGroups ? \"true\" : \"false\", \"facet.mincount\", \"1\", \"facet.method\", \"fcs\" // to avoid FC insanity\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\" + groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH (\" + queryIter + \"): \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n\n        // assert post / pre grouping facets\n        err = JSONTestUtil.matchObj(\"/facet_counts/facet_fields/\"+FOO_STRING_FIELD, realResponse, expectedFacetResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH (\" + queryIter + \"): \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(expectedFacetResponse)\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          h.query(req);\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","bugFix":["61e52acc0f10ced3042a4d0257710497d5ccf4ad"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3714bcf66a68a1600e9dd11442fc1b33b62ef088","date":1556832005,"type":3,"author":"noble","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","sourceNew":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=atLeast(10);  // make >0 to enable test\n    int queryIter=atLeast(50);\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random().nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ONE_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      // non-stored non-indexed docValue enabled fields\n      types.add(new FldType(\"score_ff\",ONE_ONE, new FVal(1,100)));\n      types.add(new FldType(\"foo_ii\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_DOCVAL_FIELD,ONE_ONE, new SVal('a','z',3,7)));\n      types.add(new FldType(\"foo_bdv\", ZERO_ONE, new BVal()));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random().nextInt(types.size())).fname;\n\n        int rows = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;\n        int start = random().nextInt(5)==0 ? random().nextInt(model.size()+2) : random().nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;    \n        int group_offset = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(2); // pick a small start normally for better coverage\n\n        IndexSchema schema = h.getCore().getLatestSchema();\n        \n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(schema, types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random().nextBoolean() ? sortComparator : createSort(schema, types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList<>(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random().nextBoolean();\n        Object modelResponse = buildGroupedResult(schema, sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        boolean truncateGroups = random().nextBoolean();\n        Map<String, Integer> facetCounts = new TreeMap<>();\n        if (truncateGroups) {\n          for (Grp grp : sortedGroups) {\n            Doc doc = grp.docs.get(0);\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            String key = doc.getFirstValue(FOO_STRING_FIELD).toString();\n            boolean exists = facetCounts.containsKey(key);\n            int count = exists ? facetCounts.get(key) : 0;\n            facetCounts.put(key, ++count);\n          }\n        } else {\n          for (Doc doc : model.values()) {\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            for (Comparable field : doc.getValues(FOO_STRING_FIELD)) {\n              String key = field.toString();\n              boolean exists = facetCounts.containsKey(key);\n              int count = exists ? facetCounts.get(key) : 0;\n              facetCounts.put(key, ++count);\n            }\n          }\n        }\n        List<Comparable> expectedFacetResponse = new ArrayList<>();\n        for (Map.Entry<String, Integer> stringIntegerEntry : facetCounts.entrySet()) {\n          expectedFacetResponse.add(stringIntegerEntry.getKey());\n          expectedFacetResponse.add(stringIntegerEntry.getValue());\n        }\n\n        int randomPercentage = random().nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr, \"fl\", \"*,score_ff,foo_ii,foo_bdv,\" + FOO_STRING_DOCVAL_FIELD // only docValued fields are not returned by default\n            ,(groupSortStr == null || groupSortStr == sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\",\n            \"facet\", \"true\", \"facet.sort\", \"index\", \"facet.limit\", \"-1\", \"facet.field\", FOO_STRING_FIELD,\n            GroupParams.GROUP_TRUNCATE, truncateGroups ? \"true\" : \"false\", \"facet.mincount\", \"1\", \"facet.method\", \"fcs\" // to avoid FC insanity\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = Utils.fromJSONString(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\" + groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH (\" + queryIter + \"): \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ Utils.toJSONString(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n\n        // assert post / pre grouping facets\n        err = JSONTestUtil.matchObj(\"/facet_counts/facet_fields/\"+FOO_STRING_FIELD, realResponse, expectedFacetResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH (\" + queryIter + \"): \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ Utils.toJSONString(expectedFacetResponse)\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          h.query(req);\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","sourceOld":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=atLeast(10);  // make >0 to enable test\n    int queryIter=atLeast(50);\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random().nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ONE_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      // non-stored non-indexed docValue enabled fields\n      types.add(new FldType(\"score_ff\",ONE_ONE, new FVal(1,100)));\n      types.add(new FldType(\"foo_ii\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_DOCVAL_FIELD,ONE_ONE, new SVal('a','z',3,7)));\n      types.add(new FldType(\"foo_bdv\", ZERO_ONE, new BVal()));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random().nextInt(types.size())).fname;\n\n        int rows = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;\n        int start = random().nextInt(5)==0 ? random().nextInt(model.size()+2) : random().nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;    \n        int group_offset = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(2); // pick a small start normally for better coverage\n\n        IndexSchema schema = h.getCore().getLatestSchema();\n        \n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(schema, types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random().nextBoolean() ? sortComparator : createSort(schema, types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList<>(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random().nextBoolean();\n        Object modelResponse = buildGroupedResult(schema, sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        boolean truncateGroups = random().nextBoolean();\n        Map<String, Integer> facetCounts = new TreeMap<>();\n        if (truncateGroups) {\n          for (Grp grp : sortedGroups) {\n            Doc doc = grp.docs.get(0);\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            String key = doc.getFirstValue(FOO_STRING_FIELD).toString();\n            boolean exists = facetCounts.containsKey(key);\n            int count = exists ? facetCounts.get(key) : 0;\n            facetCounts.put(key, ++count);\n          }\n        } else {\n          for (Doc doc : model.values()) {\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            for (Comparable field : doc.getValues(FOO_STRING_FIELD)) {\n              String key = field.toString();\n              boolean exists = facetCounts.containsKey(key);\n              int count = exists ? facetCounts.get(key) : 0;\n              facetCounts.put(key, ++count);\n            }\n          }\n        }\n        List<Comparable> expectedFacetResponse = new ArrayList<>();\n        for (Map.Entry<String, Integer> stringIntegerEntry : facetCounts.entrySet()) {\n          expectedFacetResponse.add(stringIntegerEntry.getKey());\n          expectedFacetResponse.add(stringIntegerEntry.getValue());\n        }\n\n        int randomPercentage = random().nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr, \"fl\", \"*,score_ff,foo_ii,foo_bdv,\" + FOO_STRING_DOCVAL_FIELD // only docValued fields are not returned by default\n            ,(groupSortStr == null || groupSortStr == sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\",\n            \"facet\", \"true\", \"facet.sort\", \"index\", \"facet.limit\", \"-1\", \"facet.field\", FOO_STRING_FIELD,\n            GroupParams.GROUP_TRUNCATE, truncateGroups ? \"true\" : \"false\", \"facet.mincount\", \"1\", \"facet.method\", \"fcs\" // to avoid FC insanity\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = ObjectBuilder.fromJSON(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\" + groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH (\" + queryIter + \"): \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n\n        // assert post / pre grouping facets\n        err = JSONTestUtil.matchObj(\"/facet_counts/facet_fields/\"+FOO_STRING_FIELD, realResponse, expectedFacetResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH (\" + queryIter + \"): \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ JSONUtil.toJSON(expectedFacetResponse)\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          h.query(req);\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","sourceNew":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=atLeast(10);  // make >0 to enable test\n    int queryIter=atLeast(50);\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random().nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ONE_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      // non-stored non-indexed docValue enabled fields\n      types.add(new FldType(\"score_ff\",ONE_ONE, new FVal(1,100)));\n      types.add(new FldType(\"foo_ii\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_DOCVAL_FIELD,ONE_ONE, new SVal('a','z',3,7)));\n      types.add(new FldType(\"foo_bdv\", ZERO_ONE, new BVal()));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random().nextInt(types.size())).fname;\n\n        int rows = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;\n        int start = random().nextInt(5)==0 ? random().nextInt(model.size()+2) : random().nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;    \n        int group_offset = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(2); // pick a small start normally for better coverage\n\n        IndexSchema schema = h.getCore().getLatestSchema();\n        \n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(schema, types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random().nextBoolean() ? sortComparator : createSort(schema, types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList<>(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random().nextBoolean();\n        Object modelResponse = buildGroupedResult(schema, sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        boolean truncateGroups = random().nextBoolean();\n        Map<String, Integer> facetCounts = new TreeMap<>();\n        if (truncateGroups) {\n          for (Grp grp : sortedGroups) {\n            Doc doc = grp.docs.get(0);\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            String key = doc.getFirstValue(FOO_STRING_FIELD).toString();\n            boolean exists = facetCounts.containsKey(key);\n            int count = exists ? facetCounts.get(key) : 0;\n            facetCounts.put(key, ++count);\n          }\n        } else {\n          for (Doc doc : model.values()) {\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            for (Comparable field : doc.getValues(FOO_STRING_FIELD)) {\n              String key = field.toString();\n              boolean exists = facetCounts.containsKey(key);\n              int count = exists ? facetCounts.get(key) : 0;\n              facetCounts.put(key, ++count);\n            }\n          }\n        }\n        List<Comparable> expectedFacetResponse = new ArrayList<>();\n        for (Map.Entry<String, Integer> stringIntegerEntry : facetCounts.entrySet()) {\n          expectedFacetResponse.add(stringIntegerEntry.getKey());\n          expectedFacetResponse.add(stringIntegerEntry.getValue());\n        }\n\n        int randomPercentage = random().nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr, \"fl\", \"*,score_ff,foo_ii,foo_bdv,\" + FOO_STRING_DOCVAL_FIELD // only docValued fields are not returned by default\n            ,(groupSortStr == null || groupSortStr == sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\",\n            \"facet\", \"true\", \"facet.sort\", \"index\", \"facet.limit\", \"-1\", \"facet.field\", FOO_STRING_FIELD,\n            GroupParams.GROUP_TRUNCATE, truncateGroups ? \"true\" : \"false\", \"facet.mincount\", \"1\", \"facet.method\", \"fcs\" // to avoid FC insanity\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = Utils.fromJSONString(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\" + groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH ({}}): {}\\n\\trequest={}\\n\\tresult={}\\n\\texpected={}\\n\\tsorted_model={}\"\n              , queryIter, err, req, strResponse, Utils.toJSONString(modelResponse), sortedGroups);\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n\n        // assert post / pre grouping facets\n        err = JSONTestUtil.matchObj(\"/facet_counts/facet_fields/\"+FOO_STRING_FIELD, realResponse, expectedFacetResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH ({}): {}\\n\\trequest={}\\n\\tresult={}\\n\\texpected={}\"\n              , queryIter, err, req, strResponse, Utils.toJSONString(expectedFacetResponse));\n          // re-execute the request... good for putting a breakpoint here for debugging\n          h.query(req);\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","sourceOld":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=atLeast(10);  // make >0 to enable test\n    int queryIter=atLeast(50);\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random().nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ONE_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      // non-stored non-indexed docValue enabled fields\n      types.add(new FldType(\"score_ff\",ONE_ONE, new FVal(1,100)));\n      types.add(new FldType(\"foo_ii\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_DOCVAL_FIELD,ONE_ONE, new SVal('a','z',3,7)));\n      types.add(new FldType(\"foo_bdv\", ZERO_ONE, new BVal()));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random().nextInt(types.size())).fname;\n\n        int rows = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;\n        int start = random().nextInt(5)==0 ? random().nextInt(model.size()+2) : random().nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;    \n        int group_offset = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(2); // pick a small start normally for better coverage\n\n        IndexSchema schema = h.getCore().getLatestSchema();\n        \n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(schema, types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random().nextBoolean() ? sortComparator : createSort(schema, types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList<>(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random().nextBoolean();\n        Object modelResponse = buildGroupedResult(schema, sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        boolean truncateGroups = random().nextBoolean();\n        Map<String, Integer> facetCounts = new TreeMap<>();\n        if (truncateGroups) {\n          for (Grp grp : sortedGroups) {\n            Doc doc = grp.docs.get(0);\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            String key = doc.getFirstValue(FOO_STRING_FIELD).toString();\n            boolean exists = facetCounts.containsKey(key);\n            int count = exists ? facetCounts.get(key) : 0;\n            facetCounts.put(key, ++count);\n          }\n        } else {\n          for (Doc doc : model.values()) {\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            for (Comparable field : doc.getValues(FOO_STRING_FIELD)) {\n              String key = field.toString();\n              boolean exists = facetCounts.containsKey(key);\n              int count = exists ? facetCounts.get(key) : 0;\n              facetCounts.put(key, ++count);\n            }\n          }\n        }\n        List<Comparable> expectedFacetResponse = new ArrayList<>();\n        for (Map.Entry<String, Integer> stringIntegerEntry : facetCounts.entrySet()) {\n          expectedFacetResponse.add(stringIntegerEntry.getKey());\n          expectedFacetResponse.add(stringIntegerEntry.getValue());\n        }\n\n        int randomPercentage = random().nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr, \"fl\", \"*,score_ff,foo_ii,foo_bdv,\" + FOO_STRING_DOCVAL_FIELD // only docValued fields are not returned by default\n            ,(groupSortStr == null || groupSortStr == sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\",\n            \"facet\", \"true\", \"facet.sort\", \"index\", \"facet.limit\", \"-1\", \"facet.field\", FOO_STRING_FIELD,\n            GroupParams.GROUP_TRUNCATE, truncateGroups ? \"true\" : \"false\", \"facet.mincount\", \"1\", \"facet.method\", \"fcs\" // to avoid FC insanity\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = Utils.fromJSONString(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\" + groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH (\" + queryIter + \"): \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ Utils.toJSONString(modelResponse)\n           + \"\\n\\tsorted_model=\"+ sortedGroups\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n\n        // assert post / pre grouping facets\n        err = JSONTestUtil.matchObj(\"/facet_counts/facet_fields/\"+FOO_STRING_FIELD, realResponse, expectedFacetResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH (\" + queryIter + \"): \" + err\n           + \"\\n\\trequest=\"+req\n           + \"\\n\\tresult=\"+strResponse\n           + \"\\n\\texpected=\"+ Utils.toJSONString(expectedFacetResponse)\n          );\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          h.query(req);\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa2585c33d5d66a1c837c312221eb55ddb3c4300","date":1592493170,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","pathOld":"solr/core/src/test/org/apache/solr/TestGroupingSearch#testRandomGrouping().mjava","sourceNew":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=atLeast(10);  // make >0 to enable test\n    int queryIter=atLeast(50);\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random().nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ONE_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      // non-stored non-indexed docValue enabled fields\n      types.add(new FldType(\"score_ff\",ONE_ONE, new FVal(1,100)));\n      types.add(new FldType(\"foo_ii\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_DOCVAL_FIELD,ONE_ONE, new SVal('a','z',3,7)));\n      types.add(new FldType(\"foo_bdv\", ZERO_ONE, new BVal()));\n\n      clearIndex();\n      @SuppressWarnings({\"rawtypes\"})\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random().nextInt(types.size())).fname;\n\n        int rows = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;\n        int start = random().nextInt(5)==0 ? random().nextInt(model.size()+2) : random().nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;    \n        int group_offset = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(2); // pick a small start normally for better coverage\n\n        IndexSchema schema = h.getCore().getLatestSchema();\n        \n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(schema, types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random().nextBoolean() ? sortComparator : createSort(schema, types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        @SuppressWarnings({\"rawtypes\"})\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList<>(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random().nextBoolean();\n        Object modelResponse = buildGroupedResult(schema, sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        boolean truncateGroups = random().nextBoolean();\n        Map<String, Integer> facetCounts = new TreeMap<>();\n        if (truncateGroups) {\n          for (Grp grp : sortedGroups) {\n            Doc doc = grp.docs.get(0);\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            String key = doc.getFirstValue(FOO_STRING_FIELD).toString();\n            boolean exists = facetCounts.containsKey(key);\n            int count = exists ? facetCounts.get(key) : 0;\n            facetCounts.put(key, ++count);\n          }\n        } else {\n          for (Doc doc : model.values()) {\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            for (@SuppressWarnings({\"rawtypes\"})Comparable field : doc.getValues(FOO_STRING_FIELD)) {\n              String key = field.toString();\n              boolean exists = facetCounts.containsKey(key);\n              int count = exists ? facetCounts.get(key) : 0;\n              facetCounts.put(key, ++count);\n            }\n          }\n        }\n        @SuppressWarnings({\"rawtypes\"})\n        List<Comparable> expectedFacetResponse = new ArrayList<>();\n        for (Map.Entry<String, Integer> stringIntegerEntry : facetCounts.entrySet()) {\n          expectedFacetResponse.add(stringIntegerEntry.getKey());\n          expectedFacetResponse.add(stringIntegerEntry.getValue());\n        }\n\n        int randomPercentage = random().nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr, \"fl\", \"*,score_ff,foo_ii,foo_bdv,\" + FOO_STRING_DOCVAL_FIELD // only docValued fields are not returned by default\n            ,(groupSortStr == null || groupSortStr == sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\",\n            \"facet\", \"true\", \"facet.sort\", \"index\", \"facet.limit\", \"-1\", \"facet.field\", FOO_STRING_FIELD,\n            GroupParams.GROUP_TRUNCATE, truncateGroups ? \"true\" : \"false\", \"facet.mincount\", \"1\", \"facet.method\", \"fcs\" // to avoid FC insanity\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = Utils.fromJSONString(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\" + groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH ({}}): {}\\n\\trequest={}\\n\\tresult={}\\n\\texpected={}\\n\\tsorted_model={}\"\n              , queryIter, err, req, strResponse, Utils.toJSONString(modelResponse), sortedGroups);\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n\n        // assert post / pre grouping facets\n        err = JSONTestUtil.matchObj(\"/facet_counts/facet_fields/\"+FOO_STRING_FIELD, realResponse, expectedFacetResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH ({}): {}\\n\\trequest={}\\n\\tresult={}\\n\\texpected={}\"\n              , queryIter, err, req, strResponse, Utils.toJSONString(expectedFacetResponse));\n          // re-execute the request... good for putting a breakpoint here for debugging\n          h.query(req);\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","sourceOld":"  @Test\n  public void testRandomGrouping() throws Exception {\n    /**\n     updateJ(\"{\\\"add\\\":{\\\"doc\\\":{\\\"id\\\":\\\"77\\\"}}}\", params(\"commit\",\"true\"));\n     assertJQ(req(\"q\",\"id:77\"), \"/response/numFound==1\");\n\n     Doc doc = createDocObj(types);\n     updateJ(toJSON(doc), params(\"commit\",\"true\"));\n\n     assertJQ(req(\"q\",\"id:\"+doc.id), \"/response/numFound==1\");\n    **/\n\n    int indexIter=atLeast(10);  // make >0 to enable test\n    int queryIter=atLeast(50);\n\n    while (--indexIter >= 0) {\n\n      int indexSize = random().nextInt(25 * RANDOM_MULTIPLIER);\n//indexSize=2;\n      List<FldType> types = new ArrayList<>();\n      types.add(new FldType(\"id\",ONE_ONE, new SVal('A','Z',4,4)));\n      types.add(new FldType(\"score_f\",ONE_ONE, new FVal(1,100)));  // field used to score\n      types.add(new FldType(\"foo_i\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_FIELD,ONE_ONE, new SVal('a','z',1,2)));\n      types.add(new FldType(SMALL_STRING_FIELD,ZERO_ONE, new SVal('a',(char)('c'+indexSize/10),1,1)));\n      types.add(new FldType(SMALL_INT_FIELD,ZERO_ONE, new IRange(0,5+indexSize/10)));\n\n      // non-stored non-indexed docValue enabled fields\n      types.add(new FldType(\"score_ff\",ONE_ONE, new FVal(1,100)));\n      types.add(new FldType(\"foo_ii\",ZERO_ONE, new IRange(0,indexSize)));\n      types.add(new FldType(FOO_STRING_DOCVAL_FIELD,ONE_ONE, new SVal('a','z',3,7)));\n      types.add(new FldType(\"foo_bdv\", ZERO_ONE, new BVal()));\n\n      clearIndex();\n      Map<Comparable, Doc> model = indexDocs(types, null, indexSize);\n      //System.out.println(\"############### model=\" + model);\n\n      // test with specific docs\n      if (false) {\n        clearIndex();\n        model.clear();\n        Doc d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 0;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 1;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 2;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"c\");\n        d1.getValues(SMALL_INT_FIELD).set(0,5);\n        d1.order = 3;\n        updateJ(toJSON(d1), params(\"commit\",\"false\"));\n        model.put(d1.id, d1);\n\n        d1 = createDoc(types);\n        d1.getValues(SMALL_STRING_FIELD).set(0,\"b\");\n        d1.getValues(SMALL_INT_FIELD).set(0,2);\n        d1.order = 4;\n        updateJ(toJSON(d1), params(\"commit\",\"true\"));\n        model.put(d1.id, d1);\n      }\n\n\n      for (int qiter=0; qiter<queryIter; qiter++) {\n        String groupField = types.get(random().nextInt(types.size())).fname;\n\n        int rows = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;\n        int start = random().nextInt(5)==0 ? random().nextInt(model.size()+2) : random().nextInt(5); // pick a small start normally for better coverage\n        int group_limit = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(11)-1;    \n        int group_offset = random().nextInt(10)==0 ? random().nextInt(model.size()+2) : random().nextInt(2); // pick a small start normally for better coverage\n\n        IndexSchema schema = h.getCore().getLatestSchema();\n        \n        String[] stringSortA = new String[1];\n        Comparator<Doc> sortComparator = createSort(schema, types, stringSortA);\n        String sortStr = stringSortA[0];\n        Comparator<Doc> groupComparator = random().nextBoolean() ? sortComparator : createSort(schema, types, stringSortA);\n        String groupSortStr = stringSortA[0];\n\n        // since groupSortStr defaults to sortStr, we need to normalize null to \"score desc\" if\n        // sortStr != null.\n        if (groupSortStr == null && groupSortStr != sortStr) {\n          groupSortStr = \"score desc\";\n        }\n        \n         // Test specific case\n        if (false) {\n          groupField=SMALL_INT_FIELD;\n          sortComparator=createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, true)));\n          sortStr = SMALL_STRING_FIELD + \" asc\";\n          groupComparator = createComparator(Arrays.asList(createComparator(SMALL_STRING_FIELD, true, true, false, false)));\n          groupSortStr = SMALL_STRING_FIELD + \" asc\";\n          rows=1; start=0; group_offset=1; group_limit=1;\n        }\n\n        Map<Comparable, Grp> groups = groupBy(model.values(), groupField);\n\n        // first sort the docs in each group\n        for (Grp grp : groups.values()) {\n          Collections.sort(grp.docs, groupComparator);\n        }\n\n        // now sort the groups\n\n        // if sort != group.sort, we need to find the max doc by \"sort\"\n        if (groupComparator != sortComparator) {\n          for (Grp grp : groups.values()) grp.setMaxDoc(sortComparator); \n        }\n\n        List<Grp> sortedGroups = new ArrayList<>(groups.values());\n        Collections.sort(sortedGroups,  groupComparator==sortComparator ? createFirstDocComparator(sortComparator) : createMaxDocComparator(sortComparator));\n\n        boolean includeNGroups = random().nextBoolean();\n        Object modelResponse = buildGroupedResult(schema, sortedGroups, start, rows, group_offset, group_limit, includeNGroups);\n\n        boolean truncateGroups = random().nextBoolean();\n        Map<String, Integer> facetCounts = new TreeMap<>();\n        if (truncateGroups) {\n          for (Grp grp : sortedGroups) {\n            Doc doc = grp.docs.get(0);\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            String key = doc.getFirstValue(FOO_STRING_FIELD).toString();\n            boolean exists = facetCounts.containsKey(key);\n            int count = exists ? facetCounts.get(key) : 0;\n            facetCounts.put(key, ++count);\n          }\n        } else {\n          for (Doc doc : model.values()) {\n            if (doc.getValues(FOO_STRING_FIELD) == null) {\n              continue;\n            }\n\n            for (Comparable field : doc.getValues(FOO_STRING_FIELD)) {\n              String key = field.toString();\n              boolean exists = facetCounts.containsKey(key);\n              int count = exists ? facetCounts.get(key) : 0;\n              facetCounts.put(key, ++count);\n            }\n          }\n        }\n        List<Comparable> expectedFacetResponse = new ArrayList<>();\n        for (Map.Entry<String, Integer> stringIntegerEntry : facetCounts.entrySet()) {\n          expectedFacetResponse.add(stringIntegerEntry.getKey());\n          expectedFacetResponse.add(stringIntegerEntry.getValue());\n        }\n\n        int randomPercentage = random().nextInt(101);\n        // TODO: create a random filter too\n        SolrQueryRequest req = req(\"group\",\"true\",\"wt\",\"json\",\"indent\",\"true\", \"echoParams\",\"all\", \"q\",\"{!func}score_f\", \"group.field\",groupField\n            ,sortStr==null ? \"nosort\":\"sort\", sortStr ==null ? \"\": sortStr, \"fl\", \"*,score_ff,foo_ii,foo_bdv,\" + FOO_STRING_DOCVAL_FIELD // only docValued fields are not returned by default\n            ,(groupSortStr == null || groupSortStr == sortStr) ? \"noGroupsort\":\"group.sort\", groupSortStr==null ? \"\": groupSortStr\n            ,\"rows\",\"\"+rows, \"start\",\"\"+start, \"group.offset\",\"\"+group_offset, \"group.limit\",\"\"+group_limit,\n            GroupParams.GROUP_CACHE_PERCENTAGE, Integer.toString(randomPercentage), GroupParams.GROUP_TOTAL_COUNT, includeNGroups ? \"true\" : \"false\",\n            \"facet\", \"true\", \"facet.sort\", \"index\", \"facet.limit\", \"-1\", \"facet.field\", FOO_STRING_FIELD,\n            GroupParams.GROUP_TRUNCATE, truncateGroups ? \"true\" : \"false\", \"facet.mincount\", \"1\", \"facet.method\", \"fcs\" // to avoid FC insanity\n        );\n\n        String strResponse = h.query(req);\n\n        Object realResponse = Utils.fromJSONString(strResponse);\n        String err = JSONTestUtil.matchObj(\"/grouped/\" + groupField, realResponse, modelResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH ({}}): {}\\n\\trequest={}\\n\\tresult={}\\n\\texpected={}\\n\\tsorted_model={}\"\n              , queryIter, err, req, strResponse, Utils.toJSONString(modelResponse), sortedGroups);\n\n          // re-execute the request... good for putting a breakpoint here for debugging\n          String rsp = h.query(req);\n\n          fail(err);\n        }\n\n        // assert post / pre grouping facets\n        err = JSONTestUtil.matchObj(\"/facet_counts/facet_fields/\"+FOO_STRING_FIELD, realResponse, expectedFacetResponse);\n        if (err != null) {\n          log.error(\"GROUPING MISMATCH ({}): {}\\n\\trequest={}\\n\\tresult={}\\n\\texpected={}\"\n              , queryIter, err, req, strResponse, Utils.toJSONString(expectedFacetResponse));\n          // re-execute the request... good for putting a breakpoint here for debugging\n          h.query(req);\n          fail(err);\n        }\n      } // end query iter\n    } // end index iter\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["08970e5b8411182a29412c177eff67ec1110095b"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"8be580b58bcc650d428f3f22de81cadcf51d650a":["3738f7d06920ae25ab2884f4efd80c42e95d6271"],"3714bcf66a68a1600e9dd11442fc1b33b62ef088":["286e1dbf267cac3961c3fc116b9069797ad7d1c2"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["3714bcf66a68a1600e9dd11442fc1b33b62ef088"],"08970e5b8411182a29412c177eff67ec1110095b":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"286e1dbf267cac3961c3fc116b9069797ad7d1c2":["7ae958a739da1866696f442384393ba2f13e33e5"],"3738f7d06920ae25ab2884f4efd80c42e95d6271":["c26f00b574427b55127e869b935845554afde1fa"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["8be580b58bcc650d428f3f22de81cadcf51d650a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"7ae958a739da1866696f442384393ba2f13e33e5":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":[],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","7ae958a739da1866696f442384393ba2f13e33e5"],"c26f00b574427b55127e869b935845554afde1fa":["3738f7d06920ae25ab2884f4efd80c42e95d6271"],"8be580b58bcc650d428f3f22de81cadcf51d650a":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"3714bcf66a68a1600e9dd11442fc1b33b62ef088":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"08970e5b8411182a29412c177eff67ec1110095b":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"286e1dbf267cac3961c3fc116b9069797ad7d1c2":["3714bcf66a68a1600e9dd11442fc1b33b62ef088"],"3738f7d06920ae25ab2884f4efd80c42e95d6271":["8be580b58bcc650d428f3f22de81cadcf51d650a"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["08970e5b8411182a29412c177eff67ec1110095b"],"7ae958a739da1866696f442384393ba2f13e33e5":["286e1dbf267cac3961c3fc116b9069797ad7d1c2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}