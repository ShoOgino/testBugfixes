{"path":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesReaderState#SortedSetDocValuesReaderState(IndexReader,String).mjava","commits":[{"id":"4edc984f0f4ac77c37e48ace2932f780f888453c","date":1388475218,"type":1,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesReaderState#SortedSetDocValuesReaderState(IndexReader,String).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/SortedSetDocValuesReaderState#SortedSetDocValuesReaderState(IndexReader,String).mjava","sourceNew":"  /** Creates this, pulling doc values from the specified\n   *  field. */\n  public SortedSetDocValuesReaderState(IndexReader reader, String field) throws IOException {\n\n    this.field = field;\n    this.origReader = reader;\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    topReader = SlowCompositeReaderWrapper.wrap(reader);\n    SortedSetDocValues dv = topReader.getSortedSetDocValues(field);\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n    BytesRef spare = new BytesRef();\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      dv.lookupOrd(ord, spare);\n      String[] components = FacetsConfig.stringToPath(spare.utf8ToString());\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + Arrays.toString(components) + \" \" + spare.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","sourceOld":"  /** Creates this, pulling doc values from the specified\n   *  field. */\n  public SortedSetDocValuesReaderState(IndexReader reader, String field) throws IOException {\n\n    this.field = field;\n    this.origReader = reader;\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    topReader = SlowCompositeReaderWrapper.wrap(reader);\n    SortedSetDocValues dv = topReader.getSortedSetDocValues(field);\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n    BytesRef spare = new BytesRef();\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      dv.lookupOrd(ord, spare);\n      String[] components = FacetsConfig.stringToPath(spare.utf8ToString());\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + Arrays.toString(components) + \" \" + spare.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesReaderState#SortedSetDocValuesReaderState(IndexReader,String).mjava","pathOld":"/dev/null","sourceNew":"  /** Creates this, pulling doc values from the specified\n   *  field. */\n  public SortedSetDocValuesReaderState(IndexReader reader, String field) throws IOException {\n\n    this.field = field;\n    this.origReader = reader;\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    topReader = SlowCompositeReaderWrapper.wrap(reader);\n    SortedSetDocValues dv = topReader.getSortedSetDocValues(field);\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n    BytesRef spare = new BytesRef();\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      dv.lookupOrd(ord, spare);\n      String[] components = FacetsConfig.stringToPath(spare.utf8ToString());\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + Arrays.toString(components) + \" \" + spare.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"30fc8c22124fdcf9d76449bd2fa04decbe74e2e2","date":1391685460,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/DefaultSortedSetDocValuesReaderState#DefaultSortedSetDocValuesReaderState(IndexReader,String).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesReaderState#SortedSetDocValuesReaderState(IndexReader,String).mjava","sourceNew":"  /** Creates this, pulling doc values from the specified\n   *  field. */\n  public DefaultSortedSetDocValuesReaderState(IndexReader reader, String field) throws IOException {\n    this.field = field;\n    this.origReader = reader;\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    topReader = SlowCompositeReaderWrapper.wrap(reader);\n    SortedSetDocValues dv = topReader.getSortedSetDocValues(field);\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n    BytesRef spare = new BytesRef();\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      dv.lookupOrd(ord, spare);\n      String[] components = FacetsConfig.stringToPath(spare.utf8ToString());\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + Arrays.toString(components) + \" \" + spare.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","sourceOld":"  /** Creates this, pulling doc values from the specified\n   *  field. */\n  public SortedSetDocValuesReaderState(IndexReader reader, String field) throws IOException {\n\n    this.field = field;\n    this.origReader = reader;\n\n    // We need this to create thread-safe MultiSortedSetDV\n    // per collector:\n    topReader = SlowCompositeReaderWrapper.wrap(reader);\n    SortedSetDocValues dv = topReader.getSortedSetDocValues(field);\n    if (dv == null) {\n      throw new IllegalArgumentException(\"field \\\"\" + field + \"\\\" was not indexed with SortedSetDocValues\");\n    }\n    if (dv.getValueCount() > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"can only handle valueCount < Integer.MAX_VALUE; got \" + dv.getValueCount());\n    }\n    valueCount = (int) dv.getValueCount();\n\n    // TODO: we can make this more efficient if eg we can be\n    // \"involved\" when OrdinalMap is being created?  Ie see\n    // each term/ord it's assigning as it goes...\n    String lastDim = null;\n    int startOrd = -1;\n    BytesRef spare = new BytesRef();\n\n    // TODO: this approach can work for full hierarchy?;\n    // TaxoReader can't do this since ords are not in\n    // \"sorted order\" ... but we should generalize this to\n    // support arbitrary hierarchy:\n    for(int ord=0;ord<valueCount;ord++) {\n      dv.lookupOrd(ord, spare);\n      String[] components = FacetsConfig.stringToPath(spare.utf8ToString());\n      if (components.length != 2) {\n        throw new IllegalArgumentException(\"this class can only handle 2 level hierarchy (dim/value); got: \" + Arrays.toString(components) + \" \" + spare.utf8ToString());\n      }\n      if (!components[0].equals(lastDim)) {\n        if (lastDim != null) {\n          prefixToOrdRange.put(lastDim, new OrdRange(startOrd, ord-1));\n        }\n        startOrd = ord;\n        lastDim = components[0];\n      }\n    }\n\n    if (lastDim != null) {\n      prefixToOrdRange.put(lastDim, new OrdRange(startOrd, valueCount-1));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4edc984f0f4ac77c37e48ace2932f780f888453c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"30fc8c22124fdcf9d76449bd2fa04decbe74e2e2":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4edc984f0f4ac77c37e48ace2932f780f888453c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["30fc8c22124fdcf9d76449bd2fa04decbe74e2e2"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4edc984f0f4ac77c37e48ace2932f780f888453c","3cc728b07df73b197e6d940d27f9b08b63918f13"],"4edc984f0f4ac77c37e48ace2932f780f888453c":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"30fc8c22124fdcf9d76449bd2fa04decbe74e2e2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["30fc8c22124fdcf9d76449bd2fa04decbe74e2e2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}