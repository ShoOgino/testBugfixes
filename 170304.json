{"path":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#AnalyzingSuggester(Analyzer,Analyzer,int,int,int).mjava","commits":[{"id":"6ce825e9276493231308229152c48f755ce1a0a5","date":1348871483,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#AnalyzingSuggester(Analyzer,Analyzer,int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Creates a new suggester.\n   * \n   * @param indexAnalyzer Analyzer that will be used for\n   *   analyzing suggestions while building the index.\n   * @param queryAnalyzer Analyzer that will be used for\n   *   analyzing query text during lookup\n   * @param options see {@link #EXACT_FIRST}, {@link #PRESERVE_SEP}\n   * @param maxSurfaceFormsPerAnalyzedForm Maximum number of\n   *   surface forms to keep for a single analyzed form.\n   *   When there are too many surface forms we discard the\n   *   lowest weighted ones.\n   * @param maxGraphExpansions Maximum number of graph paths\n   *   to expand from the analyzed form.  Set this to -1 for\n   *   no limit.\n   */\n  public AnalyzingSuggester(Analyzer indexAnalyzer, Analyzer queryAnalyzer, int options, int maxSurfaceFormsPerAnalyzedForm, int maxGraphExpansions) {\n    this.indexAnalyzer = indexAnalyzer;\n    this.queryAnalyzer = queryAnalyzer;\n    if ((options & ~(EXACT_FIRST | PRESERVE_SEP)) != 0) {\n      throw new IllegalArgumentException(\"options should only contain EXACT_FIRST and PRESERVE_SEP; got \" + options);\n    }\n    this.exactFirst = (options & EXACT_FIRST) != 0;\n    this.preserveSep = (options & PRESERVE_SEP) != 0;\n\n    // NOTE: this is just an implementation limitation; if\n    // somehow this is a problem we could fix it by using\n    // more than one byte to disambiguate ... but 256 seems\n    // like it should be way more then enough.\n    if (maxSurfaceFormsPerAnalyzedForm <= 0 || maxSurfaceFormsPerAnalyzedForm > 256) {\n      throw new IllegalArgumentException(\"maxSurfaceFormsPerAnalyzedForm must be > 0 and < 256 (got: \" + maxSurfaceFormsPerAnalyzedForm + \")\");\n    }\n    this.maxSurfaceFormsPerAnalyzedForm = maxSurfaceFormsPerAnalyzedForm;\n\n    if (maxGraphExpansions < 1 && maxGraphExpansions != -1) {\n      throw new IllegalArgumentException(\"maxGraphExpansions must -1 (no limit) or > 0 (got: \" + maxGraphExpansions + \")\");\n    }\n    this.maxGraphExpansions = maxGraphExpansions;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eafa8c5eabc3dacd34680054e6a33bda024080ac","date":1367691488,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#AnalyzingSuggester(Analyzer,Analyzer,int,int,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#AnalyzingSuggester(Analyzer,Analyzer,int,int,int).mjava","sourceNew":"  /**\n   * Creates a new suggester.\n   * \n   * @param indexAnalyzer Analyzer that will be used for\n   *   analyzing suggestions while building the index.\n   * @param queryAnalyzer Analyzer that will be used for\n   *   analyzing query text during lookup\n   * @param options see {@link #EXACT_FIRST}, {@link #PRESERVE_SEP}\n   * @param maxSurfaceFormsPerAnalyzedForm Maximum number of\n   *   surface forms to keep for a single analyzed form.\n   *   When there are too many surface forms we discard the\n   *   lowest weighted ones.\n   * @param maxGraphExpansions Maximum number of graph paths\n   *   to expand from the analyzed form.  Set this to -1 for\n   *   no limit.\n   */\n  public AnalyzingSuggester(Analyzer indexAnalyzer, Analyzer queryAnalyzer, int options, int maxSurfaceFormsPerAnalyzedForm, int maxGraphExpansions) {\n    this.indexAnalyzer = indexAnalyzer;\n    this.queryAnalyzer = queryAnalyzer;\n    if ((options & ~(EXACT_FIRST | PRESERVE_SEP)) != 0) {\n      throw new IllegalArgumentException(\"options should only contain EXACT_FIRST and PRESERVE_SEP; got \" + options);\n    }\n    this.exactFirst = (options & EXACT_FIRST) != 0;\n    this.preserveSep = (options & PRESERVE_SEP) != 0;\n\n    // NOTE: this is just an implementation limitation; if\n    // somehow this is a problem we could fix it by using\n    // more than one byte to disambiguate ... but 256 seems\n    // like it should be way more then enough.\n    if (maxSurfaceFormsPerAnalyzedForm <= 0 || maxSurfaceFormsPerAnalyzedForm > 256) {\n      throw new IllegalArgumentException(\"maxSurfaceFormsPerAnalyzedForm must be > 0 and < 256 (got: \" + maxSurfaceFormsPerAnalyzedForm + \")\");\n    }\n    this.maxSurfaceFormsPerAnalyzedForm = maxSurfaceFormsPerAnalyzedForm;\n\n    if (maxGraphExpansions < 1 && maxGraphExpansions != -1) {\n      throw new IllegalArgumentException(\"maxGraphExpansions must -1 (no limit) or > 0 (got: \" + maxGraphExpansions + \")\");\n    }\n    this.maxGraphExpansions = maxGraphExpansions;\n    preservePositionIncrements = true;\n  }\n\n","sourceOld":"  /**\n   * Creates a new suggester.\n   * \n   * @param indexAnalyzer Analyzer that will be used for\n   *   analyzing suggestions while building the index.\n   * @param queryAnalyzer Analyzer that will be used for\n   *   analyzing query text during lookup\n   * @param options see {@link #EXACT_FIRST}, {@link #PRESERVE_SEP}\n   * @param maxSurfaceFormsPerAnalyzedForm Maximum number of\n   *   surface forms to keep for a single analyzed form.\n   *   When there are too many surface forms we discard the\n   *   lowest weighted ones.\n   * @param maxGraphExpansions Maximum number of graph paths\n   *   to expand from the analyzed form.  Set this to -1 for\n   *   no limit.\n   */\n  public AnalyzingSuggester(Analyzer indexAnalyzer, Analyzer queryAnalyzer, int options, int maxSurfaceFormsPerAnalyzedForm, int maxGraphExpansions) {\n    this.indexAnalyzer = indexAnalyzer;\n    this.queryAnalyzer = queryAnalyzer;\n    if ((options & ~(EXACT_FIRST | PRESERVE_SEP)) != 0) {\n      throw new IllegalArgumentException(\"options should only contain EXACT_FIRST and PRESERVE_SEP; got \" + options);\n    }\n    this.exactFirst = (options & EXACT_FIRST) != 0;\n    this.preserveSep = (options & PRESERVE_SEP) != 0;\n\n    // NOTE: this is just an implementation limitation; if\n    // somehow this is a problem we could fix it by using\n    // more than one byte to disambiguate ... but 256 seems\n    // like it should be way more then enough.\n    if (maxSurfaceFormsPerAnalyzedForm <= 0 || maxSurfaceFormsPerAnalyzedForm > 256) {\n      throw new IllegalArgumentException(\"maxSurfaceFormsPerAnalyzedForm must be > 0 and < 256 (got: \" + maxSurfaceFormsPerAnalyzedForm + \")\");\n    }\n    this.maxSurfaceFormsPerAnalyzedForm = maxSurfaceFormsPerAnalyzedForm;\n\n    if (maxGraphExpansions < 1 && maxGraphExpansions != -1) {\n      throw new IllegalArgumentException(\"maxGraphExpansions must -1 (no limit) or > 0 (got: \" + maxGraphExpansions + \")\");\n    }\n    this.maxGraphExpansions = maxGraphExpansions;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4e0095ef720d1b8e7406847147af69f19af3ab6","date":1383131477,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#AnalyzingSuggester(Analyzer,Analyzer,int,int,int,boolean).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#AnalyzingSuggester(Analyzer,Analyzer,int,int,int).mjava","sourceNew":"  /**\n   * Creates a new suggester.\n   * \n   * @param indexAnalyzer Analyzer that will be used for\n   *   analyzing suggestions while building the index.\n   * @param queryAnalyzer Analyzer that will be used for\n   *   analyzing query text during lookup\n   * @param options see {@link #EXACT_FIRST}, {@link #PRESERVE_SEP}\n   * @param maxSurfaceFormsPerAnalyzedForm Maximum number of\n   *   surface forms to keep for a single analyzed form.\n   *   When there are too many surface forms we discard the\n   *   lowest weighted ones.\n   * @param maxGraphExpansions Maximum number of graph paths\n   *   to expand from the analyzed form.  Set this to -1 for\n   *   no limit.\n   * @param preservePositionIncrements Whether position holes\n   *   should appear in the automata\n   */\n  public AnalyzingSuggester(Analyzer indexAnalyzer, Analyzer queryAnalyzer, int options, int maxSurfaceFormsPerAnalyzedForm, int maxGraphExpansions,\n      boolean preservePositionIncrements) {\n    this.indexAnalyzer = indexAnalyzer;\n    this.queryAnalyzer = queryAnalyzer;\n    if ((options & ~(EXACT_FIRST | PRESERVE_SEP)) != 0) {\n      throw new IllegalArgumentException(\"options should only contain EXACT_FIRST and PRESERVE_SEP; got \" + options);\n    }\n    this.exactFirst = (options & EXACT_FIRST) != 0;\n    this.preserveSep = (options & PRESERVE_SEP) != 0;\n\n    // NOTE: this is just an implementation limitation; if\n    // somehow this is a problem we could fix it by using\n    // more than one byte to disambiguate ... but 256 seems\n    // like it should be way more then enough.\n    if (maxSurfaceFormsPerAnalyzedForm <= 0 || maxSurfaceFormsPerAnalyzedForm > 256) {\n      throw new IllegalArgumentException(\"maxSurfaceFormsPerAnalyzedForm must be > 0 and < 256 (got: \" + maxSurfaceFormsPerAnalyzedForm + \")\");\n    }\n    this.maxSurfaceFormsPerAnalyzedForm = maxSurfaceFormsPerAnalyzedForm;\n\n    if (maxGraphExpansions < 1 && maxGraphExpansions != -1) {\n      throw new IllegalArgumentException(\"maxGraphExpansions must -1 (no limit) or > 0 (got: \" + maxGraphExpansions + \")\");\n    }\n    this.maxGraphExpansions = maxGraphExpansions;\n    this.preservePositionIncrements = preservePositionIncrements;\n  }\n\n","sourceOld":"  /**\n   * Creates a new suggester.\n   * \n   * @param indexAnalyzer Analyzer that will be used for\n   *   analyzing suggestions while building the index.\n   * @param queryAnalyzer Analyzer that will be used for\n   *   analyzing query text during lookup\n   * @param options see {@link #EXACT_FIRST}, {@link #PRESERVE_SEP}\n   * @param maxSurfaceFormsPerAnalyzedForm Maximum number of\n   *   surface forms to keep for a single analyzed form.\n   *   When there are too many surface forms we discard the\n   *   lowest weighted ones.\n   * @param maxGraphExpansions Maximum number of graph paths\n   *   to expand from the analyzed form.  Set this to -1 for\n   *   no limit.\n   */\n  public AnalyzingSuggester(Analyzer indexAnalyzer, Analyzer queryAnalyzer, int options, int maxSurfaceFormsPerAnalyzedForm, int maxGraphExpansions) {\n    this.indexAnalyzer = indexAnalyzer;\n    this.queryAnalyzer = queryAnalyzer;\n    if ((options & ~(EXACT_FIRST | PRESERVE_SEP)) != 0) {\n      throw new IllegalArgumentException(\"options should only contain EXACT_FIRST and PRESERVE_SEP; got \" + options);\n    }\n    this.exactFirst = (options & EXACT_FIRST) != 0;\n    this.preserveSep = (options & PRESERVE_SEP) != 0;\n\n    // NOTE: this is just an implementation limitation; if\n    // somehow this is a problem we could fix it by using\n    // more than one byte to disambiguate ... but 256 seems\n    // like it should be way more then enough.\n    if (maxSurfaceFormsPerAnalyzedForm <= 0 || maxSurfaceFormsPerAnalyzedForm > 256) {\n      throw new IllegalArgumentException(\"maxSurfaceFormsPerAnalyzedForm must be > 0 and < 256 (got: \" + maxSurfaceFormsPerAnalyzedForm + \")\");\n    }\n    this.maxSurfaceFormsPerAnalyzedForm = maxSurfaceFormsPerAnalyzedForm;\n\n    if (maxGraphExpansions < 1 && maxGraphExpansions != -1) {\n      throw new IllegalArgumentException(\"maxGraphExpansions must -1 (no limit) or > 0 (got: \" + maxGraphExpansions + \")\");\n    }\n    this.maxGraphExpansions = maxGraphExpansions;\n    preservePositionIncrements = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"eafa8c5eabc3dacd34680054e6a33bda024080ac":["6ce825e9276493231308229152c48f755ce1a0a5"],"6ce825e9276493231308229152c48f755ce1a0a5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d4e0095ef720d1b8e7406847147af69f19af3ab6":["eafa8c5eabc3dacd34680054e6a33bda024080ac"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d4e0095ef720d1b8e7406847147af69f19af3ab6"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6ce825e9276493231308229152c48f755ce1a0a5"],"eafa8c5eabc3dacd34680054e6a33bda024080ac":["d4e0095ef720d1b8e7406847147af69f19af3ab6"],"6ce825e9276493231308229152c48f755ce1a0a5":["eafa8c5eabc3dacd34680054e6a33bda024080ac"],"d4e0095ef720d1b8e7406847147af69f19af3ab6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}