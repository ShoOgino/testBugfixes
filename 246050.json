{"path":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","commits":[{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","pathOld":"/dev/null","sourceNew":"  public void testNumericFields() throws Exception {\n    for(int i=0;i<oldNames.length;i++) {\n      // only test indexes >= 3.0\n      if (oldNames[i].compareTo(\"30.\") < 0) continue;\n      \n      unzip(getDataFile(\"index.\" + oldNames[i] + \".zip\"), oldNames[i]);\n      String fullPath = fullDir(oldNames[i]);\n      Directory dir = FSDirectory.open(new File(fullPath));\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(searcher.getIndexReader(), \"trieInt\");\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(searcher.getIndexReader(), \"trieLong\");\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      searcher.close();\n      dir.close();\n      rmDir(oldNames[i]);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["9274621789ce990dbfef455dabdf026bb3184821","d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6267e1ce56c2eec111425690cd04e251b6f14952","date":1275222352,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","sourceNew":"  public void testNumericFields() throws Exception {\n    for(int i=0;i<oldNames.length;i++) {\n      \n      unzip(getDataFile(\"index.\" + oldNames[i] + \".zip\"), oldNames[i]);\n      String fullPath = fullDir(oldNames[i]);\n      Directory dir = FSDirectory.open(new File(fullPath));\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(searcher.getIndexReader(), \"trieInt\");\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(searcher.getIndexReader(), \"trieLong\");\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      searcher.close();\n      dir.close();\n      rmDir(oldNames[i]);\n    }\n  }\n\n","sourceOld":"  public void testNumericFields() throws Exception {\n    for(int i=0;i<oldNames.length;i++) {\n      // only test indexes >= 3.0\n      if (oldNames[i].compareTo(\"30.\") < 0) continue;\n      \n      unzip(getDataFile(\"index.\" + oldNames[i] + \".zip\"), oldNames[i]);\n      String fullPath = fullDir(oldNames[i]);\n      Directory dir = FSDirectory.open(new File(fullPath));\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(searcher.getIndexReader(), \"trieInt\");\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(searcher.getIndexReader(), \"trieLong\");\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      searcher.close();\n      dir.close();\n      rmDir(oldNames[i]);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a13a126d15299d5c1e117ea99ddae6fb0fa3f209","date":1291909583,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","sourceNew":"  public void testNumericFields() throws Exception {\n    for(int i=0;i<oldNames.length;i++) {\n      \n      unzip(getDataFile(\"index.\" + oldNames[i] + \".zip\"), oldNames[i]);\n      String fullPath = fullDir(oldNames[i]);\n      Directory dir = newFSDirectory(new File(fullPath));\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(searcher.getIndexReader(), \"trieInt\");\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(searcher.getIndexReader(), \"trieLong\");\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      searcher.close();\n      dir.close();\n      rmDir(oldNames[i]);\n    }\n  }\n\n","sourceOld":"  public void testNumericFields() throws Exception {\n    for(int i=0;i<oldNames.length;i++) {\n      \n      unzip(getDataFile(\"index.\" + oldNames[i] + \".zip\"), oldNames[i]);\n      String fullPath = fullDir(oldNames[i]);\n      Directory dir = FSDirectory.open(new File(fullPath));\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(searcher.getIndexReader(), \"trieInt\");\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(searcher.getIndexReader(), \"trieLong\");\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      searcher.close();\n      dir.close();\n      rmDir(oldNames[i]);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ab5cb6a74aefb78aa0569857970b9151dfe2e787","date":1292842407,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","sourceNew":"  public void testNumericFields() throws Exception {\n    for(int i=0;i<oldNames.length;i++) {\n      \n      unzip(getDataFile(\"index.\" + oldNames[i] + \".zip\"), oldNames[i]);\n      String fullPath = fullDir(oldNames[i]);\n      Directory dir = newFSDirectory(new File(fullPath));\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(searcher.getIndexReader(), \"trieInt\");\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(searcher.getIndexReader(), \"trieLong\");\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      searcher.close();\n      dir.close();\n      rmDir(oldNames[i]);\n    }\n  }\n\n","sourceOld":"  public void testNumericFields() throws Exception {\n    for(int i=0;i<oldNames.length;i++) {\n      \n      unzip(getDataFile(\"index.\" + oldNames[i] + \".zip\"), oldNames[i]);\n      String fullPath = fullDir(oldNames[i]);\n      Directory dir = FSDirectory.open(new File(fullPath));\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(searcher.getIndexReader(), \"trieInt\");\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(searcher.getIndexReader(), \"trieLong\");\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      searcher.close();\n      dir.close();\n      rmDir(oldNames[i]);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","sourceNew":"  public void testNumericFields() throws Exception {\n    for(int i=0;i<oldNames.length;i++) {\n      \n      unzip(getDataFile(\"index.\" + oldNames[i] + \".zip\"), oldNames[i]);\n      String fullPath = fullDir(oldNames[i]);\n      Directory dir = newFSDirectory(new File(fullPath));\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(searcher.getIndexReader(), \"trieInt\");\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(searcher.getIndexReader(), \"trieLong\");\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      searcher.close();\n      dir.close();\n      rmDir(oldNames[i]);\n    }\n  }\n\n","sourceOld":"  public void testNumericFields() throws Exception {\n    for(int i=0;i<oldNames.length;i++) {\n      \n      unzip(getDataFile(\"index.\" + oldNames[i] + \".zip\"), oldNames[i]);\n      String fullPath = fullDir(oldNames[i]);\n      Directory dir = FSDirectory.open(new File(fullPath));\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(searcher.getIndexReader(), \"trieInt\");\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(searcher.getIndexReader(), \"trieLong\");\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      searcher.close();\n      dir.close();\n      rmDir(oldNames[i]);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cdad2c6b6234338031bcc1f24c001a5ad66f714","date":1296866109,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","sourceNew":"  public void testNumericFields() throws Exception {\n    for(int i=0;i<oldNames.length;i++) {\n      \n      File oldIndexDir = _TestUtil.getTempDir(oldNames[i]);\n      _TestUtil.unzip(getDataFile(\"index.\" + oldNames[i] + \".zip\"), oldIndexDir);\n      Directory dir = newFSDirectory(oldIndexDir);\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(searcher.getIndexReader(), \"trieInt\");\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(searcher.getIndexReader(), \"trieLong\");\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      searcher.close();\n      dir.close();\n      _TestUtil.rmDir(oldIndexDir);\n    }\n  }\n\n","sourceOld":"  public void testNumericFields() throws Exception {\n    for(int i=0;i<oldNames.length;i++) {\n      \n      unzip(getDataFile(\"index.\" + oldNames[i] + \".zip\"), oldNames[i]);\n      String fullPath = fullDir(oldNames[i]);\n      Directory dir = newFSDirectory(new File(fullPath));\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(searcher.getIndexReader(), \"trieInt\");\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(searcher.getIndexReader(), \"trieLong\");\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      searcher.close();\n      dir.close();\n      rmDir(oldNames[i]);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","sourceNew":"  public void testNumericFields() throws Exception {\n    for(int i=0;i<oldNames.length;i++) {\n      \n      File oldIndexDir = _TestUtil.getTempDir(oldNames[i]);\n      _TestUtil.unzip(getDataFile(\"index.\" + oldNames[i] + \".zip\"), oldIndexDir);\n      Directory dir = newFSDirectory(oldIndexDir);\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(searcher.getIndexReader(), \"trieInt\");\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(searcher.getIndexReader(), \"trieLong\");\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      searcher.close();\n      dir.close();\n      _TestUtil.rmDir(oldIndexDir);\n    }\n  }\n\n","sourceOld":"  public void testNumericFields() throws Exception {\n    for(int i=0;i<oldNames.length;i++) {\n      \n      unzip(getDataFile(\"index.\" + oldNames[i] + \".zip\"), oldNames[i]);\n      String fullPath = fullDir(oldNames[i]);\n      Directory dir = newFSDirectory(new File(fullPath));\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(searcher.getIndexReader(), \"trieInt\");\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(searcher.getIndexReader(), \"trieLong\");\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      searcher.close();\n      dir.close();\n      rmDir(oldNames[i]);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","sourceNew":"  public void testNumericFields() throws Exception {\n    for(int i=0;i<oldNames.length;i++) {\n      \n      File oldIndexDir = _TestUtil.getTempDir(oldNames[i]);\n      _TestUtil.unzip(getDataFile(\"index.\" + oldNames[i] + \".zip\"), oldIndexDir);\n      Directory dir = newFSDirectory(oldIndexDir);\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(searcher.getIndexReader(), \"trieInt\");\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(searcher.getIndexReader(), \"trieLong\");\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      searcher.close();\n      dir.close();\n      _TestUtil.rmDir(oldIndexDir);\n    }\n  }\n\n","sourceOld":"  public void testNumericFields() throws Exception {\n    for(int i=0;i<oldNames.length;i++) {\n      \n      unzip(getDataFile(\"index.\" + oldNames[i] + \".zip\"), oldNames[i]);\n      String fullPath = fullDir(oldNames[i]);\n      Directory dir = newFSDirectory(new File(fullPath));\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(searcher.getIndexReader(), \"trieInt\");\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(searcher.getIndexReader(), \"trieLong\");\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      searcher.close();\n      dir.close();\n      rmDir(oldNames[i]);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"382fe3a6ca9745891afebda9b9a57cc158305545","date":1320952430,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","sourceNew":"  public void testNumericFields() throws Exception {\n    for(int i=0;i<oldNames.length;i++) {\n      \n      File oldIndexDir = _TestUtil.getTempDir(oldNames[i]);\n      _TestUtil.unzip(getDataFile(\"index.\" + oldNames[i] + \".zip\"), oldIndexDir);\n      Directory dir = newFSDirectory(oldIndexDir);\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(searcher.getIndexReader(), \"trieInt\", false);\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(searcher.getIndexReader(), \"trieLong\", false);\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      searcher.close();\n      dir.close();\n      _TestUtil.rmDir(oldIndexDir);\n    }\n  }\n\n","sourceOld":"  public void testNumericFields() throws Exception {\n    for(int i=0;i<oldNames.length;i++) {\n      \n      File oldIndexDir = _TestUtil.getTempDir(oldNames[i]);\n      _TestUtil.unzip(getDataFile(\"index.\" + oldNames[i] + \".zip\"), oldIndexDir);\n      Directory dir = newFSDirectory(oldIndexDir);\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(searcher.getIndexReader(), \"trieInt\");\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(searcher.getIndexReader(), \"trieLong\");\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      searcher.close();\n      dir.close();\n      _TestUtil.rmDir(oldIndexDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3a0403b45dfe384fae4a1b6e96c3265d000c498","date":1321445981,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","sourceNew":"  public void testNumericFields() throws Exception {\n    for(int i=0;i<oldNames.length;i++) {\n      \n      File oldIndexDir = _TestUtil.getTempDir(oldNames[i]);\n      _TestUtil.unzip(getDataFile(\"index.\" + oldNames[i] + \".zip\"), oldIndexDir);\n      Directory dir = newFSDirectory(oldIndexDir);\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(searcher.getIndexReader(), \"trieInt\", false);\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(searcher.getIndexReader(), \"trieLong\", false);\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      searcher.close();\n      reader.close();\n      dir.close();\n      _TestUtil.rmDir(oldIndexDir);\n    }\n  }\n\n","sourceOld":"  public void testNumericFields() throws Exception {\n    for(int i=0;i<oldNames.length;i++) {\n      \n      File oldIndexDir = _TestUtil.getTempDir(oldNames[i]);\n      _TestUtil.unzip(getDataFile(\"index.\" + oldNames[i] + \".zip\"), oldIndexDir);\n      Directory dir = newFSDirectory(oldIndexDir);\n      IndexSearcher searcher = new IndexSearcher(dir, true);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(searcher.getIndexReader(), \"trieInt\", false);\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(searcher.getIndexReader(), \"trieLong\", false);\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      searcher.close();\n      dir.close();\n      _TestUtil.rmDir(oldIndexDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0e7c2454a6a8237bfd0e953f5b940838408c9055","date":1323649300,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","sourceNew":"  public void testNumericFields() throws Exception {\n    for(int i=0;i<oldNames.length;i++) {\n      \n      File oldIndexDir = _TestUtil.getTempDir(oldNames[i]);\n      _TestUtil.unzip(getDataFile(\"index.\" + oldNames[i] + \".zip\"), oldIndexDir);\n      Directory dir = newFSDirectory(oldIndexDir);\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(searcher.getIndexReader(), \"trieInt\", false);\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(searcher.getIndexReader(), \"trieLong\", false);\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      reader.close();\n      dir.close();\n      _TestUtil.rmDir(oldIndexDir);\n    }\n  }\n\n","sourceOld":"  public void testNumericFields() throws Exception {\n    for(int i=0;i<oldNames.length;i++) {\n      \n      File oldIndexDir = _TestUtil.getTempDir(oldNames[i]);\n      _TestUtil.unzip(getDataFile(\"index.\" + oldNames[i] + \".zip\"), oldIndexDir);\n      Directory dir = newFSDirectory(oldIndexDir);\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(searcher.getIndexReader(), \"trieInt\", false);\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(searcher.getIndexReader(), \"trieLong\", false);\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      searcher.close();\n      reader.close();\n      dir.close();\n      _TestUtil.rmDir(oldIndexDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","date":1323720782,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","sourceNew":"  public void testNumericFields() throws Exception {\n    for(int i=0;i<oldNames.length;i++) {\n      \n      File oldIndexDir = _TestUtil.getTempDir(oldNames[i]);\n      _TestUtil.unzip(getDataFile(\"index.\" + oldNames[i] + \".zip\"), oldIndexDir);\n      Directory dir = newFSDirectory(oldIndexDir);\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(searcher.getIndexReader(), \"trieInt\", false);\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(searcher.getIndexReader(), \"trieLong\", false);\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      reader.close();\n      dir.close();\n      _TestUtil.rmDir(oldIndexDir);\n    }\n  }\n\n","sourceOld":"  public void testNumericFields() throws Exception {\n    for(int i=0;i<oldNames.length;i++) {\n      \n      File oldIndexDir = _TestUtil.getTempDir(oldNames[i]);\n      _TestUtil.unzip(getDataFile(\"index.\" + oldNames[i] + \".zip\"), oldIndexDir);\n      Directory dir = newFSDirectory(oldIndexDir);\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(searcher.getIndexReader(), \"trieInt\", false);\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(searcher.getIndexReader(), \"trieLong\", false);\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      searcher.close();\n      reader.close();\n      dir.close();\n      _TestUtil.rmDir(oldIndexDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8be580b58bcc650d428f3f22de81cadcf51d650a","date":1325279655,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","sourceNew":"  public void testNumericFields() throws Exception {\n    for (String name : oldNames) {\n      \n      Directory dir = oldIndexDirs.get(name);\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(searcher.getIndexReader(), \"trieInt\", false);\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(searcher.getIndexReader(), \"trieLong\", false);\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      reader.close();\n    }\n  }\n\n","sourceOld":"  public void testNumericFields() throws Exception {\n    for(int i=0;i<oldNames.length;i++) {\n      \n      File oldIndexDir = _TestUtil.getTempDir(oldNames[i]);\n      _TestUtil.unzip(getDataFile(\"index.\" + oldNames[i] + \".zip\"), oldIndexDir);\n      Directory dir = newFSDirectory(oldIndexDir);\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(searcher.getIndexReader(), \"trieInt\", false);\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(searcher.getIndexReader(), \"trieLong\", false);\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      reader.close();\n      dir.close();\n      _TestUtil.rmDir(oldIndexDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2dd6ecb8250c497ed227653279d6a4f470bfbb31","date":1326814483,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","sourceNew":"  public void testNumericFields() throws Exception {\n    for (String name : oldNames) {\n      \n      Directory dir = oldIndexDirs.get(name);\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(new SlowMultiReaderWrapper(searcher.getIndexReader()), \"trieInt\", false);\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(new SlowMultiReaderWrapper(searcher.getIndexReader()), \"trieLong\", false);\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      reader.close();\n    }\n  }\n\n","sourceOld":"  public void testNumericFields() throws Exception {\n    for (String name : oldNames) {\n      \n      Directory dir = oldIndexDirs.get(name);\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(searcher.getIndexReader(), \"trieInt\", false);\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(searcher.getIndexReader(), \"trieLong\", false);\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      reader.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"386d1b0dcb065f1bfc494b1407cb41c536b95485","date":1327848512,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","sourceNew":"  public void testNumericFields() throws Exception {\n    for (String name : oldNames) {\n      \n      Directory dir = oldIndexDirs.get(name);\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(SlowCompositeReaderWrapper.wrap(searcher.getIndexReader()), \"trieInt\", false);\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(SlowCompositeReaderWrapper.wrap(searcher.getIndexReader()), \"trieLong\", false);\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      reader.close();\n    }\n  }\n\n","sourceOld":"  public void testNumericFields() throws Exception {\n    for (String name : oldNames) {\n      \n      Directory dir = oldIndexDirs.get(name);\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(new SlowMultiReaderWrapper(searcher.getIndexReader()), \"trieInt\", false);\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(new SlowMultiReaderWrapper(searcher.getIndexReader()), \"trieLong\", false);\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      reader.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","sourceNew":"  public void testNumericFields() throws Exception {\n    for (String name : oldNames) {\n      \n      Directory dir = oldIndexDirs.get(name);\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(SlowCompositeReaderWrapper.wrap(searcher.getIndexReader()), \"trieInt\", false);\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(SlowCompositeReaderWrapper.wrap(searcher.getIndexReader()), \"trieLong\", false);\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      reader.close();\n    }\n  }\n\n","sourceOld":"  public void testNumericFields() throws Exception {\n    for (String name : oldNames) {\n      \n      Directory dir = oldIndexDirs.get(name);\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(new SlowMultiReaderWrapper(searcher.getIndexReader()), \"trieInt\", false);\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(new SlowMultiReaderWrapper(searcher.getIndexReader()), \"trieLong\", false);\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      reader.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testNumericFields().mjava","sourceNew":"  public void testNumericFields() throws Exception {\n    for (String name : oldNames) {\n      \n      Directory dir = oldIndexDirs.get(name);\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(SlowCompositeReaderWrapper.wrap(searcher.getIndexReader()), \"trieInt\", false);\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(SlowCompositeReaderWrapper.wrap(searcher.getIndexReader()), \"trieLong\", false);\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      reader.close();\n    }\n  }\n\n","sourceOld":"  public void testNumericFields() throws Exception {\n    for (String name : oldNames) {\n      \n      Directory dir = oldIndexDirs.get(name);\n      IndexReader reader = IndexReader.open(dir);\n      IndexSearcher searcher = new IndexSearcher(reader);\n      \n      for (int id=10; id<15; id++) {\n        ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.valueOf(id), Integer.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        Document d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n        \n        hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.valueOf(id), Long.valueOf(id), true, true), 100).scoreDocs;\n        assertEquals(\"wrong number of hits\", 1, hits.length);\n        d = searcher.doc(hits[0].doc);\n        assertEquals(String.valueOf(id), d.get(\"id\"));\n      }\n      \n      // check that also lower-precision fields are ok\n      ScoreDoc[] hits = searcher.search(NumericRangeQuery.newIntRange(\"trieInt\", 4, Integer.MIN_VALUE, Integer.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      hits = searcher.search(NumericRangeQuery.newLongRange(\"trieLong\", 4, Long.MIN_VALUE, Long.MAX_VALUE, false, false), 100).scoreDocs;\n      assertEquals(\"wrong number of hits\", 34, hits.length);\n      \n      // check decoding into field cache\n      int[] fci = FieldCache.DEFAULT.getInts(SlowCompositeReaderWrapper.wrap(searcher.getIndexReader()), \"trieInt\", false);\n      for (int val : fci) {\n        assertTrue(\"value in id bounds\", val >= 0 && val < 35);\n      }\n      \n      long[] fcl = FieldCache.DEFAULT.getLongs(SlowCompositeReaderWrapper.wrap(searcher.getIndexReader()), \"trieLong\", false);\n      for (long val : fcl) {\n        assertTrue(\"value in id bounds\", val >= 0L && val < 35L);\n      }\n      \n      reader.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a13a126d15299d5c1e117ea99ddae6fb0fa3f209":["6267e1ce56c2eec111425690cd04e251b6f14952"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":["a3a0403b45dfe384fae4a1b6e96c3265d000c498","0e7c2454a6a8237bfd0e953f5b940838408c9055"],"3cdad2c6b6234338031bcc1f24c001a5ad66f714":["a13a126d15299d5c1e117ea99ddae6fb0fa3f209"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["6267e1ce56c2eec111425690cd04e251b6f14952","a13a126d15299d5c1e117ea99ddae6fb0fa3f209"],"8be580b58bcc650d428f3f22de81cadcf51d650a":["0e7c2454a6a8237bfd0e953f5b940838408c9055"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["6267e1ce56c2eec111425690cd04e251b6f14952","a13a126d15299d5c1e117ea99ddae6fb0fa3f209"],"382fe3a6ca9745891afebda9b9a57cc158305545":["3cdad2c6b6234338031bcc1f24c001a5ad66f714"],"2dd6ecb8250c497ed227653279d6a4f470bfbb31":["8be580b58bcc650d428f3f22de81cadcf51d650a"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["2dd6ecb8250c497ed227653279d6a4f470bfbb31","386d1b0dcb065f1bfc494b1407cb41c536b95485"],"6267e1ce56c2eec111425690cd04e251b6f14952":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"0e7c2454a6a8237bfd0e953f5b940838408c9055":["a3a0403b45dfe384fae4a1b6e96c3265d000c498"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","3cdad2c6b6234338031bcc1f24c001a5ad66f714"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a3a0403b45dfe384fae4a1b6e96c3265d000c498":["382fe3a6ca9745891afebda9b9a57cc158305545"],"386d1b0dcb065f1bfc494b1407cb41c536b95485":["2dd6ecb8250c497ed227653279d6a4f470bfbb31"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","3cdad2c6b6234338031bcc1f24c001a5ad66f714"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"a13a126d15299d5c1e117ea99ddae6fb0fa3f209":["3cdad2c6b6234338031bcc1f24c001a5ad66f714","ab5cb6a74aefb78aa0569857970b9151dfe2e787","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":[],"3cdad2c6b6234338031bcc1f24c001a5ad66f714":["382fe3a6ca9745891afebda9b9a57cc158305545","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["6267e1ce56c2eec111425690cd04e251b6f14952"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"8be580b58bcc650d428f3f22de81cadcf51d650a":["2dd6ecb8250c497ed227653279d6a4f470bfbb31"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"382fe3a6ca9745891afebda9b9a57cc158305545":["a3a0403b45dfe384fae4a1b6e96c3265d000c498"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"2dd6ecb8250c497ed227653279d6a4f470bfbb31":["5cab9a86bd67202d20b6adc463008c8e982b070a","386d1b0dcb065f1bfc494b1407cb41c536b95485"],"6267e1ce56c2eec111425690cd04e251b6f14952":["a13a126d15299d5c1e117ea99ddae6fb0fa3f209","ab5cb6a74aefb78aa0569857970b9151dfe2e787","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"0e7c2454a6a8237bfd0e953f5b940838408c9055":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","8be580b58bcc650d428f3f22de81cadcf51d650a"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"a3a0403b45dfe384fae4a1b6e96c3265d000c498":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","0e7c2454a6a8237bfd0e953f5b940838408c9055"],"386d1b0dcb065f1bfc494b1407cb41c536b95485":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}