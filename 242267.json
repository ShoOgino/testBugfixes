{"path":"lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/RectIntersectionTestHelper#testRelateWithRectangle().mjava","commits":[{"id":"8fc7b597b2d21a932a857539efde49f09ec86ba0","date":1429537254,"type":0,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/RectIntersectionTestHelper#testRelateWithRectangle().mjava","pathOld":"/dev/null","sourceNew":"  public void testRelateWithRectangle() {\n    //counters for the different intersection cases\n    int i_C = 0, i_I = 0, i_W = 0, i_D = 0, i_bboxD = 0;\n    int laps = 0;\n    final int MINLAPSPERCASE = scaledRandomIntBetween(20, 200);\n    while(i_C < MINLAPSPERCASE || i_I < MINLAPSPERCASE || i_W < MINLAPSPERCASE\n        || i_D < MINLAPSPERCASE || i_bboxD < MINLAPSPERCASE) {\n      laps++;\n\n      TestLog.clear();\n\n      Point nearP = randomPointIn(ctx.getWorldBounds());\n\n      S s = generateRandomShape(nearP);\n\n      Rectangle r = randomRectangle(s.getBoundingBox().getCenter());\n\n      SpatialRelation ic = s.relate(r);\n\n      TestLog.log(\"S-R Rel: {}, Shape {}, Rectangle {}\", ic, s, r);\n\n      try {\n        int MAX_TRIES = scaledRandomIntBetween(10, 100);\n        switch (ic) {\n          case CONTAINS:\n            i_C++;\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(r);\n              assertRelation(null, CONTAINS, s, p);\n            }\n            break;\n\n          case WITHIN:\n            i_W++;\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(s);\n              assertRelation(null, CONTAINS, r, p);\n            }\n            break;\n\n          case DISJOINT:\n            if (!s.getBoundingBox().relate(r).intersects()) {//bboxes are disjoint\n              i_bboxD++;\n              if (i_bboxD > MINLAPSPERCASE)\n                break;\n            } else {\n              i_D++;\n            }\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(r);\n              assertRelation(null, DISJOINT, s, p);\n            }\n            break;\n\n          case INTERSECTS:\n            i_I++;\n            SpatialRelation pointR = null;//set once\n            Rectangle randomPointSpace = null;\n            MAX_TRIES = 1000;//give many attempts\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p;\n              if (j < 4) {\n                p = new PointImpl(0, 0, ctx);\n                InfBufLine.cornerByQuadrant(r, j + 1, p);\n              } else {\n                if (randomPointSpace == null) {\n                  if (pointR == DISJOINT) {\n                    randomPointSpace = intersectRects(r,s.getBoundingBox());\n                  } else {//CONTAINS\n                    randomPointSpace = r;\n                  }\n                }\n                p = randomPointIn(randomPointSpace);\n              }\n              SpatialRelation pointRNew = s.relate(p);\n              if (pointR == null) {\n                pointR = pointRNew;\n              } else if (pointR != pointRNew) {\n                break;\n              } else if (j >= MAX_TRIES) {\n                //TODO consider logging instead of failing\n                fail(\"Tried intersection brute-force too many times without success\");\n              }\n            }\n\n            break;\n\n          default: fail(\"\"+ic);\n        }\n      } catch (AssertionError e) {\n        onAssertFail(e, s, r, ic);\n      }\n      if (laps > MINLAPSPERCASE * 1000)\n        fail(\"Did not find enough intersection cases in a reasonable number\" +\n            \" of random attempts. CWIDbD: \"+i_C+\",\"+i_W+\",\"+i_I+\",\"+i_D+\",\"+i_bboxD\n            + \"  Laps exceeded \"+MINLAPSPERCASE * 1000);\n    }\n    System.out.println(\"Laps: \"+laps + \" CWIDbD: \"+i_C+\",\"+i_W+\",\"+i_I+\",\"+i_D+\",\"+i_bboxD);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7486946d77195121edad36d1ee2b45e5c231041","date":1429717061,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/RectIntersectionTestHelper#testRelateWithRectangle().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/RectIntersectionTestHelper#testRelateWithRectangle().mjava","sourceNew":"  public void testRelateWithRectangle() {\n    //counters for the different intersection cases\n    int i_C = 0, i_I = 0, i_W = 0, i_D = 0, i_bboxD = 0;\n    int laps = 0;\n    final int MINLAPSPERCASE = scaledRandomIntBetween(20, 200);\n    while(i_C < MINLAPSPERCASE || i_I < MINLAPSPERCASE || i_W < MINLAPSPERCASE\n        || (!isRandomShapeRectangular() && i_D < MINLAPSPERCASE) || i_bboxD < MINLAPSPERCASE) {\n      laps++;\n\n      TestLog.clear();\n\n      Point nearP = randomPointIn(ctx.getWorldBounds());\n\n      S s = generateRandomShape(nearP);\n\n      Rectangle r = randomRectangle(s.getBoundingBox().getCenter());\n\n      SpatialRelation ic = s.relate(r);\n\n      TestLog.log(\"S-R Rel: {}, Shape {}, Rectangle {}\", ic, s, r);\n\n      if (ic != DISJOINT) {\n        assertTrue(\"if not disjoint then the shape's bbox shouldn't be disjoint\",\n            s.getBoundingBox().relate(r).intersects());\n      }\n\n      try {\n        int MAX_TRIES = scaledRandomIntBetween(10, 100);\n        switch (ic) {\n          case CONTAINS:\n            i_C++;\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(r);\n              assertRelation(null, CONTAINS, s, p);\n            }\n            break;\n\n          case WITHIN:\n            i_W++;\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(s);\n              assertRelation(null, CONTAINS, r, p);\n            }\n            break;\n\n          case DISJOINT:\n            if (!s.getBoundingBox().relate(r).intersects()) {//bboxes are disjoint\n              i_bboxD++;\n              if (i_bboxD > MINLAPSPERCASE)\n                break;\n            } else {\n              i_D++;\n            }\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(r);\n              assertRelation(null, DISJOINT, s, p);\n            }\n            break;\n\n          case INTERSECTS:\n            i_I++;\n            SpatialRelation pointR = null;//set once\n            Rectangle randomPointSpace = null;\n            MAX_TRIES = 1000;//give many attempts\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p;\n              if (j < 4) {\n                p = new PointImpl(0, 0, ctx);\n                InfBufLine.cornerByQuadrant(r, j + 1, p);\n              } else {\n                if (randomPointSpace == null) {\n                  if (pointR == DISJOINT) {\n                    randomPointSpace = intersectRects(r,s.getBoundingBox());\n                  } else {//CONTAINS\n                    randomPointSpace = r;\n                  }\n                }\n                p = randomPointIn(randomPointSpace);\n              }\n              SpatialRelation pointRNew = s.relate(p);\n              if (pointR == null) {\n                pointR = pointRNew;\n              } else if (pointR != pointRNew) {\n                break;\n              } else if (j >= MAX_TRIES) {\n                //TODO consider logging instead of failing\n                fail(\"Tried intersection brute-force too many times without success\");\n              }\n            }\n\n            break;\n\n          default: fail(\"\"+ic);\n        }\n      } catch (AssertionError e) {\n        onAssertFail(e, s, r, ic);\n      }\n      if (laps > MINLAPSPERCASE * 1000)\n        fail(\"Did not find enough intersection cases in a reasonable number\" +\n            \" of random attempts. CWIDbD: \"+i_C+\",\"+i_W+\",\"+i_I+\",\"+i_D+\",\"+i_bboxD\n            + \"  Laps exceeded \"+MINLAPSPERCASE * 1000);\n    }\n    System.out.println(\"Laps: \"+laps + \" CWIDbD: \"+i_C+\",\"+i_W+\",\"+i_I+\",\"+i_D+\",\"+i_bboxD);\n  }\n\n","sourceOld":"  public void testRelateWithRectangle() {\n    //counters for the different intersection cases\n    int i_C = 0, i_I = 0, i_W = 0, i_D = 0, i_bboxD = 0;\n    int laps = 0;\n    final int MINLAPSPERCASE = scaledRandomIntBetween(20, 200);\n    while(i_C < MINLAPSPERCASE || i_I < MINLAPSPERCASE || i_W < MINLAPSPERCASE\n        || i_D < MINLAPSPERCASE || i_bboxD < MINLAPSPERCASE) {\n      laps++;\n\n      TestLog.clear();\n\n      Point nearP = randomPointIn(ctx.getWorldBounds());\n\n      S s = generateRandomShape(nearP);\n\n      Rectangle r = randomRectangle(s.getBoundingBox().getCenter());\n\n      SpatialRelation ic = s.relate(r);\n\n      TestLog.log(\"S-R Rel: {}, Shape {}, Rectangle {}\", ic, s, r);\n\n      try {\n        int MAX_TRIES = scaledRandomIntBetween(10, 100);\n        switch (ic) {\n          case CONTAINS:\n            i_C++;\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(r);\n              assertRelation(null, CONTAINS, s, p);\n            }\n            break;\n\n          case WITHIN:\n            i_W++;\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(s);\n              assertRelation(null, CONTAINS, r, p);\n            }\n            break;\n\n          case DISJOINT:\n            if (!s.getBoundingBox().relate(r).intersects()) {//bboxes are disjoint\n              i_bboxD++;\n              if (i_bboxD > MINLAPSPERCASE)\n                break;\n            } else {\n              i_D++;\n            }\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(r);\n              assertRelation(null, DISJOINT, s, p);\n            }\n            break;\n\n          case INTERSECTS:\n            i_I++;\n            SpatialRelation pointR = null;//set once\n            Rectangle randomPointSpace = null;\n            MAX_TRIES = 1000;//give many attempts\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p;\n              if (j < 4) {\n                p = new PointImpl(0, 0, ctx);\n                InfBufLine.cornerByQuadrant(r, j + 1, p);\n              } else {\n                if (randomPointSpace == null) {\n                  if (pointR == DISJOINT) {\n                    randomPointSpace = intersectRects(r,s.getBoundingBox());\n                  } else {//CONTAINS\n                    randomPointSpace = r;\n                  }\n                }\n                p = randomPointIn(randomPointSpace);\n              }\n              SpatialRelation pointRNew = s.relate(p);\n              if (pointR == null) {\n                pointR = pointRNew;\n              } else if (pointR != pointRNew) {\n                break;\n              } else if (j >= MAX_TRIES) {\n                //TODO consider logging instead of failing\n                fail(\"Tried intersection brute-force too many times without success\");\n              }\n            }\n\n            break;\n\n          default: fail(\"\"+ic);\n        }\n      } catch (AssertionError e) {\n        onAssertFail(e, s, r, ic);\n      }\n      if (laps > MINLAPSPERCASE * 1000)\n        fail(\"Did not find enough intersection cases in a reasonable number\" +\n            \" of random attempts. CWIDbD: \"+i_C+\",\"+i_W+\",\"+i_I+\",\"+i_D+\",\"+i_bboxD\n            + \"  Laps exceeded \"+MINLAPSPERCASE * 1000);\n    }\n    System.out.println(\"Laps: \"+laps + \" CWIDbD: \"+i_C+\",\"+i_W+\",\"+i_I+\",\"+i_D+\",\"+i_bboxD);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9f29148b9875bb4ec843fd6c03ee6291236c7b88","date":1429852671,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/RectIntersectionTestHelper#testRelateWithRectangle().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/RectIntersectionTestHelper#testRelateWithRectangle().mjava","sourceNew":"  public void testRelateWithRectangle() {\n    //counters for the different intersection cases\n    int i_C = 0, i_I = 0, i_W = 0, i_D = 0, i_bboxD = 0;\n    int laps = 0;\n    final int MINLAPSPERCASE = scaledRandomIntBetween(20, 200);\n    while(i_C < MINLAPSPERCASE || i_I < MINLAPSPERCASE || i_W < MINLAPSPERCASE\n        || (!isRandomShapeRectangular() && i_D < MINLAPSPERCASE) || i_bboxD < MINLAPSPERCASE) {\n      laps++;\n\n      TestLog.clear();\n\n      if (laps > MINLAPSPERCASE * 1000) {\n        fail(\"Did not find enough intersection cases in a reasonable number\" +\n            \" of random attempts. CWIDbD: \" + i_C + \",\" + i_W + \",\" + i_I + \",\" + i_D + \",\" + i_bboxD\n            + \"  Laps exceeded \" + MINLAPSPERCASE * 1000);\n      }\n\n      Point nearP = randomPointIn(ctx.getWorldBounds());\n\n      S s = generateRandomShape(nearP);\n\n      Rectangle r = randomRectangle(s.getBoundingBox().getCenter());\n\n      SpatialRelation ic = s.relate(r);\n\n      TestLog.log(\"S-R Rel: {}, Shape {}, Rectangle {}\", ic, s, r);\n\n      if (ic != DISJOINT) {\n        assertTrue(\"if not disjoint then the shape's bbox shouldn't be disjoint\",\n            s.getBoundingBox().relate(r).intersects());\n      }\n\n      try {\n        int MAX_TRIES = scaledRandomIntBetween(10, 100);\n        switch (ic) {\n          case CONTAINS:\n            i_C++;\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(r);\n              assertRelation(null, CONTAINS, s, p);\n            }\n            break;\n\n          case WITHIN:\n            i_W++;\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(s);\n              assertRelation(null, CONTAINS, r, p);\n            }\n            break;\n\n          case DISJOINT:\n            if (!s.getBoundingBox().relate(r).intersects()) {//bboxes are disjoint\n              i_bboxD++;\n              if (i_bboxD > MINLAPSPERCASE)\n                break;\n            } else {\n              i_D++;\n            }\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(r);\n              assertRelation(null, DISJOINT, s, p);\n            }\n            break;\n\n          case INTERSECTS:\n            i_I++;\n            SpatialRelation pointR = null;//set once\n            Rectangle randomPointSpace = null;\n            MAX_TRIES = 1000;//give many attempts\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p;\n              if (j < 4) {\n                p = new PointImpl(0, 0, ctx);\n                InfBufLine.cornerByQuadrant(r, j + 1, p);\n              } else {\n                if (randomPointSpace == null) {\n                  if (pointR == DISJOINT) {\n                    randomPointSpace = intersectRects(r,s.getBoundingBox());\n                  } else {//CONTAINS\n                    randomPointSpace = r;\n                  }\n                }\n                p = randomPointIn(randomPointSpace);\n              }\n              SpatialRelation pointRNew = s.relate(p);\n              if (pointR == null) {\n                pointR = pointRNew;\n              } else if (pointR != pointRNew) {\n                break;\n              } else if (j >= MAX_TRIES) {\n                //TODO consider logging instead of failing\n                fail(\"Tried intersection brute-force too many times without success\");\n              }\n            }\n\n            break;\n\n          default: fail(\"\"+ic);\n        } // switch\n      } catch (AssertionError e) {\n        onAssertFail(e, s, r, ic);\n      }\n\n    } // while loop\n\n    System.out.println(\"Laps: \"+laps + \" CWIDbD: \"+i_C+\",\"+i_W+\",\"+i_I+\",\"+i_D+\",\"+i_bboxD);\n  }\n\n","sourceOld":"  public void testRelateWithRectangle() {\n    //counters for the different intersection cases\n    int i_C = 0, i_I = 0, i_W = 0, i_D = 0, i_bboxD = 0;\n    int laps = 0;\n    final int MINLAPSPERCASE = scaledRandomIntBetween(20, 200);\n    while(i_C < MINLAPSPERCASE || i_I < MINLAPSPERCASE || i_W < MINLAPSPERCASE\n        || (!isRandomShapeRectangular() && i_D < MINLAPSPERCASE) || i_bboxD < MINLAPSPERCASE) {\n      laps++;\n\n      TestLog.clear();\n\n      Point nearP = randomPointIn(ctx.getWorldBounds());\n\n      S s = generateRandomShape(nearP);\n\n      Rectangle r = randomRectangle(s.getBoundingBox().getCenter());\n\n      SpatialRelation ic = s.relate(r);\n\n      TestLog.log(\"S-R Rel: {}, Shape {}, Rectangle {}\", ic, s, r);\n\n      if (ic != DISJOINT) {\n        assertTrue(\"if not disjoint then the shape's bbox shouldn't be disjoint\",\n            s.getBoundingBox().relate(r).intersects());\n      }\n\n      try {\n        int MAX_TRIES = scaledRandomIntBetween(10, 100);\n        switch (ic) {\n          case CONTAINS:\n            i_C++;\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(r);\n              assertRelation(null, CONTAINS, s, p);\n            }\n            break;\n\n          case WITHIN:\n            i_W++;\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(s);\n              assertRelation(null, CONTAINS, r, p);\n            }\n            break;\n\n          case DISJOINT:\n            if (!s.getBoundingBox().relate(r).intersects()) {//bboxes are disjoint\n              i_bboxD++;\n              if (i_bboxD > MINLAPSPERCASE)\n                break;\n            } else {\n              i_D++;\n            }\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(r);\n              assertRelation(null, DISJOINT, s, p);\n            }\n            break;\n\n          case INTERSECTS:\n            i_I++;\n            SpatialRelation pointR = null;//set once\n            Rectangle randomPointSpace = null;\n            MAX_TRIES = 1000;//give many attempts\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p;\n              if (j < 4) {\n                p = new PointImpl(0, 0, ctx);\n                InfBufLine.cornerByQuadrant(r, j + 1, p);\n              } else {\n                if (randomPointSpace == null) {\n                  if (pointR == DISJOINT) {\n                    randomPointSpace = intersectRects(r,s.getBoundingBox());\n                  } else {//CONTAINS\n                    randomPointSpace = r;\n                  }\n                }\n                p = randomPointIn(randomPointSpace);\n              }\n              SpatialRelation pointRNew = s.relate(p);\n              if (pointR == null) {\n                pointR = pointRNew;\n              } else if (pointR != pointRNew) {\n                break;\n              } else if (j >= MAX_TRIES) {\n                //TODO consider logging instead of failing\n                fail(\"Tried intersection brute-force too many times without success\");\n              }\n            }\n\n            break;\n\n          default: fail(\"\"+ic);\n        }\n      } catch (AssertionError e) {\n        onAssertFail(e, s, r, ic);\n      }\n      if (laps > MINLAPSPERCASE * 1000)\n        fail(\"Did not find enough intersection cases in a reasonable number\" +\n            \" of random attempts. CWIDbD: \"+i_C+\",\"+i_W+\",\"+i_I+\",\"+i_D+\",\"+i_bboxD\n            + \"  Laps exceeded \"+MINLAPSPERCASE * 1000);\n    }\n    System.out.println(\"Laps: \"+laps + \" CWIDbD: \"+i_C+\",\"+i_W+\",\"+i_I+\",\"+i_D+\",\"+i_bboxD);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5079b556f19f6e82e97b91cc3e617bec55c4d9c","date":1430717212,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/RectIntersectionTestHelper#testRelateWithRectangle().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/RectIntersectionTestHelper#testRelateWithRectangle().mjava","sourceNew":"  public void testRelateWithRectangle() {\n    //counters for the different intersection cases\n    int i_C = 0, i_I = 0, i_W = 0, i_D = 0, i_bboxD = 0;\n    int laps = 0;\n    final int MINLAPS = scaledRandomIntBetween(20000, 200000);\n    while(i_C < getContainsMinimum(MINLAPS) || i_I < getIntersectsMinimum(MINLAPS) || i_W < getWithinMinimum(MINLAPS)\n        || (!isRandomShapeRectangular() && i_D < getDisjointMinimum(MINLAPS)) || i_bboxD < getBoundingMinimum(MINLAPS)) {\n      laps++;\n\n      TestLog.clear();\n\n      if (laps > MINLAPS) {\n        fail(\"Did not find enough contains/within/intersection/disjoint/bounds cases in a reasonable number\" +\n            \" of random attempts. CWIDbD: \" +\n            i_C + \"(\"+getContainsMinimum(MINLAPS)+\"),\" +\n            i_W + \"(\"+getWithinMinimum(MINLAPS)+\"),\" +\n            i_I + \"(\"+getIntersectsMinimum(MINLAPS)+\"),\" +\n            i_D + \"(\"+getDisjointMinimum(MINLAPS)+\"),\" +\n            i_bboxD + \"(\"+getBoundingMinimum(MINLAPS)+\")\"\n            + \"  Laps exceeded \" + MINLAPS);\n      }\n\n      Point nearP = randomPointIn(ctx.getWorldBounds());\n\n      S s = generateRandomShape(nearP);\n\n      Rectangle r = randomRectangle(s.getBoundingBox().getCenter());\n\n      SpatialRelation ic = s.relate(r);\n\n      TestLog.log(\"S-R Rel: {}, Shape {}, Rectangle {}\", ic, s, r);\n\n      if (ic != DISJOINT) {\n        assertTrue(\"if not disjoint then the shape's bbox shouldn't be disjoint\",\n            s.getBoundingBox().relate(r).intersects());\n      }\n\n      try {\n        int MAX_TRIES = scaledRandomIntBetween(10, 100);\n        switch (ic) {\n          case CONTAINS:\n            i_C++;\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(r);\n              assertRelation(null, CONTAINS, s, p);\n            }\n            break;\n\n          case WITHIN:\n            i_W++;\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(s);\n              assertRelation(null, CONTAINS, r, p);\n            }\n            break;\n\n          case DISJOINT:\n            if (!s.getBoundingBox().relate(r).intersects()) {//bboxes are disjoint\n              i_bboxD++;\n              if (i_bboxD >= getBoundingMinimum(MINLAPS))\n                break;\n            } else {\n              i_D++;\n            }\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(r);\n              assertRelation(null, DISJOINT, s, p);\n            }\n            break;\n\n          case INTERSECTS:\n            i_I++;\n            SpatialRelation pointR = null;//set once\n            Rectangle randomPointSpace = null;\n            MAX_TRIES = 1000;//give many attempts\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p;\n              if (j < 4) {\n                p = new PointImpl(0, 0, ctx);\n                InfBufLine.cornerByQuadrant(r, j + 1, p);\n              } else {\n                if (randomPointSpace == null) {\n                  if (pointR == DISJOINT) {\n                    randomPointSpace = intersectRects(r,s.getBoundingBox());\n                  } else {//CONTAINS\n                    randomPointSpace = r;\n                  }\n                }\n                p = randomPointIn(randomPointSpace);\n              }\n              SpatialRelation pointRNew = s.relate(p);\n              if (pointR == null) {\n                pointR = pointRNew;\n              } else if (pointR != pointRNew) {\n                break;\n              } else if (j >= MAX_TRIES) {\n                //TODO consider logging instead of failing\n                fail(\"Tried intersection brute-force too many times without success\");\n              }\n            }\n\n            break;\n\n          default: fail(\"\"+ic);\n        } // switch\n      } catch (AssertionError e) {\n        onAssertFail(e, s, r, ic);\n      }\n\n    } // while loop\n\n    System.out.println(\"Laps: \"+laps + \" CWIDbD: \"+i_C+\",\"+i_W+\",\"+i_I+\",\"+i_D+\",\"+i_bboxD);\n  }\n\n","sourceOld":"  public void testRelateWithRectangle() {\n    //counters for the different intersection cases\n    int i_C = 0, i_I = 0, i_W = 0, i_D = 0, i_bboxD = 0;\n    int laps = 0;\n    final int MINLAPSPERCASE = scaledRandomIntBetween(20, 200);\n    while(i_C < MINLAPSPERCASE || i_I < MINLAPSPERCASE || i_W < MINLAPSPERCASE\n        || (!isRandomShapeRectangular() && i_D < MINLAPSPERCASE) || i_bboxD < MINLAPSPERCASE) {\n      laps++;\n\n      TestLog.clear();\n\n      if (laps > MINLAPSPERCASE * 1000) {\n        fail(\"Did not find enough intersection cases in a reasonable number\" +\n            \" of random attempts. CWIDbD: \" + i_C + \",\" + i_W + \",\" + i_I + \",\" + i_D + \",\" + i_bboxD\n            + \"  Laps exceeded \" + MINLAPSPERCASE * 1000);\n      }\n\n      Point nearP = randomPointIn(ctx.getWorldBounds());\n\n      S s = generateRandomShape(nearP);\n\n      Rectangle r = randomRectangle(s.getBoundingBox().getCenter());\n\n      SpatialRelation ic = s.relate(r);\n\n      TestLog.log(\"S-R Rel: {}, Shape {}, Rectangle {}\", ic, s, r);\n\n      if (ic != DISJOINT) {\n        assertTrue(\"if not disjoint then the shape's bbox shouldn't be disjoint\",\n            s.getBoundingBox().relate(r).intersects());\n      }\n\n      try {\n        int MAX_TRIES = scaledRandomIntBetween(10, 100);\n        switch (ic) {\n          case CONTAINS:\n            i_C++;\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(r);\n              assertRelation(null, CONTAINS, s, p);\n            }\n            break;\n\n          case WITHIN:\n            i_W++;\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(s);\n              assertRelation(null, CONTAINS, r, p);\n            }\n            break;\n\n          case DISJOINT:\n            if (!s.getBoundingBox().relate(r).intersects()) {//bboxes are disjoint\n              i_bboxD++;\n              if (i_bboxD > MINLAPSPERCASE)\n                break;\n            } else {\n              i_D++;\n            }\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(r);\n              assertRelation(null, DISJOINT, s, p);\n            }\n            break;\n\n          case INTERSECTS:\n            i_I++;\n            SpatialRelation pointR = null;//set once\n            Rectangle randomPointSpace = null;\n            MAX_TRIES = 1000;//give many attempts\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p;\n              if (j < 4) {\n                p = new PointImpl(0, 0, ctx);\n                InfBufLine.cornerByQuadrant(r, j + 1, p);\n              } else {\n                if (randomPointSpace == null) {\n                  if (pointR == DISJOINT) {\n                    randomPointSpace = intersectRects(r,s.getBoundingBox());\n                  } else {//CONTAINS\n                    randomPointSpace = r;\n                  }\n                }\n                p = randomPointIn(randomPointSpace);\n              }\n              SpatialRelation pointRNew = s.relate(p);\n              if (pointR == null) {\n                pointR = pointRNew;\n              } else if (pointR != pointRNew) {\n                break;\n              } else if (j >= MAX_TRIES) {\n                //TODO consider logging instead of failing\n                fail(\"Tried intersection brute-force too many times without success\");\n              }\n            }\n\n            break;\n\n          default: fail(\"\"+ic);\n        } // switch\n      } catch (AssertionError e) {\n        onAssertFail(e, s, r, ic);\n      }\n\n    } // while loop\n\n    System.out.println(\"Laps: \"+laps + \" CWIDbD: \"+i_C+\",\"+i_W+\",\"+i_I+\",\"+i_D+\",\"+i_bboxD);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c921d81476f94b6686d3f216daa1f6b076b4a6c0","date":1430922284,"type":0,"author":"David Wayne Smiley","isMerge":true,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/RectIntersectionTestHelper#testRelateWithRectangle().mjava","pathOld":"/dev/null","sourceNew":"  public void testRelateWithRectangle() {\n    //counters for the different intersection cases\n    int i_C = 0, i_I = 0, i_W = 0, i_D = 0, i_bboxD = 0;\n    int laps = 0;\n    final int MINLAPS = scaledRandomIntBetween(20000, 200000);\n    while(i_C < getContainsMinimum(MINLAPS) || i_I < getIntersectsMinimum(MINLAPS) || i_W < getWithinMinimum(MINLAPS)\n        || (!isRandomShapeRectangular() && i_D < getDisjointMinimum(MINLAPS)) || i_bboxD < getBoundingMinimum(MINLAPS)) {\n      laps++;\n\n      LogRule.clear();\n\n      if (laps > MINLAPS) {\n        fail(\"Did not find enough contains/within/intersection/disjoint/bounds cases in a reasonable number\" +\n            \" of random attempts. CWIDbD: \" +\n            i_C + \"(\"+getContainsMinimum(MINLAPS)+\"),\" +\n            i_W + \"(\"+getWithinMinimum(MINLAPS)+\"),\" +\n            i_I + \"(\"+getIntersectsMinimum(MINLAPS)+\"),\" +\n            i_D + \"(\"+getDisjointMinimum(MINLAPS)+\"),\" +\n            i_bboxD + \"(\"+getBoundingMinimum(MINLAPS)+\")\"\n            + \"  Laps exceeded \" + MINLAPS);\n      }\n\n      Point nearP = randomPointIn(ctx.getWorldBounds());\n\n      S s = generateRandomShape(nearP);\n\n      Rectangle r = randomRectangle(s.getBoundingBox().getCenter());\n\n      SpatialRelation ic = s.relate(r);\n\n      LogRule.log(\"S-R Rel: {}, Shape {}, Rectangle {}\", ic, s, r);\n\n      if (ic != DISJOINT) {\n        assertTrue(\"if not disjoint then the shape's bbox shouldn't be disjoint\",\n            s.getBoundingBox().relate(r).intersects());\n      }\n\n      try {\n        int MAX_TRIES = scaledRandomIntBetween(10, 100);\n        switch (ic) {\n          case CONTAINS:\n            i_C++;\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(r);\n              assertRelation(null, CONTAINS, s, p);\n            }\n            break;\n\n          case WITHIN:\n            i_W++;\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(s);\n              assertRelation(null, CONTAINS, r, p);\n            }\n            break;\n\n          case DISJOINT:\n            if (!s.getBoundingBox().relate(r).intersects()) {//bboxes are disjoint\n              i_bboxD++;\n              if (i_bboxD >= getBoundingMinimum(MINLAPS))\n                break;\n            } else {\n              i_D++;\n            }\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(r);\n              assertRelation(null, DISJOINT, s, p);\n            }\n            break;\n\n          case INTERSECTS:\n            i_I++;\n            SpatialRelation pointR = null;//set once\n            Rectangle randomPointSpace = null;\n            MAX_TRIES = 1000;//give many attempts\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p;\n              if (j < 4) {\n                p = new PointImpl(0, 0, ctx);\n                InfBufLine.cornerByQuadrant(r, j + 1, p);\n              } else {\n                if (randomPointSpace == null) {\n                  if (pointR == DISJOINT) {\n                    randomPointSpace = intersectRects(r,s.getBoundingBox());\n                  } else {//CONTAINS\n                    randomPointSpace = r;\n                  }\n                }\n                p = randomPointIn(randomPointSpace);\n              }\n              SpatialRelation pointRNew = s.relate(p);\n              if (pointR == null) {\n                pointR = pointRNew;\n              } else if (pointR != pointRNew) {\n                break;\n              } else if (j >= MAX_TRIES) {\n                //TODO consider logging instead of failing\n                fail(\"Tried intersection brute-force too many times without success\");\n              }\n            }\n\n            break;\n\n          default: fail(\"\"+ic);\n        } // switch\n      } catch (AssertionError e) {\n        onAssertFail(e, s, r, ic);\n      }\n\n    } // while loop\n\n    System.out.println(\"Laps: \"+laps + \" CWIDbD: \"+i_C+\",\"+i_W+\",\"+i_I+\",\"+i_D+\",\"+i_bboxD);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["aafaf65c7159614a90c78005b3e21b3043b46024"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e53b088890392eebe20b09b16ceb07b5a6778236","date":1430938172,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/RectIntersectionTestHelper#testRelateWithRectangle().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/RectIntersectionTestHelper#testRelateWithRectangle().mjava","sourceNew":"  public void testRelateWithRectangle() {\n    //counters for the different intersection cases\n    int i_C = 0, i_I = 0, i_W = 0, i_D = 0, i_bboxD = 0;\n    int laps = 0;\n    final int MINLAPS = scaledRandomIntBetween(20000, 200000);\n    while(i_C < getContainsMinimum(MINLAPS) || i_I < getIntersectsMinimum(MINLAPS) || i_W < getWithinMinimum(MINLAPS)\n        || (!isRandomShapeRectangular() && i_D < getDisjointMinimum(MINLAPS)) || i_bboxD < getBoundingMinimum(MINLAPS)) {\n      laps++;\n\n      LogRule.clear();\n\n      if (laps > MINLAPS) {\n        fail(\"Did not find enough contains/within/intersection/disjoint/bounds cases in a reasonable number\" +\n            \" of random attempts. CWIDbD: \" +\n            i_C + \"(\"+getContainsMinimum(MINLAPS)+\"),\" +\n            i_W + \"(\"+getWithinMinimum(MINLAPS)+\"),\" +\n            i_I + \"(\"+getIntersectsMinimum(MINLAPS)+\"),\" +\n            i_D + \"(\"+getDisjointMinimum(MINLAPS)+\"),\" +\n            i_bboxD + \"(\"+getBoundingMinimum(MINLAPS)+\")\"\n            + \"  Laps exceeded \" + MINLAPS);\n      }\n\n      Point nearP = randomPointIn(ctx.getWorldBounds());\n\n      S s = generateRandomShape(nearP);\n\n      Rectangle r = randomRectangle(s.getBoundingBox().getCenter());\n\n      SpatialRelation ic = s.relate(r);\n\n      LogRule.log(\"S-R Rel: {}, Shape {}, Rectangle {}\", ic, s, r);\n\n      if (ic != DISJOINT) {\n        assertTrue(\"if not disjoint then the shape's bbox shouldn't be disjoint\",\n            s.getBoundingBox().relate(r).intersects());\n      }\n\n      try {\n        int MAX_TRIES = scaledRandomIntBetween(10, 100);\n        switch (ic) {\n          case CONTAINS:\n            i_C++;\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(r);\n              assertRelation(null, CONTAINS, s, p);\n            }\n            break;\n\n          case WITHIN:\n            i_W++;\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointInOrNull(s);\n              if (p == null) {//couldn't find a random point in shape\n                break;\n              }\n              assertRelation(null, CONTAINS, r, p);\n            }\n            break;\n\n          case DISJOINT:\n            if (!s.getBoundingBox().relate(r).intersects()) {//bboxes are disjoint\n              i_bboxD++;\n              if (i_bboxD >= getBoundingMinimum(MINLAPS))\n                break;\n            } else {\n              i_D++;\n            }\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(r);\n              assertRelation(null, DISJOINT, s, p);\n            }\n            break;\n\n          case INTERSECTS:\n            i_I++;\n            SpatialRelation pointR = null;//set once\n            Rectangle randomPointSpace = null;\n            MAX_TRIES = 1000;//give many attempts\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p;\n              if (j < 4) {\n                p = new PointImpl(0, 0, ctx);\n                InfBufLine.cornerByQuadrant(r, j + 1, p);\n              } else {\n                if (randomPointSpace == null) {\n                  if (pointR == DISJOINT) {\n                    randomPointSpace = intersectRects(r,s.getBoundingBox());\n                  } else {//CONTAINS\n                    randomPointSpace = r;\n                  }\n                }\n                p = randomPointIn(randomPointSpace);\n              }\n              SpatialRelation pointRNew = s.relate(p);\n              if (pointR == null) {\n                pointR = pointRNew;\n              } else if (pointR != pointRNew) {\n                break;\n              } else if (j >= MAX_TRIES) {\n                //TODO consider logging instead of failing\n                fail(\"Tried intersection brute-force too many times without success\");\n              }\n            }\n\n            break;\n\n          default: fail(\"\"+ic);\n        } // switch\n      } catch (AssertionError e) {\n        onAssertFail(e, s, r, ic);\n      }\n\n    } // while loop\n\n    System.out.println(\"Laps: \"+laps + \" CWIDbD: \"+i_C+\",\"+i_W+\",\"+i_I+\",\"+i_D+\",\"+i_bboxD);\n  }\n\n","sourceOld":"  public void testRelateWithRectangle() {\n    //counters for the different intersection cases\n    int i_C = 0, i_I = 0, i_W = 0, i_D = 0, i_bboxD = 0;\n    int laps = 0;\n    final int MINLAPS = scaledRandomIntBetween(20000, 200000);\n    while(i_C < getContainsMinimum(MINLAPS) || i_I < getIntersectsMinimum(MINLAPS) || i_W < getWithinMinimum(MINLAPS)\n        || (!isRandomShapeRectangular() && i_D < getDisjointMinimum(MINLAPS)) || i_bboxD < getBoundingMinimum(MINLAPS)) {\n      laps++;\n\n      LogRule.clear();\n\n      if (laps > MINLAPS) {\n        fail(\"Did not find enough contains/within/intersection/disjoint/bounds cases in a reasonable number\" +\n            \" of random attempts. CWIDbD: \" +\n            i_C + \"(\"+getContainsMinimum(MINLAPS)+\"),\" +\n            i_W + \"(\"+getWithinMinimum(MINLAPS)+\"),\" +\n            i_I + \"(\"+getIntersectsMinimum(MINLAPS)+\"),\" +\n            i_D + \"(\"+getDisjointMinimum(MINLAPS)+\"),\" +\n            i_bboxD + \"(\"+getBoundingMinimum(MINLAPS)+\")\"\n            + \"  Laps exceeded \" + MINLAPS);\n      }\n\n      Point nearP = randomPointIn(ctx.getWorldBounds());\n\n      S s = generateRandomShape(nearP);\n\n      Rectangle r = randomRectangle(s.getBoundingBox().getCenter());\n\n      SpatialRelation ic = s.relate(r);\n\n      LogRule.log(\"S-R Rel: {}, Shape {}, Rectangle {}\", ic, s, r);\n\n      if (ic != DISJOINT) {\n        assertTrue(\"if not disjoint then the shape's bbox shouldn't be disjoint\",\n            s.getBoundingBox().relate(r).intersects());\n      }\n\n      try {\n        int MAX_TRIES = scaledRandomIntBetween(10, 100);\n        switch (ic) {\n          case CONTAINS:\n            i_C++;\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(r);\n              assertRelation(null, CONTAINS, s, p);\n            }\n            break;\n\n          case WITHIN:\n            i_W++;\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(s);\n              assertRelation(null, CONTAINS, r, p);\n            }\n            break;\n\n          case DISJOINT:\n            if (!s.getBoundingBox().relate(r).intersects()) {//bboxes are disjoint\n              i_bboxD++;\n              if (i_bboxD >= getBoundingMinimum(MINLAPS))\n                break;\n            } else {\n              i_D++;\n            }\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(r);\n              assertRelation(null, DISJOINT, s, p);\n            }\n            break;\n\n          case INTERSECTS:\n            i_I++;\n            SpatialRelation pointR = null;//set once\n            Rectangle randomPointSpace = null;\n            MAX_TRIES = 1000;//give many attempts\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p;\n              if (j < 4) {\n                p = new PointImpl(0, 0, ctx);\n                InfBufLine.cornerByQuadrant(r, j + 1, p);\n              } else {\n                if (randomPointSpace == null) {\n                  if (pointR == DISJOINT) {\n                    randomPointSpace = intersectRects(r,s.getBoundingBox());\n                  } else {//CONTAINS\n                    randomPointSpace = r;\n                  }\n                }\n                p = randomPointIn(randomPointSpace);\n              }\n              SpatialRelation pointRNew = s.relate(p);\n              if (pointR == null) {\n                pointR = pointRNew;\n              } else if (pointR != pointRNew) {\n                break;\n              } else if (j >= MAX_TRIES) {\n                //TODO consider logging instead of failing\n                fail(\"Tried intersection brute-force too many times without success\");\n              }\n            }\n\n            break;\n\n          default: fail(\"\"+ic);\n        } // switch\n      } catch (AssertionError e) {\n        onAssertFail(e, s, r, ic);\n      }\n\n    } // while loop\n\n    System.out.println(\"Laps: \"+laps + \" CWIDbD: \"+i_C+\",\"+i_W+\",\"+i_I+\",\"+i_D+\",\"+i_bboxD);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aafaf65c7159614a90c78005b3e21b3043b46024","date":1431404499,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/RectIntersectionTestHelper#testRelateWithRectangle().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/RectIntersectionTestHelper#testRelateWithRectangle().mjava","sourceNew":"  public void testRelateWithRectangle() {\n    //counters for the different intersection cases\n    int i_C = 0, i_I = 0, i_W = 0, i_D = 0, i_bboxD = 0;\n    int laps = 0;\n    final int MINLAPS = scaledRandomIntBetween(20000, 200000);\n    while(i_C < getContainsMinimum(MINLAPS) || i_I < getIntersectsMinimum(MINLAPS) || i_W < getWithinMinimum(MINLAPS)\n        || (!isRandomShapeRectangular() && i_D < getDisjointMinimum(MINLAPS)) || i_bboxD < getBoundingMinimum(MINLAPS)) {\n      laps++;\n\n      LogRule.clear();\n\n      if (laps > MINLAPS) {\n        fail(\"Did not find enough contains/within/intersection/disjoint/bounds cases in a reasonable number\" +\n            \" of random attempts. CWIDbD: \" +\n            i_C + \"(\"+getContainsMinimum(MINLAPS)+\"),\" +\n            i_W + \"(\"+getWithinMinimum(MINLAPS)+\"),\" +\n            i_I + \"(\"+getIntersectsMinimum(MINLAPS)+\"),\" +\n            i_D + \"(\"+getDisjointMinimum(MINLAPS)+\"),\" +\n            i_bboxD + \"(\"+getBoundingMinimum(MINLAPS)+\")\"\n            + \"  Laps exceeded \" + MINLAPS);\n      }\n\n      Point nearP = randomPointIn(ctx.getWorldBounds());\n\n      S s = generateRandomShape(nearP);\n\n      Rectangle r = randomRectangle(s.getBoundingBox().getCenter());\n\n      SpatialRelation ic = s.relate(r);\n\n      LogRule.log(\"S-R Rel: {}, Shape {}, Rectangle {}    lap# {}\", ic, s, r, laps);\n\n      if (ic != DISJOINT) {\n        assertTrue(\"if not disjoint then the shape's bbox shouldn't be disjoint\",\n            s.getBoundingBox().relate(r).intersects());\n      }\n\n      try {\n        int MAX_TRIES = scaledRandomIntBetween(10, 100);\n        switch (ic) {\n          case CONTAINS:\n            i_C++;\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(r);\n              assertRelation(null, CONTAINS, s, p);\n            }\n            break;\n\n          case WITHIN:\n            i_W++;\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointInOrNull(s);\n              if (p == null) {//couldn't find a random point in shape\n                break;\n              }\n              assertRelation(null, CONTAINS, r, p);\n            }\n            break;\n\n          case DISJOINT:\n            if (!s.getBoundingBox().relate(r).intersects()) {//bboxes are disjoint\n              i_bboxD++;\n              if (i_bboxD >= getBoundingMinimum(MINLAPS))\n                break;\n            } else {\n              i_D++;\n            }\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(r);\n              assertRelation(null, DISJOINT, s, p);\n            }\n            break;\n\n          case INTERSECTS:\n            i_I++;\n            SpatialRelation pointR = null;//set once\n            Rectangle randomPointSpace = null;\n            MAX_TRIES = 1000;//give many attempts\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p;\n              if (j < 4) {\n                p = new PointImpl(0, 0, ctx);\n                InfBufLine.cornerByQuadrant(r, j + 1, p);\n              } else {\n                if (randomPointSpace == null) {\n                  if (pointR == DISJOINT) {\n                    randomPointSpace = intersectRects(r,s.getBoundingBox());\n                  } else {//CONTAINS\n                    randomPointSpace = r;\n                  }\n                }\n                p = randomPointIn(randomPointSpace);\n              }\n              SpatialRelation pointRNew = s.relate(p);\n              if (pointR == null) {\n                pointR = pointRNew;\n              } else if (pointR != pointRNew) {\n                break;\n              } else if (j >= MAX_TRIES) {\n                //TODO consider logging instead of failing\n                fail(\"Tried intersection brute-force too many times without success\");\n              }\n            }\n\n            break;\n\n          default: fail(\"\"+ic);\n        } // switch\n      } catch (AssertionError e) {\n        onAssertFail(e, s, r, ic);\n      }\n\n    } // while loop\n\n    System.out.println(\"Laps: \"+laps + \" CWIDbD: \"+i_C+\",\"+i_W+\",\"+i_I+\",\"+i_D+\",\"+i_bboxD);\n  }\n\n","sourceOld":"  public void testRelateWithRectangle() {\n    //counters for the different intersection cases\n    int i_C = 0, i_I = 0, i_W = 0, i_D = 0, i_bboxD = 0;\n    int laps = 0;\n    final int MINLAPS = scaledRandomIntBetween(20000, 200000);\n    while(i_C < getContainsMinimum(MINLAPS) || i_I < getIntersectsMinimum(MINLAPS) || i_W < getWithinMinimum(MINLAPS)\n        || (!isRandomShapeRectangular() && i_D < getDisjointMinimum(MINLAPS)) || i_bboxD < getBoundingMinimum(MINLAPS)) {\n      laps++;\n\n      LogRule.clear();\n\n      if (laps > MINLAPS) {\n        fail(\"Did not find enough contains/within/intersection/disjoint/bounds cases in a reasonable number\" +\n            \" of random attempts. CWIDbD: \" +\n            i_C + \"(\"+getContainsMinimum(MINLAPS)+\"),\" +\n            i_W + \"(\"+getWithinMinimum(MINLAPS)+\"),\" +\n            i_I + \"(\"+getIntersectsMinimum(MINLAPS)+\"),\" +\n            i_D + \"(\"+getDisjointMinimum(MINLAPS)+\"),\" +\n            i_bboxD + \"(\"+getBoundingMinimum(MINLAPS)+\")\"\n            + \"  Laps exceeded \" + MINLAPS);\n      }\n\n      Point nearP = randomPointIn(ctx.getWorldBounds());\n\n      S s = generateRandomShape(nearP);\n\n      Rectangle r = randomRectangle(s.getBoundingBox().getCenter());\n\n      SpatialRelation ic = s.relate(r);\n\n      LogRule.log(\"S-R Rel: {}, Shape {}, Rectangle {}\", ic, s, r);\n\n      if (ic != DISJOINT) {\n        assertTrue(\"if not disjoint then the shape's bbox shouldn't be disjoint\",\n            s.getBoundingBox().relate(r).intersects());\n      }\n\n      try {\n        int MAX_TRIES = scaledRandomIntBetween(10, 100);\n        switch (ic) {\n          case CONTAINS:\n            i_C++;\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(r);\n              assertRelation(null, CONTAINS, s, p);\n            }\n            break;\n\n          case WITHIN:\n            i_W++;\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointInOrNull(s);\n              if (p == null) {//couldn't find a random point in shape\n                break;\n              }\n              assertRelation(null, CONTAINS, r, p);\n            }\n            break;\n\n          case DISJOINT:\n            if (!s.getBoundingBox().relate(r).intersects()) {//bboxes are disjoint\n              i_bboxD++;\n              if (i_bboxD >= getBoundingMinimum(MINLAPS))\n                break;\n            } else {\n              i_D++;\n            }\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(r);\n              assertRelation(null, DISJOINT, s, p);\n            }\n            break;\n\n          case INTERSECTS:\n            i_I++;\n            SpatialRelation pointR = null;//set once\n            Rectangle randomPointSpace = null;\n            MAX_TRIES = 1000;//give many attempts\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p;\n              if (j < 4) {\n                p = new PointImpl(0, 0, ctx);\n                InfBufLine.cornerByQuadrant(r, j + 1, p);\n              } else {\n                if (randomPointSpace == null) {\n                  if (pointR == DISJOINT) {\n                    randomPointSpace = intersectRects(r,s.getBoundingBox());\n                  } else {//CONTAINS\n                    randomPointSpace = r;\n                  }\n                }\n                p = randomPointIn(randomPointSpace);\n              }\n              SpatialRelation pointRNew = s.relate(p);\n              if (pointR == null) {\n                pointR = pointRNew;\n              } else if (pointR != pointRNew) {\n                break;\n              } else if (j >= MAX_TRIES) {\n                //TODO consider logging instead of failing\n                fail(\"Tried intersection brute-force too many times without success\");\n              }\n            }\n\n            break;\n\n          default: fail(\"\"+ic);\n        } // switch\n      } catch (AssertionError e) {\n        onAssertFail(e, s, r, ic);\n      }\n\n    } // while loop\n\n    System.out.println(\"Laps: \"+laps + \" CWIDbD: \"+i_C+\",\"+i_W+\",\"+i_I+\",\"+i_D+\",\"+i_bboxD);\n  }\n\n","bugFix":["c921d81476f94b6686d3f216daa1f6b076b4a6c0"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f272fa1627d87a9082502801ea6cb7fa2d71150","date":1434169192,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/RectIntersectionTestHelper#testRelateWithRectangle().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/RectIntersectionTestHelper#testRelateWithRectangle().mjava","sourceNew":"  public void testRelateWithRectangle() {\n    //counters for the different intersection cases\n    int i_C = 0, i_I = 0, i_W = 0, i_D = 0, i_bboxD = 0;\n    int lap = 0;\n    final int MAXLAPS = getMaxLaps();\n    while(i_C < getContainsMinimum(MAXLAPS) || i_I < getIntersectsMinimum(MAXLAPS) || i_W < getWithinMinimum(MAXLAPS)\n        || (!isRandomShapeRectangular() && i_D < getDisjointMinimum(MAXLAPS)) || i_bboxD < getBoundingMinimum(MAXLAPS)) {\n      lap++;\n\n      LogRule.clear();\n\n      if (lap > MAXLAPS) {\n        fail(\"Did not find enough contains/within/intersection/disjoint/bounds cases in a reasonable number\" +\n            \" of attempts. CWIDbD: \" +\n            i_C + \"(\"+getContainsMinimum(MAXLAPS)+\"),\" +\n            i_W + \"(\"+getWithinMinimum(MAXLAPS)+\"),\" +\n            i_I + \"(\"+getIntersectsMinimum(MAXLAPS)+\"),\" +\n            i_D + \"(\"+getDisjointMinimum(MAXLAPS)+\"),\" +\n            i_bboxD + \"(\"+getBoundingMinimum(MAXLAPS)+\")\"\n            + \"  Laps exceeded \" + MAXLAPS);\n      }\n\n      Point nearP = randomPointIn(ctx.getWorldBounds());\n\n      S s = generateRandomShape(nearP);\n\n      Rectangle r = randomRectangle(s.getBoundingBox().getCenter());\n\n      SpatialRelation ic = s.relate(r);\n\n      LogRule.log(\"S-R Rel: {}, Shape {}, Rectangle {}    lap# {}\", ic, s, r, lap);\n\n      if (ic != DISJOINT) {\n        assertTrue(\"if not disjoint then the shape's bbox shouldn't be disjoint\",\n            s.getBoundingBox().relate(r).intersects());\n      }\n\n      try {\n        int MAX_TRIES = scaledRandomIntBetween(10, 100);\n        switch (ic) {\n          case CONTAINS:\n            i_C++;\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(r);\n              assertRelation(null, CONTAINS, s, p);\n            }\n            break;\n\n          case WITHIN:\n            i_W++;\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointInOrNull(s);\n              if (p == null) {//couldn't find a random point in shape\n                break;\n              }\n              assertRelation(null, CONTAINS, r, p);\n            }\n            break;\n\n          case DISJOINT:\n            if (!s.getBoundingBox().relate(r).intersects()) {//bboxes are disjoint\n              i_bboxD++;\n              if (i_bboxD >= getBoundingMinimum(MAXLAPS))\n                break;\n            } else {\n              i_D++;\n            }\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(r);\n              assertRelation(null, DISJOINT, s, p);\n            }\n            break;\n\n          case INTERSECTS:\n            i_I++;\n            SpatialRelation pointR = null;//set once\n            Rectangle randomPointSpace = null;\n            MAX_TRIES = 1000;//give many attempts\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p;\n              if (j < 4) {\n                p = new PointImpl(0, 0, ctx);\n                InfBufLine.cornerByQuadrant(r, j + 1, p);\n              } else {\n                if (randomPointSpace == null) {\n                  if (pointR == DISJOINT) {\n                    randomPointSpace = intersectRects(r,s.getBoundingBox());\n                  } else {//CONTAINS\n                    randomPointSpace = r;\n                  }\n                }\n                p = randomPointIn(randomPointSpace);\n              }\n              SpatialRelation pointRNew = s.relate(p);\n              if (pointR == null) {\n                pointR = pointRNew;\n              } else if (pointR != pointRNew) {\n                break;\n              } else if (j >= MAX_TRIES) {\n                //TODO consider logging instead of failing\n                fail(\"Tried intersection brute-force too many times without success\");\n              }\n            }\n\n            break;\n\n          default: fail(\"\"+ic);\n        } // switch\n      } catch (AssertionError e) {\n        onAssertFail(e, s, r, ic);\n      }\n\n    } // while loop\n\n    System.out.println(\"Laps: \"+lap + \" CWIDbD: \"+i_C+\",\"+i_W+\",\"+i_I+\",\"+i_D+\",\"+i_bboxD);\n  }\n\n","sourceOld":"  public void testRelateWithRectangle() {\n    //counters for the different intersection cases\n    int i_C = 0, i_I = 0, i_W = 0, i_D = 0, i_bboxD = 0;\n    int laps = 0;\n    final int MINLAPS = scaledRandomIntBetween(20000, 200000);\n    while(i_C < getContainsMinimum(MINLAPS) || i_I < getIntersectsMinimum(MINLAPS) || i_W < getWithinMinimum(MINLAPS)\n        || (!isRandomShapeRectangular() && i_D < getDisjointMinimum(MINLAPS)) || i_bboxD < getBoundingMinimum(MINLAPS)) {\n      laps++;\n\n      LogRule.clear();\n\n      if (laps > MINLAPS) {\n        fail(\"Did not find enough contains/within/intersection/disjoint/bounds cases in a reasonable number\" +\n            \" of random attempts. CWIDbD: \" +\n            i_C + \"(\"+getContainsMinimum(MINLAPS)+\"),\" +\n            i_W + \"(\"+getWithinMinimum(MINLAPS)+\"),\" +\n            i_I + \"(\"+getIntersectsMinimum(MINLAPS)+\"),\" +\n            i_D + \"(\"+getDisjointMinimum(MINLAPS)+\"),\" +\n            i_bboxD + \"(\"+getBoundingMinimum(MINLAPS)+\")\"\n            + \"  Laps exceeded \" + MINLAPS);\n      }\n\n      Point nearP = randomPointIn(ctx.getWorldBounds());\n\n      S s = generateRandomShape(nearP);\n\n      Rectangle r = randomRectangle(s.getBoundingBox().getCenter());\n\n      SpatialRelation ic = s.relate(r);\n\n      LogRule.log(\"S-R Rel: {}, Shape {}, Rectangle {}    lap# {}\", ic, s, r, laps);\n\n      if (ic != DISJOINT) {\n        assertTrue(\"if not disjoint then the shape's bbox shouldn't be disjoint\",\n            s.getBoundingBox().relate(r).intersects());\n      }\n\n      try {\n        int MAX_TRIES = scaledRandomIntBetween(10, 100);\n        switch (ic) {\n          case CONTAINS:\n            i_C++;\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(r);\n              assertRelation(null, CONTAINS, s, p);\n            }\n            break;\n\n          case WITHIN:\n            i_W++;\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointInOrNull(s);\n              if (p == null) {//couldn't find a random point in shape\n                break;\n              }\n              assertRelation(null, CONTAINS, r, p);\n            }\n            break;\n\n          case DISJOINT:\n            if (!s.getBoundingBox().relate(r).intersects()) {//bboxes are disjoint\n              i_bboxD++;\n              if (i_bboxD >= getBoundingMinimum(MINLAPS))\n                break;\n            } else {\n              i_D++;\n            }\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(r);\n              assertRelation(null, DISJOINT, s, p);\n            }\n            break;\n\n          case INTERSECTS:\n            i_I++;\n            SpatialRelation pointR = null;//set once\n            Rectangle randomPointSpace = null;\n            MAX_TRIES = 1000;//give many attempts\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p;\n              if (j < 4) {\n                p = new PointImpl(0, 0, ctx);\n                InfBufLine.cornerByQuadrant(r, j + 1, p);\n              } else {\n                if (randomPointSpace == null) {\n                  if (pointR == DISJOINT) {\n                    randomPointSpace = intersectRects(r,s.getBoundingBox());\n                  } else {//CONTAINS\n                    randomPointSpace = r;\n                  }\n                }\n                p = randomPointIn(randomPointSpace);\n              }\n              SpatialRelation pointRNew = s.relate(p);\n              if (pointR == null) {\n                pointR = pointRNew;\n              } else if (pointR != pointRNew) {\n                break;\n              } else if (j >= MAX_TRIES) {\n                //TODO consider logging instead of failing\n                fail(\"Tried intersection brute-force too many times without success\");\n              }\n            }\n\n            break;\n\n          default: fail(\"\"+ic);\n        } // switch\n      } catch (AssertionError e) {\n        onAssertFail(e, s, r, ic);\n      }\n\n    } // while loop\n\n    System.out.println(\"Laps: \"+laps + \" CWIDbD: \"+i_C+\",\"+i_W+\",\"+i_I+\",\"+i_D+\",\"+i_bboxD);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bf5e612561242a48ae4523531000b80864f864cf","date":1442976403,"type":4,"author":"David Wayne Smiley","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/RectIntersectionTestHelper#testRelateWithRectangle().mjava","sourceNew":null,"sourceOld":"  public void testRelateWithRectangle() {\n    //counters for the different intersection cases\n    int i_C = 0, i_I = 0, i_W = 0, i_D = 0, i_bboxD = 0;\n    int lap = 0;\n    final int MAXLAPS = getMaxLaps();\n    while(i_C < getContainsMinimum(MAXLAPS) || i_I < getIntersectsMinimum(MAXLAPS) || i_W < getWithinMinimum(MAXLAPS)\n        || (!isRandomShapeRectangular() && i_D < getDisjointMinimum(MAXLAPS)) || i_bboxD < getBoundingMinimum(MAXLAPS)) {\n      lap++;\n\n      LogRule.clear();\n\n      if (lap > MAXLAPS) {\n        fail(\"Did not find enough contains/within/intersection/disjoint/bounds cases in a reasonable number\" +\n            \" of attempts. CWIDbD: \" +\n            i_C + \"(\"+getContainsMinimum(MAXLAPS)+\"),\" +\n            i_W + \"(\"+getWithinMinimum(MAXLAPS)+\"),\" +\n            i_I + \"(\"+getIntersectsMinimum(MAXLAPS)+\"),\" +\n            i_D + \"(\"+getDisjointMinimum(MAXLAPS)+\"),\" +\n            i_bboxD + \"(\"+getBoundingMinimum(MAXLAPS)+\")\"\n            + \"  Laps exceeded \" + MAXLAPS);\n      }\n\n      Point nearP = randomPointIn(ctx.getWorldBounds());\n\n      S s = generateRandomShape(nearP);\n\n      Rectangle r = randomRectangle(s.getBoundingBox().getCenter());\n\n      SpatialRelation ic = s.relate(r);\n\n      LogRule.log(\"S-R Rel: {}, Shape {}, Rectangle {}    lap# {}\", ic, s, r, lap);\n\n      if (ic != DISJOINT) {\n        assertTrue(\"if not disjoint then the shape's bbox shouldn't be disjoint\",\n            s.getBoundingBox().relate(r).intersects());\n      }\n\n      try {\n        int MAX_TRIES = scaledRandomIntBetween(10, 100);\n        switch (ic) {\n          case CONTAINS:\n            i_C++;\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(r);\n              assertRelation(null, CONTAINS, s, p);\n            }\n            break;\n\n          case WITHIN:\n            i_W++;\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointInOrNull(s);\n              if (p == null) {//couldn't find a random point in shape\n                break;\n              }\n              assertRelation(null, CONTAINS, r, p);\n            }\n            break;\n\n          case DISJOINT:\n            if (!s.getBoundingBox().relate(r).intersects()) {//bboxes are disjoint\n              i_bboxD++;\n              if (i_bboxD >= getBoundingMinimum(MAXLAPS))\n                break;\n            } else {\n              i_D++;\n            }\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p = randomPointIn(r);\n              assertRelation(null, DISJOINT, s, p);\n            }\n            break;\n\n          case INTERSECTS:\n            i_I++;\n            SpatialRelation pointR = null;//set once\n            Rectangle randomPointSpace = null;\n            MAX_TRIES = 1000;//give many attempts\n            for (int j = 0; j < MAX_TRIES; j++) {\n              Point p;\n              if (j < 4) {\n                p = new PointImpl(0, 0, ctx);\n                InfBufLine.cornerByQuadrant(r, j + 1, p);\n              } else {\n                if (randomPointSpace == null) {\n                  if (pointR == DISJOINT) {\n                    randomPointSpace = intersectRects(r,s.getBoundingBox());\n                  } else {//CONTAINS\n                    randomPointSpace = r;\n                  }\n                }\n                p = randomPointIn(randomPointSpace);\n              }\n              SpatialRelation pointRNew = s.relate(p);\n              if (pointR == null) {\n                pointR = pointRNew;\n              } else if (pointR != pointRNew) {\n                break;\n              } else if (j >= MAX_TRIES) {\n                //TODO consider logging instead of failing\n                fail(\"Tried intersection brute-force too many times without success\");\n              }\n            }\n\n            break;\n\n          default: fail(\"\"+ic);\n        } // switch\n      } catch (AssertionError e) {\n        onAssertFail(e, s, r, ic);\n      }\n\n    } // while loop\n\n    System.out.println(\"Laps: \"+lap + \" CWIDbD: \"+i_C+\",\"+i_W+\",\"+i_I+\",\"+i_D+\",\"+i_bboxD);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f7486946d77195121edad36d1ee2b45e5c231041":["8fc7b597b2d21a932a857539efde49f09ec86ba0"],"aafaf65c7159614a90c78005b3e21b3043b46024":["e53b088890392eebe20b09b16ceb07b5a6778236"],"e53b088890392eebe20b09b16ceb07b5a6778236":["c921d81476f94b6686d3f216daa1f6b076b4a6c0"],"8fc7b597b2d21a932a857539efde49f09ec86ba0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3f272fa1627d87a9082502801ea6cb7fa2d71150":["aafaf65c7159614a90c78005b3e21b3043b46024"],"a5079b556f19f6e82e97b91cc3e617bec55c4d9c":["9f29148b9875bb4ec843fd6c03ee6291236c7b88"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bf5e612561242a48ae4523531000b80864f864cf":["3f272fa1627d87a9082502801ea6cb7fa2d71150"],"c921d81476f94b6686d3f216daa1f6b076b4a6c0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a5079b556f19f6e82e97b91cc3e617bec55c4d9c"],"9f29148b9875bb4ec843fd6c03ee6291236c7b88":["f7486946d77195121edad36d1ee2b45e5c231041"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bf5e612561242a48ae4523531000b80864f864cf"]},"commit2Childs":{"f7486946d77195121edad36d1ee2b45e5c231041":["9f29148b9875bb4ec843fd6c03ee6291236c7b88"],"8fc7b597b2d21a932a857539efde49f09ec86ba0":["f7486946d77195121edad36d1ee2b45e5c231041"],"aafaf65c7159614a90c78005b3e21b3043b46024":["3f272fa1627d87a9082502801ea6cb7fa2d71150"],"e53b088890392eebe20b09b16ceb07b5a6778236":["aafaf65c7159614a90c78005b3e21b3043b46024"],"3f272fa1627d87a9082502801ea6cb7fa2d71150":["bf5e612561242a48ae4523531000b80864f864cf"],"a5079b556f19f6e82e97b91cc3e617bec55c4d9c":["c921d81476f94b6686d3f216daa1f6b076b4a6c0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8fc7b597b2d21a932a857539efde49f09ec86ba0","c921d81476f94b6686d3f216daa1f6b076b4a6c0"],"bf5e612561242a48ae4523531000b80864f864cf":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c921d81476f94b6686d3f216daa1f6b076b4a6c0":["e53b088890392eebe20b09b16ceb07b5a6778236"],"9f29148b9875bb4ec843fd6c03ee6291236c7b88":["a5079b556f19f6e82e97b91cc3e617bec55c4d9c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}