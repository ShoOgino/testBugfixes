{"path":"lucene/core/src/test/org/apache/lucene/search/TestSort#testRandomStringSort().mjava","commits":[{"id":"b7523dd562634d9145b67eb4c8b3b3db2340532b","date":1330467618,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#testRandomStringSort().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandomStringSort() throws Exception {\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final String s;\n      if (random.nextBoolean()) {\n        s = _TestUtil.randomSimpleString(random, maxLength);\n      } else {\n        s = _TestUtil.randomUnicodeString(random, maxLength);\n      }\n      final BytesRef br = new BytesRef(s);\n\n      if (!allowDups) {\n        if (seen.contains(s)) {\n          continue;\n        }\n        seen.add(s);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + numDocs + \": s=\" + s);\n      }\n      \n      final Document doc = new Document();\n      doc.add(new DocValuesField(\"stringdv\", br, DocValues.Type.BYTES_VAR_SORTED));\n      doc.add(newField(\"string\", s, StringField.TYPE_UNSTORED));\n      doc.add(new DocValuesField(\"id\", numDocs, DocValues.Type.VAR_INTS));\n      docValues.add(br);\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n      final TopFieldDocs hits;\n      final SortField sf;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n        sf.setUseIndexValues(true);\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n      }\n      final Sort sort = new Sort(sf);\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      if (random.nextBoolean()) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount,\n                        sort);\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f,\n                        hitCount,\n                        sort);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues);\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          System.out.println(\"    \" + idx + \": \" + expected.get(idx).utf8ToString());\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          System.out.println(\"    \" + hitIDX + \": \" + ((BytesRef) fd.fields[0]).utf8ToString());\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        assertEquals(expected.get(hitIDX), (BytesRef) fd.fields[0]);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["04f07771a2a7dd3a395700665ed839c3dae2def2","d4d69c535930b5cce125cff868d40f6373dc27d4","cd659803551ebd8ca09b9e4ad7abd18d3d558f9d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6d8cbdadfe95a15fad972438ce43d97dfb7b152d","date":1330507165,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#testRandomStringSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#testRandomStringSort().mjava","sourceNew":"  public void testRandomStringSort() throws Exception {\n    assumeTrue(\"cannot work with Lucene3x codec\",\n               defaultCodecSupportsDocValues());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final String s;\n      if (random.nextBoolean()) {\n        s = _TestUtil.randomSimpleString(random, maxLength);\n      } else {\n        s = _TestUtil.randomUnicodeString(random, maxLength);\n      }\n      final BytesRef br = new BytesRef(s);\n\n      if (!allowDups) {\n        if (seen.contains(s)) {\n          continue;\n        }\n        seen.add(s);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + numDocs + \": s=\" + s);\n      }\n      \n      final Document doc = new Document();\n      doc.add(new DocValuesField(\"stringdv\", br, DocValues.Type.BYTES_VAR_SORTED));\n      doc.add(newField(\"string\", s, StringField.TYPE_UNSTORED));\n      doc.add(new DocValuesField(\"id\", numDocs, DocValues.Type.VAR_INTS));\n      docValues.add(br);\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n      final TopFieldDocs hits;\n      final SortField sf;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n        sf.setUseIndexValues(true);\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n      }\n      final Sort sort = new Sort(sf);\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      if (random.nextBoolean()) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount,\n                        sort);\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f,\n                        hitCount,\n                        sort);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues);\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          System.out.println(\"    \" + idx + \": \" + expected.get(idx).utf8ToString());\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          System.out.println(\"    \" + hitIDX + \": \" + ((BytesRef) fd.fields[0]).utf8ToString());\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        assertEquals(expected.get(hitIDX), (BytesRef) fd.fields[0]);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStringSort() throws Exception {\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final String s;\n      if (random.nextBoolean()) {\n        s = _TestUtil.randomSimpleString(random, maxLength);\n      } else {\n        s = _TestUtil.randomUnicodeString(random, maxLength);\n      }\n      final BytesRef br = new BytesRef(s);\n\n      if (!allowDups) {\n        if (seen.contains(s)) {\n          continue;\n        }\n        seen.add(s);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + numDocs + \": s=\" + s);\n      }\n      \n      final Document doc = new Document();\n      doc.add(new DocValuesField(\"stringdv\", br, DocValues.Type.BYTES_VAR_SORTED));\n      doc.add(newField(\"string\", s, StringField.TYPE_UNSTORED));\n      doc.add(new DocValuesField(\"id\", numDocs, DocValues.Type.VAR_INTS));\n      docValues.add(br);\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n      final TopFieldDocs hits;\n      final SortField sf;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n        sf.setUseIndexValues(true);\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n      }\n      final Sort sort = new Sort(sf);\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      if (random.nextBoolean()) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount,\n                        sort);\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f,\n                        hitCount,\n                        sort);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues);\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          System.out.println(\"    \" + idx + \": \" + expected.get(idx).utf8ToString());\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          System.out.println(\"    \" + hitIDX + \": \" + ((BytesRef) fd.fields[0]).utf8ToString());\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        assertEquals(expected.get(hitIDX), (BytesRef) fd.fields[0]);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":0,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#testRandomStringSort().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandomStringSort() throws Exception {\n    assumeTrue(\"cannot work with Lucene3x codec\",\n               defaultCodecSupportsDocValues());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final String s;\n      if (random.nextBoolean()) {\n        s = _TestUtil.randomSimpleString(random, maxLength);\n      } else {\n        s = _TestUtil.randomUnicodeString(random, maxLength);\n      }\n      final BytesRef br = new BytesRef(s);\n\n      if (!allowDups) {\n        if (seen.contains(s)) {\n          continue;\n        }\n        seen.add(s);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + numDocs + \": s=\" + s);\n      }\n      \n      final Document doc = new Document();\n      doc.add(new DocValuesField(\"stringdv\", br, DocValues.Type.BYTES_VAR_SORTED));\n      doc.add(newField(\"string\", s, StringField.TYPE_UNSTORED));\n      doc.add(new DocValuesField(\"id\", numDocs, DocValues.Type.VAR_INTS));\n      docValues.add(br);\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n      final TopFieldDocs hits;\n      final SortField sf;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n        sf.setUseIndexValues(true);\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n      }\n      final Sort sort = new Sort(sf);\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      if (random.nextBoolean()) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount,\n                        sort);\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f,\n                        hitCount,\n                        sort);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues);\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          System.out.println(\"    \" + idx + \": \" + expected.get(idx).utf8ToString());\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          System.out.println(\"    \" + hitIDX + \": \" + ((BytesRef) fd.fields[0]).utf8ToString());\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        assertEquals(expected.get(hitIDX), (BytesRef) fd.fields[0]);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#testRandomStringSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#testRandomStringSort().mjava","sourceNew":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n    assumeTrue(\"cannot work with Lucene3x codec\",\n               defaultCodecSupportsDocValues());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final String s;\n      if (random.nextBoolean()) {\n        s = _TestUtil.randomSimpleString(random, maxLength);\n      } else {\n        s = _TestUtil.randomUnicodeString(random, maxLength);\n      }\n      final BytesRef br = new BytesRef(s);\n\n      if (!allowDups) {\n        if (seen.contains(s)) {\n          continue;\n        }\n        seen.add(s);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + numDocs + \": s=\" + s);\n      }\n      \n      final Document doc = new Document();\n      doc.add(new DocValuesField(\"stringdv\", br, DocValues.Type.BYTES_VAR_SORTED));\n      doc.add(newField(\"string\", s, StringField.TYPE_UNSTORED));\n      doc.add(new DocValuesField(\"id\", numDocs, DocValues.Type.VAR_INTS));\n      docValues.add(br);\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n      final TopFieldDocs hits;\n      final SortField sf;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n        sf.setUseIndexValues(true);\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n      }\n      final Sort sort = new Sort(sf);\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      if (random.nextBoolean()) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount,\n                        sort);\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f,\n                        hitCount,\n                        sort);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues);\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          System.out.println(\"    \" + idx + \": \" + expected.get(idx).utf8ToString());\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          System.out.println(\"    \" + hitIDX + \": \" + ((BytesRef) fd.fields[0]).utf8ToString());\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        assertEquals(expected.get(hitIDX), (BytesRef) fd.fields[0]);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStringSort() throws Exception {\n    assumeTrue(\"cannot work with Lucene3x codec\",\n               defaultCodecSupportsDocValues());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final String s;\n      if (random.nextBoolean()) {\n        s = _TestUtil.randomSimpleString(random, maxLength);\n      } else {\n        s = _TestUtil.randomUnicodeString(random, maxLength);\n      }\n      final BytesRef br = new BytesRef(s);\n\n      if (!allowDups) {\n        if (seen.contains(s)) {\n          continue;\n        }\n        seen.add(s);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + numDocs + \": s=\" + s);\n      }\n      \n      final Document doc = new Document();\n      doc.add(new DocValuesField(\"stringdv\", br, DocValues.Type.BYTES_VAR_SORTED));\n      doc.add(newField(\"string\", s, StringField.TYPE_UNSTORED));\n      doc.add(new DocValuesField(\"id\", numDocs, DocValues.Type.VAR_INTS));\n      docValues.add(br);\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n      final TopFieldDocs hits;\n      final SortField sf;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n        sf.setUseIndexValues(true);\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n      }\n      final Sort sort = new Sort(sf);\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      if (random.nextBoolean()) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount,\n                        sort);\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f,\n                        hitCount,\n                        sort);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues);\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          System.out.println(\"    \" + idx + \": \" + expected.get(idx).utf8ToString());\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          System.out.println(\"    \" + hitIDX + \": \" + ((BytesRef) fd.fields[0]).utf8ToString());\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        assertEquals(expected.get(hitIDX), (BytesRef) fd.fields[0]);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cd659803551ebd8ca09b9e4ad7abd18d3d558f9d","date":1336650316,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#testRandomStringSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#testRandomStringSort().mjava","sourceNew":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n    assumeTrue(\"cannot work with Lucene3x codec\",\n               defaultCodecSupportsDocValues());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final String s;\n      if (random.nextBoolean()) {\n        s = _TestUtil.randomSimpleString(random, maxLength);\n      } else {\n        s = _TestUtil.randomUnicodeString(random, maxLength);\n      }\n      final BytesRef br = new BytesRef(s);\n\n      if (!allowDups) {\n        if (seen.contains(s)) {\n          continue;\n        }\n        seen.add(s);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + numDocs + \": s=\" + s);\n      }\n      \n      final Document doc = new Document();\n      doc.add(new SortedBytesDocValuesField(\"stringdv\", br));\n      doc.add(newField(\"string\", s, StringField.TYPE_UNSTORED));\n      doc.add(new PackedLongDocValuesField(\"id\", numDocs));\n      docValues.add(br);\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n      final TopFieldDocs hits;\n      final SortField sf;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n        sf.setUseIndexValues(true);\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n      }\n      final Sort sort = new Sort(sf);\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      if (random.nextBoolean()) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount,\n                        sort);\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f,\n                        hitCount,\n                        sort);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues);\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          System.out.println(\"    \" + idx + \": \" + expected.get(idx).utf8ToString());\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          System.out.println(\"    \" + hitIDX + \": \" + ((BytesRef) fd.fields[0]).utf8ToString());\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        assertEquals(expected.get(hitIDX), (BytesRef) fd.fields[0]);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n    assumeTrue(\"cannot work with Lucene3x codec\",\n               defaultCodecSupportsDocValues());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final String s;\n      if (random.nextBoolean()) {\n        s = _TestUtil.randomSimpleString(random, maxLength);\n      } else {\n        s = _TestUtil.randomUnicodeString(random, maxLength);\n      }\n      final BytesRef br = new BytesRef(s);\n\n      if (!allowDups) {\n        if (seen.contains(s)) {\n          continue;\n        }\n        seen.add(s);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + numDocs + \": s=\" + s);\n      }\n      \n      final Document doc = new Document();\n      doc.add(new DocValuesField(\"stringdv\", br, DocValues.Type.BYTES_VAR_SORTED));\n      doc.add(newField(\"string\", s, StringField.TYPE_UNSTORED));\n      doc.add(new DocValuesField(\"id\", numDocs, DocValues.Type.VAR_INTS));\n      docValues.add(br);\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n      final TopFieldDocs hits;\n      final SortField sf;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n        sf.setUseIndexValues(true);\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n      }\n      final Sort sort = new Sort(sf);\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      if (random.nextBoolean()) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount,\n                        sort);\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f,\n                        hitCount,\n                        sort);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues);\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          System.out.println(\"    \" + idx + \": \" + expected.get(idx).utf8ToString());\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          System.out.println(\"    \" + hitIDX + \": \" + ((BytesRef) fd.fields[0]).utf8ToString());\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        assertEquals(expected.get(hitIDX), (BytesRef) fd.fields[0]);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":["b7523dd562634d9145b67eb4c8b3b3db2340532b"],"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"57ae3024996ccdb3c36c42cb890e1efb37df4ce8","date":1338343651,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#testRandomStringSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#testRandomStringSort().mjava","sourceNew":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final String s;\n      if (random.nextBoolean()) {\n        s = _TestUtil.randomSimpleString(random, maxLength);\n      } else {\n        s = _TestUtil.randomUnicodeString(random, maxLength);\n      }\n      final BytesRef br = new BytesRef(s);\n\n      if (!allowDups) {\n        if (seen.contains(s)) {\n          continue;\n        }\n        seen.add(s);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + numDocs + \": s=\" + s);\n      }\n      \n      final Document doc = new Document();\n      doc.add(new SortedBytesDocValuesField(\"stringdv\", br));\n      doc.add(newField(\"string\", s, StringField.TYPE_UNSTORED));\n      doc.add(new PackedLongDocValuesField(\"id\", numDocs));\n      docValues.add(br);\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n      final TopFieldDocs hits;\n      final SortField sf;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n        sf.setUseIndexValues(true);\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n      }\n      final Sort sort = new Sort(sf);\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      if (random.nextBoolean()) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount,\n                        sort);\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f,\n                        hitCount,\n                        sort);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues);\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          System.out.println(\"    \" + idx + \": \" + expected.get(idx).utf8ToString());\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          System.out.println(\"    \" + hitIDX + \": \" + ((BytesRef) fd.fields[0]).utf8ToString());\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        assertEquals(expected.get(hitIDX), (BytesRef) fd.fields[0]);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n    assumeTrue(\"cannot work with Lucene3x codec\",\n               defaultCodecSupportsDocValues());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final String s;\n      if (random.nextBoolean()) {\n        s = _TestUtil.randomSimpleString(random, maxLength);\n      } else {\n        s = _TestUtil.randomUnicodeString(random, maxLength);\n      }\n      final BytesRef br = new BytesRef(s);\n\n      if (!allowDups) {\n        if (seen.contains(s)) {\n          continue;\n        }\n        seen.add(s);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + numDocs + \": s=\" + s);\n      }\n      \n      final Document doc = new Document();\n      doc.add(new SortedBytesDocValuesField(\"stringdv\", br));\n      doc.add(newField(\"string\", s, StringField.TYPE_UNSTORED));\n      doc.add(new PackedLongDocValuesField(\"id\", numDocs));\n      docValues.add(br);\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n      final TopFieldDocs hits;\n      final SortField sf;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n        sf.setUseIndexValues(true);\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n      }\n      final Sort sort = new Sort(sf);\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      if (random.nextBoolean()) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount,\n                        sort);\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f,\n                        hitCount,\n                        sort);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues);\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          System.out.println(\"    \" + idx + \": \" + expected.get(idx).utf8ToString());\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          System.out.println(\"    \" + hitIDX + \": \" + ((BytesRef) fd.fields[0]).utf8ToString());\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        assertEquals(expected.get(hitIDX), (BytesRef) fd.fields[0]);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"04f07771a2a7dd3a395700665ed839c3dae2def2","date":1339350139,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#testRandomStringSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#testRandomStringSort().mjava","sourceNew":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final String s;\n      if (random.nextBoolean()) {\n        s = _TestUtil.randomSimpleString(random, maxLength);\n      } else {\n        s = _TestUtil.randomUnicodeString(random, maxLength);\n      }\n      final BytesRef br = new BytesRef(s);\n\n      if (!allowDups) {\n        if (seen.contains(s)) {\n          continue;\n        }\n        seen.add(s);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + numDocs + \": s=\" + s);\n      }\n      \n      final Document doc = new Document();\n      doc.add(new SortedBytesDocValuesField(\"stringdv\", br));\n      doc.add(newStringField(\"string\", s, Field.Store.NO));\n      doc.add(new PackedLongDocValuesField(\"id\", numDocs));\n      docValues.add(br);\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n      final TopFieldDocs hits;\n      final SortField sf;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n        sf.setUseIndexValues(true);\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n      }\n      final Sort sort = new Sort(sf);\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      if (random.nextBoolean()) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount,\n                        sort);\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f,\n                        hitCount,\n                        sort);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues);\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          System.out.println(\"    \" + idx + \": \" + expected.get(idx).utf8ToString());\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          System.out.println(\"    \" + hitIDX + \": \" + ((BytesRef) fd.fields[0]).utf8ToString());\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        assertEquals(expected.get(hitIDX), (BytesRef) fd.fields[0]);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final String s;\n      if (random.nextBoolean()) {\n        s = _TestUtil.randomSimpleString(random, maxLength);\n      } else {\n        s = _TestUtil.randomUnicodeString(random, maxLength);\n      }\n      final BytesRef br = new BytesRef(s);\n\n      if (!allowDups) {\n        if (seen.contains(s)) {\n          continue;\n        }\n        seen.add(s);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + numDocs + \": s=\" + s);\n      }\n      \n      final Document doc = new Document();\n      doc.add(new SortedBytesDocValuesField(\"stringdv\", br));\n      doc.add(newField(\"string\", s, StringField.TYPE_UNSTORED));\n      doc.add(new PackedLongDocValuesField(\"id\", numDocs));\n      docValues.add(br);\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n      final TopFieldDocs hits;\n      final SortField sf;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n        sf.setUseIndexValues(true);\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n      }\n      final Sort sort = new Sort(sf);\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      if (random.nextBoolean()) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount,\n                        sort);\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f,\n                        hitCount,\n                        sort);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues);\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          System.out.println(\"    \" + idx + \": \" + expected.get(idx).utf8ToString());\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          System.out.println(\"    \" + hitIDX + \": \" + ((BytesRef) fd.fields[0]).utf8ToString());\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        assertEquals(expected.get(hitIDX), (BytesRef) fd.fields[0]);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":["b7523dd562634d9145b67eb4c8b3b3db2340532b"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3e29774db46ad98ca4a8d7fcbfab633ebc01f358","date":1355170812,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#testRandomStringSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#testRandomStringSort().mjava","sourceNew":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final String s;\n      if (random.nextBoolean()) {\n        s = _TestUtil.randomSimpleString(random, maxLength);\n      } else {\n        s = _TestUtil.randomUnicodeString(random, maxLength);\n      }\n      final BytesRef br = new BytesRef(s);\n\n      if (!allowDups) {\n        if (seen.contains(s)) {\n          continue;\n        }\n        seen.add(s);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + numDocs + \": s=\" + s);\n      }\n      \n      final Document doc = new Document();\n      doc.add(new SortedBytesDocValuesField(\"stringdv\", br));\n      doc.add(newStringField(\"string\", s, Field.Store.NO));\n      doc.add(new PackedLongDocValuesField(\"id\", numDocs));\n      docValues.add(br);\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n      final TopFieldDocs hits;\n      final SortField sf;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n      }\n      final Sort sort = new Sort(sf);\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      if (random.nextBoolean()) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount,\n                        sort);\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f,\n                        hitCount,\n                        sort);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues);\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          System.out.println(\"    \" + idx + \": \" + expected.get(idx).utf8ToString());\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          System.out.println(\"    \" + hitIDX + \": \" + ((BytesRef) fd.fields[0]).utf8ToString());\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        assertEquals(expected.get(hitIDX), (BytesRef) fd.fields[0]);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final String s;\n      if (random.nextBoolean()) {\n        s = _TestUtil.randomSimpleString(random, maxLength);\n      } else {\n        s = _TestUtil.randomUnicodeString(random, maxLength);\n      }\n      final BytesRef br = new BytesRef(s);\n\n      if (!allowDups) {\n        if (seen.contains(s)) {\n          continue;\n        }\n        seen.add(s);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + numDocs + \": s=\" + s);\n      }\n      \n      final Document doc = new Document();\n      doc.add(new SortedBytesDocValuesField(\"stringdv\", br));\n      doc.add(newStringField(\"string\", s, Field.Store.NO));\n      doc.add(new PackedLongDocValuesField(\"id\", numDocs));\n      docValues.add(br);\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n      final TopFieldDocs hits;\n      final SortField sf;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n        sf.setUseIndexValues(true);\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n      }\n      final Sort sort = new Sort(sf);\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      if (random.nextBoolean()) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount,\n                        sort);\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f,\n                        hitCount,\n                        sort);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues);\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          System.out.println(\"    \" + idx + \": \" + expected.get(idx).utf8ToString());\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          System.out.println(\"    \" + hitIDX + \": \" + ((BytesRef) fd.fields[0]).utf8ToString());\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        assertEquals(expected.get(hitIDX), (BytesRef) fd.fields[0]);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"423d89a2b3cc419b647c07c2b3fdbc54311d07f9","date":1358836612,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#testRandomStringSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#testRandomStringSort().mjava","sourceNew":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final String s;\n      if (random.nextBoolean()) {\n        s = _TestUtil.randomSimpleString(random, maxLength);\n      } else {\n        s = _TestUtil.randomUnicodeString(random, maxLength);\n      }\n      final BytesRef br = new BytesRef(s);\n\n      if (!allowDups) {\n        if (seen.contains(s)) {\n          continue;\n        }\n        seen.add(s);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + numDocs + \": s=\" + s);\n      }\n      \n      final Document doc = new Document();\n      doc.add(new SortedDocValuesField(\"stringdv\", br));\n      doc.add(newStringField(\"string\", s, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      docValues.add(br);\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n      final TopFieldDocs hits;\n      final SortField sf;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n      }\n      final Sort sort = new Sort(sf);\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      if (random.nextBoolean()) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount,\n                        sort);\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f,\n                        hitCount,\n                        sort);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues);\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          System.out.println(\"    \" + idx + \": \" + expected.get(idx).utf8ToString());\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          System.out.println(\"    \" + hitIDX + \": \" + ((BytesRef) fd.fields[0]).utf8ToString());\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        assertEquals(expected.get(hitIDX), (BytesRef) fd.fields[0]);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final String s;\n      if (random.nextBoolean()) {\n        s = _TestUtil.randomSimpleString(random, maxLength);\n      } else {\n        s = _TestUtil.randomUnicodeString(random, maxLength);\n      }\n      final BytesRef br = new BytesRef(s);\n\n      if (!allowDups) {\n        if (seen.contains(s)) {\n          continue;\n        }\n        seen.add(s);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + numDocs + \": s=\" + s);\n      }\n      \n      final Document doc = new Document();\n      doc.add(new SortedBytesDocValuesField(\"stringdv\", br));\n      doc.add(newStringField(\"string\", s, Field.Store.NO));\n      doc.add(new PackedLongDocValuesField(\"id\", numDocs));\n      docValues.add(br);\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n      final TopFieldDocs hits;\n      final SortField sf;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n      }\n      final Sort sort = new Sort(sf);\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      if (random.nextBoolean()) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount,\n                        sort);\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f,\n                        hitCount,\n                        sort);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues);\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          System.out.println(\"    \" + idx + \": \" + expected.get(idx).utf8ToString());\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          System.out.println(\"    \" + hitIDX + \": \" + ((BytesRef) fd.fields[0]).utf8ToString());\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        assertEquals(expected.get(hitIDX), (BytesRef) fd.fields[0]);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSort#testRandomStringSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#testRandomStringSort().mjava","sourceNew":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final String s;\n      if (random.nextBoolean()) {\n        s = _TestUtil.randomSimpleString(random, maxLength);\n      } else {\n        s = _TestUtil.randomUnicodeString(random, maxLength);\n      }\n      final BytesRef br = new BytesRef(s);\n\n      if (!allowDups) {\n        if (seen.contains(s)) {\n          continue;\n        }\n        seen.add(s);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + numDocs + \": s=\" + s);\n      }\n      \n      final Document doc = new Document();\n      doc.add(new SortedDocValuesField(\"stringdv\", br));\n      doc.add(newStringField(\"string\", s, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      docValues.add(br);\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n      final TopFieldDocs hits;\n      final SortField sf;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n      }\n      final Sort sort = new Sort(sf);\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      if (random.nextBoolean()) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount,\n                        sort);\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f,\n                        hitCount,\n                        sort);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues);\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          System.out.println(\"    \" + idx + \": \" + expected.get(idx).utf8ToString());\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          System.out.println(\"    \" + hitIDX + \": \" + ((BytesRef) fd.fields[0]).utf8ToString());\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        assertEquals(expected.get(hitIDX), (BytesRef) fd.fields[0]);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final String s;\n      if (random.nextBoolean()) {\n        s = _TestUtil.randomSimpleString(random, maxLength);\n      } else {\n        s = _TestUtil.randomUnicodeString(random, maxLength);\n      }\n      final BytesRef br = new BytesRef(s);\n\n      if (!allowDups) {\n        if (seen.contains(s)) {\n          continue;\n        }\n        seen.add(s);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + numDocs + \": s=\" + s);\n      }\n      \n      final Document doc = new Document();\n      doc.add(new SortedBytesDocValuesField(\"stringdv\", br));\n      doc.add(newStringField(\"string\", s, Field.Store.NO));\n      doc.add(new PackedLongDocValuesField(\"id\", numDocs));\n      docValues.add(br);\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n      final TopFieldDocs hits;\n      final SortField sf;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n        sf.setUseIndexValues(true);\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n      }\n      final Sort sort = new Sort(sf);\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      if (random.nextBoolean()) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount,\n                        sort);\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f,\n                        hitCount,\n                        sort);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues);\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          System.out.println(\"    \" + idx + \": \" + expected.get(idx).utf8ToString());\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          System.out.println(\"    \" + hitIDX + \": \" + ((BytesRef) fd.fields[0]).utf8ToString());\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        assertEquals(expected.get(hitIDX), (BytesRef) fd.fields[0]);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":["cd659803551ebd8ca09b9e4ad7abd18d3d558f9d","b7523dd562634d9145b67eb4c8b3b3db2340532b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f1d5408c3fa04da2652aa3db3f21d700f7111cef","date":1360854465,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#testRandomStringSort().mjava","sourceNew":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final String s;\n      if (random.nextBoolean()) {\n        s = _TestUtil.randomSimpleString(random, maxLength);\n      } else {\n        s = _TestUtil.randomUnicodeString(random, maxLength);\n      }\n      final BytesRef br = new BytesRef(s);\n\n      if (!allowDups) {\n        if (seen.contains(s)) {\n          continue;\n        }\n        seen.add(s);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + numDocs + \": s=\" + s);\n      }\n      \n      final Document doc = new Document();\n      doc.add(new SortedDocValuesField(\"stringdv\", br));\n      doc.add(newStringField(\"string\", s, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      docValues.add(br);\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n      final TopFieldDocs hits;\n      final SortField sf;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n      }\n      final Sort sort = new Sort(sf);\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      if (random.nextBoolean()) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount,\n                        sort);\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f,\n                        hitCount,\n                        sort);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues);\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          System.out.println(\"    \" + idx + \": \" + expected.get(idx).utf8ToString());\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          System.out.println(\"    \" + hitIDX + \": \" + ((BytesRef) fd.fields[0]).utf8ToString());\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        assertEquals(expected.get(hitIDX), (BytesRef) fd.fields[0]);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final String s;\n      if (random.nextBoolean()) {\n        s = _TestUtil.randomSimpleString(random, maxLength);\n      } else {\n        s = _TestUtil.randomUnicodeString(random, maxLength);\n      }\n      final BytesRef br = new BytesRef(s);\n\n      if (!allowDups) {\n        if (seen.contains(s)) {\n          continue;\n        }\n        seen.add(s);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + numDocs + \": s=\" + s);\n      }\n      \n      final Document doc = new Document();\n      doc.add(new SortedDocValuesField(\"stringdv\", br));\n      doc.add(newStringField(\"string\", s, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      docValues.add(br);\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n      final TopFieldDocs hits;\n      final SortField sf;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n      }\n      final Sort sort = new Sort(sf);\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      if (random.nextBoolean()) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount,\n                        sort);\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f,\n                        hitCount,\n                        sort);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues);\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          System.out.println(\"    \" + idx + \": \" + expected.get(idx).utf8ToString());\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          System.out.println(\"    \" + hitIDX + \": \" + ((BytesRef) fd.fields[0]).utf8ToString());\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        assertEquals(expected.get(hitIDX), (BytesRef) fd.fields[0]);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b41f996b22bd5518650f897d050088ff808ec03","date":1360969107,"type":5,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestSortRandom#testRandomStringSort().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestSort#testRandomStringSort().mjava","sourceNew":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final String s;\n      if (random.nextBoolean()) {\n        s = _TestUtil.randomSimpleString(random, maxLength);\n      } else {\n        s = _TestUtil.randomUnicodeString(random, maxLength);\n      }\n      final BytesRef br = new BytesRef(s);\n\n      if (!allowDups) {\n        if (seen.contains(s)) {\n          continue;\n        }\n        seen.add(s);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + numDocs + \": s=\" + s);\n      }\n      \n      final Document doc = new Document();\n      doc.add(new SortedDocValuesField(\"stringdv\", br));\n      doc.add(newStringField(\"string\", s, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      docValues.add(br);\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n      final TopFieldDocs hits;\n      final SortField sf;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n      }\n      final Sort sort;\n      if (random.nextBoolean()) {\n        sort = new Sort(sf);\n      } else {\n        sort = new Sort(sf, SortField.FIELD_DOC);\n      }\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      int queryType = random.nextInt(3);\n      if (queryType == 0) {\n        // force out of order\n        BooleanQuery bq = new BooleanQuery();\n        // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2\n        // which delegates to BS if there are no mandatory clauses.\n        bq.add(new MatchAllDocsQuery(), Occur.SHOULD);\n        // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return\n        // the clause instead of BQ.\n        bq.setMinimumNumberShouldMatch(1);\n        hits = s.search(bq, f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else if (queryType == 1) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        null, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f, hitCount, sort, random.nextBoolean(), random.nextBoolean());\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues);\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          System.out.println(\"    \" + idx + \": \" + expected.get(idx).utf8ToString());\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          System.out.println(\"    \" + hitIDX + \": \" + ((BytesRef) fd.fields[0]).utf8ToString());\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        assertEquals(expected.get(hitIDX), (BytesRef) fd.fields[0]);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStringSort() throws Exception {\n    Random random = new Random(random().nextLong());\n\n    final int NUM_DOCS = atLeast(100);\n    final Directory dir = newDirectory();\n    final RandomIndexWriter writer = new RandomIndexWriter(random, dir);\n    final boolean allowDups = random.nextBoolean();\n    final Set<String> seen = new HashSet<String>();\n    final int maxLength = _TestUtil.nextInt(random, 5, 100);\n    if (VERBOSE) {\n      System.out.println(\"TEST: NUM_DOCS=\" + NUM_DOCS + \" maxLength=\" + maxLength + \" allowDups=\" + allowDups);\n    }\n\n    int numDocs = 0;\n    final List<BytesRef> docValues = new ArrayList<BytesRef>();\n    // TODO: deletions\n    while (numDocs < NUM_DOCS) {\n      final String s;\n      if (random.nextBoolean()) {\n        s = _TestUtil.randomSimpleString(random, maxLength);\n      } else {\n        s = _TestUtil.randomUnicodeString(random, maxLength);\n      }\n      final BytesRef br = new BytesRef(s);\n\n      if (!allowDups) {\n        if (seen.contains(s)) {\n          continue;\n        }\n        seen.add(s);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + numDocs + \": s=\" + s);\n      }\n      \n      final Document doc = new Document();\n      doc.add(new SortedDocValuesField(\"stringdv\", br));\n      doc.add(newStringField(\"string\", s, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", numDocs));\n      docValues.add(br);\n      writer.addDocument(doc);\n      numDocs++;\n\n      if (random.nextInt(40) == 17) {\n        // force flush\n        writer.getReader().close();\n      }\n    }\n\n    final IndexReader r = writer.getReader();\n    writer.close();\n    if (VERBOSE) {\n      System.out.println(\"  reader=\" + r);\n    }\n    \n    final IndexSearcher s = newSearcher(r, false);\n    final int ITERS = atLeast(100);\n    for(int iter=0;iter<ITERS;iter++) {\n      final boolean reverse = random.nextBoolean();\n      final TopFieldDocs hits;\n      final SortField sf;\n      if (random.nextBoolean()) {\n        sf = new SortField(\"stringdv\", SortField.Type.STRING, reverse);\n      } else {\n        sf = new SortField(\"string\", SortField.Type.STRING, reverse);\n      }\n      final Sort sort = new Sort(sf);\n      final int hitCount = _TestUtil.nextInt(random, 1, r.maxDoc() + 20);\n      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);\n      if (random.nextBoolean()) {\n        hits = s.search(new ConstantScoreQuery(f),\n                        hitCount,\n                        sort);\n      } else {\n        hits = s.search(new MatchAllDocsQuery(),\n                        f,\n                        hitCount,\n                        sort);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" \" + hits.totalHits + \" hits; topN=\" + hitCount + \"; reverse=\" + reverse);\n      }\n\n      // Compute expected results:\n      Collections.sort(f.matchValues);\n      if (reverse) {\n        Collections.reverse(f.matchValues);\n      }\n      final List<BytesRef> expected = f.matchValues;\n      if (VERBOSE) {\n        System.out.println(\"  expected:\");\n        for(int idx=0;idx<expected.size();idx++) {\n          System.out.println(\"    \" + idx + \": \" + expected.get(idx).utf8ToString());\n          if (idx == hitCount-1) {\n            break;\n          }\n        }\n      }\n      \n      if (VERBOSE) {\n        System.out.println(\"  actual:\");\n        for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n          final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n          System.out.println(\"    \" + hitIDX + \": \" + ((BytesRef) fd.fields[0]).utf8ToString());\n        }\n      }\n      for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {\n        final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];\n        assertEquals(expected.get(hitIDX), (BytesRef) fd.fields[0]);\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6d8cbdadfe95a15fad972438ce43d97dfb7b152d"],"6d8cbdadfe95a15fad972438ce43d97dfb7b152d":["b7523dd562634d9145b67eb4c8b3b3db2340532b"],"3e29774db46ad98ca4a8d7fcbfab633ebc01f358":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["57ae3024996ccdb3c36c42cb890e1efb37df4ce8"],"57ae3024996ccdb3c36c42cb890e1efb37df4ce8":["cd659803551ebd8ca09b9e4ad7abd18d3d558f9d"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["04f07771a2a7dd3a395700665ed839c3dae2def2","423d89a2b3cc419b647c07c2b3fdbc54311d07f9"],"3b41f996b22bd5518650f897d050088ff808ec03":["d4d69c535930b5cce125cff868d40f6373dc27d4","f1d5408c3fa04da2652aa3db3f21d700f7111cef"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f1d5408c3fa04da2652aa3db3f21d700f7111cef":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["6d8cbdadfe95a15fad972438ce43d97dfb7b152d"],"b7523dd562634d9145b67eb4c8b3b3db2340532b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"423d89a2b3cc419b647c07c2b3fdbc54311d07f9":["3e29774db46ad98ca4a8d7fcbfab633ebc01f358"],"cd659803551ebd8ca09b9e4ad7abd18d3d558f9d":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f1d5408c3fa04da2652aa3db3f21d700f7111cef"]},"commit2Childs":{"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"6d8cbdadfe95a15fad972438ce43d97dfb7b152d":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"3e29774db46ad98ca4a8d7fcbfab633ebc01f358":["423d89a2b3cc419b647c07c2b3fdbc54311d07f9"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["3e29774db46ad98ca4a8d7fcbfab633ebc01f358","d4d69c535930b5cce125cff868d40f6373dc27d4"],"57ae3024996ccdb3c36c42cb890e1efb37df4ce8":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["3b41f996b22bd5518650f897d050088ff808ec03","f1d5408c3fa04da2652aa3db3f21d700f7111cef"],"3b41f996b22bd5518650f897d050088ff808ec03":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","b7523dd562634d9145b67eb4c8b3b3db2340532b"],"f1d5408c3fa04da2652aa3db3f21d700f7111cef":["3b41f996b22bd5518650f897d050088ff808ec03","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b7523dd562634d9145b67eb4c8b3b3db2340532b":["6d8cbdadfe95a15fad972438ce43d97dfb7b152d"],"423d89a2b3cc419b647c07c2b3fdbc54311d07f9":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["cd659803551ebd8ca09b9e4ad7abd18d3d558f9d"],"cd659803551ebd8ca09b9e4ad7abd18d3d558f9d":["57ae3024996ccdb3c36c42cb890e1efb37df4ce8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","3b41f996b22bd5518650f897d050088ff808ec03","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}