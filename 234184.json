{"path":"sandbox/contributions/webcrawler-LARM/libs/HTTPClient-patch/HTTPClient/HTTPConnection#matchNonProxy(String).mjava","commits":[{"id":"bc6055f4a2e8e9f9caaec2297010c9502480ed69","date":1050060580,"type":0,"author":"cmarschner","isMerge":false,"pathNew":"sandbox/contributions/webcrawler-LARM/libs/HTTPClient-patch/HTTPClient/HTTPConnection#matchNonProxy(String).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Determines if the given host matches any entry in the non-proxy list.\n     *\n     * @param host  the host to match - must be trim()'d and lowercase\n     * @return      true if a match is found, false otherwise\n     * @see         #dontProxyFor(java.lang.String)\n     */\n    private boolean matchNonProxy(String host)\n    {\n        // Check host name list\n\n        if (non_proxy_host_list.get(host) != null)\n        {\n            return true;\n        }\n\n        // Check domain name list\n\n        for (int idx = 0; idx < non_proxy_dom_list.size(); idx++)\n        {\n            if (host.endsWith((String) non_proxy_dom_list.elementAt(idx)))\n            {\n                return true;\n            }\n        }\n\n        // Check IP-address and subnet list\n\n        if (non_proxy_addr_list.size() == 0)\n        {\n            return false;\n        }\n\n        InetAddress[] host_addr;\n        try\n        {\n            host_addr = InetAddress.getAllByName(host);\n        }\n        catch (UnknownHostException uhe)\n        {\n            return false;\n        }\n        // maybe the proxy has better luck\n\n        for (int idx = 0; idx < non_proxy_addr_list.size(); idx++)\n        {\n            byte[] addr = (byte[]) non_proxy_addr_list.elementAt(idx);\n            byte[] mask = (byte[]) non_proxy_mask_list.elementAt(idx);\n\n            ip_loop :\n            for (int idx2 = 0; idx2 < host_addr.length; idx2++)\n            {\n                byte[] raw_addr = host_addr[idx2].getAddress();\n                if (raw_addr.length != addr.length)\n                {\n                    continue;\n                }\n\n                for (int idx3 = 0; idx3 < raw_addr.length; idx3++)\n                {\n                    if ((raw_addr[idx3] & mask[idx3]) != (addr[idx3] & mask[idx3]))\n                    {\n                        continue ip_loop;\n                    }\n                }\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"afc16d717d9ed1a8e45371668ca6de674164d624","date":1103345442,"type":4,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"/dev/null","pathOld":"sandbox/contributions/webcrawler-LARM/libs/HTTPClient-patch/HTTPClient/HTTPConnection#matchNonProxy(String).mjava","sourceNew":null,"sourceOld":"    /**\n     * Determines if the given host matches any entry in the non-proxy list.\n     *\n     * @param host  the host to match - must be trim()'d and lowercase\n     * @return      true if a match is found, false otherwise\n     * @see         #dontProxyFor(java.lang.String)\n     */\n    private boolean matchNonProxy(String host)\n    {\n        // Check host name list\n\n        if (non_proxy_host_list.get(host) != null)\n        {\n            return true;\n        }\n\n        // Check domain name list\n\n        for (int idx = 0; idx < non_proxy_dom_list.size(); idx++)\n        {\n            if (host.endsWith((String) non_proxy_dom_list.elementAt(idx)))\n            {\n                return true;\n            }\n        }\n\n        // Check IP-address and subnet list\n\n        if (non_proxy_addr_list.size() == 0)\n        {\n            return false;\n        }\n\n        InetAddress[] host_addr;\n        try\n        {\n            host_addr = InetAddress.getAllByName(host);\n        }\n        catch (UnknownHostException uhe)\n        {\n            return false;\n        }\n        // maybe the proxy has better luck\n\n        for (int idx = 0; idx < non_proxy_addr_list.size(); idx++)\n        {\n            byte[] addr = (byte[]) non_proxy_addr_list.elementAt(idx);\n            byte[] mask = (byte[]) non_proxy_mask_list.elementAt(idx);\n\n            ip_loop :\n            for (int idx2 = 0; idx2 < host_addr.length; idx2++)\n            {\n                byte[] raw_addr = host_addr[idx2].getAddress();\n                if (raw_addr.length != addr.length)\n                {\n                    continue;\n                }\n\n                for (int idx3 = 0; idx3 < raw_addr.length; idx3++)\n                {\n                    if ((raw_addr[idx3] & mask[idx3]) != (addr[idx3] & mask[idx3]))\n                    {\n                        continue ip_loop;\n                    }\n                }\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bc6055f4a2e8e9f9caaec2297010c9502480ed69":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"afc16d717d9ed1a8e45371668ca6de674164d624":["bc6055f4a2e8e9f9caaec2297010c9502480ed69"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["afc16d717d9ed1a8e45371668ca6de674164d624"]},"commit2Childs":{"bc6055f4a2e8e9f9caaec2297010c9502480ed69":["afc16d717d9ed1a8e45371668ca6de674164d624"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bc6055f4a2e8e9f9caaec2297010c9502480ed69"],"afc16d717d9ed1a8e45371668ca6de674164d624":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}