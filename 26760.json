{"path":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","commits":[{"id":"8b9fb5afeea0288262bffcc55bdcda8b5fa272c8","date":1339238489,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T]).mjava","sourceNew":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  public int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" + arc.nextArc);\n      in.pos = getNodeAddress(arc.nextArc);\n      final byte b = bytes[in.pos];\n      if (b == ARCS_AS_FIXED_ARRAY) {\n        //System.out.println(\"    nextArc fake array\");\n        in.skip(1);\n        in.readVInt();\n        if (packed) {\n          in.readVInt();\n        } else {\n          in.readInt();\n        }\n      }\n    } else {\n      if (arc.bytesPerArc != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are at fixed entries\n        in.pos = arc.posArcsStart;\n        in.skip((1+arc.arcIdx)*arc.bytesPerArc);\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        in.pos = arc.nextArc;\n      }\n    }\n    // skip flags\n    in.readByte();\n    return readLabel(in);\n  }\n\n","sourceOld":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  public int readNextArcLabel(Arc<T> arc) throws IOException {\n    assert !arc.isLast();\n\n    final BytesReader in;\n    if (arc.label == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" + arc.nextArc);\n      in = getBytesReader(getNodeAddress(arc.nextArc));\n      final byte b = bytes[in.pos];\n      if (b == ARCS_AS_FIXED_ARRAY) {\n        //System.out.println(\"    nextArc fake array\");\n        in.skip(1);\n        in.readVInt();\n        if (packed) {\n          in.readVInt();\n        } else {\n          in.readInt();\n        }\n      }\n    } else {\n      if (arc.bytesPerArc != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are at fixed entries\n        in = getBytesReader(arc.posArcsStart);\n        in.skip((1+arc.arcIdx)*arc.bytesPerArc);\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        in = getBytesReader(arc.nextArc);\n      }\n    }\n    // skip flags\n    in.readByte();\n    return readLabel(in);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb27634f76319b68d6d8fd11a7104d20294722c5","date":1355210077,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","sourceNew":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  public int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" + arc.nextArc);\n      int pos = in.pos = getNodeAddress(arc.nextArc);\n      final byte b = in.readByte();\n      if (b == ARCS_AS_FIXED_ARRAY) {\n        //System.out.println(\"    nextArc fake array\");\n        in.readVInt();\n        if (packed) {\n          in.readVInt();\n        } else {\n          in.readInt();\n        }\n      } else {\n        in.pos = pos;\n      }\n    } else {\n      if (arc.bytesPerArc != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are at fixed entries\n        in.pos = arc.posArcsStart;\n        in.skip((1+arc.arcIdx)*arc.bytesPerArc);\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        in.pos = arc.nextArc;\n      }\n    }\n    // skip flags\n    in.readByte();\n    return readLabel(in);\n  }\n\n","sourceOld":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  public int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" + arc.nextArc);\n      in.pos = getNodeAddress(arc.nextArc);\n      final byte b = bytes[in.pos];\n      if (b == ARCS_AS_FIXED_ARRAY) {\n        //System.out.println(\"    nextArc fake array\");\n        in.skip(1);\n        in.readVInt();\n        if (packed) {\n          in.readVInt();\n        } else {\n          in.readInt();\n        }\n      }\n    } else {\n      if (arc.bytesPerArc != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are at fixed entries\n        in.pos = arc.posArcsStart;\n        in.skip((1+arc.arcIdx)*arc.bytesPerArc);\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        in.pos = arc.nextArc;\n      }\n    }\n    // skip flags\n    in.readByte();\n    return readLabel(in);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","sourceNew":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  public int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" + arc.nextArc);\n      int pos = in.pos = getNodeAddress(arc.nextArc);\n      final byte b = in.readByte();\n      if (b == ARCS_AS_FIXED_ARRAY) {\n        //System.out.println(\"    nextArc fake array\");\n        in.readVInt();\n        if (packed) {\n          in.readVInt();\n        } else {\n          in.readInt();\n        }\n      } else {\n        in.pos = pos;\n      }\n    } else {\n      if (arc.bytesPerArc != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are at fixed entries\n        in.pos = arc.posArcsStart;\n        in.skip((1+arc.arcIdx)*arc.bytesPerArc);\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        in.pos = arc.nextArc;\n      }\n    }\n    // skip flags\n    in.readByte();\n    return readLabel(in);\n  }\n\n","sourceOld":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  public int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" + arc.nextArc);\n      in.pos = getNodeAddress(arc.nextArc);\n      final byte b = bytes[in.pos];\n      if (b == ARCS_AS_FIXED_ARRAY) {\n        //System.out.println(\"    nextArc fake array\");\n        in.skip(1);\n        in.readVInt();\n        if (packed) {\n          in.readVInt();\n        } else {\n          in.readInt();\n        }\n      }\n    } else {\n      if (arc.bytesPerArc != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are at fixed entries\n        in.pos = arc.posArcsStart;\n        in.skip((1+arc.arcIdx)*arc.bytesPerArc);\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        in.pos = arc.nextArc;\n      }\n    }\n    // skip flags\n    in.readByte();\n    return readLabel(in);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"87e78f3c129251e74ecc2ff73a32de0f27cf09d5","date":1358006150,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","sourceNew":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  public int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" +\n      //arc.nextArc);\n      \n      int pos = getNodeAddress(arc.nextArc);\n      in.setPosition(pos);\n\n      final byte b = in.readByte();\n      if (b == ARCS_AS_FIXED_ARRAY) {\n        //System.out.println(\"    nextArc fake array\");\n        in.readVInt();\n        if (packed) {\n          in.readVInt();\n        } else {\n          in.readInt();\n        }\n      } else {\n        in.setPosition(pos);\n      }\n    } else {\n      if (arc.bytesPerArc != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are at fixed entries\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes((1+arc.arcIdx)*arc.bytesPerArc);\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        in.setPosition(arc.nextArc);\n      }\n    }\n    // skip flags\n    in.readByte();\n    return readLabel(in);\n  }\n\n","sourceOld":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  public int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" + arc.nextArc);\n      int pos = in.pos = getNodeAddress(arc.nextArc);\n      final byte b = in.readByte();\n      if (b == ARCS_AS_FIXED_ARRAY) {\n        //System.out.println(\"    nextArc fake array\");\n        in.readVInt();\n        if (packed) {\n          in.readVInt();\n        } else {\n          in.readInt();\n        }\n      } else {\n        in.pos = pos;\n      }\n    } else {\n      if (arc.bytesPerArc != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are at fixed entries\n        in.pos = arc.posArcsStart;\n        in.skip((1+arc.arcIdx)*arc.bytesPerArc);\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        in.pos = arc.nextArc;\n      }\n    }\n    // skip flags\n    in.readByte();\n    return readLabel(in);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"556c8202987f72dd8458e25e21a82d98fc274979","date":1358008288,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","sourceNew":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  public int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" +\n      //arc.nextArc);\n      \n      int pos = getNodeAddress(arc.nextArc);\n      in.setPosition(pos);\n\n      final byte b = in.readByte();\n      if (b == ARCS_AS_FIXED_ARRAY) {\n        //System.out.println(\"    nextArc fixed array\");\n        in.readVInt();\n\n        // Skip bytesPerArc:\n        if (packed) {\n          in.readVInt();\n        } else {\n          in.readInt();\n        }\n      } else {\n        in.setPosition(pos);\n      }\n    } else {\n      if (arc.bytesPerArc != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are at fixed entries\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes((1+arc.arcIdx)*arc.bytesPerArc);\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        in.setPosition(arc.nextArc);\n      }\n    }\n    // skip flags\n    in.readByte();\n    return readLabel(in);\n  }\n\n","sourceOld":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  public int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" +\n      //arc.nextArc);\n      \n      int pos = getNodeAddress(arc.nextArc);\n      in.setPosition(pos);\n\n      final byte b = in.readByte();\n      if (b == ARCS_AS_FIXED_ARRAY) {\n        //System.out.println(\"    nextArc fake array\");\n        in.readVInt();\n        if (packed) {\n          in.readVInt();\n        } else {\n          in.readInt();\n        }\n      } else {\n        in.setPosition(pos);\n      }\n    } else {\n      if (arc.bytesPerArc != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are at fixed entries\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes((1+arc.arcIdx)*arc.bytesPerArc);\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        in.setPosition(arc.nextArc);\n      }\n    }\n    // skip flags\n    in.readByte();\n    return readLabel(in);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc6d3be942e675e8251dbe10796cdb3a484bf607","date":1358026184,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","sourceNew":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  public int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" +\n      //arc.nextArc);\n      \n      int pos = getNodeAddress(arc.nextArc);\n      in.setPosition(pos);\n\n      final byte b = in.readByte();\n      if (b == ARCS_AS_FIXED_ARRAY) {\n        //System.out.println(\"    nextArc fixed array\");\n        in.readVInt();\n\n        // Skip bytesPerArc:\n        if (packed || version >= VERSION_VINT_TARGET) {\n          in.readVInt();\n        } else {\n          in.readInt();\n        }\n      } else {\n        in.setPosition(pos);\n      }\n    } else {\n      if (arc.bytesPerArc != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are at fixed entries\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes((1+arc.arcIdx)*arc.bytesPerArc);\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        in.setPosition(arc.nextArc);\n      }\n    }\n    // skip flags\n    in.readByte();\n    return readLabel(in);\n  }\n\n","sourceOld":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  public int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" +\n      //arc.nextArc);\n      \n      int pos = getNodeAddress(arc.nextArc);\n      in.setPosition(pos);\n\n      final byte b = in.readByte();\n      if (b == ARCS_AS_FIXED_ARRAY) {\n        //System.out.println(\"    nextArc fixed array\");\n        in.readVInt();\n\n        // Skip bytesPerArc:\n        if (packed) {\n          in.readVInt();\n        } else {\n          in.readInt();\n        }\n      } else {\n        in.setPosition(pos);\n      }\n    } else {\n      if (arc.bytesPerArc != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are at fixed entries\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes((1+arc.arcIdx)*arc.bytesPerArc);\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        in.setPosition(arc.nextArc);\n      }\n    }\n    // skip flags\n    in.readByte();\n    return readLabel(in);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0","date":1358188277,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","sourceNew":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  public int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" +\n      //arc.nextArc);\n      \n      long pos = getNodeAddress(arc.nextArc);\n      in.setPosition(pos);\n\n      final byte b = in.readByte();\n      if (b == ARCS_AS_FIXED_ARRAY) {\n        //System.out.println(\"    nextArc fixed array\");\n        in.readVInt();\n\n        // Skip bytesPerArc:\n        if (packed || version >= VERSION_VINT_TARGET) {\n          in.readVInt();\n        } else {\n          in.readInt();\n        }\n      } else {\n        in.setPosition(pos);\n      }\n    } else {\n      if (arc.bytesPerArc != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are at fixed entries\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes((1+arc.arcIdx)*arc.bytesPerArc);\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        in.setPosition(arc.nextArc);\n      }\n    }\n    // skip flags\n    in.readByte();\n    return readLabel(in);\n  }\n\n","sourceOld":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  public int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" +\n      //arc.nextArc);\n      \n      int pos = getNodeAddress(arc.nextArc);\n      in.setPosition(pos);\n\n      final byte b = in.readByte();\n      if (b == ARCS_AS_FIXED_ARRAY) {\n        //System.out.println(\"    nextArc fixed array\");\n        in.readVInt();\n\n        // Skip bytesPerArc:\n        if (packed || version >= VERSION_VINT_TARGET) {\n          in.readVInt();\n        } else {\n          in.readInt();\n        }\n      } else {\n        in.setPosition(pos);\n      }\n    } else {\n      if (arc.bytesPerArc != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are at fixed entries\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes((1+arc.arcIdx)*arc.bytesPerArc);\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        in.setPosition(arc.nextArc);\n      }\n    }\n    // skip flags\n    in.readByte();\n    return readLabel(in);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8917bfede3b4ca30f4305c1e391e9218959cd723","date":1358189662,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","sourceNew":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  public int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" +\n      //arc.nextArc);\n      \n      long pos = getNodeAddress(arc.nextArc);\n      in.setPosition(pos);\n\n      final byte b = in.readByte();\n      if (b == ARCS_AS_FIXED_ARRAY) {\n        //System.out.println(\"    nextArc fixed array\");\n        in.readVInt();\n\n        // Skip bytesPerArc:\n        if (packed || version >= VERSION_VINT_TARGET) {\n          in.readVInt();\n        } else {\n          in.readInt();\n        }\n      } else {\n        in.setPosition(pos);\n      }\n    } else {\n      if (arc.bytesPerArc != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are at fixed entries\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes((1+arc.arcIdx)*arc.bytesPerArc);\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        in.setPosition(arc.nextArc);\n      }\n    }\n    // skip flags\n    in.readByte();\n    return readLabel(in);\n  }\n\n","sourceOld":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  public int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" + arc.nextArc);\n      int pos = in.pos = getNodeAddress(arc.nextArc);\n      final byte b = in.readByte();\n      if (b == ARCS_AS_FIXED_ARRAY) {\n        //System.out.println(\"    nextArc fake array\");\n        in.readVInt();\n        if (packed) {\n          in.readVInt();\n        } else {\n          in.readInt();\n        }\n      } else {\n        in.pos = pos;\n      }\n    } else {\n      if (arc.bytesPerArc != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are at fixed entries\n        in.pos = arc.posArcsStart;\n        in.skip((1+arc.arcIdx)*arc.bytesPerArc);\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        in.pos = arc.nextArc;\n      }\n    }\n    // skip flags\n    in.readByte();\n    return readLabel(in);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6244579a467d5f2673ac98265d74bddbea1a8114","date":1478786509,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","sourceNew":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  public int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" +\n      //arc.nextArc);\n      \n      long pos = arc.nextArc;\n      in.setPosition(pos);\n\n      final byte b = in.readByte();\n      if (b == ARCS_AS_FIXED_ARRAY) {\n        //System.out.println(\"    nextArc fixed array\");\n        in.readVInt();\n\n        // Skip bytesPerArc:\n        if (version >= VERSION_VINT_TARGET) {\n          in.readVInt();\n        } else {\n          in.readInt();\n        }\n      } else {\n        in.setPosition(pos);\n      }\n    } else {\n      if (arc.bytesPerArc != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are at fixed entries\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes((1+arc.arcIdx)*arc.bytesPerArc);\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        in.setPosition(arc.nextArc);\n      }\n    }\n    // skip flags\n    in.readByte();\n    return readLabel(in);\n  }\n\n","sourceOld":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  public int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" +\n      //arc.nextArc);\n      \n      long pos = getNodeAddress(arc.nextArc);\n      in.setPosition(pos);\n\n      final byte b = in.readByte();\n      if (b == ARCS_AS_FIXED_ARRAY) {\n        //System.out.println(\"    nextArc fixed array\");\n        in.readVInt();\n\n        // Skip bytesPerArc:\n        if (packed || version >= VERSION_VINT_TARGET) {\n          in.readVInt();\n        } else {\n          in.readInt();\n        }\n      } else {\n        in.setPosition(pos);\n      }\n    } else {\n      if (arc.bytesPerArc != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are at fixed entries\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes((1+arc.arcIdx)*arc.bytesPerArc);\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        in.setPosition(arc.nextArc);\n      }\n    }\n    // skip flags\n    in.readByte();\n    return readLabel(in);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"199dfa410f1fdbfd3294106b04096cce5ed34b21","date":1478812506,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","sourceNew":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  public int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" +\n      //arc.nextArc);\n      \n      long pos = arc.nextArc;\n      in.setPosition(pos);\n\n      final byte b = in.readByte();\n      if (b == ARCS_AS_FIXED_ARRAY) {\n        //System.out.println(\"    nextArc fixed array\");\n        in.readVInt();\n\n        // Skip bytesPerArc:\n        if (version >= VERSION_VINT_TARGET) {\n          in.readVInt();\n        } else {\n          in.readInt();\n        }\n      } else {\n        in.setPosition(pos);\n      }\n    } else {\n      if (arc.bytesPerArc != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are at fixed entries\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes((1+arc.arcIdx)*arc.bytesPerArc);\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        in.setPosition(arc.nextArc);\n      }\n    }\n    // skip flags\n    in.readByte();\n    return readLabel(in);\n  }\n\n","sourceOld":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  public int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" +\n      //arc.nextArc);\n      \n      long pos = getNodeAddress(arc.nextArc);\n      in.setPosition(pos);\n\n      final byte b = in.readByte();\n      if (b == ARCS_AS_FIXED_ARRAY) {\n        //System.out.println(\"    nextArc fixed array\");\n        in.readVInt();\n\n        // Skip bytesPerArc:\n        if (packed || version >= VERSION_VINT_TARGET) {\n          in.readVInt();\n        } else {\n          in.readInt();\n        }\n      } else {\n        in.setPosition(pos);\n      }\n    } else {\n      if (arc.bytesPerArc != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are at fixed entries\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes((1+arc.arcIdx)*arc.bytesPerArc);\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        in.setPosition(arc.nextArc);\n      }\n    }\n    // skip flags\n    in.readByte();\n    return readLabel(in);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0e7448656541edc407546460641f47950451b16","date":1519150500,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","sourceNew":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  public int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" +\n      //arc.nextArc);\n      \n      long pos = arc.nextArc;\n      in.setPosition(pos);\n\n      final byte b = in.readByte();\n      if (b == ARCS_AS_FIXED_ARRAY) {\n        //System.out.println(\"    nextArc fixed array\");\n        in.readVInt();\n\n        // Skip bytesPerArc:\n        in.readVInt();\n      } else {\n        in.setPosition(pos);\n      }\n    } else {\n      if (arc.bytesPerArc != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are at fixed entries\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes((1+arc.arcIdx)*arc.bytesPerArc);\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        in.setPosition(arc.nextArc);\n      }\n    }\n    // skip flags\n    in.readByte();\n    return readLabel(in);\n  }\n\n","sourceOld":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  public int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" +\n      //arc.nextArc);\n      \n      long pos = arc.nextArc;\n      in.setPosition(pos);\n\n      final byte b = in.readByte();\n      if (b == ARCS_AS_FIXED_ARRAY) {\n        //System.out.println(\"    nextArc fixed array\");\n        in.readVInt();\n\n        // Skip bytesPerArc:\n        if (version >= VERSION_VINT_TARGET) {\n          in.readVInt();\n        } else {\n          in.readInt();\n        }\n      } else {\n        in.setPosition(pos);\n      }\n    } else {\n      if (arc.bytesPerArc != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are at fixed entries\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes((1+arc.arcIdx)*arc.bytesPerArc);\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        in.setPosition(arc.nextArc);\n      }\n    }\n    // skip flags\n    in.readByte();\n    return readLabel(in);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae67e1f82a53594208ca929f382ee861dad3d7a8","date":1557134375,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","sourceNew":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  public int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" +\n      //arc.nextArc);\n      \n      long pos = arc.nextArc;\n      in.setPosition(pos);\n\n      final byte flags = in.readByte();\n      if (flags == ARCS_AS_ARRAY_PACKED || flags == ARCS_AS_ARRAY_WITH_GAPS) {\n        //System.out.println(\"    nextArc fixed array\");\n        in.readVInt();\n\n        // Skip bytesPerArc:\n        in.readVInt();\n      } else {\n        in.setPosition(pos);\n      }\n      // skip flags\n      in.readByte();\n    } else {\n      if (arc.bytesPerArc != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are in an array\n        if (arc.arcIdx >= 0) {\n          in.setPosition(arc.posArcsStart);\n          // point at next arc, -1 to skip flags\n          in.skipBytes((1 + arc.arcIdx) * arc.bytesPerArc + 1);\n        } else {\n          in.setPosition(arc.nextArc);\n          byte flags = in.readByte();\n          // skip missing arcs\n          while (flag(flags, BIT_MISSING_ARC)) {\n            in.skipBytes(arc.bytesPerArc - 1);\n            flags = in.readByte();\n          }\n        }\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        // -1 to skip flags\n        in.setPosition(arc.nextArc - 1);\n      }\n    }\n    return readLabel(in);\n  }\n\n","sourceOld":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  public int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" +\n      //arc.nextArc);\n      \n      long pos = arc.nextArc;\n      in.setPosition(pos);\n\n      final byte b = in.readByte();\n      if (b == ARCS_AS_FIXED_ARRAY) {\n        //System.out.println(\"    nextArc fixed array\");\n        in.readVInt();\n\n        // Skip bytesPerArc:\n        in.readVInt();\n      } else {\n        in.setPosition(pos);\n      }\n    } else {\n      if (arc.bytesPerArc != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are at fixed entries\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes((1+arc.arcIdx)*arc.bytesPerArc);\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        in.setPosition(arc.nextArc);\n      }\n    }\n    // skip flags\n    in.readByte();\n    return readLabel(in);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54204c8a3ca26aeafd273139fc29baf70d0f6786","date":1564170395,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","sourceNew":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label() == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" +\n      //arc.nextArc);\n      \n      long pos = arc.nextArc();\n      in.setPosition(pos);\n\n      final byte flags = in.readByte();\n      if (flags == ARCS_AS_ARRAY_PACKED || flags == ARCS_AS_ARRAY_WITH_GAPS) {\n        //System.out.println(\"    nextArc fixed array\");\n        in.readVInt();\n\n        // Skip bytesPerArc:\n        in.readVInt();\n      } else {\n        in.setPosition(pos);\n      }\n      // skip flags\n      in.readByte();\n    } else {\n      if (arc.bytesPerArc() != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are in an array\n        if (arc.arcIdx() >= 0) {\n          in.setPosition(arc.posArcsStart());\n          // point at next arc, -1 to skip flags\n          in.skipBytes((1 + arc.arcIdx()) * arc.bytesPerArc() + 1);\n        } else {\n          in.setPosition(arc.nextArc());\n          byte flags = in.readByte();\n          // skip missing arcs\n          while (flag(flags, BIT_MISSING_ARC)) {\n            in.skipBytes(arc.bytesPerArc() - 1);\n            flags = in.readByte();\n          }\n        }\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        // -1 to skip flags\n        in.setPosition(arc.nextArc() - 1);\n      }\n    }\n    return readLabel(in);\n  }\n\n","sourceOld":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  public int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" +\n      //arc.nextArc);\n      \n      long pos = arc.nextArc;\n      in.setPosition(pos);\n\n      final byte flags = in.readByte();\n      if (flags == ARCS_AS_ARRAY_PACKED || flags == ARCS_AS_ARRAY_WITH_GAPS) {\n        //System.out.println(\"    nextArc fixed array\");\n        in.readVInt();\n\n        // Skip bytesPerArc:\n        in.readVInt();\n      } else {\n        in.setPosition(pos);\n      }\n      // skip flags\n      in.readByte();\n    } else {\n      if (arc.bytesPerArc != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are in an array\n        if (arc.arcIdx >= 0) {\n          in.setPosition(arc.posArcsStart);\n          // point at next arc, -1 to skip flags\n          in.skipBytes((1 + arc.arcIdx) * arc.bytesPerArc + 1);\n        } else {\n          in.setPosition(arc.nextArc);\n          byte flags = in.readByte();\n          // skip missing arcs\n          while (flag(flags, BIT_MISSING_ARC)) {\n            in.skipBytes(arc.bytesPerArc - 1);\n            flags = in.readByte();\n          }\n        }\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        // -1 to skip flags\n        in.setPosition(arc.nextArc - 1);\n      }\n    }\n    return readLabel(in);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8061ddd97f3352007d927dae445884a6f3d857b","date":1564988276,"type":3,"author":"Atri Sharma","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","sourceNew":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label() == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" +\n      //arc.nextArc);\n      \n      long pos = arc.nextArc();\n      in.setPosition(pos);\n\n      final byte flags = in.readByte();\n      if (flags == ARCS_AS_ARRAY_PACKED || flags == ARCS_AS_ARRAY_WITH_GAPS) {\n        //System.out.println(\"    nextArc fixed array\");\n        in.readVInt();\n\n        // Skip bytesPerArc:\n        in.readVInt();\n      } else {\n        in.setPosition(pos);\n      }\n      // skip flags\n      in.readByte();\n    } else {\n      if (arc.bytesPerArc() != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are in an array\n        if (arc.arcIdx() >= 0) {\n          in.setPosition(arc.posArcsStart());\n          // point at next arc, -1 to skip flags\n          in.skipBytes((1 + arc.arcIdx()) * arc.bytesPerArc() + 1);\n        } else {\n          in.setPosition(arc.nextArc());\n          byte flags = in.readByte();\n          // skip missing arcs\n          while (flag(flags, BIT_MISSING_ARC)) {\n            in.skipBytes(arc.bytesPerArc() - 1);\n            flags = in.readByte();\n          }\n        }\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        // -1 to skip flags\n        in.setPosition(arc.nextArc() - 1);\n      }\n    }\n    return readLabel(in);\n  }\n\n","sourceOld":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  public int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" +\n      //arc.nextArc);\n      \n      long pos = arc.nextArc;\n      in.setPosition(pos);\n\n      final byte flags = in.readByte();\n      if (flags == ARCS_AS_ARRAY_PACKED || flags == ARCS_AS_ARRAY_WITH_GAPS) {\n        //System.out.println(\"    nextArc fixed array\");\n        in.readVInt();\n\n        // Skip bytesPerArc:\n        in.readVInt();\n      } else {\n        in.setPosition(pos);\n      }\n      // skip flags\n      in.readByte();\n    } else {\n      if (arc.bytesPerArc != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are in an array\n        if (arc.arcIdx >= 0) {\n          in.setPosition(arc.posArcsStart);\n          // point at next arc, -1 to skip flags\n          in.skipBytes((1 + arc.arcIdx) * arc.bytesPerArc + 1);\n        } else {\n          in.setPosition(arc.nextArc);\n          byte flags = in.readByte();\n          // skip missing arcs\n          while (flag(flags, BIT_MISSING_ARC)) {\n            in.skipBytes(arc.bytesPerArc - 1);\n            flags = in.readByte();\n          }\n        }\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        // -1 to skip flags\n        in.setPosition(arc.nextArc - 1);\n      }\n    }\n    return readLabel(in);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e19a701ad1d5fd2dd25e0f79bb5d81df864116b","date":1571070636,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","sourceNew":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label() == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" +\n      //arc.nextArc);\n      \n      long pos = arc.nextArc();\n      in.setPosition(pos);\n\n      final byte flags = in.readByte();\n      if (flags == ARCS_AS_ARRAY_PACKED) {\n        //System.out.println(\"    nextArc fixed array\");\n        in.readVInt();\n\n        // Skip bytesPerArc:\n        in.readVInt();\n      } else {\n        in.setPosition(pos);\n      }\n      // skip flags\n      in.readByte();\n    } else {\n      if (arc.bytesPerArc() != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are in an array\n        if (arc.arcIdx() >= 0) {\n          in.setPosition(arc.posArcsStart());\n          // point at next arc, -1 to skip flags\n          in.skipBytes((1 + arc.arcIdx()) * arc.bytesPerArc() + 1);\n        } else {\n          in.setPosition(arc.nextArc());\n          byte flags = in.readByte();\n          // skip missing arcs\n          while (flag(flags, BIT_MISSING_ARC)) {\n            in.skipBytes(arc.bytesPerArc() - 1);\n            flags = in.readByte();\n          }\n        }\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        // -1 to skip flags\n        in.setPosition(arc.nextArc() - 1);\n      }\n    }\n    return readLabel(in);\n  }\n\n","sourceOld":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label() == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" +\n      //arc.nextArc);\n      \n      long pos = arc.nextArc();\n      in.setPosition(pos);\n\n      final byte flags = in.readByte();\n      if (flags == ARCS_AS_ARRAY_PACKED || flags == ARCS_AS_ARRAY_WITH_GAPS) {\n        //System.out.println(\"    nextArc fixed array\");\n        in.readVInt();\n\n        // Skip bytesPerArc:\n        in.readVInt();\n      } else {\n        in.setPosition(pos);\n      }\n      // skip flags\n      in.readByte();\n    } else {\n      if (arc.bytesPerArc() != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are in an array\n        if (arc.arcIdx() >= 0) {\n          in.setPosition(arc.posArcsStart());\n          // point at next arc, -1 to skip flags\n          in.skipBytes((1 + arc.arcIdx()) * arc.bytesPerArc() + 1);\n        } else {\n          in.setPosition(arc.nextArc());\n          byte flags = in.readByte();\n          // skip missing arcs\n          while (flag(flags, BIT_MISSING_ARC)) {\n            in.skipBytes(arc.bytesPerArc() - 1);\n            flags = in.readByte();\n          }\n        }\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        // -1 to skip flags\n        in.setPosition(arc.nextArc() - 1);\n      }\n    }\n    return readLabel(in);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","sourceNew":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label() == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" +\n      //arc.nextArc);\n      \n      long pos = arc.nextArc();\n      in.setPosition(pos);\n\n      final byte flags = in.readByte();\n      if (flags == ARCS_AS_ARRAY_PACKED) {\n        //System.out.println(\"    nextArc fixed array\");\n        in.readVInt();\n\n        // Skip bytesPerArc:\n        in.readVInt();\n      } else {\n        in.setPosition(pos);\n      }\n      // skip flags\n      in.readByte();\n    } else {\n      if (arc.bytesPerArc() != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are in an array\n        if (arc.arcIdx() >= 0) {\n          in.setPosition(arc.posArcsStart());\n          // point at next arc, -1 to skip flags\n          in.skipBytes((1 + arc.arcIdx()) * arc.bytesPerArc() + 1);\n        } else {\n          in.setPosition(arc.nextArc());\n          byte flags = in.readByte();\n          // skip missing arcs\n          while (flag(flags, BIT_MISSING_ARC)) {\n            in.skipBytes(arc.bytesPerArc() - 1);\n            flags = in.readByte();\n          }\n        }\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        // -1 to skip flags\n        in.setPosition(arc.nextArc() - 1);\n      }\n    }\n    return readLabel(in);\n  }\n\n","sourceOld":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label() == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" +\n      //arc.nextArc);\n      \n      long pos = arc.nextArc();\n      in.setPosition(pos);\n\n      final byte flags = in.readByte();\n      if (flags == ARCS_AS_ARRAY_PACKED || flags == ARCS_AS_ARRAY_WITH_GAPS) {\n        //System.out.println(\"    nextArc fixed array\");\n        in.readVInt();\n\n        // Skip bytesPerArc:\n        in.readVInt();\n      } else {\n        in.setPosition(pos);\n      }\n      // skip flags\n      in.readByte();\n    } else {\n      if (arc.bytesPerArc() != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are in an array\n        if (arc.arcIdx() >= 0) {\n          in.setPosition(arc.posArcsStart());\n          // point at next arc, -1 to skip flags\n          in.skipBytes((1 + arc.arcIdx()) * arc.bytesPerArc() + 1);\n        } else {\n          in.setPosition(arc.nextArc());\n          byte flags = in.readByte();\n          // skip missing arcs\n          while (flag(flags, BIT_MISSING_ARC)) {\n            in.skipBytes(arc.bytesPerArc() - 1);\n            flags = in.readByte();\n          }\n        }\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        // -1 to skip flags\n        in.setPosition(arc.nextArc() - 1);\n      }\n    }\n    return readLabel(in);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"71d31a7d5773508492505519bb5230b87c8937ad","date":1573681693,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","sourceNew":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label() == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" + arc.nextArc);\n      // Next arc is the first arc of a node.\n      // Position to read the first arc label.\n\n      in.setPosition(arc.nextArc());\n      byte flags = in.readByte();\n      if (flags == ARCS_FOR_BINARY_SEARCH || flags == ARCS_FOR_DIRECT_ADDRESSING) {\n        //System.out.println(\"    nextArc fixed length arc\");\n        // Special arc which is actually a node header for fixed length arcs.\n        int numArcs = in.readVInt();\n        in.readVInt(); // Skip bytesPerArc.\n        if (flags == ARCS_FOR_BINARY_SEARCH) {\n          in.readByte(); // Skip arc flags.\n        } else {\n          in.skipBytes(getNumPresenceBytes(numArcs));\n        }\n      }\n    } else {\n      if (arc.bytesPerArc() != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // Arcs have fixed length.\n        if (arc.nodeFlags() == ARCS_FOR_BINARY_SEARCH) {\n          // Point to next arc, -1 to skip arc flags.\n          in.setPosition(arc.posArcsStart() - (1 + arc.arcIdx()) * arc.bytesPerArc() - 1);\n        } else {\n          assert arc.nodeFlags() == ARCS_FOR_DIRECT_ADDRESSING;\n          // Direct addressing node. The label is not stored but rather inferred\n          // based on first label and arc index in the range.\n          assert assertPresenceBytesAreValid(arc);\n          assert arc.bitTable().isBitSet(arc.arcIdx());\n          int nextIndex = arc.bitTable().nextBitSet(arc.arcIdx());\n          assert nextIndex != -1;\n          return arc.firstLabel() + nextIndex;\n        }\n      } else {\n        // Arcs have variable length.\n        //System.out.println(\"    nextArc real list\");\n        // Position to next arc, -1 to skip flags.\n        in.setPosition(arc.nextArc() - 1);\n      }\n    }\n    return readLabel(in);\n  }\n\n","sourceOld":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label() == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" +\n      //arc.nextArc);\n      \n      long pos = arc.nextArc();\n      in.setPosition(pos);\n\n      final byte flags = in.readByte();\n      if (flags == ARCS_AS_ARRAY_PACKED) {\n        //System.out.println(\"    nextArc fixed array\");\n        in.readVInt();\n\n        // Skip bytesPerArc:\n        in.readVInt();\n      } else {\n        in.setPosition(pos);\n      }\n      // skip flags\n      in.readByte();\n    } else {\n      if (arc.bytesPerArc() != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // arcs are in an array\n        if (arc.arcIdx() >= 0) {\n          in.setPosition(arc.posArcsStart());\n          // point at next arc, -1 to skip flags\n          in.skipBytes((1 + arc.arcIdx()) * arc.bytesPerArc() + 1);\n        } else {\n          in.setPosition(arc.nextArc());\n          byte flags = in.readByte();\n          // skip missing arcs\n          while (flag(flags, BIT_MISSING_ARC)) {\n            in.skipBytes(arc.bytesPerArc() - 1);\n            flags = in.readByte();\n          }\n        }\n      } else {\n        // arcs are packed\n        //System.out.println(\"    nextArc real packed\");\n        // -1 to skip flags\n        in.setPosition(arc.nextArc() - 1);\n      }\n    }\n    return readLabel(in);\n  }\n\n","bugFix":null,"bugIntro":["06086b5bd0f0d57858f0675becc58edf1f6b7c11"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"06086b5bd0f0d57858f0675becc58edf1f6b7c11","date":1586421397,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#readNextArcLabel(Arc[T],BytesReader).mjava","sourceNew":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label() == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" + arc.nextArc);\n      // Next arc is the first arc of a node.\n      // Position to read the first arc label.\n\n      in.setPosition(arc.nextArc());\n      byte flags = in.readByte();\n      if (flags == ARCS_FOR_BINARY_SEARCH || flags == ARCS_FOR_DIRECT_ADDRESSING) {\n        //System.out.println(\"    nextArc fixed length arc\");\n        // Special arc which is actually a node header for fixed length arcs.\n        int numArcs = in.readVInt();\n        in.readVInt(); // Skip bytesPerArc.\n        if (flags == ARCS_FOR_BINARY_SEARCH) {\n          in.readByte(); // Skip arc flags.\n        } else {\n          in.skipBytes(getNumPresenceBytes(numArcs));\n        }\n      }\n    } else {\n      if (arc.bytesPerArc() != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // Arcs have fixed length.\n        if (arc.nodeFlags() == ARCS_FOR_BINARY_SEARCH) {\n          // Point to next arc, -1 to skip arc flags.\n          in.setPosition(arc.posArcsStart() - (1 + arc.arcIdx()) * arc.bytesPerArc() - 1);\n        } else {\n          assert arc.nodeFlags() == ARCS_FOR_DIRECT_ADDRESSING;\n          // Direct addressing node. The label is not stored but rather inferred\n          // based on first label and arc index in the range.\n          assert BitTable.assertIsValid(arc, in);\n          assert BitTable.isBitSet(arc.arcIdx(), arc, in);\n          int nextIndex = BitTable.nextBitSet(arc.arcIdx(), arc, in);\n          assert nextIndex != -1;\n          return arc.firstLabel() + nextIndex;\n        }\n      } else {\n        // Arcs have variable length.\n        //System.out.println(\"    nextArc real list\");\n        // Position to next arc, -1 to skip flags.\n        in.setPosition(arc.nextArc() - 1);\n      }\n    }\n    return readLabel(in);\n  }\n\n","sourceOld":"  /** Peeks at next arc's label; does not alter arc.  Do\n   *  not call this if arc.isLast()! */\n  int readNextArcLabel(Arc<T> arc, BytesReader in) throws IOException {\n    assert !arc.isLast();\n\n    if (arc.label() == END_LABEL) {\n      //System.out.println(\"    nextArc fake \" + arc.nextArc);\n      // Next arc is the first arc of a node.\n      // Position to read the first arc label.\n\n      in.setPosition(arc.nextArc());\n      byte flags = in.readByte();\n      if (flags == ARCS_FOR_BINARY_SEARCH || flags == ARCS_FOR_DIRECT_ADDRESSING) {\n        //System.out.println(\"    nextArc fixed length arc\");\n        // Special arc which is actually a node header for fixed length arcs.\n        int numArcs = in.readVInt();\n        in.readVInt(); // Skip bytesPerArc.\n        if (flags == ARCS_FOR_BINARY_SEARCH) {\n          in.readByte(); // Skip arc flags.\n        } else {\n          in.skipBytes(getNumPresenceBytes(numArcs));\n        }\n      }\n    } else {\n      if (arc.bytesPerArc() != 0) {\n        //System.out.println(\"    nextArc real array\");\n        // Arcs have fixed length.\n        if (arc.nodeFlags() == ARCS_FOR_BINARY_SEARCH) {\n          // Point to next arc, -1 to skip arc flags.\n          in.setPosition(arc.posArcsStart() - (1 + arc.arcIdx()) * arc.bytesPerArc() - 1);\n        } else {\n          assert arc.nodeFlags() == ARCS_FOR_DIRECT_ADDRESSING;\n          // Direct addressing node. The label is not stored but rather inferred\n          // based on first label and arc index in the range.\n          assert assertPresenceBytesAreValid(arc);\n          assert arc.bitTable().isBitSet(arc.arcIdx());\n          int nextIndex = arc.bitTable().nextBitSet(arc.arcIdx());\n          assert nextIndex != -1;\n          return arc.firstLabel() + nextIndex;\n        }\n      } else {\n        // Arcs have variable length.\n        //System.out.println(\"    nextArc real list\");\n        // Position to next arc, -1 to skip flags.\n        in.setPosition(arc.nextArc() - 1);\n      }\n    }\n    return readLabel(in);\n  }\n\n","bugFix":["71d31a7d5773508492505519bb5230b87c8937ad"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c0e7448656541edc407546460641f47950451b16":["6244579a467d5f2673ac98265d74bddbea1a8114"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["8b9fb5afeea0288262bffcc55bdcda8b5fa272c8","cb27634f76319b68d6d8fd11a7104d20294722c5"],"8b9fb5afeea0288262bffcc55bdcda8b5fa272c8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0":["fc6d3be942e675e8251dbe10796cdb3a484bf607"],"8917bfede3b4ca30f4305c1e391e9218959cd723":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"556c8202987f72dd8458e25e21a82d98fc274979":["87e78f3c129251e74ecc2ff73a32de0f27cf09d5"],"6244579a467d5f2673ac98265d74bddbea1a8114":["d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":["d3c397b1515e745d8b12d70edfc0e17cb7eac7f0","6244579a467d5f2673ac98265d74bddbea1a8114"],"71d31a7d5773508492505519bb5230b87c8937ad":["3e19a701ad1d5fd2dd25e0f79bb5d81df864116b"],"ae67e1f82a53594208ca929f382ee861dad3d7a8":["c0e7448656541edc407546460641f47950451b16"],"87e78f3c129251e74ecc2ff73a32de0f27cf09d5":["cb27634f76319b68d6d8fd11a7104d20294722c5"],"f8061ddd97f3352007d927dae445884a6f3d857b":["ae67e1f82a53594208ca929f382ee861dad3d7a8","54204c8a3ca26aeafd273139fc29baf70d0f6786"],"cb27634f76319b68d6d8fd11a7104d20294722c5":["8b9fb5afeea0288262bffcc55bdcda8b5fa272c8"],"54204c8a3ca26aeafd273139fc29baf70d0f6786":["ae67e1f82a53594208ca929f382ee861dad3d7a8"],"06086b5bd0f0d57858f0675becc58edf1f6b7c11":["71d31a7d5773508492505519bb5230b87c8937ad"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3e19a701ad1d5fd2dd25e0f79bb5d81df864116b":["54204c8a3ca26aeafd273139fc29baf70d0f6786"],"fc6d3be942e675e8251dbe10796cdb3a484bf607":["556c8202987f72dd8458e25e21a82d98fc274979"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["06086b5bd0f0d57858f0675becc58edf1f6b7c11"],"b0b597c65628ca9e73913a07e81691f8229bae35":["54204c8a3ca26aeafd273139fc29baf70d0f6786","3e19a701ad1d5fd2dd25e0f79bb5d81df864116b"]},"commit2Childs":{"c0e7448656541edc407546460641f47950451b16":["ae67e1f82a53594208ca929f382ee861dad3d7a8"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["8917bfede3b4ca30f4305c1e391e9218959cd723"],"8b9fb5afeea0288262bffcc55bdcda8b5fa272c8":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","cb27634f76319b68d6d8fd11a7104d20294722c5"],"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0":["8917bfede3b4ca30f4305c1e391e9218959cd723","6244579a467d5f2673ac98265d74bddbea1a8114","199dfa410f1fdbfd3294106b04096cce5ed34b21"],"8917bfede3b4ca30f4305c1e391e9218959cd723":[],"556c8202987f72dd8458e25e21a82d98fc274979":["fc6d3be942e675e8251dbe10796cdb3a484bf607"],"6244579a467d5f2673ac98265d74bddbea1a8114":["c0e7448656541edc407546460641f47950451b16","199dfa410f1fdbfd3294106b04096cce5ed34b21"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":[],"87e78f3c129251e74ecc2ff73a32de0f27cf09d5":["556c8202987f72dd8458e25e21a82d98fc274979"],"71d31a7d5773508492505519bb5230b87c8937ad":["06086b5bd0f0d57858f0675becc58edf1f6b7c11"],"ae67e1f82a53594208ca929f382ee861dad3d7a8":["f8061ddd97f3352007d927dae445884a6f3d857b","54204c8a3ca26aeafd273139fc29baf70d0f6786"],"f8061ddd97f3352007d927dae445884a6f3d857b":[],"cb27634f76319b68d6d8fd11a7104d20294722c5":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","87e78f3c129251e74ecc2ff73a32de0f27cf09d5"],"54204c8a3ca26aeafd273139fc29baf70d0f6786":["f8061ddd97f3352007d927dae445884a6f3d857b","3e19a701ad1d5fd2dd25e0f79bb5d81df864116b","b0b597c65628ca9e73913a07e81691f8229bae35"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8b9fb5afeea0288262bffcc55bdcda8b5fa272c8"],"06086b5bd0f0d57858f0675becc58edf1f6b7c11":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3e19a701ad1d5fd2dd25e0f79bb5d81df864116b":["71d31a7d5773508492505519bb5230b87c8937ad","b0b597c65628ca9e73913a07e81691f8229bae35"],"fc6d3be942e675e8251dbe10796cdb3a484bf607":["d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["8917bfede3b4ca30f4305c1e391e9218959cd723","199dfa410f1fdbfd3294106b04096cce5ed34b21","f8061ddd97f3352007d927dae445884a6f3d857b","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}