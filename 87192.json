{"path":"lucene/core/src/test/org/apache/lucene/search/TestLRUFilterCache#testConcurrency().mjava","commits":[{"id":"e5eed7b3a60b52b9f1c32db9c49da397e06f88af","date":1417105424,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLRUFilterCache#testConcurrency().mjava","pathOld":"/dev/null","sourceNew":"  public void testConcurrency() throws Throwable {\n    final LRUFilterCache filterCache = new LRUFilterCache(1 + random().nextInt(20), 1 + random().nextInt(10000));\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    SearcherManager mgr = new SearcherManager(w.w, random().nextBoolean(), new SearcherFactory());\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                filterCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Filter f = new QueryWrapperFilter(new TermQuery(new Term(\"color\", value)));\n                final Filter cached = filterCache.doCache(f, MAYBE_CACHE_POLICY);\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(new ConstantScoreQuery(cached), collector);\n                TotalHitCountCollector collector2 = new TotalHitCountCollector();\n                searcher.search(new ConstantScoreQuery(f), collector2);\n                assertEquals(collector.getTotalHits(), collector2.getTotalHits());\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    filterCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    filterCache.assertConsistent();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60596f28be69b10c37a56a303c2dbea07b2ca4ba","date":1425060541,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLRUFilterCache#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000));\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                final int totalHits2 = searcher.search(q, 1).totalHits; // will not use the cache because of scores\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Throwable {\n    final LRUFilterCache filterCache = new LRUFilterCache(1 + random().nextInt(20), 1 + random().nextInt(10000));\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    SearcherManager mgr = new SearcherManager(w.w, random().nextBoolean(), new SearcherFactory());\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                filterCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Filter f = new QueryWrapperFilter(new TermQuery(new Term(\"color\", value)));\n                final Filter cached = filterCache.doCache(f, MAYBE_CACHE_POLICY);\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(new ConstantScoreQuery(cached), collector);\n                TotalHitCountCollector collector2 = new TotalHitCountCollector();\n                searcher.search(new ConstantScoreQuery(f), collector2);\n                assertEquals(collector.getTotalHits(), collector2.getTotalHits());\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    filterCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    filterCache.assertConsistent();\n  }\n\n","bugFix":null,"bugIntro":["f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":4,"author":"Ryan Ernst","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLRUFilterCache#testConcurrency().mjava","sourceNew":null,"sourceOld":"  public void testConcurrency() throws Throwable {\n    final LRUFilterCache filterCache = new LRUFilterCache(1 + random().nextInt(20), 1 + random().nextInt(10000));\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    SearcherManager mgr = new SearcherManager(w.w, random().nextBoolean(), new SearcherFactory());\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                filterCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Filter f = new QueryWrapperFilter(new TermQuery(new Term(\"color\", value)));\n                final Filter cached = filterCache.doCache(f, MAYBE_CACHE_POLICY);\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(new ConstantScoreQuery(cached), collector);\n                TotalHitCountCollector collector2 = new TotalHitCountCollector();\n                searcher.search(new ConstantScoreQuery(f), collector2);\n                assertEquals(collector.getTotalHits(), collector2.getTotalHits());\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    filterCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    filterCache.assertConsistent();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["e5eed7b3a60b52b9f1c32db9c49da397e06f88af","60596f28be69b10c37a56a303c2dbea07b2ca4ba"],"60596f28be69b10c37a56a303c2dbea07b2ca4ba":["e5eed7b3a60b52b9f1c32db9c49da397e06f88af"],"e5eed7b3a60b52b9f1c32db9c49da397e06f88af":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["60596f28be69b10c37a56a303c2dbea07b2ca4ba"]},"commit2Childs":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"60596f28be69b10c37a56a303c2dbea07b2ca4ba":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e5eed7b3a60b52b9f1c32db9c49da397e06f88af":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","60596f28be69b10c37a56a303c2dbea07b2ca4ba"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e5eed7b3a60b52b9f1c32db9c49da397e06f88af"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}