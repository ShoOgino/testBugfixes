{"path":"lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery#testSingleQueryExactMatchScoresHighest().mjava","commits":[{"id":"9f7c14f40c65357617cada58ca9b026ab9f81c24","date":1432120112,"type":0,"author":"Mark Harwood","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery#testSingleQueryExactMatchScoresHighest().mjava","pathOld":"/dev/null","sourceNew":"  public void testSingleQueryExactMatchScoresHighest() throws Exception {\n    //See issue LUCENE-329 - IDF shouldn't wreck similarity ranking \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    addDoc(\"smith\", writer);\n    addDoc(\"smith\", writer);\n    addDoc(\"smith\", writer);\n    addDoc(\"smith\", writer);\n    addDoc(\"smith\", writer);\n    addDoc(\"smith\", writer);\n    addDoc(\"smythe\", writer);\n    addDoc(\"smdssasd\", writer);\n\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new DefaultSimilarity()); //avoid randomisation of similarity algo by test framework\n    writer.close();\n    String searchTerms[] = { \"smith\", \"smythe\", \"smdssasd\" };\n    for (String searchTerm : searchTerms) {\n      FuzzyQuery query = new FuzzyQuery(new Term(\"field\", searchTerm), 2, 1);\n      ScoreDoc[] hits = searcher.search(query, 1000).scoreDocs;\n      StoredDocument bestDoc = searcher.doc(hits[0].doc);\n      assertTrue(hits.length > 0);\n      String topMatch = bestDoc.get(\"field\");\n      assertEquals(searchTerm, topMatch);\n      if (hits.length > 1) {\n        StoredDocument worstDoc = searcher.doc(hits[hits.length - 1].doc);\n        String worstMatch = worstDoc.get(\"field\");\n        assertNotSame(searchTerm, worstMatch);\n      }\n    }\n    reader.close();\n    directory.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81d0720146de53dd3a4a023d2a3d1089d86d748d","date":1442268215,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery#testSingleQueryExactMatchScoresHighest().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery#testSingleQueryExactMatchScoresHighest().mjava","sourceNew":"  public void testSingleQueryExactMatchScoresHighest() throws Exception {\n    //See issue LUCENE-329 - IDF shouldn't wreck similarity ranking \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    addDoc(\"smith\", writer);\n    addDoc(\"smith\", writer);\n    addDoc(\"smith\", writer);\n    addDoc(\"smith\", writer);\n    addDoc(\"smith\", writer);\n    addDoc(\"smith\", writer);\n    addDoc(\"smythe\", writer);\n    addDoc(\"smdssasd\", writer);\n\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new ClassicSimilarity()); //avoid randomisation of similarity algo by test framework\n    writer.close();\n    String searchTerms[] = { \"smith\", \"smythe\", \"smdssasd\" };\n    for (String searchTerm : searchTerms) {\n      FuzzyQuery query = new FuzzyQuery(new Term(\"field\", searchTerm), 2, 1);\n      ScoreDoc[] hits = searcher.search(query, 1000).scoreDocs;\n      StoredDocument bestDoc = searcher.doc(hits[0].doc);\n      assertTrue(hits.length > 0);\n      String topMatch = bestDoc.get(\"field\");\n      assertEquals(searchTerm, topMatch);\n      if (hits.length > 1) {\n        StoredDocument worstDoc = searcher.doc(hits[hits.length - 1].doc);\n        String worstMatch = worstDoc.get(\"field\");\n        assertNotSame(searchTerm, worstMatch);\n      }\n    }\n    reader.close();\n    directory.close();\n  }\n\n","sourceOld":"  public void testSingleQueryExactMatchScoresHighest() throws Exception {\n    //See issue LUCENE-329 - IDF shouldn't wreck similarity ranking \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    addDoc(\"smith\", writer);\n    addDoc(\"smith\", writer);\n    addDoc(\"smith\", writer);\n    addDoc(\"smith\", writer);\n    addDoc(\"smith\", writer);\n    addDoc(\"smith\", writer);\n    addDoc(\"smythe\", writer);\n    addDoc(\"smdssasd\", writer);\n\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new DefaultSimilarity()); //avoid randomisation of similarity algo by test framework\n    writer.close();\n    String searchTerms[] = { \"smith\", \"smythe\", \"smdssasd\" };\n    for (String searchTerm : searchTerms) {\n      FuzzyQuery query = new FuzzyQuery(new Term(\"field\", searchTerm), 2, 1);\n      ScoreDoc[] hits = searcher.search(query, 1000).scoreDocs;\n      StoredDocument bestDoc = searcher.doc(hits[0].doc);\n      assertTrue(hits.length > 0);\n      String topMatch = bestDoc.get(\"field\");\n      assertEquals(searchTerm, topMatch);\n      if (hits.length > 1) {\n        StoredDocument worstDoc = searcher.doc(hits[hits.length - 1].doc);\n        String worstMatch = worstDoc.get(\"field\");\n        assertNotSame(searchTerm, worstMatch);\n      }\n    }\n    reader.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c","date":1453060490,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery#testSingleQueryExactMatchScoresHighest().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery#testSingleQueryExactMatchScoresHighest().mjava","sourceNew":"  public void testSingleQueryExactMatchScoresHighest() throws Exception {\n    //See issue LUCENE-329 - IDF shouldn't wreck similarity ranking \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    addDoc(\"smith\", writer);\n    addDoc(\"smith\", writer);\n    addDoc(\"smith\", writer);\n    addDoc(\"smith\", writer);\n    addDoc(\"smith\", writer);\n    addDoc(\"smith\", writer);\n    addDoc(\"smythe\", writer);\n    addDoc(\"smdssasd\", writer);\n\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new ClassicSimilarity()); //avoid randomisation of similarity algo by test framework\n    writer.close();\n    String searchTerms[] = { \"smith\", \"smythe\", \"smdssasd\" };\n    for (String searchTerm : searchTerms) {\n      FuzzyQuery query = new FuzzyQuery(new Term(\"field\", searchTerm), 2, 1);\n      ScoreDoc[] hits = searcher.search(query, 1000).scoreDocs;\n      Document bestDoc = searcher.doc(hits[0].doc);\n      assertTrue(hits.length > 0);\n      String topMatch = bestDoc.get(\"field\");\n      assertEquals(searchTerm, topMatch);\n      if (hits.length > 1) {\n        Document worstDoc = searcher.doc(hits[hits.length - 1].doc);\n        String worstMatch = worstDoc.get(\"field\");\n        assertNotSame(searchTerm, worstMatch);\n      }\n    }\n    reader.close();\n    directory.close();\n  }\n\n","sourceOld":"  public void testSingleQueryExactMatchScoresHighest() throws Exception {\n    //See issue LUCENE-329 - IDF shouldn't wreck similarity ranking \n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);\n    addDoc(\"smith\", writer);\n    addDoc(\"smith\", writer);\n    addDoc(\"smith\", writer);\n    addDoc(\"smith\", writer);\n    addDoc(\"smith\", writer);\n    addDoc(\"smith\", writer);\n    addDoc(\"smythe\", writer);\n    addDoc(\"smdssasd\", writer);\n\n    IndexReader reader = writer.getReader();\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new ClassicSimilarity()); //avoid randomisation of similarity algo by test framework\n    writer.close();\n    String searchTerms[] = { \"smith\", \"smythe\", \"smdssasd\" };\n    for (String searchTerm : searchTerms) {\n      FuzzyQuery query = new FuzzyQuery(new Term(\"field\", searchTerm), 2, 1);\n      ScoreDoc[] hits = searcher.search(query, 1000).scoreDocs;\n      StoredDocument bestDoc = searcher.doc(hits[0].doc);\n      assertTrue(hits.length > 0);\n      String topMatch = bestDoc.get(\"field\");\n      assertEquals(searchTerm, topMatch);\n      if (hits.length > 1) {\n        StoredDocument worstDoc = searcher.doc(hits[hits.length - 1].doc);\n        String worstMatch = worstDoc.get(\"field\");\n        assertNotSame(searchTerm, worstMatch);\n      }\n    }\n    reader.close();\n    directory.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9f7c14f40c65357617cada58ca9b026ab9f81c24":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"81d0720146de53dd3a4a023d2a3d1089d86d748d":["9f7c14f40c65357617cada58ca9b026ab9f81c24"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c"],"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c":["81d0720146de53dd3a4a023d2a3d1089d86d748d"]},"commit2Childs":{"9f7c14f40c65357617cada58ca9b026ab9f81c24":["81d0720146de53dd3a4a023d2a3d1089d86d748d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9f7c14f40c65357617cada58ca9b026ab9f81c24"],"81d0720146de53dd3a4a023d2a3d1089d86d748d":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}