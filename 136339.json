{"path":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int,ScoreMergeMode).mjava","commits":[{"id":"85d41890f2bad879e6a04c6dd7d2cf276f973994","date":1338488367,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int,ScoreMergeMode).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int).mjava","sourceNew":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN, ScoreMergeMode scoreMergeMode)\n    throws IOException {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs = new TopDocs[shardGroups.length];\n    float totalMaxScore = Float.MIN_VALUE;\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      double scoreSum = 0.0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                             shardGroupDocs.scoreDocs,\n                                             shardGroupDocs.maxScore);\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n        scoreSum += shardGroupDocs.score;\n      }\n\n      final TopDocs mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, shardTopDocs);\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n\n      final float groupScore;\n      switch(scoreMergeMode) {\n      case None:\n        groupScore = Float.NaN;\n        break;\n      case Avg:\n        if (totalHits > 0) {\n          groupScore = (float) (scoreSum / totalHits);\n        } else {\n          groupScore = Float.NaN;\n        }\n        break;\n      case Total:\n        groupScore = (float) scoreSum;\n        break;\n      default:\n        throw new IllegalArgumentException(\"can't handle ScoreMergeMode \" + scoreMergeMode);\n      }\n        \n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<T>(groupScore,\n                                                   maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n      totalMaxScore = Math.max(totalMaxScore, maxScore);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<T>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n      return new TopGroups<T>(result, totalGroupCount);\n    } else {\n      return new TopGroups<T>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n    }\n  }\n\n","sourceOld":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN)\n    throws IOException {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs = new TopDocs[shardGroups.length];\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                             shardGroupDocs.scoreDocs,\n                                             shardGroupDocs.maxScore);\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n      }\n\n      final TopDocs mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, shardTopDocs);\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<T>(maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<T>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs);\n      return new TopGroups<T>(result, totalGroupCount);\n    } else {\n      return new TopGroups<T>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"97d4692d0c601ff773f0a2231967312428a904e4","date":1366026608,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int,ScoreMergeMode).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int,ScoreMergeMode).mjava","sourceNew":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN, ScoreMergeMode scoreMergeMode)\n    throws IOException {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs = new TopDocs[shardGroups.length];\n    float totalMaxScore = Float.MIN_VALUE;\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      double scoreSum = 0.0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                             shardGroupDocs.scoreDocs,\n                                             shardGroupDocs.maxScore);\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n        scoreSum += shardGroupDocs.score;\n      }\n\n      final TopDocs mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, shardTopDocs);\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n\n      final float groupScore;\n      switch(scoreMergeMode) {\n      case None:\n        groupScore = Float.NaN;\n        break;\n      case Avg:\n        if (totalHits > 0) {\n          groupScore = (float) (scoreSum / totalHits);\n        } else {\n          groupScore = Float.NaN;\n        }\n        break;\n      case Total:\n        groupScore = (float) scoreSum;\n        break;\n      default:\n        throw new IllegalArgumentException(\"can't handle ScoreMergeMode \" + scoreMergeMode);\n      }\n        \n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<>(groupScore,\n                                                   maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n      totalMaxScore = Math.max(totalMaxScore, maxScore);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n      return new TopGroups<>(result, totalGroupCount);\n    } else {\n      return new TopGroups<>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n    }\n  }\n\n","sourceOld":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN, ScoreMergeMode scoreMergeMode)\n    throws IOException {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs = new TopDocs[shardGroups.length];\n    float totalMaxScore = Float.MIN_VALUE;\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      double scoreSum = 0.0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                             shardGroupDocs.scoreDocs,\n                                             shardGroupDocs.maxScore);\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n        scoreSum += shardGroupDocs.score;\n      }\n\n      final TopDocs mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, shardTopDocs);\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n\n      final float groupScore;\n      switch(scoreMergeMode) {\n      case None:\n        groupScore = Float.NaN;\n        break;\n      case Avg:\n        if (totalHits > 0) {\n          groupScore = (float) (scoreSum / totalHits);\n        } else {\n          groupScore = Float.NaN;\n        }\n        break;\n      case Total:\n        groupScore = (float) scoreSum;\n        break;\n      default:\n        throw new IllegalArgumentException(\"can't handle ScoreMergeMode \" + scoreMergeMode);\n      }\n        \n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<T>(groupScore,\n                                                   maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n      totalMaxScore = Math.max(totalMaxScore, maxScore);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<T>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n      return new TopGroups<T>(result, totalGroupCount);\n    } else {\n      return new TopGroups<T>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fb17639909a369c1e64866842e5c213440acc17e","date":1423238093,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int,ScoreMergeMode).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int,ScoreMergeMode).mjava","sourceNew":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN, ScoreMergeMode scoreMergeMode)\n    throws IOException {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs;\n    if (docSort == null) {\n      shardTopDocs = new TopDocs[shardGroups.length];\n    } else {\n      shardTopDocs = new TopFieldDocs[shardGroups.length];\n    }\n    float totalMaxScore = Float.MIN_VALUE;\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      double scoreSum = 0.0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        if (docSort == null) {\n          shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                               shardGroupDocs.scoreDocs,\n                                               shardGroupDocs.maxScore);\n        } else {\n          shardTopDocs[shardIDX] = new TopFieldDocs(shardGroupDocs.totalHits,\n              shardGroupDocs.scoreDocs,\n              docSort.getSort(),\n              shardGroupDocs.maxScore);\n        }\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n        scoreSum += shardGroupDocs.score;\n      }\n\n      final TopDocs mergedTopDocs;\n      if (docSort == null) {\n        mergedTopDocs = TopDocs.merge(docOffset + docTopN, shardTopDocs);\n      } else {\n        mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, (TopFieldDocs[]) shardTopDocs);\n      }\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n\n      final float groupScore;\n      switch(scoreMergeMode) {\n      case None:\n        groupScore = Float.NaN;\n        break;\n      case Avg:\n        if (totalHits > 0) {\n          groupScore = (float) (scoreSum / totalHits);\n        } else {\n          groupScore = Float.NaN;\n        }\n        break;\n      case Total:\n        groupScore = (float) scoreSum;\n        break;\n      default:\n        throw new IllegalArgumentException(\"can't handle ScoreMergeMode \" + scoreMergeMode);\n      }\n        \n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<>(groupScore,\n                                                   maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n      totalMaxScore = Math.max(totalMaxScore, maxScore);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n      return new TopGroups<>(result, totalGroupCount);\n    } else {\n      return new TopGroups<>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n    }\n  }\n\n","sourceOld":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN, ScoreMergeMode scoreMergeMode)\n    throws IOException {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs = new TopDocs[shardGroups.length];\n    float totalMaxScore = Float.MIN_VALUE;\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      double scoreSum = 0.0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                             shardGroupDocs.scoreDocs,\n                                             shardGroupDocs.maxScore);\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n        scoreSum += shardGroupDocs.score;\n      }\n\n      final TopDocs mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, shardTopDocs);\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n\n      final float groupScore;\n      switch(scoreMergeMode) {\n      case None:\n        groupScore = Float.NaN;\n        break;\n      case Avg:\n        if (totalHits > 0) {\n          groupScore = (float) (scoreSum / totalHits);\n        } else {\n          groupScore = Float.NaN;\n        }\n        break;\n      case Total:\n        groupScore = (float) scoreSum;\n        break;\n      default:\n        throw new IllegalArgumentException(\"can't handle ScoreMergeMode \" + scoreMergeMode);\n      }\n        \n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<>(groupScore,\n                                                   maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n      totalMaxScore = Math.max(totalMaxScore, maxScore);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n      return new TopGroups<>(result, totalGroupCount);\n    } else {\n      return new TopGroups<>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5e8a6094f2ecf9edcd3bb224b087580ac0aa13f2","date":1448513807,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int,ScoreMergeMode).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int,ScoreMergeMode).mjava","sourceNew":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN, ScoreMergeMode scoreMergeMode)\n    throws IOException {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs;\n    if (docSort.equals(Sort.RELEVANCE)) {\n      shardTopDocs = new TopDocs[shardGroups.length];\n    } else {\n      shardTopDocs = new TopFieldDocs[shardGroups.length];\n    }\n    float totalMaxScore = Float.MIN_VALUE;\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      double scoreSum = 0.0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        if (docSort.equals(Sort.RELEVANCE)) {\n          shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                               shardGroupDocs.scoreDocs,\n                                               shardGroupDocs.maxScore);\n        } else {\n          shardTopDocs[shardIDX] = new TopFieldDocs(shardGroupDocs.totalHits,\n              shardGroupDocs.scoreDocs,\n              docSort.getSort(),\n              shardGroupDocs.maxScore);\n        }\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n        scoreSum += shardGroupDocs.score;\n      }\n\n      final TopDocs mergedTopDocs;\n      if (docSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(docOffset + docTopN, shardTopDocs);\n      } else {\n        mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, (TopFieldDocs[]) shardTopDocs);\n      }\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n\n      final float groupScore;\n      switch(scoreMergeMode) {\n      case None:\n        groupScore = Float.NaN;\n        break;\n      case Avg:\n        if (totalHits > 0) {\n          groupScore = (float) (scoreSum / totalHits);\n        } else {\n          groupScore = Float.NaN;\n        }\n        break;\n      case Total:\n        groupScore = (float) scoreSum;\n        break;\n      default:\n        throw new IllegalArgumentException(\"can't handle ScoreMergeMode \" + scoreMergeMode);\n      }\n        \n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<>(groupScore,\n                                                   maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n      totalMaxScore = Math.max(totalMaxScore, maxScore);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n      return new TopGroups<>(result, totalGroupCount);\n    } else {\n      return new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n    }\n  }\n\n","sourceOld":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN, ScoreMergeMode scoreMergeMode)\n    throws IOException {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs;\n    if (docSort == null) {\n      shardTopDocs = new TopDocs[shardGroups.length];\n    } else {\n      shardTopDocs = new TopFieldDocs[shardGroups.length];\n    }\n    float totalMaxScore = Float.MIN_VALUE;\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      double scoreSum = 0.0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        if (docSort == null) {\n          shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                               shardGroupDocs.scoreDocs,\n                                               shardGroupDocs.maxScore);\n        } else {\n          shardTopDocs[shardIDX] = new TopFieldDocs(shardGroupDocs.totalHits,\n              shardGroupDocs.scoreDocs,\n              docSort.getSort(),\n              shardGroupDocs.maxScore);\n        }\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n        scoreSum += shardGroupDocs.score;\n      }\n\n      final TopDocs mergedTopDocs;\n      if (docSort == null) {\n        mergedTopDocs = TopDocs.merge(docOffset + docTopN, shardTopDocs);\n      } else {\n        mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, (TopFieldDocs[]) shardTopDocs);\n      }\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n\n      final float groupScore;\n      switch(scoreMergeMode) {\n      case None:\n        groupScore = Float.NaN;\n        break;\n      case Avg:\n        if (totalHits > 0) {\n          groupScore = (float) (scoreSum / totalHits);\n        } else {\n          groupScore = Float.NaN;\n        }\n        break;\n      case Total:\n        groupScore = (float) scoreSum;\n        break;\n      default:\n        throw new IllegalArgumentException(\"can't handle ScoreMergeMode \" + scoreMergeMode);\n      }\n        \n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<>(groupScore,\n                                                   maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n      totalMaxScore = Math.max(totalMaxScore, maxScore);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n      return new TopGroups<>(result, totalGroupCount);\n    } else {\n      return new TopGroups<>(groupSort.getSort(),\n                              docSort == null ? null : docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"03e38c6374c23083c93e212a9498ff0a9c255476","date":1484767039,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int,ScoreMergeMode).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int,ScoreMergeMode).mjava","sourceNew":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN, ScoreMergeMode scoreMergeMode) {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs;\n    if (docSort.equals(Sort.RELEVANCE)) {\n      shardTopDocs = new TopDocs[shardGroups.length];\n    } else {\n      shardTopDocs = new TopFieldDocs[shardGroups.length];\n    }\n    float totalMaxScore = Float.MIN_VALUE;\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      double scoreSum = 0.0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        if (docSort.equals(Sort.RELEVANCE)) {\n          shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                               shardGroupDocs.scoreDocs,\n                                               shardGroupDocs.maxScore);\n        } else {\n          shardTopDocs[shardIDX] = new TopFieldDocs(shardGroupDocs.totalHits,\n              shardGroupDocs.scoreDocs,\n              docSort.getSort(),\n              shardGroupDocs.maxScore);\n        }\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n        scoreSum += shardGroupDocs.score;\n      }\n\n      final TopDocs mergedTopDocs;\n      if (docSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(docOffset + docTopN, shardTopDocs);\n      } else {\n        mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, (TopFieldDocs[]) shardTopDocs);\n      }\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n\n      final float groupScore;\n      switch(scoreMergeMode) {\n      case None:\n        groupScore = Float.NaN;\n        break;\n      case Avg:\n        if (totalHits > 0) {\n          groupScore = (float) (scoreSum / totalHits);\n        } else {\n          groupScore = Float.NaN;\n        }\n        break;\n      case Total:\n        groupScore = (float) scoreSum;\n        break;\n      default:\n        throw new IllegalArgumentException(\"can't handle ScoreMergeMode \" + scoreMergeMode);\n      }\n        \n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<>(groupScore,\n                                                   maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n      totalMaxScore = Math.max(totalMaxScore, maxScore);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n      return new TopGroups<>(result, totalGroupCount);\n    } else {\n      return new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n    }\n  }\n\n","sourceOld":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN, ScoreMergeMode scoreMergeMode)\n    throws IOException {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs;\n    if (docSort.equals(Sort.RELEVANCE)) {\n      shardTopDocs = new TopDocs[shardGroups.length];\n    } else {\n      shardTopDocs = new TopFieldDocs[shardGroups.length];\n    }\n    float totalMaxScore = Float.MIN_VALUE;\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      double scoreSum = 0.0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        if (docSort.equals(Sort.RELEVANCE)) {\n          shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                               shardGroupDocs.scoreDocs,\n                                               shardGroupDocs.maxScore);\n        } else {\n          shardTopDocs[shardIDX] = new TopFieldDocs(shardGroupDocs.totalHits,\n              shardGroupDocs.scoreDocs,\n              docSort.getSort(),\n              shardGroupDocs.maxScore);\n        }\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n        scoreSum += shardGroupDocs.score;\n      }\n\n      final TopDocs mergedTopDocs;\n      if (docSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(docOffset + docTopN, shardTopDocs);\n      } else {\n        mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, (TopFieldDocs[]) shardTopDocs);\n      }\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n\n      final float groupScore;\n      switch(scoreMergeMode) {\n      case None:\n        groupScore = Float.NaN;\n        break;\n      case Avg:\n        if (totalHits > 0) {\n          groupScore = (float) (scoreSum / totalHits);\n        } else {\n          groupScore = Float.NaN;\n        }\n        break;\n      case Total:\n        groupScore = (float) scoreSum;\n        break;\n      default:\n        throw new IllegalArgumentException(\"can't handle ScoreMergeMode \" + scoreMergeMode);\n      }\n        \n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<>(groupScore,\n                                                   maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n      totalMaxScore = Math.max(totalMaxScore, maxScore);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n      return new TopGroups<>(result, totalGroupCount);\n    } else {\n      return new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"90a682dc1bfd188ef61cc28373c7f5d700b4ac75","date":1485186128,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int,ScoreMergeMode).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int,ScoreMergeMode).mjava","sourceNew":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN, ScoreMergeMode scoreMergeMode) {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs;\n    if (docSort.equals(Sort.RELEVANCE)) {\n      shardTopDocs = new TopDocs[shardGroups.length];\n    } else {\n      shardTopDocs = new TopFieldDocs[shardGroups.length];\n    }\n    float totalMaxScore = Float.MIN_VALUE;\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      double scoreSum = 0.0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        if (docSort.equals(Sort.RELEVANCE)) {\n          shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                               shardGroupDocs.scoreDocs,\n                                               shardGroupDocs.maxScore);\n        } else {\n          shardTopDocs[shardIDX] = new TopFieldDocs(shardGroupDocs.totalHits,\n              shardGroupDocs.scoreDocs,\n              docSort.getSort(),\n              shardGroupDocs.maxScore);\n        }\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n        scoreSum += shardGroupDocs.score;\n      }\n\n      final TopDocs mergedTopDocs;\n      if (docSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(docOffset + docTopN, shardTopDocs);\n      } else {\n        mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, (TopFieldDocs[]) shardTopDocs);\n      }\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n\n      final float groupScore;\n      switch(scoreMergeMode) {\n      case None:\n        groupScore = Float.NaN;\n        break;\n      case Avg:\n        if (totalHits > 0) {\n          groupScore = (float) (scoreSum / totalHits);\n        } else {\n          groupScore = Float.NaN;\n        }\n        break;\n      case Total:\n        groupScore = (float) scoreSum;\n        break;\n      default:\n        throw new IllegalArgumentException(\"can't handle ScoreMergeMode \" + scoreMergeMode);\n      }\n        \n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<>(groupScore,\n                                                   maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n      totalMaxScore = Math.max(totalMaxScore, maxScore);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n      return new TopGroups<>(result, totalGroupCount);\n    } else {\n      return new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n    }\n  }\n\n","sourceOld":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN, ScoreMergeMode scoreMergeMode)\n    throws IOException {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs;\n    if (docSort.equals(Sort.RELEVANCE)) {\n      shardTopDocs = new TopDocs[shardGroups.length];\n    } else {\n      shardTopDocs = new TopFieldDocs[shardGroups.length];\n    }\n    float totalMaxScore = Float.MIN_VALUE;\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      double scoreSum = 0.0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        if (docSort.equals(Sort.RELEVANCE)) {\n          shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                               shardGroupDocs.scoreDocs,\n                                               shardGroupDocs.maxScore);\n        } else {\n          shardTopDocs[shardIDX] = new TopFieldDocs(shardGroupDocs.totalHits,\n              shardGroupDocs.scoreDocs,\n              docSort.getSort(),\n              shardGroupDocs.maxScore);\n        }\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n        scoreSum += shardGroupDocs.score;\n      }\n\n      final TopDocs mergedTopDocs;\n      if (docSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(docOffset + docTopN, shardTopDocs);\n      } else {\n        mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, (TopFieldDocs[]) shardTopDocs);\n      }\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n\n      final float groupScore;\n      switch(scoreMergeMode) {\n      case None:\n        groupScore = Float.NaN;\n        break;\n      case Avg:\n        if (totalHits > 0) {\n          groupScore = (float) (scoreSum / totalHits);\n        } else {\n          groupScore = Float.NaN;\n        }\n        break;\n      case Total:\n        groupScore = (float) scoreSum;\n        break;\n      default:\n        throw new IllegalArgumentException(\"can't handle ScoreMergeMode \" + scoreMergeMode);\n      }\n        \n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<>(groupScore,\n                                                   maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n      totalMaxScore = Math.max(totalMaxScore, maxScore);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n      return new TopGroups<>(result, totalGroupCount);\n    } else {\n      return new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81fff83bdb893c1471efd78f6a9a3ce4f98120b9","date":1531895937,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int,ScoreMergeMode).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int,ScoreMergeMode).mjava","sourceNew":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN, ScoreMergeMode scoreMergeMode) {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs;\n    if (docSort.equals(Sort.RELEVANCE)) {\n      shardTopDocs = new TopDocs[shardGroups.length];\n    } else {\n      shardTopDocs = new TopFieldDocs[shardGroups.length];\n    }\n    float totalMaxScore = Float.MIN_VALUE;\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      double scoreSum = 0.0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        if (docSort.equals(Sort.RELEVANCE)) {\n          shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                               shardGroupDocs.scoreDocs);\n        } else {\n          shardTopDocs[shardIDX] = new TopFieldDocs(shardGroupDocs.totalHits,\n              shardGroupDocs.scoreDocs,\n              docSort.getSort());\n        }\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n        scoreSum += shardGroupDocs.score;\n      }\n\n      final TopDocs mergedTopDocs;\n      if (docSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(docOffset + docTopN, shardTopDocs);\n      } else {\n        mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, (TopFieldDocs[]) shardTopDocs);\n      }\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n\n      final float groupScore;\n      switch(scoreMergeMode) {\n      case None:\n        groupScore = Float.NaN;\n        break;\n      case Avg:\n        if (totalHits > 0) {\n          groupScore = (float) (scoreSum / totalHits);\n        } else {\n          groupScore = Float.NaN;\n        }\n        break;\n      case Total:\n        groupScore = (float) scoreSum;\n        break;\n      default:\n        throw new IllegalArgumentException(\"can't handle ScoreMergeMode \" + scoreMergeMode);\n      }\n        \n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<>(groupScore,\n                                                   maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n      totalMaxScore = Math.max(totalMaxScore, maxScore);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n      return new TopGroups<>(result, totalGroupCount);\n    } else {\n      return new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n    }\n  }\n\n","sourceOld":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN, ScoreMergeMode scoreMergeMode) {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs;\n    if (docSort.equals(Sort.RELEVANCE)) {\n      shardTopDocs = new TopDocs[shardGroups.length];\n    } else {\n      shardTopDocs = new TopFieldDocs[shardGroups.length];\n    }\n    float totalMaxScore = Float.MIN_VALUE;\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      double scoreSum = 0.0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        if (docSort.equals(Sort.RELEVANCE)) {\n          shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                               shardGroupDocs.scoreDocs,\n                                               shardGroupDocs.maxScore);\n        } else {\n          shardTopDocs[shardIDX] = new TopFieldDocs(shardGroupDocs.totalHits,\n              shardGroupDocs.scoreDocs,\n              docSort.getSort(),\n              shardGroupDocs.maxScore);\n        }\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n        scoreSum += shardGroupDocs.score;\n      }\n\n      final TopDocs mergedTopDocs;\n      if (docSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(docOffset + docTopN, shardTopDocs);\n      } else {\n        mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, (TopFieldDocs[]) shardTopDocs);\n      }\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n\n      final float groupScore;\n      switch(scoreMergeMode) {\n      case None:\n        groupScore = Float.NaN;\n        break;\n      case Avg:\n        if (totalHits > 0) {\n          groupScore = (float) (scoreSum / totalHits);\n        } else {\n          groupScore = Float.NaN;\n        }\n        break;\n      case Total:\n        groupScore = (float) scoreSum;\n        break;\n      default:\n        throw new IllegalArgumentException(\"can't handle ScoreMergeMode \" + scoreMergeMode);\n      }\n        \n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<>(groupScore,\n                                                   maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n      totalMaxScore = Math.max(totalMaxScore, maxScore);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n      return new TopGroups<>(result, totalGroupCount);\n    } else {\n      return new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int,ScoreMergeMode).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int,ScoreMergeMode).mjava","sourceNew":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN, ScoreMergeMode scoreMergeMode) {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs;\n    if (docSort.equals(Sort.RELEVANCE)) {\n      shardTopDocs = new TopDocs[shardGroups.length];\n    } else {\n      shardTopDocs = new TopFieldDocs[shardGroups.length];\n    }\n    float totalMaxScore = Float.MIN_VALUE;\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      double scoreSum = 0.0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        if (docSort.equals(Sort.RELEVANCE)) {\n          shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                               shardGroupDocs.scoreDocs);\n        } else {\n          shardTopDocs[shardIDX] = new TopFieldDocs(shardGroupDocs.totalHits,\n              shardGroupDocs.scoreDocs,\n              docSort.getSort());\n        }\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n        scoreSum += shardGroupDocs.score;\n      }\n\n      final TopDocs mergedTopDocs;\n      if (docSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(docOffset + docTopN, shardTopDocs);\n      } else {\n        mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, (TopFieldDocs[]) shardTopDocs);\n      }\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n\n      final float groupScore;\n      switch(scoreMergeMode) {\n      case None:\n        groupScore = Float.NaN;\n        break;\n      case Avg:\n        if (totalHits > 0) {\n          groupScore = (float) (scoreSum / totalHits);\n        } else {\n          groupScore = Float.NaN;\n        }\n        break;\n      case Total:\n        groupScore = (float) scoreSum;\n        break;\n      default:\n        throw new IllegalArgumentException(\"can't handle ScoreMergeMode \" + scoreMergeMode);\n      }\n        \n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<>(groupScore,\n                                                   maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n      totalMaxScore = Math.max(totalMaxScore, maxScore);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n      return new TopGroups<>(result, totalGroupCount);\n    } else {\n      return new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n    }\n  }\n\n","sourceOld":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN, ScoreMergeMode scoreMergeMode) {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs;\n    if (docSort.equals(Sort.RELEVANCE)) {\n      shardTopDocs = new TopDocs[shardGroups.length];\n    } else {\n      shardTopDocs = new TopFieldDocs[shardGroups.length];\n    }\n    float totalMaxScore = Float.MIN_VALUE;\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      double scoreSum = 0.0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        if (docSort.equals(Sort.RELEVANCE)) {\n          shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                               shardGroupDocs.scoreDocs,\n                                               shardGroupDocs.maxScore);\n        } else {\n          shardTopDocs[shardIDX] = new TopFieldDocs(shardGroupDocs.totalHits,\n              shardGroupDocs.scoreDocs,\n              docSort.getSort(),\n              shardGroupDocs.maxScore);\n        }\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n        scoreSum += shardGroupDocs.score;\n      }\n\n      final TopDocs mergedTopDocs;\n      if (docSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(docOffset + docTopN, shardTopDocs);\n      } else {\n        mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, (TopFieldDocs[]) shardTopDocs);\n      }\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n\n      final float groupScore;\n      switch(scoreMergeMode) {\n      case None:\n        groupScore = Float.NaN;\n        break;\n      case Avg:\n        if (totalHits > 0) {\n          groupScore = (float) (scoreSum / totalHits);\n        } else {\n          groupScore = Float.NaN;\n        }\n        break;\n      case Total:\n        groupScore = (float) scoreSum;\n        break;\n      default:\n        throw new IllegalArgumentException(\"can't handle ScoreMergeMode \" + scoreMergeMode);\n      }\n        \n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<>(groupScore,\n                                                   maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n      totalMaxScore = Math.max(totalMaxScore, maxScore);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n      return new TopGroups<>(result, totalGroupCount);\n    } else {\n      return new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int,ScoreMergeMode).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int,ScoreMergeMode).mjava","sourceNew":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN, ScoreMergeMode scoreMergeMode) {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs;\n    if (docSort.equals(Sort.RELEVANCE)) {\n      shardTopDocs = new TopDocs[shardGroups.length];\n    } else {\n      shardTopDocs = new TopFieldDocs[shardGroups.length];\n    }\n    float totalMaxScore = Float.MIN_VALUE;\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      double scoreSum = 0.0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        if (docSort.equals(Sort.RELEVANCE)) {\n          shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                               shardGroupDocs.scoreDocs);\n        } else {\n          shardTopDocs[shardIDX] = new TopFieldDocs(shardGroupDocs.totalHits,\n              shardGroupDocs.scoreDocs,\n              docSort.getSort());\n        }\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        assert shardGroupDocs.totalHits.relation == Relation.EQUAL_TO;\n        totalHits += shardGroupDocs.totalHits.value;\n        scoreSum += shardGroupDocs.score;\n      }\n\n      final TopDocs mergedTopDocs;\n      if (docSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(docOffset + docTopN, shardTopDocs);\n      } else {\n        mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, (TopFieldDocs[]) shardTopDocs);\n      }\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n\n      final float groupScore;\n      switch(scoreMergeMode) {\n      case None:\n        groupScore = Float.NaN;\n        break;\n      case Avg:\n        if (totalHits > 0) {\n          groupScore = (float) (scoreSum / totalHits);\n        } else {\n          groupScore = Float.NaN;\n        }\n        break;\n      case Total:\n        groupScore = (float) scoreSum;\n        break;\n      default:\n        throw new IllegalArgumentException(\"can't handle ScoreMergeMode \" + scoreMergeMode);\n      }\n        \n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<>(groupScore,\n                                                   maxScore,\n                                                   new TotalHits(totalHits, TotalHits.Relation.EQUAL_TO),\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n      totalMaxScore = Math.max(totalMaxScore, maxScore);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n      return new TopGroups<>(result, totalGroupCount);\n    } else {\n      return new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n    }\n  }\n\n","sourceOld":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN, ScoreMergeMode scoreMergeMode) {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs;\n    if (docSort.equals(Sort.RELEVANCE)) {\n      shardTopDocs = new TopDocs[shardGroups.length];\n    } else {\n      shardTopDocs = new TopFieldDocs[shardGroups.length];\n    }\n    float totalMaxScore = Float.MIN_VALUE;\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      double scoreSum = 0.0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        if (docSort.equals(Sort.RELEVANCE)) {\n          shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                               shardGroupDocs.scoreDocs);\n        } else {\n          shardTopDocs[shardIDX] = new TopFieldDocs(shardGroupDocs.totalHits,\n              shardGroupDocs.scoreDocs,\n              docSort.getSort());\n        }\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        totalHits += shardGroupDocs.totalHits;\n        scoreSum += shardGroupDocs.score;\n      }\n\n      final TopDocs mergedTopDocs;\n      if (docSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(docOffset + docTopN, shardTopDocs);\n      } else {\n        mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, (TopFieldDocs[]) shardTopDocs);\n      }\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n\n      final float groupScore;\n      switch(scoreMergeMode) {\n      case None:\n        groupScore = Float.NaN;\n        break;\n      case Avg:\n        if (totalHits > 0) {\n          groupScore = (float) (scoreSum / totalHits);\n        } else {\n          groupScore = Float.NaN;\n        }\n        break;\n      case Total:\n        groupScore = (float) scoreSum;\n        break;\n      default:\n        throw new IllegalArgumentException(\"can't handle ScoreMergeMode \" + scoreMergeMode);\n      }\n        \n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<>(groupScore,\n                                                   maxScore,\n                                                   totalHits,\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n      totalMaxScore = Math.max(totalMaxScore, maxScore);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n      return new TopGroups<>(result, totalGroupCount);\n    } else {\n      return new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fccd4a691aac1aff06ab8110d8693514a34160c3","date":1562092518,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int,ScoreMergeMode).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int,ScoreMergeMode).mjava","sourceNew":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN, ScoreMergeMode scoreMergeMode) {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs;\n    if (docSort.equals(Sort.RELEVANCE)) {\n      shardTopDocs = new TopDocs[shardGroups.length];\n    } else {\n      shardTopDocs = new TopFieldDocs[shardGroups.length];\n    }\n    float totalMaxScore = Float.MIN_VALUE;\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      double scoreSum = 0.0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        if (docSort.equals(Sort.RELEVANCE)) {\n          shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                               shardGroupDocs.scoreDocs);\n        } else {\n          shardTopDocs[shardIDX] = new TopFieldDocs(shardGroupDocs.totalHits,\n              shardGroupDocs.scoreDocs,\n              docSort.getSort());\n        }\n\n        for (int i = 0; i < shardTopDocs[shardIDX].scoreDocs.length; i++) {\n          shardTopDocs[shardIDX].scoreDocs[i].shardIndex = shardIDX;\n        }\n\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        assert shardGroupDocs.totalHits.relation == Relation.EQUAL_TO;\n        totalHits += shardGroupDocs.totalHits.value;\n        scoreSum += shardGroupDocs.score;\n      }\n\n      final TopDocs mergedTopDocs;\n      if (docSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(docOffset + docTopN, shardTopDocs);\n      } else {\n        mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, (TopFieldDocs[]) shardTopDocs);\n      }\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n\n      final float groupScore;\n      switch(scoreMergeMode) {\n      case None:\n        groupScore = Float.NaN;\n        break;\n      case Avg:\n        if (totalHits > 0) {\n          groupScore = (float) (scoreSum / totalHits);\n        } else {\n          groupScore = Float.NaN;\n        }\n        break;\n      case Total:\n        groupScore = (float) scoreSum;\n        break;\n      default:\n        throw new IllegalArgumentException(\"can't handle ScoreMergeMode \" + scoreMergeMode);\n      }\n        \n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<>(groupScore,\n                                                   maxScore,\n                                                   new TotalHits(totalHits, TotalHits.Relation.EQUAL_TO),\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n      totalMaxScore = Math.max(totalMaxScore, maxScore);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n      return new TopGroups<>(result, totalGroupCount);\n    } else {\n      return new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n    }\n  }\n\n","sourceOld":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN, ScoreMergeMode scoreMergeMode) {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs;\n    if (docSort.equals(Sort.RELEVANCE)) {\n      shardTopDocs = new TopDocs[shardGroups.length];\n    } else {\n      shardTopDocs = new TopFieldDocs[shardGroups.length];\n    }\n    float totalMaxScore = Float.MIN_VALUE;\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      double scoreSum = 0.0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        if (docSort.equals(Sort.RELEVANCE)) {\n          shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                               shardGroupDocs.scoreDocs);\n        } else {\n          shardTopDocs[shardIDX] = new TopFieldDocs(shardGroupDocs.totalHits,\n              shardGroupDocs.scoreDocs,\n              docSort.getSort());\n        }\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        assert shardGroupDocs.totalHits.relation == Relation.EQUAL_TO;\n        totalHits += shardGroupDocs.totalHits.value;\n        scoreSum += shardGroupDocs.score;\n      }\n\n      final TopDocs mergedTopDocs;\n      if (docSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(docOffset + docTopN, shardTopDocs);\n      } else {\n        mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, (TopFieldDocs[]) shardTopDocs);\n      }\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n\n      final float groupScore;\n      switch(scoreMergeMode) {\n      case None:\n        groupScore = Float.NaN;\n        break;\n      case Avg:\n        if (totalHits > 0) {\n          groupScore = (float) (scoreSum / totalHits);\n        } else {\n          groupScore = Float.NaN;\n        }\n        break;\n      case Total:\n        groupScore = (float) scoreSum;\n        break;\n      default:\n        throw new IllegalArgumentException(\"can't handle ScoreMergeMode \" + scoreMergeMode);\n      }\n        \n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<>(groupScore,\n                                                   maxScore,\n                                                   new TotalHits(totalHits, TotalHits.Relation.EQUAL_TO),\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n      totalMaxScore = Math.max(totalMaxScore, maxScore);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n      return new TopGroups<>(result, totalGroupCount);\n    } else {\n      return new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1ea80da8756bb282c46782b7a5027eb59802c436","date":1571828922,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int,ScoreMergeMode).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int,ScoreMergeMode).mjava","sourceNew":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN, ScoreMergeMode scoreMergeMode) {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs;\n    if (docSort.equals(Sort.RELEVANCE)) {\n      shardTopDocs = new TopDocs[shardGroups.length];\n    } else {\n      shardTopDocs = new TopFieldDocs[shardGroups.length];\n    }\n    float totalMaxScore = Float.MIN_VALUE;\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      double scoreSum = 0.0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        if (docSort.equals(Sort.RELEVANCE)) {\n          shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                               shardGroupDocs.scoreDocs);\n        } else {\n          shardTopDocs[shardIDX] = new TopFieldDocs(shardGroupDocs.totalHits,\n              shardGroupDocs.scoreDocs,\n              docSort.getSort());\n        }\n\n        for (int i = 0; i < shardTopDocs[shardIDX].scoreDocs.length; i++) {\n          shardTopDocs[shardIDX].scoreDocs[i].shardIndex = shardIDX;\n        }\n\n        maxScore =  nonNANmax(maxScore, shardGroupDocs.maxScore);\n        assert shardGroupDocs.totalHits.relation == Relation.EQUAL_TO;\n        totalHits += shardGroupDocs.totalHits.value;\n        scoreSum += shardGroupDocs.score;\n      }\n\n      final TopDocs mergedTopDocs;\n      if (docSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(docOffset + docTopN, shardTopDocs);\n      } else {\n        mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, (TopFieldDocs[]) shardTopDocs);\n      }\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n\n      final float groupScore;\n      switch(scoreMergeMode) {\n      case None:\n        groupScore = Float.NaN;\n        break;\n      case Avg:\n        if (totalHits > 0) {\n          groupScore = (float) (scoreSum / totalHits);\n        } else {\n          groupScore = Float.NaN;\n        }\n        break;\n      case Total:\n        groupScore = (float) scoreSum;\n        break;\n      default:\n        throw new IllegalArgumentException(\"can't handle ScoreMergeMode \" + scoreMergeMode);\n      }\n        \n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<>(groupScore,\n                                                   maxScore,\n                                                   new TotalHits(totalHits, TotalHits.Relation.EQUAL_TO),\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n      totalMaxScore = nonNANmax(totalMaxScore, maxScore);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n      return new TopGroups<>(result, totalGroupCount);\n    } else {\n      return new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n    }\n  }\n\n","sourceOld":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN, ScoreMergeMode scoreMergeMode) {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs;\n    if (docSort.equals(Sort.RELEVANCE)) {\n      shardTopDocs = new TopDocs[shardGroups.length];\n    } else {\n      shardTopDocs = new TopFieldDocs[shardGroups.length];\n    }\n    float totalMaxScore = Float.MIN_VALUE;\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      double scoreSum = 0.0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        if (docSort.equals(Sort.RELEVANCE)) {\n          shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                               shardGroupDocs.scoreDocs);\n        } else {\n          shardTopDocs[shardIDX] = new TopFieldDocs(shardGroupDocs.totalHits,\n              shardGroupDocs.scoreDocs,\n              docSort.getSort());\n        }\n\n        for (int i = 0; i < shardTopDocs[shardIDX].scoreDocs.length; i++) {\n          shardTopDocs[shardIDX].scoreDocs[i].shardIndex = shardIDX;\n        }\n\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        assert shardGroupDocs.totalHits.relation == Relation.EQUAL_TO;\n        totalHits += shardGroupDocs.totalHits.value;\n        scoreSum += shardGroupDocs.score;\n      }\n\n      final TopDocs mergedTopDocs;\n      if (docSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(docOffset + docTopN, shardTopDocs);\n      } else {\n        mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, (TopFieldDocs[]) shardTopDocs);\n      }\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n\n      final float groupScore;\n      switch(scoreMergeMode) {\n      case None:\n        groupScore = Float.NaN;\n        break;\n      case Avg:\n        if (totalHits > 0) {\n          groupScore = (float) (scoreSum / totalHits);\n        } else {\n          groupScore = Float.NaN;\n        }\n        break;\n      case Total:\n        groupScore = (float) scoreSum;\n        break;\n      default:\n        throw new IllegalArgumentException(\"can't handle ScoreMergeMode \" + scoreMergeMode);\n      }\n        \n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<>(groupScore,\n                                                   maxScore,\n                                                   new TotalHits(totalHits, TotalHits.Relation.EQUAL_TO),\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n      totalMaxScore = Math.max(totalMaxScore, maxScore);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n      return new TopGroups<>(result, totalGroupCount);\n    } else {\n      return new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"94376748c9c736515a6f26c0fb1e5986d315b843","date":1571850798,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int,ScoreMergeMode).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int,ScoreMergeMode).mjava","sourceNew":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN, ScoreMergeMode scoreMergeMode) {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs;\n    if (docSort.equals(Sort.RELEVANCE)) {\n      shardTopDocs = new TopDocs[shardGroups.length];\n    } else {\n      shardTopDocs = new TopFieldDocs[shardGroups.length];\n    }\n    float totalMaxScore = Float.MIN_VALUE;\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      double scoreSum = 0.0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        if (docSort.equals(Sort.RELEVANCE)) {\n          shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                               shardGroupDocs.scoreDocs);\n        } else {\n          shardTopDocs[shardIDX] = new TopFieldDocs(shardGroupDocs.totalHits,\n              shardGroupDocs.scoreDocs,\n              docSort.getSort());\n        }\n\n        for (int i = 0; i < shardTopDocs[shardIDX].scoreDocs.length; i++) {\n          shardTopDocs[shardIDX].scoreDocs[i].shardIndex = shardIDX;\n        }\n\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        assert shardGroupDocs.totalHits.relation == Relation.EQUAL_TO;\n        totalHits += shardGroupDocs.totalHits.value;\n        scoreSum += shardGroupDocs.score;\n      }\n\n      final TopDocs mergedTopDocs;\n      if (docSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(docOffset + docTopN, shardTopDocs);\n      } else {\n        mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, (TopFieldDocs[]) shardTopDocs);\n      }\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n\n      final float groupScore;\n      switch(scoreMergeMode) {\n      case None:\n        groupScore = Float.NaN;\n        break;\n      case Avg:\n        if (totalHits > 0) {\n          groupScore = (float) (scoreSum / totalHits);\n        } else {\n          groupScore = Float.NaN;\n        }\n        break;\n      case Total:\n        groupScore = (float) scoreSum;\n        break;\n      default:\n        throw new IllegalArgumentException(\"can't handle ScoreMergeMode \" + scoreMergeMode);\n      }\n        \n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<>(groupScore,\n                                                   maxScore,\n                                                   new TotalHits(totalHits, TotalHits.Relation.EQUAL_TO),\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n      totalMaxScore = Math.max(totalMaxScore, maxScore);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n      return new TopGroups<>(result, totalGroupCount);\n    } else {\n      return new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n    }\n  }\n\n","sourceOld":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN, ScoreMergeMode scoreMergeMode) {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs;\n    if (docSort.equals(Sort.RELEVANCE)) {\n      shardTopDocs = new TopDocs[shardGroups.length];\n    } else {\n      shardTopDocs = new TopFieldDocs[shardGroups.length];\n    }\n    float totalMaxScore = Float.MIN_VALUE;\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      double scoreSum = 0.0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        if (docSort.equals(Sort.RELEVANCE)) {\n          shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                               shardGroupDocs.scoreDocs);\n        } else {\n          shardTopDocs[shardIDX] = new TopFieldDocs(shardGroupDocs.totalHits,\n              shardGroupDocs.scoreDocs,\n              docSort.getSort());\n        }\n\n        for (int i = 0; i < shardTopDocs[shardIDX].scoreDocs.length; i++) {\n          shardTopDocs[shardIDX].scoreDocs[i].shardIndex = shardIDX;\n        }\n\n        maxScore =  nonNANmax(maxScore, shardGroupDocs.maxScore);\n        assert shardGroupDocs.totalHits.relation == Relation.EQUAL_TO;\n        totalHits += shardGroupDocs.totalHits.value;\n        scoreSum += shardGroupDocs.score;\n      }\n\n      final TopDocs mergedTopDocs;\n      if (docSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(docOffset + docTopN, shardTopDocs);\n      } else {\n        mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, (TopFieldDocs[]) shardTopDocs);\n      }\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n\n      final float groupScore;\n      switch(scoreMergeMode) {\n      case None:\n        groupScore = Float.NaN;\n        break;\n      case Avg:\n        if (totalHits > 0) {\n          groupScore = (float) (scoreSum / totalHits);\n        } else {\n          groupScore = Float.NaN;\n        }\n        break;\n      case Total:\n        groupScore = (float) scoreSum;\n        break;\n      default:\n        throw new IllegalArgumentException(\"can't handle ScoreMergeMode \" + scoreMergeMode);\n      }\n        \n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<>(groupScore,\n                                                   maxScore,\n                                                   new TotalHits(totalHits, TotalHits.Relation.EQUAL_TO),\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n      totalMaxScore = nonNANmax(totalMaxScore, maxScore);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n      return new TopGroups<>(result, totalGroupCount);\n    } else {\n      return new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":["2eb9dcbcff763b925aeaf51efba4dabd996ec69a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2eb9dcbcff763b925aeaf51efba4dabd996ec69a","date":1575896984,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int,ScoreMergeMode).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int,ScoreMergeMode).mjava","sourceNew":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN, ScoreMergeMode scoreMergeMode) {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs;\n    if (docSort.equals(Sort.RELEVANCE)) {\n      shardTopDocs = new TopDocs[shardGroups.length];\n    } else {\n      shardTopDocs = new TopFieldDocs[shardGroups.length];\n    }\n    float totalMaxScore = Float.NaN;\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.NaN;\n      int totalHits = 0;\n      double scoreSum = 0.0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        if (docSort.equals(Sort.RELEVANCE)) {\n          shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                               shardGroupDocs.scoreDocs);\n        } else {\n          shardTopDocs[shardIDX] = new TopFieldDocs(shardGroupDocs.totalHits,\n              shardGroupDocs.scoreDocs,\n              docSort.getSort());\n        }\n\n        for (int i = 0; i < shardTopDocs[shardIDX].scoreDocs.length; i++) {\n          shardTopDocs[shardIDX].scoreDocs[i].shardIndex = shardIDX;\n        }\n\n        maxScore =  nonNANmax(maxScore, shardGroupDocs.maxScore);\n        assert shardGroupDocs.totalHits.relation == Relation.EQUAL_TO;\n        totalHits += shardGroupDocs.totalHits.value;\n        scoreSum += shardGroupDocs.score;\n      }\n\n      final TopDocs mergedTopDocs;\n      if (docSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(docOffset + docTopN, shardTopDocs);\n      } else {\n        mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, (TopFieldDocs[]) shardTopDocs);\n      }\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n\n      final float groupScore;\n      switch(scoreMergeMode) {\n      case None:\n        groupScore = Float.NaN;\n        break;\n      case Avg:\n        if (totalHits > 0) {\n          groupScore = (float) (scoreSum / totalHits);\n        } else {\n          groupScore = Float.NaN;\n        }\n        break;\n      case Total:\n        groupScore = (float) scoreSum;\n        break;\n      default:\n        throw new IllegalArgumentException(\"can't handle ScoreMergeMode \" + scoreMergeMode);\n      }\n        \n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<>(groupScore,\n                                                   maxScore,\n                                                   new TotalHits(totalHits, TotalHits.Relation.EQUAL_TO),\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n      totalMaxScore = nonNANmax(totalMaxScore, maxScore);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n      return new TopGroups<>(result, totalGroupCount);\n    } else {\n      return new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n    }\n  }\n\n","sourceOld":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN, ScoreMergeMode scoreMergeMode) {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs;\n    if (docSort.equals(Sort.RELEVANCE)) {\n      shardTopDocs = new TopDocs[shardGroups.length];\n    } else {\n      shardTopDocs = new TopFieldDocs[shardGroups.length];\n    }\n    float totalMaxScore = Float.MIN_VALUE;\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      double scoreSum = 0.0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        if (docSort.equals(Sort.RELEVANCE)) {\n          shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                               shardGroupDocs.scoreDocs);\n        } else {\n          shardTopDocs[shardIDX] = new TopFieldDocs(shardGroupDocs.totalHits,\n              shardGroupDocs.scoreDocs,\n              docSort.getSort());\n        }\n\n        for (int i = 0; i < shardTopDocs[shardIDX].scoreDocs.length; i++) {\n          shardTopDocs[shardIDX].scoreDocs[i].shardIndex = shardIDX;\n        }\n\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        assert shardGroupDocs.totalHits.relation == Relation.EQUAL_TO;\n        totalHits += shardGroupDocs.totalHits.value;\n        scoreSum += shardGroupDocs.score;\n      }\n\n      final TopDocs mergedTopDocs;\n      if (docSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(docOffset + docTopN, shardTopDocs);\n      } else {\n        mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, (TopFieldDocs[]) shardTopDocs);\n      }\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n\n      final float groupScore;\n      switch(scoreMergeMode) {\n      case None:\n        groupScore = Float.NaN;\n        break;\n      case Avg:\n        if (totalHits > 0) {\n          groupScore = (float) (scoreSum / totalHits);\n        } else {\n          groupScore = Float.NaN;\n        }\n        break;\n      case Total:\n        groupScore = (float) scoreSum;\n        break;\n      default:\n        throw new IllegalArgumentException(\"can't handle ScoreMergeMode \" + scoreMergeMode);\n      }\n        \n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<>(groupScore,\n                                                   maxScore,\n                                                   new TotalHits(totalHits, TotalHits.Relation.EQUAL_TO),\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n      totalMaxScore = Math.max(totalMaxScore, maxScore);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n      return new TopGroups<>(result, totalGroupCount);\n    } else {\n      return new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n    }\n  }\n\n","bugFix":["85d41890f2bad879e6a04c6dd7d2cf276f973994","d4aa50b979cd392e00e5bc0f23f78cbd106cb968","94376748c9c736515a6f26c0fb1e5986d315b843"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df3f594d6024cc3f64b0d0932c5efc80dfbe64bb","date":1575906501,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int,ScoreMergeMode).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups#[T]_merge(TopGroups[T][],Sort,Sort,int,int,ScoreMergeMode).mjava","sourceNew":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN, ScoreMergeMode scoreMergeMode) {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs;\n    if (docSort.equals(Sort.RELEVANCE)) {\n      shardTopDocs = new TopDocs[shardGroups.length];\n    } else {\n      shardTopDocs = new TopFieldDocs[shardGroups.length];\n    }\n    float totalMaxScore = Float.NaN;\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.NaN;\n      int totalHits = 0;\n      double scoreSum = 0.0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        if (docSort.equals(Sort.RELEVANCE)) {\n          shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                               shardGroupDocs.scoreDocs);\n        } else {\n          shardTopDocs[shardIDX] = new TopFieldDocs(shardGroupDocs.totalHits,\n              shardGroupDocs.scoreDocs,\n              docSort.getSort());\n        }\n\n        for (int i = 0; i < shardTopDocs[shardIDX].scoreDocs.length; i++) {\n          shardTopDocs[shardIDX].scoreDocs[i].shardIndex = shardIDX;\n        }\n\n        maxScore =  nonNANmax(maxScore, shardGroupDocs.maxScore);\n        assert shardGroupDocs.totalHits.relation == Relation.EQUAL_TO;\n        totalHits += shardGroupDocs.totalHits.value;\n        scoreSum += shardGroupDocs.score;\n      }\n\n      final TopDocs mergedTopDocs;\n      if (docSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(docOffset + docTopN, shardTopDocs);\n      } else {\n        mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, (TopFieldDocs[]) shardTopDocs);\n      }\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n\n      final float groupScore;\n      switch(scoreMergeMode) {\n      case None:\n        groupScore = Float.NaN;\n        break;\n      case Avg:\n        if (totalHits > 0) {\n          groupScore = (float) (scoreSum / totalHits);\n        } else {\n          groupScore = Float.NaN;\n        }\n        break;\n      case Total:\n        groupScore = (float) scoreSum;\n        break;\n      default:\n        throw new IllegalArgumentException(\"can't handle ScoreMergeMode \" + scoreMergeMode);\n      }\n        \n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<>(groupScore,\n                                                   maxScore,\n                                                   new TotalHits(totalHits, TotalHits.Relation.EQUAL_TO),\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n      totalMaxScore = nonNANmax(totalMaxScore, maxScore);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n      return new TopGroups<>(result, totalGroupCount);\n    } else {\n      return new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n    }\n  }\n\n","sourceOld":"  /** Merges an array of TopGroups, for example obtained\n   *  from the second-pass collector across multiple\n   *  shards.  Each TopGroups must have been sorted by the\n   *  same groupSort and docSort, and the top groups passed\n   *  to all second-pass collectors must be the same.\n   *\n   * <b>NOTE</b>: We can't always compute an exact totalGroupCount.\n   * Documents belonging to a group may occur on more than\n   * one shard and thus the merged totalGroupCount can be\n   * higher than the actual totalGroupCount. In this case the\n   * totalGroupCount represents a upper bound. If the documents\n   * of one group do only reside in one shard then the\n   * totalGroupCount is exact.\n   *\n   * <b>NOTE</b>: the topDocs in each GroupDocs is actually\n   * an instance of TopDocsAndShards\n   */\n  public static <T> TopGroups<T> merge(TopGroups<T>[] shardGroups, Sort groupSort, Sort docSort, int docOffset, int docTopN, ScoreMergeMode scoreMergeMode) {\n\n    //System.out.println(\"TopGroups.merge\");\n\n    if (shardGroups.length == 0) {\n      return null;\n    }\n\n    int totalHitCount = 0;\n    int totalGroupedHitCount = 0;\n    // Optionally merge the totalGroupCount.\n    Integer totalGroupCount = null;\n\n    final int numGroups = shardGroups[0].groups.length;\n    for(TopGroups<T> shard : shardGroups) {\n      if (numGroups != shard.groups.length) {\n        throw new IllegalArgumentException(\"number of groups differs across shards; you must pass same top groups to all shards' second-pass collector\");\n      }\n      totalHitCount += shard.totalHitCount;\n      totalGroupedHitCount += shard.totalGroupedHitCount;\n      if (shard.totalGroupCount != null) {\n        if (totalGroupCount == null) {\n          totalGroupCount = 0;\n        }\n\n        totalGroupCount += shard.totalGroupCount;\n      }\n    }\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<T>[] mergedGroupDocs = new GroupDocs[numGroups];\n\n    final TopDocs[] shardTopDocs;\n    if (docSort.equals(Sort.RELEVANCE)) {\n      shardTopDocs = new TopDocs[shardGroups.length];\n    } else {\n      shardTopDocs = new TopFieldDocs[shardGroups.length];\n    }\n    float totalMaxScore = Float.MIN_VALUE;\n\n    for(int groupIDX=0;groupIDX<numGroups;groupIDX++) {\n      final T groupValue = shardGroups[0].groups[groupIDX].groupValue;\n      //System.out.println(\"  merge groupValue=\" + groupValue + \" sortValues=\" + Arrays.toString(shardGroups[0].groups[groupIDX].groupSortValues));\n      float maxScore = Float.MIN_VALUE;\n      int totalHits = 0;\n      double scoreSum = 0.0;\n      for(int shardIDX=0;shardIDX<shardGroups.length;shardIDX++) {\n        //System.out.println(\"    shard=\" + shardIDX);\n        final TopGroups<T> shard = shardGroups[shardIDX];\n        final GroupDocs<?> shardGroupDocs = shard.groups[groupIDX];\n        if (groupValue == null) {\n          if (shardGroupDocs.groupValue != null) {\n            throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n          }\n        } else if (!groupValue.equals(shardGroupDocs.groupValue)) {\n          throw new IllegalArgumentException(\"group values differ across shards; you must pass same top groups to all shards' second-pass collector\");\n        }\n\n        /*\n        for(ScoreDoc sd : shardGroupDocs.scoreDocs) {\n          System.out.println(\"      doc=\" + sd.doc);\n        }\n        */\n\n        if (docSort.equals(Sort.RELEVANCE)) {\n          shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,\n                                               shardGroupDocs.scoreDocs);\n        } else {\n          shardTopDocs[shardIDX] = new TopFieldDocs(shardGroupDocs.totalHits,\n              shardGroupDocs.scoreDocs,\n              docSort.getSort());\n        }\n\n        for (int i = 0; i < shardTopDocs[shardIDX].scoreDocs.length; i++) {\n          shardTopDocs[shardIDX].scoreDocs[i].shardIndex = shardIDX;\n        }\n\n        maxScore = Math.max(maxScore, shardGroupDocs.maxScore);\n        assert shardGroupDocs.totalHits.relation == Relation.EQUAL_TO;\n        totalHits += shardGroupDocs.totalHits.value;\n        scoreSum += shardGroupDocs.score;\n      }\n\n      final TopDocs mergedTopDocs;\n      if (docSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(docOffset + docTopN, shardTopDocs);\n      } else {\n        mergedTopDocs = TopDocs.merge(docSort, docOffset + docTopN, (TopFieldDocs[]) shardTopDocs);\n      }\n\n      // Slice;\n      final ScoreDoc[] mergedScoreDocs;\n      if (docOffset == 0) {\n        mergedScoreDocs = mergedTopDocs.scoreDocs;\n      } else if (docOffset >= mergedTopDocs.scoreDocs.length) {\n        mergedScoreDocs = new ScoreDoc[0];\n      } else {\n        mergedScoreDocs = new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];\n        System.arraycopy(mergedTopDocs.scoreDocs,\n                         docOffset,\n                         mergedScoreDocs,\n                         0,\n                         mergedTopDocs.scoreDocs.length - docOffset);\n      }\n\n      final float groupScore;\n      switch(scoreMergeMode) {\n      case None:\n        groupScore = Float.NaN;\n        break;\n      case Avg:\n        if (totalHits > 0) {\n          groupScore = (float) (scoreSum / totalHits);\n        } else {\n          groupScore = Float.NaN;\n        }\n        break;\n      case Total:\n        groupScore = (float) scoreSum;\n        break;\n      default:\n        throw new IllegalArgumentException(\"can't handle ScoreMergeMode \" + scoreMergeMode);\n      }\n        \n      //System.out.println(\"SHARDS=\" + Arrays.toString(mergedTopDocs.shardIndex));\n      mergedGroupDocs[groupIDX] = new GroupDocs<>(groupScore,\n                                                   maxScore,\n                                                   new TotalHits(totalHits, TotalHits.Relation.EQUAL_TO),\n                                                   mergedScoreDocs,\n                                                   groupValue,\n                                                   shardGroups[0].groups[groupIDX].groupSortValues);\n      totalMaxScore = Math.max(totalMaxScore, maxScore);\n    }\n\n    if (totalGroupCount != null) {\n      TopGroups<T> result = new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n      return new TopGroups<>(result, totalGroupCount);\n    } else {\n      return new TopGroups<>(groupSort.getSort(),\n                              docSort.getSort(),\n                              totalHitCount,\n                              totalGroupedHitCount,\n                              mergedGroupDocs,\n                              totalMaxScore);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fb17639909a369c1e64866842e5c213440acc17e":["97d4692d0c601ff773f0a2231967312428a904e4"],"df3f594d6024cc3f64b0d0932c5efc80dfbe64bb":["94376748c9c736515a6f26c0fb1e5986d315b843","2eb9dcbcff763b925aeaf51efba4dabd996ec69a"],"2eb9dcbcff763b925aeaf51efba4dabd996ec69a":["94376748c9c736515a6f26c0fb1e5986d315b843"],"5e8a6094f2ecf9edcd3bb224b087580ac0aa13f2":["fb17639909a369c1e64866842e5c213440acc17e"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":["5e8a6094f2ecf9edcd3bb224b087580ac0aa13f2","03e38c6374c23083c93e212a9498ff0a9c255476"],"85d41890f2bad879e6a04c6dd7d2cf276f973994":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["03e38c6374c23083c93e212a9498ff0a9c255476","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"03e38c6374c23083c93e212a9498ff0a9c255476":["5e8a6094f2ecf9edcd3bb224b087580ac0aa13f2"],"fccd4a691aac1aff06ab8110d8693514a34160c3":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"97d4692d0c601ff773f0a2231967312428a904e4":["85d41890f2bad879e6a04c6dd7d2cf276f973994"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1ea80da8756bb282c46782b7a5027eb59802c436":["fccd4a691aac1aff06ab8110d8693514a34160c3"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["03e38c6374c23083c93e212a9498ff0a9c255476"],"94376748c9c736515a6f26c0fb1e5986d315b843":["1ea80da8756bb282c46782b7a5027eb59802c436"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2eb9dcbcff763b925aeaf51efba4dabd996ec69a"]},"commit2Childs":{"fb17639909a369c1e64866842e5c213440acc17e":["5e8a6094f2ecf9edcd3bb224b087580ac0aa13f2"],"df3f594d6024cc3f64b0d0932c5efc80dfbe64bb":[],"2eb9dcbcff763b925aeaf51efba4dabd996ec69a":["df3f594d6024cc3f64b0d0932c5efc80dfbe64bb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5e8a6094f2ecf9edcd3bb224b087580ac0aa13f2":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75","03e38c6374c23083c93e212a9498ff0a9c255476"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":[],"85d41890f2bad879e6a04c6dd7d2cf276f973994":["97d4692d0c601ff773f0a2231967312428a904e4"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"03e38c6374c23083c93e212a9498ff0a9c255476":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"fccd4a691aac1aff06ab8110d8693514a34160c3":["1ea80da8756bb282c46782b7a5027eb59802c436"],"97d4692d0c601ff773f0a2231967312428a904e4":["fb17639909a369c1e64866842e5c213440acc17e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["85d41890f2bad879e6a04c6dd7d2cf276f973994"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","83788ad129a5154d5c6562c4e8ce3db48793aada"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["fccd4a691aac1aff06ab8110d8693514a34160c3"],"1ea80da8756bb282c46782b7a5027eb59802c436":["94376748c9c736515a6f26c0fb1e5986d315b843"],"94376748c9c736515a6f26c0fb1e5986d315b843":["df3f594d6024cc3f64b0d0932c5efc80dfbe64bb","2eb9dcbcff763b925aeaf51efba4dabd996ec69a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["df3f594d6024cc3f64b0d0932c5efc80dfbe64bb","90a682dc1bfd188ef61cc28373c7f5d700b4ac75","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}