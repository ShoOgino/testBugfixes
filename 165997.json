{"path":"solr/core/src/test/org/apache/solr/search/TestRecoveryHdfs#testBuffering().mjava","commits":[{"id":"849494cf2f3a96af5c8c84995108ddd8456fcd04","date":1372277913,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecoveryHdfs#testBuffering().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = new Runnable() {\n      @Override\n      public void run() {\n        logReplayFinish.release();\n      }\n    };\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["add53de9835b2cd1a7a80b4e0036afee171c9fdf"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":0,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecoveryHdfs#testBuffering().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = new Runnable() {\n      @Override\n      public void run() {\n        logReplayFinish.release();\n      }\n    };\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a0c04b71951333291abc7f317109a6a5957bd28","date":1457097827,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecoveryHdfs#testBuffering().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRecoveryHdfs#testBuffering().mjava","sourceNew":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = () -> logReplayFinish.release();\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = new Runnable() {\n      @Override\n      public void run() {\n        logReplayFinish.release();\n      }\n    };\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"043df2e9a841864922c32756a44c939ed768cb89","date":1459876536,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecoveryHdfs#testBuffering().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRecoveryHdfs#testBuffering().mjava","sourceNew":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = () -> logReplayFinish.release();\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b6284684320a9808c41a5e43de958b2da22f89bd","date":1459977490,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecoveryHdfs#testBuffering().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRecoveryHdfs#testBuffering().mjava","sourceNew":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = () -> logReplayFinish.release();\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2c801a37c38aedbd2ddbd27f2aaeb30cd5c7af0f","date":1552317217,"type":3,"author":"Kevin Risden","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecoveryHdfs#testBuffering().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRecoveryHdfs#testBuffering().mjava","sourceNew":"  @Test\n  public void testBuffering() throws Exception {\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testBuffering() throws Exception {\n\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"add53de9835b2cd1a7a80b4e0036afee171c9fdf","date":1552937136,"type":3,"author":"Kevin Risden","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecoveryHdfs#testBuffering().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRecoveryHdfs#testBuffering().mjava","sourceNew":"  @Test\n  public void testBuffering() throws Exception {\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertNull(rinfoFuture);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertNotNull(rinfoFuture);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertNotNull(rinfoFuture);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testBuffering() throws Exception {\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture == null);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertTrue(rinfoFuture != null);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n  }\n\n","bugFix":["849494cf2f3a96af5c8c84995108ddd8456fcd04"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bdf107cf16be0f22504ae184fed81596665a244","date":1576012524,"type":3,"author":"Kevin Risden","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecoveryHdfs#testBuffering().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRecoveryHdfs#testBuffering().mjava","sourceNew":"  @Test\n  public void testBuffering() throws Exception {\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(TIMEOUT, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertNull(rinfoFuture);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertNotNull(rinfoFuture);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertNotNull(rinfoFuture);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testBuffering() throws Exception {\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertNull(rinfoFuture);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertNotNull(rinfoFuture);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertNotNull(rinfoFuture);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a229cb50768e988c50a2106bdae3a92154f428bf","date":1576051038,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecoveryHdfs#testBuffering().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRecoveryHdfs#testBuffering().mjava","sourceNew":"  @Test\n  public void testBuffering() throws Exception {\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(TIMEOUT, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertNull(rinfoFuture);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertNotNull(rinfoFuture);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertNotNull(rinfoFuture);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testBuffering() throws Exception {\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertNull(rinfoFuture);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertNotNull(rinfoFuture);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertNotNull(rinfoFuture);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1","date":1579200426,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRecoveryHdfs#testBuffering().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRecoveryHdfs#testBuffering().mjava","sourceNew":"  @Test\n  public void testBuffering() throws Exception {\n    TestInjection.skipIndexWriterCommitOnClose = true;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(TIMEOUT, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertNull(rinfoFuture);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertNotNull(rinfoFuture);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertNotNull(rinfoFuture);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testBuffering() throws Exception {\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(TIMEOUT, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      clearIndex();\n      assertU(commit());\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n      assertNull(rinfoFuture);\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // simulate updates from a leader\n      updateJ(jsonAdd(sdoc(\"id\",\"B1\", \"_version_\",\"1010\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B11\", \"_version_\",\"1015\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonDelQ(\"id:B1 id:B11 id:B2 id:B3\"), params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-1017\"));\n      updateJ(jsonAdd(sdoc(\"id\",\"B2\", \"_version_\",\"1020\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"1030\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B1\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2010\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      assertU(commit());\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n      // updates should be buffered, so we should not see any results yet.\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==0\"\n      );\n\n      // real-time get should also not show anything (this could change in the future,\n      // but it's currently used for validating version numbers too, so it would\n      // be bad for updates to be visible if we're just buffering.\n      assertJQ(req(\"qt\",\"/get\", \"id\",\"B3\")\n          ,\"=={'doc':null}\"\n      );\n\n\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertNotNull(rinfoFuture);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"6\")\n          ,\"=={'versions':[-2010,1030,1020,-1017,1015,1010]}\"\n      );\n\n\n      assertJQ(req(\"q\", \"*:*\")\n          , \"/response/numFound==2\"\n      );\n\n      // move back to recovering\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      Long ver = getVer(req(\"qt\",\"/get\", \"id\",\"B3\"));\n      assertEquals(1030L, ver.longValue());\n\n      // add a reordered doc that shouldn't overwrite one in the index\n      updateJ(jsonAdd(sdoc(\"id\",\"B3\", \"_version_\",\"3\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // reorder two buffered updates\n      updateJ(jsonAdd(sdoc(\"id\",\"B4\", \"_version_\",\"1040\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      deleteAndGetVersion(\"B4\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-940\"));   // this update should not take affect\n      updateJ(jsonAdd(sdoc(\"id\",\"B6\", \"_version_\",\"1060\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B5\", \"_version_\",\"1050\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      updateJ(jsonAdd(sdoc(\"id\",\"B8\", \"_version_\",\"1080\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // test that delete by query is at least buffered along with everything else so it will delete the\n      // currently buffered id:8 (even if it doesn't currently support versioning)\n      updateJ(\"{\\\"delete\\\": { \\\"query\\\":\\\"id:B2 OR id:B8\\\" }}\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-3000\"));\n\n      assertJQ(req(\"qt\",\"/get\", \"getVersions\",\"13\")\n          ,\"=={'versions':[-3000,1080,1050,1060,-940,1040,3,-2010,1030,1020,-1017,1015,1010]}\"  // the \"3\" appears because versions aren't checked while buffering\n      );\n\n      logReplay.drainPermits();\n      rinfoFuture = ulog.applyBufferedUpdates();\n      assertNotNull(rinfoFuture);\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      // apply a single update\n      logReplay.release(1);\n\n      // now add another update\n      updateJ(jsonAdd(sdoc(\"id\",\"B7\", \"_version_\",\"1070\")), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      // a reordered update that should be dropped\n      deleteAndGetVersion(\"B5\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-950\"));\n\n      deleteAndGetVersion(\"B6\", params(DISTRIB_UPDATE_PARAM,FROM_LEADER, \"_version_\",\"-2060\"));\n\n      logReplay.release(1000);\n      UpdateLog.RecoveryInfo recInfo = rinfoFuture.get();\n\n      assertJQ(req(\"q\", \"*:*\", \"sort\",\"id asc\", \"fl\",\"id,_version_\")\n          , \"/response/docs==[\"\n                           + \"{'id':'B3','_version_':1030}\"\n                           + \",{'id':'B4','_version_':1040}\"\n                           + \",{'id':'B5','_version_':1050}\"\n                           + \",{'id':'B7','_version_':1070}\"\n                           +\"]\"\n      );\n\n      assertEquals(1, recInfo.deleteByQuery);\n\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState()); // leave each test method in a good state\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n\n      req().close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"849494cf2f3a96af5c8c84995108ddd8456fcd04":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2c801a37c38aedbd2ddbd27f2aaeb30cd5c7af0f":["b6284684320a9808c41a5e43de958b2da22f89bd"],"043df2e9a841864922c32756a44c939ed768cb89":["3a0c04b71951333291abc7f317109a6a5957bd28"],"a229cb50768e988c50a2106bdae3a92154f428bf":["add53de9835b2cd1a7a80b4e0036afee171c9fdf","6bdf107cf16be0f22504ae184fed81596665a244"],"b6284684320a9808c41a5e43de958b2da22f89bd":["3a0c04b71951333291abc7f317109a6a5957bd28","043df2e9a841864922c32756a44c939ed768cb89"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","849494cf2f3a96af5c8c84995108ddd8456fcd04"],"6bdf107cf16be0f22504ae184fed81596665a244":["add53de9835b2cd1a7a80b4e0036afee171c9fdf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1":["6bdf107cf16be0f22504ae184fed81596665a244"],"3a0c04b71951333291abc7f317109a6a5957bd28":["849494cf2f3a96af5c8c84995108ddd8456fcd04"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1"],"add53de9835b2cd1a7a80b4e0036afee171c9fdf":["2c801a37c38aedbd2ddbd27f2aaeb30cd5c7af0f"]},"commit2Childs":{"849494cf2f3a96af5c8c84995108ddd8456fcd04":["37a0f60745e53927c4c876cfe5b5a58170f0646c","3a0c04b71951333291abc7f317109a6a5957bd28"],"2c801a37c38aedbd2ddbd27f2aaeb30cd5c7af0f":["add53de9835b2cd1a7a80b4e0036afee171c9fdf"],"043df2e9a841864922c32756a44c939ed768cb89":["b6284684320a9808c41a5e43de958b2da22f89bd"],"a229cb50768e988c50a2106bdae3a92154f428bf":[],"b6284684320a9808c41a5e43de958b2da22f89bd":["2c801a37c38aedbd2ddbd27f2aaeb30cd5c7af0f"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["849494cf2f3a96af5c8c84995108ddd8456fcd04","37a0f60745e53927c4c876cfe5b5a58170f0646c"],"6bdf107cf16be0f22504ae184fed81596665a244":["a229cb50768e988c50a2106bdae3a92154f428bf","b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1"],"b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3a0c04b71951333291abc7f317109a6a5957bd28":["043df2e9a841864922c32756a44c939ed768cb89","b6284684320a9808c41a5e43de958b2da22f89bd"],"add53de9835b2cd1a7a80b4e0036afee171c9fdf":["a229cb50768e988c50a2106bdae3a92154f428bf","6bdf107cf16be0f22504ae184fed81596665a244"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a229cb50768e988c50a2106bdae3a92154f428bf","37a0f60745e53927c4c876cfe5b5a58170f0646c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}