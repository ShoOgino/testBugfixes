{"path":"solr/core/src/java/org/apache/solr/handler/admin/RebalanceLeaders#ensurePreferredIsLeader(Slice).mjava","commits":[{"id":"73fd358e8ec697393d56617f4d9cedaca74dca14","date":1547954439,"type":1,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/RebalanceLeaders#ensurePreferredIsLeader(Slice).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/RebalanceLeaders#ensurePreferredIsLeader(NamedList[Object],Slice,Map[String,String]).mjava","sourceNew":"  // The process is:\n  // if the replica with preferredLeader is already the leader, do nothing\n  // Otherwise:\n  // > if two nodes have the same sequence number and both point to the current leader, we presume that we've just\n  //   moved it, move the one that does _not_ have the preferredLeader to the end of the list.\n  // > move the current leader to the end of the list. This _should_ mean that the current ephemeral node in the\n  //   leader election queue is removed and the only remaining node watching it is triggered to become leader.\n  private void ensurePreferredIsLeader(Slice slice) throws KeeperException, InterruptedException {\n    for (Replica replica : slice.getReplicas()) {\n      // Tell the replica to become the leader if we're the preferred leader AND active AND not the leader already\n      if (replica.getBool(SliceMutator.PREFERRED_LEADER_PROP, false) == false) {\n        continue;\n      }\n      // OK, we are the preferred leader, are we the actual leader?\n      if (replica.getBool(LEADER_PROP, false)) {\n        //We're a preferred leader, but we're _also_ the leader, don't need to do anything.\n        addAlreadyLeaderToResults(slice, replica);\n        return; // already the leader, do nothing.\n      }\n      ZkStateReader zkStateReader = coreContainer.getZkController().getZkStateReader();\n      // We're the preferred leader, but someone else is leader. Only become leader if we're active.\n      if (replica.isActive(zkStateReader.getClusterState().getLiveNodes()) == false) {\n        addInactiveToResults(slice, replica);\n        return; // Don't try to become the leader if we're not active!\n      }\n\n      List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zkStateReader.getZkClient(),\n          ZkStateReader.getShardLeadersElectPath(collectionName, slice.getName()));\n\n      if (electionQueueInBadState(electionNodes, slice, replica)) {\n        return;\n      }\n\n      // Replica is the preferred leader but not the actual leader, do something about that.\n      // \"Something\" is\n      // 1> if the preferred leader isn't first in line, tell it to re-queue itself.\n      // 2> tell the actual leader to re-queue itself.\n\n      // Ok, the sorting for election nodes is a bit strange. If the sequence numbers are the same, then the whole\n      // string is used, but that sorts nodes with the same sequence number by their session IDs from ZK.\n      // While this is determinate, it's not quite what we need, so re-queue nodes that aren't us and are\n      // watching the leader node..\n\n\n      String firstWatcher = electionNodes.get(1);\n\n      if (LeaderElector.getNodeName(firstWatcher).equals(replica.getName()) == false) {\n        makeReplicaFirstWatcher(slice, replica);\n      }\n\n      // This replica should be the leader at the end of the day, so let's record that information to check at the end\n      pendingOps.put(slice.getName(), replica.getName());\n      String leaderElectionNode = electionNodes.get(0);\n      String coreName = slice.getReplica(LeaderElector.getNodeName(leaderElectionNode)).getStr(CORE_NAME_PROP);\n      rejoinElectionQueue(slice, leaderElectionNode, coreName, false);\n      waitForNodeChange(slice, leaderElectionNode);\n\n      return; // Done with this slice, skip the rest of the replicas.\n    }\n  }\n\n","sourceOld":"  private void ensurePreferredIsLeader(NamedList<Object> results,\n                                       Slice slice, Map<String, String> currentRequests) throws KeeperException, InterruptedException {\n    final String inactivePreferreds = \"inactivePreferreds\";\n    final String alreadyLeaders = \"alreadyLeaders\";\n    String collectionName = req.getParams().get(COLLECTION_PROP);\n\n    for (Replica replica : slice.getReplicas()) {\n      // Tell the replica to become the leader if we're the preferred leader AND active AND not the leader already\n      if (replica.getBool(SliceMutator.PREFERRED_LEADER_PROP, false) == false) {\n        continue;\n      }\n      // OK, we are the preferred leader, are we the actual leader?\n      if (replica.getBool(LEADER_PROP, false)) {\n        //We're a preferred leader, but we're _also_ the leader, don't need to do anything.\n        NamedList<Object> noops = (NamedList<Object>) results.get(alreadyLeaders);\n        if (noops == null) {\n          noops = new NamedList<>();\n          results.add(alreadyLeaders, noops);\n        }\n        NamedList<Object> res = new NamedList<>();\n        res.add(\"status\", \"success\");\n        res.add(\"msg\", \"Already leader\");\n        res.add(\"shard\", slice.getName());\n        res.add(\"nodeName\", replica.getNodeName());\n        noops.add(replica.getName(), res);\n        return; // already the leader, do nothing.\n      }\n\n      // We're the preferred leader, but someone else is leader. Only become leader if we're active.\n      if (replica.getState() != Replica.State.ACTIVE) {\n        NamedList<Object> inactives = (NamedList<Object>) results.get(inactivePreferreds);\n        if (inactives == null) {\n          inactives = new NamedList<>();\n          results.add(inactivePreferreds, inactives);\n        }\n        NamedList<Object> res = new NamedList<>();\n        res.add(\"status\", \"skipped\");\n        res.add(\"msg\", \"Node is a referredLeader, but it's inactive. Skipping\");\n        res.add(\"shard\", slice.getName());\n        res.add(\"nodeName\", replica.getNodeName());\n        inactives.add(replica.getName(), res);\n        return; // Don't try to become the leader if we're not active!\n      }\n\n      // Replica is the preferred leader but not the actual leader, do something about that.\n      // \"Something\" is\n      // 1> if the preferred leader isn't first in line, tell it to re-queue itself.\n      // 2> tell the actual leader to re-queue itself.\n\n      ZkStateReader zkStateReader = coreContainer.getZkController().getZkStateReader();\n\n      List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zkStateReader.getZkClient(),\n          ZkStateReader.getShardLeadersElectPath(collectionName, slice.getName()));\n\n      if (electionNodes.size() < 2) { // if there's only one node in the queue, should already be leader and we shouldn't be here anyway.\n        log.info(\"Rebalancing leaders and slice \" + slice.getName() + \" has less than two elements in the leader \" +\n            \"election queue, but replica \" + replica.getName() + \" doesn't think it's the leader.\");\n        return;\n      }\n\n      // Ok, the sorting for election nodes is a bit strange. If the sequence numbers are the same, then the whole\n      // string is used, but that sorts nodes with the same sequence number by their session IDs from ZK.\n      // While this is determinate, it's not quite what we need, so re-queue nodes that aren't us and are\n      // watching the leader node..\n\n      String firstWatcher = electionNodes.get(1);\n\n      if (LeaderElector.getNodeName(firstWatcher).equals(replica.getName()) == false) {\n        makeReplicaFirstWatcher(collectionName, slice, replica);\n      }\n\n      String coreName = slice.getReplica(LeaderElector.getNodeName(electionNodes.get(0))).getStr(CORE_NAME_PROP);\n      rejoinElection(collectionName, slice, electionNodes.get(0), coreName, false);\n      waitForNodeChange(collectionName, slice, electionNodes.get(0));\n\n\n      return; // Done with this slice, skip the rest of the replicas.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c89f1ef80a9432f4eabaeda9a1e135cd72e60836","date":1547972642,"type":1,"author":"Tommaso Teofili","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/RebalanceLeaders#ensurePreferredIsLeader(Slice).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/RebalanceLeaders#ensurePreferredIsLeader(NamedList[Object],Slice,Map[String,String]).mjava","sourceNew":"  // The process is:\n  // if the replica with preferredLeader is already the leader, do nothing\n  // Otherwise:\n  // > if two nodes have the same sequence number and both point to the current leader, we presume that we've just\n  //   moved it, move the one that does _not_ have the preferredLeader to the end of the list.\n  // > move the current leader to the end of the list. This _should_ mean that the current ephemeral node in the\n  //   leader election queue is removed and the only remaining node watching it is triggered to become leader.\n  private void ensurePreferredIsLeader(Slice slice) throws KeeperException, InterruptedException {\n    for (Replica replica : slice.getReplicas()) {\n      // Tell the replica to become the leader if we're the preferred leader AND active AND not the leader already\n      if (replica.getBool(SliceMutator.PREFERRED_LEADER_PROP, false) == false) {\n        continue;\n      }\n      // OK, we are the preferred leader, are we the actual leader?\n      if (replica.getBool(LEADER_PROP, false)) {\n        //We're a preferred leader, but we're _also_ the leader, don't need to do anything.\n        addAlreadyLeaderToResults(slice, replica);\n        return; // already the leader, do nothing.\n      }\n      ZkStateReader zkStateReader = coreContainer.getZkController().getZkStateReader();\n      // We're the preferred leader, but someone else is leader. Only become leader if we're active.\n      if (replica.isActive(zkStateReader.getClusterState().getLiveNodes()) == false) {\n        addInactiveToResults(slice, replica);\n        return; // Don't try to become the leader if we're not active!\n      }\n\n      List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zkStateReader.getZkClient(),\n          ZkStateReader.getShardLeadersElectPath(collectionName, slice.getName()));\n\n      if (electionQueueInBadState(electionNodes, slice, replica)) {\n        return;\n      }\n\n      // Replica is the preferred leader but not the actual leader, do something about that.\n      // \"Something\" is\n      // 1> if the preferred leader isn't first in line, tell it to re-queue itself.\n      // 2> tell the actual leader to re-queue itself.\n\n      // Ok, the sorting for election nodes is a bit strange. If the sequence numbers are the same, then the whole\n      // string is used, but that sorts nodes with the same sequence number by their session IDs from ZK.\n      // While this is determinate, it's not quite what we need, so re-queue nodes that aren't us and are\n      // watching the leader node..\n\n\n      String firstWatcher = electionNodes.get(1);\n\n      if (LeaderElector.getNodeName(firstWatcher).equals(replica.getName()) == false) {\n        makeReplicaFirstWatcher(slice, replica);\n      }\n\n      // This replica should be the leader at the end of the day, so let's record that information to check at the end\n      pendingOps.put(slice.getName(), replica.getName());\n      String leaderElectionNode = electionNodes.get(0);\n      String coreName = slice.getReplica(LeaderElector.getNodeName(leaderElectionNode)).getStr(CORE_NAME_PROP);\n      rejoinElectionQueue(slice, leaderElectionNode, coreName, false);\n      waitForNodeChange(slice, leaderElectionNode);\n\n      return; // Done with this slice, skip the rest of the replicas.\n    }\n  }\n\n","sourceOld":"  private void ensurePreferredIsLeader(NamedList<Object> results,\n                                       Slice slice, Map<String, String> currentRequests) throws KeeperException, InterruptedException {\n    final String inactivePreferreds = \"inactivePreferreds\";\n    final String alreadyLeaders = \"alreadyLeaders\";\n    String collectionName = req.getParams().get(COLLECTION_PROP);\n\n    for (Replica replica : slice.getReplicas()) {\n      // Tell the replica to become the leader if we're the preferred leader AND active AND not the leader already\n      if (replica.getBool(SliceMutator.PREFERRED_LEADER_PROP, false) == false) {\n        continue;\n      }\n      // OK, we are the preferred leader, are we the actual leader?\n      if (replica.getBool(LEADER_PROP, false)) {\n        //We're a preferred leader, but we're _also_ the leader, don't need to do anything.\n        NamedList<Object> noops = (NamedList<Object>) results.get(alreadyLeaders);\n        if (noops == null) {\n          noops = new NamedList<>();\n          results.add(alreadyLeaders, noops);\n        }\n        NamedList<Object> res = new NamedList<>();\n        res.add(\"status\", \"success\");\n        res.add(\"msg\", \"Already leader\");\n        res.add(\"shard\", slice.getName());\n        res.add(\"nodeName\", replica.getNodeName());\n        noops.add(replica.getName(), res);\n        return; // already the leader, do nothing.\n      }\n\n      // We're the preferred leader, but someone else is leader. Only become leader if we're active.\n      if (replica.getState() != Replica.State.ACTIVE) {\n        NamedList<Object> inactives = (NamedList<Object>) results.get(inactivePreferreds);\n        if (inactives == null) {\n          inactives = new NamedList<>();\n          results.add(inactivePreferreds, inactives);\n        }\n        NamedList<Object> res = new NamedList<>();\n        res.add(\"status\", \"skipped\");\n        res.add(\"msg\", \"Node is a referredLeader, but it's inactive. Skipping\");\n        res.add(\"shard\", slice.getName());\n        res.add(\"nodeName\", replica.getNodeName());\n        inactives.add(replica.getName(), res);\n        return; // Don't try to become the leader if we're not active!\n      }\n\n      // Replica is the preferred leader but not the actual leader, do something about that.\n      // \"Something\" is\n      // 1> if the preferred leader isn't first in line, tell it to re-queue itself.\n      // 2> tell the actual leader to re-queue itself.\n\n      ZkStateReader zkStateReader = coreContainer.getZkController().getZkStateReader();\n\n      List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zkStateReader.getZkClient(),\n          ZkStateReader.getShardLeadersElectPath(collectionName, slice.getName()));\n\n      if (electionNodes.size() < 2) { // if there's only one node in the queue, should already be leader and we shouldn't be here anyway.\n        log.info(\"Rebalancing leaders and slice \" + slice.getName() + \" has less than two elements in the leader \" +\n            \"election queue, but replica \" + replica.getName() + \" doesn't think it's the leader.\");\n        return;\n      }\n\n      // Ok, the sorting for election nodes is a bit strange. If the sequence numbers are the same, then the whole\n      // string is used, but that sorts nodes with the same sequence number by their session IDs from ZK.\n      // While this is determinate, it's not quite what we need, so re-queue nodes that aren't us and are\n      // watching the leader node..\n\n      String firstWatcher = electionNodes.get(1);\n\n      if (LeaderElector.getNodeName(firstWatcher).equals(replica.getName()) == false) {\n        makeReplicaFirstWatcher(collectionName, slice, replica);\n      }\n\n      String coreName = slice.getReplica(LeaderElector.getNodeName(electionNodes.get(0))).getStr(CORE_NAME_PROP);\n      rejoinElection(collectionName, slice, electionNodes.get(0), coreName, false);\n      waitForNodeChange(collectionName, slice, electionNodes.get(0));\n\n\n      return; // Done with this slice, skip the rest of the replicas.\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c89f1ef80a9432f4eabaeda9a1e135cd72e60836":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","73fd358e8ec697393d56617f4d9cedaca74dca14"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"73fd358e8ec697393d56617f4d9cedaca74dca14":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["73fd358e8ec697393d56617f4d9cedaca74dca14"]},"commit2Childs":{"c89f1ef80a9432f4eabaeda9a1e135cd72e60836":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c89f1ef80a9432f4eabaeda9a1e135cd72e60836","73fd358e8ec697393d56617f4d9cedaca74dca14"],"73fd358e8ec697393d56617f4d9cedaca74dca14":["c89f1ef80a9432f4eabaeda9a1e135cd72e60836","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c89f1ef80a9432f4eabaeda9a1e135cd72e60836","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}