{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/XYdZSolid#XYdZSolid(PlanetModel,double,double,double,double,double).mjava","commits":[{"id":"b4e444678504caf66a8060b1d514383aa4feac0c","date":1457399659,"type":1,"author":"David Smiley","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/XYdZSolid#XYdZSolid(PlanetModel,double,double,double,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/geo3d/XYdZSolid#XYdZSolid(PlanetModel,double,double,double,double,double).mjava","sourceNew":"  /**\n   * Sole constructor\n   *\n   *@param planetModel is the planet model.\n   *@param minX is the minimum X value.\n   *@param maxX is the maximum X value.\n   *@param minY is the minimum Y value.\n   *@param maxY is the maximum Y value.\n   *@param Z is the Z value.\n   */\n  public XYdZSolid(final PlanetModel planetModel,\n    final double minX,\n    final double maxX,\n    final double minY,\n    final double maxY,\n    final double Z) {\n    super(planetModel);\n    // Argument checking\n    if (maxX - minX < Vector.MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"X values in wrong order or identical\");\n    if (maxY - minY < Vector.MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"Y values in wrong order or identical\");\n\n    final double worldMinZ = planetModel.getMinimumZValue();\n    final double worldMaxZ = planetModel.getMaximumZValue();\n    \n    // Construct the planes\n    minXPlane = new SidedPlane(maxX,0.0,0.0,xUnitVector,-minX);\n    maxXPlane = new SidedPlane(minX,0.0,0.0,xUnitVector,-maxX);\n    minYPlane = new SidedPlane(0.0,maxY,0.0,yUnitVector,-minY);\n    maxYPlane = new SidedPlane(0.0,minY,0.0,yUnitVector,-maxY);\n    zPlane = new Plane(zUnitVector,-Z);\n      \n    // We need at least one point on the planet surface for each manifestation of the shape.\n    // There can be up to 2 (on opposite sides of the world).  But we have to go through\n    // 4 combinations of adjacent planes in order to find out if any have 2 intersection solution.\n    // Typically, this requires 4 square root operations. \n    final GeoPoint[] minXZ = minXPlane.findIntersections(planetModel,zPlane,maxXPlane,minYPlane,maxYPlane);\n    final GeoPoint[] maxXZ = maxXPlane.findIntersections(planetModel,zPlane,minXPlane,minYPlane,maxYPlane);\n    final GeoPoint[] minYZ = minYPlane.findIntersections(planetModel,zPlane,maxYPlane,minXPlane,maxXPlane);\n    final GeoPoint[] maxYZ = maxYPlane.findIntersections(planetModel,zPlane,minYPlane,minXPlane,maxXPlane);\n      \n    notableZPoints = glueTogether(minXZ, maxXZ, minYZ, maxYZ);\n\n    // Now, compute the edge points.\n    // This is the trickiest part of setting up an XYZSolid.  We've computed intersections already, so\n    // we'll start there.  We know that at most there will be two disconnected shapes on the planet surface.\n    // But there's also a case where exactly one plane slices through the world, and none of the bounding plane\n    // intersections do.  Thus, if we don't find any of the edge intersection cases, we have to look for that last case.\n      \n    // If we still haven't encountered anything, we need to look at single-plane/world intersections.\n    // We detect these by looking at the world model and noting its x, y, and z bounds.\n    // The cases we are looking for are when the four corner points for any given\n    // plane are all outside of the world, AND that plane intersects the world.\n    // There are four corner points all told; we must evaluate these WRT the planet surface.\n    final boolean minXminYZ = planetModel.pointOutside(minX, minY, Z);\n    final boolean minXmaxYZ = planetModel.pointOutside(minX, maxY, Z);\n    final boolean maxXminYZ = planetModel.pointOutside(maxX, minY, Z);\n    final boolean maxXmaxYZ = planetModel.pointOutside(maxX, maxY, Z);\n\n    final GeoPoint[] zEdges;\n    if (Z - worldMinZ >= -Vector.MINIMUM_RESOLUTION && Z - worldMaxZ <= Vector.MINIMUM_RESOLUTION &&\n      minX < 0.0 && maxX > 0.0 && minY < 0.0 && maxY > 0.0 &&\n      minXminYZ && minXmaxYZ && maxXminYZ && maxXmaxYZ) {\n      // Find any point on the minZ plane that intersects the world\n      // First construct a perpendicular plane that will allow us to find a sample point.\n      // This plane is vertical and goes through the points (0,0,0) and (1,0,0)\n      // Then use it to compute a sample point.\n      final GeoPoint intPoint = zPlane.getSampleIntersectionPoint(planetModel, xVerticalPlane);\n      if (intPoint != null) {\n        zEdges = new GeoPoint[]{intPoint};\n      } else {\n        zEdges = EMPTY_POINTS;\n      }\n    } else {\n      zEdges= EMPTY_POINTS;\n    }\n\n    this.edgePoints = glueTogether(minXZ, maxXZ, minYZ, maxYZ, zEdges);\n  }\n\n","sourceOld":"  /**\n   * Sole constructor\n   *\n   *@param planetModel is the planet model.\n   *@param minX is the minimum X value.\n   *@param maxX is the maximum X value.\n   *@param minY is the minimum Y value.\n   *@param maxY is the maximum Y value.\n   *@param Z is the Z value.\n   */\n  public XYdZSolid(final PlanetModel planetModel,\n    final double minX,\n    final double maxX,\n    final double minY,\n    final double maxY,\n    final double Z) {\n    super(planetModel);\n    // Argument checking\n    if (maxX - minX < Vector.MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"X values in wrong order or identical\");\n    if (maxY - minY < Vector.MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"Y values in wrong order or identical\");\n\n    final double worldMinZ = planetModel.getMinimumZValue();\n    final double worldMaxZ = planetModel.getMaximumZValue();\n    \n    // Construct the planes\n    minXPlane = new SidedPlane(maxX,0.0,0.0,xUnitVector,-minX);\n    maxXPlane = new SidedPlane(minX,0.0,0.0,xUnitVector,-maxX);\n    minYPlane = new SidedPlane(0.0,maxY,0.0,yUnitVector,-minY);\n    maxYPlane = new SidedPlane(0.0,minY,0.0,yUnitVector,-maxY);\n    zPlane = new Plane(zUnitVector,-Z);\n      \n    // We need at least one point on the planet surface for each manifestation of the shape.\n    // There can be up to 2 (on opposite sides of the world).  But we have to go through\n    // 4 combinations of adjacent planes in order to find out if any have 2 intersection solution.\n    // Typically, this requires 4 square root operations. \n    final GeoPoint[] minXZ = minXPlane.findIntersections(planetModel,zPlane,maxXPlane,minYPlane,maxYPlane);\n    final GeoPoint[] maxXZ = maxXPlane.findIntersections(planetModel,zPlane,minXPlane,minYPlane,maxYPlane);\n    final GeoPoint[] minYZ = minYPlane.findIntersections(planetModel,zPlane,maxYPlane,minXPlane,maxXPlane);\n    final GeoPoint[] maxYZ = maxYPlane.findIntersections(planetModel,zPlane,minYPlane,minXPlane,maxXPlane);\n      \n    notableZPoints = glueTogether(minXZ, maxXZ, minYZ, maxYZ);\n\n    // Now, compute the edge points.\n    // This is the trickiest part of setting up an XYZSolid.  We've computed intersections already, so\n    // we'll start there.  We know that at most there will be two disconnected shapes on the planet surface.\n    // But there's also a case where exactly one plane slices through the world, and none of the bounding plane\n    // intersections do.  Thus, if we don't find any of the edge intersection cases, we have to look for that last case.\n      \n    // If we still haven't encountered anything, we need to look at single-plane/world intersections.\n    // We detect these by looking at the world model and noting its x, y, and z bounds.\n    // The cases we are looking for are when the four corner points for any given\n    // plane are all outside of the world, AND that plane intersects the world.\n    // There are four corner points all told; we must evaluate these WRT the planet surface.\n    final boolean minXminYZ = planetModel.pointOutside(minX, minY, Z);\n    final boolean minXmaxYZ = planetModel.pointOutside(minX, maxY, Z);\n    final boolean maxXminYZ = planetModel.pointOutside(maxX, minY, Z);\n    final boolean maxXmaxYZ = planetModel.pointOutside(maxX, maxY, Z);\n\n    final GeoPoint[] zEdges;\n    if (Z - worldMinZ >= -Vector.MINIMUM_RESOLUTION && Z - worldMaxZ <= Vector.MINIMUM_RESOLUTION &&\n      minX < 0.0 && maxX > 0.0 && minY < 0.0 && maxY > 0.0 &&\n      minXminYZ && minXmaxYZ && maxXminYZ && maxXmaxYZ) {\n      // Find any point on the minZ plane that intersects the world\n      // First construct a perpendicular plane that will allow us to find a sample point.\n      // This plane is vertical and goes through the points (0,0,0) and (1,0,0)\n      // Then use it to compute a sample point.\n      final GeoPoint intPoint = zPlane.getSampleIntersectionPoint(planetModel, xVerticalPlane);\n      if (intPoint != null) {\n        zEdges = new GeoPoint[]{intPoint};\n      } else {\n        zEdges = EMPTY_POINTS;\n      }\n    } else {\n      zEdges= EMPTY_POINTS;\n    }\n\n    this.edgePoints = glueTogether(minXZ, maxXZ, minYZ, maxYZ, zEdges);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"25f722af2eac1e9065821e525111924b171ab724","date":1503596482,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/XYdZSolid#XYdZSolid(PlanetModel,double,double,double,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/XYdZSolid#XYdZSolid(PlanetModel,double,double,double,double,double).mjava","sourceNew":"  /**\n   * Sole constructor\n   *\n   *@param planetModel is the planet model.\n   *@param minX is the minimum X value.\n   *@param maxX is the maximum X value.\n   *@param minY is the minimum Y value.\n   *@param maxY is the maximum Y value.\n   *@param Z is the Z value.\n   */\n  public XYdZSolid(final PlanetModel planetModel,\n    final double minX,\n    final double maxX,\n    final double minY,\n    final double maxY,\n    final double Z) {\n    super(planetModel);\n    // Argument checking\n    if (maxX - minX < Vector.MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"X values in wrong order or identical\");\n    if (maxY - minY < Vector.MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"Y values in wrong order or identical\");\n\n    this.minX = minX;\n    this.maxX = maxX;\n    this.minY = minY;\n    this.maxY = maxY;\n    this.Z = Z;\n\n    final double worldMinZ = planetModel.getMinimumZValue();\n    final double worldMaxZ = planetModel.getMaximumZValue();\n    \n    // Construct the planes\n    minXPlane = new SidedPlane(maxX,0.0,0.0,xUnitVector,-minX);\n    maxXPlane = new SidedPlane(minX,0.0,0.0,xUnitVector,-maxX);\n    minYPlane = new SidedPlane(0.0,maxY,0.0,yUnitVector,-minY);\n    maxYPlane = new SidedPlane(0.0,minY,0.0,yUnitVector,-maxY);\n    zPlane = new Plane(zUnitVector,-Z);\n      \n    // We need at least one point on the planet surface for each manifestation of the shape.\n    // There can be up to 2 (on opposite sides of the world).  But we have to go through\n    // 4 combinations of adjacent planes in order to find out if any have 2 intersection solution.\n    // Typically, this requires 4 square root operations. \n    final GeoPoint[] minXZ = minXPlane.findIntersections(planetModel,zPlane,maxXPlane,minYPlane,maxYPlane);\n    final GeoPoint[] maxXZ = maxXPlane.findIntersections(planetModel,zPlane,minXPlane,minYPlane,maxYPlane);\n    final GeoPoint[] minYZ = minYPlane.findIntersections(planetModel,zPlane,maxYPlane,minXPlane,maxXPlane);\n    final GeoPoint[] maxYZ = maxYPlane.findIntersections(planetModel,zPlane,minYPlane,minXPlane,maxXPlane);\n      \n    notableZPoints = glueTogether(minXZ, maxXZ, minYZ, maxYZ);\n\n    // Now, compute the edge points.\n    // This is the trickiest part of setting up an XYZSolid.  We've computed intersections already, so\n    // we'll start there.  We know that at most there will be two disconnected shapes on the planet surface.\n    // But there's also a case where exactly one plane slices through the world, and none of the bounding plane\n    // intersections do.  Thus, if we don't find any of the edge intersection cases, we have to look for that last case.\n      \n    // If we still haven't encountered anything, we need to look at single-plane/world intersections.\n    // We detect these by looking at the world model and noting its x, y, and z bounds.\n    // The cases we are looking for are when the four corner points for any given\n    // plane are all outside of the world, AND that plane intersects the world.\n    // There are four corner points all told; we must evaluate these WRT the planet surface.\n    final boolean minXminYZ = planetModel.pointOutside(minX, minY, Z);\n    final boolean minXmaxYZ = planetModel.pointOutside(minX, maxY, Z);\n    final boolean maxXminYZ = planetModel.pointOutside(maxX, minY, Z);\n    final boolean maxXmaxYZ = planetModel.pointOutside(maxX, maxY, Z);\n\n    final GeoPoint[] zEdges;\n    if (Z - worldMinZ >= -Vector.MINIMUM_RESOLUTION && Z - worldMaxZ <= Vector.MINIMUM_RESOLUTION &&\n      minX < 0.0 && maxX > 0.0 && minY < 0.0 && maxY > 0.0 &&\n      minXminYZ && minXmaxYZ && maxXminYZ && maxXmaxYZ) {\n      // Find any point on the minZ plane that intersects the world\n      // First construct a perpendicular plane that will allow us to find a sample point.\n      // This plane is vertical and goes through the points (0,0,0) and (1,0,0)\n      // Then use it to compute a sample point.\n      final GeoPoint intPoint = zPlane.getSampleIntersectionPoint(planetModel, xVerticalPlane);\n      if (intPoint != null) {\n        zEdges = new GeoPoint[]{intPoint};\n      } else {\n        zEdges = EMPTY_POINTS;\n      }\n    } else {\n      zEdges= EMPTY_POINTS;\n    }\n\n    this.edgePoints = glueTogether(minXZ, maxXZ, minYZ, maxYZ, zEdges);\n  }\n\n","sourceOld":"  /**\n   * Sole constructor\n   *\n   *@param planetModel is the planet model.\n   *@param minX is the minimum X value.\n   *@param maxX is the maximum X value.\n   *@param minY is the minimum Y value.\n   *@param maxY is the maximum Y value.\n   *@param Z is the Z value.\n   */\n  public XYdZSolid(final PlanetModel planetModel,\n    final double minX,\n    final double maxX,\n    final double minY,\n    final double maxY,\n    final double Z) {\n    super(planetModel);\n    // Argument checking\n    if (maxX - minX < Vector.MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"X values in wrong order or identical\");\n    if (maxY - minY < Vector.MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"Y values in wrong order or identical\");\n\n    final double worldMinZ = planetModel.getMinimumZValue();\n    final double worldMaxZ = planetModel.getMaximumZValue();\n    \n    // Construct the planes\n    minXPlane = new SidedPlane(maxX,0.0,0.0,xUnitVector,-minX);\n    maxXPlane = new SidedPlane(minX,0.0,0.0,xUnitVector,-maxX);\n    minYPlane = new SidedPlane(0.0,maxY,0.0,yUnitVector,-minY);\n    maxYPlane = new SidedPlane(0.0,minY,0.0,yUnitVector,-maxY);\n    zPlane = new Plane(zUnitVector,-Z);\n      \n    // We need at least one point on the planet surface for each manifestation of the shape.\n    // There can be up to 2 (on opposite sides of the world).  But we have to go through\n    // 4 combinations of adjacent planes in order to find out if any have 2 intersection solution.\n    // Typically, this requires 4 square root operations. \n    final GeoPoint[] minXZ = minXPlane.findIntersections(planetModel,zPlane,maxXPlane,minYPlane,maxYPlane);\n    final GeoPoint[] maxXZ = maxXPlane.findIntersections(planetModel,zPlane,minXPlane,minYPlane,maxYPlane);\n    final GeoPoint[] minYZ = minYPlane.findIntersections(planetModel,zPlane,maxYPlane,minXPlane,maxXPlane);\n    final GeoPoint[] maxYZ = maxYPlane.findIntersections(planetModel,zPlane,minYPlane,minXPlane,maxXPlane);\n      \n    notableZPoints = glueTogether(minXZ, maxXZ, minYZ, maxYZ);\n\n    // Now, compute the edge points.\n    // This is the trickiest part of setting up an XYZSolid.  We've computed intersections already, so\n    // we'll start there.  We know that at most there will be two disconnected shapes on the planet surface.\n    // But there's also a case where exactly one plane slices through the world, and none of the bounding plane\n    // intersections do.  Thus, if we don't find any of the edge intersection cases, we have to look for that last case.\n      \n    // If we still haven't encountered anything, we need to look at single-plane/world intersections.\n    // We detect these by looking at the world model and noting its x, y, and z bounds.\n    // The cases we are looking for are when the four corner points for any given\n    // plane are all outside of the world, AND that plane intersects the world.\n    // There are four corner points all told; we must evaluate these WRT the planet surface.\n    final boolean minXminYZ = planetModel.pointOutside(minX, minY, Z);\n    final boolean minXmaxYZ = planetModel.pointOutside(minX, maxY, Z);\n    final boolean maxXminYZ = planetModel.pointOutside(maxX, minY, Z);\n    final boolean maxXmaxYZ = planetModel.pointOutside(maxX, maxY, Z);\n\n    final GeoPoint[] zEdges;\n    if (Z - worldMinZ >= -Vector.MINIMUM_RESOLUTION && Z - worldMaxZ <= Vector.MINIMUM_RESOLUTION &&\n      minX < 0.0 && maxX > 0.0 && minY < 0.0 && maxY > 0.0 &&\n      minXminYZ && minXmaxYZ && maxXminYZ && maxXmaxYZ) {\n      // Find any point on the minZ plane that intersects the world\n      // First construct a perpendicular plane that will allow us to find a sample point.\n      // This plane is vertical and goes through the points (0,0,0) and (1,0,0)\n      // Then use it to compute a sample point.\n      final GeoPoint intPoint = zPlane.getSampleIntersectionPoint(planetModel, xVerticalPlane);\n      if (intPoint != null) {\n        zEdges = new GeoPoint[]{intPoint};\n      } else {\n        zEdges = EMPTY_POINTS;\n      }\n    } else {\n      zEdges= EMPTY_POINTS;\n    }\n\n    this.edgePoints = glueTogether(minXZ, maxXZ, minYZ, maxYZ, zEdges);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a7809d1d753b67f48b1a706e17034bf8b624ea3","date":1504366927,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/XYdZSolid#XYdZSolid(PlanetModel,double,double,double,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/XYdZSolid#XYdZSolid(PlanetModel,double,double,double,double,double).mjava","sourceNew":"  /**\n   * Sole constructor\n   *\n   *@param planetModel is the planet model.\n   *@param minX is the minimum X value.\n   *@param maxX is the maximum X value.\n   *@param minY is the minimum Y value.\n   *@param maxY is the maximum Y value.\n   *@param Z is the Z value.\n   */\n  public XYdZSolid(final PlanetModel planetModel,\n    final double minX,\n    final double maxX,\n    final double minY,\n    final double maxY,\n    final double Z) {\n    super(planetModel);\n    // Argument checking\n    if (maxX - minX < Vector.MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"X values in wrong order or identical\");\n    if (maxY - minY < Vector.MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"Y values in wrong order or identical\");\n\n    this.minX = minX;\n    this.maxX = maxX;\n    this.minY = minY;\n    this.maxY = maxY;\n    this.Z = Z;\n\n    final double worldMinZ = planetModel.getMinimumZValue();\n    final double worldMaxZ = planetModel.getMaximumZValue();\n    \n    // Construct the planes\n    minXPlane = new SidedPlane(maxX,0.0,0.0,xUnitVector,-minX);\n    maxXPlane = new SidedPlane(minX,0.0,0.0,xUnitVector,-maxX);\n    minYPlane = new SidedPlane(0.0,maxY,0.0,yUnitVector,-minY);\n    maxYPlane = new SidedPlane(0.0,minY,0.0,yUnitVector,-maxY);\n    zPlane = new Plane(zUnitVector,-Z);\n      \n    // We need at least one point on the planet surface for each manifestation of the shape.\n    // There can be up to 2 (on opposite sides of the world).  But we have to go through\n    // 4 combinations of adjacent planes in order to find out if any have 2 intersection solution.\n    // Typically, this requires 4 square root operations. \n    final GeoPoint[] minXZ = minXPlane.findIntersections(planetModel,zPlane,maxXPlane,minYPlane,maxYPlane);\n    final GeoPoint[] maxXZ = maxXPlane.findIntersections(planetModel,zPlane,minXPlane,minYPlane,maxYPlane);\n    final GeoPoint[] minYZ = minYPlane.findIntersections(planetModel,zPlane,maxYPlane,minXPlane,maxXPlane);\n    final GeoPoint[] maxYZ = maxYPlane.findIntersections(planetModel,zPlane,minYPlane,minXPlane,maxXPlane);\n      \n    notableZPoints = glueTogether(minXZ, maxXZ, minYZ, maxYZ);\n\n    // Now, compute the edge points.\n    // This is the trickiest part of setting up an XYZSolid.  We've computed intersections already, so\n    // we'll start there.  We know that at most there will be two disconnected shapes on the planet surface.\n    // But there's also a case where exactly one plane slices through the world, and none of the bounding plane\n    // intersections do.  Thus, if we don't find any of the edge intersection cases, we have to look for that last case.\n      \n    // If we still haven't encountered anything, we need to look at single-plane/world intersections.\n    // We detect these by looking at the world model and noting its x, y, and z bounds.\n    // The cases we are looking for are when the four corner points for any given\n    // plane are all outside of the world, AND that plane intersects the world.\n    // There are four corner points all told; we must evaluate these WRT the planet surface.\n    final boolean minXminYZ = planetModel.pointOutside(minX, minY, Z);\n    final boolean minXmaxYZ = planetModel.pointOutside(minX, maxY, Z);\n    final boolean maxXminYZ = planetModel.pointOutside(maxX, minY, Z);\n    final boolean maxXmaxYZ = planetModel.pointOutside(maxX, maxY, Z);\n\n    final GeoPoint[] zEdges;\n    if (Z - worldMinZ >= -Vector.MINIMUM_RESOLUTION && Z - worldMaxZ <= Vector.MINIMUM_RESOLUTION &&\n      minX < 0.0 && maxX > 0.0 && minY < 0.0 && maxY > 0.0 &&\n      minXminYZ && minXmaxYZ && maxXminYZ && maxXmaxYZ) {\n      // Find any point on the minZ plane that intersects the world\n      // First construct a perpendicular plane that will allow us to find a sample point.\n      // This plane is vertical and goes through the points (0,0,0) and (1,0,0)\n      // Then use it to compute a sample point.\n      final GeoPoint intPoint = zPlane.getSampleIntersectionPoint(planetModel, xVerticalPlane);\n      if (intPoint != null) {\n        zEdges = new GeoPoint[]{intPoint};\n      } else {\n        zEdges = EMPTY_POINTS;\n      }\n    } else {\n      zEdges= EMPTY_POINTS;\n    }\n\n    this.edgePoints = glueTogether(minXZ, maxXZ, minYZ, maxYZ, zEdges);\n  }\n\n","sourceOld":"  /**\n   * Sole constructor\n   *\n   *@param planetModel is the planet model.\n   *@param minX is the minimum X value.\n   *@param maxX is the maximum X value.\n   *@param minY is the minimum Y value.\n   *@param maxY is the maximum Y value.\n   *@param Z is the Z value.\n   */\n  public XYdZSolid(final PlanetModel planetModel,\n    final double minX,\n    final double maxX,\n    final double minY,\n    final double maxY,\n    final double Z) {\n    super(planetModel);\n    // Argument checking\n    if (maxX - minX < Vector.MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"X values in wrong order or identical\");\n    if (maxY - minY < Vector.MINIMUM_RESOLUTION)\n      throw new IllegalArgumentException(\"Y values in wrong order or identical\");\n\n    final double worldMinZ = planetModel.getMinimumZValue();\n    final double worldMaxZ = planetModel.getMaximumZValue();\n    \n    // Construct the planes\n    minXPlane = new SidedPlane(maxX,0.0,0.0,xUnitVector,-minX);\n    maxXPlane = new SidedPlane(minX,0.0,0.0,xUnitVector,-maxX);\n    minYPlane = new SidedPlane(0.0,maxY,0.0,yUnitVector,-minY);\n    maxYPlane = new SidedPlane(0.0,minY,0.0,yUnitVector,-maxY);\n    zPlane = new Plane(zUnitVector,-Z);\n      \n    // We need at least one point on the planet surface for each manifestation of the shape.\n    // There can be up to 2 (on opposite sides of the world).  But we have to go through\n    // 4 combinations of adjacent planes in order to find out if any have 2 intersection solution.\n    // Typically, this requires 4 square root operations. \n    final GeoPoint[] minXZ = minXPlane.findIntersections(planetModel,zPlane,maxXPlane,minYPlane,maxYPlane);\n    final GeoPoint[] maxXZ = maxXPlane.findIntersections(planetModel,zPlane,minXPlane,minYPlane,maxYPlane);\n    final GeoPoint[] minYZ = minYPlane.findIntersections(planetModel,zPlane,maxYPlane,minXPlane,maxXPlane);\n    final GeoPoint[] maxYZ = maxYPlane.findIntersections(planetModel,zPlane,minYPlane,minXPlane,maxXPlane);\n      \n    notableZPoints = glueTogether(minXZ, maxXZ, minYZ, maxYZ);\n\n    // Now, compute the edge points.\n    // This is the trickiest part of setting up an XYZSolid.  We've computed intersections already, so\n    // we'll start there.  We know that at most there will be two disconnected shapes on the planet surface.\n    // But there's also a case where exactly one plane slices through the world, and none of the bounding plane\n    // intersections do.  Thus, if we don't find any of the edge intersection cases, we have to look for that last case.\n      \n    // If we still haven't encountered anything, we need to look at single-plane/world intersections.\n    // We detect these by looking at the world model and noting its x, y, and z bounds.\n    // The cases we are looking for are when the four corner points for any given\n    // plane are all outside of the world, AND that plane intersects the world.\n    // There are four corner points all told; we must evaluate these WRT the planet surface.\n    final boolean minXminYZ = planetModel.pointOutside(minX, minY, Z);\n    final boolean minXmaxYZ = planetModel.pointOutside(minX, maxY, Z);\n    final boolean maxXminYZ = planetModel.pointOutside(maxX, minY, Z);\n    final boolean maxXmaxYZ = planetModel.pointOutside(maxX, maxY, Z);\n\n    final GeoPoint[] zEdges;\n    if (Z - worldMinZ >= -Vector.MINIMUM_RESOLUTION && Z - worldMaxZ <= Vector.MINIMUM_RESOLUTION &&\n      minX < 0.0 && maxX > 0.0 && minY < 0.0 && maxY > 0.0 &&\n      minXminYZ && minXmaxYZ && maxXminYZ && maxXmaxYZ) {\n      // Find any point on the minZ plane that intersects the world\n      // First construct a perpendicular plane that will allow us to find a sample point.\n      // This plane is vertical and goes through the points (0,0,0) and (1,0,0)\n      // Then use it to compute a sample point.\n      final GeoPoint intPoint = zPlane.getSampleIntersectionPoint(planetModel, xVerticalPlane);\n      if (intPoint != null) {\n        zEdges = new GeoPoint[]{intPoint};\n      } else {\n        zEdges = EMPTY_POINTS;\n      }\n    } else {\n      zEdges= EMPTY_POINTS;\n    }\n\n    this.edgePoints = glueTogether(minXZ, maxXZ, minYZ, maxYZ, zEdges);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"25f722af2eac1e9065821e525111924b171ab724":["b4e444678504caf66a8060b1d514383aa4feac0c"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":["b4e444678504caf66a8060b1d514383aa4feac0c","25f722af2eac1e9065821e525111924b171ab724"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b4e444678504caf66a8060b1d514383aa4feac0c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["25f722af2eac1e9065821e525111924b171ab724"]},"commit2Childs":{"25f722af2eac1e9065821e525111924b171ab724":["3a7809d1d753b67f48b1a706e17034bf8b624ea3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b4e444678504caf66a8060b1d514383aa4feac0c"],"b4e444678504caf66a8060b1d514383aa4feac0c":["25f722af2eac1e9065821e525111924b171ab724","3a7809d1d753b67f48b1a706e17034bf8b624ea3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3a7809d1d753b67f48b1a706e17034bf8b624ea3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}