{"path":"solr/core/src/test/org/apache/solr/search/RankQueryTestPlugin.TestMergeStrategy1#merge(ResponseBuilder,ShardRequest).mjava","commits":[{"id":"bd81b9f1e22432a668756e938bfb0835c1abb11b","date":1546254331,"type":1,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/RankQueryTestPlugin.TestMergeStrategy1#merge(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRankQueryPlugin.TestMergeStrategy1#merge(ResponseBuilder,ShardRequest).mjava","sourceNew":"    public void merge(ResponseBuilder rb, ShardRequest sreq) {\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n\n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      List<ShardDoc> shardDocs = new ArrayList();\n\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n\n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY))) {\n          partialResults = true;\n        }\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        SortSpec ss = rb.getSortSpec();\n        Sort sort = ss.getSort();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"merge_values\"));\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n        List lst = (List)unmarshalledSortFieldValues.getVal(0);\n\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = lst.get(i);\n          if (scoreObj != null) {\n            shardDoc.score = ((Integer)scoreObj).floatValue();\n          }\n          shardDocs.add(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n      Collections.sort(shardDocs, (o1, o2) -> {\n        if (o1.score < o2.score) {\n          return 1;\n        } else if (o1.score > o2.score) {\n          return -1;\n        } else {\n          return 0;  //To change body of implemented methods use File | Settings | File Templates.\n        }\n      });\n\n      int resultSize = shardDocs.size();\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=0; i<shardDocs.size(); i++) {\n        ShardDoc shardDoc = shardDocs.get(i);\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(0);\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE );\n      }\n    }\n\n","sourceOld":"    public void merge(ResponseBuilder rb, ShardRequest sreq) {\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n\n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      List<ShardDoc> shardDocs = new ArrayList();\n\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n\n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY))) {\n          partialResults = true;\n        }\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        SortSpec ss = rb.getSortSpec();\n        Sort sort = ss.getSort();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"merge_values\"));\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n        List lst = (List)unmarshalledSortFieldValues.getVal(0);\n\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = lst.get(i);\n          if (scoreObj != null) {\n            shardDoc.score = ((Integer)scoreObj).floatValue();\n          }\n          shardDocs.add(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n      Collections.sort(shardDocs, (o1, o2) -> {\n        if (o1.score < o2.score) {\n          return 1;\n        } else if (o1.score > o2.score) {\n          return -1;\n        } else {\n          return 0;  //To change body of implemented methods use File | Settings | File Templates.\n        }\n      });\n\n      int resultSize = shardDocs.size();\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=0; i<shardDocs.size(); i++) {\n        ShardDoc shardDoc = shardDocs.get(i);\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(0);\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE );\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e98520789adb1d5ad05afb4956eca0944a929688","date":1592430701,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/RankQueryTestPlugin.TestMergeStrategy1#merge(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/RankQueryTestPlugin.TestMergeStrategy1#merge(ResponseBuilder,ShardRequest).mjava","sourceNew":"    @SuppressWarnings({\"unchecked\"})\n    public void merge(ResponseBuilder rb, ShardRequest sreq) {\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n\n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      List<ShardDoc> shardDocs = new ArrayList<>();\n\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n\n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY))) {\n          partialResults = true;\n        }\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        SortSpec ss = rb.getSortSpec();\n        Sort sort = ss.getSort();\n\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"merge_values\"));\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n        @SuppressWarnings({\"rawtypes\"})\n        List lst = (List)unmarshalledSortFieldValues.getVal(0);\n\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = lst.get(i);\n          if (scoreObj != null) {\n            shardDoc.score = ((Integer)scoreObj).floatValue();\n          }\n          shardDocs.add(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n      Collections.sort(shardDocs, (o1, o2) -> {\n        if (o1.score < o2.score) {\n          return 1;\n        } else if (o1.score > o2.score) {\n          return -1;\n        } else {\n          return 0;  //To change body of implemented methods use File | Settings | File Templates.\n        }\n      });\n\n      int resultSize = shardDocs.size();\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=0; i<shardDocs.size(); i++) {\n        ShardDoc shardDoc = shardDocs.get(i);\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(0);\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE );\n      }\n    }\n\n","sourceOld":"    public void merge(ResponseBuilder rb, ShardRequest sreq) {\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n\n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      List<ShardDoc> shardDocs = new ArrayList();\n\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n\n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY))) {\n          partialResults = true;\n        }\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n        SortSpec ss = rb.getSortSpec();\n        Sort sort = ss.getSort();\n\n        NamedList sortFieldValues = (NamedList)(srsp.getSolrResponse().getResponse().get(\"merge_values\"));\n        NamedList unmarshalledSortFieldValues = unmarshalSortValues(ss, sortFieldValues, schema);\n        List lst = (List)unmarshalledSortFieldValues.getVal(0);\n\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = lst.get(i);\n          if (scoreObj != null) {\n            shardDoc.score = ((Integer)scoreObj).floatValue();\n          }\n          shardDocs.add(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n      Collections.sort(shardDocs, (o1, o2) -> {\n        if (o1.score < o2.score) {\n          return 1;\n        } else if (o1.score > o2.score) {\n          return -1;\n        } else {\n          return 0;  //To change body of implemented methods use File | Settings | File Templates.\n        }\n      });\n\n      int resultSize = shardDocs.size();\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=0; i<shardDocs.size(); i++) {\n        ShardDoc shardDoc = shardDocs.get(i);\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(0);\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE );\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bd81b9f1e22432a668756e938bfb0835c1abb11b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e98520789adb1d5ad05afb4956eca0944a929688"],"e98520789adb1d5ad05afb4956eca0944a929688":["bd81b9f1e22432a668756e938bfb0835c1abb11b"]},"commit2Childs":{"bd81b9f1e22432a668756e938bfb0835c1abb11b":["e98520789adb1d5ad05afb4956eca0944a929688"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bd81b9f1e22432a668756e938bfb0835c1abb11b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"e98520789adb1d5ad05afb4956eca0944a929688":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}