{"path":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,Set[BytesRef],boolean,int).mjava","commits":[{"id":"58d0345a28bb6b4be59c38e6a77e2cc0e615ee4b","date":1395588343,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,Set[BytesRef],boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","sourceNew":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, Set<BytesRef> contexts, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n    if (contexts != null) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    if (fst == null) {\n      return Collections.emptyList();\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    for (int i = 0; i < key.length(); i++) {\n      if (key.charAt(i) == 0x1E) {\n        throw new IllegalArgumentException(\"lookup key cannot contain HOLE character U+001E; this character is reserved\");\n      }\n      if (key.charAt(i) == 0x1F) {\n        throw new IllegalArgumentException(\"lookup key cannot contain unit separator character U+001F; this character is reserved\");\n      }\n    }\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader();\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<>();\n\n      final List<LookupResult> results = new ArrayList<>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(convertAutomaton(lookupAutomaton), fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n        assert completions.isComplete;\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(Result<Pair<Long,BytesRef>> completion : completions) {\n          BytesRef output2 = completion.output.output2;\n          if (sameSurfaceForm(utf8Key, output2)) {\n            results.add(getLookupResult(completion.output.output1, output2, spare));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (sameSurfaceForm(utf8Key, output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n      assert completions.isComplete;\n\n      for(Result<Pair<Long,BytesRef>> completion : completions) {\n\n        LookupResult result = getLookupResult(completion.output.output1, completion.output.output2, spare);\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","sourceOld":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n    if (fst == null) {\n      return Collections.emptyList();\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    for (int i = 0; i < key.length(); i++) {\n      if (key.charAt(i) == 0x1E) {\n        throw new IllegalArgumentException(\"lookup key cannot contain HOLE character U+001E; this character is reserved\");\n      }\n      if (key.charAt(i) == 0x1F) {\n        throw new IllegalArgumentException(\"lookup key cannot contain unit separator character U+001F; this character is reserved\");\n      }\n    }\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader();\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<>();\n\n      final List<LookupResult> results = new ArrayList<>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(convertAutomaton(lookupAutomaton), fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n        assert completions.isComplete;\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(Result<Pair<Long,BytesRef>> completion : completions) {\n          BytesRef output2 = completion.output.output2;\n          if (sameSurfaceForm(utf8Key, output2)) {\n            results.add(getLookupResult(completion.output.output1, output2, spare));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (sameSurfaceForm(utf8Key, output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n      assert completions.isComplete;\n\n      for(Result<Pair<Long,BytesRef>> completion : completions) {\n\n        LookupResult result = getLookupResult(completion.output.output1, completion.output.output2, spare);\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"75ac8571c2d82c574e446c3729251b994c69a55c","date":1402523781,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,Set[BytesRef],boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,Set[BytesRef],boolean,int).mjava","sourceNew":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, Set<BytesRef> contexts, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n    if (contexts != null) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    if (fst == null) {\n      return Collections.emptyList();\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    for (int i = 0; i < key.length(); i++) {\n      if (key.charAt(i) == 0x1E) {\n        throw new IllegalArgumentException(\"lookup key cannot contain HOLE character U+001E; this character is reserved\");\n      }\n      if (key.charAt(i) == 0x1F) {\n        throw new IllegalArgumentException(\"lookup key cannot contain unit separator character U+001F; this character is reserved\");\n      }\n    }\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n      LightAutomaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader();\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<>();\n\n      final List<LookupResult> results = new ArrayList<>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(convertAutomaton(lookupAutomaton), fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n        assert completions.isComplete;\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(Result<Pair<Long,BytesRef>> completion : completions) {\n          BytesRef output2 = completion.output.output2;\n          if (sameSurfaceForm(utf8Key, output2)) {\n            results.add(getLookupResult(completion.output.output1, output2, spare));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (sameSurfaceForm(utf8Key, output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n      assert completions.isComplete;\n\n      for(Result<Pair<Long,BytesRef>> completion : completions) {\n\n        LookupResult result = getLookupResult(completion.output.output1, completion.output.output2, spare);\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","sourceOld":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, Set<BytesRef> contexts, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n    if (contexts != null) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    if (fst == null) {\n      return Collections.emptyList();\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    for (int i = 0; i < key.length(); i++) {\n      if (key.charAt(i) == 0x1E) {\n        throw new IllegalArgumentException(\"lookup key cannot contain HOLE character U+001E; this character is reserved\");\n      }\n      if (key.charAt(i) == 0x1F) {\n        throw new IllegalArgumentException(\"lookup key cannot contain unit separator character U+001F; this character is reserved\");\n      }\n    }\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader();\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<>();\n\n      final List<LookupResult> results = new ArrayList<>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(convertAutomaton(lookupAutomaton), fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n        assert completions.isComplete;\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(Result<Pair<Long,BytesRef>> completion : completions) {\n          BytesRef output2 = completion.output.output2;\n          if (sameSurfaceForm(utf8Key, output2)) {\n            results.add(getLookupResult(completion.output.output1, output2, spare));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (sameSurfaceForm(utf8Key, output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n      assert completions.isComplete;\n\n      for(Result<Pair<Long,BytesRef>> completion : completions) {\n\n        LookupResult result = getLookupResult(completion.output.output1, completion.output.output2, spare);\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4ca1c732df8923f5624f6c06b1dcca9e69d98c96","date":1402957391,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,Set[BytesRef],boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,Set[BytesRef],boolean,int).mjava","sourceNew":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, Set<BytesRef> contexts, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n    if (contexts != null) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    if (fst == null) {\n      return Collections.emptyList();\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    for (int i = 0; i < key.length(); i++) {\n      if (key.charAt(i) == 0x1E) {\n        throw new IllegalArgumentException(\"lookup key cannot contain HOLE character U+001E; this character is reserved\");\n      }\n      if (key.charAt(i) == 0x1F) {\n        throw new IllegalArgumentException(\"lookup key cannot contain unit separator character U+001F; this character is reserved\");\n      }\n    }\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader();\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<>();\n\n      final List<LookupResult> results = new ArrayList<>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(convertAutomaton(lookupAutomaton), fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n        assert completions.isComplete;\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(Result<Pair<Long,BytesRef>> completion : completions) {\n          BytesRef output2 = completion.output.output2;\n          if (sameSurfaceForm(utf8Key, output2)) {\n            results.add(getLookupResult(completion.output.output1, output2, spare));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (sameSurfaceForm(utf8Key, output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n      assert completions.isComplete;\n\n      for(Result<Pair<Long,BytesRef>> completion : completions) {\n\n        LookupResult result = getLookupResult(completion.output.output1, completion.output.output2, spare);\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","sourceOld":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, Set<BytesRef> contexts, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n    if (contexts != null) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    if (fst == null) {\n      return Collections.emptyList();\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    for (int i = 0; i < key.length(); i++) {\n      if (key.charAt(i) == 0x1E) {\n        throw new IllegalArgumentException(\"lookup key cannot contain HOLE character U+001E; this character is reserved\");\n      }\n      if (key.charAt(i) == 0x1F) {\n        throw new IllegalArgumentException(\"lookup key cannot contain unit separator character U+001F; this character is reserved\");\n      }\n    }\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n      LightAutomaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader();\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<>();\n\n      final List<LookupResult> results = new ArrayList<>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(convertAutomaton(lookupAutomaton), fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n        assert completions.isComplete;\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(Result<Pair<Long,BytesRef>> completion : completions) {\n          BytesRef output2 = completion.output.output2;\n          if (sameSurfaceForm(utf8Key, output2)) {\n            results.add(getLookupResult(completion.output.output1, output2, spare));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (sameSurfaceForm(utf8Key, output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n      assert completions.isComplete;\n\n      for(Result<Pair<Long,BytesRef>> completion : completions) {\n\n        LookupResult result = getLookupResult(completion.output.output1, completion.output.output2, spare);\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5c84485629d80d203608e8975a1139de9933cc38","date":1403166128,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,Set[BytesRef],boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,Set[BytesRef],boolean,int).mjava","sourceNew":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, Set<BytesRef> contexts, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n    if (contexts != null) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    if (fst == null) {\n      return Collections.emptyList();\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    for (int i = 0; i < key.length(); i++) {\n      if (key.charAt(i) == 0x1E) {\n        throw new IllegalArgumentException(\"lookup key cannot contain HOLE character U+001E; this character is reserved\");\n      }\n      if (key.charAt(i) == 0x1F) {\n        throw new IllegalArgumentException(\"lookup key cannot contain unit separator character U+001F; this character is reserved\");\n      }\n    }\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader();\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<>();\n\n      final List<LookupResult> results = new ArrayList<>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(convertAutomaton(lookupAutomaton), fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n        assert completions.isComplete;\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(Result<Pair<Long,BytesRef>> completion : completions) {\n          BytesRef output2 = completion.output.output2;\n          if (sameSurfaceForm(utf8Key, output2)) {\n            results.add(getLookupResult(completion.output.output1, output2, spare));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (sameSurfaceForm(utf8Key, output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n      assert completions.isComplete;\n\n      for(Result<Pair<Long,BytesRef>> completion : completions) {\n\n        LookupResult result = getLookupResult(completion.output.output1, completion.output.output2, spare);\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","sourceOld":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, Set<BytesRef> contexts, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n    if (contexts != null) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    if (fst == null) {\n      return Collections.emptyList();\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    for (int i = 0; i < key.length(); i++) {\n      if (key.charAt(i) == 0x1E) {\n        throw new IllegalArgumentException(\"lookup key cannot contain HOLE character U+001E; this character is reserved\");\n      }\n      if (key.charAt(i) == 0x1F) {\n        throw new IllegalArgumentException(\"lookup key cannot contain unit separator character U+001F; this character is reserved\");\n      }\n    }\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader();\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<>();\n\n      final List<LookupResult> results = new ArrayList<>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(convertAutomaton(lookupAutomaton), fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n        assert completions.isComplete;\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(Result<Pair<Long,BytesRef>> completion : completions) {\n          BytesRef output2 = completion.output.output2;\n          if (sameSurfaceForm(utf8Key, output2)) {\n            results.add(getLookupResult(completion.output.output1, output2, spare));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (sameSurfaceForm(utf8Key, output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n      assert completions.isComplete;\n\n      for(Result<Pair<Long,BytesRef>> completion : completions) {\n\n        LookupResult result = getLookupResult(completion.output.output1, completion.output.output2, spare);\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,Set[BytesRef],boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,Set[BytesRef],boolean,int).mjava","sourceNew":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, Set<BytesRef> contexts, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n    if (contexts != null) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    if (fst == null) {\n      return Collections.emptyList();\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    for (int i = 0; i < key.length(); i++) {\n      if (key.charAt(i) == 0x1E) {\n        throw new IllegalArgumentException(\"lookup key cannot contain HOLE character U+001E; this character is reserved\");\n      }\n      if (key.charAt(i) == 0x1F) {\n        throw new IllegalArgumentException(\"lookup key cannot contain unit separator character U+001F; this character is reserved\");\n      }\n    }\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRefBuilder spare = new CharsRefBuilder();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader();\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<>();\n\n      final List<LookupResult> results = new ArrayList<>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(convertAutomaton(lookupAutomaton), fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n        assert completions.isComplete;\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(Result<Pair<Long,BytesRef>> completion : completions) {\n          BytesRef output2 = completion.output.output2;\n          if (sameSurfaceForm(utf8Key, output2)) {\n            results.add(getLookupResult(completion.output.output1, output2, spare));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (sameSurfaceForm(utf8Key, output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n      assert completions.isComplete;\n\n      for(Result<Pair<Long,BytesRef>> completion : completions) {\n\n        LookupResult result = getLookupResult(completion.output.output1, completion.output.output2, spare);\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","sourceOld":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, Set<BytesRef> contexts, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n    if (contexts != null) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    if (fst == null) {\n      return Collections.emptyList();\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    for (int i = 0; i < key.length(); i++) {\n      if (key.charAt(i) == 0x1E) {\n        throw new IllegalArgumentException(\"lookup key cannot contain HOLE character U+001E; this character is reserved\");\n      }\n      if (key.charAt(i) == 0x1F) {\n        throw new IllegalArgumentException(\"lookup key cannot contain unit separator character U+001F; this character is reserved\");\n      }\n    }\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader();\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<>();\n\n      final List<LookupResult> results = new ArrayList<>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(convertAutomaton(lookupAutomaton), fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n        assert completions.isComplete;\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(Result<Pair<Long,BytesRef>> completion : completions) {\n          BytesRef output2 = completion.output.output2;\n          if (sameSurfaceForm(utf8Key, output2)) {\n            results.add(getLookupResult(completion.output.output1, output2, spare));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (sameSurfaceForm(utf8Key, output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n      assert completions.isComplete;\n\n      for(Result<Pair<Long,BytesRef>> completion : completions) {\n\n        LookupResult result = getLookupResult(completion.output.output1, completion.output.output2, spare);\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","bugFix":["6ce825e9276493231308229152c48f755ce1a0a5"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54204c8a3ca26aeafd273139fc29baf70d0f6786","date":1564170395,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,Set[BytesRef],boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,Set[BytesRef],boolean,int).mjava","sourceNew":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, Set<BytesRef> contexts, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n    if (contexts != null) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    if (fst == null) {\n      return Collections.emptyList();\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    for (int i = 0; i < key.length(); i++) {\n      if (key.charAt(i) == 0x1E) {\n        throw new IllegalArgumentException(\"lookup key cannot contain HOLE character U+001E; this character is reserved\");\n      }\n      if (key.charAt(i) == 0x1F) {\n        throw new IllegalArgumentException(\"lookup key cannot contain unit separator character U+001F; this character is reserved\");\n      }\n    }\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRefBuilder spare = new CharsRefBuilder();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader();\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<>();\n\n      final List<LookupResult> results = new ArrayList<>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(convertAutomaton(lookupAutomaton), fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output()), false, path.input);\n          }\n        }\n\n        TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n        assert completions.isComplete;\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(Result<Pair<Long,BytesRef>> completion : completions) {\n          BytesRef output2 = completion.output.output2;\n          if (sameSurfaceForm(utf8Key, output2)) {\n            results.add(getLookupResult(completion.output.output1, output2, spare));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (sameSurfaceForm(utf8Key, output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n      assert completions.isComplete;\n\n      for(Result<Pair<Long,BytesRef>> completion : completions) {\n\n        LookupResult result = getLookupResult(completion.output.output1, completion.output.output2, spare);\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","sourceOld":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, Set<BytesRef> contexts, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n    if (contexts != null) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    if (fst == null) {\n      return Collections.emptyList();\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    for (int i = 0; i < key.length(); i++) {\n      if (key.charAt(i) == 0x1E) {\n        throw new IllegalArgumentException(\"lookup key cannot contain HOLE character U+001E; this character is reserved\");\n      }\n      if (key.charAt(i) == 0x1F) {\n        throw new IllegalArgumentException(\"lookup key cannot contain unit separator character U+001F; this character is reserved\");\n      }\n    }\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRefBuilder spare = new CharsRefBuilder();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader();\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<>();\n\n      final List<LookupResult> results = new ArrayList<>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(convertAutomaton(lookupAutomaton), fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n        assert completions.isComplete;\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(Result<Pair<Long,BytesRef>> completion : completions) {\n          BytesRef output2 = completion.output.output2;\n          if (sameSurfaceForm(utf8Key, output2)) {\n            results.add(getLookupResult(completion.output.output1, output2, spare));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (sameSurfaceForm(utf8Key, output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n      assert completions.isComplete;\n\n      for(Result<Pair<Long,BytesRef>> completion : completions) {\n\n        LookupResult result = getLookupResult(completion.output.output1, completion.output.output2, spare);\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8061ddd97f3352007d927dae445884a6f3d857b","date":1564988276,"type":3,"author":"Atri Sharma","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,Set[BytesRef],boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,Set[BytesRef],boolean,int).mjava","sourceNew":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, Set<BytesRef> contexts, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n    if (contexts != null) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    if (fst == null) {\n      return Collections.emptyList();\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    for (int i = 0; i < key.length(); i++) {\n      if (key.charAt(i) == 0x1E) {\n        throw new IllegalArgumentException(\"lookup key cannot contain HOLE character U+001E; this character is reserved\");\n      }\n      if (key.charAt(i) == 0x1F) {\n        throw new IllegalArgumentException(\"lookup key cannot contain unit separator character U+001F; this character is reserved\");\n      }\n    }\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRefBuilder spare = new CharsRefBuilder();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader();\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<>();\n\n      final List<LookupResult> results = new ArrayList<>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(convertAutomaton(lookupAutomaton), fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output()), false, path.input);\n          }\n        }\n\n        TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n        assert completions.isComplete;\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(Result<Pair<Long,BytesRef>> completion : completions) {\n          BytesRef output2 = completion.output.output2;\n          if (sameSurfaceForm(utf8Key, output2)) {\n            results.add(getLookupResult(completion.output.output1, output2, spare));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (sameSurfaceForm(utf8Key, output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n      assert completions.isComplete;\n\n      for(Result<Pair<Long,BytesRef>> completion : completions) {\n\n        LookupResult result = getLookupResult(completion.output.output1, completion.output.output2, spare);\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","sourceOld":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, Set<BytesRef> contexts, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n    if (contexts != null) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    if (fst == null) {\n      return Collections.emptyList();\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    for (int i = 0; i < key.length(); i++) {\n      if (key.charAt(i) == 0x1E) {\n        throw new IllegalArgumentException(\"lookup key cannot contain HOLE character U+001E; this character is reserved\");\n      }\n      if (key.charAt(i) == 0x1F) {\n        throw new IllegalArgumentException(\"lookup key cannot contain unit separator character U+001F; this character is reserved\");\n      }\n    }\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRefBuilder spare = new CharsRefBuilder();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader();\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<>();\n\n      final List<LookupResult> results = new ArrayList<>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(convertAutomaton(lookupAutomaton), fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n        assert completions.isComplete;\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(Result<Pair<Long,BytesRef>> completion : completions) {\n          BytesRef output2 = completion.output.output2;\n          if (sameSurfaceForm(utf8Key, output2)) {\n            results.add(getLookupResult(completion.output.output1, output2, spare));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (sameSurfaceForm(utf8Key, output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n      assert completions.isComplete;\n\n      for(Result<Pair<Long,BytesRef>> completion : completions) {\n\n        LookupResult result = getLookupResult(completion.output.output1, completion.output.output2, spare);\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54204c8a3ca26aeafd273139fc29baf70d0f6786":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"75ac8571c2d82c574e446c3729251b994c69a55c":["58d0345a28bb6b4be59c38e6a77e2cc0e615ee4b"],"58d0345a28bb6b4be59c38e6a77e2cc0e615ee4b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["75ac8571c2d82c574e446c3729251b994c69a55c"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["5c84485629d80d203608e8975a1139de9933cc38"],"5c84485629d80d203608e8975a1139de9933cc38":["58d0345a28bb6b4be59c38e6a77e2cc0e615ee4b","4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"f8061ddd97f3352007d927dae445884a6f3d857b":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","54204c8a3ca26aeafd273139fc29baf70d0f6786"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["54204c8a3ca26aeafd273139fc29baf70d0f6786"]},"commit2Childs":{"54204c8a3ca26aeafd273139fc29baf70d0f6786":["f8061ddd97f3352007d927dae445884a6f3d857b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"75ac8571c2d82c574e446c3729251b994c69a55c":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"58d0345a28bb6b4be59c38e6a77e2cc0e615ee4b":["75ac8571c2d82c574e446c3729251b994c69a55c","5c84485629d80d203608e8975a1139de9933cc38"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["58d0345a28bb6b4be59c38e6a77e2cc0e615ee4b"],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["5c84485629d80d203608e8975a1139de9933cc38"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["54204c8a3ca26aeafd273139fc29baf70d0f6786","f8061ddd97f3352007d927dae445884a6f3d857b"],"5c84485629d80d203608e8975a1139de9933cc38":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"f8061ddd97f3352007d927dae445884a6f3d857b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["f8061ddd97f3352007d927dae445884a6f3d857b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}