{"path":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testWaitForElapsed().mjava","commits":[{"id":"c0b90ab8b228b1f7a05d5ddfbe879ce962d8964a","date":1524514741,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testWaitForElapsed().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testWaitForElapsed() throws Exception {\n    SolrResourceLoader loader = cluster.getJettySolrRunner(0).getCoreContainer().getResourceLoader();\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    SolrZkClient zkClient = solrClient.getZkStateReader().getZkClient();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), solrClient) {\n      @Override\n      public NodeStateProvider getNodeStateProvider() {\n        return new SolrClientNodeStateProvider(solrClient) {\n          @Override\n          public Map<String, Object> getNodeValues(String node, Collection<String> tags) {\n            Map<String, Object> values = super.getNodeValues(node, tags);\n            values.keySet().forEach(k -> {\n              values.replace(k, mockRate.get());\n            });\n            return values;\n          }\n        };\n      }\n    };\n    TimeSource timeSource = cloudManager.getTimeSource();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, 1.0, 0.1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // set mock rates\n      mockRate.set(2.0);\n      TimeOut timeOut = new TimeOut(waitForSeconds + 2, TimeUnit.SECONDS, timeSource);\n      // simulate ScheduledTriggers\n      while (!timeOut.hasTimedOut()) {\n        trigger.run();\n        timeSource.sleep(1000);\n      }\n      // violation persisted longer than waitFor - there should be events\n      assertTrue(events.toString(), events.size() > 0);\n      TriggerEvent event = events.get(0);\n      assertEquals(event.toString(), TriggerEventType.SEARCHRATE, event.eventType);\n      Map<String, Object> hotNodes, hotCollections, hotShards;\n      List<ReplicaInfo> hotReplicas;\n      hotNodes = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_NODES);\n      hotCollections = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_COLLECTIONS);\n      hotShards = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_SHARDS);\n      hotReplicas = (List<ReplicaInfo>)event.properties.get(SearchRateTrigger.HOT_REPLICAS);\n      assertFalse(\"no hot nodes?\", hotNodes.isEmpty());\n      assertFalse(\"no hot collections?\", hotCollections.isEmpty());\n      assertFalse(\"no hot shards?\", hotShards.isEmpty());\n      assertFalse(\"no hot replicas?\", hotReplicas.isEmpty());\n    }\n\n    mockRate.set(0.0);\n    events.clear();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger2\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      mockRate.set(2.0);\n      trigger.run();\n      // waitFor not elapsed\n      assertTrue(events.toString(), events.isEmpty());\n      Thread.sleep(1000);\n      trigger.run();\n      assertTrue(events.toString(), events.isEmpty());\n      Thread.sleep(1000);\n      mockRate.set(0.0);\n      trigger.run();\n      Thread.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds - 2, TimeUnit.SECONDS));\n      trigger.run();\n\n      // violations persisted shorter than waitFor - there should be no events\n      assertTrue(events.toString(), events.isEmpty());\n\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["042b92cf48996255bedb0c3c4bf772d7e06e4dea","bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"042b92cf48996255bedb0c3c4bf772d7e06e4dea","date":1534272102,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testWaitForElapsed().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testWaitForElapsed().mjava","sourceNew":"  @Test\n  public void testWaitForElapsed() throws Exception {\n    SolrResourceLoader loader = cluster.getJettySolrRunner(0).getCoreContainer().getResourceLoader();\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    SolrZkClient zkClient = solrClient.getZkStateReader().getZkClient();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), solrClient) {\n      @Override\n      public NodeStateProvider getNodeStateProvider() {\n        return new SolrClientNodeStateProvider(solrClient) {\n          @Override\n          public Map<String, Object> getNodeValues(String node, Collection<String> tags) {\n            Map<String, Object> values = super.getNodeValues(node, tags);\n            values.keySet().forEach(k -> {\n              values.replace(k, mockRate.get());\n            });\n            return values;\n          }\n        };\n      }\n    };\n    TimeSource timeSource = cloudManager.getTimeSource();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, 1.0, 0.1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // set mock rates\n      mockRate.set(2.0);\n      TimeOut timeOut = new TimeOut(waitForSeconds + 2, TimeUnit.SECONDS, timeSource);\n      // simulate ScheduledTriggers\n      while (!timeOut.hasTimedOut()) {\n        trigger.run();\n        timeSource.sleep(1000);\n      }\n      // violation persisted longer than waitFor - there should be events\n      assertTrue(events.toString(), events.size() > 0);\n      TriggerEvent event = events.get(0);\n      assertEquals(event.toString(), TriggerEventType.SEARCHRATE, event.eventType);\n      Map<String, Object> hotNodes, hotCollections, hotShards;\n      List<ReplicaInfo> hotReplicas;\n      hotNodes = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_NODES);\n      hotCollections = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_COLLECTIONS);\n      hotShards = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_SHARDS);\n      hotReplicas = (List<ReplicaInfo>)event.properties.get(SearchRateTrigger.HOT_REPLICAS);\n      assertTrue(\"no hot nodes?\", hotNodes.isEmpty());\n      assertFalse(\"no hot collections?\", hotCollections.isEmpty());\n      assertFalse(\"no hot shards?\", hotShards.isEmpty());\n      assertFalse(\"no hot replicas?\", hotReplicas.isEmpty());\n    }\n\n    mockRate.set(0.0);\n    events.clear();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger2\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      mockRate.set(2.0);\n      trigger.run();\n      // waitFor not elapsed\n      assertTrue(events.toString(), events.isEmpty());\n      Thread.sleep(1000);\n      trigger.run();\n      assertTrue(events.toString(), events.isEmpty());\n      Thread.sleep(1000);\n      mockRate.set(0.0);\n      trigger.run();\n      Thread.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds - 2, TimeUnit.SECONDS));\n      trigger.run();\n\n      // violations persisted shorter than waitFor - there should be no events\n      assertTrue(events.toString(), events.isEmpty());\n\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testWaitForElapsed() throws Exception {\n    SolrResourceLoader loader = cluster.getJettySolrRunner(0).getCoreContainer().getResourceLoader();\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    SolrZkClient zkClient = solrClient.getZkStateReader().getZkClient();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), solrClient) {\n      @Override\n      public NodeStateProvider getNodeStateProvider() {\n        return new SolrClientNodeStateProvider(solrClient) {\n          @Override\n          public Map<String, Object> getNodeValues(String node, Collection<String> tags) {\n            Map<String, Object> values = super.getNodeValues(node, tags);\n            values.keySet().forEach(k -> {\n              values.replace(k, mockRate.get());\n            });\n            return values;\n          }\n        };\n      }\n    };\n    TimeSource timeSource = cloudManager.getTimeSource();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, 1.0, 0.1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // set mock rates\n      mockRate.set(2.0);\n      TimeOut timeOut = new TimeOut(waitForSeconds + 2, TimeUnit.SECONDS, timeSource);\n      // simulate ScheduledTriggers\n      while (!timeOut.hasTimedOut()) {\n        trigger.run();\n        timeSource.sleep(1000);\n      }\n      // violation persisted longer than waitFor - there should be events\n      assertTrue(events.toString(), events.size() > 0);\n      TriggerEvent event = events.get(0);\n      assertEquals(event.toString(), TriggerEventType.SEARCHRATE, event.eventType);\n      Map<String, Object> hotNodes, hotCollections, hotShards;\n      List<ReplicaInfo> hotReplicas;\n      hotNodes = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_NODES);\n      hotCollections = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_COLLECTIONS);\n      hotShards = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_SHARDS);\n      hotReplicas = (List<ReplicaInfo>)event.properties.get(SearchRateTrigger.HOT_REPLICAS);\n      assertFalse(\"no hot nodes?\", hotNodes.isEmpty());\n      assertFalse(\"no hot collections?\", hotCollections.isEmpty());\n      assertFalse(\"no hot shards?\", hotShards.isEmpty());\n      assertFalse(\"no hot replicas?\", hotReplicas.isEmpty());\n    }\n\n    mockRate.set(0.0);\n    events.clear();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger2\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      mockRate.set(2.0);\n      trigger.run();\n      // waitFor not elapsed\n      assertTrue(events.toString(), events.isEmpty());\n      Thread.sleep(1000);\n      trigger.run();\n      assertTrue(events.toString(), events.isEmpty());\n      Thread.sleep(1000);\n      mockRate.set(0.0);\n      trigger.run();\n      Thread.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds - 2, TimeUnit.SECONDS));\n      trigger.run();\n\n      // violations persisted shorter than waitFor - there should be no events\n      assertTrue(events.toString(), events.isEmpty());\n\n    }\n  }\n\n","bugFix":["c0b90ab8b228b1f7a05d5ddfbe879ce962d8964a"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testWaitForElapsed().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testWaitForElapsed().mjava","sourceNew":"  @Test\n  public void testWaitForElapsed() throws Exception {\n    SolrResourceLoader loader = cluster.getJettySolrRunner(0).getCoreContainer().getResourceLoader();\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    SolrZkClient zkClient = solrClient.getZkStateReader().getZkClient();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), solrClient) {\n      @Override\n      public NodeStateProvider getNodeStateProvider() {\n        return new SolrClientNodeStateProvider(solrClient) {\n          @Override\n          public Map<String, Object> getNodeValues(String node, Collection<String> tags) {\n            Map<String, Object> values = super.getNodeValues(node, tags);\n            values.keySet().forEach(k -> {\n              values.replace(k, mockRate.get());\n            });\n            return values;\n          }\n        };\n      }\n    };\n    TimeSource timeSource = cloudManager.getTimeSource();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 4));\n\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, 1.0, 0.1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // set mock rates\n      mockRate.set(2.0);\n      TimeOut timeOut = new TimeOut(waitForSeconds + 2, TimeUnit.SECONDS, timeSource);\n      // simulate ScheduledTriggers\n      while (!timeOut.hasTimedOut()) {\n        trigger.run();\n        timeSource.sleep(1000);\n      }\n      // violation persisted longer than waitFor - there should be events\n      assertTrue(events.toString(), events.size() > 0);\n      TriggerEvent event = events.get(0);\n      assertEquals(event.toString(), TriggerEventType.SEARCHRATE, event.eventType);\n      Map<String, Object> hotNodes, hotCollections, hotShards;\n      List<ReplicaInfo> hotReplicas;\n      hotNodes = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_NODES);\n      hotCollections = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_COLLECTIONS);\n      hotShards = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_SHARDS);\n      hotReplicas = (List<ReplicaInfo>)event.properties.get(SearchRateTrigger.HOT_REPLICAS);\n      assertTrue(\"no hot nodes?\", hotNodes.isEmpty());\n      assertFalse(\"no hot collections?\", hotCollections.isEmpty());\n      assertFalse(\"no hot shards?\", hotShards.isEmpty());\n      assertFalse(\"no hot replicas?\", hotReplicas.isEmpty());\n    }\n\n    mockRate.set(0.0);\n    events.clear();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger2\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      mockRate.set(2.0);\n      trigger.run();\n      // waitFor not elapsed\n      assertTrue(events.toString(), events.isEmpty());\n      Thread.sleep(1000);\n      trigger.run();\n      assertTrue(events.toString(), events.isEmpty());\n      Thread.sleep(1000);\n      mockRate.set(0.0);\n      trigger.run();\n      Thread.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds - 2, TimeUnit.SECONDS));\n      trigger.run();\n\n      // violations persisted shorter than waitFor - there should be no events\n      assertTrue(events.toString(), events.isEmpty());\n\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testWaitForElapsed() throws Exception {\n    SolrResourceLoader loader = cluster.getJettySolrRunner(0).getCoreContainer().getResourceLoader();\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    SolrZkClient zkClient = solrClient.getZkStateReader().getZkClient();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), solrClient) {\n      @Override\n      public NodeStateProvider getNodeStateProvider() {\n        return new SolrClientNodeStateProvider(solrClient) {\n          @Override\n          public Map<String, Object> getNodeValues(String node, Collection<String> tags) {\n            Map<String, Object> values = super.getNodeValues(node, tags);\n            values.keySet().forEach(k -> {\n              values.replace(k, mockRate.get());\n            });\n            return values;\n          }\n        };\n      }\n    };\n    TimeSource timeSource = cloudManager.getTimeSource();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 2));\n\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, 1.0, 0.1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // set mock rates\n      mockRate.set(2.0);\n      TimeOut timeOut = new TimeOut(waitForSeconds + 2, TimeUnit.SECONDS, timeSource);\n      // simulate ScheduledTriggers\n      while (!timeOut.hasTimedOut()) {\n        trigger.run();\n        timeSource.sleep(1000);\n      }\n      // violation persisted longer than waitFor - there should be events\n      assertTrue(events.toString(), events.size() > 0);\n      TriggerEvent event = events.get(0);\n      assertEquals(event.toString(), TriggerEventType.SEARCHRATE, event.eventType);\n      Map<String, Object> hotNodes, hotCollections, hotShards;\n      List<ReplicaInfo> hotReplicas;\n      hotNodes = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_NODES);\n      hotCollections = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_COLLECTIONS);\n      hotShards = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_SHARDS);\n      hotReplicas = (List<ReplicaInfo>)event.properties.get(SearchRateTrigger.HOT_REPLICAS);\n      assertTrue(\"no hot nodes?\", hotNodes.isEmpty());\n      assertFalse(\"no hot collections?\", hotCollections.isEmpty());\n      assertFalse(\"no hot shards?\", hotShards.isEmpty());\n      assertFalse(\"no hot replicas?\", hotReplicas.isEmpty());\n    }\n\n    mockRate.set(0.0);\n    events.clear();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger2\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      mockRate.set(2.0);\n      trigger.run();\n      // waitFor not elapsed\n      assertTrue(events.toString(), events.isEmpty());\n      Thread.sleep(1000);\n      trigger.run();\n      assertTrue(events.toString(), events.isEmpty());\n      Thread.sleep(1000);\n      mockRate.set(0.0);\n      trigger.run();\n      Thread.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds - 2, TimeUnit.SECONDS));\n      trigger.run();\n\n      // violations persisted shorter than waitFor - there should be no events\n      assertTrue(events.toString(), events.isEmpty());\n\n    }\n  }\n\n","bugFix":["c0b90ab8b228b1f7a05d5ddfbe879ce962d8964a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5","date":1556572478,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testWaitForElapsed().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testWaitForElapsed().mjava","sourceNew":"  @Test\n  public void testWaitForElapsed() throws Exception {\n    SolrResourceLoader loader = cluster.getJettySolrRunner(0).getCoreContainer().getResourceLoader();\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    SolrZkClient zkClient = solrClient.getZkStateReader().getZkClient();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), solrClient) {\n      @Override\n      public NodeStateProvider getNodeStateProvider() {\n        return new SolrClientNodeStateProvider(solrClient) {\n          @Override\n          public Map<String, Object> getNodeValues(String node, Collection<String> tags) {\n            Map<String, Object> values = super.getNodeValues(node, tags);\n            values.keySet().forEach(k -> {\n              values.replace(k, mockRate.get());\n            });\n            return values;\n          }\n        };\n      }\n    };\n    TimeSource timeSource = cloudManager.getTimeSource();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n    CloudUtil.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 4));\n\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, 1.0, 0.1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // set mock rates\n      mockRate.set(2.0);\n      TimeOut timeOut = new TimeOut(waitForSeconds + 2, TimeUnit.SECONDS, timeSource);\n      // simulate ScheduledTriggers\n      while (!timeOut.hasTimedOut()) {\n        trigger.run();\n        timeSource.sleep(1000);\n      }\n      // violation persisted longer than waitFor - there should be events\n      assertTrue(events.toString(), events.size() > 0);\n      TriggerEvent event = events.get(0);\n      assertEquals(event.toString(), TriggerEventType.SEARCHRATE, event.eventType);\n      Map<String, Object> hotNodes, hotCollections, hotShards;\n      List<ReplicaInfo> hotReplicas;\n      hotNodes = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_NODES);\n      hotCollections = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_COLLECTIONS);\n      hotShards = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_SHARDS);\n      hotReplicas = (List<ReplicaInfo>)event.properties.get(SearchRateTrigger.HOT_REPLICAS);\n      assertTrue(\"no hot nodes?\", hotNodes.isEmpty());\n      assertFalse(\"no hot collections?\", hotCollections.isEmpty());\n      assertFalse(\"no hot shards?\", hotShards.isEmpty());\n      assertFalse(\"no hot replicas?\", hotReplicas.isEmpty());\n    }\n\n    mockRate.set(0.0);\n    events.clear();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger2\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      mockRate.set(2.0);\n      trigger.run();\n      // waitFor not elapsed\n      assertTrue(events.toString(), events.isEmpty());\n      Thread.sleep(1000);\n      trigger.run();\n      assertTrue(events.toString(), events.isEmpty());\n      Thread.sleep(1000);\n      mockRate.set(0.0);\n      trigger.run();\n      Thread.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds - 2, TimeUnit.SECONDS));\n      trigger.run();\n\n      // violations persisted shorter than waitFor - there should be no events\n      assertTrue(events.toString(), events.isEmpty());\n\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testWaitForElapsed() throws Exception {\n    SolrResourceLoader loader = cluster.getJettySolrRunner(0).getCoreContainer().getResourceLoader();\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    SolrZkClient zkClient = solrClient.getZkStateReader().getZkClient();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), solrClient) {\n      @Override\n      public NodeStateProvider getNodeStateProvider() {\n        return new SolrClientNodeStateProvider(solrClient) {\n          @Override\n          public Map<String, Object> getNodeValues(String node, Collection<String> tags) {\n            Map<String, Object> values = super.getNodeValues(node, tags);\n            values.keySet().forEach(k -> {\n              values.replace(k, mockRate.get());\n            });\n            return values;\n          }\n        };\n      }\n    };\n    TimeSource timeSource = cloudManager.getTimeSource();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 4));\n\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, 1.0, 0.1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // set mock rates\n      mockRate.set(2.0);\n      TimeOut timeOut = new TimeOut(waitForSeconds + 2, TimeUnit.SECONDS, timeSource);\n      // simulate ScheduledTriggers\n      while (!timeOut.hasTimedOut()) {\n        trigger.run();\n        timeSource.sleep(1000);\n      }\n      // violation persisted longer than waitFor - there should be events\n      assertTrue(events.toString(), events.size() > 0);\n      TriggerEvent event = events.get(0);\n      assertEquals(event.toString(), TriggerEventType.SEARCHRATE, event.eventType);\n      Map<String, Object> hotNodes, hotCollections, hotShards;\n      List<ReplicaInfo> hotReplicas;\n      hotNodes = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_NODES);\n      hotCollections = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_COLLECTIONS);\n      hotShards = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_SHARDS);\n      hotReplicas = (List<ReplicaInfo>)event.properties.get(SearchRateTrigger.HOT_REPLICAS);\n      assertTrue(\"no hot nodes?\", hotNodes.isEmpty());\n      assertFalse(\"no hot collections?\", hotCollections.isEmpty());\n      assertFalse(\"no hot shards?\", hotShards.isEmpty());\n      assertFalse(\"no hot replicas?\", hotReplicas.isEmpty());\n    }\n\n    mockRate.set(0.0);\n    events.clear();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger2\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      mockRate.set(2.0);\n      trigger.run();\n      // waitFor not elapsed\n      assertTrue(events.toString(), events.isEmpty());\n      Thread.sleep(1000);\n      trigger.run();\n      assertTrue(events.toString(), events.isEmpty());\n      Thread.sleep(1000);\n      mockRate.set(0.0);\n      trigger.run();\n      Thread.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds - 2, TimeUnit.SECONDS));\n      trigger.run();\n\n      // violations persisted shorter than waitFor - there should be no events\n      assertTrue(events.toString(), events.isEmpty());\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa2585c33d5d66a1c837c312221eb55ddb3c4300","date":1592493170,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testWaitForElapsed().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testWaitForElapsed().mjava","sourceNew":"  @Test\n  @SuppressWarnings({\"unchecked\"})\n  public void testWaitForElapsed() throws Exception {\n    SolrResourceLoader loader = cluster.getJettySolrRunner(0).getCoreContainer().getResourceLoader();\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    SolrZkClient zkClient = solrClient.getZkStateReader().getZkClient();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), solrClient) {\n      @Override\n      public NodeStateProvider getNodeStateProvider() {\n        return new SolrClientNodeStateProvider(solrClient) {\n          @Override\n          public Map<String, Object> getNodeValues(String node, Collection<String> tags) {\n            Map<String, Object> values = super.getNodeValues(node, tags);\n            values.keySet().forEach(k -> {\n              values.replace(k, mockRate.get());\n            });\n            return values;\n          }\n        };\n      }\n    };\n    TimeSource timeSource = cloudManager.getTimeSource();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n    CloudUtil.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 4));\n\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, 1.0, 0.1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // set mock rates\n      mockRate.set(2.0);\n      TimeOut timeOut = new TimeOut(waitForSeconds + 2, TimeUnit.SECONDS, timeSource);\n      // simulate ScheduledTriggers\n      while (!timeOut.hasTimedOut()) {\n        trigger.run();\n        timeSource.sleep(1000);\n      }\n      // violation persisted longer than waitFor - there should be events\n      assertTrue(events.toString(), events.size() > 0);\n      TriggerEvent event = events.get(0);\n      assertEquals(event.toString(), TriggerEventType.SEARCHRATE, event.eventType);\n      Map<String, Object> hotNodes, hotCollections, hotShards;\n      List<ReplicaInfo> hotReplicas;\n      hotNodes = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_NODES);\n      hotCollections = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_COLLECTIONS);\n      hotShards = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_SHARDS);\n      hotReplicas = (List<ReplicaInfo>)event.properties.get(SearchRateTrigger.HOT_REPLICAS);\n      assertTrue(\"no hot nodes?\", hotNodes.isEmpty());\n      assertFalse(\"no hot collections?\", hotCollections.isEmpty());\n      assertFalse(\"no hot shards?\", hotShards.isEmpty());\n      assertFalse(\"no hot replicas?\", hotReplicas.isEmpty());\n    }\n\n    mockRate.set(0.0);\n    events.clear();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger2\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      mockRate.set(2.0);\n      trigger.run();\n      // waitFor not elapsed\n      assertTrue(events.toString(), events.isEmpty());\n      Thread.sleep(1000);\n      trigger.run();\n      assertTrue(events.toString(), events.isEmpty());\n      Thread.sleep(1000);\n      mockRate.set(0.0);\n      trigger.run();\n      Thread.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds - 2, TimeUnit.SECONDS));\n      trigger.run();\n\n      // violations persisted shorter than waitFor - there should be no events\n      assertTrue(events.toString(), events.isEmpty());\n\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testWaitForElapsed() throws Exception {\n    SolrResourceLoader loader = cluster.getJettySolrRunner(0).getCoreContainer().getResourceLoader();\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    SolrZkClient zkClient = solrClient.getZkStateReader().getZkClient();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), solrClient) {\n      @Override\n      public NodeStateProvider getNodeStateProvider() {\n        return new SolrClientNodeStateProvider(solrClient) {\n          @Override\n          public Map<String, Object> getNodeValues(String node, Collection<String> tags) {\n            Map<String, Object> values = super.getNodeValues(node, tags);\n            values.keySet().forEach(k -> {\n              values.replace(k, mockRate.get());\n            });\n            return values;\n          }\n        };\n      }\n    };\n    TimeSource timeSource = cloudManager.getTimeSource();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n    CloudUtil.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 4));\n\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, 1.0, 0.1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // set mock rates\n      mockRate.set(2.0);\n      TimeOut timeOut = new TimeOut(waitForSeconds + 2, TimeUnit.SECONDS, timeSource);\n      // simulate ScheduledTriggers\n      while (!timeOut.hasTimedOut()) {\n        trigger.run();\n        timeSource.sleep(1000);\n      }\n      // violation persisted longer than waitFor - there should be events\n      assertTrue(events.toString(), events.size() > 0);\n      TriggerEvent event = events.get(0);\n      assertEquals(event.toString(), TriggerEventType.SEARCHRATE, event.eventType);\n      Map<String, Object> hotNodes, hotCollections, hotShards;\n      List<ReplicaInfo> hotReplicas;\n      hotNodes = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_NODES);\n      hotCollections = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_COLLECTIONS);\n      hotShards = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_SHARDS);\n      hotReplicas = (List<ReplicaInfo>)event.properties.get(SearchRateTrigger.HOT_REPLICAS);\n      assertTrue(\"no hot nodes?\", hotNodes.isEmpty());\n      assertFalse(\"no hot collections?\", hotCollections.isEmpty());\n      assertFalse(\"no hot shards?\", hotShards.isEmpty());\n      assertFalse(\"no hot replicas?\", hotReplicas.isEmpty());\n    }\n\n    mockRate.set(0.0);\n    events.clear();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger2\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      mockRate.set(2.0);\n      trigger.run();\n      // waitFor not elapsed\n      assertTrue(events.toString(), events.isEmpty());\n      Thread.sleep(1000);\n      trigger.run();\n      assertTrue(events.toString(), events.isEmpty());\n      Thread.sleep(1000);\n      mockRate.set(0.0);\n      trigger.run();\n      Thread.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds - 2, TimeUnit.SECONDS));\n      trigger.run();\n\n      // violations persisted shorter than waitFor - there should be no events\n      assertTrue(events.toString(), events.isEmpty());\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testWaitForElapsed().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testWaitForElapsed().mjava","sourceNew":"  @Test\n  @SuppressWarnings({\"unchecked\"})\n  public void testWaitForElapsed() throws Exception {\n    SolrResourceLoader loader = cluster.getJettySolrRunner(0).getCoreContainer().getResourceLoader();\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    SolrZkClient zkClient = solrClient.getZkStateReader().getZkClient();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), solrClient) {\n      @Override\n      public NodeStateProvider getNodeStateProvider() {\n        return new SolrClientNodeStateProvider(solrClient) {\n          @Override\n          public Map<String, Object> getNodeValues(String node, Collection<String> tags) {\n            Map<String, Object> values = super.getNodeValues(node, tags);\n            values.keySet().forEach(k -> {\n              values.replace(k, mockRate.get());\n            });\n            return values;\n          }\n        };\n      }\n    };\n    TimeSource timeSource = cloudManager.getTimeSource();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    create.process(solrClient);\n    CloudUtil.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 4));\n\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, 1.0, 0.1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // set mock rates\n      mockRate.set(2.0);\n      TimeOut timeOut = new TimeOut(waitForSeconds + 2, TimeUnit.SECONDS, timeSource);\n      // simulate ScheduledTriggers\n      while (!timeOut.hasTimedOut()) {\n        trigger.run();\n        timeSource.sleep(1000);\n      }\n      // violation persisted longer than waitFor - there should be events\n      assertTrue(events.toString(), events.size() > 0);\n      TriggerEvent event = events.get(0);\n      assertEquals(event.toString(), TriggerEventType.SEARCHRATE, event.eventType);\n      Map<String, Object> hotNodes, hotCollections, hotShards;\n      List<ReplicaInfo> hotReplicas;\n      hotNodes = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_NODES);\n      hotCollections = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_COLLECTIONS);\n      hotShards = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_SHARDS);\n      hotReplicas = (List<ReplicaInfo>)event.properties.get(SearchRateTrigger.HOT_REPLICAS);\n      assertTrue(\"no hot nodes?\", hotNodes.isEmpty());\n      assertFalse(\"no hot collections?\", hotCollections.isEmpty());\n      assertFalse(\"no hot shards?\", hotShards.isEmpty());\n      assertFalse(\"no hot replicas?\", hotReplicas.isEmpty());\n    }\n\n    mockRate.set(0.0);\n    events.clear();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger2\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      mockRate.set(2.0);\n      trigger.run();\n      // waitFor not elapsed\n      assertTrue(events.toString(), events.isEmpty());\n      Thread.sleep(1000);\n      trigger.run();\n      assertTrue(events.toString(), events.isEmpty());\n      Thread.sleep(1000);\n      mockRate.set(0.0);\n      trigger.run();\n      Thread.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds - 2, TimeUnit.SECONDS));\n      trigger.run();\n\n      // violations persisted shorter than waitFor - there should be no events\n      assertTrue(events.toString(), events.isEmpty());\n\n    }\n  }\n\n","sourceOld":"  @Test\n  @SuppressWarnings({\"unchecked\"})\n  public void testWaitForElapsed() throws Exception {\n    SolrResourceLoader loader = cluster.getJettySolrRunner(0).getCoreContainer().getResourceLoader();\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    SolrZkClient zkClient = solrClient.getZkStateReader().getZkClient();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), solrClient) {\n      @Override\n      public NodeStateProvider getNodeStateProvider() {\n        return new SolrClientNodeStateProvider(solrClient) {\n          @Override\n          public Map<String, Object> getNodeValues(String node, Collection<String> tags) {\n            Map<String, Object> values = super.getNodeValues(node, tags);\n            values.keySet().forEach(k -> {\n              values.replace(k, mockRate.get());\n            });\n            return values;\n          }\n        };\n      }\n    };\n    TimeSource timeSource = cloudManager.getTimeSource();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n    CloudUtil.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 4));\n\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, 1.0, 0.1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // set mock rates\n      mockRate.set(2.0);\n      TimeOut timeOut = new TimeOut(waitForSeconds + 2, TimeUnit.SECONDS, timeSource);\n      // simulate ScheduledTriggers\n      while (!timeOut.hasTimedOut()) {\n        trigger.run();\n        timeSource.sleep(1000);\n      }\n      // violation persisted longer than waitFor - there should be events\n      assertTrue(events.toString(), events.size() > 0);\n      TriggerEvent event = events.get(0);\n      assertEquals(event.toString(), TriggerEventType.SEARCHRATE, event.eventType);\n      Map<String, Object> hotNodes, hotCollections, hotShards;\n      List<ReplicaInfo> hotReplicas;\n      hotNodes = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_NODES);\n      hotCollections = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_COLLECTIONS);\n      hotShards = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_SHARDS);\n      hotReplicas = (List<ReplicaInfo>)event.properties.get(SearchRateTrigger.HOT_REPLICAS);\n      assertTrue(\"no hot nodes?\", hotNodes.isEmpty());\n      assertFalse(\"no hot collections?\", hotCollections.isEmpty());\n      assertFalse(\"no hot shards?\", hotShards.isEmpty());\n      assertFalse(\"no hot replicas?\", hotReplicas.isEmpty());\n    }\n\n    mockRate.set(0.0);\n    events.clear();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger2\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      mockRate.set(2.0);\n      trigger.run();\n      // waitFor not elapsed\n      assertTrue(events.toString(), events.isEmpty());\n      Thread.sleep(1000);\n      trigger.run();\n      assertTrue(events.toString(), events.isEmpty());\n      Thread.sleep(1000);\n      mockRate.set(0.0);\n      trigger.run();\n      Thread.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds - 2, TimeUnit.SECONDS));\n      trigger.run();\n\n      // violations persisted shorter than waitFor - there should be no events\n      assertTrue(events.toString(), events.isEmpty());\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd","date":1594731683,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testWaitForElapsed().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testWaitForElapsed().mjava","sourceNew":"  @Test\n  @SuppressWarnings({\"unchecked\"})\n  public void testWaitForElapsed() throws Exception {\n    SolrResourceLoader loader = cluster.getJettySolrRunner(0).getCoreContainer().getResourceLoader();\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    SolrZkClient zkClient = solrClient.getZkStateReader().getZkClient();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), solrClient) {\n      @Override\n      public NodeStateProvider getNodeStateProvider() {\n        return new SolrClientNodeStateProvider(solrClient) {\n          @Override\n          public Map<String, Object> getNodeValues(String node, Collection<String> tags) {\n            Map<String, Object> values = super.getNodeValues(node, tags);\n            values.keySet().forEach(k -> {\n              values.replace(k, mockRate.get());\n            });\n            return values;\n          }\n        };\n      }\n    };\n    TimeSource timeSource = cloudManager.getTimeSource();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    create.process(solrClient);\n    CloudUtil.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 4));\n\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, 1.0, 0.1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // set mock rates\n      mockRate.set(2.0);\n      TimeOut timeOut = new TimeOut(waitForSeconds + 2, TimeUnit.SECONDS, timeSource);\n      // simulate ScheduledTriggers\n      while (!timeOut.hasTimedOut()) {\n        trigger.run();\n        timeSource.sleep(1000);\n      }\n      // violation persisted longer than waitFor - there should be events\n      assertTrue(events.toString(), events.size() > 0);\n      TriggerEvent event = events.get(0);\n      assertEquals(event.toString(), TriggerEventType.SEARCHRATE, event.eventType);\n      Map<String, Object> hotNodes, hotCollections, hotShards;\n      List<Replica> hotReplicas;\n      hotNodes = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_NODES);\n      hotCollections = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_COLLECTIONS);\n      hotShards = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_SHARDS);\n      hotReplicas = (List<Replica>)event.properties.get(SearchRateTrigger.HOT_REPLICAS);\n      assertTrue(\"no hot nodes?\", hotNodes.isEmpty());\n      assertFalse(\"no hot collections?\", hotCollections.isEmpty());\n      assertFalse(\"no hot shards?\", hotShards.isEmpty());\n      assertFalse(\"no hot replicas?\", hotReplicas.isEmpty());\n    }\n\n    mockRate.set(0.0);\n    events.clear();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger2\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      mockRate.set(2.0);\n      trigger.run();\n      // waitFor not elapsed\n      assertTrue(events.toString(), events.isEmpty());\n      Thread.sleep(1000);\n      trigger.run();\n      assertTrue(events.toString(), events.isEmpty());\n      Thread.sleep(1000);\n      mockRate.set(0.0);\n      trigger.run();\n      Thread.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds - 2, TimeUnit.SECONDS));\n      trigger.run();\n\n      // violations persisted shorter than waitFor - there should be no events\n      assertTrue(events.toString(), events.isEmpty());\n\n    }\n  }\n\n","sourceOld":"  @Test\n  @SuppressWarnings({\"unchecked\"})\n  public void testWaitForElapsed() throws Exception {\n    SolrResourceLoader loader = cluster.getJettySolrRunner(0).getCoreContainer().getResourceLoader();\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    SolrZkClient zkClient = solrClient.getZkStateReader().getZkClient();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), solrClient) {\n      @Override\n      public NodeStateProvider getNodeStateProvider() {\n        return new SolrClientNodeStateProvider(solrClient) {\n          @Override\n          public Map<String, Object> getNodeValues(String node, Collection<String> tags) {\n            Map<String, Object> values = super.getNodeValues(node, tags);\n            values.keySet().forEach(k -> {\n              values.replace(k, mockRate.get());\n            });\n            return values;\n          }\n        };\n      }\n    };\n    TimeSource timeSource = cloudManager.getTimeSource();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    create.process(solrClient);\n    CloudUtil.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 4));\n\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, 1.0, 0.1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // set mock rates\n      mockRate.set(2.0);\n      TimeOut timeOut = new TimeOut(waitForSeconds + 2, TimeUnit.SECONDS, timeSource);\n      // simulate ScheduledTriggers\n      while (!timeOut.hasTimedOut()) {\n        trigger.run();\n        timeSource.sleep(1000);\n      }\n      // violation persisted longer than waitFor - there should be events\n      assertTrue(events.toString(), events.size() > 0);\n      TriggerEvent event = events.get(0);\n      assertEquals(event.toString(), TriggerEventType.SEARCHRATE, event.eventType);\n      Map<String, Object> hotNodes, hotCollections, hotShards;\n      List<ReplicaInfo> hotReplicas;\n      hotNodes = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_NODES);\n      hotCollections = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_COLLECTIONS);\n      hotShards = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_SHARDS);\n      hotReplicas = (List<ReplicaInfo>)event.properties.get(SearchRateTrigger.HOT_REPLICAS);\n      assertTrue(\"no hot nodes?\", hotNodes.isEmpty());\n      assertFalse(\"no hot collections?\", hotCollections.isEmpty());\n      assertFalse(\"no hot shards?\", hotShards.isEmpty());\n      assertFalse(\"no hot replicas?\", hotReplicas.isEmpty());\n    }\n\n    mockRate.set(0.0);\n    events.clear();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger2\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      mockRate.set(2.0);\n      trigger.run();\n      // waitFor not elapsed\n      assertTrue(events.toString(), events.isEmpty());\n      Thread.sleep(1000);\n      trigger.run();\n      assertTrue(events.toString(), events.isEmpty());\n      Thread.sleep(1000);\n      mockRate.set(0.0);\n      trigger.run();\n      Thread.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds - 2, TimeUnit.SECONDS));\n      trigger.run();\n\n      // violations persisted shorter than waitFor - there should be no events\n      assertTrue(events.toString(), events.isEmpty());\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/SearchRateTriggerTest#testWaitForElapsed().mjava","sourceNew":null,"sourceOld":"  @Test\n  @SuppressWarnings({\"unchecked\"})\n  public void testWaitForElapsed() throws Exception {\n    SolrResourceLoader loader = cluster.getJettySolrRunner(0).getCoreContainer().getResourceLoader();\n    CloudSolrClient solrClient = cluster.getSolrClient();\n    SolrZkClient zkClient = solrClient.getZkStateReader().getZkClient();\n    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), solrClient) {\n      @Override\n      public NodeStateProvider getNodeStateProvider() {\n        return new SolrClientNodeStateProvider(solrClient) {\n          @Override\n          public Map<String, Object> getNodeValues(String node, Collection<String> tags) {\n            Map<String, Object> values = super.getNodeValues(node, tags);\n            values.keySet().forEach(k -> {\n              values.replace(k, mockRate.get());\n            });\n            return values;\n          }\n        };\n      }\n    };\n    TimeSource timeSource = cloudManager.getTimeSource();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,\n        \"conf\", 2, 2);\n    create.process(solrClient);\n    CloudUtil.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 4));\n\n    long waitForSeconds = 5 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, 1.0, 0.1);\n    final List<TriggerEvent> events = new ArrayList<>();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger1\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      // set mock rates\n      mockRate.set(2.0);\n      TimeOut timeOut = new TimeOut(waitForSeconds + 2, TimeUnit.SECONDS, timeSource);\n      // simulate ScheduledTriggers\n      while (!timeOut.hasTimedOut()) {\n        trigger.run();\n        timeSource.sleep(1000);\n      }\n      // violation persisted longer than waitFor - there should be events\n      assertTrue(events.toString(), events.size() > 0);\n      TriggerEvent event = events.get(0);\n      assertEquals(event.toString(), TriggerEventType.SEARCHRATE, event.eventType);\n      Map<String, Object> hotNodes, hotCollections, hotShards;\n      List<Replica> hotReplicas;\n      hotNodes = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_NODES);\n      hotCollections = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_COLLECTIONS);\n      hotShards = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_SHARDS);\n      hotReplicas = (List<Replica>)event.properties.get(SearchRateTrigger.HOT_REPLICAS);\n      assertTrue(\"no hot nodes?\", hotNodes.isEmpty());\n      assertFalse(\"no hot collections?\", hotCollections.isEmpty());\n      assertFalse(\"no hot shards?\", hotShards.isEmpty());\n      assertFalse(\"no hot replicas?\", hotReplicas.isEmpty());\n    }\n\n    mockRate.set(0.0);\n    events.clear();\n\n    try (SearchRateTrigger trigger = new SearchRateTrigger(\"search_rate_trigger2\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n      trigger.setProcessor(event -> events.add(event));\n\n      mockRate.set(2.0);\n      trigger.run();\n      // waitFor not elapsed\n      assertTrue(events.toString(), events.isEmpty());\n      Thread.sleep(1000);\n      trigger.run();\n      assertTrue(events.toString(), events.isEmpty());\n      Thread.sleep(1000);\n      mockRate.set(0.0);\n      trigger.run();\n      Thread.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds - 2, TimeUnit.SECONDS));\n      trigger.run();\n\n      // violations persisted shorter than waitFor - there should be no events\n      assertTrue(events.toString(), events.isEmpty());\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"042b92cf48996255bedb0c3c4bf772d7e06e4dea":["c0b90ab8b228b1f7a05d5ddfbe879ce962d8964a"],"c0b90ab8b228b1f7a05d5ddfbe879ce962d8964a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"3f504512a03d978990cbff30db0522b354e846db":["7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"]},"commit2Childs":{"042b92cf48996255bedb0c3c4bf772d7e06e4dea":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"c0b90ab8b228b1f7a05d5ddfbe879ce962d8964a":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd":["3f504512a03d978990cbff30db0522b354e846db"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c0b90ab8b228b1f7a05d5ddfbe879ce962d8964a"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}