{"path":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#preUpdate().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#preUpdate().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#preUpdate().mjava","sourceNew":"  private boolean preUpdate() throws CorruptIndexException, IOException {\n    ensureOpen();\n    boolean maybeMerge = false;\n    if (flushControl.anyStalledThreads() || flushControl.numQueuedFlushes() > 0) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"DocumentsWriter has queued dwpt; will hijack this thread to flush pending segment(s)\");\n      }\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          maybeMerge |= doFlush(flushingDWPT);\n        }\n  \n        if (infoStream.isEnabled(\"DW\")) {\n          if (flushControl.anyStalledThreads()) {\n            infoStream.message(\"DW\", \"WARNING DocumentsWriter has stalled threads; waiting\");\n          }\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"continue indexing after helping out flushing DocumentsWriter is healthy\");\n      }\n    }\n    return maybeMerge;\n  }\n\n","sourceOld":"  private boolean preUpdate() throws CorruptIndexException, IOException {\n    ensureOpen();\n    boolean maybeMerge = false;\n    if (flushControl.anyStalledThreads() || flushControl.numQueuedFlushes() > 0) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"DocumentsWriter has queued dwpt; will hijack this thread to flush pending segment(s)\");\n      }\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          maybeMerge |= doFlush(flushingDWPT);\n        }\n  \n        if (infoStream.isEnabled(\"DW\")) {\n          if (flushControl.anyStalledThreads()) {\n            infoStream.message(\"DW\", \"WARNING DocumentsWriter has stalled threads; waiting\");\n          }\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"continue indexing after helping out flushing DocumentsWriter is healthy\");\n      }\n    }\n    return maybeMerge;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#preUpdate().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#preUpdate().mjava","sourceNew":"  private boolean preUpdate() throws IOException {\n    ensureOpen();\n    boolean maybeMerge = false;\n    if (flushControl.anyStalledThreads() || flushControl.numQueuedFlushes() > 0) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"DocumentsWriter has queued dwpt; will hijack this thread to flush pending segment(s)\");\n      }\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          maybeMerge |= doFlush(flushingDWPT);\n        }\n  \n        if (infoStream.isEnabled(\"DW\")) {\n          if (flushControl.anyStalledThreads()) {\n            infoStream.message(\"DW\", \"WARNING DocumentsWriter has stalled threads; waiting\");\n          }\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"continue indexing after helping out flushing DocumentsWriter is healthy\");\n      }\n    }\n    return maybeMerge;\n  }\n\n","sourceOld":"  private boolean preUpdate() throws CorruptIndexException, IOException {\n    ensureOpen();\n    boolean maybeMerge = false;\n    if (flushControl.anyStalledThreads() || flushControl.numQueuedFlushes() > 0) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"DocumentsWriter has queued dwpt; will hijack this thread to flush pending segment(s)\");\n      }\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          maybeMerge |= doFlush(flushingDWPT);\n        }\n  \n        if (infoStream.isEnabled(\"DW\")) {\n          if (flushControl.anyStalledThreads()) {\n            infoStream.message(\"DW\", \"WARNING DocumentsWriter has stalled threads; waiting\");\n          }\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"continue indexing after helping out flushing DocumentsWriter is healthy\");\n      }\n    }\n    return maybeMerge;\n  }\n\n","bugFix":["2c6dc1a64ac36088ccb8d5e20b74c48c8d3bba27"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#preUpdate().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#preUpdate().mjava","sourceNew":"  private boolean preUpdate() throws IOException {\n    ensureOpen();\n    boolean maybeMerge = false;\n    if (flushControl.anyStalledThreads() || flushControl.numQueuedFlushes() > 0) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"DocumentsWriter has queued dwpt; will hijack this thread to flush pending segment(s)\");\n      }\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          maybeMerge |= doFlush(flushingDWPT);\n        }\n  \n        if (infoStream.isEnabled(\"DW\")) {\n          if (flushControl.anyStalledThreads()) {\n            infoStream.message(\"DW\", \"WARNING DocumentsWriter has stalled threads; waiting\");\n          }\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"continue indexing after helping out flushing DocumentsWriter is healthy\");\n      }\n    }\n    return maybeMerge;\n  }\n\n","sourceOld":"  private boolean preUpdate() throws CorruptIndexException, IOException {\n    ensureOpen();\n    boolean maybeMerge = false;\n    if (flushControl.anyStalledThreads() || flushControl.numQueuedFlushes() > 0) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"DocumentsWriter has queued dwpt; will hijack this thread to flush pending segment(s)\");\n      }\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          maybeMerge |= doFlush(flushingDWPT);\n        }\n  \n        if (infoStream.isEnabled(\"DW\")) {\n          if (flushControl.anyStalledThreads()) {\n            infoStream.message(\"DW\", \"WARNING DocumentsWriter has stalled threads; waiting\");\n          }\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"continue indexing after helping out flushing DocumentsWriter is healthy\");\n      }\n    }\n    return maybeMerge;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7af110b00ea8df9429309d83e38e0533d82e144f","date":1376924768,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#preUpdate().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#preUpdate().mjava","sourceNew":"  private boolean preUpdate() throws IOException {\n    ensureOpen();\n    boolean hasEvents = false;\n    if (flushControl.anyStalledThreads() || flushControl.numQueuedFlushes() > 0) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"DocumentsWriter has queued dwpt; will hijack this thread to flush pending segment(s)\");\n      }\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          hasEvents |= doFlush(flushingDWPT);\n        }\n  \n        if (infoStream.isEnabled(\"DW\")) {\n          if (flushControl.anyStalledThreads()) {\n            infoStream.message(\"DW\", \"WARNING DocumentsWriter has stalled threads; waiting\");\n          }\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"continue indexing after helping out flushing DocumentsWriter is healthy\");\n      }\n    }\n    return hasEvents;\n  }\n\n","sourceOld":"  private boolean preUpdate() throws IOException {\n    ensureOpen();\n    boolean maybeMerge = false;\n    if (flushControl.anyStalledThreads() || flushControl.numQueuedFlushes() > 0) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"DocumentsWriter has queued dwpt; will hijack this thread to flush pending segment(s)\");\n      }\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          maybeMerge |= doFlush(flushingDWPT);\n        }\n  \n        if (infoStream.isEnabled(\"DW\")) {\n          if (flushControl.anyStalledThreads()) {\n            infoStream.message(\"DW\", \"WARNING DocumentsWriter has stalled threads; waiting\");\n          }\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"continue indexing after helping out flushing DocumentsWriter is healthy\");\n      }\n    }\n    return maybeMerge;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31d4861802ca404d78ca1d15f4550eec415b9199","date":1376947894,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#preUpdate().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#preUpdate().mjava","sourceNew":"  private boolean preUpdate() throws IOException {\n    ensureOpen();\n    boolean hasEvents = false;\n    if (flushControl.anyStalledThreads() || flushControl.numQueuedFlushes() > 0) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"DocumentsWriter has queued dwpt; will hijack this thread to flush pending segment(s)\");\n      }\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          hasEvents |= doFlush(flushingDWPT);\n        }\n  \n        if (infoStream.isEnabled(\"DW\")) {\n          if (flushControl.anyStalledThreads()) {\n            infoStream.message(\"DW\", \"WARNING DocumentsWriter has stalled threads; waiting\");\n          }\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"continue indexing after helping out flushing DocumentsWriter is healthy\");\n      }\n    }\n    return hasEvents;\n  }\n\n","sourceOld":"  private boolean preUpdate() throws IOException {\n    ensureOpen();\n    boolean maybeMerge = false;\n    if (flushControl.anyStalledThreads() || flushControl.numQueuedFlushes() > 0) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"DocumentsWriter has queued dwpt; will hijack this thread to flush pending segment(s)\");\n      }\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          maybeMerge |= doFlush(flushingDWPT);\n        }\n  \n        if (infoStream.isEnabled(\"DW\")) {\n          if (flushControl.anyStalledThreads()) {\n            infoStream.message(\"DW\", \"WARNING DocumentsWriter has stalled threads; waiting\");\n          }\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"continue indexing after helping out flushing DocumentsWriter is healthy\");\n      }\n    }\n    return maybeMerge;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#preUpdate().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#preUpdate().mjava","sourceNew":"  private boolean preUpdate() throws IOException {\n    ensureOpen();\n    boolean hasEvents = false;\n    if (flushControl.anyStalledThreads() || flushControl.numQueuedFlushes() > 0) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"DocumentsWriter has queued dwpt; will hijack this thread to flush pending segment(s)\");\n      }\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          hasEvents |= doFlush(flushingDWPT);\n        }\n  \n        if (infoStream.isEnabled(\"DW\")) {\n          if (flushControl.anyStalledThreads()) {\n            infoStream.message(\"DW\", \"WARNING DocumentsWriter has stalled threads; waiting\");\n          }\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"continue indexing after helping out flushing DocumentsWriter is healthy\");\n      }\n    }\n    return hasEvents;\n  }\n\n","sourceOld":"  private boolean preUpdate() throws IOException {\n    ensureOpen();\n    boolean maybeMerge = false;\n    if (flushControl.anyStalledThreads() || flushControl.numQueuedFlushes() > 0) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"DocumentsWriter has queued dwpt; will hijack this thread to flush pending segment(s)\");\n      }\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          maybeMerge |= doFlush(flushingDWPT);\n        }\n  \n        if (infoStream.isEnabled(\"DW\")) {\n          if (flushControl.anyStalledThreads()) {\n            infoStream.message(\"DW\", \"WARNING DocumentsWriter has stalled threads; waiting\");\n          }\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"continue indexing after helping out flushing DocumentsWriter is healthy\");\n      }\n    }\n    return maybeMerge;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9299079153fd7895bf3cf6835cf7019af2ba89b3","date":1417813477,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#preUpdate().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#preUpdate().mjava","sourceNew":"  private boolean preUpdate() throws IOException, AbortingException {\n    ensureOpen();\n    boolean hasEvents = false;\n    if (flushControl.anyStalledThreads() || flushControl.numQueuedFlushes() > 0) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"DocumentsWriter has queued dwpt; will hijack this thread to flush pending segment(s)\");\n      }\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          hasEvents |= doFlush(flushingDWPT);\n        }\n  \n        if (infoStream.isEnabled(\"DW\")) {\n          if (flushControl.anyStalledThreads()) {\n            infoStream.message(\"DW\", \"WARNING DocumentsWriter has stalled threads; waiting\");\n          }\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"continue indexing after helping out flushing DocumentsWriter is healthy\");\n      }\n    }\n    return hasEvents;\n  }\n\n","sourceOld":"  private boolean preUpdate() throws IOException {\n    ensureOpen();\n    boolean hasEvents = false;\n    if (flushControl.anyStalledThreads() || flushControl.numQueuedFlushes() > 0) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"DocumentsWriter has queued dwpt; will hijack this thread to flush pending segment(s)\");\n      }\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          hasEvents |= doFlush(flushingDWPT);\n        }\n  \n        if (infoStream.isEnabled(\"DW\")) {\n          if (flushControl.anyStalledThreads()) {\n            infoStream.message(\"DW\", \"WARNING DocumentsWriter has stalled threads; waiting\");\n          }\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"continue indexing after helping out flushing DocumentsWriter is healthy\");\n      }\n    }\n    return hasEvents;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c02b804ab16489b95429791a2d8fb0e0728354d4","date":1436551798,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#preUpdate().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#preUpdate().mjava","sourceNew":"  private boolean preUpdate() throws IOException, AbortingException {\n    ensureOpen();\n    boolean hasEvents = false;\n    if (flushControl.anyStalledThreads() || flushControl.numQueuedFlushes() > 0) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"DocumentsWriter has queued dwpt; will hijack this thread to flush pending segment(s)\");\n      }\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          hasEvents |= doFlush(flushingDWPT);\n        }\n  \n        if (infoStream.isEnabled(\"DW\") && flushControl.anyStalledThreads()) {\n          infoStream.message(\"DW\", \"WARNING DocumentsWriter has stalled threads; waiting\");\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"continue indexing after helping out flushing DocumentsWriter is healthy\");\n      }\n    }\n    return hasEvents;\n  }\n\n","sourceOld":"  private boolean preUpdate() throws IOException, AbortingException {\n    ensureOpen();\n    boolean hasEvents = false;\n    if (flushControl.anyStalledThreads() || flushControl.numQueuedFlushes() > 0) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"DocumentsWriter has queued dwpt; will hijack this thread to flush pending segment(s)\");\n      }\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          hasEvents |= doFlush(flushingDWPT);\n        }\n  \n        if (infoStream.isEnabled(\"DW\")) {\n          if (flushControl.anyStalledThreads()) {\n            infoStream.message(\"DW\", \"WARNING DocumentsWriter has stalled threads; waiting\");\n          }\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"continue indexing after helping out flushing DocumentsWriter is healthy\");\n      }\n    }\n    return hasEvents;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"be382406ee6e8449e49c082b50c31367e7add702","date":1469488703,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#preUpdate().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#preUpdate().mjava","sourceNew":"  private boolean preUpdate() throws IOException, AbortingException {\n    ensureOpen();\n    boolean hasEvents = false;\n    if (flushControl.anyStalledThreads() || flushControl.numQueuedFlushes() > 0) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          hasEvents |= doFlush(flushingDWPT);\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n    }\n    return hasEvents;\n  }\n\n","sourceOld":"  private boolean preUpdate() throws IOException, AbortingException {\n    ensureOpen();\n    boolean hasEvents = false;\n    if (flushControl.anyStalledThreads() || flushControl.numQueuedFlushes() > 0) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"DocumentsWriter has queued dwpt; will hijack this thread to flush pending segment(s)\");\n      }\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          hasEvents |= doFlush(flushingDWPT);\n        }\n  \n        if (infoStream.isEnabled(\"DW\") && flushControl.anyStalledThreads()) {\n          infoStream.message(\"DW\", \"WARNING DocumentsWriter has stalled threads; waiting\");\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"continue indexing after helping out flushing DocumentsWriter is healthy\");\n      }\n    }\n    return hasEvents;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d08973aa47f2cf98a588293a53af4e948952ccfb","date":1469518724,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#preUpdate().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#preUpdate().mjava","sourceNew":"  private boolean preUpdate() throws IOException, AbortingException {\n    ensureOpen();\n    boolean hasEvents = false;\n    if (flushControl.anyStalledThreads() || flushControl.numQueuedFlushes() > 0) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          hasEvents |= doFlush(flushingDWPT);\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n    }\n    return hasEvents;\n  }\n\n","sourceOld":"  private boolean preUpdate() throws IOException, AbortingException {\n    ensureOpen();\n    boolean hasEvents = false;\n    if (flushControl.anyStalledThreads() || flushControl.numQueuedFlushes() > 0) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"DocumentsWriter has queued dwpt; will hijack this thread to flush pending segment(s)\");\n      }\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          hasEvents |= doFlush(flushingDWPT);\n        }\n  \n        if (infoStream.isEnabled(\"DW\") && flushControl.anyStalledThreads()) {\n          infoStream.message(\"DW\", \"WARNING DocumentsWriter has stalled threads; waiting\");\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"continue indexing after helping out flushing DocumentsWriter is healthy\");\n      }\n    }\n    return hasEvents;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#preUpdate().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#preUpdate().mjava","sourceNew":"  private boolean preUpdate() throws IOException, AbortingException {\n    ensureOpen();\n    boolean hasEvents = false;\n    if (flushControl.anyStalledThreads() || flushControl.numQueuedFlushes() > 0) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          hasEvents |= doFlush(flushingDWPT);\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n    }\n    return hasEvents;\n  }\n\n","sourceOld":"  private boolean preUpdate() throws IOException, AbortingException {\n    ensureOpen();\n    boolean hasEvents = false;\n    if (flushControl.anyStalledThreads() || flushControl.numQueuedFlushes() > 0) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"DocumentsWriter has queued dwpt; will hijack this thread to flush pending segment(s)\");\n      }\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          hasEvents |= doFlush(flushingDWPT);\n        }\n  \n        if (infoStream.isEnabled(\"DW\") && flushControl.anyStalledThreads()) {\n          infoStream.message(\"DW\", \"WARNING DocumentsWriter has stalled threads; waiting\");\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"continue indexing after helping out flushing DocumentsWriter is healthy\");\n      }\n    }\n    return hasEvents;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f1ea5763a93795952100d48e19c48f19777c552c","date":1512660172,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#preUpdate().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#preUpdate().mjava","sourceNew":"  private boolean preUpdate() throws IOException, AbortingException {\n    ensureOpen();\n    boolean hasEvents = false;\n\n    if (flushControl.anyStalledThreads() || (flushControl.numQueuedFlushes() > 0 && config.checkPendingFlushOnUpdate)) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          hasEvents |= doFlush(flushingDWPT);\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n    }\n    return hasEvents;\n  }\n\n","sourceOld":"  private boolean preUpdate() throws IOException, AbortingException {\n    ensureOpen();\n    boolean hasEvents = false;\n    if (flushControl.anyStalledThreads() || flushControl.numQueuedFlushes() > 0) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          hasEvents |= doFlush(flushingDWPT);\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n    }\n    return hasEvents;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#preUpdate().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#preUpdate().mjava","sourceNew":"  private boolean preUpdate() throws IOException, AbortingException {\n    ensureOpen();\n    boolean hasEvents = false;\n\n    if (flushControl.anyStalledThreads() || (flushControl.numQueuedFlushes() > 0 && config.checkPendingFlushOnUpdate)) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          hasEvents |= doFlush(flushingDWPT);\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n    }\n    return hasEvents;\n  }\n\n","sourceOld":"  private boolean preUpdate() throws IOException, AbortingException {\n    ensureOpen();\n    boolean hasEvents = false;\n    if (flushControl.anyStalledThreads() || flushControl.numQueuedFlushes() > 0) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          hasEvents |= doFlush(flushingDWPT);\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n    }\n    return hasEvents;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"845b760a99e5f369fcd0a5d723a87b8def6a3f56","date":1521117993,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#preUpdate().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#preUpdate().mjava","sourceNew":"  private boolean preUpdate() throws IOException {\n    ensureOpen();\n    boolean hasEvents = false;\n\n    if (flushControl.anyStalledThreads() || (flushControl.numQueuedFlushes() > 0 && config.checkPendingFlushOnUpdate)) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          hasEvents |= doFlush(flushingDWPT);\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n    }\n    return hasEvents;\n  }\n\n","sourceOld":"  private boolean preUpdate() throws IOException, AbortingException {\n    ensureOpen();\n    boolean hasEvents = false;\n\n    if (flushControl.anyStalledThreads() || (flushControl.numQueuedFlushes() > 0 && config.checkPendingFlushOnUpdate)) {\n      // Help out flushing any queued DWPTs so we can un-stall:\n      do {\n        // Try pick up pending threads here if possible\n        DocumentsWriterPerThread flushingDWPT;\n        while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n          // Don't push the delete here since the update could fail!\n          hasEvents |= doFlush(flushingDWPT);\n        }\n        \n        flushControl.waitIfStalled(); // block if stalled\n      } while (flushControl.numQueuedFlushes() != 0); // still queued DWPTs try help flushing\n    }\n    return hasEvents;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["417142ff08fda9cf0b72d5133e63097a166c6458"],"7af110b00ea8df9429309d83e38e0533d82e144f":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"f1ea5763a93795952100d48e19c48f19777c552c":["d08973aa47f2cf98a588293a53af4e948952ccfb"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","7af110b00ea8df9429309d83e38e0533d82e144f"],"31d4861802ca404d78ca1d15f4550eec415b9199":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","7af110b00ea8df9429309d83e38e0533d82e144f"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["c02b804ab16489b95429791a2d8fb0e0728354d4","d08973aa47f2cf98a588293a53af4e948952ccfb"],"c02b804ab16489b95429791a2d8fb0e0728354d4":["9299079153fd7895bf3cf6835cf7019af2ba89b3"],"417142ff08fda9cf0b72d5133e63097a166c6458":["d08973aa47f2cf98a588293a53af4e948952ccfb","f1ea5763a93795952100d48e19c48f19777c552c"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"be382406ee6e8449e49c082b50c31367e7add702":["c02b804ab16489b95429791a2d8fb0e0728354d4"],"9299079153fd7895bf3cf6835cf7019af2ba89b3":["7af110b00ea8df9429309d83e38e0533d82e144f"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d08973aa47f2cf98a588293a53af4e948952ccfb":["c02b804ab16489b95429791a2d8fb0e0728354d4","be382406ee6e8449e49c082b50c31367e7add702"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["845b760a99e5f369fcd0a5d723a87b8def6a3f56"]},"commit2Childs":{"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7af110b00ea8df9429309d83e38e0533d82e144f":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199","9299079153fd7895bf3cf6835cf7019af2ba89b3"],"f1ea5763a93795952100d48e19c48f19777c552c":["417142ff08fda9cf0b72d5133e63097a166c6458"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["fe33227f6805edab2036cbb80645cc4e2d1fa424","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"31d4861802ca404d78ca1d15f4550eec415b9199":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"417142ff08fda9cf0b72d5133e63097a166c6458":["845b760a99e5f369fcd0a5d723a87b8def6a3f56"],"c02b804ab16489b95429791a2d8fb0e0728354d4":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","be382406ee6e8449e49c082b50c31367e7add702","d08973aa47f2cf98a588293a53af4e948952ccfb"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"be382406ee6e8449e49c082b50c31367e7add702":["d08973aa47f2cf98a588293a53af4e948952ccfb"],"9299079153fd7895bf3cf6835cf7019af2ba89b3":["c02b804ab16489b95429791a2d8fb0e0728354d4"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["7af110b00ea8df9429309d83e38e0533d82e144f","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"d08973aa47f2cf98a588293a53af4e948952ccfb":["f1ea5763a93795952100d48e19c48f19777c552c","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","417142ff08fda9cf0b72d5133e63097a166c6458"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}