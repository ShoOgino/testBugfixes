{"path":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads#testOpenTwoIndexWritersOnDifferentThreads().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads#testOpenTwoIndexWritersOnDifferentThreads().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterWithThreads#testOpenTwoIndexWritersOnDifferentThreads().mjava","sourceNew":"  //  LUCENE-3365: Test adding two documents with the same field from two different IndexWriters \n  //  that we attempt to open at the same time.  As long as the first IndexWriter completes\n  //  and closes before the second IndexWriter time's out trying to get the Lock,\n  //  we should see both documents\n  public void testOpenTwoIndexWritersOnDifferentThreads() throws IOException, InterruptedException {\n     final MockDirectoryWrapper dir = newDirectory();\n     CountDownLatch oneIWConstructed = new CountDownLatch(1);\n     DelayedIndexAndCloseRunnable thread1 = new DelayedIndexAndCloseRunnable(\n         dir, oneIWConstructed);\n     DelayedIndexAndCloseRunnable thread2 = new DelayedIndexAndCloseRunnable(\n         dir, oneIWConstructed);\n\n     thread1.start();\n     thread2.start();\n     oneIWConstructed.await();\n\n     thread1.startIndexing();\n     thread2.startIndexing();\n\n     thread1.join();\n     thread2.join();\n     \n     assertFalse(\"Failed due to: \" + thread1.failure, thread1.failed);\n     assertFalse(\"Failed due to: \" + thread2.failure, thread2.failed);\n     // now verify that we have two documents in the index\n     IndexReader reader = IndexReader.open(dir);\n     assertEquals(\"IndexReader should have one document per thread running\", 2,\n         reader.numDocs());\n     \n     reader.close();\n     dir.close();\n  }\n\n","sourceOld":"  //  LUCENE-3365: Test adding two documents with the same field from two different IndexWriters \n  //  that we attempt to open at the same time.  As long as the first IndexWriter completes\n  //  and closes before the second IndexWriter time's out trying to get the Lock,\n  //  we should see both documents\n  public void testOpenTwoIndexWritersOnDifferentThreads() throws IOException, InterruptedException {\n     final MockDirectoryWrapper dir = newDirectory();\n     CountDownLatch oneIWConstructed = new CountDownLatch(1);\n     DelayedIndexAndCloseRunnable thread1 = new DelayedIndexAndCloseRunnable(\n         dir, oneIWConstructed);\n     DelayedIndexAndCloseRunnable thread2 = new DelayedIndexAndCloseRunnable(\n         dir, oneIWConstructed);\n\n     thread1.start();\n     thread2.start();\n     oneIWConstructed.await();\n\n     thread1.startIndexing();\n     thread2.startIndexing();\n\n     thread1.join();\n     thread2.join();\n     \n     assertFalse(\"Failed due to: \" + thread1.failure, thread1.failed);\n     assertFalse(\"Failed due to: \" + thread2.failure, thread2.failed);\n     // now verify that we have two documents in the index\n     IndexReader reader = IndexReader.open(dir);\n     assertEquals(\"IndexReader should have one document per thread running\", 2,\n         reader.numDocs());\n     \n     reader.close();\n     dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f","date":1338430031,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads#testOpenTwoIndexWritersOnDifferentThreads().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads#testOpenTwoIndexWritersOnDifferentThreads().mjava","sourceNew":"  //  LUCENE-3365: Test adding two documents with the same field from two different IndexWriters \n  //  that we attempt to open at the same time.  As long as the first IndexWriter completes\n  //  and closes before the second IndexWriter time's out trying to get the Lock,\n  //  we should see both documents\n  public void testOpenTwoIndexWritersOnDifferentThreads() throws IOException, InterruptedException {\n     final MockDirectoryWrapper dir = newDirectory();\n     CountDownLatch oneIWConstructed = new CountDownLatch(1);\n     DelayedIndexAndCloseRunnable thread1 = new DelayedIndexAndCloseRunnable(\n         dir, oneIWConstructed);\n     DelayedIndexAndCloseRunnable thread2 = new DelayedIndexAndCloseRunnable(\n         dir, oneIWConstructed);\n\n     thread1.start();\n     thread2.start();\n     oneIWConstructed.await();\n\n     thread1.startIndexing();\n     thread2.startIndexing();\n\n     thread1.join();\n     thread2.join();\n     \n     assertFalse(\"Failed due to: \" + thread1.failure, thread1.failed);\n     assertFalse(\"Failed due to: \" + thread2.failure, thread2.failed);\n     // now verify that we have two documents in the index\n     IndexReader reader = DirectoryReader.open(dir);\n     assertEquals(\"IndexReader should have one document per thread running\", 2,\n         reader.numDocs());\n     \n     reader.close();\n     dir.close();\n  }\n\n","sourceOld":"  //  LUCENE-3365: Test adding two documents with the same field from two different IndexWriters \n  //  that we attempt to open at the same time.  As long as the first IndexWriter completes\n  //  and closes before the second IndexWriter time's out trying to get the Lock,\n  //  we should see both documents\n  public void testOpenTwoIndexWritersOnDifferentThreads() throws IOException, InterruptedException {\n     final MockDirectoryWrapper dir = newDirectory();\n     CountDownLatch oneIWConstructed = new CountDownLatch(1);\n     DelayedIndexAndCloseRunnable thread1 = new DelayedIndexAndCloseRunnable(\n         dir, oneIWConstructed);\n     DelayedIndexAndCloseRunnable thread2 = new DelayedIndexAndCloseRunnable(\n         dir, oneIWConstructed);\n\n     thread1.start();\n     thread2.start();\n     oneIWConstructed.await();\n\n     thread1.startIndexing();\n     thread2.startIndexing();\n\n     thread1.join();\n     thread2.join();\n     \n     assertFalse(\"Failed due to: \" + thread1.failure, thread1.failed);\n     assertFalse(\"Failed due to: \" + thread2.failure, thread2.failed);\n     // now verify that we have two documents in the index\n     IndexReader reader = IndexReader.open(dir);\n     assertEquals(\"IndexReader should have one document per thread running\", 2,\n         reader.numDocs());\n     \n     reader.close();\n     dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d19974432be9aed28ee7dca73bdf01d139e763a9","date":1342822166,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads#testOpenTwoIndexWritersOnDifferentThreads().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads#testOpenTwoIndexWritersOnDifferentThreads().mjava","sourceNew":"  //  LUCENE-3365: Test adding two documents with the same field from two different IndexWriters \n  //  that we attempt to open at the same time.  As long as the first IndexWriter completes\n  //  and closes before the second IndexWriter time's out trying to get the Lock,\n  //  we should see both documents\n  public void testOpenTwoIndexWritersOnDifferentThreads() throws IOException, InterruptedException {\n     final Directory dir = newDirectory();\n     CountDownLatch oneIWConstructed = new CountDownLatch(1);\n     DelayedIndexAndCloseRunnable thread1 = new DelayedIndexAndCloseRunnable(\n         dir, oneIWConstructed);\n     DelayedIndexAndCloseRunnable thread2 = new DelayedIndexAndCloseRunnable(\n         dir, oneIWConstructed);\n\n     thread1.start();\n     thread2.start();\n     oneIWConstructed.await();\n\n     thread1.startIndexing();\n     thread2.startIndexing();\n\n     thread1.join();\n     thread2.join();\n     \n     assertFalse(\"Failed due to: \" + thread1.failure, thread1.failed);\n     assertFalse(\"Failed due to: \" + thread2.failure, thread2.failed);\n     // now verify that we have two documents in the index\n     IndexReader reader = DirectoryReader.open(dir);\n     assertEquals(\"IndexReader should have one document per thread running\", 2,\n         reader.numDocs());\n     \n     reader.close();\n     dir.close();\n  }\n\n","sourceOld":"  //  LUCENE-3365: Test adding two documents with the same field from two different IndexWriters \n  //  that we attempt to open at the same time.  As long as the first IndexWriter completes\n  //  and closes before the second IndexWriter time's out trying to get the Lock,\n  //  we should see both documents\n  public void testOpenTwoIndexWritersOnDifferentThreads() throws IOException, InterruptedException {\n     final MockDirectoryWrapper dir = newDirectory();\n     CountDownLatch oneIWConstructed = new CountDownLatch(1);\n     DelayedIndexAndCloseRunnable thread1 = new DelayedIndexAndCloseRunnable(\n         dir, oneIWConstructed);\n     DelayedIndexAndCloseRunnable thread2 = new DelayedIndexAndCloseRunnable(\n         dir, oneIWConstructed);\n\n     thread1.start();\n     thread2.start();\n     oneIWConstructed.await();\n\n     thread1.startIndexing();\n     thread2.startIndexing();\n\n     thread1.join();\n     thread2.join();\n     \n     assertFalse(\"Failed due to: \" + thread1.failure, thread1.failed);\n     assertFalse(\"Failed due to: \" + thread2.failure, thread2.failed);\n     // now verify that we have two documents in the index\n     IndexReader reader = DirectoryReader.open(dir);\n     assertEquals(\"IndexReader should have one document per thread running\", 2,\n         reader.numDocs());\n     \n     reader.close();\n     dir.close();\n  }\n\n","bugFix":["adde4ed7da03e734626803a3802e6cf88b77a2e7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","date":1343059585,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads#testOpenTwoIndexWritersOnDifferentThreads().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads#testOpenTwoIndexWritersOnDifferentThreads().mjava","sourceNew":"  //  LUCENE-3365: Test adding two documents with the same field from two different IndexWriters \n  //  that we attempt to open at the same time.  As long as the first IndexWriter completes\n  //  and closes before the second IndexWriter time's out trying to get the Lock,\n  //  we should see both documents\n  public void testOpenTwoIndexWritersOnDifferentThreads() throws IOException, InterruptedException {\n     final Directory dir = newDirectory();\n     CountDownLatch oneIWConstructed = new CountDownLatch(1);\n     DelayedIndexAndCloseRunnable thread1 = new DelayedIndexAndCloseRunnable(\n         dir, oneIWConstructed);\n     DelayedIndexAndCloseRunnable thread2 = new DelayedIndexAndCloseRunnable(\n         dir, oneIWConstructed);\n\n     thread1.start();\n     thread2.start();\n     oneIWConstructed.await();\n\n     thread1.startIndexing();\n     thread2.startIndexing();\n\n     thread1.join();\n     thread2.join();\n     \n     assertFalse(\"Failed due to: \" + thread1.failure, thread1.failed);\n     assertFalse(\"Failed due to: \" + thread2.failure, thread2.failed);\n     // now verify that we have two documents in the index\n     IndexReader reader = DirectoryReader.open(dir);\n     assertEquals(\"IndexReader should have one document per thread running\", 2,\n         reader.numDocs());\n     \n     reader.close();\n     dir.close();\n  }\n\n","sourceOld":"  //  LUCENE-3365: Test adding two documents with the same field from two different IndexWriters \n  //  that we attempt to open at the same time.  As long as the first IndexWriter completes\n  //  and closes before the second IndexWriter time's out trying to get the Lock,\n  //  we should see both documents\n  public void testOpenTwoIndexWritersOnDifferentThreads() throws IOException, InterruptedException {\n     final MockDirectoryWrapper dir = newDirectory();\n     CountDownLatch oneIWConstructed = new CountDownLatch(1);\n     DelayedIndexAndCloseRunnable thread1 = new DelayedIndexAndCloseRunnable(\n         dir, oneIWConstructed);\n     DelayedIndexAndCloseRunnable thread2 = new DelayedIndexAndCloseRunnable(\n         dir, oneIWConstructed);\n\n     thread1.start();\n     thread2.start();\n     oneIWConstructed.await();\n\n     thread1.startIndexing();\n     thread2.startIndexing();\n\n     thread1.join();\n     thread2.join();\n     \n     assertFalse(\"Failed due to: \" + thread1.failure, thread1.failed);\n     assertFalse(\"Failed due to: \" + thread2.failure, thread2.failed);\n     // now verify that we have two documents in the index\n     IndexReader reader = DirectoryReader.open(dir);\n     assertEquals(\"IndexReader should have one document per thread running\", 2,\n         reader.numDocs());\n     \n     reader.close();\n     dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads#testOpenTwoIndexWritersOnDifferentThreads().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads#testOpenTwoIndexWritersOnDifferentThreads().mjava","sourceNew":"  //  LUCENE-3365: Test adding two documents with the same field from two different IndexWriters \n  //  that we attempt to open at the same time.  As long as the first IndexWriter completes\n  //  and closes before the second IndexWriter time's out trying to get the Lock,\n  //  we should see both documents\n  public void testOpenTwoIndexWritersOnDifferentThreads() throws IOException, InterruptedException {\n     final Directory dir = newDirectory();\n     CountDownLatch oneIWConstructed = new CountDownLatch(1);\n     DelayedIndexAndCloseRunnable thread1 = new DelayedIndexAndCloseRunnable(\n         dir, oneIWConstructed);\n     DelayedIndexAndCloseRunnable thread2 = new DelayedIndexAndCloseRunnable(\n         dir, oneIWConstructed);\n\n     thread1.start();\n     thread2.start();\n     oneIWConstructed.await();\n\n     thread1.startIndexing();\n     thread2.startIndexing();\n\n     thread1.join();\n     thread2.join();\n     \n     assertFalse(\"Failed due to: \" + thread1.failure, thread1.failed);\n     assertFalse(\"Failed due to: \" + thread2.failure, thread2.failed);\n     // now verify that we have two documents in the index\n     IndexReader reader = DirectoryReader.open(dir);\n     assertEquals(\"IndexReader should have one document per thread running\", 2,\n         reader.numDocs());\n     \n     reader.close();\n     dir.close();\n  }\n\n","sourceOld":"  //  LUCENE-3365: Test adding two documents with the same field from two different IndexWriters \n  //  that we attempt to open at the same time.  As long as the first IndexWriter completes\n  //  and closes before the second IndexWriter time's out trying to get the Lock,\n  //  we should see both documents\n  public void testOpenTwoIndexWritersOnDifferentThreads() throws IOException, InterruptedException {\n     final MockDirectoryWrapper dir = newDirectory();\n     CountDownLatch oneIWConstructed = new CountDownLatch(1);\n     DelayedIndexAndCloseRunnable thread1 = new DelayedIndexAndCloseRunnable(\n         dir, oneIWConstructed);\n     DelayedIndexAndCloseRunnable thread2 = new DelayedIndexAndCloseRunnable(\n         dir, oneIWConstructed);\n\n     thread1.start();\n     thread2.start();\n     oneIWConstructed.await();\n\n     thread1.startIndexing();\n     thread2.startIndexing();\n\n     thread1.join();\n     thread2.join();\n     \n     assertFalse(\"Failed due to: \" + thread1.failure, thread1.failed);\n     assertFalse(\"Failed due to: \" + thread2.failure, thread2.failed);\n     // now verify that we have two documents in the index\n     IndexReader reader = DirectoryReader.open(dir);\n     assertEquals(\"IndexReader should have one document per thread running\", 2,\n         reader.numDocs());\n     \n     reader.close();\n     dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe5a649a43513e006706855ad781e5900bce56b3","date":1347826142,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads#testOpenTwoIndexWritersOnDifferentThreads().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads#testOpenTwoIndexWritersOnDifferentThreads().mjava","sourceNew":"  //  LUCENE-3365: Test adding two documents with the same field from two different IndexWriters \n  //  that we attempt to open at the same time.  As long as the first IndexWriter completes\n  //  and closes before the second IndexWriter time's out trying to get the Lock,\n  //  we should see both documents\n  public void testOpenTwoIndexWritersOnDifferentThreads() throws IOException, InterruptedException {\n     final Directory dir = newDirectory();\n     CountDownLatch oneIWConstructed = new CountDownLatch(1);\n     DelayedIndexAndCloseRunnable thread1 = new DelayedIndexAndCloseRunnable(\n         dir, oneIWConstructed);\n     DelayedIndexAndCloseRunnable thread2 = new DelayedIndexAndCloseRunnable(\n         dir, oneIWConstructed);\n\n     thread1.start();\n     thread2.start();\n     oneIWConstructed.await();\n\n     thread1.startIndexing();\n     thread2.startIndexing();\n\n     thread1.join();\n     thread2.join();\n     \n     assumeFalse(\"aborting test: timeout obtaining lock\", thread1.failure instanceof LockObtainFailedException);\n     assumeFalse(\"aborting test: timeout obtaining lock\", thread2.failure instanceof LockObtainFailedException);\n\n     assertFalse(\"Failed due to: \" + thread1.failure, thread1.failed);\n     assertFalse(\"Failed due to: \" + thread2.failure, thread2.failed);\n     // now verify that we have two documents in the index\n     IndexReader reader = DirectoryReader.open(dir);\n     assertEquals(\"IndexReader should have one document per thread running\", 2,\n         reader.numDocs());\n     \n     reader.close();\n     dir.close();\n  }\n\n","sourceOld":"  //  LUCENE-3365: Test adding two documents with the same field from two different IndexWriters \n  //  that we attempt to open at the same time.  As long as the first IndexWriter completes\n  //  and closes before the second IndexWriter time's out trying to get the Lock,\n  //  we should see both documents\n  public void testOpenTwoIndexWritersOnDifferentThreads() throws IOException, InterruptedException {\n     final Directory dir = newDirectory();\n     CountDownLatch oneIWConstructed = new CountDownLatch(1);\n     DelayedIndexAndCloseRunnable thread1 = new DelayedIndexAndCloseRunnable(\n         dir, oneIWConstructed);\n     DelayedIndexAndCloseRunnable thread2 = new DelayedIndexAndCloseRunnable(\n         dir, oneIWConstructed);\n\n     thread1.start();\n     thread2.start();\n     oneIWConstructed.await();\n\n     thread1.startIndexing();\n     thread2.startIndexing();\n\n     thread1.join();\n     thread2.join();\n     \n     assertFalse(\"Failed due to: \" + thread1.failure, thread1.failed);\n     assertFalse(\"Failed due to: \" + thread2.failure, thread2.failed);\n     // now verify that we have two documents in the index\n     IndexReader reader = DirectoryReader.open(dir);\n     assertEquals(\"IndexReader should have one document per thread running\", 2,\n         reader.numDocs());\n     \n     reader.close();\n     dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"120bebc9652a3f290cc91bcc302f9f192dad2e8d","date":1347890799,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads#testOpenTwoIndexWritersOnDifferentThreads().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads#testOpenTwoIndexWritersOnDifferentThreads().mjava","sourceNew":"  //  LUCENE-3365: Test adding two documents with the same field from two different IndexWriters \n  //  that we attempt to open at the same time.  As long as the first IndexWriter completes\n  //  and closes before the second IndexWriter time's out trying to get the Lock,\n  //  we should see both documents\n  public void testOpenTwoIndexWritersOnDifferentThreads() throws IOException, InterruptedException {\n     final Directory dir = newDirectory();\n     CountDownLatch oneIWConstructed = new CountDownLatch(1);\n     DelayedIndexAndCloseRunnable thread1 = new DelayedIndexAndCloseRunnable(\n         dir, oneIWConstructed);\n     DelayedIndexAndCloseRunnable thread2 = new DelayedIndexAndCloseRunnable(\n         dir, oneIWConstructed);\n\n     thread1.start();\n     thread2.start();\n     oneIWConstructed.await();\n\n     thread1.startIndexing();\n     thread2.startIndexing();\n\n     thread1.join();\n     thread2.join();\n     \n     // ensure the directory is closed if we hit the timeout and throw assume\n     // TODO: can we improve this in LuceneTestCase? I dont know what the logic would be...\n     try {\n       assumeFalse(\"aborting test: timeout obtaining lock\", thread1.failure instanceof LockObtainFailedException);\n       assumeFalse(\"aborting test: timeout obtaining lock\", thread2.failure instanceof LockObtainFailedException);\n\n       assertFalse(\"Failed due to: \" + thread1.failure, thread1.failed);\n       assertFalse(\"Failed due to: \" + thread2.failure, thread2.failed);\n       // now verify that we have two documents in the index\n       IndexReader reader = DirectoryReader.open(dir);\n       assertEquals(\"IndexReader should have one document per thread running\", 2,\n         reader.numDocs());\n     \n       reader.close();\n     } finally {\n       dir.close();\n     }\n  }\n\n","sourceOld":"  //  LUCENE-3365: Test adding two documents with the same field from two different IndexWriters \n  //  that we attempt to open at the same time.  As long as the first IndexWriter completes\n  //  and closes before the second IndexWriter time's out trying to get the Lock,\n  //  we should see both documents\n  public void testOpenTwoIndexWritersOnDifferentThreads() throws IOException, InterruptedException {\n     final Directory dir = newDirectory();\n     CountDownLatch oneIWConstructed = new CountDownLatch(1);\n     DelayedIndexAndCloseRunnable thread1 = new DelayedIndexAndCloseRunnable(\n         dir, oneIWConstructed);\n     DelayedIndexAndCloseRunnable thread2 = new DelayedIndexAndCloseRunnable(\n         dir, oneIWConstructed);\n\n     thread1.start();\n     thread2.start();\n     oneIWConstructed.await();\n\n     thread1.startIndexing();\n     thread2.startIndexing();\n\n     thread1.join();\n     thread2.join();\n     \n     assumeFalse(\"aborting test: timeout obtaining lock\", thread1.failure instanceof LockObtainFailedException);\n     assumeFalse(\"aborting test: timeout obtaining lock\", thread2.failure instanceof LockObtainFailedException);\n\n     assertFalse(\"Failed due to: \" + thread1.failure, thread1.failed);\n     assertFalse(\"Failed due to: \" + thread2.failure, thread2.failed);\n     // now verify that we have two documents in the index\n     IndexReader reader = DirectoryReader.open(dir);\n     assertEquals(\"IndexReader should have one document per thread running\", 2,\n         reader.numDocs());\n     \n     reader.close();\n     dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9f7829b01acc3b2d4cad883060a0fbf544eaae1","date":1521396858,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads#testOpenTwoIndexWritersOnDifferentThreads().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads#testOpenTwoIndexWritersOnDifferentThreads().mjava","sourceNew":"  //  LUCENE-3365: Test adding two documents with the same field from two different IndexWriters \n  //  that we attempt to open at the same time.  As long as the first IndexWriter completes\n  //  and closes before the second IndexWriter time's out trying to get the Lock,\n  //  we should see both documents\n  public void testOpenTwoIndexWritersOnDifferentThreads() throws IOException, InterruptedException {\n     try (final Directory dir = newDirectory()) {\n       CyclicBarrier syncStart = new CyclicBarrier(2);\n       DelayedIndexAndCloseRunnable thread1 = new DelayedIndexAndCloseRunnable(dir, syncStart);\n       DelayedIndexAndCloseRunnable thread2 = new DelayedIndexAndCloseRunnable(dir, syncStart);\n       thread1.start();\n       thread2.start();\n       thread1.join();\n       thread2.join();\n\n       if (thread1.failure instanceof LockObtainFailedException ||\n           thread2.failure instanceof LockObtainFailedException) {\n         // We only care about the situation when the two writers succeeded.\n         return;\n       }\n\n       assertFalse(\"Failed due to: \" + thread1.failure, thread1.failed);\n       assertFalse(\"Failed due to: \" + thread2.failure, thread2.failed);\n\n       // now verify that we have two documents in the index\n       IndexReader reader = DirectoryReader.open(dir);\n       assertEquals(\"IndexReader should have one document per thread running\", 2,\n         reader.numDocs());\n\n       reader.close();\n     }\n  }\n\n","sourceOld":"  //  LUCENE-3365: Test adding two documents with the same field from two different IndexWriters \n  //  that we attempt to open at the same time.  As long as the first IndexWriter completes\n  //  and closes before the second IndexWriter time's out trying to get the Lock,\n  //  we should see both documents\n  public void testOpenTwoIndexWritersOnDifferentThreads() throws IOException, InterruptedException {\n     final Directory dir = newDirectory();\n     CountDownLatch oneIWConstructed = new CountDownLatch(1);\n     DelayedIndexAndCloseRunnable thread1 = new DelayedIndexAndCloseRunnable(\n         dir, oneIWConstructed);\n     DelayedIndexAndCloseRunnable thread2 = new DelayedIndexAndCloseRunnable(\n         dir, oneIWConstructed);\n\n     thread1.start();\n     thread2.start();\n     oneIWConstructed.await();\n\n     thread1.startIndexing();\n     thread2.startIndexing();\n\n     thread1.join();\n     thread2.join();\n     \n     // ensure the directory is closed if we hit the timeout and throw assume\n     // TODO: can we improve this in LuceneTestCase? I dont know what the logic would be...\n     try {\n       assumeFalse(\"aborting test: timeout obtaining lock\", thread1.failure instanceof LockObtainFailedException);\n       assumeFalse(\"aborting test: timeout obtaining lock\", thread2.failure instanceof LockObtainFailedException);\n\n       assertFalse(\"Failed due to: \" + thread1.failure, thread1.failed);\n       assertFalse(\"Failed due to: \" + thread2.failure, thread2.failed);\n       // now verify that we have two documents in the index\n       IndexReader reader = DirectoryReader.open(dir);\n       assertEquals(\"IndexReader should have one document per thread running\", 2,\n         reader.numDocs());\n     \n       reader.close();\n     } finally {\n       dir.close();\n     }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"203e3fcf513c02ee2c07015f2ce277e26dc60907","date":1521404157,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads#testOpenTwoIndexWritersOnDifferentThreads().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads#testOpenTwoIndexWritersOnDifferentThreads().mjava","sourceNew":"  //  LUCENE-3365: Test adding two documents with the same field from two different IndexWriters \n  //  that we attempt to open at the same time.  As long as the first IndexWriter completes\n  //  and closes before the second IndexWriter time's out trying to get the Lock,\n  //  we should see both documents\n  public void testOpenTwoIndexWritersOnDifferentThreads() throws IOException, InterruptedException {\n     try (final Directory dir = newDirectory()) {\n       CyclicBarrier syncStart = new CyclicBarrier(2);\n       DelayedIndexAndCloseRunnable thread1 = new DelayedIndexAndCloseRunnable(dir, syncStart);\n       DelayedIndexAndCloseRunnable thread2 = new DelayedIndexAndCloseRunnable(dir, syncStart);\n       thread1.start();\n       thread2.start();\n       thread1.join();\n       thread2.join();\n\n       if (thread1.failure instanceof LockObtainFailedException ||\n           thread2.failure instanceof LockObtainFailedException) {\n         // We only care about the situation when the two writers succeeded.\n         return;\n       }\n\n       assertFalse(\"Failed due to: \" + thread1.failure, thread1.failed);\n       assertFalse(\"Failed due to: \" + thread2.failure, thread2.failed);\n\n       // now verify that we have two documents in the index\n       IndexReader reader = DirectoryReader.open(dir);\n       assertEquals(\"IndexReader should have one document per thread running\", 2,\n         reader.numDocs());\n\n       reader.close();\n     }\n  }\n\n","sourceOld":"  //  LUCENE-3365: Test adding two documents with the same field from two different IndexWriters \n  //  that we attempt to open at the same time.  As long as the first IndexWriter completes\n  //  and closes before the second IndexWriter time's out trying to get the Lock,\n  //  we should see both documents\n  public void testOpenTwoIndexWritersOnDifferentThreads() throws IOException, InterruptedException {\n     final Directory dir = newDirectory();\n     CountDownLatch oneIWConstructed = new CountDownLatch(1);\n     DelayedIndexAndCloseRunnable thread1 = new DelayedIndexAndCloseRunnable(\n         dir, oneIWConstructed);\n     DelayedIndexAndCloseRunnable thread2 = new DelayedIndexAndCloseRunnable(\n         dir, oneIWConstructed);\n\n     thread1.start();\n     thread2.start();\n     oneIWConstructed.await();\n\n     thread1.startIndexing();\n     thread2.startIndexing();\n\n     thread1.join();\n     thread2.join();\n     \n     // ensure the directory is closed if we hit the timeout and throw assume\n     // TODO: can we improve this in LuceneTestCase? I dont know what the logic would be...\n     try {\n       assumeFalse(\"aborting test: timeout obtaining lock\", thread1.failure instanceof LockObtainFailedException);\n       assumeFalse(\"aborting test: timeout obtaining lock\", thread2.failure instanceof LockObtainFailedException);\n\n       assertFalse(\"Failed due to: \" + thread1.failure, thread1.failed);\n       assertFalse(\"Failed due to: \" + thread2.failure, thread2.failed);\n       // now verify that we have two documents in the index\n       IndexReader reader = DirectoryReader.open(dir);\n       assertEquals(\"IndexReader should have one document per thread running\", 2,\n         reader.numDocs());\n     \n       reader.close();\n     } finally {\n       dir.close();\n     }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"aba371508186796cc6151d8223a5b4e16d02e26e":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f","d19974432be9aed28ee7dca73bdf01d139e763a9"],"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d19974432be9aed28ee7dca73bdf01d139e763a9":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"203e3fcf513c02ee2c07015f2ce277e26dc60907":["120bebc9652a3f290cc91bcc302f9f192dad2e8d","d9f7829b01acc3b2d4cad883060a0fbf544eaae1"],"d9f7829b01acc3b2d4cad883060a0fbf544eaae1":["120bebc9652a3f290cc91bcc302f9f192dad2e8d"],"fe5a649a43513e006706855ad781e5900bce56b3":["d19974432be9aed28ee7dca73bdf01d139e763a9"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f","d19974432be9aed28ee7dca73bdf01d139e763a9"],"120bebc9652a3f290cc91bcc302f9f192dad2e8d":["fe5a649a43513e006706855ad781e5900bce56b3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["203e3fcf513c02ee2c07015f2ce277e26dc60907"]},"commit2Childs":{"aba371508186796cc6151d8223a5b4e16d02e26e":[],"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f":["aba371508186796cc6151d8223a5b4e16d02e26e","d19974432be9aed28ee7dca73bdf01d139e763a9","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"d19974432be9aed28ee7dca73bdf01d139e763a9":["aba371508186796cc6151d8223a5b4e16d02e26e","fe5a649a43513e006706855ad781e5900bce56b3","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"203e3fcf513c02ee2c07015f2ce277e26dc60907":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d9f7829b01acc3b2d4cad883060a0fbf544eaae1":["203e3fcf513c02ee2c07015f2ce277e26dc60907"],"fe5a649a43513e006706855ad781e5900bce56b3":["120bebc9652a3f290cc91bcc302f9f192dad2e8d"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":[],"120bebc9652a3f290cc91bcc302f9f192dad2e8d":["203e3fcf513c02ee2c07015f2ce277e26dc60907","d9f7829b01acc3b2d4cad883060a0fbf544eaae1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}