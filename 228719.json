{"path":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.FacetLabelReader#nextFacetLabel(int).mjava","commits":[{"id":"2b0ae449d456c3d95466275e466ca402ce36f52b","date":1601304937,"type":0,"author":"goankur","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.FacetLabelReader#nextFacetLabel(int).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Retrieves the next {@link FacetLabel} for the specified {@code docId}, or {@code null} if there are no more.\n     * This method has state: if the provided {@code docId} is the same as the previous invocation, it returns the\n     * next {@link FacetLabel} for that document.  Otherwise, it advances to the new {@code docId} and provides the\n     * first {@link FacetLabel} for that document, or {@code null} if that document has no indexed facets.  Each\n     * new {@code docId} must be in strictly monotonic (increasing) order.\n     *\n     * <p><b>NOTE</b>: The returned FacetLabels may not be in the same order in which they were indexed</p>\n     *\n     * @param docId input docId provided in monotonic (non-decreasing) order\n     * @return the first or next {@link FacetLabel}, or {@code null} if there are no more\n     * @throws IOException when a low-level IO issue occurs\n     * @throws IllegalArgumentException if docId provided is less than docId supplied in an earlier invocation\n     */\n    public FacetLabel nextFacetLabel(int docId) throws IOException {\n      if (currentDocId != docId) {\n        if (docId < currentDocId) {\n          throw new IllegalArgumentException(\"docs out of order: previous docId=\" + currentDocId\n              + \" current docId=\" + docId);\n        }\n        ordinalsSegmentReader.get(docId, decodedOrds);\n        currentDocId = docId;\n        currentPos = decodedOrds.offset;\n      }\n\n      int endPos = decodedOrds.offset + decodedOrds.length;\n      assert currentPos <= endPos;\n\n      if (currentPos == endPos) {\n        // no more FacetLabels\n        return null;\n      }\n\n      int ord = decodedOrds.ints[currentPos++];\n      return taxoReader.getPath(ord);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2b0ae449d456c3d95466275e466ca402ce36f52b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2b0ae449d456c3d95466275e466ca402ce36f52b"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2b0ae449d456c3d95466275e466ca402ce36f52b"],"2b0ae449d456c3d95466275e466ca402ce36f52b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}