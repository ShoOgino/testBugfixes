{"path":"solr/src/java/org/apache/solr/core/SolrCore#close().mjava","commits":[{"id":"893269407f5c988a4b2ee13c7ffc01ec43136c1d","date":1268598046,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         hook.close( this );\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","date":1268599006,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":null,"sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         hook.close( this );\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         hook.close( this );\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         hook.close( this );\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da8d55113b689b06716246649de6f62430f15c0","date":1453508340,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         hook.close( this );\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5984f3962c191f46dc80585c9aefa49208aaabde","date":1279649199,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         hook.close( this );\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         hook.close( this );\n      }\n    }\n  }\n\n","bugFix":["8fe3c163c8df3fb3e4248c30f8ae8034cc786589"],"bugIntro":["e22ffe8cc51a892ae103df018822d7873e901c2a","e22ffe8cc51a892ae103df018822d7873e901c2a","e22ffe8cc51a892ae103df018822d7873e901c2a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         hook.close( this );\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         hook.close( this );\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b05bc1c7371d421d25b9b27324a7dc6e7393911d","date":1287537688,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.close( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n\n\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         hook.close( this );\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["3c8475e39c56b28600d2b496f3e78f7421190f62","3c8475e39c56b28600d2b496f3e78f7421190f62","3c8475e39c56b28600d2b496f3e78f7421190f62","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4ecea1664e8617d82eca3b8055a3c37cb4da8511","date":1287578668,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.close( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n\n\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         hook.close( this );\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.close( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n\n\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         hook.close( this );\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dea805b16da0748ae2eada3c2a449bbb7dcb19","date":1308741523,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.close( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2553b00f699380c64959ccb27991289aae87be2e","date":1309290151,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.close( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.close( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#close().mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#close().mjava","sourceNew":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Close all resources allocated by the core if it is no longer in use...\n   * <ul>\n   *   <li>searcher</li>\n   *   <li>updateHandler</li>\n   *   <li>all CloseHooks will be notified</li>\n   *   <li>All MBeans will be unregistered from MBeanServer if JMX was enabled\n   *       </li>\n   * </ul>\n   * <p>   \n   * <p>\n   * The behavior of this method is determined by the result of decrementing\n   * the core's reference count (A core is created with a refrence count of 1)...\n   * </p>\n   * <ul>\n   *   <li>If reference count is > 0, the usage count is decreased by 1 and no\n   *       resources are released.\n   *   </li>\n   *   <li>If reference count is == 0, the resources are released.\n   *   <li>If reference count is &lt; 0, and error is logged and no further action\n   *       is taken.\n   *   </li>\n   * </ul>\n   * @see #isClosed() \n   */\n  public void close() {\n    int count = refCount.decrementAndGet();\n    if (count > 0) return; // close is called often, and only actually closes if nothing is using it.\n    if (count < 0) {\n      log.error(\"Too many close [count:{}] on {}. Please report this exception to solr-user@lucene.apache.org\", count, this );\n      return;\n    }\n    log.info(logid+\" CLOSING SolrCore \" + this);\n\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.preClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);           \n         }\n      }\n    }\n\n\n    try {\n      infoRegistry.clear();\n    } catch (Exception e) {\n      SolrException.log(log, e);\n    }\n    try {\n      updateHandler.close();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      searcherExecutor.shutdown();\n      if (!searcherExecutor.awaitTermination(60, TimeUnit.SECONDS)) {\n        log.error(\"Timeout waiting for searchExecutor to terminate\");\n      }\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n    try {\n      // Since we waited for the searcherExecutor to shut down,\n      // there should be no more searchers warming in the background\n      // that we need to take care of.\n      //\n      // For the case that a searcher was registered *before* warming\n      // then the searchExecutor will throw an exception when getSearcher()\n      // tries to use it, and the exception handling code should close it.\n      closeSearcher();\n    } catch (Exception e) {\n      SolrException.log(log,e);\n    }\n\n    if( closeHooks != null ) {\n       for( CloseHook hook : closeHooks ) {\n         try {\n           hook.postClose( this );\n         } catch (Throwable e) {\n           SolrException.log(log, e);\n         }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5984f3962c191f46dc80585c9aefa49208aaabde":["1da8d55113b689b06716246649de6f62430f15c0"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"c26f00b574427b55127e869b935845554afde1fa":["b7dea805b16da0748ae2eada3c2a449bbb7dcb19","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"5f4e87790277826a2aea119328600dfb07761f32":["1da8d55113b689b06716246649de6f62430f15c0","5984f3962c191f46dc80585c9aefa49208aaabde"],"2553b00f699380c64959ccb27991289aae87be2e":["b05bc1c7371d421d25b9b27324a7dc6e7393911d","b7dea805b16da0748ae2eada3c2a449bbb7dcb19"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["5f4e87790277826a2aea119328600dfb07761f32","b05bc1c7371d421d25b9b27324a7dc6e7393911d"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["b05bc1c7371d421d25b9b27324a7dc6e7393911d","b7dea805b16da0748ae2eada3c2a449bbb7dcb19"],"1da8d55113b689b06716246649de6f62430f15c0":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","ad94625fb8d088209f46650c8097196fec67f00c"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["2553b00f699380c64959ccb27991289aae87be2e"],"b7dea805b16da0748ae2eada3c2a449bbb7dcb19":["b05bc1c7371d421d25b9b27324a7dc6e7393911d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":["b7dea805b16da0748ae2eada3c2a449bbb7dcb19"],"ad94625fb8d088209f46650c8097196fec67f00c":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"b05bc1c7371d421d25b9b27324a7dc6e7393911d":["5984f3962c191f46dc80585c9aefa49208aaabde"],"4ecea1664e8617d82eca3b8055a3c37cb4da8511":["5984f3962c191f46dc80585c9aefa49208aaabde","b05bc1c7371d421d25b9b27324a7dc6e7393911d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"]},"commit2Childs":{"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"],"5984f3962c191f46dc80585c9aefa49208aaabde":["5f4e87790277826a2aea119328600dfb07761f32","b05bc1c7371d421d25b9b27324a7dc6e7393911d","4ecea1664e8617d82eca3b8055a3c37cb4da8511"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["1da8d55113b689b06716246649de6f62430f15c0"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["ad94625fb8d088209f46650c8097196fec67f00c"],"5f4e87790277826a2aea119328600dfb07761f32":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"2553b00f699380c64959ccb27991289aae87be2e":["c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"1da8d55113b689b06716246649de6f62430f15c0":["5984f3962c191f46dc80585c9aefa49208aaabde","5f4e87790277826a2aea119328600dfb07761f32"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"b7dea805b16da0748ae2eada3c2a449bbb7dcb19":["c26f00b574427b55127e869b935845554afde1fa","2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","a258fbb26824fd104ed795e5d9033d2d040049ee"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"ad94625fb8d088209f46650c8097196fec67f00c":["1da8d55113b689b06716246649de6f62430f15c0"],"b05bc1c7371d421d25b9b27324a7dc6e7393911d":["2553b00f699380c64959ccb27991289aae87be2e","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","d083e83f225b11e5fdd900e83d26ddb385b6955c","b7dea805b16da0748ae2eada3c2a449bbb7dcb19","4ecea1664e8617d82eca3b8055a3c37cb4da8511"],"4ecea1664e8617d82eca3b8055a3c37cb4da8511":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","d083e83f225b11e5fdd900e83d26ddb385b6955c","a258fbb26824fd104ed795e5d9033d2d040049ee","4ecea1664e8617d82eca3b8055a3c37cb4da8511","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}