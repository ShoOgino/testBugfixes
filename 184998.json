{"path":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/PrefixTreeFacetCounter#compute(PrefixTreeStrategy,LeafReaderContext,Bits,Shape,int,FacetVisitor).mjava","commits":[{"id":"478e85d406c2ea05f4e5028248b9a8e43f300885","date":1421346780,"type":0,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/PrefixTreeFacetCounter#compute(PrefixTreeStrategy,LeafReaderContext,Bits,Shape,int,FacetVisitor).mjava","pathOld":"/dev/null","sourceNew":"  /** Lower-level per-leaf segment method. */\n  public static void compute(final PrefixTreeStrategy strategy, final LeafReaderContext context, final Bits acceptDocs,\n                             final Shape queryShape, final int facetLevel, final FacetVisitor facetVisitor)\n      throws IOException {\n    if (acceptDocs != null && acceptDocs.length() != context.reader().maxDoc()) {\n      throw new IllegalArgumentException(\n          \"acceptDocs bits length \" + acceptDocs.length() +\" != leaf maxdoc \" + context.reader().maxDoc());\n    }\n    final SpatialPrefixTree tree = strategy.getGrid();\n\n    //scanLevel is an optimization knob of AbstractVisitingPrefixTreeFilter. It's unlikely\n    // another scanLevel would be much faster and it tends to be a risky knob (can help a little, can hurt a ton).\n    // TODO use RPT's configured scan level?  Do we know better here?  Hard to say.\n    final int scanLevel = tree.getMaxLevels();\n\n    //AbstractVisitingPrefixTreeFilter is a Lucene Filter.  We don't need a filter; we use it for its great prefix-tree\n    // traversal code.  TODO consider refactoring if/when it makes sense (more use cases than this)\n    new AbstractVisitingPrefixTreeFilter(queryShape, strategy.getFieldName(), tree, facetLevel, scanLevel) {\n\n      @Override\n      public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n        assert facetLevel == super.detailLevel;//same thing, FYI. (constant)\n\n        final boolean hasIndexedLeaves = !strategy.isPointsOnly();\n\n        return new VisitorTemplate(context, acceptDocs, hasIndexedLeaves) {\n\n          @Override\n          protected void start() throws IOException {\n            facetVisitor.startOfSegment();\n          }\n\n          @Override\n          protected DocIdSet finish() throws IOException {\n            return null;//unused;\n          }\n\n          @Override\n          protected boolean visit(Cell cell) throws IOException {\n            // At facetLevel...\n            if (cell.getLevel() == facetLevel) {\n              // Count docs\n              visitLeaf(cell);//we're not a leaf but we treat it as such at facet level\n              return false;//don't descend further; this is enough detail\n            }\n\n            // We optimize for discriminating filters (reflected in acceptDocs) and short-circuit if no\n            // matching docs. We could do this at all levels or never but the closer we get to the facet level, the\n            // higher the probability this is worthwhile. We do when docFreq == 1 because it's a cheap check, especially\n            // due to \"pulsing\" in the codec.\n            //TODO this opt should move to VisitorTemplate (which contains an optimization TODO to this effect)\n            if (cell.getLevel() == facetLevel - 1 || termsEnum.docFreq() == 1) {\n              if (!hasDocsAtThisTerm()) {\n                return false;\n              }\n            }\n            return true;\n          }\n\n          @Override\n          protected void visitLeaf(Cell cell) throws IOException {\n            final int count = countDocsAtThisTerm();\n            if (count > 0) {\n              facetVisitor.visit(cell, count);\n            }\n          }\n\n          private int countDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return termsEnum.docFreq();\n            }\n            int count = 0;\n            docsEnum = termsEnum.docs(acceptDocs, docsEnum, DocsEnum.FLAG_NONE);\n            while (docsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            return count;\n          }\n\n          private boolean hasDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return true;\n            }\n            docsEnum = termsEnum.docs(acceptDocs, docsEnum, DocsEnum.FLAG_NONE);\n            return (docsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);\n          }\n\n        }.getDocIdSet();\n      }\n    }.getDocIdSet(context, acceptDocs);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"294167f39e911e101e57b68cfeaf13cb05810e75","date":1421350806,"type":5,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeFacetCounter#compute(PrefixTreeStrategy,LeafReaderContext,Bits,Shape,int,FacetVisitor).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/PrefixTreeFacetCounter#compute(PrefixTreeStrategy,LeafReaderContext,Bits,Shape,int,FacetVisitor).mjava","sourceNew":"  /** Lower-level per-leaf segment method. */\n  public static void compute(final PrefixTreeStrategy strategy, final LeafReaderContext context, final Bits acceptDocs,\n                             final Shape queryShape, final int facetLevel, final FacetVisitor facetVisitor)\n      throws IOException {\n    if (acceptDocs != null && acceptDocs.length() != context.reader().maxDoc()) {\n      throw new IllegalArgumentException(\n          \"acceptDocs bits length \" + acceptDocs.length() +\" != leaf maxdoc \" + context.reader().maxDoc());\n    }\n    final SpatialPrefixTree tree = strategy.getGrid();\n\n    //scanLevel is an optimization knob of AbstractVisitingPrefixTreeFilter. It's unlikely\n    // another scanLevel would be much faster and it tends to be a risky knob (can help a little, can hurt a ton).\n    // TODO use RPT's configured scan level?  Do we know better here?  Hard to say.\n    final int scanLevel = tree.getMaxLevels();\n\n    //AbstractVisitingPrefixTreeFilter is a Lucene Filter.  We don't need a filter; we use it for its great prefix-tree\n    // traversal code.  TODO consider refactoring if/when it makes sense (more use cases than this)\n    new AbstractVisitingPrefixTreeFilter(queryShape, strategy.getFieldName(), tree, facetLevel, scanLevel) {\n\n      @Override\n      public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n        assert facetLevel == super.detailLevel;//same thing, FYI. (constant)\n\n        final boolean hasIndexedLeaves = !strategy.isPointsOnly();\n\n        return new VisitorTemplate(context, acceptDocs, hasIndexedLeaves) {\n\n          @Override\n          protected void start() throws IOException {\n            facetVisitor.startOfSegment();\n          }\n\n          @Override\n          protected DocIdSet finish() throws IOException {\n            return null;//unused;\n          }\n\n          @Override\n          protected boolean visit(Cell cell) throws IOException {\n            // At facetLevel...\n            if (cell.getLevel() == facetLevel) {\n              // Count docs\n              visitLeaf(cell);//we're not a leaf but we treat it as such at facet level\n              return false;//don't descend further; this is enough detail\n            }\n\n            // We optimize for discriminating filters (reflected in acceptDocs) and short-circuit if no\n            // matching docs. We could do this at all levels or never but the closer we get to the facet level, the\n            // higher the probability this is worthwhile. We do when docFreq == 1 because it's a cheap check, especially\n            // due to \"pulsing\" in the codec.\n            //TODO this opt should move to VisitorTemplate (which contains an optimization TODO to this effect)\n            if (cell.getLevel() == facetLevel - 1 || termsEnum.docFreq() == 1) {\n              if (!hasDocsAtThisTerm()) {\n                return false;\n              }\n            }\n            return true;\n          }\n\n          @Override\n          protected void visitLeaf(Cell cell) throws IOException {\n            final int count = countDocsAtThisTerm();\n            if (count > 0) {\n              facetVisitor.visit(cell, count);\n            }\n          }\n\n          private int countDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return termsEnum.docFreq();\n            }\n            int count = 0;\n            docsEnum = termsEnum.docs(acceptDocs, docsEnum, DocsEnum.FLAG_NONE);\n            while (docsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            return count;\n          }\n\n          private boolean hasDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return true;\n            }\n            docsEnum = termsEnum.docs(acceptDocs, docsEnum, DocsEnum.FLAG_NONE);\n            return (docsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);\n          }\n\n        }.getDocIdSet();\n      }\n    }.getDocIdSet(context, acceptDocs);\n  }\n\n","sourceOld":"  /** Lower-level per-leaf segment method. */\n  public static void compute(final PrefixTreeStrategy strategy, final LeafReaderContext context, final Bits acceptDocs,\n                             final Shape queryShape, final int facetLevel, final FacetVisitor facetVisitor)\n      throws IOException {\n    if (acceptDocs != null && acceptDocs.length() != context.reader().maxDoc()) {\n      throw new IllegalArgumentException(\n          \"acceptDocs bits length \" + acceptDocs.length() +\" != leaf maxdoc \" + context.reader().maxDoc());\n    }\n    final SpatialPrefixTree tree = strategy.getGrid();\n\n    //scanLevel is an optimization knob of AbstractVisitingPrefixTreeFilter. It's unlikely\n    // another scanLevel would be much faster and it tends to be a risky knob (can help a little, can hurt a ton).\n    // TODO use RPT's configured scan level?  Do we know better here?  Hard to say.\n    final int scanLevel = tree.getMaxLevels();\n\n    //AbstractVisitingPrefixTreeFilter is a Lucene Filter.  We don't need a filter; we use it for its great prefix-tree\n    // traversal code.  TODO consider refactoring if/when it makes sense (more use cases than this)\n    new AbstractVisitingPrefixTreeFilter(queryShape, strategy.getFieldName(), tree, facetLevel, scanLevel) {\n\n      @Override\n      public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n        assert facetLevel == super.detailLevel;//same thing, FYI. (constant)\n\n        final boolean hasIndexedLeaves = !strategy.isPointsOnly();\n\n        return new VisitorTemplate(context, acceptDocs, hasIndexedLeaves) {\n\n          @Override\n          protected void start() throws IOException {\n            facetVisitor.startOfSegment();\n          }\n\n          @Override\n          protected DocIdSet finish() throws IOException {\n            return null;//unused;\n          }\n\n          @Override\n          protected boolean visit(Cell cell) throws IOException {\n            // At facetLevel...\n            if (cell.getLevel() == facetLevel) {\n              // Count docs\n              visitLeaf(cell);//we're not a leaf but we treat it as such at facet level\n              return false;//don't descend further; this is enough detail\n            }\n\n            // We optimize for discriminating filters (reflected in acceptDocs) and short-circuit if no\n            // matching docs. We could do this at all levels or never but the closer we get to the facet level, the\n            // higher the probability this is worthwhile. We do when docFreq == 1 because it's a cheap check, especially\n            // due to \"pulsing\" in the codec.\n            //TODO this opt should move to VisitorTemplate (which contains an optimization TODO to this effect)\n            if (cell.getLevel() == facetLevel - 1 || termsEnum.docFreq() == 1) {\n              if (!hasDocsAtThisTerm()) {\n                return false;\n              }\n            }\n            return true;\n          }\n\n          @Override\n          protected void visitLeaf(Cell cell) throws IOException {\n            final int count = countDocsAtThisTerm();\n            if (count > 0) {\n              facetVisitor.visit(cell, count);\n            }\n          }\n\n          private int countDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return termsEnum.docFreq();\n            }\n            int count = 0;\n            docsEnum = termsEnum.docs(acceptDocs, docsEnum, DocsEnum.FLAG_NONE);\n            while (docsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            return count;\n          }\n\n          private boolean hasDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return true;\n            }\n            docsEnum = termsEnum.docs(acceptDocs, docsEnum, DocsEnum.FLAG_NONE);\n            return (docsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);\n          }\n\n        }.getDocIdSet();\n      }\n    }.getDocIdSet(context, acceptDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"294167f39e911e101e57b68cfeaf13cb05810e75":["478e85d406c2ea05f4e5028248b9a8e43f300885"],"478e85d406c2ea05f4e5028248b9a8e43f300885":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["294167f39e911e101e57b68cfeaf13cb05810e75"]},"commit2Childs":{"294167f39e911e101e57b68cfeaf13cb05810e75":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"478e85d406c2ea05f4e5028248b9a8e43f300885":["294167f39e911e101e57b68cfeaf13cb05810e75"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["478e85d406c2ea05f4e5028248b9a8e43f300885"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}