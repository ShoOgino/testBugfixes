{"path":"solr/core/src/java/org/apache/solr/store/blockcache/BlockCache#BlockCache(Metrics,boolean,long,int,int).mjava","commits":[{"id":"849494cf2f3a96af5c8c84995108ddd8456fcd04","date":1372277913,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/store/blockcache/BlockCache#BlockCache(Metrics,boolean,long,int,int).mjava","pathOld":"/dev/null","sourceNew":"  public BlockCache(Metrics metrics, boolean directAllocation,\n      long totalMemory, int slabSize, int blockSize) {\n    this.metrics = metrics;\n    numberOfBlocksPerBank = slabSize / blockSize;\n    int numberOfBanks = (int) (totalMemory / slabSize);\n    \n    banks = new ByteBuffer[numberOfBanks];\n    locks = new BlockLocks[numberOfBanks];\n    lockCounters = new AtomicInteger[numberOfBanks];\n    maxEntries = (numberOfBlocksPerBank * numberOfBanks) - 1;\n    for (int i = 0; i < numberOfBanks; i++) {\n      if (directAllocation) {\n        banks[i] = ByteBuffer.allocateDirect(numberOfBlocksPerBank * blockSize);\n      } else {\n        banks[i] = ByteBuffer.allocate(numberOfBlocksPerBank * blockSize);\n      }\n      locks[i] = new BlockLocks(numberOfBlocksPerBank);\n      lockCounters[i] = new AtomicInteger();\n    }\n    \n    EvictionListener<BlockCacheKey,BlockCacheLocation> listener = new EvictionListener<BlockCacheKey,BlockCacheLocation>() {\n      @Override\n      public void onEviction(BlockCacheKey key, BlockCacheLocation location) {\n        releaseLocation(location);\n      }\n    };\n    cache = new ConcurrentLinkedHashMap.Builder<BlockCacheKey,BlockCacheLocation>()\n        .maximumWeightedCapacity(maxEntries).listener(listener).build();\n    this.blockSize = blockSize;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":0,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/store/blockcache/BlockCache#BlockCache(Metrics,boolean,long,int,int).mjava","pathOld":"/dev/null","sourceNew":"  public BlockCache(Metrics metrics, boolean directAllocation,\n      long totalMemory, int slabSize, int blockSize) {\n    this.metrics = metrics;\n    numberOfBlocksPerBank = slabSize / blockSize;\n    int numberOfBanks = (int) (totalMemory / slabSize);\n    \n    banks = new ByteBuffer[numberOfBanks];\n    locks = new BlockLocks[numberOfBanks];\n    lockCounters = new AtomicInteger[numberOfBanks];\n    maxEntries = (numberOfBlocksPerBank * numberOfBanks) - 1;\n    for (int i = 0; i < numberOfBanks; i++) {\n      if (directAllocation) {\n        banks[i] = ByteBuffer.allocateDirect(numberOfBlocksPerBank * blockSize);\n      } else {\n        banks[i] = ByteBuffer.allocate(numberOfBlocksPerBank * blockSize);\n      }\n      locks[i] = new BlockLocks(numberOfBlocksPerBank);\n      lockCounters[i] = new AtomicInteger();\n    }\n    \n    EvictionListener<BlockCacheKey,BlockCacheLocation> listener = new EvictionListener<BlockCacheKey,BlockCacheLocation>() {\n      @Override\n      public void onEviction(BlockCacheKey key, BlockCacheLocation location) {\n        releaseLocation(location);\n      }\n    };\n    cache = new ConcurrentLinkedHashMap.Builder<BlockCacheKey,BlockCacheLocation>()\n        .maximumWeightedCapacity(maxEntries).listener(listener).build();\n    this.blockSize = blockSize;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"da1d30d294dfaad0bb977ab36cb218612d8ffdf9","date":1428517399,"type":3,"author":"Shawn Heisey","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/store/blockcache/BlockCache#BlockCache(Metrics,boolean,long,int,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/store/blockcache/BlockCache#BlockCache(Metrics,boolean,long,int,int).mjava","sourceNew":"  public BlockCache(Metrics metrics, boolean directAllocation,\n      long totalMemory, int slabSize, int blockSize) {\n    this.metrics = metrics;\n    numberOfBlocksPerBank = slabSize / blockSize;\n    int numberOfBanks = (int) (totalMemory / slabSize);\n    \n    banks = new ByteBuffer[numberOfBanks];\n    locks = new BlockLocks[numberOfBanks];\n    lockCounters = new AtomicInteger[numberOfBanks];\n    maxEntries = (numberOfBlocksPerBank * numberOfBanks) - 1;\n    for (int i = 0; i < numberOfBanks; i++) {\n      if (directAllocation) {\n        banks[i] = ByteBuffer.allocateDirect(numberOfBlocksPerBank * blockSize);\n      } else {\n        banks[i] = ByteBuffer.allocate(numberOfBlocksPerBank * blockSize);\n      }\n      locks[i] = new BlockLocks(numberOfBlocksPerBank);\n      lockCounters[i] = new AtomicInteger();\n    }\n\n    RemovalListener<BlockCacheKey,BlockCacheLocation> listener = \n        notification -> releaseLocation(notification.getValue());\n    cache = Caffeine.newBuilder()\n        .removalListener(listener)\n        .maximumSize(maxEntries)\n        .build();\n    this.blockSize = blockSize;\n  }\n\n","sourceOld":"  public BlockCache(Metrics metrics, boolean directAllocation,\n      long totalMemory, int slabSize, int blockSize) {\n    this.metrics = metrics;\n    numberOfBlocksPerBank = slabSize / blockSize;\n    int numberOfBanks = (int) (totalMemory / slabSize);\n    \n    banks = new ByteBuffer[numberOfBanks];\n    locks = new BlockLocks[numberOfBanks];\n    lockCounters = new AtomicInteger[numberOfBanks];\n    maxEntries = (numberOfBlocksPerBank * numberOfBanks) - 1;\n    for (int i = 0; i < numberOfBanks; i++) {\n      if (directAllocation) {\n        banks[i] = ByteBuffer.allocateDirect(numberOfBlocksPerBank * blockSize);\n      } else {\n        banks[i] = ByteBuffer.allocate(numberOfBlocksPerBank * blockSize);\n      }\n      locks[i] = new BlockLocks(numberOfBlocksPerBank);\n      lockCounters[i] = new AtomicInteger();\n    }\n    \n    EvictionListener<BlockCacheKey,BlockCacheLocation> listener = new EvictionListener<BlockCacheKey,BlockCacheLocation>() {\n      @Override\n      public void onEviction(BlockCacheKey key, BlockCacheLocation location) {\n        releaseLocation(location);\n      }\n    };\n    cache = new ConcurrentLinkedHashMap.Builder<BlockCacheKey,BlockCacheLocation>()\n        .maximumWeightedCapacity(maxEntries).listener(listener).build();\n    this.blockSize = blockSize;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e1c058cf6636d4738330f52c3b56f52c0aa8fcc9","date":1479205115,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/store/blockcache/BlockCache#BlockCache(Metrics,boolean,long,int,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/store/blockcache/BlockCache#BlockCache(Metrics,boolean,long,int,int).mjava","sourceNew":"  public BlockCache(Metrics metrics, boolean directAllocation,\n      long totalMemory, int slabSize, int blockSize) {\n    this.metrics = metrics;\n    numberOfBlocksPerBank = slabSize / blockSize;\n    int numberOfBanks = (int) (totalMemory / slabSize);\n    \n    banks = new ByteBuffer[numberOfBanks];\n    locks = new BlockLocks[numberOfBanks];\n    lockCounters = new AtomicInteger[numberOfBanks];\n    maxEntries = (numberOfBlocksPerBank * numberOfBanks) - 1;\n    for (int i = 0; i < numberOfBanks; i++) {\n      if (directAllocation) {\n        banks[i] = ByteBuffer.allocateDirect(numberOfBlocksPerBank * blockSize);\n      } else {\n        banks[i] = ByteBuffer.allocate(numberOfBlocksPerBank * blockSize);\n      }\n      locks[i] = new BlockLocks(numberOfBlocksPerBank);\n      lockCounters[i] = new AtomicInteger();\n    }\n\n    RemovalListener<BlockCacheKey,BlockCacheLocation> listener = \n        notification -> releaseLocation(notification.getKey(), notification.getValue());\n    cache = Caffeine.newBuilder()\n        .removalListener(listener)\n        .maximumSize(maxEntries)\n        .build();\n    this.blockSize = blockSize;\n  }\n\n","sourceOld":"  public BlockCache(Metrics metrics, boolean directAllocation,\n      long totalMemory, int slabSize, int blockSize) {\n    this.metrics = metrics;\n    numberOfBlocksPerBank = slabSize / blockSize;\n    int numberOfBanks = (int) (totalMemory / slabSize);\n    \n    banks = new ByteBuffer[numberOfBanks];\n    locks = new BlockLocks[numberOfBanks];\n    lockCounters = new AtomicInteger[numberOfBanks];\n    maxEntries = (numberOfBlocksPerBank * numberOfBanks) - 1;\n    for (int i = 0; i < numberOfBanks; i++) {\n      if (directAllocation) {\n        banks[i] = ByteBuffer.allocateDirect(numberOfBlocksPerBank * blockSize);\n      } else {\n        banks[i] = ByteBuffer.allocate(numberOfBlocksPerBank * blockSize);\n      }\n      locks[i] = new BlockLocks(numberOfBlocksPerBank);\n      lockCounters[i] = new AtomicInteger();\n    }\n\n    RemovalListener<BlockCacheKey,BlockCacheLocation> listener = \n        notification -> releaseLocation(notification.getValue());\n    cache = Caffeine.newBuilder()\n        .removalListener(listener)\n        .maximumSize(maxEntries)\n        .build();\n    this.blockSize = blockSize;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"21019aa828c8c9b0153877543a8b3f200bf2ca19","date":1479224450,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/store/blockcache/BlockCache#BlockCache(Metrics,boolean,long,int,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/store/blockcache/BlockCache#BlockCache(Metrics,boolean,long,int,int).mjava","sourceNew":"  public BlockCache(Metrics metrics, boolean directAllocation,\n      long totalMemory, int slabSize, int blockSize) {\n    this.metrics = metrics;\n    numberOfBlocksPerBank = slabSize / blockSize;\n    int numberOfBanks = (int) (totalMemory / slabSize);\n    \n    banks = new ByteBuffer[numberOfBanks];\n    locks = new BlockLocks[numberOfBanks];\n    lockCounters = new AtomicInteger[numberOfBanks];\n    maxEntries = (numberOfBlocksPerBank * numberOfBanks) - 1;\n    for (int i = 0; i < numberOfBanks; i++) {\n      if (directAllocation) {\n        banks[i] = ByteBuffer.allocateDirect(numberOfBlocksPerBank * blockSize);\n      } else {\n        banks[i] = ByteBuffer.allocate(numberOfBlocksPerBank * blockSize);\n      }\n      locks[i] = new BlockLocks(numberOfBlocksPerBank);\n      lockCounters[i] = new AtomicInteger();\n    }\n\n    RemovalListener<BlockCacheKey,BlockCacheLocation> listener = \n        notification -> releaseLocation(notification.getKey(), notification.getValue());\n    cache = Caffeine.newBuilder()\n        .removalListener(listener)\n        .maximumSize(maxEntries)\n        .build();\n    this.blockSize = blockSize;\n  }\n\n","sourceOld":"  public BlockCache(Metrics metrics, boolean directAllocation,\n      long totalMemory, int slabSize, int blockSize) {\n    this.metrics = metrics;\n    numberOfBlocksPerBank = slabSize / blockSize;\n    int numberOfBanks = (int) (totalMemory / slabSize);\n    \n    banks = new ByteBuffer[numberOfBanks];\n    locks = new BlockLocks[numberOfBanks];\n    lockCounters = new AtomicInteger[numberOfBanks];\n    maxEntries = (numberOfBlocksPerBank * numberOfBanks) - 1;\n    for (int i = 0; i < numberOfBanks; i++) {\n      if (directAllocation) {\n        banks[i] = ByteBuffer.allocateDirect(numberOfBlocksPerBank * blockSize);\n      } else {\n        banks[i] = ByteBuffer.allocate(numberOfBlocksPerBank * blockSize);\n      }\n      locks[i] = new BlockLocks(numberOfBlocksPerBank);\n      lockCounters[i] = new AtomicInteger();\n    }\n\n    RemovalListener<BlockCacheKey,BlockCacheLocation> listener = \n        notification -> releaseLocation(notification.getValue());\n    cache = Caffeine.newBuilder()\n        .removalListener(listener)\n        .maximumSize(maxEntries)\n        .build();\n    this.blockSize = blockSize;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2fcacd1ac7e3ae3c58c744705673084c77e088f3","date":1487353838,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/store/blockcache/BlockCache#BlockCache(Metrics,boolean,long,int,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/store/blockcache/BlockCache#BlockCache(Metrics,boolean,long,int,int).mjava","sourceNew":"  public BlockCache(Metrics metrics, boolean directAllocation,\n      long totalMemory, int slabSize, int blockSize) {\n    this.metrics = metrics;\n    numberOfBlocksPerBank = slabSize / blockSize;\n    int numberOfBanks = (int) (totalMemory / slabSize);\n    \n    banks = new ByteBuffer[numberOfBanks];\n    locks = new BlockLocks[numberOfBanks];\n    lockCounters = new AtomicInteger[numberOfBanks];\n    maxEntries = (numberOfBlocksPerBank * numberOfBanks) - 1;\n    for (int i = 0; i < numberOfBanks; i++) {\n      if (directAllocation) {\n        banks[i] = ByteBuffer.allocateDirect(numberOfBlocksPerBank * blockSize);\n      } else {\n        banks[i] = ByteBuffer.allocate(numberOfBlocksPerBank * blockSize);\n      }\n      locks[i] = new BlockLocks(numberOfBlocksPerBank);\n      lockCounters[i] = new AtomicInteger();\n    }\n\n    RemovalListener<BlockCacheKey,BlockCacheLocation> listener = (blockCacheKey, blockCacheLocation, removalCause) -> releaseLocation(blockCacheKey, blockCacheLocation);\n\n    cache = Caffeine.newBuilder()\n        .removalListener(listener)\n        .maximumSize(maxEntries)\n        .build();\n    this.blockSize = blockSize;\n  }\n\n","sourceOld":"  public BlockCache(Metrics metrics, boolean directAllocation,\n      long totalMemory, int slabSize, int blockSize) {\n    this.metrics = metrics;\n    numberOfBlocksPerBank = slabSize / blockSize;\n    int numberOfBanks = (int) (totalMemory / slabSize);\n    \n    banks = new ByteBuffer[numberOfBanks];\n    locks = new BlockLocks[numberOfBanks];\n    lockCounters = new AtomicInteger[numberOfBanks];\n    maxEntries = (numberOfBlocksPerBank * numberOfBanks) - 1;\n    for (int i = 0; i < numberOfBanks; i++) {\n      if (directAllocation) {\n        banks[i] = ByteBuffer.allocateDirect(numberOfBlocksPerBank * blockSize);\n      } else {\n        banks[i] = ByteBuffer.allocate(numberOfBlocksPerBank * blockSize);\n      }\n      locks[i] = new BlockLocks(numberOfBlocksPerBank);\n      lockCounters[i] = new AtomicInteger();\n    }\n\n    RemovalListener<BlockCacheKey,BlockCacheLocation> listener = \n        notification -> releaseLocation(notification.getKey(), notification.getValue());\n    cache = Caffeine.newBuilder()\n        .removalListener(listener)\n        .maximumSize(maxEntries)\n        .build();\n    this.blockSize = blockSize;\n  }\n\n","bugFix":null,"bugIntro":["2aeae9008caa3439c2f8b209183da208994812d1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2aeae9008caa3439c2f8b209183da208994812d1","date":1488562773,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/store/blockcache/BlockCache#BlockCache(Metrics,boolean,long,int,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/store/blockcache/BlockCache#BlockCache(Metrics,boolean,long,int,int).mjava","sourceNew":"  public BlockCache(Metrics metrics, boolean directAllocation,\n      long totalMemory, int slabSize, int blockSize) {\n    this.metrics = metrics;\n    numberOfBlocksPerBank = slabSize / blockSize;\n    int numberOfBanks = (int) (totalMemory / slabSize);\n    \n    banks = new ByteBuffer[numberOfBanks];\n    locks = new BlockLocks[numberOfBanks];\n    lockCounters = new AtomicInteger[numberOfBanks];\n    maxEntries = (numberOfBlocksPerBank * numberOfBanks) - 1;\n    for (int i = 0; i < numberOfBanks; i++) {\n      if (directAllocation) {\n        banks[i] = ByteBuffer.allocateDirect(numberOfBlocksPerBank * blockSize);\n      } else {\n        banks[i] = ByteBuffer.allocate(numberOfBlocksPerBank * blockSize);\n      }\n      locks[i] = new BlockLocks(numberOfBlocksPerBank);\n      lockCounters[i] = new AtomicInteger();\n    }\n\n    RemovalListener<BlockCacheKey,BlockCacheLocation> listener = (blockCacheKey, blockCacheLocation, removalCause) -> releaseLocation(blockCacheKey, blockCacheLocation, removalCause);\n\n    cache = Caffeine.newBuilder()\n        .removalListener(listener)\n        .maximumSize(maxEntries)\n        .build();\n    this.blockSize = blockSize;\n  }\n\n","sourceOld":"  public BlockCache(Metrics metrics, boolean directAllocation,\n      long totalMemory, int slabSize, int blockSize) {\n    this.metrics = metrics;\n    numberOfBlocksPerBank = slabSize / blockSize;\n    int numberOfBanks = (int) (totalMemory / slabSize);\n    \n    banks = new ByteBuffer[numberOfBanks];\n    locks = new BlockLocks[numberOfBanks];\n    lockCounters = new AtomicInteger[numberOfBanks];\n    maxEntries = (numberOfBlocksPerBank * numberOfBanks) - 1;\n    for (int i = 0; i < numberOfBanks; i++) {\n      if (directAllocation) {\n        banks[i] = ByteBuffer.allocateDirect(numberOfBlocksPerBank * blockSize);\n      } else {\n        banks[i] = ByteBuffer.allocate(numberOfBlocksPerBank * blockSize);\n      }\n      locks[i] = new BlockLocks(numberOfBlocksPerBank);\n      lockCounters[i] = new AtomicInteger();\n    }\n\n    RemovalListener<BlockCacheKey,BlockCacheLocation> listener = (blockCacheKey, blockCacheLocation, removalCause) -> releaseLocation(blockCacheKey, blockCacheLocation);\n\n    cache = Caffeine.newBuilder()\n        .removalListener(listener)\n        .maximumSize(maxEntries)\n        .build();\n    this.blockSize = blockSize;\n  }\n\n","bugFix":["2fcacd1ac7e3ae3c58c744705673084c77e088f3"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"849494cf2f3a96af5c8c84995108ddd8456fcd04":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2aeae9008caa3439c2f8b209183da208994812d1":["2fcacd1ac7e3ae3c58c744705673084c77e088f3"],"2fcacd1ac7e3ae3c58c744705673084c77e088f3":["e1c058cf6636d4738330f52c3b56f52c0aa8fcc9"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","849494cf2f3a96af5c8c84995108ddd8456fcd04"],"21019aa828c8c9b0153877543a8b3f200bf2ca19":["da1d30d294dfaad0bb977ab36cb218612d8ffdf9","e1c058cf6636d4738330f52c3b56f52c0aa8fcc9"],"e1c058cf6636d4738330f52c3b56f52c0aa8fcc9":["da1d30d294dfaad0bb977ab36cb218612d8ffdf9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2aeae9008caa3439c2f8b209183da208994812d1"],"da1d30d294dfaad0bb977ab36cb218612d8ffdf9":["849494cf2f3a96af5c8c84995108ddd8456fcd04"]},"commit2Childs":{"849494cf2f3a96af5c8c84995108ddd8456fcd04":["37a0f60745e53927c4c876cfe5b5a58170f0646c","da1d30d294dfaad0bb977ab36cb218612d8ffdf9"],"2aeae9008caa3439c2f8b209183da208994812d1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2fcacd1ac7e3ae3c58c744705673084c77e088f3":["2aeae9008caa3439c2f8b209183da208994812d1"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"21019aa828c8c9b0153877543a8b3f200bf2ca19":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["849494cf2f3a96af5c8c84995108ddd8456fcd04","37a0f60745e53927c4c876cfe5b5a58170f0646c"],"e1c058cf6636d4738330f52c3b56f52c0aa8fcc9":["2fcacd1ac7e3ae3c58c744705673084c77e088f3","21019aa828c8c9b0153877543a8b3f200bf2ca19"],"da1d30d294dfaad0bb977ab36cb218612d8ffdf9":["21019aa828c8c9b0153877543a8b3f200bf2ca19","e1c058cf6636d4738330f52c3b56f52c0aa8fcc9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","21019aa828c8c9b0153877543a8b3f200bf2ca19","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}