{"path":"lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer#ReqOptSumScorer(Scorer,Scorer,ScoreMode).mjava","commits":[{"id":"fd80b885e3e9bdc61935e784f634562d13b81979","date":1533736198,"type":1,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer#ReqOptSumScorer(Scorer,Scorer,ScoreMode).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer#ReqOptSumScorer(Scorer,Scorer).mjava","sourceNew":"  /**\n   * Construct a <code>ReqOptScorer</code>.\n   *\n   * @param reqScorer The required scorer. This must match.\n   * @param optScorer The optional scorer. This is used for scoring only.\n   * @param scoreMode  How the produced scorers will be consumed.\n   */\n  public ReqOptSumScorer(Scorer reqScorer, Scorer optScorer, ScoreMode scoreMode) throws IOException {\n    super(reqScorer.weight);\n    assert reqScorer != null;\n    assert optScorer != null;\n    this.reqScorer = reqScorer;\n    this.optScorer = optScorer;\n\n    final TwoPhaseIterator reqTwoPhase = reqScorer.twoPhaseIterator();\n    this.optTwoPhase = optScorer.twoPhaseIterator();\n    if (reqTwoPhase == null) {\n      reqApproximation = reqScorer.iterator();\n    } else {\n      reqApproximation = reqTwoPhase.approximation();\n    }\n    if (optTwoPhase == null) {\n      optApproximation = optScorer.iterator();\n    } else {\n      optApproximation = optTwoPhase.approximation();\n    }\n    if (scoreMode != ScoreMode.TOP_SCORES) {\n      approximation = reqApproximation;\n      this.reqMaxScore = Float.POSITIVE_INFINITY;\n    } else {\n      reqScorer.advanceShallow(0);\n      optScorer.advanceShallow(0);\n      this.reqMaxScore = reqScorer.getMaxScore(NO_MORE_DOCS);\n      this.approximation = new DocIdSetIterator() {\n        int upTo = -1;\n        float maxScore;\n\n        private void moveToNextBlock(int target) throws IOException {\n          upTo = advanceShallow(target);\n          float reqMaxScoreBlock = reqScorer.getMaxScore(upTo);\n          maxScore = getMaxScore(upTo);\n\n          // Potentially move to a conjunction\n          optIsRequired = reqMaxScoreBlock < minScore;\n        }\n\n        private int advanceImpacts(int target) throws IOException {\n          if (target > upTo) {\n            moveToNextBlock(target);\n          }\n\n          while (true) {\n            if (maxScore >= minScore) {\n              return target;\n            }\n\n            if (upTo == NO_MORE_DOCS) {\n              return NO_MORE_DOCS;\n            }\n\n            target = upTo + 1;\n\n            moveToNextBlock(target);\n          }\n        }\n\n        @Override\n        public int nextDoc() throws IOException {\n          return advanceInternal(reqApproximation.docID()+1);\n        }\n\n        @Override\n        public int advance(int target) throws IOException {\n          return advanceInternal(target);\n        }\n\n        private int advanceInternal(int target) throws IOException {\n          if (target == NO_MORE_DOCS) {\n            reqApproximation.advance(target);\n            return NO_MORE_DOCS;\n          }\n          int reqDoc = target;\n          advanceHead: for (;;) {\n            if (minScore != 0) {\n              reqDoc = advanceImpacts(reqDoc);\n            }\n            if (reqApproximation.docID() < reqDoc) {\n              reqDoc = reqApproximation.advance(reqDoc);\n            }\n            if (reqDoc == NO_MORE_DOCS || optIsRequired == false) {\n              return reqDoc;\n            }\n\n            int upperBound = reqMaxScore < minScore ? NO_MORE_DOCS : upTo;\n            if (reqDoc > upperBound) {\n              continue;\n            }\n\n            // Find the next common doc within the current block\n            for (;;) { // invariant: reqDoc >= optDoc\n              int optDoc = optApproximation.docID();\n              if (optDoc < reqDoc) {\n                optDoc = optApproximation.advance(reqDoc);\n              }\n              if (optDoc > upperBound) {\n                reqDoc = upperBound + 1;\n                continue advanceHead;\n              }\n\n              if (optDoc != reqDoc) {\n                reqDoc = reqApproximation.advance(optDoc);\n                if (reqDoc > upperBound) {\n                  continue advanceHead;\n                }\n              }\n\n              if (reqDoc == NO_MORE_DOCS || optDoc == reqDoc) {\n                return reqDoc;\n              }\n            }\n          }\n        }\n\n        @Override\n        public int docID() {\n          return reqApproximation.docID();\n        }\n\n        @Override\n        public long cost() {\n          return reqApproximation.cost();\n        }\n      };\n    }\n\n    if (reqTwoPhase == null && optTwoPhase == null) {\n      this.twoPhase = null;\n    } else {\n      this.twoPhase = new TwoPhaseIterator(approximation) {\n\n        @Override\n        public boolean matches() throws IOException {\n          if (reqTwoPhase != null && reqTwoPhase.matches() == false) {\n            return false;\n          }\n          if (optTwoPhase != null) {\n            if (optIsRequired) {\n              // The below condition is rare and can only happen if we transitioned to optIsRequired=true\n              // after the opt approximation was advanced and before it was confirmed.\n              if (reqScorer.docID() != optApproximation.docID()) {\n                if (optApproximation.docID() < reqScorer.docID()) {\n                  optApproximation.advance(reqScorer.docID());\n                }\n                if (reqScorer.docID() != optApproximation.docID()) {\n                  return false;\n                }\n              }\n              if (optTwoPhase.matches() == false) {\n                // Advance the iterator to make it clear it doesn't match the current doc id\n                optApproximation.nextDoc();\n                return false;\n              }\n            } else if (optApproximation.docID() == reqScorer.docID() && optTwoPhase.matches() == false) {\n              // Advance the iterator to make it clear it doesn't match the current doc id\n              optApproximation.nextDoc();\n            }\n          }\n          return true;\n        }\n\n        @Override\n        public float matchCost() {\n          float matchCost = 1;\n          if (reqTwoPhase != null) {\n            matchCost += reqTwoPhase.matchCost();\n          }\n          if (optTwoPhase != null) {\n            matchCost += optTwoPhase.matchCost();\n          }\n          return matchCost;\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** Construct a <code>ReqOptScorer</code>.\n   * @param reqScorer The required scorer. This must match.\n   * @param optScorer The optional scorer. This is used for scoring only.\n   */\n  public ReqOptSumScorer(\n      Scorer reqScorer,\n      Scorer optScorer) throws IOException\n  {\n    super(reqScorer.weight);\n    assert reqScorer != null;\n    assert optScorer != null;\n    this.reqScorer = reqScorer;\n    this.optScorer = optScorer;\n\n    reqScorer.advanceShallow(0);\n    this.reqMaxScore = reqScorer.getMaxScore(DocIdSetIterator.NO_MORE_DOCS);\n    this.maxScorePropagator = new MaxScoreSumPropagator(Arrays.asList(reqScorer, optScorer));\n\n    final TwoPhaseIterator reqTwoPhase = reqScorer.twoPhaseIterator();\n    this.optTwoPhase = optScorer.twoPhaseIterator();\n    final DocIdSetIterator reqApproximation;\n    if (reqTwoPhase == null) {\n      reqApproximation = reqScorer.iterator();\n    } else {\n      reqApproximation= reqTwoPhase.approximation();\n    }\n    if (optTwoPhase == null) {\n      optApproximation = optScorer.iterator();\n    } else {\n      optApproximation= optTwoPhase.approximation();\n    }\n\n    approximation = new DocIdSetIterator() {\n\n      private int nextCommonDoc(int reqDoc) throws IOException {\n        int optDoc = optApproximation.docID();\n        if (optDoc > reqDoc) {\n          reqDoc = reqApproximation.advance(optDoc);\n        }\n\n        while (true) { // invariant: reqDoc >= optDoc\n          if (reqDoc == optDoc) {\n            return reqDoc;\n          }\n\n          optDoc = optApproximation.advance(reqDoc);\n          if (optDoc == reqDoc) {\n            return reqDoc;\n          }\n          reqDoc = reqApproximation.advance(optDoc);\n        }\n      }\n\n      @Override\n      public int nextDoc() throws IOException {\n        int doc = reqApproximation.nextDoc();\n        if (optIsRequired) {\n          doc = nextCommonDoc(doc);\n        }\n        return doc;\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n        int doc = reqApproximation.advance(target);\n        if (optIsRequired) {\n          doc = nextCommonDoc(doc);\n        }\n        return doc;\n      }\n\n      @Override\n      public int docID() {\n        return reqApproximation.docID();\n      }\n\n      @Override\n      public long cost() {\n        return reqApproximation.cost();\n      }\n\n    };\n\n    if (reqTwoPhase == null && optTwoPhase == null) {\n      this.twoPhase = null;\n    } else {\n      this.twoPhase = new TwoPhaseIterator(approximation) {\n\n        @Override\n        public boolean matches() throws IOException {\n          if (reqTwoPhase != null && reqTwoPhase.matches() == false) {\n            return false;\n          }\n          if (optTwoPhase != null) {\n            if (optIsRequired) {\n              // The below condition is rare and can only happen if we transitioned to optIsRequired=true\n              // after the opt approximation was advanced and before it was confirmed.\n              if (reqScorer.docID() != optApproximation.docID()) {\n                if (optApproximation.docID() < reqScorer.docID()) {\n                  optApproximation.advance(reqScorer.docID());\n                }\n                if (reqScorer.docID() != optApproximation.docID()) {\n                  return false;\n                }\n              }\n              if (optTwoPhase.matches() == false) {\n                // Advance the iterator to make it clear it doesn't match the current doc id\n                optApproximation.nextDoc();\n                return false;\n              }\n            } else if (optApproximation.docID() == reqScorer.docID() && optTwoPhase.matches() == false) {\n              // Advance the iterator to make it clear it doesn't match the current doc id\n              optApproximation.nextDoc();\n            }\n          }\n          return true;\n        }\n\n        @Override\n        public float matchCost() {\n          float matchCost = 1;\n          if (reqTwoPhase != null) {\n            matchCost += reqTwoPhase.matchCost();\n          }\n          if (optTwoPhase != null) {\n            matchCost += optTwoPhase.matchCost();\n          }\n          return matchCost;\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"12789a348ea3f09c9c3b71488cfa1c32da08b2a3","date":1534270167,"type":3,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer#ReqOptSumScorer(Scorer,Scorer,ScoreMode).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer#ReqOptSumScorer(Scorer,Scorer,ScoreMode).mjava","sourceNew":"  /**\n   * Construct a <code>ReqOptScorer</code>.\n   *\n   * @param reqScorer The required scorer. This must match.\n   * @param optScorer The optional scorer. This is used for scoring only.\n   * @param scoreMode  How the produced scorers will be consumed.\n   */\n  public ReqOptSumScorer(Scorer reqScorer, Scorer optScorer, ScoreMode scoreMode) throws IOException {\n    super(reqScorer.weight);\n    assert reqScorer != null;\n    assert optScorer != null;\n    if (scoreMode == ScoreMode.TOP_SCORES) {\n      this.maxScorePropagator = new MaxScoreSumPropagator(Arrays.asList(reqScorer, optScorer));\n    } else {\n      this.maxScorePropagator = null;\n    }\n    this.reqScorer = reqScorer;\n    this.optScorer = optScorer;\n\n    final TwoPhaseIterator reqTwoPhase = reqScorer.twoPhaseIterator();\n    this.optTwoPhase = optScorer.twoPhaseIterator();\n    if (reqTwoPhase == null) {\n      reqApproximation = reqScorer.iterator();\n    } else {\n      reqApproximation = reqTwoPhase.approximation();\n    }\n    if (optTwoPhase == null) {\n      optApproximation = optScorer.iterator();\n    } else {\n      optApproximation = optTwoPhase.approximation();\n    }\n    if (scoreMode != ScoreMode.TOP_SCORES) {\n      approximation = reqApproximation;\n      this.reqMaxScore = Float.POSITIVE_INFINITY;\n    } else {\n      reqScorer.advanceShallow(0);\n      optScorer.advanceShallow(0);\n      this.reqMaxScore = reqScorer.getMaxScore(NO_MORE_DOCS);\n      this.approximation = new DocIdSetIterator() {\n        int upTo = -1;\n        float maxScore;\n\n        private void moveToNextBlock(int target) throws IOException {\n          upTo = advanceShallow(target);\n          float reqMaxScoreBlock = reqScorer.getMaxScore(upTo);\n          maxScore = getMaxScore(upTo);\n\n          // Potentially move to a conjunction\n          optIsRequired = reqMaxScoreBlock < minScore;\n        }\n\n        private int advanceImpacts(int target) throws IOException {\n          if (target > upTo) {\n            moveToNextBlock(target);\n          }\n\n          while (true) {\n            if (maxScore >= minScore) {\n              return target;\n            }\n\n            if (upTo == NO_MORE_DOCS) {\n              return NO_MORE_DOCS;\n            }\n\n            target = upTo + 1;\n\n            moveToNextBlock(target);\n          }\n        }\n\n        @Override\n        public int nextDoc() throws IOException {\n          return advanceInternal(reqApproximation.docID()+1);\n        }\n\n        @Override\n        public int advance(int target) throws IOException {\n          return advanceInternal(target);\n        }\n\n        private int advanceInternal(int target) throws IOException {\n          if (target == NO_MORE_DOCS) {\n            reqApproximation.advance(target);\n            return NO_MORE_DOCS;\n          }\n          int reqDoc = target;\n          advanceHead: for (;;) {\n            if (minScore != 0) {\n              reqDoc = advanceImpacts(reqDoc);\n            }\n            if (reqApproximation.docID() < reqDoc) {\n              reqDoc = reqApproximation.advance(reqDoc);\n            }\n            if (reqDoc == NO_MORE_DOCS || optIsRequired == false) {\n              return reqDoc;\n            }\n\n            int upperBound = reqMaxScore < minScore ? NO_MORE_DOCS : upTo;\n            if (reqDoc > upperBound) {\n              continue;\n            }\n\n            // Find the next common doc within the current block\n            for (;;) { // invariant: reqDoc >= optDoc\n              int optDoc = optApproximation.docID();\n              if (optDoc < reqDoc) {\n                optDoc = optApproximation.advance(reqDoc);\n              }\n              if (optDoc > upperBound) {\n                reqDoc = upperBound + 1;\n                continue advanceHead;\n              }\n\n              if (optDoc != reqDoc) {\n                reqDoc = reqApproximation.advance(optDoc);\n                if (reqDoc > upperBound) {\n                  continue advanceHead;\n                }\n              }\n\n              if (reqDoc == NO_MORE_DOCS || optDoc == reqDoc) {\n                return reqDoc;\n              }\n            }\n          }\n        }\n\n        @Override\n        public int docID() {\n          return reqApproximation.docID();\n        }\n\n        @Override\n        public long cost() {\n          return reqApproximation.cost();\n        }\n      };\n    }\n\n    if (reqTwoPhase == null && optTwoPhase == null) {\n      this.twoPhase = null;\n    } else {\n      this.twoPhase = new TwoPhaseIterator(approximation) {\n\n        @Override\n        public boolean matches() throws IOException {\n          if (reqTwoPhase != null && reqTwoPhase.matches() == false) {\n            return false;\n          }\n          if (optTwoPhase != null) {\n            if (optIsRequired) {\n              // The below condition is rare and can only happen if we transitioned to optIsRequired=true\n              // after the opt approximation was advanced and before it was confirmed.\n              if (reqScorer.docID() != optApproximation.docID()) {\n                if (optApproximation.docID() < reqScorer.docID()) {\n                  optApproximation.advance(reqScorer.docID());\n                }\n                if (reqScorer.docID() != optApproximation.docID()) {\n                  return false;\n                }\n              }\n              if (optTwoPhase.matches() == false) {\n                // Advance the iterator to make it clear it doesn't match the current doc id\n                optApproximation.nextDoc();\n                return false;\n              }\n            } else if (optApproximation.docID() == reqScorer.docID() && optTwoPhase.matches() == false) {\n              // Advance the iterator to make it clear it doesn't match the current doc id\n              optApproximation.nextDoc();\n            }\n          }\n          return true;\n        }\n\n        @Override\n        public float matchCost() {\n          float matchCost = 1;\n          if (reqTwoPhase != null) {\n            matchCost += reqTwoPhase.matchCost();\n          }\n          if (optTwoPhase != null) {\n            matchCost += optTwoPhase.matchCost();\n          }\n          return matchCost;\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /**\n   * Construct a <code>ReqOptScorer</code>.\n   *\n   * @param reqScorer The required scorer. This must match.\n   * @param optScorer The optional scorer. This is used for scoring only.\n   * @param scoreMode  How the produced scorers will be consumed.\n   */\n  public ReqOptSumScorer(Scorer reqScorer, Scorer optScorer, ScoreMode scoreMode) throws IOException {\n    super(reqScorer.weight);\n    assert reqScorer != null;\n    assert optScorer != null;\n    this.reqScorer = reqScorer;\n    this.optScorer = optScorer;\n\n    final TwoPhaseIterator reqTwoPhase = reqScorer.twoPhaseIterator();\n    this.optTwoPhase = optScorer.twoPhaseIterator();\n    if (reqTwoPhase == null) {\n      reqApproximation = reqScorer.iterator();\n    } else {\n      reqApproximation = reqTwoPhase.approximation();\n    }\n    if (optTwoPhase == null) {\n      optApproximation = optScorer.iterator();\n    } else {\n      optApproximation = optTwoPhase.approximation();\n    }\n    if (scoreMode != ScoreMode.TOP_SCORES) {\n      approximation = reqApproximation;\n      this.reqMaxScore = Float.POSITIVE_INFINITY;\n    } else {\n      reqScorer.advanceShallow(0);\n      optScorer.advanceShallow(0);\n      this.reqMaxScore = reqScorer.getMaxScore(NO_MORE_DOCS);\n      this.approximation = new DocIdSetIterator() {\n        int upTo = -1;\n        float maxScore;\n\n        private void moveToNextBlock(int target) throws IOException {\n          upTo = advanceShallow(target);\n          float reqMaxScoreBlock = reqScorer.getMaxScore(upTo);\n          maxScore = getMaxScore(upTo);\n\n          // Potentially move to a conjunction\n          optIsRequired = reqMaxScoreBlock < minScore;\n        }\n\n        private int advanceImpacts(int target) throws IOException {\n          if (target > upTo) {\n            moveToNextBlock(target);\n          }\n\n          while (true) {\n            if (maxScore >= minScore) {\n              return target;\n            }\n\n            if (upTo == NO_MORE_DOCS) {\n              return NO_MORE_DOCS;\n            }\n\n            target = upTo + 1;\n\n            moveToNextBlock(target);\n          }\n        }\n\n        @Override\n        public int nextDoc() throws IOException {\n          return advanceInternal(reqApproximation.docID()+1);\n        }\n\n        @Override\n        public int advance(int target) throws IOException {\n          return advanceInternal(target);\n        }\n\n        private int advanceInternal(int target) throws IOException {\n          if (target == NO_MORE_DOCS) {\n            reqApproximation.advance(target);\n            return NO_MORE_DOCS;\n          }\n          int reqDoc = target;\n          advanceHead: for (;;) {\n            if (minScore != 0) {\n              reqDoc = advanceImpacts(reqDoc);\n            }\n            if (reqApproximation.docID() < reqDoc) {\n              reqDoc = reqApproximation.advance(reqDoc);\n            }\n            if (reqDoc == NO_MORE_DOCS || optIsRequired == false) {\n              return reqDoc;\n            }\n\n            int upperBound = reqMaxScore < minScore ? NO_MORE_DOCS : upTo;\n            if (reqDoc > upperBound) {\n              continue;\n            }\n\n            // Find the next common doc within the current block\n            for (;;) { // invariant: reqDoc >= optDoc\n              int optDoc = optApproximation.docID();\n              if (optDoc < reqDoc) {\n                optDoc = optApproximation.advance(reqDoc);\n              }\n              if (optDoc > upperBound) {\n                reqDoc = upperBound + 1;\n                continue advanceHead;\n              }\n\n              if (optDoc != reqDoc) {\n                reqDoc = reqApproximation.advance(optDoc);\n                if (reqDoc > upperBound) {\n                  continue advanceHead;\n                }\n              }\n\n              if (reqDoc == NO_MORE_DOCS || optDoc == reqDoc) {\n                return reqDoc;\n              }\n            }\n          }\n        }\n\n        @Override\n        public int docID() {\n          return reqApproximation.docID();\n        }\n\n        @Override\n        public long cost() {\n          return reqApproximation.cost();\n        }\n      };\n    }\n\n    if (reqTwoPhase == null && optTwoPhase == null) {\n      this.twoPhase = null;\n    } else {\n      this.twoPhase = new TwoPhaseIterator(approximation) {\n\n        @Override\n        public boolean matches() throws IOException {\n          if (reqTwoPhase != null && reqTwoPhase.matches() == false) {\n            return false;\n          }\n          if (optTwoPhase != null) {\n            if (optIsRequired) {\n              // The below condition is rare and can only happen if we transitioned to optIsRequired=true\n              // after the opt approximation was advanced and before it was confirmed.\n              if (reqScorer.docID() != optApproximation.docID()) {\n                if (optApproximation.docID() < reqScorer.docID()) {\n                  optApproximation.advance(reqScorer.docID());\n                }\n                if (reqScorer.docID() != optApproximation.docID()) {\n                  return false;\n                }\n              }\n              if (optTwoPhase.matches() == false) {\n                // Advance the iterator to make it clear it doesn't match the current doc id\n                optApproximation.nextDoc();\n                return false;\n              }\n            } else if (optApproximation.docID() == reqScorer.docID() && optTwoPhase.matches() == false) {\n              // Advance the iterator to make it clear it doesn't match the current doc id\n              optApproximation.nextDoc();\n            }\n          }\n          return true;\n        }\n\n        @Override\n        public float matchCost() {\n          float matchCost = 1;\n          if (reqTwoPhase != null) {\n            matchCost += reqTwoPhase.matchCost();\n          }\n          if (optTwoPhase != null) {\n            matchCost += optTwoPhase.matchCost();\n          }\n          return matchCost;\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"12789a348ea3f09c9c3b71488cfa1c32da08b2a3":["fd80b885e3e9bdc61935e784f634562d13b81979"],"fd80b885e3e9bdc61935e784f634562d13b81979":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["12789a348ea3f09c9c3b71488cfa1c32da08b2a3"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fd80b885e3e9bdc61935e784f634562d13b81979"],"12789a348ea3f09c9c3b71488cfa1c32da08b2a3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fd80b885e3e9bdc61935e784f634562d13b81979":["12789a348ea3f09c9c3b71488cfa1c32da08b2a3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}