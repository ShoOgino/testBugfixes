{"path":"lucene/sandbox/src/test/org/apache/lucene/document/BaseShapeEncodingTestCase#verifyEncoding(double,double,double,double,double,double).mjava","commits":[{"id":"c286b0d8c507a88b289407e2fe161effa275c6b0","date":1562615977,"type":1,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/BaseShapeEncodingTestCase#verifyEncoding(double,double,double,double,double,double).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonShapeEncoding#verifyEncoding(double,double,double,double,double,double).mjava","sourceNew":"  private void verifyEncoding(double ay, double ax, double by, double bx, double cy, double cx) {\n    int[] original = new int[]{\n        encodeY(ay),\n        encodeX(ax),\n        encodeY(by),\n        encodeX(bx),\n        encodeY(cy),\n        encodeX(cx)};\n\n    //quantize the triangle\n    byte[] b = new byte[7 * ShapeField.BYTES];\n    ShapeField.encodeTriangle(b, original[0], original[1], original[2], original[3], original[4], original[5]);\n    int[] encoded = new int[6];\n    ShapeField.decodeTriangle(b, encoded);\n    double[] encodedQuantize = new double[] {\n        decodeY(encoded[0]),\n        decodeX(encoded[1]),\n        decodeY(encoded[2]),\n        decodeX(encoded[3]),\n        decodeY(encoded[4]),\n        decodeX(encoded[5])};\n\n    int orientation = GeoUtils.orient(original[1], original[0], original[3], original[2], original[5], original[4]);\n    //quantize original\n    double[] originalQuantize;\n    //we need to change the orientation if CW\n    if (orientation == -1) {\n      originalQuantize = new double[] {\n          decodeY(original[4]),\n          decodeX(original[5]),\n          decodeY(original[2]),\n          decodeX(original[3]),\n          decodeY(original[0]),\n          decodeX(original[1])};\n    } else {\n      originalQuantize = new double[] {\n          decodeY(original[0]),\n          decodeX(original[1]),\n          decodeY(original[2]),\n          decodeX(original[3]),\n          decodeY(original[4]),\n          decodeX(original[5])};\n    }\n\n    for (int i =0; i < 100; i ++) {\n      Polygon2D polygon2D = createPolygon2D(nextPolygon());\n      PointValues.Relation originalRelation = polygon2D.relateTriangle(originalQuantize[1], originalQuantize[0], originalQuantize[3], originalQuantize[2], originalQuantize[5], originalQuantize[4]);\n      PointValues.Relation encodedRelation = polygon2D.relateTriangle(encodedQuantize[1], encodedQuantize[0], encodedQuantize[3], encodedQuantize[2], encodedQuantize[5], encodedQuantize[4]);\n      assertTrue(originalRelation == encodedRelation);\n    }\n  }\n\n","sourceOld":"  private void verifyEncoding(double alat, double alon, double blat, double blon, double clat, double clon) {\n    int[] original = new int[]{GeoEncodingUtils.encodeLatitude(alat),\n        GeoEncodingUtils.encodeLongitude(alon),\n        GeoEncodingUtils.encodeLatitude(blat),\n        GeoEncodingUtils.encodeLongitude(blon),\n        GeoEncodingUtils.encodeLatitude(clat),\n        GeoEncodingUtils.encodeLongitude(clon)};\n\n    //quantize the triangle\n    byte[] b = new byte[7 * LatLonShape.BYTES];\n    LatLonShape.encodeTriangle(b, original[0], original[1], original[2], original[3], original[4], original[5]);\n    int[] encoded = new int[6];\n    LatLonShape.decodeTriangle(b, encoded);\n    double[] encodedQuantize = new double[] {GeoEncodingUtils.decodeLatitude(encoded[0]),\n        GeoEncodingUtils.decodeLongitude(encoded[1]),\n        GeoEncodingUtils.decodeLatitude(encoded[2]),\n        GeoEncodingUtils.decodeLongitude(encoded[3]),\n        GeoEncodingUtils.decodeLatitude(encoded[4]),\n        GeoEncodingUtils.decodeLongitude(encoded[5])};\n\n    int orientation = GeoUtils.orient(original[1], original[0], original[3], original[2], original[5], original[4]);\n    //quantize original\n    double[] originalQuantize;\n    //we need to change the orientation if CW\n    if (orientation == -1) {\n      originalQuantize = new double[] {GeoEncodingUtils.decodeLatitude(original[4]),\n          GeoEncodingUtils.decodeLongitude(original[5]),\n          GeoEncodingUtils.decodeLatitude(original[2]),\n          GeoEncodingUtils.decodeLongitude(original[3]),\n          GeoEncodingUtils.decodeLatitude(original[0]),\n          GeoEncodingUtils.decodeLongitude(original[1])};\n    } else {\n      originalQuantize = new double[] {GeoEncodingUtils.decodeLatitude(original[0]),\n          GeoEncodingUtils.decodeLongitude(original[1]),\n          GeoEncodingUtils.decodeLatitude(original[2]),\n          GeoEncodingUtils.decodeLongitude(original[3]),\n          GeoEncodingUtils.decodeLatitude(original[4]),\n          GeoEncodingUtils.decodeLongitude(original[5])};\n    }\n\n    for (int i =0; i < 100; i ++) {\n      Polygon polygon = GeoTestUtil.nextPolygon();\n      Polygon2D polygon2D = Polygon2D.create(polygon);\n      PointValues.Relation originalRelation = polygon2D.relateTriangle(originalQuantize[1], originalQuantize[0], originalQuantize[3], originalQuantize[2], originalQuantize[5], originalQuantize[4]);\n      PointValues.Relation encodedRelation = polygon2D.relateTriangle(encodedQuantize[1], encodedQuantize[0], encodedQuantize[3], encodedQuantize[2], encodedQuantize[5], encodedQuantize[4]);\n      assertTrue(originalRelation == encodedRelation);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ed90f8ba7e7be13d155f954862178b23a324125","date":1568020603,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/BaseShapeEncodingTestCase#verifyEncoding(double,double,double,double,double,double).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/BaseShapeEncodingTestCase#verifyEncoding(double,double,double,double,double,double).mjava","sourceNew":"  private void verifyEncoding(double ay, double ax, double by, double bx, double cy, double cx) {\n    int[] original = new int[]{\n        encodeY(ay),\n        encodeX(ax),\n        encodeY(by),\n        encodeX(bx),\n        encodeY(cy),\n        encodeX(cx)};\n\n    //quantize the triangle\n    byte[] b = new byte[7 * ShapeField.BYTES];\n    ShapeField.encodeTriangle(b, original[0], original[1], true, original[2], original[3], true, original[4], original[5], true);\n    ShapeField.DecodedTriangle encoded = new ShapeField.DecodedTriangle();\n    ShapeField.decodeTriangle(b, encoded);\n    double[] encodedQuantize = new double[] {\n        decodeY(encoded.aY),\n        decodeX(encoded.aX),\n        decodeY(encoded.bY),\n        decodeX(encoded.bX),\n        decodeY(encoded.cY),\n        decodeX(encoded.cX)};\n\n    int orientation = GeoUtils.orient(original[1], original[0], original[3], original[2], original[5], original[4]);\n    //quantize original\n    double[] originalQuantize;\n    //we need to change the orientation if CW\n    if (orientation == -1) {\n      originalQuantize = new double[] {\n          decodeY(original[4]),\n          decodeX(original[5]),\n          decodeY(original[2]),\n          decodeX(original[3]),\n          decodeY(original[0]),\n          decodeX(original[1])};\n    } else {\n      originalQuantize = new double[] {\n          decodeY(original[0]),\n          decodeX(original[1]),\n          decodeY(original[2]),\n          decodeX(original[3]),\n          decodeY(original[4]),\n          decodeX(original[5])};\n    }\n\n    for (int i =0; i < 100; i ++) {\n      Polygon2D polygon2D = createPolygon2D(nextPolygon());\n      PointValues.Relation originalRelation = polygon2D.relateTriangle(originalQuantize[1], originalQuantize[0], originalQuantize[3], originalQuantize[2], originalQuantize[5], originalQuantize[4]);\n      PointValues.Relation encodedRelation = polygon2D.relateTriangle(encodedQuantize[1], encodedQuantize[0], encodedQuantize[3], encodedQuantize[2], encodedQuantize[5], encodedQuantize[4]);\n      assertTrue(originalRelation == encodedRelation);\n    }\n  }\n\n","sourceOld":"  private void verifyEncoding(double ay, double ax, double by, double bx, double cy, double cx) {\n    int[] original = new int[]{\n        encodeY(ay),\n        encodeX(ax),\n        encodeY(by),\n        encodeX(bx),\n        encodeY(cy),\n        encodeX(cx)};\n\n    //quantize the triangle\n    byte[] b = new byte[7 * ShapeField.BYTES];\n    ShapeField.encodeTriangle(b, original[0], original[1], original[2], original[3], original[4], original[5]);\n    int[] encoded = new int[6];\n    ShapeField.decodeTriangle(b, encoded);\n    double[] encodedQuantize = new double[] {\n        decodeY(encoded[0]),\n        decodeX(encoded[1]),\n        decodeY(encoded[2]),\n        decodeX(encoded[3]),\n        decodeY(encoded[4]),\n        decodeX(encoded[5])};\n\n    int orientation = GeoUtils.orient(original[1], original[0], original[3], original[2], original[5], original[4]);\n    //quantize original\n    double[] originalQuantize;\n    //we need to change the orientation if CW\n    if (orientation == -1) {\n      originalQuantize = new double[] {\n          decodeY(original[4]),\n          decodeX(original[5]),\n          decodeY(original[2]),\n          decodeX(original[3]),\n          decodeY(original[0]),\n          decodeX(original[1])};\n    } else {\n      originalQuantize = new double[] {\n          decodeY(original[0]),\n          decodeX(original[1]),\n          decodeY(original[2]),\n          decodeX(original[3]),\n          decodeY(original[4]),\n          decodeX(original[5])};\n    }\n\n    for (int i =0; i < 100; i ++) {\n      Polygon2D polygon2D = createPolygon2D(nextPolygon());\n      PointValues.Relation originalRelation = polygon2D.relateTriangle(originalQuantize[1], originalQuantize[0], originalQuantize[3], originalQuantize[2], originalQuantize[5], originalQuantize[4]);\n      PointValues.Relation encodedRelation = polygon2D.relateTriangle(encodedQuantize[1], encodedQuantize[0], encodedQuantize[3], encodedQuantize[2], encodedQuantize[5], encodedQuantize[4]);\n      assertTrue(originalRelation == encodedRelation);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b5e250f1fb163f190f5ec72b6eeb8271162d8ae1","date":1571074565,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/BaseShapeEncodingTestCase#verifyEncoding(double,double,double,double,double,double).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/BaseShapeEncodingTestCase#verifyEncoding(double,double,double,double,double,double).mjava","sourceNew":"  private void verifyEncoding(double ay, double ax, double by, double bx, double cy, double cx) {\n    int[] original = new int[]{\n        encodeY(ay),\n        encodeX(ax),\n        encodeY(by),\n        encodeX(bx),\n        encodeY(cy),\n        encodeX(cx)};\n\n    //quantize the triangle\n    byte[] b = new byte[7 * ShapeField.BYTES];\n    ShapeField.encodeTriangle(b, original[0], original[1], true, original[2], original[3], true, original[4], original[5], true);\n    ShapeField.DecodedTriangle encoded = new ShapeField.DecodedTriangle();\n    ShapeField.decodeTriangle(b, encoded);\n    double[] encodedQuantize = new double[] {\n        decodeY(encoded.aY),\n        decodeX(encoded.aX),\n        decodeY(encoded.bY),\n        decodeX(encoded.bX),\n        decodeY(encoded.cY),\n        decodeX(encoded.cX)};\n\n    int orientation = GeoUtils.orient(original[1], original[0], original[3], original[2], original[5], original[4]);\n    //quantize original\n    double[] originalQuantize;\n    //we need to change the orientation if CW\n    if (orientation == -1) {\n      originalQuantize = new double[] {\n          decodeY(original[4]),\n          decodeX(original[5]),\n          decodeY(original[2]),\n          decodeX(original[3]),\n          decodeY(original[0]),\n          decodeX(original[1])};\n    } else {\n      originalQuantize = new double[] {\n          decodeY(original[0]),\n          decodeX(original[1]),\n          decodeY(original[2]),\n          decodeX(original[3]),\n          decodeY(original[4]),\n          decodeX(original[5])};\n    }\n\n    for (int i =0; i < 100; i ++) {\n      Component2D polygon2D = createPolygon2D(nextPolygon());\n      PointValues.Relation originalRelation = polygon2D.relateTriangle(originalQuantize[1], originalQuantize[0], originalQuantize[3], originalQuantize[2], originalQuantize[5], originalQuantize[4]);\n      PointValues.Relation encodedRelation = polygon2D.relateTriangle(encodedQuantize[1], encodedQuantize[0], encodedQuantize[3], encodedQuantize[2], encodedQuantize[5], encodedQuantize[4]);\n      assertTrue(originalRelation == encodedRelation);\n    }\n  }\n\n","sourceOld":"  private void verifyEncoding(double ay, double ax, double by, double bx, double cy, double cx) {\n    int[] original = new int[]{\n        encodeY(ay),\n        encodeX(ax),\n        encodeY(by),\n        encodeX(bx),\n        encodeY(cy),\n        encodeX(cx)};\n\n    //quantize the triangle\n    byte[] b = new byte[7 * ShapeField.BYTES];\n    ShapeField.encodeTriangle(b, original[0], original[1], true, original[2], original[3], true, original[4], original[5], true);\n    ShapeField.DecodedTriangle encoded = new ShapeField.DecodedTriangle();\n    ShapeField.decodeTriangle(b, encoded);\n    double[] encodedQuantize = new double[] {\n        decodeY(encoded.aY),\n        decodeX(encoded.aX),\n        decodeY(encoded.bY),\n        decodeX(encoded.bX),\n        decodeY(encoded.cY),\n        decodeX(encoded.cX)};\n\n    int orientation = GeoUtils.orient(original[1], original[0], original[3], original[2], original[5], original[4]);\n    //quantize original\n    double[] originalQuantize;\n    //we need to change the orientation if CW\n    if (orientation == -1) {\n      originalQuantize = new double[] {\n          decodeY(original[4]),\n          decodeX(original[5]),\n          decodeY(original[2]),\n          decodeX(original[3]),\n          decodeY(original[0]),\n          decodeX(original[1])};\n    } else {\n      originalQuantize = new double[] {\n          decodeY(original[0]),\n          decodeX(original[1]),\n          decodeY(original[2]),\n          decodeX(original[3]),\n          decodeY(original[4]),\n          decodeX(original[5])};\n    }\n\n    for (int i =0; i < 100; i ++) {\n      Polygon2D polygon2D = createPolygon2D(nextPolygon());\n      PointValues.Relation originalRelation = polygon2D.relateTriangle(originalQuantize[1], originalQuantize[0], originalQuantize[3], originalQuantize[2], originalQuantize[5], originalQuantize[4]);\n      PointValues.Relation encodedRelation = polygon2D.relateTriangle(encodedQuantize[1], encodedQuantize[0], encodedQuantize[3], encodedQuantize[2], encodedQuantize[5], encodedQuantize[4]);\n      assertTrue(originalRelation == encodedRelation);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/BaseShapeEncodingTestCase#verifyEncoding(double,double,double,double,double,double).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/BaseShapeEncodingTestCase#verifyEncoding(double,double,double,double,double,double).mjava","sourceNew":"  private void verifyEncoding(double ay, double ax, double by, double bx, double cy, double cx) {\n    int[] original = new int[]{\n        encodeY(ay),\n        encodeX(ax),\n        encodeY(by),\n        encodeX(bx),\n        encodeY(cy),\n        encodeX(cx)};\n\n    //quantize the triangle\n    byte[] b = new byte[7 * ShapeField.BYTES];\n    ShapeField.encodeTriangle(b, original[0], original[1], true, original[2], original[3], true, original[4], original[5], true);\n    ShapeField.DecodedTriangle encoded = new ShapeField.DecodedTriangle();\n    ShapeField.decodeTriangle(b, encoded);\n    double[] encodedQuantize = new double[] {\n        decodeY(encoded.aY),\n        decodeX(encoded.aX),\n        decodeY(encoded.bY),\n        decodeX(encoded.bX),\n        decodeY(encoded.cY),\n        decodeX(encoded.cX)};\n\n    int orientation = GeoUtils.orient(original[1], original[0], original[3], original[2], original[5], original[4]);\n    //quantize original\n    double[] originalQuantize;\n    //we need to change the orientation if CW\n    if (orientation == -1) {\n      originalQuantize = new double[] {\n          decodeY(original[4]),\n          decodeX(original[5]),\n          decodeY(original[2]),\n          decodeX(original[3]),\n          decodeY(original[0]),\n          decodeX(original[1])};\n    } else {\n      originalQuantize = new double[] {\n          decodeY(original[0]),\n          decodeX(original[1]),\n          decodeY(original[2]),\n          decodeX(original[3]),\n          decodeY(original[4]),\n          decodeX(original[5])};\n    }\n\n    for (int i =0; i < 100; i ++) {\n      Component2D polygon2D = createPolygon2D(nextPolygon());\n      PointValues.Relation originalRelation = polygon2D.relateTriangle(originalQuantize[1], originalQuantize[0], originalQuantize[3], originalQuantize[2], originalQuantize[5], originalQuantize[4]);\n      PointValues.Relation encodedRelation = polygon2D.relateTriangle(encodedQuantize[1], encodedQuantize[0], encodedQuantize[3], encodedQuantize[2], encodedQuantize[5], encodedQuantize[4]);\n      assertTrue(originalRelation == encodedRelation);\n    }\n  }\n\n","sourceOld":"  private void verifyEncoding(double ay, double ax, double by, double bx, double cy, double cx) {\n    int[] original = new int[]{\n        encodeY(ay),\n        encodeX(ax),\n        encodeY(by),\n        encodeX(bx),\n        encodeY(cy),\n        encodeX(cx)};\n\n    //quantize the triangle\n    byte[] b = new byte[7 * ShapeField.BYTES];\n    ShapeField.encodeTriangle(b, original[0], original[1], true, original[2], original[3], true, original[4], original[5], true);\n    ShapeField.DecodedTriangle encoded = new ShapeField.DecodedTriangle();\n    ShapeField.decodeTriangle(b, encoded);\n    double[] encodedQuantize = new double[] {\n        decodeY(encoded.aY),\n        decodeX(encoded.aX),\n        decodeY(encoded.bY),\n        decodeX(encoded.bX),\n        decodeY(encoded.cY),\n        decodeX(encoded.cX)};\n\n    int orientation = GeoUtils.orient(original[1], original[0], original[3], original[2], original[5], original[4]);\n    //quantize original\n    double[] originalQuantize;\n    //we need to change the orientation if CW\n    if (orientation == -1) {\n      originalQuantize = new double[] {\n          decodeY(original[4]),\n          decodeX(original[5]),\n          decodeY(original[2]),\n          decodeX(original[3]),\n          decodeY(original[0]),\n          decodeX(original[1])};\n    } else {\n      originalQuantize = new double[] {\n          decodeY(original[0]),\n          decodeX(original[1]),\n          decodeY(original[2]),\n          decodeX(original[3]),\n          decodeY(original[4]),\n          decodeX(original[5])};\n    }\n\n    for (int i =0; i < 100; i ++) {\n      Polygon2D polygon2D = createPolygon2D(nextPolygon());\n      PointValues.Relation originalRelation = polygon2D.relateTriangle(originalQuantize[1], originalQuantize[0], originalQuantize[3], originalQuantize[2], originalQuantize[5], originalQuantize[4]);\n      PointValues.Relation encodedRelation = polygon2D.relateTriangle(encodedQuantize[1], encodedQuantize[0], encodedQuantize[3], encodedQuantize[2], encodedQuantize[5], encodedQuantize[4]);\n      assertTrue(originalRelation == encodedRelation);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09c1e6d465800c73af60624bf9d4459a19f7940c","date":1579293280,"type":5,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/document/BaseShapeEncodingTestCase#verifyEncoding(double,double,double,double,double,double).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/BaseShapeEncodingTestCase#verifyEncoding(double,double,double,double,double,double).mjava","sourceNew":"  private void verifyEncoding(double ay, double ax, double by, double bx, double cy, double cx) {\n    int[] original = new int[]{\n        encodeY(ay),\n        encodeX(ax),\n        encodeY(by),\n        encodeX(bx),\n        encodeY(cy),\n        encodeX(cx)};\n\n    //quantize the triangle\n    byte[] b = new byte[7 * ShapeField.BYTES];\n    ShapeField.encodeTriangle(b, original[0], original[1], true, original[2], original[3], true, original[4], original[5], true);\n    ShapeField.DecodedTriangle encoded = new ShapeField.DecodedTriangle();\n    ShapeField.decodeTriangle(b, encoded);\n    double[] encodedQuantize = new double[] {\n        decodeY(encoded.aY),\n        decodeX(encoded.aX),\n        decodeY(encoded.bY),\n        decodeX(encoded.bX),\n        decodeY(encoded.cY),\n        decodeX(encoded.cX)};\n\n    int orientation = GeoUtils.orient(original[1], original[0], original[3], original[2], original[5], original[4]);\n    //quantize original\n    double[] originalQuantize;\n    //we need to change the orientation if CW\n    if (orientation == -1) {\n      originalQuantize = new double[] {\n          decodeY(original[4]),\n          decodeX(original[5]),\n          decodeY(original[2]),\n          decodeX(original[3]),\n          decodeY(original[0]),\n          decodeX(original[1])};\n    } else {\n      originalQuantize = new double[] {\n          decodeY(original[0]),\n          decodeX(original[1]),\n          decodeY(original[2]),\n          decodeX(original[3]),\n          decodeY(original[4]),\n          decodeX(original[5])};\n    }\n\n    for (int i =0; i < 100; i ++) {\n      Component2D polygon2D = createPolygon2D(nextPolygon());\n      PointValues.Relation originalRelation = polygon2D.relateTriangle(originalQuantize[1], originalQuantize[0], originalQuantize[3], originalQuantize[2], originalQuantize[5], originalQuantize[4]);\n      PointValues.Relation encodedRelation = polygon2D.relateTriangle(encodedQuantize[1], encodedQuantize[0], encodedQuantize[3], encodedQuantize[2], encodedQuantize[5], encodedQuantize[4]);\n      assertTrue(originalRelation == encodedRelation);\n    }\n  }\n\n","sourceOld":"  private void verifyEncoding(double ay, double ax, double by, double bx, double cy, double cx) {\n    int[] original = new int[]{\n        encodeY(ay),\n        encodeX(ax),\n        encodeY(by),\n        encodeX(bx),\n        encodeY(cy),\n        encodeX(cx)};\n\n    //quantize the triangle\n    byte[] b = new byte[7 * ShapeField.BYTES];\n    ShapeField.encodeTriangle(b, original[0], original[1], true, original[2], original[3], true, original[4], original[5], true);\n    ShapeField.DecodedTriangle encoded = new ShapeField.DecodedTriangle();\n    ShapeField.decodeTriangle(b, encoded);\n    double[] encodedQuantize = new double[] {\n        decodeY(encoded.aY),\n        decodeX(encoded.aX),\n        decodeY(encoded.bY),\n        decodeX(encoded.bX),\n        decodeY(encoded.cY),\n        decodeX(encoded.cX)};\n\n    int orientation = GeoUtils.orient(original[1], original[0], original[3], original[2], original[5], original[4]);\n    //quantize original\n    double[] originalQuantize;\n    //we need to change the orientation if CW\n    if (orientation == -1) {\n      originalQuantize = new double[] {\n          decodeY(original[4]),\n          decodeX(original[5]),\n          decodeY(original[2]),\n          decodeX(original[3]),\n          decodeY(original[0]),\n          decodeX(original[1])};\n    } else {\n      originalQuantize = new double[] {\n          decodeY(original[0]),\n          decodeX(original[1]),\n          decodeY(original[2]),\n          decodeX(original[3]),\n          decodeY(original[4]),\n          decodeX(original[5])};\n    }\n\n    for (int i =0; i < 100; i ++) {\n      Component2D polygon2D = createPolygon2D(nextPolygon());\n      PointValues.Relation originalRelation = polygon2D.relateTriangle(originalQuantize[1], originalQuantize[0], originalQuantize[3], originalQuantize[2], originalQuantize[5], originalQuantize[4]);\n      PointValues.Relation encodedRelation = polygon2D.relateTriangle(encodedQuantize[1], encodedQuantize[0], encodedQuantize[3], encodedQuantize[2], encodedQuantize[5], encodedQuantize[4]);\n      assertTrue(originalRelation == encodedRelation);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b5e250f1fb163f190f5ec72b6eeb8271162d8ae1":["5ed90f8ba7e7be13d155f954862178b23a324125"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"09c1e6d465800c73af60624bf9d4459a19f7940c":["b5e250f1fb163f190f5ec72b6eeb8271162d8ae1"],"c286b0d8c507a88b289407e2fe161effa275c6b0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5ed90f8ba7e7be13d155f954862178b23a324125":["c286b0d8c507a88b289407e2fe161effa275c6b0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["09c1e6d465800c73af60624bf9d4459a19f7940c"],"b0b597c65628ca9e73913a07e81691f8229bae35":["5ed90f8ba7e7be13d155f954862178b23a324125","b5e250f1fb163f190f5ec72b6eeb8271162d8ae1"]},"commit2Childs":{"b5e250f1fb163f190f5ec72b6eeb8271162d8ae1":["09c1e6d465800c73af60624bf9d4459a19f7940c","b0b597c65628ca9e73913a07e81691f8229bae35"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c286b0d8c507a88b289407e2fe161effa275c6b0"],"09c1e6d465800c73af60624bf9d4459a19f7940c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c286b0d8c507a88b289407e2fe161effa275c6b0":["5ed90f8ba7e7be13d155f954862178b23a324125"],"5ed90f8ba7e7be13d155f954862178b23a324125":["b5e250f1fb163f190f5ec72b6eeb8271162d8ae1","b0b597c65628ca9e73913a07e81691f8229bae35"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}