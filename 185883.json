{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter#VersionBlockTreeTermsWriter(SegmentWriteState,PostingsWriterBase,int,int).mjava","commits":[{"id":"6256acedd658c13275a01e4ba106a621956a22f6","date":1400192928,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter#VersionBlockTreeTermsWriter(SegmentWriteState,PostingsWriterBase,int,int).mjava","pathOld":"/dev/null","sourceNew":"  /** Create a new writer.  The number of items (terms or\n   *  sub-blocks) per block will aim to be between\n   *  minItemsPerBlock and maxItemsPerBlock, though in some\n   *  cases the blocks may be smaller than the min. */\n  public VersionBlockTreeTermsWriter(\n                                     SegmentWriteState state,\n                                     PostingsWriterBase postingsWriter,\n                                     int minItemsInBlock,\n                                     int maxItemsInBlock)\n    throws IOException\n  {\n    if (minItemsInBlock <= 1) {\n      throw new IllegalArgumentException(\"minItemsInBlock must be >= 2; got \" + minItemsInBlock);\n    }\n    if (maxItemsInBlock <= 0) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be >= 1; got \" + maxItemsInBlock);\n    }\n    if (minItemsInBlock > maxItemsInBlock) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be >= minItemsInBlock; got maxItemsInBlock=\" + maxItemsInBlock + \" minItemsInBlock=\" + minItemsInBlock);\n    }\n    if (2*(minItemsInBlock-1) > maxItemsInBlock) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be at least 2*(minItemsInBlock-1); got maxItemsInBlock=\" + maxItemsInBlock + \" minItemsInBlock=\" + minItemsInBlock);\n    }\n\n    maxDoc = state.segmentInfo.getDocCount();\n\n    final String termsFileName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, TERMS_EXTENSION);\n    out = state.directory.createOutput(termsFileName, state.context);\n    boolean success = false;\n    IndexOutput indexOut = null;\n    try {\n      fieldInfos = state.fieldInfos;\n      this.minItemsInBlock = minItemsInBlock;\n      this.maxItemsInBlock = maxItemsInBlock;\n      writeHeader(out);\n\n      //DEBUG = state.segmentName.equals(\"_4a\");\n\n      final String termsIndexFileName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, TERMS_INDEX_EXTENSION);\n      indexOut = state.directory.createOutput(termsIndexFileName, state.context);\n      writeIndexHeader(indexOut);\n\n      this.postingsWriter = postingsWriter;\n      // segment = state.segmentName;\n\n      // System.out.println(\"BTW.init seg=\" + state.segmentName);\n\n      postingsWriter.init(out);                          // have consumer write its format/header\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(out, indexOut);\n      }\n    }\n    this.indexOut = indexOut;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7d615ef411046679022f6728bb2b876273d13ae","date":1400253450,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter#VersionBlockTreeTermsWriter(SegmentWriteState,PostingsWriterBase,int,int).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter#VersionBlockTreeTermsWriter(SegmentWriteState,PostingsWriterBase,int,int).mjava","sourceNew":"  /** Create a new writer.  The number of items (terms or\n   *  sub-blocks) per block will aim to be between\n   *  minItemsPerBlock and maxItemsPerBlock, though in some\n   *  cases the blocks may be smaller than the min. */\n  public VersionBlockTreeTermsWriter(\n                                     SegmentWriteState state,\n                                     PostingsWriterBase postingsWriter,\n                                     int minItemsInBlock,\n                                     int maxItemsInBlock)\n    throws IOException\n  {\n    System.out.println(\"VBTTW minItemsInBlock=\" + minItemsInBlock + \" maxItemsInBlock=\" + maxItemsInBlock);\n    if (minItemsInBlock <= 1) {\n      throw new IllegalArgumentException(\"minItemsInBlock must be >= 2; got \" + minItemsInBlock);\n    }\n    if (maxItemsInBlock <= 0) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be >= 1; got \" + maxItemsInBlock);\n    }\n    if (minItemsInBlock > maxItemsInBlock) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be >= minItemsInBlock; got maxItemsInBlock=\" + maxItemsInBlock + \" minItemsInBlock=\" + minItemsInBlock);\n    }\n    if (2*(minItemsInBlock-1) > maxItemsInBlock) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be at least 2*(minItemsInBlock-1); got maxItemsInBlock=\" + maxItemsInBlock + \" minItemsInBlock=\" + minItemsInBlock);\n    }\n\n    maxDoc = state.segmentInfo.getDocCount();\n\n    final String termsFileName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, TERMS_EXTENSION);\n    out = state.directory.createOutput(termsFileName, state.context);\n    boolean success = false;\n    IndexOutput indexOut = null;\n    try {\n      fieldInfos = state.fieldInfos;\n      this.minItemsInBlock = minItemsInBlock;\n      this.maxItemsInBlock = maxItemsInBlock;\n      writeHeader(out);\n\n      //DEBUG = state.segmentName.equals(\"_4a\");\n\n      final String termsIndexFileName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, TERMS_INDEX_EXTENSION);\n      indexOut = state.directory.createOutput(termsIndexFileName, state.context);\n      writeIndexHeader(indexOut);\n\n      this.postingsWriter = postingsWriter;\n      segment = state.segmentInfo.name;\n\n      // System.out.println(\"BTW.init seg=\" + state.segmentName);\n\n      postingsWriter.init(out);                          // have consumer write its format/header\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(out, indexOut);\n      }\n    }\n    this.indexOut = indexOut;\n  }\n\n","sourceOld":"  /** Create a new writer.  The number of items (terms or\n   *  sub-blocks) per block will aim to be between\n   *  minItemsPerBlock and maxItemsPerBlock, though in some\n   *  cases the blocks may be smaller than the min. */\n  public VersionBlockTreeTermsWriter(\n                                     SegmentWriteState state,\n                                     PostingsWriterBase postingsWriter,\n                                     int minItemsInBlock,\n                                     int maxItemsInBlock)\n    throws IOException\n  {\n    if (minItemsInBlock <= 1) {\n      throw new IllegalArgumentException(\"minItemsInBlock must be >= 2; got \" + minItemsInBlock);\n    }\n    if (maxItemsInBlock <= 0) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be >= 1; got \" + maxItemsInBlock);\n    }\n    if (minItemsInBlock > maxItemsInBlock) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be >= minItemsInBlock; got maxItemsInBlock=\" + maxItemsInBlock + \" minItemsInBlock=\" + minItemsInBlock);\n    }\n    if (2*(minItemsInBlock-1) > maxItemsInBlock) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be at least 2*(minItemsInBlock-1); got maxItemsInBlock=\" + maxItemsInBlock + \" minItemsInBlock=\" + minItemsInBlock);\n    }\n\n    maxDoc = state.segmentInfo.getDocCount();\n\n    final String termsFileName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, TERMS_EXTENSION);\n    out = state.directory.createOutput(termsFileName, state.context);\n    boolean success = false;\n    IndexOutput indexOut = null;\n    try {\n      fieldInfos = state.fieldInfos;\n      this.minItemsInBlock = minItemsInBlock;\n      this.maxItemsInBlock = maxItemsInBlock;\n      writeHeader(out);\n\n      //DEBUG = state.segmentName.equals(\"_4a\");\n\n      final String termsIndexFileName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, TERMS_INDEX_EXTENSION);\n      indexOut = state.directory.createOutput(termsIndexFileName, state.context);\n      writeIndexHeader(indexOut);\n\n      this.postingsWriter = postingsWriter;\n      // segment = state.segmentName;\n\n      // System.out.println(\"BTW.init seg=\" + state.segmentName);\n\n      postingsWriter.init(out);                          // have consumer write its format/header\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(out, indexOut);\n      }\n    }\n    this.indexOut = indexOut;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efcf27cd5ca23def8376b4c321970c14dd71623","date":1400662679,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter#VersionBlockTreeTermsWriter(SegmentWriteState,PostingsWriterBase,int,int).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter#VersionBlockTreeTermsWriter(SegmentWriteState,PostingsWriterBase,int,int).mjava","sourceNew":"  /** Create a new writer.  The number of items (terms or\n   *  sub-blocks) per block will aim to be between\n   *  minItemsPerBlock and maxItemsPerBlock, though in some\n   *  cases the blocks may be smaller than the min. */\n  public VersionBlockTreeTermsWriter(\n                                     SegmentWriteState state,\n                                     PostingsWriterBase postingsWriter,\n                                     int minItemsInBlock,\n                                     int maxItemsInBlock)\n    throws IOException\n  {\n    if (minItemsInBlock <= 1) {\n      throw new IllegalArgumentException(\"minItemsInBlock must be >= 2; got \" + minItemsInBlock);\n    }\n    if (maxItemsInBlock <= 0) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be >= 1; got \" + maxItemsInBlock);\n    }\n    if (minItemsInBlock > maxItemsInBlock) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be >= minItemsInBlock; got maxItemsInBlock=\" + maxItemsInBlock + \" minItemsInBlock=\" + minItemsInBlock);\n    }\n    if (2*(minItemsInBlock-1) > maxItemsInBlock) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be at least 2*(minItemsInBlock-1); got maxItemsInBlock=\" + maxItemsInBlock + \" minItemsInBlock=\" + minItemsInBlock);\n    }\n\n    maxDoc = state.segmentInfo.getDocCount();\n\n    final String termsFileName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, TERMS_EXTENSION);\n    out = state.directory.createOutput(termsFileName, state.context);\n    boolean success = false;\n    IndexOutput indexOut = null;\n    try {\n      fieldInfos = state.fieldInfos;\n      this.minItemsInBlock = minItemsInBlock;\n      this.maxItemsInBlock = maxItemsInBlock;\n      writeHeader(out);\n\n      //DEBUG = state.segmentName.equals(\"_4a\");\n\n      final String termsIndexFileName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, TERMS_INDEX_EXTENSION);\n      indexOut = state.directory.createOutput(termsIndexFileName, state.context);\n      writeIndexHeader(indexOut);\n\n      this.postingsWriter = postingsWriter;\n      segment = state.segmentInfo.name;\n\n      // System.out.println(\"BTW.init seg=\" + state.segmentName);\n\n      postingsWriter.init(out);                          // have consumer write its format/header\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(out, indexOut);\n      }\n    }\n    this.indexOut = indexOut;\n  }\n\n","sourceOld":"  /** Create a new writer.  The number of items (terms or\n   *  sub-blocks) per block will aim to be between\n   *  minItemsPerBlock and maxItemsPerBlock, though in some\n   *  cases the blocks may be smaller than the min. */\n  public VersionBlockTreeTermsWriter(\n                                     SegmentWriteState state,\n                                     PostingsWriterBase postingsWriter,\n                                     int minItemsInBlock,\n                                     int maxItemsInBlock)\n    throws IOException\n  {\n    System.out.println(\"VBTTW minItemsInBlock=\" + minItemsInBlock + \" maxItemsInBlock=\" + maxItemsInBlock);\n    if (minItemsInBlock <= 1) {\n      throw new IllegalArgumentException(\"minItemsInBlock must be >= 2; got \" + minItemsInBlock);\n    }\n    if (maxItemsInBlock <= 0) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be >= 1; got \" + maxItemsInBlock);\n    }\n    if (minItemsInBlock > maxItemsInBlock) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be >= minItemsInBlock; got maxItemsInBlock=\" + maxItemsInBlock + \" minItemsInBlock=\" + minItemsInBlock);\n    }\n    if (2*(minItemsInBlock-1) > maxItemsInBlock) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be at least 2*(minItemsInBlock-1); got maxItemsInBlock=\" + maxItemsInBlock + \" minItemsInBlock=\" + minItemsInBlock);\n    }\n\n    maxDoc = state.segmentInfo.getDocCount();\n\n    final String termsFileName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, TERMS_EXTENSION);\n    out = state.directory.createOutput(termsFileName, state.context);\n    boolean success = false;\n    IndexOutput indexOut = null;\n    try {\n      fieldInfos = state.fieldInfos;\n      this.minItemsInBlock = minItemsInBlock;\n      this.maxItemsInBlock = maxItemsInBlock;\n      writeHeader(out);\n\n      //DEBUG = state.segmentName.equals(\"_4a\");\n\n      final String termsIndexFileName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, TERMS_INDEX_EXTENSION);\n      indexOut = state.directory.createOutput(termsIndexFileName, state.context);\n      writeIndexHeader(indexOut);\n\n      this.postingsWriter = postingsWriter;\n      segment = state.segmentInfo.name;\n\n      // System.out.println(\"BTW.init seg=\" + state.segmentName);\n\n      postingsWriter.init(out);                          // have consumer write its format/header\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(out, indexOut);\n      }\n    }\n    this.indexOut = indexOut;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a2a0b58a171748f1022e63a0483908e6f50b0abf","date":1400686165,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter#VersionBlockTreeTermsWriter(SegmentWriteState,PostingsWriterBase,int,int).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter#VersionBlockTreeTermsWriter(SegmentWriteState,PostingsWriterBase,int,int).mjava","sourceNew":"  /** Create a new writer.  The number of items (terms or\n   *  sub-blocks) per block will aim to be between\n   *  minItemsPerBlock and maxItemsPerBlock, though in some\n   *  cases the blocks may be smaller than the min. */\n  public VersionBlockTreeTermsWriter(\n                                     SegmentWriteState state,\n                                     PostingsWriterBase postingsWriter,\n                                     int minItemsInBlock,\n                                     int maxItemsInBlock)\n    throws IOException\n  {\n    if (minItemsInBlock <= 1) {\n      throw new IllegalArgumentException(\"minItemsInBlock must be >= 2; got \" + minItemsInBlock);\n    }\n    if (maxItemsInBlock <= 0) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be >= 1; got \" + maxItemsInBlock);\n    }\n    if (minItemsInBlock > maxItemsInBlock) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be >= minItemsInBlock; got maxItemsInBlock=\" + maxItemsInBlock + \" minItemsInBlock=\" + minItemsInBlock);\n    }\n    if (2*(minItemsInBlock-1) > maxItemsInBlock) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be at least 2*(minItemsInBlock-1); got maxItemsInBlock=\" + maxItemsInBlock + \" minItemsInBlock=\" + minItemsInBlock);\n    }\n\n    maxDoc = state.segmentInfo.getDocCount();\n\n    final String termsFileName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, TERMS_EXTENSION);\n    out = state.directory.createOutput(termsFileName, state.context);\n    boolean success = false;\n    IndexOutput indexOut = null;\n    try {\n      fieldInfos = state.fieldInfos;\n      this.minItemsInBlock = minItemsInBlock;\n      this.maxItemsInBlock = maxItemsInBlock;\n      CodecUtil.writeHeader(out, TERMS_CODEC_NAME, VERSION_CURRENT);   \n\n      //DEBUG = state.segmentName.equals(\"_4a\");\n\n      final String termsIndexFileName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, TERMS_INDEX_EXTENSION);\n      indexOut = state.directory.createOutput(termsIndexFileName, state.context);\n      CodecUtil.writeHeader(indexOut, TERMS_INDEX_CODEC_NAME, VERSION_CURRENT); \n\n      this.postingsWriter = postingsWriter;\n      segment = state.segmentInfo.name;\n\n      // System.out.println(\"BTW.init seg=\" + state.segmentName);\n\n      postingsWriter.init(out);                          // have consumer write its format/header\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(out, indexOut);\n      }\n    }\n    this.indexOut = indexOut;\n  }\n\n","sourceOld":"  /** Create a new writer.  The number of items (terms or\n   *  sub-blocks) per block will aim to be between\n   *  minItemsPerBlock and maxItemsPerBlock, though in some\n   *  cases the blocks may be smaller than the min. */\n  public VersionBlockTreeTermsWriter(\n                                     SegmentWriteState state,\n                                     PostingsWriterBase postingsWriter,\n                                     int minItemsInBlock,\n                                     int maxItemsInBlock)\n    throws IOException\n  {\n    if (minItemsInBlock <= 1) {\n      throw new IllegalArgumentException(\"minItemsInBlock must be >= 2; got \" + minItemsInBlock);\n    }\n    if (maxItemsInBlock <= 0) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be >= 1; got \" + maxItemsInBlock);\n    }\n    if (minItemsInBlock > maxItemsInBlock) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be >= minItemsInBlock; got maxItemsInBlock=\" + maxItemsInBlock + \" minItemsInBlock=\" + minItemsInBlock);\n    }\n    if (2*(minItemsInBlock-1) > maxItemsInBlock) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be at least 2*(minItemsInBlock-1); got maxItemsInBlock=\" + maxItemsInBlock + \" minItemsInBlock=\" + minItemsInBlock);\n    }\n\n    maxDoc = state.segmentInfo.getDocCount();\n\n    final String termsFileName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, TERMS_EXTENSION);\n    out = state.directory.createOutput(termsFileName, state.context);\n    boolean success = false;\n    IndexOutput indexOut = null;\n    try {\n      fieldInfos = state.fieldInfos;\n      this.minItemsInBlock = minItemsInBlock;\n      this.maxItemsInBlock = maxItemsInBlock;\n      writeHeader(out);\n\n      //DEBUG = state.segmentName.equals(\"_4a\");\n\n      final String termsIndexFileName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, TERMS_INDEX_EXTENSION);\n      indexOut = state.directory.createOutput(termsIndexFileName, state.context);\n      writeIndexHeader(indexOut);\n\n      this.postingsWriter = postingsWriter;\n      segment = state.segmentInfo.name;\n\n      // System.out.println(\"BTW.init seg=\" + state.segmentName);\n\n      postingsWriter.init(out);                          // have consumer write its format/header\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(out, indexOut);\n      }\n    }\n    this.indexOut = indexOut;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca044bd4a0bea8391cbebb44a34aba53a9b50541","date":1400784655,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter#VersionBlockTreeTermsWriter(SegmentWriteState,PostingsWriterBase,int,int).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter#VersionBlockTreeTermsWriter(SegmentWriteState,PostingsWriterBase,int,int).mjava","sourceNew":"  /** Create a new writer.  The number of items (terms or\n   *  sub-blocks) per block will aim to be between\n   *  minItemsPerBlock and maxItemsPerBlock, though in some\n   *  cases the blocks may be smaller than the min. */\n  public VersionBlockTreeTermsWriter(\n                                     SegmentWriteState state,\n                                     PostingsWriterBase postingsWriter,\n                                     int minItemsInBlock,\n                                     int maxItemsInBlock)\n    throws IOException\n  {\n    if (minItemsInBlock <= 1) {\n      throw new IllegalArgumentException(\"minItemsInBlock must be >= 2; got \" + minItemsInBlock);\n    }\n    if (maxItemsInBlock <= 0) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be >= 1; got \" + maxItemsInBlock);\n    }\n    if (minItemsInBlock > maxItemsInBlock) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be >= minItemsInBlock; got maxItemsInBlock=\" + maxItemsInBlock + \" minItemsInBlock=\" + minItemsInBlock);\n    }\n    if (2*(minItemsInBlock-1) > maxItemsInBlock) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be at least 2*(minItemsInBlock-1); got maxItemsInBlock=\" + maxItemsInBlock + \" minItemsInBlock=\" + minItemsInBlock);\n    }\n\n    maxDoc = state.segmentInfo.getDocCount();\n\n    final String termsFileName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, TERMS_EXTENSION);\n    out = state.directory.createOutput(termsFileName, state.context);\n    boolean success = false;\n    IndexOutput indexOut = null;\n    try {\n      fieldInfos = state.fieldInfos;\n      this.minItemsInBlock = minItemsInBlock;\n      this.maxItemsInBlock = maxItemsInBlock;\n      CodecUtil.writeHeader(out, TERMS_CODEC_NAME, VERSION_CURRENT);   \n\n      //DEBUG = state.segmentName.equals(\"_4a\");\n\n      final String termsIndexFileName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, TERMS_INDEX_EXTENSION);\n      indexOut = state.directory.createOutput(termsIndexFileName, state.context);\n      CodecUtil.writeHeader(indexOut, TERMS_INDEX_CODEC_NAME, VERSION_CURRENT); \n\n      this.postingsWriter = postingsWriter;\n      // segment = state.segmentInfo.name;\n\n      // System.out.println(\"BTW.init seg=\" + state.segmentName);\n\n      postingsWriter.init(out);                          // have consumer write its format/header\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(out, indexOut);\n      }\n    }\n    this.indexOut = indexOut;\n  }\n\n","sourceOld":"  /** Create a new writer.  The number of items (terms or\n   *  sub-blocks) per block will aim to be between\n   *  minItemsPerBlock and maxItemsPerBlock, though in some\n   *  cases the blocks may be smaller than the min. */\n  public VersionBlockTreeTermsWriter(\n                                     SegmentWriteState state,\n                                     PostingsWriterBase postingsWriter,\n                                     int minItemsInBlock,\n                                     int maxItemsInBlock)\n    throws IOException\n  {\n    if (minItemsInBlock <= 1) {\n      throw new IllegalArgumentException(\"minItemsInBlock must be >= 2; got \" + minItemsInBlock);\n    }\n    if (maxItemsInBlock <= 0) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be >= 1; got \" + maxItemsInBlock);\n    }\n    if (minItemsInBlock > maxItemsInBlock) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be >= minItemsInBlock; got maxItemsInBlock=\" + maxItemsInBlock + \" minItemsInBlock=\" + minItemsInBlock);\n    }\n    if (2*(minItemsInBlock-1) > maxItemsInBlock) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be at least 2*(minItemsInBlock-1); got maxItemsInBlock=\" + maxItemsInBlock + \" minItemsInBlock=\" + minItemsInBlock);\n    }\n\n    maxDoc = state.segmentInfo.getDocCount();\n\n    final String termsFileName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, TERMS_EXTENSION);\n    out = state.directory.createOutput(termsFileName, state.context);\n    boolean success = false;\n    IndexOutput indexOut = null;\n    try {\n      fieldInfos = state.fieldInfos;\n      this.minItemsInBlock = minItemsInBlock;\n      this.maxItemsInBlock = maxItemsInBlock;\n      CodecUtil.writeHeader(out, TERMS_CODEC_NAME, VERSION_CURRENT);   \n\n      //DEBUG = state.segmentName.equals(\"_4a\");\n\n      final String termsIndexFileName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, TERMS_INDEX_EXTENSION);\n      indexOut = state.directory.createOutput(termsIndexFileName, state.context);\n      CodecUtil.writeHeader(indexOut, TERMS_INDEX_CODEC_NAME, VERSION_CURRENT); \n\n      this.postingsWriter = postingsWriter;\n      segment = state.segmentInfo.name;\n\n      // System.out.println(\"BTW.init seg=\" + state.segmentName);\n\n      postingsWriter.init(out);                          // have consumer write its format/header\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(out, indexOut);\n      }\n    }\n    this.indexOut = indexOut;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e","date":1400786907,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter#VersionBlockTreeTermsWriter(SegmentWriteState,PostingsWriterBase,int,int).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter#VersionBlockTreeTermsWriter(SegmentWriteState,PostingsWriterBase,int,int).mjava","sourceNew":"  /** Create a new writer.  The number of items (terms or\n   *  sub-blocks) per block will aim to be between\n   *  minItemsPerBlock and maxItemsPerBlock, though in some\n   *  cases the blocks may be smaller than the min. */\n  public VersionBlockTreeTermsWriter(\n                                     SegmentWriteState state,\n                                     PostingsWriterBase postingsWriter,\n                                     int minItemsInBlock,\n                                     int maxItemsInBlock)\n    throws IOException\n  {\n    if (minItemsInBlock <= 1) {\n      throw new IllegalArgumentException(\"minItemsInBlock must be >= 2; got \" + minItemsInBlock);\n    }\n    if (maxItemsInBlock <= 0) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be >= 1; got \" + maxItemsInBlock);\n    }\n    if (minItemsInBlock > maxItemsInBlock) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be >= minItemsInBlock; got maxItemsInBlock=\" + maxItemsInBlock + \" minItemsInBlock=\" + minItemsInBlock);\n    }\n    if (2*(minItemsInBlock-1) > maxItemsInBlock) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be at least 2*(minItemsInBlock-1); got maxItemsInBlock=\" + maxItemsInBlock + \" minItemsInBlock=\" + minItemsInBlock);\n    }\n\n    maxDoc = state.segmentInfo.getDocCount();\n\n    final String termsFileName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, TERMS_EXTENSION);\n    out = state.directory.createOutput(termsFileName, state.context);\n    boolean success = false;\n    IndexOutput indexOut = null;\n    try {\n      fieldInfos = state.fieldInfos;\n      this.minItemsInBlock = minItemsInBlock;\n      this.maxItemsInBlock = maxItemsInBlock;\n      CodecUtil.writeHeader(out, TERMS_CODEC_NAME, VERSION_CURRENT);   \n\n      //DEBUG = state.segmentName.equals(\"_4a\");\n\n      final String termsIndexFileName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, TERMS_INDEX_EXTENSION);\n      indexOut = state.directory.createOutput(termsIndexFileName, state.context);\n      CodecUtil.writeHeader(indexOut, TERMS_INDEX_CODEC_NAME, VERSION_CURRENT); \n\n      this.postingsWriter = postingsWriter;\n      // segment = state.segmentInfo.name;\n\n      // System.out.println(\"BTW.init seg=\" + state.segmentName);\n\n      postingsWriter.init(out);                          // have consumer write its format/header\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(out, indexOut);\n      }\n    }\n    this.indexOut = indexOut;\n  }\n\n","sourceOld":"  /** Create a new writer.  The number of items (terms or\n   *  sub-blocks) per block will aim to be between\n   *  minItemsPerBlock and maxItemsPerBlock, though in some\n   *  cases the blocks may be smaller than the min. */\n  public VersionBlockTreeTermsWriter(\n                                     SegmentWriteState state,\n                                     PostingsWriterBase postingsWriter,\n                                     int minItemsInBlock,\n                                     int maxItemsInBlock)\n    throws IOException\n  {\n    if (minItemsInBlock <= 1) {\n      throw new IllegalArgumentException(\"minItemsInBlock must be >= 2; got \" + minItemsInBlock);\n    }\n    if (maxItemsInBlock <= 0) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be >= 1; got \" + maxItemsInBlock);\n    }\n    if (minItemsInBlock > maxItemsInBlock) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be >= minItemsInBlock; got maxItemsInBlock=\" + maxItemsInBlock + \" minItemsInBlock=\" + minItemsInBlock);\n    }\n    if (2*(minItemsInBlock-1) > maxItemsInBlock) {\n      throw new IllegalArgumentException(\"maxItemsInBlock must be at least 2*(minItemsInBlock-1); got maxItemsInBlock=\" + maxItemsInBlock + \" minItemsInBlock=\" + minItemsInBlock);\n    }\n\n    maxDoc = state.segmentInfo.getDocCount();\n\n    final String termsFileName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, TERMS_EXTENSION);\n    out = state.directory.createOutput(termsFileName, state.context);\n    boolean success = false;\n    IndexOutput indexOut = null;\n    try {\n      fieldInfos = state.fieldInfos;\n      this.minItemsInBlock = minItemsInBlock;\n      this.maxItemsInBlock = maxItemsInBlock;\n      CodecUtil.writeHeader(out, TERMS_CODEC_NAME, VERSION_CURRENT);   \n\n      //DEBUG = state.segmentName.equals(\"_4a\");\n\n      final String termsIndexFileName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, TERMS_INDEX_EXTENSION);\n      indexOut = state.directory.createOutput(termsIndexFileName, state.context);\n      CodecUtil.writeHeader(indexOut, TERMS_INDEX_CODEC_NAME, VERSION_CURRENT); \n\n      this.postingsWriter = postingsWriter;\n      // segment = state.segmentInfo.name;\n\n      // System.out.println(\"BTW.init seg=\" + state.segmentName);\n\n      postingsWriter.init(out);                          // have consumer write its format/header\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(out, indexOut);\n      }\n    }\n    this.indexOut = indexOut;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e":["ca044bd4a0bea8391cbebb44a34aba53a9b50541"],"ca044bd4a0bea8391cbebb44a34aba53a9b50541":["a2a0b58a171748f1022e63a0483908e6f50b0abf"],"0efcf27cd5ca23def8376b4c321970c14dd71623":["b7d615ef411046679022f6728bb2b876273d13ae"],"6256acedd658c13275a01e4ba106a621956a22f6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a2a0b58a171748f1022e63a0483908e6f50b0abf":["0efcf27cd5ca23def8376b4c321970c14dd71623"],"b7d615ef411046679022f6728bb2b876273d13ae":["6256acedd658c13275a01e4ba106a621956a22f6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e":[],"ca044bd4a0bea8391cbebb44a34aba53a9b50541":["3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e"],"0efcf27cd5ca23def8376b4c321970c14dd71623":["a2a0b58a171748f1022e63a0483908e6f50b0abf"],"6256acedd658c13275a01e4ba106a621956a22f6":["b7d615ef411046679022f6728bb2b876273d13ae"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6256acedd658c13275a01e4ba106a621956a22f6","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a2a0b58a171748f1022e63a0483908e6f50b0abf":["ca044bd4a0bea8391cbebb44a34aba53a9b50541"],"b7d615ef411046679022f6728bb2b876273d13ae":["0efcf27cd5ca23def8376b4c321970c14dd71623"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}