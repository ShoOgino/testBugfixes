{"path":"solr/core/src/java/org/apache/solr/cloud/ZkController#updateLeaderInitiatedRecoveryState(String,String,String,String).mjava","commits":[{"id":"14d5815ecbef89580f5c48990bcd433f04f8563a","date":1399564106,"type":0,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#updateLeaderInitiatedRecoveryState(String,String,String,String).mjava","pathOld":"/dev/null","sourceNew":"  private void updateLeaderInitiatedRecoveryState(String collection, String shardId, String coreName, String state) {\n    if (collection == null || shardId == null || coreName == null) {\n      log.warn(\"Cannot set leader-initiated recovery state znode to \"+state+\" using: collection=\"+collection+\n          \"; shardId=\"+shardId+\"; coreName=\"+coreName);\n      return; // if we don't have complete data about a core in cloud mode, do nothing\n    }\n\n    String znodePath = getLeaderInitiatedRecoveryZnodePath(collection, shardId, coreName);\n    \n    if (ZkStateReader.ACTIVE.equals(state)) {\n      // since we're marking it active, we don't need this znode anymore, so delete instead of update\n      try {\n        zkClient.delete(znodePath, -1, false);\n      } catch (Exception justLogIt) {\n        log.warn(\"Failed to delete znode \"+znodePath+\" due to: \"+justLogIt);\n      }\n      return;\n    }\n    \n    byte[] znodeData = null;\n    try {\n      znodeData = state.getBytes(\"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new Error(\"JVM Does not seem to support UTF-8\", e);\n    }\n\n    boolean retryOnConnLoss = true; // be a little more robust when trying to write data\n    try {\n      if (zkClient.exists(znodePath, retryOnConnLoss)) {\n        zkClient.setData(znodePath, znodeData, retryOnConnLoss);\n      } else {\n        zkClient.makePath(znodePath, znodeData, retryOnConnLoss);\n      }\n      log.info(\"Wrote \"+state+\" to \"+znodePath);\n    } catch (Exception exc) {\n      if (exc instanceof SolrException) {\n        throw (SolrException)exc;\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \n            \"Failed to update data to \"+state+\" for znode: \"+znodePath, exc);        \n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"07c824e7f6927860d366e4888be45e4db8c9e03b","date":1405193679,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#updateLeaderInitiatedRecoveryState(String,String,String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#updateLeaderInitiatedRecoveryState(String,String,String,String).mjava","sourceNew":"  private void updateLeaderInitiatedRecoveryState(String collection, String shardId, String coreNodeName, String state) {\n    if (collection == null || shardId == null || coreNodeName == null) {\n      log.warn(\"Cannot set leader-initiated recovery state znode to \"+state+\" using: collection=\"+collection+\n          \"; shardId=\"+shardId+\"; coreNodeName=\"+coreNodeName);\n      return; // if we don't have complete data about a core in cloud mode, do nothing\n    }\n\n    String znodePath = getLeaderInitiatedRecoveryZnodePath(collection, shardId, coreNodeName);\n    \n    if (ZkStateReader.ACTIVE.equals(state)) {\n      // since we're marking it active, we don't need this znode anymore, so delete instead of update\n      try {\n        zkClient.delete(znodePath, -1, false);\n      } catch (Exception justLogIt) {\n        log.warn(\"Failed to delete znode \"+znodePath+\" due to: \"+justLogIt);\n      }\n      return;\n    }\n    \n    byte[] znodeData = null;\n    try {\n      znodeData = state.getBytes(\"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new Error(\"JVM Does not seem to support UTF-8\", e);\n    }\n\n    boolean retryOnConnLoss = true; // be a little more robust when trying to write data\n    try {\n      if (zkClient.exists(znodePath, retryOnConnLoss)) {\n        zkClient.setData(znodePath, znodeData, retryOnConnLoss);\n      } else {\n        zkClient.makePath(znodePath, znodeData, retryOnConnLoss);\n      }\n      log.info(\"Wrote \"+state+\" to \"+znodePath);\n    } catch (Exception exc) {\n      if (exc instanceof SolrException) {\n        throw (SolrException)exc;\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \n            \"Failed to update data to \"+state+\" for znode: \"+znodePath, exc);        \n      }\n    }\n  }\n\n","sourceOld":"  private void updateLeaderInitiatedRecoveryState(String collection, String shardId, String coreName, String state) {\n    if (collection == null || shardId == null || coreName == null) {\n      log.warn(\"Cannot set leader-initiated recovery state znode to \"+state+\" using: collection=\"+collection+\n          \"; shardId=\"+shardId+\"; coreName=\"+coreName);\n      return; // if we don't have complete data about a core in cloud mode, do nothing\n    }\n\n    String znodePath = getLeaderInitiatedRecoveryZnodePath(collection, shardId, coreName);\n    \n    if (ZkStateReader.ACTIVE.equals(state)) {\n      // since we're marking it active, we don't need this znode anymore, so delete instead of update\n      try {\n        zkClient.delete(znodePath, -1, false);\n      } catch (Exception justLogIt) {\n        log.warn(\"Failed to delete znode \"+znodePath+\" due to: \"+justLogIt);\n      }\n      return;\n    }\n    \n    byte[] znodeData = null;\n    try {\n      znodeData = state.getBytes(\"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new Error(\"JVM Does not seem to support UTF-8\", e);\n    }\n\n    boolean retryOnConnLoss = true; // be a little more robust when trying to write data\n    try {\n      if (zkClient.exists(znodePath, retryOnConnLoss)) {\n        zkClient.setData(znodePath, znodeData, retryOnConnLoss);\n      } else {\n        zkClient.makePath(znodePath, znodeData, retryOnConnLoss);\n      }\n      log.info(\"Wrote \"+state+\" to \"+znodePath);\n    } catch (Exception exc) {\n      if (exc instanceof SolrException) {\n        throw (SolrException)exc;\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \n            \"Failed to update data to \"+state+\" for znode: \"+znodePath, exc);        \n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e758245b4acfbc0eae618c8f5d49f799d3b33157","date":1412710512,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#updateLeaderInitiatedRecoveryState(String,String,String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#updateLeaderInitiatedRecoveryState(String,String,String,String).mjava","sourceNew":"  private void updateLeaderInitiatedRecoveryState(String collection, String shardId, String coreNodeName, String state) {\n    if (collection == null || shardId == null || coreNodeName == null) {\n      log.warn(\"Cannot set leader-initiated recovery state znode to \"+state+\" using: collection=\"+collection+\n          \"; shardId=\"+shardId+\"; coreNodeName=\"+coreNodeName);\n      return; // if we don't have complete data about a core in cloud mode, do nothing\n    }\n\n    String znodePath = getLeaderInitiatedRecoveryZnodePath(collection, shardId, coreNodeName);\n    \n    if (ZkStateReader.ACTIVE.equals(state)) {\n      // since we're marking it active, we don't need this znode anymore, so delete instead of update\n      try {\n        zkClient.delete(znodePath, -1, false);\n      } catch (Exception justLogIt) {\n        log.warn(\"Failed to delete znode \"+znodePath+\" due to: \"+justLogIt);\n      }\n      return;\n    }\n\n    Map<String,Object> stateObj = null;\n    try {\n      stateObj = getLeaderInitiatedRecoveryStateObject(collection, shardId, coreNodeName);\n    } catch (Exception exc) {\n      log.warn(exc.getMessage(), exc);\n    }\n    if (stateObj == null)\n      stateObj = new LinkedHashMap<String,Object>();\n\n    stateObj.put(\"state\", state);\n    // only update the createdBy value if its not set\n    if (stateObj.get(\"createdByNodeName\") == null)\n      stateObj.put(\"createdByNodeName\", String.valueOf(this.nodeName));\n\n    byte[] znodeData = ZkStateReader.toJSON(stateObj);\n    boolean retryOnConnLoss = true; // be a little more robust when trying to write data\n    try {\n      if (zkClient.exists(znodePath, retryOnConnLoss)) {\n        zkClient.setData(znodePath, znodeData, retryOnConnLoss);\n      } else {\n        zkClient.makePath(znodePath, znodeData, retryOnConnLoss);\n      }\n      log.info(\"Wrote \"+state+\" to \"+znodePath);\n    } catch (Exception exc) {\n      if (exc instanceof SolrException) {\n        throw (SolrException)exc;\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \n            \"Failed to update data to \"+state+\" for znode: \"+znodePath, exc);        \n      }\n    }\n  }\n\n","sourceOld":"  private void updateLeaderInitiatedRecoveryState(String collection, String shardId, String coreNodeName, String state) {\n    if (collection == null || shardId == null || coreNodeName == null) {\n      log.warn(\"Cannot set leader-initiated recovery state znode to \"+state+\" using: collection=\"+collection+\n          \"; shardId=\"+shardId+\"; coreNodeName=\"+coreNodeName);\n      return; // if we don't have complete data about a core in cloud mode, do nothing\n    }\n\n    String znodePath = getLeaderInitiatedRecoveryZnodePath(collection, shardId, coreNodeName);\n    \n    if (ZkStateReader.ACTIVE.equals(state)) {\n      // since we're marking it active, we don't need this znode anymore, so delete instead of update\n      try {\n        zkClient.delete(znodePath, -1, false);\n      } catch (Exception justLogIt) {\n        log.warn(\"Failed to delete znode \"+znodePath+\" due to: \"+justLogIt);\n      }\n      return;\n    }\n    \n    byte[] znodeData = null;\n    try {\n      znodeData = state.getBytes(\"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new Error(\"JVM Does not seem to support UTF-8\", e);\n    }\n\n    boolean retryOnConnLoss = true; // be a little more robust when trying to write data\n    try {\n      if (zkClient.exists(znodePath, retryOnConnLoss)) {\n        zkClient.setData(znodePath, znodeData, retryOnConnLoss);\n      } else {\n        zkClient.makePath(znodePath, znodeData, retryOnConnLoss);\n      }\n      log.info(\"Wrote \"+state+\" to \"+znodePath);\n    } catch (Exception exc) {\n      if (exc instanceof SolrException) {\n        throw (SolrException)exc;\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \n            \"Failed to update data to \"+state+\" for znode: \"+znodePath, exc);        \n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eb5ad0342ee8bffa4c3a79e4446b6027143ffc9a","date":1413205592,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#updateLeaderInitiatedRecoveryState(String,String,String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#updateLeaderInitiatedRecoveryState(String,String,String,String).mjava","sourceNew":"  private void updateLeaderInitiatedRecoveryState(String collection, String shardId, String coreNodeName, String state) {\n    if (collection == null || shardId == null || coreNodeName == null) {\n      log.warn(\"Cannot set leader-initiated recovery state znode to \"+state+\" using: collection=\"+collection+\n          \"; shardId=\"+shardId+\"; coreNodeName=\"+coreNodeName);\n      return; // if we don't have complete data about a core in cloud mode, do nothing\n    }\n\n    String znodePath = getLeaderInitiatedRecoveryZnodePath(collection, shardId, coreNodeName);\n    \n    if (ZkStateReader.ACTIVE.equals(state)) {\n      // since we're marking it active, we don't need this znode anymore, so delete instead of update\n      try {\n        zkClient.delete(znodePath, -1, false);\n      } catch (Exception justLogIt) {\n        log.warn(\"Failed to delete znode \"+znodePath+\" due to: \"+justLogIt);\n      }\n      return;\n    }\n\n    Map<String,Object> stateObj = null;\n    try {\n      stateObj = getLeaderInitiatedRecoveryStateObject(collection, shardId, coreNodeName);\n    } catch (Exception exc) {\n      log.warn(exc.getMessage(), exc);\n    }\n    if (stateObj == null)\n      stateObj = new LinkedHashMap<>();\n\n    stateObj.put(\"state\", state);\n    // only update the createdBy value if its not set\n    if (stateObj.get(\"createdByNodeName\") == null)\n      stateObj.put(\"createdByNodeName\", String.valueOf(this.nodeName));\n\n    byte[] znodeData = ZkStateReader.toJSON(stateObj);\n    boolean retryOnConnLoss = true; // be a little more robust when trying to write data\n    try {\n      if (zkClient.exists(znodePath, retryOnConnLoss)) {\n        zkClient.setData(znodePath, znodeData, retryOnConnLoss);\n      } else {\n        zkClient.makePath(znodePath, znodeData, retryOnConnLoss);\n      }\n      log.info(\"Wrote \"+state+\" to \"+znodePath);\n    } catch (Exception exc) {\n      if (exc instanceof SolrException) {\n        throw (SolrException)exc;\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \n            \"Failed to update data to \"+state+\" for znode: \"+znodePath, exc);        \n      }\n    }\n  }\n\n","sourceOld":"  private void updateLeaderInitiatedRecoveryState(String collection, String shardId, String coreNodeName, String state) {\n    if (collection == null || shardId == null || coreNodeName == null) {\n      log.warn(\"Cannot set leader-initiated recovery state znode to \"+state+\" using: collection=\"+collection+\n          \"; shardId=\"+shardId+\"; coreNodeName=\"+coreNodeName);\n      return; // if we don't have complete data about a core in cloud mode, do nothing\n    }\n\n    String znodePath = getLeaderInitiatedRecoveryZnodePath(collection, shardId, coreNodeName);\n    \n    if (ZkStateReader.ACTIVE.equals(state)) {\n      // since we're marking it active, we don't need this znode anymore, so delete instead of update\n      try {\n        zkClient.delete(znodePath, -1, false);\n      } catch (Exception justLogIt) {\n        log.warn(\"Failed to delete znode \"+znodePath+\" due to: \"+justLogIt);\n      }\n      return;\n    }\n\n    Map<String,Object> stateObj = null;\n    try {\n      stateObj = getLeaderInitiatedRecoveryStateObject(collection, shardId, coreNodeName);\n    } catch (Exception exc) {\n      log.warn(exc.getMessage(), exc);\n    }\n    if (stateObj == null)\n      stateObj = new LinkedHashMap<String,Object>();\n\n    stateObj.put(\"state\", state);\n    // only update the createdBy value if its not set\n    if (stateObj.get(\"createdByNodeName\") == null)\n      stateObj.put(\"createdByNodeName\", String.valueOf(this.nodeName));\n\n    byte[] znodeData = ZkStateReader.toJSON(stateObj);\n    boolean retryOnConnLoss = true; // be a little more robust when trying to write data\n    try {\n      if (zkClient.exists(znodePath, retryOnConnLoss)) {\n        zkClient.setData(znodePath, znodeData, retryOnConnLoss);\n      } else {\n        zkClient.makePath(znodePath, znodeData, retryOnConnLoss);\n      }\n      log.info(\"Wrote \"+state+\" to \"+znodePath);\n    } catch (Exception exc) {\n      if (exc instanceof SolrException) {\n        throw (SolrException)exc;\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \n            \"Failed to update data to \"+state+\" for znode: \"+znodePath, exc);        \n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["3f12b7260301796a1d2c5d6d3bbf5295b19ef0b7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#updateLeaderInitiatedRecoveryState(String,String,String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#updateLeaderInitiatedRecoveryState(String,String,String,String).mjava","sourceNew":"  private void updateLeaderInitiatedRecoveryState(String collection, String shardId, String coreNodeName, String state) {\n    if (collection == null || shardId == null || coreNodeName == null) {\n      log.warn(\"Cannot set leader-initiated recovery state znode to \"+state+\" using: collection=\"+collection+\n          \"; shardId=\"+shardId+\"; coreNodeName=\"+coreNodeName);\n      return; // if we don't have complete data about a core in cloud mode, do nothing\n    }\n\n    String znodePath = getLeaderInitiatedRecoveryZnodePath(collection, shardId, coreNodeName);\n    \n    if (ZkStateReader.ACTIVE.equals(state)) {\n      // since we're marking it active, we don't need this znode anymore, so delete instead of update\n      try {\n        zkClient.delete(znodePath, -1, false);\n      } catch (Exception justLogIt) {\n        log.warn(\"Failed to delete znode \"+znodePath+\" due to: \"+justLogIt);\n      }\n      return;\n    }\n\n    Map<String,Object> stateObj = null;\n    try {\n      stateObj = getLeaderInitiatedRecoveryStateObject(collection, shardId, coreNodeName);\n    } catch (Exception exc) {\n      log.warn(exc.getMessage(), exc);\n    }\n    if (stateObj == null)\n      stateObj = new LinkedHashMap<>();\n\n    stateObj.put(\"state\", state);\n    // only update the createdBy value if its not set\n    if (stateObj.get(\"createdByNodeName\") == null)\n      stateObj.put(\"createdByNodeName\", String.valueOf(this.nodeName));\n\n    byte[] znodeData = ZkStateReader.toJSON(stateObj);\n    boolean retryOnConnLoss = true; // be a little more robust when trying to write data\n    try {\n      if (zkClient.exists(znodePath, retryOnConnLoss)) {\n        zkClient.setData(znodePath, znodeData, retryOnConnLoss);\n      } else {\n        zkClient.makePath(znodePath, znodeData, retryOnConnLoss);\n      }\n      log.info(\"Wrote \"+state+\" to \"+znodePath);\n    } catch (Exception exc) {\n      if (exc instanceof SolrException) {\n        throw (SolrException)exc;\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \n            \"Failed to update data to \"+state+\" for znode: \"+znodePath, exc);        \n      }\n    }\n  }\n\n","sourceOld":"  private void updateLeaderInitiatedRecoveryState(String collection, String shardId, String coreNodeName, String state) {\n    if (collection == null || shardId == null || coreNodeName == null) {\n      log.warn(\"Cannot set leader-initiated recovery state znode to \"+state+\" using: collection=\"+collection+\n          \"; shardId=\"+shardId+\"; coreNodeName=\"+coreNodeName);\n      return; // if we don't have complete data about a core in cloud mode, do nothing\n    }\n\n    String znodePath = getLeaderInitiatedRecoveryZnodePath(collection, shardId, coreNodeName);\n    \n    if (ZkStateReader.ACTIVE.equals(state)) {\n      // since we're marking it active, we don't need this znode anymore, so delete instead of update\n      try {\n        zkClient.delete(znodePath, -1, false);\n      } catch (Exception justLogIt) {\n        log.warn(\"Failed to delete znode \"+znodePath+\" due to: \"+justLogIt);\n      }\n      return;\n    }\n    \n    byte[] znodeData = null;\n    try {\n      znodeData = state.getBytes(\"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new Error(\"JVM Does not seem to support UTF-8\", e);\n    }\n\n    boolean retryOnConnLoss = true; // be a little more robust when trying to write data\n    try {\n      if (zkClient.exists(znodePath, retryOnConnLoss)) {\n        zkClient.setData(znodePath, znodeData, retryOnConnLoss);\n      } else {\n        zkClient.makePath(znodePath, znodeData, retryOnConnLoss);\n      }\n      log.info(\"Wrote \"+state+\" to \"+znodePath);\n    } catch (Exception exc) {\n      if (exc instanceof SolrException) {\n        throw (SolrException)exc;\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \n            \"Failed to update data to \"+state+\" for znode: \"+znodePath, exc);        \n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f12b7260301796a1d2c5d6d3bbf5295b19ef0b7","date":1417534918,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#updateLeaderInitiatedRecoveryState(String,String,String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#updateLeaderInitiatedRecoveryState(String,String,String,String).mjava","sourceNew":"  private void updateLeaderInitiatedRecoveryState(String collection, String shardId, String coreNodeName, String state) {\n    if (collection == null || shardId == null || coreNodeName == null) {\n      log.warn(\"Cannot set leader-initiated recovery state znode to \"+state+\" using: collection=\"+collection+\n          \"; shardId=\"+shardId+\"; coreNodeName=\"+coreNodeName);\n      return; // if we don't have complete data about a core in cloud mode, do nothing\n    }\n\n    String znodePath = getLeaderInitiatedRecoveryZnodePath(collection, shardId, coreNodeName);\n    \n    if (ZkStateReader.ACTIVE.equals(state)) {\n      // since we're marking it active, we don't need this znode anymore, so delete instead of update\n      try {\n        zkClient.delete(znodePath, -1, false);\n      } catch (Exception justLogIt) {\n        log.warn(\"Failed to delete znode \"+znodePath+\" due to: \"+justLogIt);\n      }\n      return;\n    }\n\n    Map<String,Object> stateObj = null;\n    try {\n      stateObj = getLeaderInitiatedRecoveryStateObject(collection, shardId, coreNodeName);\n    } catch (Exception exc) {\n      log.warn(exc.getMessage(), exc);\n    }\n    if (stateObj == null)\n      stateObj = ZkNodeProps.makeMap();\n\n    stateObj.put(\"state\", state);\n    // only update the createdBy value if its not set\n    if (stateObj.get(\"createdByNodeName\") == null)\n      stateObj.put(\"createdByNodeName\", String.valueOf(this.nodeName));\n\n    byte[] znodeData = ZkStateReader.toJSON(stateObj);\n    boolean retryOnConnLoss = true; // be a little more robust when trying to write data\n    try {\n      if (zkClient.exists(znodePath, retryOnConnLoss)) {\n        zkClient.setData(znodePath, znodeData, retryOnConnLoss);\n      } else {\n        zkClient.makePath(znodePath, znodeData, retryOnConnLoss);\n      }\n      log.info(\"Wrote \"+state+\" to \"+znodePath);\n    } catch (Exception exc) {\n      if (exc instanceof SolrException) {\n        throw (SolrException)exc;\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \n            \"Failed to update data to \"+state+\" for znode: \"+znodePath, exc);        \n      }\n    }\n  }\n\n","sourceOld":"  private void updateLeaderInitiatedRecoveryState(String collection, String shardId, String coreNodeName, String state) {\n    if (collection == null || shardId == null || coreNodeName == null) {\n      log.warn(\"Cannot set leader-initiated recovery state znode to \"+state+\" using: collection=\"+collection+\n          \"; shardId=\"+shardId+\"; coreNodeName=\"+coreNodeName);\n      return; // if we don't have complete data about a core in cloud mode, do nothing\n    }\n\n    String znodePath = getLeaderInitiatedRecoveryZnodePath(collection, shardId, coreNodeName);\n    \n    if (ZkStateReader.ACTIVE.equals(state)) {\n      // since we're marking it active, we don't need this znode anymore, so delete instead of update\n      try {\n        zkClient.delete(znodePath, -1, false);\n      } catch (Exception justLogIt) {\n        log.warn(\"Failed to delete znode \"+znodePath+\" due to: \"+justLogIt);\n      }\n      return;\n    }\n\n    Map<String,Object> stateObj = null;\n    try {\n      stateObj = getLeaderInitiatedRecoveryStateObject(collection, shardId, coreNodeName);\n    } catch (Exception exc) {\n      log.warn(exc.getMessage(), exc);\n    }\n    if (stateObj == null)\n      stateObj = new LinkedHashMap<>();\n\n    stateObj.put(\"state\", state);\n    // only update the createdBy value if its not set\n    if (stateObj.get(\"createdByNodeName\") == null)\n      stateObj.put(\"createdByNodeName\", String.valueOf(this.nodeName));\n\n    byte[] znodeData = ZkStateReader.toJSON(stateObj);\n    boolean retryOnConnLoss = true; // be a little more robust when trying to write data\n    try {\n      if (zkClient.exists(znodePath, retryOnConnLoss)) {\n        zkClient.setData(znodePath, znodeData, retryOnConnLoss);\n      } else {\n        zkClient.makePath(znodePath, znodeData, retryOnConnLoss);\n      }\n      log.info(\"Wrote \"+state+\" to \"+znodePath);\n    } catch (Exception exc) {\n      if (exc instanceof SolrException) {\n        throw (SolrException)exc;\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \n            \"Failed to update data to \"+state+\" for znode: \"+znodePath, exc);        \n      }\n    }\n  }\n\n","bugFix":["eb5ad0342ee8bffa4c3a79e4446b6027143ffc9a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1","date":1419400138,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#updateLeaderInitiatedRecoveryState(String,String,String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#updateLeaderInitiatedRecoveryState(String,String,String,String).mjava","sourceNew":"  private void updateLeaderInitiatedRecoveryState(String collection, String shardId, String coreNodeName, String state) {\n    if (collection == null || shardId == null || coreNodeName == null) {\n      log.warn(\"Cannot set leader-initiated recovery state znode to \"+state+\" using: collection=\"+collection+\n          \"; shardId=\"+shardId+\"; coreNodeName=\"+coreNodeName);\n      return; // if we don't have complete data about a core in cloud mode, do nothing\n    }\n\n    String znodePath = getLeaderInitiatedRecoveryZnodePath(collection, shardId, coreNodeName);\n    \n    if (ZkStateReader.ACTIVE.equals(state)) {\n      // since we're marking it active, we don't need this znode anymore, so delete instead of update\n      try {\n        zkClient.delete(znodePath, -1, false);\n      } catch (Exception justLogIt) {\n        log.warn(\"Failed to delete znode \"+znodePath+\" due to: \"+justLogIt);\n      }\n      return;\n    }\n\n    Map<String,Object> stateObj = null;\n    try {\n      stateObj = getLeaderInitiatedRecoveryStateObject(collection, shardId, coreNodeName);\n    } catch (Exception exc) {\n      log.warn(exc.getMessage(), exc);\n    }\n    if (stateObj == null)\n      stateObj = ZkNodeProps.makeMap();\n\n    stateObj.put(\"state\", state);\n    // only update the createdBy value if it's not set\n    if (stateObj.get(\"createdByNodeName\") == null)\n      stateObj.put(\"createdByNodeName\", String.valueOf(this.nodeName));\n\n    byte[] znodeData = ZkStateReader.toJSON(stateObj);\n    boolean retryOnConnLoss = true; // be a little more robust when trying to write data\n    try {\n      if (zkClient.exists(znodePath, retryOnConnLoss)) {\n        zkClient.setData(znodePath, znodeData, retryOnConnLoss);\n      } else {\n        zkClient.makePath(znodePath, znodeData, retryOnConnLoss);\n      }\n      log.info(\"Wrote \"+state+\" to \"+znodePath);\n    } catch (Exception exc) {\n      if (exc instanceof SolrException) {\n        throw (SolrException)exc;\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \n            \"Failed to update data to \"+state+\" for znode: \"+znodePath, exc);        \n      }\n    }\n  }\n\n","sourceOld":"  private void updateLeaderInitiatedRecoveryState(String collection, String shardId, String coreNodeName, String state) {\n    if (collection == null || shardId == null || coreNodeName == null) {\n      log.warn(\"Cannot set leader-initiated recovery state znode to \"+state+\" using: collection=\"+collection+\n          \"; shardId=\"+shardId+\"; coreNodeName=\"+coreNodeName);\n      return; // if we don't have complete data about a core in cloud mode, do nothing\n    }\n\n    String znodePath = getLeaderInitiatedRecoveryZnodePath(collection, shardId, coreNodeName);\n    \n    if (ZkStateReader.ACTIVE.equals(state)) {\n      // since we're marking it active, we don't need this znode anymore, so delete instead of update\n      try {\n        zkClient.delete(znodePath, -1, false);\n      } catch (Exception justLogIt) {\n        log.warn(\"Failed to delete znode \"+znodePath+\" due to: \"+justLogIt);\n      }\n      return;\n    }\n\n    Map<String,Object> stateObj = null;\n    try {\n      stateObj = getLeaderInitiatedRecoveryStateObject(collection, shardId, coreNodeName);\n    } catch (Exception exc) {\n      log.warn(exc.getMessage(), exc);\n    }\n    if (stateObj == null)\n      stateObj = ZkNodeProps.makeMap();\n\n    stateObj.put(\"state\", state);\n    // only update the createdBy value if its not set\n    if (stateObj.get(\"createdByNodeName\") == null)\n      stateObj.put(\"createdByNodeName\", String.valueOf(this.nodeName));\n\n    byte[] znodeData = ZkStateReader.toJSON(stateObj);\n    boolean retryOnConnLoss = true; // be a little more robust when trying to write data\n    try {\n      if (zkClient.exists(znodePath, retryOnConnLoss)) {\n        zkClient.setData(znodePath, znodeData, retryOnConnLoss);\n      } else {\n        zkClient.makePath(znodePath, znodeData, retryOnConnLoss);\n      }\n      log.info(\"Wrote \"+state+\" to \"+znodePath);\n    } catch (Exception exc) {\n      if (exc instanceof SolrException) {\n        throw (SolrException)exc;\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \n            \"Failed to update data to \"+state+\" for znode: \"+znodePath, exc);        \n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd042b1ba3cc0f8bc92f7896c2c51438ba60e4fc","date":1426444850,"type":5,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#updateLeaderInitiatedRecoveryState(String,String,String,String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#updateLeaderInitiatedRecoveryState(String,String,String,String).mjava","sourceNew":"  private void updateLeaderInitiatedRecoveryState(String collection, String shardId, String coreNodeName, String state,\n                                                  String leaderCoreNodeName) {\n    if (collection == null || shardId == null || coreNodeName == null) {\n      log.warn(\"Cannot set leader-initiated recovery state znode to \"+state+\" using: collection=\"+collection+\n          \"; shardId=\"+shardId+\"; coreNodeName=\"+coreNodeName);\n      return; // if we don't have complete data about a core in cloud mode, do nothing\n    }\n\n    String znodePath = getLeaderInitiatedRecoveryZnodePath(collection, shardId, coreNodeName);\n    \n    if (ZkStateReader.ACTIVE.equals(state)) {\n      // since we're marking it active, we don't need this znode anymore, so delete instead of update\n      try {\n        zkClient.delete(znodePath, -1, false);\n      } catch (Exception justLogIt) {\n        log.warn(\"Failed to delete znode \" + znodePath, justLogIt);\n      }\n      return;\n    }\n\n    Map<String,Object> stateObj = null;\n    try {\n      stateObj = getLeaderInitiatedRecoveryStateObject(collection, shardId, coreNodeName);\n    } catch (Exception exc) {\n      log.warn(exc.getMessage(), exc);\n    }\n    if (stateObj == null)\n      stateObj = ZkNodeProps.makeMap();\n\n    stateObj.put(\"state\", state);\n    // only update the createdBy value if it's not set\n    if (stateObj.get(\"createdByNodeName\") == null)\n      stateObj.put(\"createdByNodeName\", String.valueOf(this.nodeName));\n\n    byte[] znodeData = ZkStateReader.toJSON(stateObj);\n\n    try {\n      if (ZkStateReader.DOWN.equals(state)) {\n        markShardAsDownIfLeader(collection, shardId, leaderCoreNodeName, znodePath, znodeData);\n      } else  {\n        if (zkClient.exists(znodePath, true)) {\n          zkClient.setData(znodePath, znodeData, true);\n        } else {\n          zkClient.makePath(znodePath, znodeData, true);\n        }\n      }\n      log.info(\"Wrote \"+state+\" to \"+znodePath);\n    } catch (Exception exc) {\n      if (exc instanceof SolrException) {\n        throw (SolrException)exc;\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Failed to update data to \"+state+\" for znode: \"+znodePath, exc);\n      }\n    }\n  }\n\n","sourceOld":"  private void updateLeaderInitiatedRecoveryState(String collection, String shardId, String coreNodeName, String state) {\n    if (collection == null || shardId == null || coreNodeName == null) {\n      log.warn(\"Cannot set leader-initiated recovery state znode to \"+state+\" using: collection=\"+collection+\n          \"; shardId=\"+shardId+\"; coreNodeName=\"+coreNodeName);\n      return; // if we don't have complete data about a core in cloud mode, do nothing\n    }\n\n    String znodePath = getLeaderInitiatedRecoveryZnodePath(collection, shardId, coreNodeName);\n    \n    if (ZkStateReader.ACTIVE.equals(state)) {\n      // since we're marking it active, we don't need this znode anymore, so delete instead of update\n      try {\n        zkClient.delete(znodePath, -1, false);\n      } catch (Exception justLogIt) {\n        log.warn(\"Failed to delete znode \"+znodePath+\" due to: \"+justLogIt);\n      }\n      return;\n    }\n\n    Map<String,Object> stateObj = null;\n    try {\n      stateObj = getLeaderInitiatedRecoveryStateObject(collection, shardId, coreNodeName);\n    } catch (Exception exc) {\n      log.warn(exc.getMessage(), exc);\n    }\n    if (stateObj == null)\n      stateObj = ZkNodeProps.makeMap();\n\n    stateObj.put(\"state\", state);\n    // only update the createdBy value if it's not set\n    if (stateObj.get(\"createdByNodeName\") == null)\n      stateObj.put(\"createdByNodeName\", String.valueOf(this.nodeName));\n\n    byte[] znodeData = ZkStateReader.toJSON(stateObj);\n    boolean retryOnConnLoss = true; // be a little more robust when trying to write data\n    try {\n      if (zkClient.exists(znodePath, retryOnConnLoss)) {\n        zkClient.setData(znodePath, znodeData, retryOnConnLoss);\n      } else {\n        zkClient.makePath(znodePath, znodeData, retryOnConnLoss);\n      }\n      log.info(\"Wrote \"+state+\" to \"+znodePath);\n    } catch (Exception exc) {\n      if (exc instanceof SolrException) {\n        throw (SolrException)exc;\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \n            \"Failed to update data to \"+state+\" for znode: \"+znodePath, exc);        \n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":4,"author":"Ryan Ernst","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#updateLeaderInitiatedRecoveryState(String,String,String,String).mjava","sourceNew":null,"sourceOld":"  private void updateLeaderInitiatedRecoveryState(String collection, String shardId, String coreNodeName, String state) {\n    if (collection == null || shardId == null || coreNodeName == null) {\n      log.warn(\"Cannot set leader-initiated recovery state znode to \"+state+\" using: collection=\"+collection+\n          \"; shardId=\"+shardId+\"; coreNodeName=\"+coreNodeName);\n      return; // if we don't have complete data about a core in cloud mode, do nothing\n    }\n\n    String znodePath = getLeaderInitiatedRecoveryZnodePath(collection, shardId, coreNodeName);\n    \n    if (ZkStateReader.ACTIVE.equals(state)) {\n      // since we're marking it active, we don't need this znode anymore, so delete instead of update\n      try {\n        zkClient.delete(znodePath, -1, false);\n      } catch (Exception justLogIt) {\n        log.warn(\"Failed to delete znode \"+znodePath+\" due to: \"+justLogIt);\n      }\n      return;\n    }\n\n    Map<String,Object> stateObj = null;\n    try {\n      stateObj = getLeaderInitiatedRecoveryStateObject(collection, shardId, coreNodeName);\n    } catch (Exception exc) {\n      log.warn(exc.getMessage(), exc);\n    }\n    if (stateObj == null)\n      stateObj = ZkNodeProps.makeMap();\n\n    stateObj.put(\"state\", state);\n    // only update the createdBy value if it's not set\n    if (stateObj.get(\"createdByNodeName\") == null)\n      stateObj.put(\"createdByNodeName\", String.valueOf(this.nodeName));\n\n    byte[] znodeData = ZkStateReader.toJSON(stateObj);\n    boolean retryOnConnLoss = true; // be a little more robust when trying to write data\n    try {\n      if (zkClient.exists(znodePath, retryOnConnLoss)) {\n        zkClient.setData(znodePath, znodeData, retryOnConnLoss);\n      } else {\n        zkClient.makePath(znodePath, znodeData, retryOnConnLoss);\n      }\n      log.info(\"Wrote \"+state+\" to \"+znodePath);\n    } catch (Exception exc) {\n      if (exc instanceof SolrException) {\n        throw (SolrException)exc;\n      } else {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \n            \"Failed to update data to \"+state+\" for znode: \"+znodePath, exc);        \n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"dd042b1ba3cc0f8bc92f7896c2c51438ba60e4fc":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"e758245b4acfbc0eae618c8f5d49f799d3b33157":["07c824e7f6927860d366e4888be45e4db8c9e03b"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1","dd042b1ba3cc0f8bc92f7896c2c51438ba60e4fc"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["3f12b7260301796a1d2c5d6d3bbf5295b19ef0b7"],"55980207f1977bd1463465de1659b821347e2fa8":["07c824e7f6927860d366e4888be45e4db8c9e03b","eb5ad0342ee8bffa4c3a79e4446b6027143ffc9a"],"3f12b7260301796a1d2c5d6d3bbf5295b19ef0b7":["eb5ad0342ee8bffa4c3a79e4446b6027143ffc9a"],"07c824e7f6927860d366e4888be45e4db8c9e03b":["14d5815ecbef89580f5c48990bcd433f04f8563a"],"eb5ad0342ee8bffa4c3a79e4446b6027143ffc9a":["e758245b4acfbc0eae618c8f5d49f799d3b33157"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"14d5815ecbef89580f5c48990bcd433f04f8563a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["dd042b1ba3cc0f8bc92f7896c2c51438ba60e4fc"]},"commit2Childs":{"dd042b1ba3cc0f8bc92f7896c2c51438ba60e4fc":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e758245b4acfbc0eae618c8f5d49f799d3b33157":["eb5ad0342ee8bffa4c3a79e4446b6027143ffc9a"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["dd042b1ba3cc0f8bc92f7896c2c51438ba60e4fc","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"55980207f1977bd1463465de1659b821347e2fa8":[],"3f12b7260301796a1d2c5d6d3bbf5295b19ef0b7":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"07c824e7f6927860d366e4888be45e4db8c9e03b":["e758245b4acfbc0eae618c8f5d49f799d3b33157","55980207f1977bd1463465de1659b821347e2fa8"],"eb5ad0342ee8bffa4c3a79e4446b6027143ffc9a":["55980207f1977bd1463465de1659b821347e2fa8","3f12b7260301796a1d2c5d6d3bbf5295b19ef0b7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["14d5815ecbef89580f5c48990bcd433f04f8563a"],"14d5815ecbef89580f5c48990bcd433f04f8563a":["07c824e7f6927860d366e4888be45e4db8c9e03b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","55980207f1977bd1463465de1659b821347e2fa8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}