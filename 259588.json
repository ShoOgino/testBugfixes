{"path":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testMidUseUnload().mjava","commits":[{"id":"625b61328a0889d9b3d61cdcbfc490339f61096e","date":1452790491,"type":0,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testMidUseUnload().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testMidUseUnload() throws Exception {\n    final int maximumSleepMillis = random().nextInt(10000); // sleep for up to 10 s\n    if (VERBOSE) {\n      System.out.println(\"TestLazyCores.testMidUseUnload maximumSleepMillis=\"+maximumSleepMillis);\n    }\n    \n    class TestThread extends Thread {\n      \n      SolrCore core_to_use = null;\n      \n      @Override\n      public void run() {\n        \n        final int sleep_millis = random().nextInt(maximumSleepMillis);\n        try {\n          if (sleep_millis > 0) {\n            if (VERBOSE) {\n              System.out.println(\"TestLazyCores.testMidUseUnload Thread.run sleeping for \"+sleep_millis+\" ms\");\n            }\n            Thread.sleep(sleep_millis);\n          }\n        }\n        catch (InterruptedException ie) {\n          if (VERBOSE) {\n            System.out.println(\"TestLazyCores.testMidUseUnload Thread.run caught \"+ie+\" whilst sleeping for \"+sleep_millis+\" ms\");\n          }\n        }\n        \n        assertFalse(core_to_use.isClosed()); // not closed since we are still using it and hold a reference\n        core_to_use.close(); // now give up our reference to the core\n      }\n    };\n\n    CoreContainer cc = init();\n    \n    try {\n      TestThread thread = new TestThread();\n      \n      thread.core_to_use = cc.getCore(\"collection1\");\n      assertNotNull(thread.core_to_use);\n      assertFalse(thread.core_to_use.isClosed()); // freshly-in-use core is not closed\n      thread.start();\n      \n      unloadViaAdmin(cc, \"collection1\");\n      assertTrue(thread.core_to_use.isClosed()); // after unload-ing the core is closed\n\n      thread.join();\n    } finally {\n      cc.shutdown();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5a6ac8de25264a5542d711108a30ea530edd3a7","date":1466740167,"type":3,"author":"Erick","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testMidUseUnload().mjava","pathOld":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testMidUseUnload().mjava","sourceNew":"  @Test\n  public void testMidUseUnload() throws Exception {\n    final int maximumSleepMillis = random().nextInt(9999) + 1; // sleep for up to 10 s Must add 1 because using\n                                                               // this as a seed will rea few lines down will\n                                                               // throw an exception if this is zero\n    if (VERBOSE) {\n      System.out.println(\"TestLazyCores.testMidUseUnload maximumSleepMillis=\"+maximumSleepMillis);\n    }\n    \n    class TestThread extends Thread {\n      \n      SolrCore core_to_use = null;\n      \n      @Override\n      public void run() {\n        \n        final int sleep_millis = random().nextInt(maximumSleepMillis);\n        try {\n          if (sleep_millis > 0) {\n            if (VERBOSE) {\n              System.out.println(\"TestLazyCores.testMidUseUnload Thread.run sleeping for \"+sleep_millis+\" ms\");\n            }\n            Thread.sleep(sleep_millis);\n          }\n        }\n        catch (InterruptedException ie) {\n          if (VERBOSE) {\n            System.out.println(\"TestLazyCores.testMidUseUnload Thread.run caught \"+ie+\" whilst sleeping for \"+sleep_millis+\" ms\");\n          }\n        }\n        \n        assertFalse(core_to_use.isClosed()); // not closed since we are still using it and hold a reference\n        core_to_use.close(); // now give up our reference to the core\n      }\n    };\n\n    CoreContainer cc = init();\n    \n    try {\n      TestThread thread = new TestThread();\n      \n      thread.core_to_use = cc.getCore(\"collection1\");\n      assertNotNull(thread.core_to_use);\n      assertFalse(thread.core_to_use.isClosed()); // freshly-in-use core is not closed\n      thread.start();\n      \n      unloadViaAdmin(cc, \"collection1\");\n      assertTrue(thread.core_to_use.isClosed()); // after unload-ing the core is closed\n\n      thread.join();\n    } finally {\n      cc.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testMidUseUnload() throws Exception {\n    final int maximumSleepMillis = random().nextInt(10000); // sleep for up to 10 s\n    if (VERBOSE) {\n      System.out.println(\"TestLazyCores.testMidUseUnload maximumSleepMillis=\"+maximumSleepMillis);\n    }\n    \n    class TestThread extends Thread {\n      \n      SolrCore core_to_use = null;\n      \n      @Override\n      public void run() {\n        \n        final int sleep_millis = random().nextInt(maximumSleepMillis);\n        try {\n          if (sleep_millis > 0) {\n            if (VERBOSE) {\n              System.out.println(\"TestLazyCores.testMidUseUnload Thread.run sleeping for \"+sleep_millis+\" ms\");\n            }\n            Thread.sleep(sleep_millis);\n          }\n        }\n        catch (InterruptedException ie) {\n          if (VERBOSE) {\n            System.out.println(\"TestLazyCores.testMidUseUnload Thread.run caught \"+ie+\" whilst sleeping for \"+sleep_millis+\" ms\");\n          }\n        }\n        \n        assertFalse(core_to_use.isClosed()); // not closed since we are still using it and hold a reference\n        core_to_use.close(); // now give up our reference to the core\n      }\n    };\n\n    CoreContainer cc = init();\n    \n    try {\n      TestThread thread = new TestThread();\n      \n      thread.core_to_use = cc.getCore(\"collection1\");\n      assertNotNull(thread.core_to_use);\n      assertFalse(thread.core_to_use.isClosed()); // freshly-in-use core is not closed\n      thread.start();\n      \n      unloadViaAdmin(cc, \"collection1\");\n      assertTrue(thread.core_to_use.isClosed()); // after unload-ing the core is closed\n\n      thread.join();\n    } finally {\n      cc.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testMidUseUnload().mjava","pathOld":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testMidUseUnload().mjava","sourceNew":"  @Test\n  public void testMidUseUnload() throws Exception {\n    final int maximumSleepMillis = random().nextInt(9999) + 1; // sleep for up to 10 s Must add 1 because using\n                                                               // this as a seed will rea few lines down will\n                                                               // throw an exception if this is zero\n    if (VERBOSE) {\n      System.out.println(\"TestLazyCores.testMidUseUnload maximumSleepMillis=\"+maximumSleepMillis);\n    }\n    \n    class TestThread extends Thread {\n      \n      SolrCore core_to_use = null;\n      \n      @Override\n      public void run() {\n        \n        final int sleep_millis = random().nextInt(maximumSleepMillis);\n        try {\n          if (sleep_millis > 0) {\n            if (VERBOSE) {\n              System.out.println(\"TestLazyCores.testMidUseUnload Thread.run sleeping for \"+sleep_millis+\" ms\");\n            }\n            Thread.sleep(sleep_millis);\n          }\n        }\n        catch (InterruptedException ie) {\n          if (VERBOSE) {\n            System.out.println(\"TestLazyCores.testMidUseUnload Thread.run caught \"+ie+\" whilst sleeping for \"+sleep_millis+\" ms\");\n          }\n        }\n        \n        assertFalse(core_to_use.isClosed()); // not closed since we are still using it and hold a reference\n        core_to_use.close(); // now give up our reference to the core\n      }\n    };\n\n    CoreContainer cc = init();\n    \n    try {\n      TestThread thread = new TestThread();\n      \n      thread.core_to_use = cc.getCore(\"collection1\");\n      assertNotNull(thread.core_to_use);\n      assertFalse(thread.core_to_use.isClosed()); // freshly-in-use core is not closed\n      thread.start();\n      \n      unloadViaAdmin(cc, \"collection1\");\n      assertTrue(thread.core_to_use.isClosed()); // after unload-ing the core is closed\n\n      thread.join();\n    } finally {\n      cc.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testMidUseUnload() throws Exception {\n    final int maximumSleepMillis = random().nextInt(10000); // sleep for up to 10 s\n    if (VERBOSE) {\n      System.out.println(\"TestLazyCores.testMidUseUnload maximumSleepMillis=\"+maximumSleepMillis);\n    }\n    \n    class TestThread extends Thread {\n      \n      SolrCore core_to_use = null;\n      \n      @Override\n      public void run() {\n        \n        final int sleep_millis = random().nextInt(maximumSleepMillis);\n        try {\n          if (sleep_millis > 0) {\n            if (VERBOSE) {\n              System.out.println(\"TestLazyCores.testMidUseUnload Thread.run sleeping for \"+sleep_millis+\" ms\");\n            }\n            Thread.sleep(sleep_millis);\n          }\n        }\n        catch (InterruptedException ie) {\n          if (VERBOSE) {\n            System.out.println(\"TestLazyCores.testMidUseUnload Thread.run caught \"+ie+\" whilst sleeping for \"+sleep_millis+\" ms\");\n          }\n        }\n        \n        assertFalse(core_to_use.isClosed()); // not closed since we are still using it and hold a reference\n        core_to_use.close(); // now give up our reference to the core\n      }\n    };\n\n    CoreContainer cc = init();\n    \n    try {\n      TestThread thread = new TestThread();\n      \n      thread.core_to_use = cc.getCore(\"collection1\");\n      assertNotNull(thread.core_to_use);\n      assertFalse(thread.core_to_use.isClosed()); // freshly-in-use core is not closed\n      thread.start();\n      \n      unloadViaAdmin(cc, \"collection1\");\n      assertTrue(thread.core_to_use.isClosed()); // after unload-ing the core is closed\n\n      thread.join();\n    } finally {\n      cc.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad026d488f8fbf9ab33e5232d3343395c19b6cc8","date":1507308872,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testMidUseUnload().mjava","pathOld":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testMidUseUnload().mjava","sourceNew":"  @Test\n  public void testMidUseUnload() throws Exception {\n    final int maximumSleepMillis = random().nextInt(9999) + 1; // sleep for up to 10 s Must add 1 because using\n    // this as a seed will rea few lines down will\n    // throw an exception if this is zero\n    if (VERBOSE) {\n      System.out.println(\"TestLazyCores.testMidUseUnload maximumSleepMillis=\" + maximumSleepMillis);\n    }\n\n    class TestThread extends Thread {\n\n      SolrCore core_to_use = null;\n\n      @Override\n      public void run() {\n\n        final int sleep_millis = random().nextInt(maximumSleepMillis);\n        try {\n          if (sleep_millis > 0) {\n            if (VERBOSE) {\n              System.out.println(\"TestLazyCores.testMidUseUnload Thread.run sleeping for \" + sleep_millis + \" ms\");\n            }\n            Thread.sleep(sleep_millis);\n          }\n        } catch (InterruptedException ie) {\n          if (VERBOSE) {\n            System.out.println(\"TestLazyCores.testMidUseUnload Thread.run caught \" + ie + \" whilst sleeping for \" + sleep_millis + \" ms\");\n          }\n        }\n\n        assertFalse(core_to_use.isClosed()); // not closed since we are still using it and hold a reference\n        core_to_use.close(); // now give up our reference to the core\n      }\n    }\n    ;\n\n    CoreContainer cc = init();\n\n    try {\n      TestThread thread = new TestThread();\n\n      thread.core_to_use = cc.getCore(\"collection1\");\n      assertNotNull(thread.core_to_use);\n      assertFalse(thread.core_to_use.isClosed()); // freshly-in-use core is not closed\n      thread.start();\n\n      unloadViaAdmin(cc, \"collection1\");\n      assertTrue(thread.core_to_use.isClosed()); // after unload-ing the core is closed\n\n      thread.join();\n    } finally {\n      cc.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testMidUseUnload() throws Exception {\n    final int maximumSleepMillis = random().nextInt(9999) + 1; // sleep for up to 10 s Must add 1 because using\n                                                               // this as a seed will rea few lines down will\n                                                               // throw an exception if this is zero\n    if (VERBOSE) {\n      System.out.println(\"TestLazyCores.testMidUseUnload maximumSleepMillis=\"+maximumSleepMillis);\n    }\n    \n    class TestThread extends Thread {\n      \n      SolrCore core_to_use = null;\n      \n      @Override\n      public void run() {\n        \n        final int sleep_millis = random().nextInt(maximumSleepMillis);\n        try {\n          if (sleep_millis > 0) {\n            if (VERBOSE) {\n              System.out.println(\"TestLazyCores.testMidUseUnload Thread.run sleeping for \"+sleep_millis+\" ms\");\n            }\n            Thread.sleep(sleep_millis);\n          }\n        }\n        catch (InterruptedException ie) {\n          if (VERBOSE) {\n            System.out.println(\"TestLazyCores.testMidUseUnload Thread.run caught \"+ie+\" whilst sleeping for \"+sleep_millis+\" ms\");\n          }\n        }\n        \n        assertFalse(core_to_use.isClosed()); // not closed since we are still using it and hold a reference\n        core_to_use.close(); // now give up our reference to the core\n      }\n    };\n\n    CoreContainer cc = init();\n    \n    try {\n      TestThread thread = new TestThread();\n      \n      thread.core_to_use = cc.getCore(\"collection1\");\n      assertNotNull(thread.core_to_use);\n      assertFalse(thread.core_to_use.isClosed()); // freshly-in-use core is not closed\n      thread.start();\n      \n      unloadViaAdmin(cc, \"collection1\");\n      assertTrue(thread.core_to_use.isClosed()); // after unload-ing the core is closed\n\n      thread.join();\n    } finally {\n      cc.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"48e6317c36b128552eaed2363bb069267defb0e0","date":1507335877,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testMidUseUnload().mjava","pathOld":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testMidUseUnload().mjava","sourceNew":"  @Test\n  public void testMidUseUnload() throws Exception {\n    final int maximumSleepMillis = random().nextInt(9999) + 1; // sleep for up to 10 s Must add 1 because using\n                                                               // this as a seed will rea few lines down will\n                                                               // throw an exception if this is zero\n    if (VERBOSE) {\n      System.out.println(\"TestLazyCores.testMidUseUnload maximumSleepMillis=\"+maximumSleepMillis);\n    }\n    \n    class TestThread extends Thread {\n      \n      SolrCore core_to_use = null;\n      \n      @Override\n      public void run() {\n        \n        final int sleep_millis = random().nextInt(maximumSleepMillis);\n        try {\n          if (sleep_millis > 0) {\n            if (VERBOSE) {\n              System.out.println(\"TestLazyCores.testMidUseUnload Thread.run sleeping for \"+sleep_millis+\" ms\");\n            }\n            Thread.sleep(sleep_millis);\n          }\n        }\n        catch (InterruptedException ie) {\n          if (VERBOSE) {\n            System.out.println(\"TestLazyCores.testMidUseUnload Thread.run caught \"+ie+\" whilst sleeping for \"+sleep_millis+\" ms\");\n          }\n        }\n        \n        assertFalse(core_to_use.isClosed()); // not closed since we are still using it and hold a reference\n        core_to_use.close(); // now give up our reference to the core\n      }\n    };\n\n    CoreContainer cc = init();\n    \n    try {\n      TestThread thread = new TestThread();\n      \n      thread.core_to_use = cc.getCore(\"collection1\");\n      assertNotNull(thread.core_to_use);\n      assertFalse(thread.core_to_use.isClosed()); // freshly-in-use core is not closed\n      thread.start();\n      \n      unloadViaAdmin(cc, \"collection1\");\n      assertTrue(thread.core_to_use.isClosed()); // after unload-ing the core is closed\n\n      thread.join();\n    } finally {\n      cc.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testMidUseUnload() throws Exception {\n    final int maximumSleepMillis = random().nextInt(9999) + 1; // sleep for up to 10 s Must add 1 because using\n    // this as a seed will rea few lines down will\n    // throw an exception if this is zero\n    if (VERBOSE) {\n      System.out.println(\"TestLazyCores.testMidUseUnload maximumSleepMillis=\" + maximumSleepMillis);\n    }\n\n    class TestThread extends Thread {\n\n      SolrCore core_to_use = null;\n\n      @Override\n      public void run() {\n\n        final int sleep_millis = random().nextInt(maximumSleepMillis);\n        try {\n          if (sleep_millis > 0) {\n            if (VERBOSE) {\n              System.out.println(\"TestLazyCores.testMidUseUnload Thread.run sleeping for \" + sleep_millis + \" ms\");\n            }\n            Thread.sleep(sleep_millis);\n          }\n        } catch (InterruptedException ie) {\n          if (VERBOSE) {\n            System.out.println(\"TestLazyCores.testMidUseUnload Thread.run caught \" + ie + \" whilst sleeping for \" + sleep_millis + \" ms\");\n          }\n        }\n\n        assertFalse(core_to_use.isClosed()); // not closed since we are still using it and hold a reference\n        core_to_use.close(); // now give up our reference to the core\n      }\n    }\n    ;\n\n    CoreContainer cc = init();\n\n    try {\n      TestThread thread = new TestThread();\n\n      thread.core_to_use = cc.getCore(\"collection1\");\n      assertNotNull(thread.core_to_use);\n      assertFalse(thread.core_to_use.isClosed()); // freshly-in-use core is not closed\n      thread.start();\n\n      unloadViaAdmin(cc, \"collection1\");\n      assertTrue(thread.core_to_use.isClosed()); // after unload-ing the core is closed\n\n      thread.join();\n    } finally {\n      cc.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c5a6ac8de25264a5542d711108a30ea530edd3a7":["625b61328a0889d9b3d61cdcbfc490339f61096e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ad026d488f8fbf9ab33e5232d3343395c19b6cc8":["c5a6ac8de25264a5542d711108a30ea530edd3a7"],"625b61328a0889d9b3d61cdcbfc490339f61096e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["625b61328a0889d9b3d61cdcbfc490339f61096e","c5a6ac8de25264a5542d711108a30ea530edd3a7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["48e6317c36b128552eaed2363bb069267defb0e0"],"48e6317c36b128552eaed2363bb069267defb0e0":["ad026d488f8fbf9ab33e5232d3343395c19b6cc8"]},"commit2Childs":{"c5a6ac8de25264a5542d711108a30ea530edd3a7":["ad026d488f8fbf9ab33e5232d3343395c19b6cc8","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["625b61328a0889d9b3d61cdcbfc490339f61096e"],"ad026d488f8fbf9ab33e5232d3343395c19b6cc8":["48e6317c36b128552eaed2363bb069267defb0e0"],"625b61328a0889d9b3d61cdcbfc490339f61096e":["c5a6ac8de25264a5542d711108a30ea530edd3a7","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"48e6317c36b128552eaed2363bb069267defb0e0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}