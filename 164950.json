{"path":"lucene/sandbox/src/test/org/apache/lucene/document/TestNearest#testNearestNeighborRandom().mjava","commits":[{"id":"b01431682e11036a1a7d757a3fa7c1f903fb2c45","date":1460646145,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/TestNearest#testNearestNeighborRandom().mjava","pathOld":"/dev/null","sourceNew":"  public void testNearestNeighborRandom() throws Exception {\n    \n    int numPoints = atLeast(5000);\n    Directory dir;\n    if (numPoints > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    double[] lats = new double[numPoints];\n    double[] lons = new double[numPoints];\n\n    IndexWriterConfig iwc = getIndexWriterConfig();\n    iwc.setMergePolicy(newLogMergePolicy());\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int id=0;id<numPoints;id++) {\n      lats[id] = quantizeLat(GeoTestUtil.nextLatitude());\n      lons[id] = quantizeLon(GeoTestUtil.nextLongitude());\n      Document doc = new Document();\n      doc.add(new LatLonPoint(\"point\", lats[id], lons[id]));\n      doc.add(new StoredField(\"id\", id));\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n\n    DirectoryReader r = w.getReader();\n    if (VERBOSE) {      \n      System.out.println(\"TEST: reader=\" + r);\n    }\n    IndexSearcher s = newSearcher(r);\n    int iters = atLeast(100);\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {      \n        System.out.println(\"\\nTEST: iter=\" + iter);\n      }\n      double pointLat = GeoTestUtil.nextLatitude();\n      double pointLon = GeoTestUtil.nextLongitude();\n\n      // dumb brute force search to get the expected result:\n      NearestHit[] expectedHits = new NearestHit[lats.length];\n      for(int id=0;id<lats.length;id++) {\n        NearestHit hit = new NearestHit();\n        hit.distanceMeters = SloppyMath.haversinMeters(pointLat, pointLon, lats[id], lons[id]);\n        hit.docID = id;\n        expectedHits[id] = hit;\n      }\n\n      Arrays.sort(expectedHits, new Comparator<NearestHit>() {\n          @Override\n          public int compare(NearestHit a, NearestHit b) {\n            int cmp = Double.compare(a.distanceMeters, b.distanceMeters);\n            if (cmp != 0) {\n              return cmp;\n            }\n            // tie break by smaller docID:\n            return a.docID - b.docID;\n          }\n        });\n\n      int topN = TestUtil.nextInt(random(), 1, lats.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nhits for pointLat=\" + pointLat + \" pointLon=\" + pointLon);\n      }\n\n      // Also test with MatchAllDocsQuery, sorting by distance:\n      TopFieldDocs fieldDocs = s.search(new MatchAllDocsQuery(), topN, new Sort(LatLonPoint.newDistanceSort(\"point\", pointLat, pointLon)));\n\n      ScoreDoc[] hits = LatLonPoint.nearest(s, \"point\", pointLat, pointLon, topN).scoreDocs;\n      for(int i=0;i<topN;i++) {\n        NearestHit expected = expectedHits[i];\n        FieldDoc expected2 = (FieldDoc) fieldDocs.scoreDocs[i];\n        FieldDoc actual = (FieldDoc) hits[i];\n        Document actualDoc = r.document(actual.doc);\n\n        if (VERBOSE) {\n          System.out.println(\"hit \" + i);\n          System.out.println(\"  expected id=\" + expected.docID + \" lat=\" + lats[expected.docID] + \" lon=\" + lons[expected.docID] + \" distance=\" + expected.distanceMeters + \" meters\");\n          System.out.println(\"  actual id=\" + actualDoc.getField(\"id\") + \" distance=\" + actual.fields[0] + \" meters\");\n        }\n\n        assertEquals(expected.docID, actual.doc);\n        assertEquals(expected.distanceMeters, ((Double) actual.fields[0]).doubleValue(), 0.0);\n\n        assertEquals(expected.docID, expected.docID);\n        assertEquals(((Double) expected2.fields[0]).doubleValue(), expected.distanceMeters, 0.0);\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0c5157cc4f97bef35d7de60c890d7077e5315387","date":1460657452,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/TestNearest#testNearestNeighborRandom().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/TestNearest#testNearestNeighborRandom().mjava","sourceNew":"  public void testNearestNeighborRandom() throws Exception {\n    \n    int numPoints = atLeast(5000);\n    Directory dir;\n    if (numPoints > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    double[] lats = new double[numPoints];\n    double[] lons = new double[numPoints];\n\n    IndexWriterConfig iwc = getIndexWriterConfig();\n    iwc.setMergePolicy(newLogMergePolicy());\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int id=0;id<numPoints;id++) {\n      lats[id] = quantizeLat(GeoTestUtil.nextLatitude());\n      lons[id] = quantizeLon(GeoTestUtil.nextLongitude());\n      Document doc = new Document();\n      doc.add(new LatLonPoint(\"point\", lats[id], lons[id]));\n      doc.add(new StoredField(\"id\", id));\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n\n    DirectoryReader r = w.getReader();\n    if (VERBOSE) {      \n      System.out.println(\"TEST: reader=\" + r);\n    }\n    // can't wrap because we require Lucene60PointsFormat directly but e.g. ParallelReader wraps with its own points impl:\n    IndexSearcher s = newSearcher(r, false);\n    int iters = atLeast(100);\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {      \n        System.out.println(\"\\nTEST: iter=\" + iter);\n      }\n      double pointLat = GeoTestUtil.nextLatitude();\n      double pointLon = GeoTestUtil.nextLongitude();\n\n      // dumb brute force search to get the expected result:\n      NearestHit[] expectedHits = new NearestHit[lats.length];\n      for(int id=0;id<lats.length;id++) {\n        NearestHit hit = new NearestHit();\n        hit.distanceMeters = SloppyMath.haversinMeters(pointLat, pointLon, lats[id], lons[id]);\n        hit.docID = id;\n        expectedHits[id] = hit;\n      }\n\n      Arrays.sort(expectedHits, new Comparator<NearestHit>() {\n          @Override\n          public int compare(NearestHit a, NearestHit b) {\n            int cmp = Double.compare(a.distanceMeters, b.distanceMeters);\n            if (cmp != 0) {\n              return cmp;\n            }\n            // tie break by smaller docID:\n            return a.docID - b.docID;\n          }\n        });\n\n      int topN = TestUtil.nextInt(random(), 1, lats.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nhits for pointLat=\" + pointLat + \" pointLon=\" + pointLon);\n      }\n\n      // Also test with MatchAllDocsQuery, sorting by distance:\n      TopFieldDocs fieldDocs = s.search(new MatchAllDocsQuery(), topN, new Sort(LatLonPoint.newDistanceSort(\"point\", pointLat, pointLon)));\n\n      ScoreDoc[] hits = LatLonPoint.nearest(s, \"point\", pointLat, pointLon, topN).scoreDocs;\n      for(int i=0;i<topN;i++) {\n        NearestHit expected = expectedHits[i];\n        FieldDoc expected2 = (FieldDoc) fieldDocs.scoreDocs[i];\n        FieldDoc actual = (FieldDoc) hits[i];\n        Document actualDoc = r.document(actual.doc);\n\n        if (VERBOSE) {\n          System.out.println(\"hit \" + i);\n          System.out.println(\"  expected id=\" + expected.docID + \" lat=\" + lats[expected.docID] + \" lon=\" + lons[expected.docID] + \" distance=\" + expected.distanceMeters + \" meters\");\n          System.out.println(\"  actual id=\" + actualDoc.getField(\"id\") + \" distance=\" + actual.fields[0] + \" meters\");\n        }\n\n        assertEquals(expected.docID, actual.doc);\n        assertEquals(expected.distanceMeters, ((Double) actual.fields[0]).doubleValue(), 0.0);\n\n        assertEquals(expected.docID, expected.docID);\n        assertEquals(((Double) expected2.fields[0]).doubleValue(), expected.distanceMeters, 0.0);\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testNearestNeighborRandom() throws Exception {\n    \n    int numPoints = atLeast(5000);\n    Directory dir;\n    if (numPoints > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    double[] lats = new double[numPoints];\n    double[] lons = new double[numPoints];\n\n    IndexWriterConfig iwc = getIndexWriterConfig();\n    iwc.setMergePolicy(newLogMergePolicy());\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int id=0;id<numPoints;id++) {\n      lats[id] = quantizeLat(GeoTestUtil.nextLatitude());\n      lons[id] = quantizeLon(GeoTestUtil.nextLongitude());\n      Document doc = new Document();\n      doc.add(new LatLonPoint(\"point\", lats[id], lons[id]));\n      doc.add(new StoredField(\"id\", id));\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n\n    DirectoryReader r = w.getReader();\n    if (VERBOSE) {      \n      System.out.println(\"TEST: reader=\" + r);\n    }\n    IndexSearcher s = newSearcher(r);\n    int iters = atLeast(100);\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {      \n        System.out.println(\"\\nTEST: iter=\" + iter);\n      }\n      double pointLat = GeoTestUtil.nextLatitude();\n      double pointLon = GeoTestUtil.nextLongitude();\n\n      // dumb brute force search to get the expected result:\n      NearestHit[] expectedHits = new NearestHit[lats.length];\n      for(int id=0;id<lats.length;id++) {\n        NearestHit hit = new NearestHit();\n        hit.distanceMeters = SloppyMath.haversinMeters(pointLat, pointLon, lats[id], lons[id]);\n        hit.docID = id;\n        expectedHits[id] = hit;\n      }\n\n      Arrays.sort(expectedHits, new Comparator<NearestHit>() {\n          @Override\n          public int compare(NearestHit a, NearestHit b) {\n            int cmp = Double.compare(a.distanceMeters, b.distanceMeters);\n            if (cmp != 0) {\n              return cmp;\n            }\n            // tie break by smaller docID:\n            return a.docID - b.docID;\n          }\n        });\n\n      int topN = TestUtil.nextInt(random(), 1, lats.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nhits for pointLat=\" + pointLat + \" pointLon=\" + pointLon);\n      }\n\n      // Also test with MatchAllDocsQuery, sorting by distance:\n      TopFieldDocs fieldDocs = s.search(new MatchAllDocsQuery(), topN, new Sort(LatLonPoint.newDistanceSort(\"point\", pointLat, pointLon)));\n\n      ScoreDoc[] hits = LatLonPoint.nearest(s, \"point\", pointLat, pointLon, topN).scoreDocs;\n      for(int i=0;i<topN;i++) {\n        NearestHit expected = expectedHits[i];\n        FieldDoc expected2 = (FieldDoc) fieldDocs.scoreDocs[i];\n        FieldDoc actual = (FieldDoc) hits[i];\n        Document actualDoc = r.document(actual.doc);\n\n        if (VERBOSE) {\n          System.out.println(\"hit \" + i);\n          System.out.println(\"  expected id=\" + expected.docID + \" lat=\" + lats[expected.docID] + \" lon=\" + lons[expected.docID] + \" distance=\" + expected.distanceMeters + \" meters\");\n          System.out.println(\"  actual id=\" + actualDoc.getField(\"id\") + \" distance=\" + actual.fields[0] + \" meters\");\n        }\n\n        assertEquals(expected.docID, actual.doc);\n        assertEquals(expected.distanceMeters, ((Double) actual.fields[0]).doubleValue(), 0.0);\n\n        assertEquals(expected.docID, expected.docID);\n        assertEquals(((Double) expected2.fields[0]).doubleValue(), expected.distanceMeters, 0.0);\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cc75470f235495b4ac71f43bba9b503023f7f2d0","date":1461532530,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/TestNearest#testNearestNeighborRandom().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/TestNearest#testNearestNeighborRandom().mjava","sourceNew":"  public void testNearestNeighborRandom() throws Exception {\n    \n    int numPoints = atLeast(5000);\n    Directory dir;\n    if (numPoints > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    double[] lats = new double[numPoints];\n    double[] lons = new double[numPoints];\n\n    IndexWriterConfig iwc = getIndexWriterConfig();\n    iwc.setMergePolicy(newLogMergePolicy());\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int id=0;id<numPoints;id++) {\n      lats[id] = quantizeLat(GeoTestUtil.nextLatitude());\n      lons[id] = quantizeLon(GeoTestUtil.nextLongitude());\n      Document doc = new Document();\n      doc.add(new LatLonPoint(\"point\", lats[id], lons[id]));\n      doc.add(new LatLonDocValuesField(\"point\", lats[id], lons[id]));\n      doc.add(new StoredField(\"id\", id));\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n\n    DirectoryReader r = w.getReader();\n    if (VERBOSE) {      \n      System.out.println(\"TEST: reader=\" + r);\n    }\n    // can't wrap because we require Lucene60PointsFormat directly but e.g. ParallelReader wraps with its own points impl:\n    IndexSearcher s = newSearcher(r, false);\n    int iters = atLeast(100);\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {      \n        System.out.println(\"\\nTEST: iter=\" + iter);\n      }\n      double pointLat = GeoTestUtil.nextLatitude();\n      double pointLon = GeoTestUtil.nextLongitude();\n\n      // dumb brute force search to get the expected result:\n      NearestHit[] expectedHits = new NearestHit[lats.length];\n      for(int id=0;id<lats.length;id++) {\n        NearestHit hit = new NearestHit();\n        hit.distanceMeters = SloppyMath.haversinMeters(pointLat, pointLon, lats[id], lons[id]);\n        hit.docID = id;\n        expectedHits[id] = hit;\n      }\n\n      Arrays.sort(expectedHits, new Comparator<NearestHit>() {\n          @Override\n          public int compare(NearestHit a, NearestHit b) {\n            int cmp = Double.compare(a.distanceMeters, b.distanceMeters);\n            if (cmp != 0) {\n              return cmp;\n            }\n            // tie break by smaller docID:\n            return a.docID - b.docID;\n          }\n        });\n\n      int topN = TestUtil.nextInt(random(), 1, lats.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nhits for pointLat=\" + pointLat + \" pointLon=\" + pointLon);\n      }\n\n      // Also test with MatchAllDocsQuery, sorting by distance:\n      TopFieldDocs fieldDocs = s.search(new MatchAllDocsQuery(), topN, new Sort(LatLonDocValuesField.newDistanceSort(\"point\", pointLat, pointLon)));\n\n      ScoreDoc[] hits = LatLonPoint.nearest(s, \"point\", pointLat, pointLon, topN).scoreDocs;\n      for(int i=0;i<topN;i++) {\n        NearestHit expected = expectedHits[i];\n        FieldDoc expected2 = (FieldDoc) fieldDocs.scoreDocs[i];\n        FieldDoc actual = (FieldDoc) hits[i];\n        Document actualDoc = r.document(actual.doc);\n\n        if (VERBOSE) {\n          System.out.println(\"hit \" + i);\n          System.out.println(\"  expected id=\" + expected.docID + \" lat=\" + lats[expected.docID] + \" lon=\" + lons[expected.docID] + \" distance=\" + expected.distanceMeters + \" meters\");\n          System.out.println(\"  actual id=\" + actualDoc.getField(\"id\") + \" distance=\" + actual.fields[0] + \" meters\");\n        }\n\n        assertEquals(expected.docID, actual.doc);\n        assertEquals(expected.distanceMeters, ((Double) actual.fields[0]).doubleValue(), 0.0);\n\n        assertEquals(expected.docID, expected.docID);\n        assertEquals(((Double) expected2.fields[0]).doubleValue(), expected.distanceMeters, 0.0);\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testNearestNeighborRandom() throws Exception {\n    \n    int numPoints = atLeast(5000);\n    Directory dir;\n    if (numPoints > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    double[] lats = new double[numPoints];\n    double[] lons = new double[numPoints];\n\n    IndexWriterConfig iwc = getIndexWriterConfig();\n    iwc.setMergePolicy(newLogMergePolicy());\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int id=0;id<numPoints;id++) {\n      lats[id] = quantizeLat(GeoTestUtil.nextLatitude());\n      lons[id] = quantizeLon(GeoTestUtil.nextLongitude());\n      Document doc = new Document();\n      doc.add(new LatLonPoint(\"point\", lats[id], lons[id]));\n      doc.add(new StoredField(\"id\", id));\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n\n    DirectoryReader r = w.getReader();\n    if (VERBOSE) {      \n      System.out.println(\"TEST: reader=\" + r);\n    }\n    // can't wrap because we require Lucene60PointsFormat directly but e.g. ParallelReader wraps with its own points impl:\n    IndexSearcher s = newSearcher(r, false);\n    int iters = atLeast(100);\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {      \n        System.out.println(\"\\nTEST: iter=\" + iter);\n      }\n      double pointLat = GeoTestUtil.nextLatitude();\n      double pointLon = GeoTestUtil.nextLongitude();\n\n      // dumb brute force search to get the expected result:\n      NearestHit[] expectedHits = new NearestHit[lats.length];\n      for(int id=0;id<lats.length;id++) {\n        NearestHit hit = new NearestHit();\n        hit.distanceMeters = SloppyMath.haversinMeters(pointLat, pointLon, lats[id], lons[id]);\n        hit.docID = id;\n        expectedHits[id] = hit;\n      }\n\n      Arrays.sort(expectedHits, new Comparator<NearestHit>() {\n          @Override\n          public int compare(NearestHit a, NearestHit b) {\n            int cmp = Double.compare(a.distanceMeters, b.distanceMeters);\n            if (cmp != 0) {\n              return cmp;\n            }\n            // tie break by smaller docID:\n            return a.docID - b.docID;\n          }\n        });\n\n      int topN = TestUtil.nextInt(random(), 1, lats.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nhits for pointLat=\" + pointLat + \" pointLon=\" + pointLon);\n      }\n\n      // Also test with MatchAllDocsQuery, sorting by distance:\n      TopFieldDocs fieldDocs = s.search(new MatchAllDocsQuery(), topN, new Sort(LatLonPoint.newDistanceSort(\"point\", pointLat, pointLon)));\n\n      ScoreDoc[] hits = LatLonPoint.nearest(s, \"point\", pointLat, pointLon, topN).scoreDocs;\n      for(int i=0;i<topN;i++) {\n        NearestHit expected = expectedHits[i];\n        FieldDoc expected2 = (FieldDoc) fieldDocs.scoreDocs[i];\n        FieldDoc actual = (FieldDoc) hits[i];\n        Document actualDoc = r.document(actual.doc);\n\n        if (VERBOSE) {\n          System.out.println(\"hit \" + i);\n          System.out.println(\"  expected id=\" + expected.docID + \" lat=\" + lats[expected.docID] + \" lon=\" + lons[expected.docID] + \" distance=\" + expected.distanceMeters + \" meters\");\n          System.out.println(\"  actual id=\" + actualDoc.getField(\"id\") + \" distance=\" + actual.fields[0] + \" meters\");\n        }\n\n        assertEquals(expected.docID, actual.doc);\n        assertEquals(expected.distanceMeters, ((Double) actual.fields[0]).doubleValue(), 0.0);\n\n        assertEquals(expected.docID, expected.docID);\n        assertEquals(((Double) expected2.fields[0]).doubleValue(), expected.distanceMeters, 0.0);\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7f901826e47f75f810d7aae24b0455d21ea1fe2","date":1461678892,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/TestNearest#testNearestNeighborRandom().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/TestNearest#testNearestNeighborRandom().mjava","sourceNew":"  public void testNearestNeighborRandom() throws Exception {\n    \n    int numPoints = atLeast(5000);\n    Directory dir;\n    if (numPoints > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    double[] lats = new double[numPoints];\n    double[] lons = new double[numPoints];\n\n    IndexWriterConfig iwc = getIndexWriterConfig();\n    iwc.setMergePolicy(newLogMergePolicy());\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int id=0;id<numPoints;id++) {\n      lats[id] = quantizeLat(GeoTestUtil.nextLatitude());\n      lons[id] = quantizeLon(GeoTestUtil.nextLongitude());\n      Document doc = new Document();\n      doc.add(new LatLonPoint(\"point\", lats[id], lons[id]));\n      doc.add(new LatLonDocValuesField(\"point\", lats[id], lons[id]));\n      doc.add(new StoredField(\"id\", id));\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n\n    DirectoryReader r = w.getReader();\n    if (VERBOSE) {      \n      System.out.println(\"TEST: reader=\" + r);\n    }\n    // can't wrap because we require Lucene60PointsFormat directly but e.g. ParallelReader wraps with its own points impl:\n    IndexSearcher s = newSearcher(r, false);\n    int iters = atLeast(100);\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {      \n        System.out.println(\"\\nTEST: iter=\" + iter);\n      }\n      double pointLat = GeoTestUtil.nextLatitude();\n      double pointLon = GeoTestUtil.nextLongitude();\n\n      // dumb brute force search to get the expected result:\n      NearestHit[] expectedHits = new NearestHit[lats.length];\n      for(int id=0;id<lats.length;id++) {\n        NearestHit hit = new NearestHit();\n        hit.distanceMeters = SloppyMath.haversinMeters(pointLat, pointLon, lats[id], lons[id]);\n        hit.docID = id;\n        expectedHits[id] = hit;\n      }\n\n      Arrays.sort(expectedHits, new Comparator<NearestHit>() {\n          @Override\n          public int compare(NearestHit a, NearestHit b) {\n            int cmp = Double.compare(a.distanceMeters, b.distanceMeters);\n            if (cmp != 0) {\n              return cmp;\n            }\n            // tie break by smaller docID:\n            return a.docID - b.docID;\n          }\n        });\n\n      int topN = TestUtil.nextInt(random(), 1, lats.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nhits for pointLat=\" + pointLat + \" pointLon=\" + pointLon);\n      }\n\n      // Also test with MatchAllDocsQuery, sorting by distance:\n      TopFieldDocs fieldDocs = s.search(new MatchAllDocsQuery(), topN, new Sort(LatLonDocValuesField.newDistanceSort(\"point\", pointLat, pointLon)));\n\n      ScoreDoc[] hits = LatLonPoint.nearest(s, \"point\", pointLat, pointLon, topN).scoreDocs;\n      for(int i=0;i<topN;i++) {\n        NearestHit expected = expectedHits[i];\n        FieldDoc expected2 = (FieldDoc) fieldDocs.scoreDocs[i];\n        FieldDoc actual = (FieldDoc) hits[i];\n        Document actualDoc = r.document(actual.doc);\n\n        if (VERBOSE) {\n          System.out.println(\"hit \" + i);\n          System.out.println(\"  expected id=\" + expected.docID + \" lat=\" + lats[expected.docID] + \" lon=\" + lons[expected.docID] + \" distance=\" + expected.distanceMeters + \" meters\");\n          System.out.println(\"  actual id=\" + actualDoc.getField(\"id\") + \" distance=\" + actual.fields[0] + \" meters\");\n        }\n\n        assertEquals(expected.docID, actual.doc);\n        assertEquals(expected.distanceMeters, ((Double) actual.fields[0]).doubleValue(), 0.0);\n\n        assertEquals(expected.docID, expected.docID);\n        assertEquals(((Double) expected2.fields[0]).doubleValue(), expected.distanceMeters, 0.0);\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testNearestNeighborRandom() throws Exception {\n    \n    int numPoints = atLeast(5000);\n    Directory dir;\n    if (numPoints > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    double[] lats = new double[numPoints];\n    double[] lons = new double[numPoints];\n\n    IndexWriterConfig iwc = getIndexWriterConfig();\n    iwc.setMergePolicy(newLogMergePolicy());\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int id=0;id<numPoints;id++) {\n      lats[id] = quantizeLat(GeoTestUtil.nextLatitude());\n      lons[id] = quantizeLon(GeoTestUtil.nextLongitude());\n      Document doc = new Document();\n      doc.add(new LatLonPoint(\"point\", lats[id], lons[id]));\n      doc.add(new StoredField(\"id\", id));\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n\n    DirectoryReader r = w.getReader();\n    if (VERBOSE) {      \n      System.out.println(\"TEST: reader=\" + r);\n    }\n    // can't wrap because we require Lucene60PointsFormat directly but e.g. ParallelReader wraps with its own points impl:\n    IndexSearcher s = newSearcher(r, false);\n    int iters = atLeast(100);\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {      \n        System.out.println(\"\\nTEST: iter=\" + iter);\n      }\n      double pointLat = GeoTestUtil.nextLatitude();\n      double pointLon = GeoTestUtil.nextLongitude();\n\n      // dumb brute force search to get the expected result:\n      NearestHit[] expectedHits = new NearestHit[lats.length];\n      for(int id=0;id<lats.length;id++) {\n        NearestHit hit = new NearestHit();\n        hit.distanceMeters = SloppyMath.haversinMeters(pointLat, pointLon, lats[id], lons[id]);\n        hit.docID = id;\n        expectedHits[id] = hit;\n      }\n\n      Arrays.sort(expectedHits, new Comparator<NearestHit>() {\n          @Override\n          public int compare(NearestHit a, NearestHit b) {\n            int cmp = Double.compare(a.distanceMeters, b.distanceMeters);\n            if (cmp != 0) {\n              return cmp;\n            }\n            // tie break by smaller docID:\n            return a.docID - b.docID;\n          }\n        });\n\n      int topN = TestUtil.nextInt(random(), 1, lats.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nhits for pointLat=\" + pointLat + \" pointLon=\" + pointLon);\n      }\n\n      // Also test with MatchAllDocsQuery, sorting by distance:\n      TopFieldDocs fieldDocs = s.search(new MatchAllDocsQuery(), topN, new Sort(LatLonPoint.newDistanceSort(\"point\", pointLat, pointLon)));\n\n      ScoreDoc[] hits = LatLonPoint.nearest(s, \"point\", pointLat, pointLon, topN).scoreDocs;\n      for(int i=0;i<topN;i++) {\n        NearestHit expected = expectedHits[i];\n        FieldDoc expected2 = (FieldDoc) fieldDocs.scoreDocs[i];\n        FieldDoc actual = (FieldDoc) hits[i];\n        Document actualDoc = r.document(actual.doc);\n\n        if (VERBOSE) {\n          System.out.println(\"hit \" + i);\n          System.out.println(\"  expected id=\" + expected.docID + \" lat=\" + lats[expected.docID] + \" lon=\" + lons[expected.docID] + \" distance=\" + expected.distanceMeters + \" meters\");\n          System.out.println(\"  actual id=\" + actualDoc.getField(\"id\") + \" distance=\" + actual.fields[0] + \" meters\");\n        }\n\n        assertEquals(expected.docID, actual.doc);\n        assertEquals(expected.distanceMeters, ((Double) actual.fields[0]).doubleValue(), 0.0);\n\n        assertEquals(expected.docID, expected.docID);\n        assertEquals(((Double) expected2.fields[0]).doubleValue(), expected.distanceMeters, 0.0);\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"88b0212386fe531136816706dc37dc49b9dbf7dc","date":1532560226,"type":5,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestNearest#testNearestNeighborRandom().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/TestNearest#testNearestNeighborRandom().mjava","sourceNew":"  public void testNearestNeighborRandom() throws Exception {\n    \n    int numPoints = atLeast(5000);\n    Directory dir;\n    if (numPoints > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    double[] lats = new double[numPoints];\n    double[] lons = new double[numPoints];\n\n    IndexWriterConfig iwc = getIndexWriterConfig();\n    iwc.setMergePolicy(newLogMergePolicy());\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int id=0;id<numPoints;id++) {\n      lats[id] = quantizeLat(GeoTestUtil.nextLatitude());\n      lons[id] = quantizeLon(GeoTestUtil.nextLongitude());\n      Document doc = new Document();\n      doc.add(new LatLonPoint(\"point\", lats[id], lons[id]));\n      doc.add(new LatLonDocValuesField(\"point\", lats[id], lons[id]));\n      doc.add(new StoredField(\"id\", id));\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n\n    DirectoryReader r = w.getReader();\n    if (VERBOSE) {      \n      System.out.println(\"TEST: reader=\" + r);\n    }\n    // can't wrap because we require Lucene60PointsFormat directly but e.g. ParallelReader wraps with its own points impl:\n    IndexSearcher s = newSearcher(r, false);\n    int iters = atLeast(100);\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {      \n        System.out.println(\"\\nTEST: iter=\" + iter);\n      }\n      double pointLat = GeoTestUtil.nextLatitude();\n      double pointLon = GeoTestUtil.nextLongitude();\n\n      // dumb brute force search to get the expected result:\n      NearestHit[] expectedHits = new NearestHit[lats.length];\n      for(int id=0;id<lats.length;id++) {\n        NearestHit hit = new NearestHit();\n        hit.distanceMeters = SloppyMath.haversinMeters(pointLat, pointLon, lats[id], lons[id]);\n        hit.docID = id;\n        expectedHits[id] = hit;\n      }\n\n      Arrays.sort(expectedHits, new Comparator<NearestHit>() {\n          @Override\n          public int compare(NearestHit a, NearestHit b) {\n            int cmp = Double.compare(a.distanceMeters, b.distanceMeters);\n            if (cmp != 0) {\n              return cmp;\n            }\n            // tie break by smaller docID:\n            return a.docID - b.docID;\n          }\n        });\n\n      int topN = TestUtil.nextInt(random(), 1, lats.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nhits for pointLat=\" + pointLat + \" pointLon=\" + pointLon);\n      }\n\n      // Also test with MatchAllDocsQuery, sorting by distance:\n      TopFieldDocs fieldDocs = s.search(new MatchAllDocsQuery(), topN, new Sort(LatLonDocValuesField.newDistanceSort(\"point\", pointLat, pointLon)));\n\n      ScoreDoc[] hits = LatLonPointPrototypeQueries.nearest(s, \"point\", pointLat, pointLon, topN).scoreDocs;\n      for(int i=0;i<topN;i++) {\n        NearestHit expected = expectedHits[i];\n        FieldDoc expected2 = (FieldDoc) fieldDocs.scoreDocs[i];\n        FieldDoc actual = (FieldDoc) hits[i];\n        Document actualDoc = r.document(actual.doc);\n\n        if (VERBOSE) {\n          System.out.println(\"hit \" + i);\n          System.out.println(\"  expected id=\" + expected.docID + \" lat=\" + lats[expected.docID] + \" lon=\" + lons[expected.docID] + \" distance=\" + expected.distanceMeters + \" meters\");\n          System.out.println(\"  actual id=\" + actualDoc.getField(\"id\") + \" distance=\" + actual.fields[0] + \" meters\");\n        }\n\n        assertEquals(expected.docID, actual.doc);\n        assertEquals(expected.distanceMeters, ((Double) actual.fields[0]).doubleValue(), 0.0);\n\n        assertEquals(expected.docID, expected.docID);\n        assertEquals(((Double) expected2.fields[0]).doubleValue(), expected.distanceMeters, 0.0);\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testNearestNeighborRandom() throws Exception {\n    \n    int numPoints = atLeast(5000);\n    Directory dir;\n    if (numPoints > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n    double[] lats = new double[numPoints];\n    double[] lons = new double[numPoints];\n\n    IndexWriterConfig iwc = getIndexWriterConfig();\n    iwc.setMergePolicy(newLogMergePolicy());\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int id=0;id<numPoints;id++) {\n      lats[id] = quantizeLat(GeoTestUtil.nextLatitude());\n      lons[id] = quantizeLon(GeoTestUtil.nextLongitude());\n      Document doc = new Document();\n      doc.add(new LatLonPoint(\"point\", lats[id], lons[id]));\n      doc.add(new LatLonDocValuesField(\"point\", lats[id], lons[id]));\n      doc.add(new StoredField(\"id\", id));\n      w.addDocument(doc);\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n\n    DirectoryReader r = w.getReader();\n    if (VERBOSE) {      \n      System.out.println(\"TEST: reader=\" + r);\n    }\n    // can't wrap because we require Lucene60PointsFormat directly but e.g. ParallelReader wraps with its own points impl:\n    IndexSearcher s = newSearcher(r, false);\n    int iters = atLeast(100);\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {      \n        System.out.println(\"\\nTEST: iter=\" + iter);\n      }\n      double pointLat = GeoTestUtil.nextLatitude();\n      double pointLon = GeoTestUtil.nextLongitude();\n\n      // dumb brute force search to get the expected result:\n      NearestHit[] expectedHits = new NearestHit[lats.length];\n      for(int id=0;id<lats.length;id++) {\n        NearestHit hit = new NearestHit();\n        hit.distanceMeters = SloppyMath.haversinMeters(pointLat, pointLon, lats[id], lons[id]);\n        hit.docID = id;\n        expectedHits[id] = hit;\n      }\n\n      Arrays.sort(expectedHits, new Comparator<NearestHit>() {\n          @Override\n          public int compare(NearestHit a, NearestHit b) {\n            int cmp = Double.compare(a.distanceMeters, b.distanceMeters);\n            if (cmp != 0) {\n              return cmp;\n            }\n            // tie break by smaller docID:\n            return a.docID - b.docID;\n          }\n        });\n\n      int topN = TestUtil.nextInt(random(), 1, lats.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nhits for pointLat=\" + pointLat + \" pointLon=\" + pointLon);\n      }\n\n      // Also test with MatchAllDocsQuery, sorting by distance:\n      TopFieldDocs fieldDocs = s.search(new MatchAllDocsQuery(), topN, new Sort(LatLonDocValuesField.newDistanceSort(\"point\", pointLat, pointLon)));\n\n      ScoreDoc[] hits = LatLonPoint.nearest(s, \"point\", pointLat, pointLon, topN).scoreDocs;\n      for(int i=0;i<topN;i++) {\n        NearestHit expected = expectedHits[i];\n        FieldDoc expected2 = (FieldDoc) fieldDocs.scoreDocs[i];\n        FieldDoc actual = (FieldDoc) hits[i];\n        Document actualDoc = r.document(actual.doc);\n\n        if (VERBOSE) {\n          System.out.println(\"hit \" + i);\n          System.out.println(\"  expected id=\" + expected.docID + \" lat=\" + lats[expected.docID] + \" lon=\" + lons[expected.docID] + \" distance=\" + expected.distanceMeters + \" meters\");\n          System.out.println(\"  actual id=\" + actualDoc.getField(\"id\") + \" distance=\" + actual.fields[0] + \" meters\");\n        }\n\n        assertEquals(expected.docID, actual.doc);\n        assertEquals(expected.distanceMeters, ((Double) actual.fields[0]).doubleValue(), 0.0);\n\n        assertEquals(expected.docID, expected.docID);\n        assertEquals(((Double) expected2.fields[0]).doubleValue(), expected.distanceMeters, 0.0);\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0c5157cc4f97bef35d7de60c890d7077e5315387":["b01431682e11036a1a7d757a3fa7c1f903fb2c45"],"b01431682e11036a1a7d757a3fa7c1f903fb2c45":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"88b0212386fe531136816706dc37dc49b9dbf7dc":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["0c5157cc4f97bef35d7de60c890d7077e5315387","cc75470f235495b4ac71f43bba9b503023f7f2d0"],"cc75470f235495b4ac71f43bba9b503023f7f2d0":["0c5157cc4f97bef35d7de60c890d7077e5315387"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["88b0212386fe531136816706dc37dc49b9dbf7dc"]},"commit2Childs":{"0c5157cc4f97bef35d7de60c890d7077e5315387":["f7f901826e47f75f810d7aae24b0455d21ea1fe2","cc75470f235495b4ac71f43bba9b503023f7f2d0"],"b01431682e11036a1a7d757a3fa7c1f903fb2c45":["0c5157cc4f97bef35d7de60c890d7077e5315387"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b01431682e11036a1a7d757a3fa7c1f903fb2c45"],"88b0212386fe531136816706dc37dc49b9dbf7dc":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["88b0212386fe531136816706dc37dc49b9dbf7dc"],"cc75470f235495b4ac71f43bba9b503023f7f2d0":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}