{"path":"lucene/src/java/org/apache/lucene/search/UnionDocsAndPositionsEnum[MultiPhraseQuery]#UnionDocsAndPositionsEnum(Bits,IndexReader,Term[]).mjava","commits":[{"id":"d827579cb8382b568e1eb2ab73a72189eb3d9b80","date":1317751030,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/UnionDocsAndPositionsEnum[MultiPhraseQuery]#UnionDocsAndPositionsEnum(Bits,IndexReader,Term[]).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/UnionDocsAndPositionsEnum[MultiPhraseQuery]#UnionDocsAndPositionsEnum(IndexReader,Term[]).mjava","sourceNew":"  public UnionDocsAndPositionsEnum(Bits liveDocs, IndexReader indexReader, Term[] terms) throws IOException {\n    List<DocsAndPositionsEnum> docsEnums = new LinkedList<DocsAndPositionsEnum>();\n    for (int i = 0; i < terms.length; i++) {\n      DocsAndPositionsEnum postings = indexReader.termPositionsEnum(liveDocs,\n                                                                    terms[i].field(),\n                                                                    terms[i].bytes());\n      if (postings != null) {\n        docsEnums.add(postings);\n      } else {\n        if (indexReader.termDocsEnum(liveDocs, terms[i].field(), terms[i].bytes()) != null) {\n          // term does exist, but has no positions\n          throw new IllegalStateException(\"field \\\"\" + terms[i].field() + \"\\\" was indexed without position data; cannot run PhraseQuery (term=\" + terms[i].text() + \")\");\n        }\n      }\n    }\n\n    _queue = new DocsQueue(docsEnums);\n    _posList = new IntQueue();\n  }\n\n","sourceOld":"  public UnionDocsAndPositionsEnum(IndexReader indexReader, Term[] terms) throws IOException {\n    List<DocsAndPositionsEnum> docsEnums = new LinkedList<DocsAndPositionsEnum>();\n    final Bits liveDocs = indexReader.getLiveDocs();\n    for (int i = 0; i < terms.length; i++) {\n      DocsAndPositionsEnum postings = indexReader.termPositionsEnum(liveDocs,\n                                                                    terms[i].field(),\n                                                                    terms[i].bytes());\n      if (postings != null) {\n        docsEnums.add(postings);\n      } else {\n        if (indexReader.termDocsEnum(liveDocs, terms[i].field(), terms[i].bytes()) != null) {\n          // term does exist, but has no positions\n          throw new IllegalStateException(\"field \\\"\" + terms[i].field() + \"\\\" was indexed without position data; cannot run PhraseQuery (term=\" + terms[i].text() + \")\");\n        }\n      }\n    }\n\n    _queue = new DocsQueue(docsEnums);\n    _posList = new IntQueue();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e2297162a22c55456e200caef2cbcb00fe381120","date":1321551342,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/search/UnionDocsAndPositionsEnum[MultiPhraseQuery]#UnionDocsAndPositionsEnum(Bits,IndexReader,Term[]).mjava","sourceNew":null,"sourceOld":"  public UnionDocsAndPositionsEnum(Bits liveDocs, IndexReader indexReader, Term[] terms) throws IOException {\n    List<DocsAndPositionsEnum> docsEnums = new LinkedList<DocsAndPositionsEnum>();\n    for (int i = 0; i < terms.length; i++) {\n      DocsAndPositionsEnum postings = indexReader.termPositionsEnum(liveDocs,\n                                                                    terms[i].field(),\n                                                                    terms[i].bytes());\n      if (postings != null) {\n        docsEnums.add(postings);\n      } else {\n        if (indexReader.termDocsEnum(liveDocs, terms[i].field(), terms[i].bytes()) != null) {\n          // term does exist, but has no positions\n          throw new IllegalStateException(\"field \\\"\" + terms[i].field() + \"\\\" was indexed without position data; cannot run PhraseQuery (term=\" + terms[i].text() + \")\");\n        }\n      }\n    }\n\n    _queue = new DocsQueue(docsEnums);\n    _posList = new IntQueue();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d827579cb8382b568e1eb2ab73a72189eb3d9b80":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e2297162a22c55456e200caef2cbcb00fe381120":["d827579cb8382b568e1eb2ab73a72189eb3d9b80"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e2297162a22c55456e200caef2cbcb00fe381120"]},"commit2Childs":{"d827579cb8382b568e1eb2ab73a72189eb3d9b80":["e2297162a22c55456e200caef2cbcb00fe381120"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d827579cb8382b568e1eb2ab73a72189eb3d9b80"],"e2297162a22c55456e200caef2cbcb00fe381120":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}