{"path":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","commits":[{"id":"2c30e4c1cee08b3b229a77991882594fe7250b66","date":1344448871,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n\n    indexr(id, 0, \"a_t\", \"to come to the aid of their country.\");\n    \n    // compare leaders list\n    CloudJettyRunner shard1Leader = shardToLeaderJetty.get(\"shard1\");\n    CloudJettyRunner shard2Leader = shardToLeaderJetty.get(\"shard2\");\n    assertEquals(2, cloudClient.getLeaderUrlList().size());\n    HashSet<String> leaderUrlSet = new HashSet<String>();\n    leaderUrlSet.addAll(cloudClient.getLeaderUrlList());\n    assertTrue(\"fail check for leader:\" + shard1Leader.url + \" in \"\n        + leaderUrlSet, leaderUrlSet.contains(shard1Leader.url + \"/\"));\n    assertTrue(\"fail check for leader:\" + shard2Leader.url + \" in \"\n        + leaderUrlSet, leaderUrlSet.contains(shard2Leader.url + \"/\"));\n\n    // compare replicas list\n    Set<String> replicas = new HashSet<String>();\n    List<CloudJettyRunner> jetties = shardToJetty.get(\"shard1\");\n    for (CloudJettyRunner cjetty : jetties) {\n      replicas.add(cjetty.url);\n    }\n    jetties = shardToJetty.get(\"shard2\");\n    for (CloudJettyRunner cjetty : jetties) {\n      replicas.add(cjetty.url);\n    }\n    replicas.remove(shard1Leader.url);\n    replicas.remove(shard2Leader.url);\n    \n    assertEquals(replicas.size(), cloudClient.getReplicasList().size());\n    \n    for (String url : cloudClient.getReplicasList()) {\n      assertTrue(\"fail check for replica:\" + url + \" in \" + replicas,\n          replicas.contains(stripTrailingSlash(url)));\n    }\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["719a344a9f4424f4ca57e4453bb44b954df0a512","e086a6377e06f1ff139e957e119d766644bbce89","71e2dc2d61511a3d73446a67f08ce653e8dbda6d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n\n    indexr(id, 0, \"a_t\", \"to come to the aid of their country.\");\n    \n    // compare leaders list\n    CloudJettyRunner shard1Leader = shardToLeaderJetty.get(\"shard1\");\n    CloudJettyRunner shard2Leader = shardToLeaderJetty.get(\"shard2\");\n    assertEquals(2, cloudClient.getLeaderUrlList().size());\n    HashSet<String> leaderUrlSet = new HashSet<String>();\n    leaderUrlSet.addAll(cloudClient.getLeaderUrlList());\n    assertTrue(\"fail check for leader:\" + shard1Leader.url + \" in \"\n        + leaderUrlSet, leaderUrlSet.contains(shard1Leader.url + \"/\"));\n    assertTrue(\"fail check for leader:\" + shard2Leader.url + \" in \"\n        + leaderUrlSet, leaderUrlSet.contains(shard2Leader.url + \"/\"));\n\n    // compare replicas list\n    Set<String> replicas = new HashSet<String>();\n    List<CloudJettyRunner> jetties = shardToJetty.get(\"shard1\");\n    for (CloudJettyRunner cjetty : jetties) {\n      replicas.add(cjetty.url);\n    }\n    jetties = shardToJetty.get(\"shard2\");\n    for (CloudJettyRunner cjetty : jetties) {\n      replicas.add(cjetty.url);\n    }\n    replicas.remove(shard1Leader.url);\n    replicas.remove(shard2Leader.url);\n    \n    assertEquals(replicas.size(), cloudClient.getReplicasList().size());\n    \n    for (String url : cloudClient.getReplicasList()) {\n      assertTrue(\"fail check for replica:\" + url + \" in \" + replicas,\n          replicas.contains(stripTrailingSlash(url)));\n    }\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n\n    indexr(id, 0, \"a_t\", \"to come to the aid of their country.\");\n    \n    // compare leaders list\n    CloudJettyRunner shard1Leader = shardToLeaderJetty.get(\"shard1\");\n    CloudJettyRunner shard2Leader = shardToLeaderJetty.get(\"shard2\");\n    assertEquals(2, cloudClient.getLeaderUrlList().size());\n    HashSet<String> leaderUrlSet = new HashSet<String>();\n    leaderUrlSet.addAll(cloudClient.getLeaderUrlList());\n    assertTrue(\"fail check for leader:\" + shard1Leader.url + \" in \"\n        + leaderUrlSet, leaderUrlSet.contains(shard1Leader.url + \"/\"));\n    assertTrue(\"fail check for leader:\" + shard2Leader.url + \" in \"\n        + leaderUrlSet, leaderUrlSet.contains(shard2Leader.url + \"/\"));\n\n    // compare replicas list\n    Set<String> replicas = new HashSet<String>();\n    List<CloudJettyRunner> jetties = shardToJetty.get(\"shard1\");\n    for (CloudJettyRunner cjetty : jetties) {\n      replicas.add(cjetty.url);\n    }\n    jetties = shardToJetty.get(\"shard2\");\n    for (CloudJettyRunner cjetty : jetties) {\n      replicas.add(cjetty.url);\n    }\n    replicas.remove(shard1Leader.url);\n    replicas.remove(shard2Leader.url);\n    \n    assertEquals(replicas.size(), cloudClient.getReplicasList().size());\n    \n    for (String url : cloudClient.getReplicasList()) {\n      assertTrue(\"fail check for replica:\" + url + \" in \" + replicas,\n          replicas.contains(stripTrailingSlash(url)));\n    }\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"719a344a9f4424f4ca57e4453bb44b954df0a512","date":1351211403,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n\n    indexr(id, 0, \"a_t\", \"to come to the aid of their country.\");\n    \n    // compare leaders list\n    CloudJettyRunner shard1Leader = shardToLeaderJetty.get(\"shard1\");\n    CloudJettyRunner shard2Leader = shardToLeaderJetty.get(\"shard2\");\n    assertEquals(2, cloudClient.getLeaderUrlLists().get(\"collection1\").size());\n    HashSet<String> leaderUrlSet = new HashSet<String>();\n    leaderUrlSet.addAll(cloudClient.getLeaderUrlLists().get(\"collection1\"));\n    assertTrue(\"fail check for leader:\" + shard1Leader.url + \" in \"\n        + leaderUrlSet, leaderUrlSet.contains(shard1Leader.url + \"/\"));\n    assertTrue(\"fail check for leader:\" + shard2Leader.url + \" in \"\n        + leaderUrlSet, leaderUrlSet.contains(shard2Leader.url + \"/\"));\n\n    // compare replicas list\n    Set<String> replicas = new HashSet<String>();\n    List<CloudJettyRunner> jetties = shardToJetty.get(\"shard1\");\n    for (CloudJettyRunner cjetty : jetties) {\n      replicas.add(cjetty.url);\n    }\n    jetties = shardToJetty.get(\"shard2\");\n    for (CloudJettyRunner cjetty : jetties) {\n      replicas.add(cjetty.url);\n    }\n    replicas.remove(shard1Leader.url);\n    replicas.remove(shard2Leader.url);\n    \n    assertEquals(replicas.size(), cloudClient.getReplicasLists().get(\"collection1\").size());\n    \n    for (String url : cloudClient.getReplicasLists().get(\"collection1\")) {\n      assertTrue(\"fail check for replica:\" + url + \" in \" + replicas,\n          replicas.contains(stripTrailingSlash(url)));\n    }\n    \n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n\n    indexr(id, 0, \"a_t\", \"to come to the aid of their country.\");\n    \n    // compare leaders list\n    CloudJettyRunner shard1Leader = shardToLeaderJetty.get(\"shard1\");\n    CloudJettyRunner shard2Leader = shardToLeaderJetty.get(\"shard2\");\n    assertEquals(2, cloudClient.getLeaderUrlList().size());\n    HashSet<String> leaderUrlSet = new HashSet<String>();\n    leaderUrlSet.addAll(cloudClient.getLeaderUrlList());\n    assertTrue(\"fail check for leader:\" + shard1Leader.url + \" in \"\n        + leaderUrlSet, leaderUrlSet.contains(shard1Leader.url + \"/\"));\n    assertTrue(\"fail check for leader:\" + shard2Leader.url + \" in \"\n        + leaderUrlSet, leaderUrlSet.contains(shard2Leader.url + \"/\"));\n\n    // compare replicas list\n    Set<String> replicas = new HashSet<String>();\n    List<CloudJettyRunner> jetties = shardToJetty.get(\"shard1\");\n    for (CloudJettyRunner cjetty : jetties) {\n      replicas.add(cjetty.url);\n    }\n    jetties = shardToJetty.get(\"shard2\");\n    for (CloudJettyRunner cjetty : jetties) {\n      replicas.add(cjetty.url);\n    }\n    replicas.remove(shard1Leader.url);\n    replicas.remove(shard2Leader.url);\n    \n    assertEquals(replicas.size(), cloudClient.getReplicasList().size());\n    \n    for (String url : cloudClient.getReplicasList()) {\n      assertTrue(\"fail check for replica:\" + url + \" in \" + replicas,\n          replicas.contains(stripTrailingSlash(url)));\n    }\n    \n  }\n\n","bugFix":["2c30e4c1cee08b3b229a77991882594fe7250b66"],"bugIntro":["71e2dc2d61511a3d73446a67f08ce653e8dbda6d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3e5770229553263d3f8e5c6ec5131dcc63b12f08","date":1351440810,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n\n    indexr(id, 0, \"a_t\", \"to come to the aid of their country.\");\n    \n    // compare leaders list\n    CloudJettyRunner shard1Leader = shardToLeaderJetty.get(\"shard1\");\n    CloudJettyRunner shard2Leader = shardToLeaderJetty.get(\"shard2\");\n    assertEquals(2, cloudClient.getLeaderUrlLists().get(\"collection1\").size());\n    HashSet<String> leaderUrlSet = new HashSet<String>();\n    leaderUrlSet.addAll(cloudClient.getLeaderUrlLists().get(\"collection1\"));\n    assertTrue(\"fail check for leader:\" + shard1Leader.url + \" in \"\n        + leaderUrlSet, leaderUrlSet.contains(shard1Leader.url + \"/\"));\n    assertTrue(\"fail check for leader:\" + shard2Leader.url + \" in \"\n        + leaderUrlSet, leaderUrlSet.contains(shard2Leader.url + \"/\"));\n\n    // compare replicas list\n    Set<String> replicas = new HashSet<String>();\n    List<CloudJettyRunner> jetties = shardToJetty.get(\"shard1\");\n    for (CloudJettyRunner cjetty : jetties) {\n      replicas.add(cjetty.url);\n    }\n    jetties = shardToJetty.get(\"shard2\");\n    for (CloudJettyRunner cjetty : jetties) {\n      replicas.add(cjetty.url);\n    }\n    replicas.remove(shard1Leader.url);\n    replicas.remove(shard2Leader.url);\n    \n    assertEquals(replicas.size(), cloudClient.getReplicasLists().get(\"collection1\").size());\n    \n    for (String url : cloudClient.getReplicasLists().get(\"collection1\")) {\n      assertTrue(\"fail check for replica:\" + url + \" in \" + replicas,\n          replicas.contains(stripTrailingSlash(url)));\n    }\n    \n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n\n    indexr(id, 0, \"a_t\", \"to come to the aid of their country.\");\n    \n    // compare leaders list\n    CloudJettyRunner shard1Leader = shardToLeaderJetty.get(\"shard1\");\n    CloudJettyRunner shard2Leader = shardToLeaderJetty.get(\"shard2\");\n    assertEquals(2, cloudClient.getLeaderUrlLists().get(\"collection1\").size());\n    HashSet<String> leaderUrlSet = new HashSet<String>();\n    leaderUrlSet.addAll(cloudClient.getLeaderUrlLists().get(\"collection1\"));\n    assertTrue(\"fail check for leader:\" + shard1Leader.url + \" in \"\n        + leaderUrlSet, leaderUrlSet.contains(shard1Leader.url + \"/\"));\n    assertTrue(\"fail check for leader:\" + shard2Leader.url + \" in \"\n        + leaderUrlSet, leaderUrlSet.contains(shard2Leader.url + \"/\"));\n\n    // compare replicas list\n    Set<String> replicas = new HashSet<String>();\n    List<CloudJettyRunner> jetties = shardToJetty.get(\"shard1\");\n    for (CloudJettyRunner cjetty : jetties) {\n      replicas.add(cjetty.url);\n    }\n    jetties = shardToJetty.get(\"shard2\");\n    for (CloudJettyRunner cjetty : jetties) {\n      replicas.add(cjetty.url);\n    }\n    replicas.remove(shard1Leader.url);\n    replicas.remove(shard2Leader.url);\n    \n    assertEquals(replicas.size(), cloudClient.getReplicasLists().get(\"collection1\").size());\n    \n    for (String url : cloudClient.getReplicasLists().get(\"collection1\")) {\n      assertTrue(\"fail check for replica:\" + url + \" in \" + replicas,\n          replicas.contains(stripTrailingSlash(url)));\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f2126b84bd093fa3d921582a109a0ee578c28126","date":1351522501,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n\n    indexr(id, 0, \"a_t\", \"to come to the aid of their country.\");\n    \n    // compare leaders list\n    CloudJettyRunner shard1Leader = shardToLeaderJetty.get(\"shard1\");\n    CloudJettyRunner shard2Leader = shardToLeaderJetty.get(\"shard2\");\n    assertEquals(2, cloudClient.getLeaderUrlLists().get(\"collection1\").size());\n    HashSet<String> leaderUrlSet = new HashSet<String>();\n    leaderUrlSet.addAll(cloudClient.getLeaderUrlLists().get(\"collection1\"));\n    assertTrue(\"fail check for leader:\" + shard1Leader.url + \" in \"\n        + leaderUrlSet, leaderUrlSet.contains(shard1Leader.url + \"/\"));\n    assertTrue(\"fail check for leader:\" + shard2Leader.url + \" in \"\n        + leaderUrlSet, leaderUrlSet.contains(shard2Leader.url + \"/\"));\n\n    // compare replicas list\n    Set<String> replicas = new HashSet<String>();\n    List<CloudJettyRunner> jetties = shardToJetty.get(\"shard1\");\n    for (CloudJettyRunner cjetty : jetties) {\n      replicas.add(cjetty.url);\n    }\n    jetties = shardToJetty.get(\"shard2\");\n    for (CloudJettyRunner cjetty : jetties) {\n      replicas.add(cjetty.url);\n    }\n    replicas.remove(shard1Leader.url);\n    replicas.remove(shard2Leader.url);\n    \n    assertEquals(replicas.size(), cloudClient.getReplicasLists().get(\"collection1\").size());\n    \n    for (String url : cloudClient.getReplicasLists().get(\"collection1\")) {\n      assertTrue(\"fail check for replica:\" + url + \" in \" + replicas,\n          replicas.contains(stripTrailingSlash(url)));\n    }\n    \n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n\n    indexr(id, 0, \"a_t\", \"to come to the aid of their country.\");\n    \n    // compare leaders list\n    CloudJettyRunner shard1Leader = shardToLeaderJetty.get(\"shard1\");\n    CloudJettyRunner shard2Leader = shardToLeaderJetty.get(\"shard2\");\n    assertEquals(2, cloudClient.getLeaderUrlList().size());\n    HashSet<String> leaderUrlSet = new HashSet<String>();\n    leaderUrlSet.addAll(cloudClient.getLeaderUrlList());\n    assertTrue(\"fail check for leader:\" + shard1Leader.url + \" in \"\n        + leaderUrlSet, leaderUrlSet.contains(shard1Leader.url + \"/\"));\n    assertTrue(\"fail check for leader:\" + shard2Leader.url + \" in \"\n        + leaderUrlSet, leaderUrlSet.contains(shard2Leader.url + \"/\"));\n\n    // compare replicas list\n    Set<String> replicas = new HashSet<String>();\n    List<CloudJettyRunner> jetties = shardToJetty.get(\"shard1\");\n    for (CloudJettyRunner cjetty : jetties) {\n      replicas.add(cjetty.url);\n    }\n    jetties = shardToJetty.get(\"shard2\");\n    for (CloudJettyRunner cjetty : jetties) {\n      replicas.add(cjetty.url);\n    }\n    replicas.remove(shard1Leader.url);\n    replicas.remove(shard2Leader.url);\n    \n    assertEquals(replicas.size(), cloudClient.getReplicasList().size());\n    \n    for (String url : cloudClient.getReplicasList()) {\n      assertTrue(\"fail check for replica:\" + url + \" in \" + replicas,\n          replicas.contains(stripTrailingSlash(url)));\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"71e2dc2d61511a3d73446a67f08ce653e8dbda6d","date":1371491887,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n\n    indexr(id, 0, \"a_t\", \"to come to the aid of their country.\");\n    \n    CloudJettyRunner shard1Leader = shardToLeaderJetty.get(\"shard1\");\n    CloudJettyRunner shard2Leader = shardToLeaderJetty.get(\"shard2\");\n    \n    if (cloudClient.isUpdatesToLeaders()) {\n      // compare leaders list\n      assertEquals(2, cloudClient.getLeaderUrlLists().get(\"collection1\").size());\n      HashSet<String> leaderUrlSet = new HashSet<String>();\n      leaderUrlSet.addAll(cloudClient.getLeaderUrlLists().get(\"collection1\"));\n      assertTrue(\"fail check for leader:\" + shard1Leader.url + \" in \"\n          + leaderUrlSet, leaderUrlSet.contains(shard1Leader.url + \"/\"));\n      assertTrue(\"fail check for leader:\" + shard2Leader.url + \" in \"\n          + leaderUrlSet, leaderUrlSet.contains(shard2Leader.url + \"/\"));\n      \n      // compare replicas list\n      Set<String> replicas = new HashSet<String>();\n      List<CloudJettyRunner> jetties = shardToJetty.get(\"shard1\");\n      for (CloudJettyRunner cjetty : jetties) {\n        replicas.add(cjetty.url);\n      }\n      jetties = shardToJetty.get(\"shard2\");\n      for (CloudJettyRunner cjetty : jetties) {\n        replicas.add(cjetty.url);\n      }\n      replicas.remove(shard1Leader.url);\n      replicas.remove(shard2Leader.url);\n      \n      assertEquals(replicas.size(),\n          cloudClient.getReplicasLists().get(\"collection1\").size());\n      \n      for (String url : cloudClient.getReplicasLists().get(\"collection1\")) {\n        assertTrue(\"fail check for replica:\" + url + \" in \" + replicas,\n            replicas.contains(stripTrailingSlash(url)));\n      }\n    }\n    \n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n\n    indexr(id, 0, \"a_t\", \"to come to the aid of their country.\");\n    \n    // compare leaders list\n    CloudJettyRunner shard1Leader = shardToLeaderJetty.get(\"shard1\");\n    CloudJettyRunner shard2Leader = shardToLeaderJetty.get(\"shard2\");\n    assertEquals(2, cloudClient.getLeaderUrlLists().get(\"collection1\").size());\n    HashSet<String> leaderUrlSet = new HashSet<String>();\n    leaderUrlSet.addAll(cloudClient.getLeaderUrlLists().get(\"collection1\"));\n    assertTrue(\"fail check for leader:\" + shard1Leader.url + \" in \"\n        + leaderUrlSet, leaderUrlSet.contains(shard1Leader.url + \"/\"));\n    assertTrue(\"fail check for leader:\" + shard2Leader.url + \" in \"\n        + leaderUrlSet, leaderUrlSet.contains(shard2Leader.url + \"/\"));\n\n    // compare replicas list\n    Set<String> replicas = new HashSet<String>();\n    List<CloudJettyRunner> jetties = shardToJetty.get(\"shard1\");\n    for (CloudJettyRunner cjetty : jetties) {\n      replicas.add(cjetty.url);\n    }\n    jetties = shardToJetty.get(\"shard2\");\n    for (CloudJettyRunner cjetty : jetties) {\n      replicas.add(cjetty.url);\n    }\n    replicas.remove(shard1Leader.url);\n    replicas.remove(shard2Leader.url);\n    \n    assertEquals(replicas.size(), cloudClient.getReplicasLists().get(\"collection1\").size());\n    \n    for (String url : cloudClient.getReplicasLists().get(\"collection1\")) {\n      assertTrue(\"fail check for replica:\" + url + \" in \" + replicas,\n          replicas.contains(stripTrailingSlash(url)));\n    }\n    \n  }\n\n","bugFix":["719a344a9f4424f4ca57e4453bb44b954df0a512","2c30e4c1cee08b3b229a77991882594fe7250b66"],"bugIntro":["e086a6377e06f1ff139e957e119d766644bbce89"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n\n    indexr(id, 0, \"a_t\", \"to come to the aid of their country.\");\n    \n    CloudJettyRunner shard1Leader = shardToLeaderJetty.get(\"shard1\");\n    CloudJettyRunner shard2Leader = shardToLeaderJetty.get(\"shard2\");\n    \n    if (cloudClient.isUpdatesToLeaders()) {\n      // compare leaders list\n      assertEquals(2, cloudClient.getLeaderUrlLists().get(\"collection1\").size());\n      HashSet<String> leaderUrlSet = new HashSet<String>();\n      leaderUrlSet.addAll(cloudClient.getLeaderUrlLists().get(\"collection1\"));\n      assertTrue(\"fail check for leader:\" + shard1Leader.url + \" in \"\n          + leaderUrlSet, leaderUrlSet.contains(shard1Leader.url + \"/\"));\n      assertTrue(\"fail check for leader:\" + shard2Leader.url + \" in \"\n          + leaderUrlSet, leaderUrlSet.contains(shard2Leader.url + \"/\"));\n      \n      // compare replicas list\n      Set<String> replicas = new HashSet<String>();\n      List<CloudJettyRunner> jetties = shardToJetty.get(\"shard1\");\n      for (CloudJettyRunner cjetty : jetties) {\n        replicas.add(cjetty.url);\n      }\n      jetties = shardToJetty.get(\"shard2\");\n      for (CloudJettyRunner cjetty : jetties) {\n        replicas.add(cjetty.url);\n      }\n      replicas.remove(shard1Leader.url);\n      replicas.remove(shard2Leader.url);\n      \n      assertEquals(replicas.size(),\n          cloudClient.getReplicasLists().get(\"collection1\").size());\n      \n      for (String url : cloudClient.getReplicasLists().get(\"collection1\")) {\n        assertTrue(\"fail check for replica:\" + url + \" in \" + replicas,\n            replicas.contains(stripTrailingSlash(url)));\n      }\n    }\n    \n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n\n    indexr(id, 0, \"a_t\", \"to come to the aid of their country.\");\n    \n    // compare leaders list\n    CloudJettyRunner shard1Leader = shardToLeaderJetty.get(\"shard1\");\n    CloudJettyRunner shard2Leader = shardToLeaderJetty.get(\"shard2\");\n    assertEquals(2, cloudClient.getLeaderUrlLists().get(\"collection1\").size());\n    HashSet<String> leaderUrlSet = new HashSet<String>();\n    leaderUrlSet.addAll(cloudClient.getLeaderUrlLists().get(\"collection1\"));\n    assertTrue(\"fail check for leader:\" + shard1Leader.url + \" in \"\n        + leaderUrlSet, leaderUrlSet.contains(shard1Leader.url + \"/\"));\n    assertTrue(\"fail check for leader:\" + shard2Leader.url + \" in \"\n        + leaderUrlSet, leaderUrlSet.contains(shard2Leader.url + \"/\"));\n\n    // compare replicas list\n    Set<String> replicas = new HashSet<String>();\n    List<CloudJettyRunner> jetties = shardToJetty.get(\"shard1\");\n    for (CloudJettyRunner cjetty : jetties) {\n      replicas.add(cjetty.url);\n    }\n    jetties = shardToJetty.get(\"shard2\");\n    for (CloudJettyRunner cjetty : jetties) {\n      replicas.add(cjetty.url);\n    }\n    replicas.remove(shard1Leader.url);\n    replicas.remove(shard2Leader.url);\n    \n    assertEquals(replicas.size(), cloudClient.getReplicasLists().get(\"collection1\").size());\n    \n    for (String url : cloudClient.getReplicasLists().get(\"collection1\")) {\n      assertTrue(\"fail check for replica:\" + url + \" in \" + replicas,\n          replicas.contains(stripTrailingSlash(url)));\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d5fc588fc7c6e55c0d778665292d023bf8d5f3b1","date":1378862385,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n\n    commit();\n    \n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList response = cloudClient.request(request);\n    CloudSolrServer.RouteResponse rr = (CloudSolrServer.RouteResponse) response;\n    Map<String,LBHttpSolrServer.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrServer.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      HttpSolrServer solrServer = new HttpSolrServer(url);\n      QueryResponse queryResponse = queryRequest.process(solrServer);\n      SolrDocumentList docList = queryResponse.getResults();\n      assertTrue(docList.getNumFound() == 1);\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    \n    CloudSolrServer threadedClient = null;\n    try {\n      threadedClient = new CloudSolrServer(zkServer.getZkAddress());\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(\"collection1\");\n      response = threadedClient.request(request);\n      rr = (CloudSolrServer.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        HttpSolrServer solrServer = new HttpSolrServer(url);\n        QueryResponse queryResponse = queryRequest.process(solrServer);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    } finally {\n      threadedClient.shutdown();\n    }\n    \n    del(\"*:*\");\n    commit();\n    \n    indexr(id, 0, \"a_t\", \"to come to the aid of their country.\");\n    \n    CloudJettyRunner shard1Leader = shardToLeaderJetty.get(\"shard1\");\n    CloudJettyRunner shard2Leader = shardToLeaderJetty.get(\"shard2\");\n    \n    if (cloudClient.isUpdatesToLeaders()) {\n      // compare leaders list\n      assertEquals(2, cloudClient.getLeaderUrlLists().get(\"collection1\").size());\n      HashSet<String> leaderUrlSet = new HashSet<String>();\n      leaderUrlSet.addAll(cloudClient.getLeaderUrlLists().get(\"collection1\"));\n      assertTrue(\"fail check for leader:\" + shard1Leader.url + \" in \"\n          + leaderUrlSet, leaderUrlSet.contains(shard1Leader.url + \"/\"));\n      assertTrue(\"fail check for leader:\" + shard2Leader.url + \" in \"\n          + leaderUrlSet, leaderUrlSet.contains(shard2Leader.url + \"/\"));\n      \n      // compare replicas list\n      Set<String> replicas = new HashSet<String>();\n      List<CloudJettyRunner> jetties = shardToJetty.get(\"shard1\");\n      for (CloudJettyRunner cjetty : jetties) {\n        replicas.add(cjetty.url);\n      }\n      jetties = shardToJetty.get(\"shard2\");\n      for (CloudJettyRunner cjetty : jetties) {\n        replicas.add(cjetty.url);\n      }\n      replicas.remove(shard1Leader.url);\n      replicas.remove(shard2Leader.url);\n      \n      assertEquals(replicas.size(),\n          cloudClient.getReplicasLists().get(\"collection1\").size());\n      \n      for (String url : cloudClient.getReplicasLists().get(\"collection1\")) {\n        assertTrue(\"fail check for replica:\" + url + \" in \" + replicas,\n            replicas.contains(stripTrailingSlash(url)));\n      }\n    }\n    \n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n\n    indexr(id, 0, \"a_t\", \"to come to the aid of their country.\");\n    \n    CloudJettyRunner shard1Leader = shardToLeaderJetty.get(\"shard1\");\n    CloudJettyRunner shard2Leader = shardToLeaderJetty.get(\"shard2\");\n    \n    if (cloudClient.isUpdatesToLeaders()) {\n      // compare leaders list\n      assertEquals(2, cloudClient.getLeaderUrlLists().get(\"collection1\").size());\n      HashSet<String> leaderUrlSet = new HashSet<String>();\n      leaderUrlSet.addAll(cloudClient.getLeaderUrlLists().get(\"collection1\"));\n      assertTrue(\"fail check for leader:\" + shard1Leader.url + \" in \"\n          + leaderUrlSet, leaderUrlSet.contains(shard1Leader.url + \"/\"));\n      assertTrue(\"fail check for leader:\" + shard2Leader.url + \" in \"\n          + leaderUrlSet, leaderUrlSet.contains(shard2Leader.url + \"/\"));\n      \n      // compare replicas list\n      Set<String> replicas = new HashSet<String>();\n      List<CloudJettyRunner> jetties = shardToJetty.get(\"shard1\");\n      for (CloudJettyRunner cjetty : jetties) {\n        replicas.add(cjetty.url);\n      }\n      jetties = shardToJetty.get(\"shard2\");\n      for (CloudJettyRunner cjetty : jetties) {\n        replicas.add(cjetty.url);\n      }\n      replicas.remove(shard1Leader.url);\n      replicas.remove(shard2Leader.url);\n      \n      assertEquals(replicas.size(),\n          cloudClient.getReplicasLists().get(\"collection1\").size());\n      \n      for (String url : cloudClient.getReplicasLists().get(\"collection1\")) {\n        assertTrue(\"fail check for replica:\" + url + \" in \" + replicas,\n            replicas.contains(stripTrailingSlash(url)));\n      }\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":["e086a6377e06f1ff139e957e119d766644bbce89"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e086a6377e06f1ff139e957e119d766644bbce89","date":1380719702,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n\n    commit();\n    \n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList response = cloudClient.request(request);\n    CloudSolrServer.RouteResponse rr = (CloudSolrServer.RouteResponse) response;\n    Map<String,LBHttpSolrServer.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrServer.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      HttpSolrServer solrServer = new HttpSolrServer(url);\n      QueryResponse queryResponse = queryRequest.process(solrServer);\n      SolrDocumentList docList = queryResponse.getResults();\n      assertTrue(docList.getNumFound() == 1);\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    \n    CloudSolrServer threadedClient = null;\n    try {\n      threadedClient = new CloudSolrServer(zkServer.getZkAddress());\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(\"collection1\");\n      response = threadedClient.request(request);\n      rr = (CloudSolrServer.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        HttpSolrServer solrServer = new HttpSolrServer(url);\n        QueryResponse queryResponse = queryRequest.process(solrServer);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    } finally {\n      threadedClient.shutdown();\n    }\n    \n    del(\"*:*\");\n    commit();\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n\n    commit();\n    \n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList response = cloudClient.request(request);\n    CloudSolrServer.RouteResponse rr = (CloudSolrServer.RouteResponse) response;\n    Map<String,LBHttpSolrServer.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrServer.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      HttpSolrServer solrServer = new HttpSolrServer(url);\n      QueryResponse queryResponse = queryRequest.process(solrServer);\n      SolrDocumentList docList = queryResponse.getResults();\n      assertTrue(docList.getNumFound() == 1);\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    \n    CloudSolrServer threadedClient = null;\n    try {\n      threadedClient = new CloudSolrServer(zkServer.getZkAddress());\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(\"collection1\");\n      response = threadedClient.request(request);\n      rr = (CloudSolrServer.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        HttpSolrServer solrServer = new HttpSolrServer(url);\n        QueryResponse queryResponse = queryRequest.process(solrServer);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    } finally {\n      threadedClient.shutdown();\n    }\n    \n    del(\"*:*\");\n    commit();\n    \n    indexr(id, 0, \"a_t\", \"to come to the aid of their country.\");\n    \n    CloudJettyRunner shard1Leader = shardToLeaderJetty.get(\"shard1\");\n    CloudJettyRunner shard2Leader = shardToLeaderJetty.get(\"shard2\");\n    \n    if (cloudClient.isUpdatesToLeaders()) {\n      // compare leaders list\n      assertEquals(2, cloudClient.getLeaderUrlLists().get(\"collection1\").size());\n      HashSet<String> leaderUrlSet = new HashSet<String>();\n      leaderUrlSet.addAll(cloudClient.getLeaderUrlLists().get(\"collection1\"));\n      assertTrue(\"fail check for leader:\" + shard1Leader.url + \" in \"\n          + leaderUrlSet, leaderUrlSet.contains(shard1Leader.url + \"/\"));\n      assertTrue(\"fail check for leader:\" + shard2Leader.url + \" in \"\n          + leaderUrlSet, leaderUrlSet.contains(shard2Leader.url + \"/\"));\n      \n      // compare replicas list\n      Set<String> replicas = new HashSet<String>();\n      List<CloudJettyRunner> jetties = shardToJetty.get(\"shard1\");\n      for (CloudJettyRunner cjetty : jetties) {\n        replicas.add(cjetty.url);\n      }\n      jetties = shardToJetty.get(\"shard2\");\n      for (CloudJettyRunner cjetty : jetties) {\n        replicas.add(cjetty.url);\n      }\n      replicas.remove(shard1Leader.url);\n      replicas.remove(shard2Leader.url);\n      \n      assertEquals(replicas.size(),\n          cloudClient.getReplicasLists().get(\"collection1\").size());\n      \n      for (String url : cloudClient.getReplicasLists().get(\"collection1\")) {\n        assertTrue(\"fail check for replica:\" + url + \" in \" + replicas,\n            replicas.contains(stripTrailingSlash(url)));\n      }\n    }\n    \n  }\n\n","bugFix":["d5fc588fc7c6e55c0d778665292d023bf8d5f3b1","2c30e4c1cee08b3b229a77991882594fe7250b66","71e2dc2d61511a3d73446a67f08ce653e8dbda6d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14f5fb047085ab89f16696609c848b225b51b482","date":1395311996,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n\n    commit();\n    \n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList response = cloudClient.request(request);\n    CloudSolrServer.RouteResponse rr = (CloudSolrServer.RouteResponse) response;\n    Map<String,LBHttpSolrServer.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrServer.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      HttpSolrServer solrServer = new HttpSolrServer(url);\n      QueryResponse queryResponse = queryRequest.process(solrServer);\n      SolrDocumentList docList = queryResponse.getResults();\n      assertTrue(docList.getNumFound() == 1);\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    \n    CloudSolrServer threadedClient = null;\n    try {\n      threadedClient = new CloudSolrServer(zkServer.getZkAddress());\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(\"collection1\");\n      response = threadedClient.request(request);\n      rr = (CloudSolrServer.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        HttpSolrServer solrServer = new HttpSolrServer(url);\n        QueryResponse queryResponse = queryRequest.process(solrServer);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    } finally {\n      threadedClient.shutdown();\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(DEFAULT_COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(new HttpSolrServer(baseURL)));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < 1000; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do 1000 queries with _route_ parameter to the same shard\n    for (int i = 0; i < 1000; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      cloudClient.query(solrParams);\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(new HttpSolrServer(baseURL));\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", 1000, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    del(\"*:*\");\n    commit();\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n\n    commit();\n    \n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList response = cloudClient.request(request);\n    CloudSolrServer.RouteResponse rr = (CloudSolrServer.RouteResponse) response;\n    Map<String,LBHttpSolrServer.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrServer.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      HttpSolrServer solrServer = new HttpSolrServer(url);\n      QueryResponse queryResponse = queryRequest.process(solrServer);\n      SolrDocumentList docList = queryResponse.getResults();\n      assertTrue(docList.getNumFound() == 1);\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    \n    CloudSolrServer threadedClient = null;\n    try {\n      threadedClient = new CloudSolrServer(zkServer.getZkAddress());\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(\"collection1\");\n      response = threadedClient.request(request);\n      rr = (CloudSolrServer.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        HttpSolrServer solrServer = new HttpSolrServer(url);\n        QueryResponse queryResponse = queryRequest.process(solrServer);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    } finally {\n      threadedClient.shutdown();\n    }\n    \n    del(\"*:*\");\n    commit();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a71cd524413ff09c5289c5084837d90838ac78c7","date":1395681365,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n\n    commit();\n    \n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList response = cloudClient.request(request);\n    CloudSolrServer.RouteResponse rr = (CloudSolrServer.RouteResponse) response;\n    Map<String,LBHttpSolrServer.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrServer.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      HttpSolrServer solrServer = new HttpSolrServer(url);\n      QueryResponse queryResponse = queryRequest.process(solrServer);\n      SolrDocumentList docList = queryResponse.getResults();\n      assertTrue(docList.getNumFound() == 1);\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    \n    CloudSolrServer threadedClient = null;\n    try {\n      threadedClient = new CloudSolrServer(zkServer.getZkAddress());\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(\"collection1\");\n      response = threadedClient.request(request);\n      rr = (CloudSolrServer.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        HttpSolrServer solrServer = new HttpSolrServer(url);\n        QueryResponse queryResponse = queryRequest.process(solrServer);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    } finally {\n      threadedClient.shutdown();\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(DEFAULT_COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(new HttpSolrServer(baseURL)));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 1;\n    } else {\n      n = random().nextInt(9) + 1;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      cloudClient.query(solrParams);\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(new HttpSolrServer(baseURL));\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    del(\"*:*\");\n    commit();\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n\n    commit();\n    \n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList response = cloudClient.request(request);\n    CloudSolrServer.RouteResponse rr = (CloudSolrServer.RouteResponse) response;\n    Map<String,LBHttpSolrServer.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrServer.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      HttpSolrServer solrServer = new HttpSolrServer(url);\n      QueryResponse queryResponse = queryRequest.process(solrServer);\n      SolrDocumentList docList = queryResponse.getResults();\n      assertTrue(docList.getNumFound() == 1);\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    \n    CloudSolrServer threadedClient = null;\n    try {\n      threadedClient = new CloudSolrServer(zkServer.getZkAddress());\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(\"collection1\");\n      response = threadedClient.request(request);\n      rr = (CloudSolrServer.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        HttpSolrServer solrServer = new HttpSolrServer(url);\n        QueryResponse queryResponse = queryRequest.process(solrServer);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    } finally {\n      threadedClient.shutdown();\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(DEFAULT_COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(new HttpSolrServer(baseURL)));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < 1000; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do 1000 queries with _route_ parameter to the same shard\n    for (int i = 0; i < 1000; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      cloudClient.query(solrParams);\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(new HttpSolrServer(baseURL));\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", 1000, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    del(\"*:*\");\n    commit();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"743772f8c51ff41a7d7cdcc9f9e71125d1bcbaee","date":1396367412,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n\n    commit();\n    \n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList response = cloudClient.request(request);\n    CloudSolrServer.RouteResponse rr = (CloudSolrServer.RouteResponse) response;\n    Map<String,LBHttpSolrServer.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrServer.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      HttpSolrServer solrServer = new HttpSolrServer(url);\n      QueryResponse queryResponse = queryRequest.process(solrServer);\n      SolrDocumentList docList = queryResponse.getResults();\n      assertTrue(docList.getNumFound() == 1);\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    \n    CloudSolrServer threadedClient = null;\n    try {\n      threadedClient = new CloudSolrServer(zkServer.getZkAddress());\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(\"collection1\");\n      response = threadedClient.request(request);\n      rr = (CloudSolrServer.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        HttpSolrServer solrServer = new HttpSolrServer(url);\n        QueryResponse queryResponse = queryRequest.process(solrServer);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    } finally {\n      threadedClient.shutdown();\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(DEFAULT_COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(new HttpSolrServer(baseURL)));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      cloudClient.query(solrParams);\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(new HttpSolrServer(baseURL));\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    del(\"*:*\");\n    commit();\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n\n    commit();\n    \n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList response = cloudClient.request(request);\n    CloudSolrServer.RouteResponse rr = (CloudSolrServer.RouteResponse) response;\n    Map<String,LBHttpSolrServer.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrServer.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      HttpSolrServer solrServer = new HttpSolrServer(url);\n      QueryResponse queryResponse = queryRequest.process(solrServer);\n      SolrDocumentList docList = queryResponse.getResults();\n      assertTrue(docList.getNumFound() == 1);\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    \n    CloudSolrServer threadedClient = null;\n    try {\n      threadedClient = new CloudSolrServer(zkServer.getZkAddress());\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(\"collection1\");\n      response = threadedClient.request(request);\n      rr = (CloudSolrServer.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        HttpSolrServer solrServer = new HttpSolrServer(url);\n        QueryResponse queryResponse = queryRequest.process(solrServer);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    } finally {\n      threadedClient.shutdown();\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(DEFAULT_COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(new HttpSolrServer(baseURL)));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 1;\n    } else {\n      n = random().nextInt(9) + 1;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      cloudClient.query(solrParams);\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(new HttpSolrServer(baseURL));\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    del(\"*:*\");\n    commit();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n\n    commit();\n    \n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList response = cloudClient.request(request);\n    CloudSolrServer.RouteResponse rr = (CloudSolrServer.RouteResponse) response;\n    Map<String,LBHttpSolrServer.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrServer.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      HttpSolrServer solrServer = new HttpSolrServer(url);\n      QueryResponse queryResponse = queryRequest.process(solrServer);\n      SolrDocumentList docList = queryResponse.getResults();\n      assertTrue(docList.getNumFound() == 1);\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    \n    CloudSolrServer threadedClient = null;\n    try {\n      threadedClient = new CloudSolrServer(zkServer.getZkAddress());\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(\"collection1\");\n      response = threadedClient.request(request);\n      rr = (CloudSolrServer.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        HttpSolrServer solrServer = new HttpSolrServer(url);\n        QueryResponse queryResponse = queryRequest.process(solrServer);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    } finally {\n      threadedClient.shutdown();\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(DEFAULT_COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(new HttpSolrServer(baseURL)));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      cloudClient.query(solrParams);\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(new HttpSolrServer(baseURL));\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    del(\"*:*\");\n    commit();\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n\n    commit();\n    \n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList response = cloudClient.request(request);\n    CloudSolrServer.RouteResponse rr = (CloudSolrServer.RouteResponse) response;\n    Map<String,LBHttpSolrServer.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrServer.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      HttpSolrServer solrServer = new HttpSolrServer(url);\n      QueryResponse queryResponse = queryRequest.process(solrServer);\n      SolrDocumentList docList = queryResponse.getResults();\n      assertTrue(docList.getNumFound() == 1);\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    \n    CloudSolrServer threadedClient = null;\n    try {\n      threadedClient = new CloudSolrServer(zkServer.getZkAddress());\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(\"collection1\");\n      response = threadedClient.request(request);\n      rr = (CloudSolrServer.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        HttpSolrServer solrServer = new HttpSolrServer(url);\n        QueryResponse queryResponse = queryRequest.process(solrServer);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    } finally {\n      threadedClient.shutdown();\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(DEFAULT_COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(new HttpSolrServer(baseURL)));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 1;\n    } else {\n      n = random().nextInt(9) + 1;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      cloudClient.query(solrParams);\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(new HttpSolrServer(baseURL));\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    del(\"*:*\");\n    commit();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0622fbd990643ae4cacb693db6a0c82cf8916ae2","date":1397637446,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    allTests();\n    testStateVersionParam();\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n\n    commit();\n    \n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList response = cloudClient.request(request);\n    CloudSolrServer.RouteResponse rr = (CloudSolrServer.RouteResponse) response;\n    Map<String,LBHttpSolrServer.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrServer.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      HttpSolrServer solrServer = new HttpSolrServer(url);\n      QueryResponse queryResponse = queryRequest.process(solrServer);\n      SolrDocumentList docList = queryResponse.getResults();\n      assertTrue(docList.getNumFound() == 1);\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    \n    CloudSolrServer threadedClient = null;\n    try {\n      threadedClient = new CloudSolrServer(zkServer.getZkAddress());\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(\"collection1\");\n      response = threadedClient.request(request);\n      rr = (CloudSolrServer.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        HttpSolrServer solrServer = new HttpSolrServer(url);\n        QueryResponse queryResponse = queryRequest.process(solrServer);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    } finally {\n      threadedClient.shutdown();\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(DEFAULT_COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(new HttpSolrServer(baseURL)));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      cloudClient.query(solrParams);\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(new HttpSolrServer(baseURL));\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    del(\"*:*\");\n    commit();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5a233896b7f16ac9b4ed601ef8207d98f1f0500","date":1398857046,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    allTests();\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    allTests();\n    testStateVersionParam();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6f693ed86f289b2e42b46684409b3997f2c264a","date":1404319832,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    allTests();\n    stateVersionParamTest();\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    allTests();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4c07fa58a256dccf8b95364855fd5e9ad4d1401","date":1404386015,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    allTests();\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    allTests();\n    stateVersionParamTest();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9279b175e5e66258442d2123a50f052219a9cc1b","date":1410531077,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    allTests();\n    stateVersionParamTest();\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    allTests();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"791652abeeebb8642f54a7b42ca914c55805479a","date":1413382171,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    allTests();\n    stateVersionParamTest();\n    customHttpClientTest();\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    allTests();\n    stateVersionParamTest();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84","date":1413458798,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    allTests();\n    stateVersionParamTest();\n    customHttpClientTest();\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    allTests();\n    stateVersionParamTest();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#doTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    allTests();\n    stateVersionParamTest();\n    customHttpClientTest();\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    allTests();\n    stateVersionParamTest();\n    customHttpClientTest();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5eb2511ababf862ea11e10761c70ee560cd84510":["a71cd524413ff09c5289c5084837d90838ac78c7","743772f8c51ff41a7d7cdcc9f9e71125d1bcbaee"],"c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84":["9279b175e5e66258442d2123a50f052219a9cc1b","791652abeeebb8642f54a7b42ca914c55805479a"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["3e5770229553263d3f8e5c6ec5131dcc63b12f08","71e2dc2d61511a3d73446a67f08ce653e8dbda6d"],"d5fc588fc7c6e55c0d778665292d023bf8d5f3b1":["71e2dc2d61511a3d73446a67f08ce653e8dbda6d"],"14f5fb047085ab89f16696609c848b225b51b482":["e086a6377e06f1ff139e957e119d766644bbce89"],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"a5a233896b7f16ac9b4ed601ef8207d98f1f0500":["0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"bafca15d8e408346a67f4282ad1143b88023893b":["791652abeeebb8642f54a7b42ca914c55805479a"],"71e2dc2d61511a3d73446a67f08ce653e8dbda6d":["3e5770229553263d3f8e5c6ec5131dcc63b12f08"],"9279b175e5e66258442d2123a50f052219a9cc1b":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"],"3e5770229553263d3f8e5c6ec5131dcc63b12f08":["719a344a9f4424f4ca57e4453bb44b954df0a512"],"743772f8c51ff41a7d7cdcc9f9e71125d1bcbaee":["a71cd524413ff09c5289c5084837d90838ac78c7"],"a6f693ed86f289b2e42b46684409b3997f2c264a":["a5a233896b7f16ac9b4ed601ef8207d98f1f0500"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c30e4c1cee08b3b229a77991882594fe7250b66"],"719a344a9f4424f4ca57e4453bb44b954df0a512":["2c30e4c1cee08b3b229a77991882594fe7250b66"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c30e4c1cee08b3b229a77991882594fe7250b66"],"a71cd524413ff09c5289c5084837d90838ac78c7":["14f5fb047085ab89f16696609c848b225b51b482"],"e086a6377e06f1ff139e957e119d766644bbce89":["d5fc588fc7c6e55c0d778665292d023bf8d5f3b1"],"791652abeeebb8642f54a7b42ca914c55805479a":["9279b175e5e66258442d2123a50f052219a9cc1b"],"f2126b84bd093fa3d921582a109a0ee578c28126":["2c30e4c1cee08b3b229a77991882594fe7250b66","3e5770229553263d3f8e5c6ec5131dcc63b12f08"],"0622fbd990643ae4cacb693db6a0c82cf8916ae2":["743772f8c51ff41a7d7cdcc9f9e71125d1bcbaee"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bafca15d8e408346a67f4282ad1143b88023893b"],"2c30e4c1cee08b3b229a77991882594fe7250b66":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"5eb2511ababf862ea11e10761c70ee560cd84510":[],"c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84":[],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"d5fc588fc7c6e55c0d778665292d023bf8d5f3b1":["e086a6377e06f1ff139e957e119d766644bbce89"],"14f5fb047085ab89f16696609c848b225b51b482":["a71cd524413ff09c5289c5084837d90838ac78c7"],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["9279b175e5e66258442d2123a50f052219a9cc1b"],"a5a233896b7f16ac9b4ed601ef8207d98f1f0500":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"bafca15d8e408346a67f4282ad1143b88023893b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"71e2dc2d61511a3d73446a67f08ce653e8dbda6d":["37a0f60745e53927c4c876cfe5b5a58170f0646c","d5fc588fc7c6e55c0d778665292d023bf8d5f3b1"],"9279b175e5e66258442d2123a50f052219a9cc1b":["c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84","791652abeeebb8642f54a7b42ca914c55805479a"],"3e5770229553263d3f8e5c6ec5131dcc63b12f08":["37a0f60745e53927c4c876cfe5b5a58170f0646c","71e2dc2d61511a3d73446a67f08ce653e8dbda6d","f2126b84bd093fa3d921582a109a0ee578c28126"],"743772f8c51ff41a7d7cdcc9f9e71125d1bcbaee":["5eb2511ababf862ea11e10761c70ee560cd84510","0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"a6f693ed86f289b2e42b46684409b3997f2c264a":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":[],"719a344a9f4424f4ca57e4453bb44b954df0a512":["3e5770229553263d3f8e5c6ec5131dcc63b12f08"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c7869f64c874ebf7f317d22c00baf2b6857797a6","d6f074e73200c07d54f242d3880a8da5a35ff97b","2c30e4c1cee08b3b229a77991882594fe7250b66"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"a71cd524413ff09c5289c5084837d90838ac78c7":["5eb2511ababf862ea11e10761c70ee560cd84510","743772f8c51ff41a7d7cdcc9f9e71125d1bcbaee"],"e086a6377e06f1ff139e957e119d766644bbce89":["14f5fb047085ab89f16696609c848b225b51b482"],"791652abeeebb8642f54a7b42ca914c55805479a":["c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84","bafca15d8e408346a67f4282ad1143b88023893b"],"f2126b84bd093fa3d921582a109a0ee578c28126":[],"0622fbd990643ae4cacb693db6a0c82cf8916ae2":["a5a233896b7f16ac9b4ed601ef8207d98f1f0500"],"2c30e4c1cee08b3b229a77991882594fe7250b66":["c7869f64c874ebf7f317d22c00baf2b6857797a6","719a344a9f4424f4ca57e4453bb44b954df0a512","d6f074e73200c07d54f242d3880a8da5a35ff97b","f2126b84bd093fa3d921582a109a0ee578c28126"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5eb2511ababf862ea11e10761c70ee560cd84510","c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84","37a0f60745e53927c4c876cfe5b5a58170f0646c","c7869f64c874ebf7f317d22c00baf2b6857797a6","d6f074e73200c07d54f242d3880a8da5a35ff97b","f2126b84bd093fa3d921582a109a0ee578c28126","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}