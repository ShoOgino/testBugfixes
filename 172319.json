{"path":"solr/core/src/java/org/apache/solr/update/processor/TolerantUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","commits":[{"id":"f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef","date":1458928975,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/TolerantUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    \n    try {\n      \n      super.processDelete(cmd);\n      \n    } catch (Throwable t) {\n      firstErrTracker.caught(t);\n      \n      ToleratedUpdateError err = new ToleratedUpdateError(cmd.isDeleteById() ? CmdType.DELID : CmdType.DELQ,\n                                                          cmd.isDeleteById() ? cmd.id : cmd.query,\n                                                          t.getMessage());\n      knownErrors.add(err);\n\n      // NOTE: we're not using this to dedup before adding to knownErrors.\n      // if we're lucky enough to get an immediate local failure (ie: we're a leader, or some other processor\n      // failed) then recording the multiple failures is a good thing -- helps us with an accurate fail\n      // fast if we exceed maxErrors\n      if (CmdType.DELQ.equals(err.getType())) {\n        knownDBQErrors.add(err);\n      }\n      \n      if (knownErrors.size() > maxErrors) {\n        firstErrTracker.throwFirst();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1a77e5e21cbd575a8240b0e3926164f15295f4e8","date":1544979500,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/TolerantUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/TolerantUpdateProcessor#processDelete(DeleteUpdateCommand).mjava","sourceNew":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    \n    try {\n\n      super.processDelete(cmd);\n\n    } catch (Throwable t) {\n      firstErrTracker.caught(t);\n\n      ToleratedUpdateError err = new ToleratedUpdateError(cmd.isDeleteById() ? CmdType.DELID : CmdType.DELQ,\n                                                          cmd.isDeleteById() ? cmd.id : cmd.query,\n                                                          t.getMessage());\n      knownErrors.add(err);\n\n      // NOTE: we're not using this to dedup before adding to knownErrors.\n      // if we're lucky enough to get an immediate local failure (ie: we're a leader, or some other processor\n      // failed) then recording the multiple failures is a good thing -- helps us with an accurate fail\n      // fast if we exceed maxErrors\n      if (CmdType.DELQ.equals(err.getType())) {\n        knownDBQErrors.add(err);\n      }\n\n      if (knownErrors.size() > maxErrors) {\n        firstErrTracker.throwFirst();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    \n    try {\n      \n      super.processDelete(cmd);\n      \n    } catch (Throwable t) {\n      firstErrTracker.caught(t);\n      \n      ToleratedUpdateError err = new ToleratedUpdateError(cmd.isDeleteById() ? CmdType.DELID : CmdType.DELQ,\n                                                          cmd.isDeleteById() ? cmd.id : cmd.query,\n                                                          t.getMessage());\n      knownErrors.add(err);\n\n      // NOTE: we're not using this to dedup before adding to knownErrors.\n      // if we're lucky enough to get an immediate local failure (ie: we're a leader, or some other processor\n      // failed) then recording the multiple failures is a good thing -- helps us with an accurate fail\n      // fast if we exceed maxErrors\n      if (CmdType.DELQ.equals(err.getType())) {\n        knownDBQErrors.add(err);\n      }\n      \n      if (knownErrors.size() > maxErrors) {\n        firstErrTracker.throwFirst();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"]},"commit2Childs":{"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef"],"f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}