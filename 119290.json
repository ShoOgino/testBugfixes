{"path":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkHeader(DataInput,String,int,int).mjava","commits":[{"id":"bcce0e518c0546269a896ca6124ba4313059185f","date":1340381078,"type":1,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkHeader(DataInput,String,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/CodecUtil#checkHeader(DataInput,String,int,int).mjava","sourceNew":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeHeader(DataOutput, String, int)}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code> and\n   * an expected version range (<code>minVersion to maxVersion</code>).\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>.\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeHeader(DataOutput, String, int)\n   */\n  public static int checkHeader(DataInput in, String codec, int minVersion, int maxVersion)\n    throws IOException {\n\n    // Safety to guard against reading a bogus string:\n    final int actualHeader = in.readInt();\n    if (actualHeader != CODEC_MAGIC) {\n      throw new CorruptIndexException(\"codec header mismatch: actual header=\" + actualHeader + \" vs expected header=\" + CODEC_MAGIC + \" (resource: \" + in + \")\");\n    }\n    return checkHeaderNoMagic(in, codec, minVersion, maxVersion);\n  }\n\n","sourceOld":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeHeader(DataOutput, String, int)}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code> and\n   * an expected version range (<code>minVersion to maxVersion</code>).\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>.\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeHeader(DataOutput, String, int)\n   */\n  public static int checkHeader(DataInput in, String codec, int minVersion, int maxVersion)\n    throws IOException {\n\n    // Safety to guard against reading a bogus string:\n    final int actualHeader = in.readInt();\n    if (actualHeader != CODEC_MAGIC) {\n      throw new CorruptIndexException(\"codec header mismatch: actual header=\" + actualHeader + \" vs expected header=\" + CODEC_MAGIC + \" (resource: \" + in + \")\");\n    }\n    return checkHeaderNoMagic(in, codec, minVersion, maxVersion);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":1,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkHeader(DataInput,String,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/CodecUtil#checkHeader(DataInput,String,int,int).mjava","sourceNew":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeHeader(DataOutput, String, int)}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code> and\n   * an expected version range (<code>minVersion to maxVersion</code>).\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>.\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeHeader(DataOutput, String, int)\n   */\n  public static int checkHeader(DataInput in, String codec, int minVersion, int maxVersion)\n    throws IOException {\n\n    // Safety to guard against reading a bogus string:\n    final int actualHeader = in.readInt();\n    if (actualHeader != CODEC_MAGIC) {\n      throw new CorruptIndexException(\"codec header mismatch: actual header=\" + actualHeader + \" vs expected header=\" + CODEC_MAGIC + \" (resource: \" + in + \")\");\n    }\n    return checkHeaderNoMagic(in, codec, minVersion, maxVersion);\n  }\n\n","sourceOld":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeHeader(DataOutput, String, int)}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code> and\n   * an expected version range (<code>minVersion to maxVersion</code>).\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>.\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeHeader(DataOutput, String, int)\n   */\n  public static int checkHeader(DataInput in, String codec, int minVersion, int maxVersion)\n    throws IOException {\n\n    // Safety to guard against reading a bogus string:\n    final int actualHeader = in.readInt();\n    if (actualHeader != CODEC_MAGIC) {\n      throw new CorruptIndexException(\"codec header mismatch: actual header=\" + actualHeader + \" vs expected header=\" + CODEC_MAGIC + \" (resource: \" + in + \")\");\n    }\n    return checkHeaderNoMagic(in, codec, minVersion, maxVersion);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9a70ce9bddc6f985feb8e5e182aebe20872328d4","date":1411172748,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkHeader(DataInput,String,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkHeader(DataInput,String,int,int).mjava","sourceNew":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeHeader(DataOutput, String, int)}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code> and\n   * an expected version range (<code>minVersion to maxVersion</code>).\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>.\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeHeader(DataOutput, String, int)\n   */\n  public static int checkHeader(DataInput in, String codec, int minVersion, int maxVersion)\n    throws IOException {\n\n    // Safety to guard against reading a bogus string:\n    final int actualHeader = in.readInt();\n    if (actualHeader != CODEC_MAGIC) {\n      throw new CorruptIndexException(\"codec header mismatch: actual header=\" + actualHeader + \" vs expected header=\" + CODEC_MAGIC, in);\n    }\n    return checkHeaderNoMagic(in, codec, minVersion, maxVersion);\n  }\n\n","sourceOld":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeHeader(DataOutput, String, int)}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code> and\n   * an expected version range (<code>minVersion to maxVersion</code>).\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>.\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeHeader(DataOutput, String, int)\n   */\n  public static int checkHeader(DataInput in, String codec, int minVersion, int maxVersion)\n    throws IOException {\n\n    // Safety to guard against reading a bogus string:\n    final int actualHeader = in.readInt();\n    if (actualHeader != CODEC_MAGIC) {\n      throw new CorruptIndexException(\"codec header mismatch: actual header=\" + actualHeader + \" vs expected header=\" + CODEC_MAGIC + \" (resource: \" + in + \")\");\n    }\n    return checkHeaderNoMagic(in, codec, minVersion, maxVersion);\n  }\n\n","bugFix":["f1efe3edca215dd9891cb42af283fed96f792ca0"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b11b097f011a298f1a54676482032c2b261e26f3","date":1411698138,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkHeader(DataInput,String,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkHeader(DataInput,String,int,int).mjava","sourceNew":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeHeader(DataOutput, String, int)}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code> and\n   * an expected version range (<code>minVersion to maxVersion</code>).\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>.\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeHeader(DataOutput, String, int)\n   */\n  public static int checkHeader(DataInput in, String codec, int minVersion, int maxVersion) throws IOException {\n    // Safety to guard against reading a bogus string:\n    final int actualHeader = in.readInt();\n    if (actualHeader != CODEC_MAGIC) {\n      throw new CorruptIndexException(\"codec header mismatch: actual header=\" + actualHeader + \" vs expected header=\" + CODEC_MAGIC, in);\n    }\n    return checkHeaderNoMagic(in, codec, minVersion, maxVersion);\n  }\n\n","sourceOld":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeHeader(DataOutput, String, int)}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code> and\n   * an expected version range (<code>minVersion to maxVersion</code>).\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>.\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeHeader(DataOutput, String, int)\n   */\n  public static int checkHeader(DataInput in, String codec, int minVersion, int maxVersion)\n    throws IOException {\n\n    // Safety to guard against reading a bogus string:\n    final int actualHeader = in.readInt();\n    if (actualHeader != CODEC_MAGIC) {\n      throw new CorruptIndexException(\"codec header mismatch: actual header=\" + actualHeader + \" vs expected header=\" + CODEC_MAGIC, in);\n    }\n    return checkHeaderNoMagic(in, codec, minVersion, maxVersion);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5f6bd27530a2846413fe2d00030493c0e2d3a072","date":1411811855,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkHeader(DataInput,String,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkHeader(DataInput,String,int,int).mjava","sourceNew":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeHeader(DataOutput, String, int)}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code> and\n   * an expected version range (<code>minVersion to maxVersion</code>).\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>.\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeHeader(DataOutput, String, int)\n   */\n  public static int checkHeader(DataInput in, String codec, int minVersion, int maxVersion) throws IOException {\n    // Safety to guard against reading a bogus string:\n    final int actualHeader = in.readInt();\n    if (actualHeader != CODEC_MAGIC) {\n      throw new CorruptIndexException(\"codec header mismatch: actual header=\" + actualHeader + \" vs expected header=\" + CODEC_MAGIC, in);\n    }\n    return checkHeaderNoMagic(in, codec, minVersion, maxVersion);\n  }\n\n","sourceOld":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeHeader(DataOutput, String, int)}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code> and\n   * an expected version range (<code>minVersion to maxVersion</code>).\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>.\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeHeader(DataOutput, String, int)\n   */\n  public static int checkHeader(DataInput in, String codec, int minVersion, int maxVersion)\n    throws IOException {\n\n    // Safety to guard against reading a bogus string:\n    final int actualHeader = in.readInt();\n    if (actualHeader != CODEC_MAGIC) {\n      throw new CorruptIndexException(\"codec header mismatch: actual header=\" + actualHeader + \" vs expected header=\" + CODEC_MAGIC, in);\n    }\n    return checkHeaderNoMagic(in, codec, minVersion, maxVersion);\n  }\n\n","bugFix":["955c32f886db6f6356c9fcdea6b1f1cb4effda24","5a26f154aa4ead03cc4cb89ee0e9e4f9b79443f0"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b1eb427f2c6beed80d1724555fc1db003ccf3030","date":1417137397,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkHeader(DataInput,String,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#checkHeader(DataInput,String,int,int).mjava","sourceNew":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeHeader(DataOutput, String, int)}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code> and\n   * an expected version range (<code>minVersion to maxVersion</code>).\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where {@code minVersion <= actual <= maxVersion}.\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeHeader(DataOutput, String, int)\n   */\n  public static int checkHeader(DataInput in, String codec, int minVersion, int maxVersion) throws IOException {\n    // Safety to guard against reading a bogus string:\n    final int actualHeader = in.readInt();\n    if (actualHeader != CODEC_MAGIC) {\n      throw new CorruptIndexException(\"codec header mismatch: actual header=\" + actualHeader + \" vs expected header=\" + CODEC_MAGIC, in);\n    }\n    return checkHeaderNoMagic(in, codec, minVersion, maxVersion);\n  }\n\n","sourceOld":"  /**\n   * Reads and validates a header previously written with \n   * {@link #writeHeader(DataOutput, String, int)}.\n   * <p>\n   * When reading a file, supply the expected <code>codec</code> and\n   * an expected version range (<code>minVersion to maxVersion</code>).\n   * \n   * @param in Input stream, positioned at the point where the\n   *        header was previously written. Typically this is located\n   *        at the beginning of the file.\n   * @param codec The expected codec name.\n   * @param minVersion The minimum supported expected version number.\n   * @param maxVersion The maximum supported expected version number.\n   * @return The actual version found, when a valid header is found \n   *         that matches <code>codec</code>, with an actual version \n   *         where <code>minVersion <= actual <= maxVersion</code>.\n   *         Otherwise an exception is thrown.\n   * @throws CorruptIndexException If the first four bytes are not\n   *         {@link #CODEC_MAGIC}, or if the actual codec found is\n   *         not <code>codec</code>.\n   * @throws IndexFormatTooOldException If the actual version is less \n   *         than <code>minVersion</code>.\n   * @throws IndexFormatTooNewException If the actual version is greater \n   *         than <code>maxVersion</code>.\n   * @throws IOException If there is an I/O error reading from the underlying medium.\n   * @see #writeHeader(DataOutput, String, int)\n   */\n  public static int checkHeader(DataInput in, String codec, int minVersion, int maxVersion) throws IOException {\n    // Safety to guard against reading a bogus string:\n    final int actualHeader = in.readInt();\n    if (actualHeader != CODEC_MAGIC) {\n      throw new CorruptIndexException(\"codec header mismatch: actual header=\" + actualHeader + \" vs expected header=\" + CODEC_MAGIC, in);\n    }\n    return checkHeaderNoMagic(in, codec, minVersion, maxVersion);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b1eb427f2c6beed80d1724555fc1db003ccf3030":["5f6bd27530a2846413fe2d00030493c0e2d3a072"],"9a70ce9bddc6f985feb8e5e182aebe20872328d4":["bcce0e518c0546269a896ca6124ba4313059185f"],"bcce0e518c0546269a896ca6124ba4313059185f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","bcce0e518c0546269a896ca6124ba4313059185f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5f6bd27530a2846413fe2d00030493c0e2d3a072":["9a70ce9bddc6f985feb8e5e182aebe20872328d4","b11b097f011a298f1a54676482032c2b261e26f3"],"b11b097f011a298f1a54676482032c2b261e26f3":["9a70ce9bddc6f985feb8e5e182aebe20872328d4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b1eb427f2c6beed80d1724555fc1db003ccf3030"]},"commit2Childs":{"b1eb427f2c6beed80d1724555fc1db003ccf3030":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9a70ce9bddc6f985feb8e5e182aebe20872328d4":["5f6bd27530a2846413fe2d00030493c0e2d3a072","b11b097f011a298f1a54676482032c2b261e26f3"],"bcce0e518c0546269a896ca6124ba4313059185f":["9a70ce9bddc6f985feb8e5e182aebe20872328d4","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"5f6bd27530a2846413fe2d00030493c0e2d3a072":["b1eb427f2c6beed80d1724555fc1db003ccf3030"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bcce0e518c0546269a896ca6124ba4313059185f","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"b11b097f011a298f1a54676482032c2b261e26f3":["5f6bd27530a2846413fe2d00030493c0e2d3a072"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}