{"path":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#test().mjava","commits":[{"id":"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9","date":1453892412,"type":1,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#test().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestNRTReplication#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    Node.globalStartNS = System.nanoTime();\n\n    message(\"change thread name from \" + Thread.currentThread().getName());\n    Thread.currentThread().setName(\"main\");\n\n    childTempDir = createTempDir(\"child\");\n\n    // We are parent process:\n\n    // Silly bootstrapping:\n    versionToTransLogLocation.put(0L, 0L);\n    versionToTransLogLocation.put(1L, 0L);\n\n    int numNodes;\n\n    if (NUM_NODES == null) {\n      numNodes = TestUtil.nextInt(random(), 2, 10);\n    } else {\n      numNodes = NUM_NODES.intValue();\n    }\n\n    System.out.println(\"TEST: using \" + numNodes + \" nodes\");\n\n    transLogPath = createTempDir(\"NRTReplication\").resolve(\"translog\");\n    transLog = new SimpleTransLog(transLogPath);\n\n    //state.rateLimiters = new RateLimiter[numNodes];\n    indexPaths = new Path[numNodes];\n    nodes = new NodeProcess[numNodes];\n    nodeTimeStamps = new long[numNodes];\n    Arrays.fill(nodeTimeStamps, Node.globalStartNS);\n    starting = new boolean[numNodes];\n    \n    for(int i=0;i<numNodes;i++) {\n      indexPaths[i] = createTempDir(\"index\" + i);\n    }\n\n    Thread[] indexers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + indexers.length + \" indexer threads\");\n    for(int i=0;i<indexers.length;i++) {\n      indexers[i] = new IndexThread();\n      indexers[i].setName(\"indexer\" + i);\n      indexers[i].setDaemon(true);\n      indexers[i].start();\n    }\n\n    Thread[] searchers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + searchers.length + \" searcher threads\");\n    for(int i=0;i<searchers.length;i++) {\n      searchers[i] = new SearchThread();\n      searchers[i].setName(\"searcher\" + i);\n      searchers[i].setDaemon(true);\n      searchers[i].start();\n    }\n\n    Thread restarter = new RestartThread();\n    restarter.setName(\"restarter\");\n    restarter.setDaemon(true);\n    restarter.start();\n\n    int runTimeSec;\n    if (TEST_NIGHTLY) {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 120, 240);\n    } else {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 45, 120);\n    }\n\n    System.out.println(\"TEST: will run for \" + runTimeSec + \" sec\");\n\n    long endTime = System.nanoTime() + runTimeSec*1000000000L;\n\n    sendReplicasToPrimary();\n\n    while (failed.get() == false && System.nanoTime() < endTime) {\n\n      // Wait a bit:\n      Thread.sleep(TestUtil.nextInt(random(), Math.min(runTimeSec*4, 200), runTimeSec*4));\n      if (primary != null && random().nextBoolean()) {\n        message(\"top: now flush primary\");\n        NodeProcess curPrimary = primary;\n        if (curPrimary != null) {\n\n          // Save these before we start flush:\n          long nextTransLogLoc = transLog.getNextLocation();\n          int markerUptoSav = markerUpto.get();\n\n          long result;\n          try {\n            result = primary.flush();\n          } catch (Throwable t) {\n            message(\"top: flush failed; skipping: \" + t.getMessage());\n            result = -1;\n          }\n          if (result > 0) {\n            // There were changes\n            lastPrimaryVersion = result;\n            addTransLogLoc(lastPrimaryVersion, nextTransLogLoc);\n            addVersionMarker(lastPrimaryVersion, markerUptoSav);\n          }\n        }\n      }\n\n      StringBuilder sb = new StringBuilder();\n      int liveCount = 0;\n      for(int i=0;i<nodes.length;i++) {\n        NodeProcess node = nodes[i];\n        if (node != null) {\n          if (sb.length() != 0) {\n            sb.append(\" \");\n          }\n          liveCount++;\n          if (node.isPrimary) {\n            sb.append('P');\n          } else {\n            sb.append('R');\n          }\n          sb.append(i);\n        }\n      }\n\n      message(\"PG=\" + (primary == null ? \"X\" : primaryGen) + \" \" + liveCount + \" (of \" + nodes.length + \") nodes running: \" + sb);\n\n      // Commit a random node, primary or replica\n\n      {\n        NodeProcess node = nodes[random().nextInt(nodes.length)];\n        if (node != null) {\n          // TODO: if this node is primary, it means we committed a \"partial\" version (not exposed as an NRT point)... not sure it matters.\n          // maybe we somehow allow IW to commit a specific sis (the one we just flushed)?\n          message(\"top: now commit node=\" + node);\n          node.commitAsync();\n        }\n      }\n    }\n\n    message(\"TEST: top: test done, now close\");\n    stop.set(true);\n    for(Thread thread : indexers) {\n      thread.join();\n    }\n    for(Thread thread : searchers) {\n      thread.join();\n    }\n    restarter.join();\n\n    // Close replicas before primary so we cancel any in-progres replications:\n    System.out.println(\"TEST: top: now close replicas\");\n    List<Closeable> toClose = new ArrayList<>();\n    for(NodeProcess node : nodes) {\n      if (node != primary && node != null) {\n        toClose.add(node);\n      }\n    }\n    IOUtils.close(toClose);\n    IOUtils.close(primary);\n    IOUtils.close(transLog);\n\n    if (failed.get() == false) {\n      message(\"TEST: top: now checkIndex\");    \n      for(Path path : indexPaths) {\n        message(\"TEST: check \" + path);\n        MockDirectoryWrapper dir = newMockFSDirectory(path);\n        // Just too slow otherwise\n        dir.setCrossCheckTermVectorsOnClose(false);\n        dir.close();\n      }\n    } else {\n      message(\"TEST: failed; skip checkIndex\");\n    }\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    Node.globalStartNS = System.nanoTime();\n\n    message(\"change thread name from \" + Thread.currentThread().getName());\n    Thread.currentThread().setName(\"main\");\n\n    childTempDir = createTempDir(\"child\");\n\n    // We are parent process:\n\n    // Silly bootstrapping:\n    versionToTransLogLocation.put(0L, 0L);\n    versionToTransLogLocation.put(1L, 0L);\n\n    int numNodes;\n\n    if (NUM_NODES == null) {\n      numNodes = TestUtil.nextInt(random(), 2, 10);\n    } else {\n      numNodes = NUM_NODES.intValue();\n    }\n\n    System.out.println(\"TEST: using \" + numNodes + \" nodes\");\n\n    transLogPath = createTempDir(\"NRTReplication\").resolve(\"translog\");\n    transLog = new SimpleTransLog(transLogPath);\n\n    //state.rateLimiters = new RateLimiter[numNodes];\n    indexPaths = new Path[numNodes];\n    nodes = new NodeProcess[numNodes];\n    nodeTimeStamps = new long[numNodes];\n    Arrays.fill(nodeTimeStamps, Node.globalStartNS);\n    starting = new boolean[numNodes];\n    \n    for(int i=0;i<numNodes;i++) {\n      indexPaths[i] = createTempDir(\"index\" + i);\n    }\n\n    Thread[] indexers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + indexers.length + \" indexer threads\");\n    for(int i=0;i<indexers.length;i++) {\n      indexers[i] = new IndexThread();\n      indexers[i].setName(\"indexer\" + i);\n      indexers[i].setDaemon(true);\n      indexers[i].start();\n    }\n\n    Thread[] searchers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + searchers.length + \" searcher threads\");\n    for(int i=0;i<searchers.length;i++) {\n      searchers[i] = new SearchThread();\n      searchers[i].setName(\"searcher\" + i);\n      searchers[i].setDaemon(true);\n      searchers[i].start();\n    }\n\n    Thread restarter = new RestartThread();\n    restarter.setName(\"restarter\");\n    restarter.setDaemon(true);\n    restarter.start();\n\n    int runTimeSec;\n    if (TEST_NIGHTLY) {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 120, 240);\n    } else {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 45, 120);\n    }\n\n    System.out.println(\"TEST: will run for \" + runTimeSec + \" sec\");\n\n    long endTime = System.nanoTime() + runTimeSec*1000000000L;\n\n    sendReplicasToPrimary();\n\n    while (failed.get() == false && System.nanoTime() < endTime) {\n\n      // Wait a bit:\n      Thread.sleep(TestUtil.nextInt(random(), Math.min(runTimeSec*4, 200), runTimeSec*4));\n      if (primary != null && random().nextBoolean()) {\n        message(\"top: now flush primary\");\n        NodeProcess curPrimary = primary;\n        if (curPrimary != null) {\n\n          // Save these before we start flush:\n          long nextTransLogLoc = transLog.getNextLocation();\n          int markerUptoSav = markerUpto.get();\n\n          long result;\n          try {\n            result = primary.flush();\n          } catch (Throwable t) {\n            message(\"top: flush failed; skipping: \" + t.getMessage());\n            result = -1;\n          }\n          if (result > 0) {\n            // There were changes\n            lastPrimaryVersion = result;\n            addTransLogLoc(lastPrimaryVersion, nextTransLogLoc);\n            addVersionMarker(lastPrimaryVersion, markerUptoSav);\n          }\n        }\n      }\n\n      StringBuilder sb = new StringBuilder();\n      int liveCount = 0;\n      for(int i=0;i<nodes.length;i++) {\n        NodeProcess node = nodes[i];\n        if (node != null) {\n          if (sb.length() != 0) {\n            sb.append(\" \");\n          }\n          liveCount++;\n          if (node.isPrimary) {\n            sb.append('P');\n          } else {\n            sb.append('R');\n          }\n          sb.append(i);\n        }\n      }\n\n      message(\"PG=\" + (primary == null ? \"X\" : primaryGen) + \" \" + liveCount + \" (of \" + nodes.length + \") nodes running: \" + sb);\n\n      // Commit a random node, primary or replica\n\n      {\n        NodeProcess node = nodes[random().nextInt(nodes.length)];\n        if (node != null) {\n          // TODO: if this node is primary, it means we committed a \"partial\" version (not exposed as an NRT point)... not sure it matters.\n          // maybe we somehow allow IW to commit a specific sis (the one we just flushed)?\n          message(\"top: now commit node=\" + node);\n          node.commitAsync();\n        }\n      }\n    }\n\n    message(\"TEST: top: test done, now close\");\n    stop.set(true);\n    for(Thread thread : indexers) {\n      thread.join();\n    }\n    for(Thread thread : searchers) {\n      thread.join();\n    }\n    restarter.join();\n\n    // Close replicas before primary so we cancel any in-progres replications:\n    System.out.println(\"TEST: top: now close replicas\");\n    List<Closeable> toClose = new ArrayList<>();\n    for(NodeProcess node : nodes) {\n      if (node != primary && node != null) {\n        toClose.add(node);\n      }\n    }\n    IOUtils.close(toClose);\n    IOUtils.close(primary);\n    IOUtils.close(transLog);\n\n    if (failed.get() == false) {\n      message(\"TEST: top: now checkIndex\");    \n      for(Path path : indexPaths) {\n        message(\"TEST: check \" + path);\n        MockDirectoryWrapper dir = newMockFSDirectory(path);\n        // Just too slow otherwise\n        dir.setCrossCheckTermVectorsOnClose(false);\n        dir.close();\n      }\n    } else {\n      message(\"TEST: failed; skip checkIndex\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec317d5d3de749e12abcc9e6f976d765638fe9e2","date":1454411397,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#test().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    Node.globalStartNS = System.nanoTime();\n\n    message(\"change thread name from \" + Thread.currentThread().getName());\n    Thread.currentThread().setName(\"main\");\n\n    childTempDir = createTempDir(\"child\");\n\n    // We are parent process:\n\n    // Silly bootstrapping:\n    versionToTransLogLocation.put(0L, 0L);\n\n    // nocommit why also 1?\n    //versionToTransLogLocation.put(1L, 0L);\n\n    versionToMarker.put(0L, 0);\n\n    int numNodes;\n\n    if (NUM_NODES == null) {\n      numNodes = TestUtil.nextInt(random(), 2, 10);\n    } else {\n      numNodes = NUM_NODES.intValue();\n    }\n\n    System.out.println(\"TEST: using \" + numNodes + \" nodes\");\n\n    transLogPath = createTempDir(\"NRTReplication\").resolve(\"translog\");\n    transLog = new SimpleTransLog(transLogPath);\n\n    //state.rateLimiters = new RateLimiter[numNodes];\n    indexPaths = new Path[numNodes];\n    nodes = new NodeProcess[numNodes];\n    nodeTimeStamps = new long[numNodes];\n    Arrays.fill(nodeTimeStamps, Node.globalStartNS);\n    starting = new boolean[numNodes];\n    \n    for(int i=0;i<numNodes;i++) {\n      indexPaths[i] = createTempDir(\"index\" + i);\n    }\n\n    Thread[] indexers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + indexers.length + \" indexer threads\");\n    for(int i=0;i<indexers.length;i++) {\n      indexers[i] = new IndexThread();\n      indexers[i].setName(\"indexer\" + i);\n      indexers[i].setDaemon(true);\n      indexers[i].start();\n    }\n\n    Thread[] searchers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + searchers.length + \" searcher threads\");\n    for(int i=0;i<searchers.length;i++) {\n      searchers[i] = new SearchThread();\n      searchers[i].setName(\"searcher\" + i);\n      searchers[i].setDaemon(true);\n      searchers[i].start();\n    }\n\n    Thread restarter = new RestartThread();\n    restarter.setName(\"restarter\");\n    restarter.setDaemon(true);\n    restarter.start();\n\n    int runTimeSec;\n    if (TEST_NIGHTLY) {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 120, 240);\n    } else {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 45, 120);\n    }\n\n    System.out.println(\"TEST: will run for \" + runTimeSec + \" sec\");\n\n    long endTime = System.nanoTime() + runTimeSec*1000000000L;\n\n    sendReplicasToPrimary();\n\n    while (failed.get() == false && System.nanoTime() < endTime) {\n\n      // Wait a bit:\n      Thread.sleep(TestUtil.nextInt(random(), Math.min(runTimeSec*4, 200), runTimeSec*4));\n      if (primary != null && random().nextBoolean()) {\n        NodeProcess curPrimary = primary;\n        if (curPrimary != null) {\n\n          // Save these before we start flush:\n          long nextTransLogLoc = transLog.getNextLocation();\n          int markerUptoSav = markerUpto.get();\n          message(\"top: now flush primary; at least marker count=\" + markerUptoSav);\n\n          long result;\n          try {\n            result = primary.flush(markerUptoSav);\n          } catch (Throwable t) {\n            message(\"top: flush failed; skipping: \" + t.getMessage());\n            result = -1;\n          }\n          if (result > 0) {\n            // There were changes\n            message(\"top: flush finished with changed; new primary version=\" + result);\n            lastPrimaryVersion = result;\n            addTransLogLoc(lastPrimaryVersion, nextTransLogLoc);\n            addVersionMarker(lastPrimaryVersion, markerUptoSav);\n          }\n        }\n      }\n\n      StringBuilder sb = new StringBuilder();\n      int liveCount = 0;\n      for(int i=0;i<nodes.length;i++) {\n        NodeProcess node = nodes[i];\n        if (node != null) {\n          if (sb.length() != 0) {\n            sb.append(\" \");\n          }\n          liveCount++;\n          if (node.isPrimary) {\n            sb.append('P');\n          } else {\n            sb.append('R');\n          }\n          sb.append(i);\n        }\n      }\n\n      message(\"PG=\" + (primary == null ? \"X\" : primaryGen) + \" \" + liveCount + \" (of \" + nodes.length + \") nodes running: \" + sb);\n\n      // Commit a random node, primary or replica\n\n      {\n        NodeProcess node = nodes[random().nextInt(nodes.length)];\n        if (node != null && node.nodeIsClosing.get() == false) {\n          // TODO: if this node is primary, it means we committed a \"partial\" version (not exposed as an NRT point)... not sure it matters.\n          // maybe we somehow allow IW to commit a specific sis (the one we just flushed)?\n          message(\"top: now commit node=\" + node);\n          node.commitAsync();\n        }\n      }\n    }\n\n    message(\"TEST: top: test done, now close\");\n    stop.set(true);\n    for(Thread thread : indexers) {\n      thread.join();\n    }\n    for(Thread thread : searchers) {\n      thread.join();\n    }\n    restarter.join();\n\n    // Close replicas before primary so we cancel any in-progres replications:\n    System.out.println(\"TEST: top: now close replicas\");\n    List<Closeable> toClose = new ArrayList<>();\n    for(NodeProcess node : nodes) {\n      if (node != primary && node != null) {\n        toClose.add(node);\n      }\n    }\n    IOUtils.close(toClose);\n    IOUtils.close(primary);\n    IOUtils.close(transLog);\n\n    if (failed.get() == false) {\n      message(\"TEST: top: now checkIndex\");    \n      for(Path path : indexPaths) {\n        message(\"TEST: check \" + path);\n        MockDirectoryWrapper dir = newMockFSDirectory(path);\n        // Just too slow otherwise\n        dir.setCrossCheckTermVectorsOnClose(false);\n        dir.close();\n      }\n    } else {\n      message(\"TEST: failed; skip checkIndex\");\n    }\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    Node.globalStartNS = System.nanoTime();\n\n    message(\"change thread name from \" + Thread.currentThread().getName());\n    Thread.currentThread().setName(\"main\");\n\n    childTempDir = createTempDir(\"child\");\n\n    // We are parent process:\n\n    // Silly bootstrapping:\n    versionToTransLogLocation.put(0L, 0L);\n    versionToTransLogLocation.put(1L, 0L);\n\n    int numNodes;\n\n    if (NUM_NODES == null) {\n      numNodes = TestUtil.nextInt(random(), 2, 10);\n    } else {\n      numNodes = NUM_NODES.intValue();\n    }\n\n    System.out.println(\"TEST: using \" + numNodes + \" nodes\");\n\n    transLogPath = createTempDir(\"NRTReplication\").resolve(\"translog\");\n    transLog = new SimpleTransLog(transLogPath);\n\n    //state.rateLimiters = new RateLimiter[numNodes];\n    indexPaths = new Path[numNodes];\n    nodes = new NodeProcess[numNodes];\n    nodeTimeStamps = new long[numNodes];\n    Arrays.fill(nodeTimeStamps, Node.globalStartNS);\n    starting = new boolean[numNodes];\n    \n    for(int i=0;i<numNodes;i++) {\n      indexPaths[i] = createTempDir(\"index\" + i);\n    }\n\n    Thread[] indexers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + indexers.length + \" indexer threads\");\n    for(int i=0;i<indexers.length;i++) {\n      indexers[i] = new IndexThread();\n      indexers[i].setName(\"indexer\" + i);\n      indexers[i].setDaemon(true);\n      indexers[i].start();\n    }\n\n    Thread[] searchers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + searchers.length + \" searcher threads\");\n    for(int i=0;i<searchers.length;i++) {\n      searchers[i] = new SearchThread();\n      searchers[i].setName(\"searcher\" + i);\n      searchers[i].setDaemon(true);\n      searchers[i].start();\n    }\n\n    Thread restarter = new RestartThread();\n    restarter.setName(\"restarter\");\n    restarter.setDaemon(true);\n    restarter.start();\n\n    int runTimeSec;\n    if (TEST_NIGHTLY) {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 120, 240);\n    } else {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 45, 120);\n    }\n\n    System.out.println(\"TEST: will run for \" + runTimeSec + \" sec\");\n\n    long endTime = System.nanoTime() + runTimeSec*1000000000L;\n\n    sendReplicasToPrimary();\n\n    while (failed.get() == false && System.nanoTime() < endTime) {\n\n      // Wait a bit:\n      Thread.sleep(TestUtil.nextInt(random(), Math.min(runTimeSec*4, 200), runTimeSec*4));\n      if (primary != null && random().nextBoolean()) {\n        message(\"top: now flush primary\");\n        NodeProcess curPrimary = primary;\n        if (curPrimary != null) {\n\n          // Save these before we start flush:\n          long nextTransLogLoc = transLog.getNextLocation();\n          int markerUptoSav = markerUpto.get();\n\n          long result;\n          try {\n            result = primary.flush();\n          } catch (Throwable t) {\n            message(\"top: flush failed; skipping: \" + t.getMessage());\n            result = -1;\n          }\n          if (result > 0) {\n            // There were changes\n            lastPrimaryVersion = result;\n            addTransLogLoc(lastPrimaryVersion, nextTransLogLoc);\n            addVersionMarker(lastPrimaryVersion, markerUptoSav);\n          }\n        }\n      }\n\n      StringBuilder sb = new StringBuilder();\n      int liveCount = 0;\n      for(int i=0;i<nodes.length;i++) {\n        NodeProcess node = nodes[i];\n        if (node != null) {\n          if (sb.length() != 0) {\n            sb.append(\" \");\n          }\n          liveCount++;\n          if (node.isPrimary) {\n            sb.append('P');\n          } else {\n            sb.append('R');\n          }\n          sb.append(i);\n        }\n      }\n\n      message(\"PG=\" + (primary == null ? \"X\" : primaryGen) + \" \" + liveCount + \" (of \" + nodes.length + \") nodes running: \" + sb);\n\n      // Commit a random node, primary or replica\n\n      {\n        NodeProcess node = nodes[random().nextInt(nodes.length)];\n        if (node != null) {\n          // TODO: if this node is primary, it means we committed a \"partial\" version (not exposed as an NRT point)... not sure it matters.\n          // maybe we somehow allow IW to commit a specific sis (the one we just flushed)?\n          message(\"top: now commit node=\" + node);\n          node.commitAsync();\n        }\n      }\n    }\n\n    message(\"TEST: top: test done, now close\");\n    stop.set(true);\n    for(Thread thread : indexers) {\n      thread.join();\n    }\n    for(Thread thread : searchers) {\n      thread.join();\n    }\n    restarter.join();\n\n    // Close replicas before primary so we cancel any in-progres replications:\n    System.out.println(\"TEST: top: now close replicas\");\n    List<Closeable> toClose = new ArrayList<>();\n    for(NodeProcess node : nodes) {\n      if (node != primary && node != null) {\n        toClose.add(node);\n      }\n    }\n    IOUtils.close(toClose);\n    IOUtils.close(primary);\n    IOUtils.close(transLog);\n\n    if (failed.get() == false) {\n      message(\"TEST: top: now checkIndex\");    \n      for(Path path : indexPaths) {\n        message(\"TEST: check \" + path);\n        MockDirectoryWrapper dir = newMockFSDirectory(path);\n        // Just too slow otherwise\n        dir.setCrossCheckTermVectorsOnClose(false);\n        dir.close();\n      }\n    } else {\n      message(\"TEST: failed; skip checkIndex\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"13ea66b549e25413e4e3057bf3492ab828899110","date":1454958424,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#test().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    Node.globalStartNS = System.nanoTime();\n\n    message(\"change thread name from \" + Thread.currentThread().getName());\n    Thread.currentThread().setName(\"main\");\n\n    childTempDir = createTempDir(\"child\");\n\n    // We are parent process:\n\n    // Silly bootstrapping:\n    versionToTransLogLocation.put(0L, 0L);\n\n    versionToMarker.put(0L, 0);\n\n    int numNodes;\n\n    if (NUM_NODES == null) {\n      numNodes = TestUtil.nextInt(random(), 2, 10);\n    } else {\n      numNodes = NUM_NODES.intValue();\n    }\n\n    System.out.println(\"TEST: using \" + numNodes + \" nodes\");\n\n    transLogPath = createTempDir(\"NRTReplication\").resolve(\"translog\");\n    transLog = new SimpleTransLog(transLogPath);\n\n    //state.rateLimiters = new RateLimiter[numNodes];\n    indexPaths = new Path[numNodes];\n    nodes = new NodeProcess[numNodes];\n    nodeTimeStamps = new long[numNodes];\n    Arrays.fill(nodeTimeStamps, Node.globalStartNS);\n    starting = new boolean[numNodes];\n    \n    for(int i=0;i<numNodes;i++) {\n      indexPaths[i] = createTempDir(\"index\" + i);\n    }\n\n    Thread[] indexers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + indexers.length + \" indexer threads\");\n    for(int i=0;i<indexers.length;i++) {\n      indexers[i] = new IndexThread();\n      indexers[i].setName(\"indexer\" + i);\n      indexers[i].setDaemon(true);\n      indexers[i].start();\n    }\n\n    Thread[] searchers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + searchers.length + \" searcher threads\");\n    for(int i=0;i<searchers.length;i++) {\n      searchers[i] = new SearchThread();\n      searchers[i].setName(\"searcher\" + i);\n      searchers[i].setDaemon(true);\n      searchers[i].start();\n    }\n\n    Thread restarter = new RestartThread();\n    restarter.setName(\"restarter\");\n    restarter.setDaemon(true);\n    restarter.start();\n\n    int runTimeSec;\n    if (TEST_NIGHTLY) {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 120, 240);\n    } else {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 45, 120);\n    }\n\n    System.out.println(\"TEST: will run for \" + runTimeSec + \" sec\");\n\n    long endTime = System.nanoTime() + runTimeSec*1000000000L;\n\n    sendReplicasToPrimary();\n\n    while (failed.get() == false && System.nanoTime() < endTime) {\n\n      // Wait a bit:\n      Thread.sleep(TestUtil.nextInt(random(), Math.min(runTimeSec*4, 200), runTimeSec*4));\n      if (primary != null && random().nextBoolean()) {\n        NodeProcess curPrimary = primary;\n        if (curPrimary != null) {\n\n          // Save these before we start flush:\n          long nextTransLogLoc = transLog.getNextLocation();\n          int markerUptoSav = markerUpto.get();\n          message(\"top: now flush primary; at least marker count=\" + markerUptoSav);\n\n          long result;\n          try {\n            result = primary.flush(markerUptoSav);\n          } catch (Throwable t) {\n            message(\"top: flush failed; skipping: \" + t.getMessage());\n            result = -1;\n          }\n          if (result > 0) {\n            // There were changes\n            message(\"top: flush finished with changed; new primary version=\" + result);\n            lastPrimaryVersion = result;\n            addTransLogLoc(lastPrimaryVersion, nextTransLogLoc);\n            addVersionMarker(lastPrimaryVersion, markerUptoSav);\n          }\n        }\n      }\n\n      StringBuilder sb = new StringBuilder();\n      int liveCount = 0;\n      for(int i=0;i<nodes.length;i++) {\n        NodeProcess node = nodes[i];\n        if (node != null) {\n          if (sb.length() != 0) {\n            sb.append(\" \");\n          }\n          liveCount++;\n          if (node.isPrimary) {\n            sb.append('P');\n          } else {\n            sb.append('R');\n          }\n          sb.append(i);\n        }\n      }\n\n      message(\"PG=\" + (primary == null ? \"X\" : primaryGen) + \" \" + liveCount + \" (of \" + nodes.length + \") nodes running: \" + sb);\n\n      // Commit a random node, primary or replica\n\n      {\n        NodeProcess node = nodes[random().nextInt(nodes.length)];\n        if (node != null && node.nodeIsClosing.get() == false) {\n          // TODO: if this node is primary, it means we committed an unpublished version (not exposed as an NRT point)... not sure it matters.\n          // maybe we somehow allow IW to commit a specific sis (the one we just flushed)?\n          message(\"top: now commit node=\" + node);\n          try {\n            node.commitAsync();\n          } catch (Throwable t) {\n            message(\"top: hit exception during commit with R\" + node.id + \"; skipping\");\n            t.printStackTrace(System.out);\n          }\n        }\n      }\n    }\n\n    message(\"TEST: top: test done, now close\");\n    stop.set(true);\n    for(Thread thread : indexers) {\n      thread.join();\n    }\n    for(Thread thread : searchers) {\n      thread.join();\n    }\n    restarter.join();\n\n    // Close replicas before primary so we cancel any in-progres replications:\n    System.out.println(\"TEST: top: now close replicas\");\n    List<Closeable> toClose = new ArrayList<>();\n    for(NodeProcess node : nodes) {\n      if (node != primary && node != null) {\n        toClose.add(node);\n      }\n    }\n    IOUtils.close(toClose);\n    IOUtils.close(primary);\n    IOUtils.close(transLog);\n\n    if (failed.get() == false) {\n      message(\"TEST: top: now checkIndex\");    \n      for(Path path : indexPaths) {\n        message(\"TEST: check \" + path);\n        MockDirectoryWrapper dir = newMockFSDirectory(path);\n        // Just too slow otherwise\n        dir.setCrossCheckTermVectorsOnClose(false);\n        dir.close();\n      }\n    } else {\n      message(\"TEST: failed; skip checkIndex\");\n    }\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    Node.globalStartNS = System.nanoTime();\n\n    message(\"change thread name from \" + Thread.currentThread().getName());\n    Thread.currentThread().setName(\"main\");\n\n    childTempDir = createTempDir(\"child\");\n\n    // We are parent process:\n\n    // Silly bootstrapping:\n    versionToTransLogLocation.put(0L, 0L);\n\n    // nocommit why also 1?\n    //versionToTransLogLocation.put(1L, 0L);\n\n    versionToMarker.put(0L, 0);\n\n    int numNodes;\n\n    if (NUM_NODES == null) {\n      numNodes = TestUtil.nextInt(random(), 2, 10);\n    } else {\n      numNodes = NUM_NODES.intValue();\n    }\n\n    System.out.println(\"TEST: using \" + numNodes + \" nodes\");\n\n    transLogPath = createTempDir(\"NRTReplication\").resolve(\"translog\");\n    transLog = new SimpleTransLog(transLogPath);\n\n    //state.rateLimiters = new RateLimiter[numNodes];\n    indexPaths = new Path[numNodes];\n    nodes = new NodeProcess[numNodes];\n    nodeTimeStamps = new long[numNodes];\n    Arrays.fill(nodeTimeStamps, Node.globalStartNS);\n    starting = new boolean[numNodes];\n    \n    for(int i=0;i<numNodes;i++) {\n      indexPaths[i] = createTempDir(\"index\" + i);\n    }\n\n    Thread[] indexers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + indexers.length + \" indexer threads\");\n    for(int i=0;i<indexers.length;i++) {\n      indexers[i] = new IndexThread();\n      indexers[i].setName(\"indexer\" + i);\n      indexers[i].setDaemon(true);\n      indexers[i].start();\n    }\n\n    Thread[] searchers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + searchers.length + \" searcher threads\");\n    for(int i=0;i<searchers.length;i++) {\n      searchers[i] = new SearchThread();\n      searchers[i].setName(\"searcher\" + i);\n      searchers[i].setDaemon(true);\n      searchers[i].start();\n    }\n\n    Thread restarter = new RestartThread();\n    restarter.setName(\"restarter\");\n    restarter.setDaemon(true);\n    restarter.start();\n\n    int runTimeSec;\n    if (TEST_NIGHTLY) {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 120, 240);\n    } else {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 45, 120);\n    }\n\n    System.out.println(\"TEST: will run for \" + runTimeSec + \" sec\");\n\n    long endTime = System.nanoTime() + runTimeSec*1000000000L;\n\n    sendReplicasToPrimary();\n\n    while (failed.get() == false && System.nanoTime() < endTime) {\n\n      // Wait a bit:\n      Thread.sleep(TestUtil.nextInt(random(), Math.min(runTimeSec*4, 200), runTimeSec*4));\n      if (primary != null && random().nextBoolean()) {\n        NodeProcess curPrimary = primary;\n        if (curPrimary != null) {\n\n          // Save these before we start flush:\n          long nextTransLogLoc = transLog.getNextLocation();\n          int markerUptoSav = markerUpto.get();\n          message(\"top: now flush primary; at least marker count=\" + markerUptoSav);\n\n          long result;\n          try {\n            result = primary.flush(markerUptoSav);\n          } catch (Throwable t) {\n            message(\"top: flush failed; skipping: \" + t.getMessage());\n            result = -1;\n          }\n          if (result > 0) {\n            // There were changes\n            message(\"top: flush finished with changed; new primary version=\" + result);\n            lastPrimaryVersion = result;\n            addTransLogLoc(lastPrimaryVersion, nextTransLogLoc);\n            addVersionMarker(lastPrimaryVersion, markerUptoSav);\n          }\n        }\n      }\n\n      StringBuilder sb = new StringBuilder();\n      int liveCount = 0;\n      for(int i=0;i<nodes.length;i++) {\n        NodeProcess node = nodes[i];\n        if (node != null) {\n          if (sb.length() != 0) {\n            sb.append(\" \");\n          }\n          liveCount++;\n          if (node.isPrimary) {\n            sb.append('P');\n          } else {\n            sb.append('R');\n          }\n          sb.append(i);\n        }\n      }\n\n      message(\"PG=\" + (primary == null ? \"X\" : primaryGen) + \" \" + liveCount + \" (of \" + nodes.length + \") nodes running: \" + sb);\n\n      // Commit a random node, primary or replica\n\n      {\n        NodeProcess node = nodes[random().nextInt(nodes.length)];\n        if (node != null && node.nodeIsClosing.get() == false) {\n          // TODO: if this node is primary, it means we committed a \"partial\" version (not exposed as an NRT point)... not sure it matters.\n          // maybe we somehow allow IW to commit a specific sis (the one we just flushed)?\n          message(\"top: now commit node=\" + node);\n          node.commitAsync();\n        }\n      }\n    }\n\n    message(\"TEST: top: test done, now close\");\n    stop.set(true);\n    for(Thread thread : indexers) {\n      thread.join();\n    }\n    for(Thread thread : searchers) {\n      thread.join();\n    }\n    restarter.join();\n\n    // Close replicas before primary so we cancel any in-progres replications:\n    System.out.println(\"TEST: top: now close replicas\");\n    List<Closeable> toClose = new ArrayList<>();\n    for(NodeProcess node : nodes) {\n      if (node != primary && node != null) {\n        toClose.add(node);\n      }\n    }\n    IOUtils.close(toClose);\n    IOUtils.close(primary);\n    IOUtils.close(transLog);\n\n    if (failed.get() == false) {\n      message(\"TEST: top: now checkIndex\");    \n      for(Path path : indexPaths) {\n        message(\"TEST: check \" + path);\n        MockDirectoryWrapper dir = newMockFSDirectory(path);\n        // Just too slow otherwise\n        dir.setCrossCheckTermVectorsOnClose(false);\n        dir.close();\n      }\n    } else {\n      message(\"TEST: failed; skip checkIndex\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1b0febf62c2d9baeee7db38998d9197700ccbab9","date":1454958476,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#test().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    Node.globalStartNS = System.nanoTime();\n\n    message(\"change thread name from \" + Thread.currentThread().getName());\n    Thread.currentThread().setName(\"main\");\n\n    childTempDir = createTempDir(\"child\");\n\n    // We are parent process:\n\n    // Silly bootstrapping:\n    versionToTransLogLocation.put(0L, 0L);\n\n    versionToMarker.put(0L, 0);\n\n    int numNodes;\n\n    if (NUM_NODES == null) {\n      numNodes = TestUtil.nextInt(random(), 2, 10);\n    } else {\n      numNodes = NUM_NODES.intValue();\n    }\n\n    System.out.println(\"TEST: using \" + numNodes + \" nodes\");\n\n    transLogPath = createTempDir(\"NRTReplication\").resolve(\"translog\");\n    transLog = new SimpleTransLog(transLogPath);\n\n    //state.rateLimiters = new RateLimiter[numNodes];\n    indexPaths = new Path[numNodes];\n    nodes = new NodeProcess[numNodes];\n    nodeTimeStamps = new long[numNodes];\n    Arrays.fill(nodeTimeStamps, Node.globalStartNS);\n    starting = new boolean[numNodes];\n    \n    for(int i=0;i<numNodes;i++) {\n      indexPaths[i] = createTempDir(\"index\" + i);\n    }\n\n    Thread[] indexers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + indexers.length + \" indexer threads\");\n    for(int i=0;i<indexers.length;i++) {\n      indexers[i] = new IndexThread();\n      indexers[i].setName(\"indexer\" + i);\n      indexers[i].setDaemon(true);\n      indexers[i].start();\n    }\n\n    Thread[] searchers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + searchers.length + \" searcher threads\");\n    for(int i=0;i<searchers.length;i++) {\n      searchers[i] = new SearchThread();\n      searchers[i].setName(\"searcher\" + i);\n      searchers[i].setDaemon(true);\n      searchers[i].start();\n    }\n\n    Thread restarter = new RestartThread();\n    restarter.setName(\"restarter\");\n    restarter.setDaemon(true);\n    restarter.start();\n\n    int runTimeSec;\n    if (TEST_NIGHTLY) {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 120, 240);\n    } else {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 45, 120);\n    }\n\n    System.out.println(\"TEST: will run for \" + runTimeSec + \" sec\");\n\n    long endTime = System.nanoTime() + runTimeSec*1000000000L;\n\n    sendReplicasToPrimary();\n\n    while (failed.get() == false && System.nanoTime() < endTime) {\n\n      // Wait a bit:\n      Thread.sleep(TestUtil.nextInt(random(), Math.min(runTimeSec*4, 200), runTimeSec*4));\n      if (primary != null && random().nextBoolean()) {\n        NodeProcess curPrimary = primary;\n        if (curPrimary != null) {\n\n          // Save these before we start flush:\n          long nextTransLogLoc = transLog.getNextLocation();\n          int markerUptoSav = markerUpto.get();\n          message(\"top: now flush primary; at least marker count=\" + markerUptoSav);\n\n          long result;\n          try {\n            result = primary.flush(markerUptoSav);\n          } catch (Throwable t) {\n            message(\"top: flush failed; skipping: \" + t.getMessage());\n            result = -1;\n          }\n          if (result > 0) {\n            // There were changes\n            message(\"top: flush finished with changed; new primary version=\" + result);\n            lastPrimaryVersion = result;\n            addTransLogLoc(lastPrimaryVersion, nextTransLogLoc);\n            addVersionMarker(lastPrimaryVersion, markerUptoSav);\n          }\n        }\n      }\n\n      StringBuilder sb = new StringBuilder();\n      int liveCount = 0;\n      for(int i=0;i<nodes.length;i++) {\n        NodeProcess node = nodes[i];\n        if (node != null) {\n          if (sb.length() != 0) {\n            sb.append(\" \");\n          }\n          liveCount++;\n          if (node.isPrimary) {\n            sb.append('P');\n          } else {\n            sb.append('R');\n          }\n          sb.append(i);\n        }\n      }\n\n      message(\"PG=\" + (primary == null ? \"X\" : primaryGen) + \" \" + liveCount + \" (of \" + nodes.length + \") nodes running: \" + sb);\n\n      // Commit a random node, primary or replica\n\n      {\n        NodeProcess node = nodes[random().nextInt(nodes.length)];\n        if (node != null && node.nodeIsClosing.get() == false) {\n          // TODO: if this node is primary, it means we committed an unpublished version (not exposed as an NRT point)... not sure it matters.\n          // maybe we somehow allow IW to commit a specific sis (the one we just flushed)?\n          message(\"top: now commit node=\" + node);\n          try {\n            node.commitAsync();\n          } catch (Throwable t) {\n            message(\"top: hit exception during commit with R\" + node.id + \"; skipping\");\n            t.printStackTrace(System.out);\n          }\n        }\n      }\n    }\n\n    message(\"TEST: top: test done, now close\");\n    stop.set(true);\n    for(Thread thread : indexers) {\n      thread.join();\n    }\n    for(Thread thread : searchers) {\n      thread.join();\n    }\n    restarter.join();\n\n    // Close replicas before primary so we cancel any in-progres replications:\n    System.out.println(\"TEST: top: now close replicas\");\n    List<Closeable> toClose = new ArrayList<>();\n    for(NodeProcess node : nodes) {\n      if (node != primary && node != null) {\n        toClose.add(node);\n      }\n    }\n    IOUtils.close(toClose);\n    IOUtils.close(primary);\n    IOUtils.close(transLog);\n\n    if (failed.get() == false) {\n      message(\"TEST: top: now checkIndex\");    \n      for(Path path : indexPaths) {\n        message(\"TEST: check \" + path);\n        MockDirectoryWrapper dir = newMockFSDirectory(path);\n        // Just too slow otherwise\n        dir.setCrossCheckTermVectorsOnClose(false);\n        dir.close();\n      }\n    } else {\n      message(\"TEST: failed; skip checkIndex\");\n    }\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    Node.globalStartNS = System.nanoTime();\n\n    message(\"change thread name from \" + Thread.currentThread().getName());\n    Thread.currentThread().setName(\"main\");\n\n    childTempDir = createTempDir(\"child\");\n\n    // We are parent process:\n\n    // Silly bootstrapping:\n    versionToTransLogLocation.put(0L, 0L);\n\n    // nocommit why also 1?\n    //versionToTransLogLocation.put(1L, 0L);\n\n    versionToMarker.put(0L, 0);\n\n    int numNodes;\n\n    if (NUM_NODES == null) {\n      numNodes = TestUtil.nextInt(random(), 2, 10);\n    } else {\n      numNodes = NUM_NODES.intValue();\n    }\n\n    System.out.println(\"TEST: using \" + numNodes + \" nodes\");\n\n    transLogPath = createTempDir(\"NRTReplication\").resolve(\"translog\");\n    transLog = new SimpleTransLog(transLogPath);\n\n    //state.rateLimiters = new RateLimiter[numNodes];\n    indexPaths = new Path[numNodes];\n    nodes = new NodeProcess[numNodes];\n    nodeTimeStamps = new long[numNodes];\n    Arrays.fill(nodeTimeStamps, Node.globalStartNS);\n    starting = new boolean[numNodes];\n    \n    for(int i=0;i<numNodes;i++) {\n      indexPaths[i] = createTempDir(\"index\" + i);\n    }\n\n    Thread[] indexers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + indexers.length + \" indexer threads\");\n    for(int i=0;i<indexers.length;i++) {\n      indexers[i] = new IndexThread();\n      indexers[i].setName(\"indexer\" + i);\n      indexers[i].setDaemon(true);\n      indexers[i].start();\n    }\n\n    Thread[] searchers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + searchers.length + \" searcher threads\");\n    for(int i=0;i<searchers.length;i++) {\n      searchers[i] = new SearchThread();\n      searchers[i].setName(\"searcher\" + i);\n      searchers[i].setDaemon(true);\n      searchers[i].start();\n    }\n\n    Thread restarter = new RestartThread();\n    restarter.setName(\"restarter\");\n    restarter.setDaemon(true);\n    restarter.start();\n\n    int runTimeSec;\n    if (TEST_NIGHTLY) {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 120, 240);\n    } else {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 45, 120);\n    }\n\n    System.out.println(\"TEST: will run for \" + runTimeSec + \" sec\");\n\n    long endTime = System.nanoTime() + runTimeSec*1000000000L;\n\n    sendReplicasToPrimary();\n\n    while (failed.get() == false && System.nanoTime() < endTime) {\n\n      // Wait a bit:\n      Thread.sleep(TestUtil.nextInt(random(), Math.min(runTimeSec*4, 200), runTimeSec*4));\n      if (primary != null && random().nextBoolean()) {\n        NodeProcess curPrimary = primary;\n        if (curPrimary != null) {\n\n          // Save these before we start flush:\n          long nextTransLogLoc = transLog.getNextLocation();\n          int markerUptoSav = markerUpto.get();\n          message(\"top: now flush primary; at least marker count=\" + markerUptoSav);\n\n          long result;\n          try {\n            result = primary.flush(markerUptoSav);\n          } catch (Throwable t) {\n            message(\"top: flush failed; skipping: \" + t.getMessage());\n            result = -1;\n          }\n          if (result > 0) {\n            // There were changes\n            message(\"top: flush finished with changed; new primary version=\" + result);\n            lastPrimaryVersion = result;\n            addTransLogLoc(lastPrimaryVersion, nextTransLogLoc);\n            addVersionMarker(lastPrimaryVersion, markerUptoSav);\n          }\n        }\n      }\n\n      StringBuilder sb = new StringBuilder();\n      int liveCount = 0;\n      for(int i=0;i<nodes.length;i++) {\n        NodeProcess node = nodes[i];\n        if (node != null) {\n          if (sb.length() != 0) {\n            sb.append(\" \");\n          }\n          liveCount++;\n          if (node.isPrimary) {\n            sb.append('P');\n          } else {\n            sb.append('R');\n          }\n          sb.append(i);\n        }\n      }\n\n      message(\"PG=\" + (primary == null ? \"X\" : primaryGen) + \" \" + liveCount + \" (of \" + nodes.length + \") nodes running: \" + sb);\n\n      // Commit a random node, primary or replica\n\n      {\n        NodeProcess node = nodes[random().nextInt(nodes.length)];\n        if (node != null && node.nodeIsClosing.get() == false) {\n          // TODO: if this node is primary, it means we committed a \"partial\" version (not exposed as an NRT point)... not sure it matters.\n          // maybe we somehow allow IW to commit a specific sis (the one we just flushed)?\n          message(\"top: now commit node=\" + node);\n          node.commitAsync();\n        }\n      }\n    }\n\n    message(\"TEST: top: test done, now close\");\n    stop.set(true);\n    for(Thread thread : indexers) {\n      thread.join();\n    }\n    for(Thread thread : searchers) {\n      thread.join();\n    }\n    restarter.join();\n\n    // Close replicas before primary so we cancel any in-progres replications:\n    System.out.println(\"TEST: top: now close replicas\");\n    List<Closeable> toClose = new ArrayList<>();\n    for(NodeProcess node : nodes) {\n      if (node != primary && node != null) {\n        toClose.add(node);\n      }\n    }\n    IOUtils.close(toClose);\n    IOUtils.close(primary);\n    IOUtils.close(transLog);\n\n    if (failed.get() == false) {\n      message(\"TEST: top: now checkIndex\");    \n      for(Path path : indexPaths) {\n        message(\"TEST: check \" + path);\n        MockDirectoryWrapper dir = newMockFSDirectory(path);\n        // Just too slow otherwise\n        dir.setCrossCheckTermVectorsOnClose(false);\n        dir.close();\n      }\n    } else {\n      message(\"TEST: failed; skip checkIndex\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c3d0d2e502d016d967c45c0c972ace4d02885e07","date":1454976917,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#test().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    Node.globalStartNS = System.nanoTime();\n\n    message(\"change thread name from \" + Thread.currentThread().getName());\n    Thread.currentThread().setName(\"main\");\n\n    childTempDir = createTempDir(\"child\");\n\n    // We are parent process:\n\n    // Silly bootstrapping:\n    versionToTransLogLocation.put(0L, 0L);\n\n    versionToMarker.put(0L, 0);\n\n    int numNodes;\n\n    if (NUM_NODES == null) {\n      numNodes = TestUtil.nextInt(random(), 2, 10);\n    } else {\n      numNodes = NUM_NODES.intValue();\n    }\n\n    System.out.println(\"TEST: using \" + numNodes + \" nodes\");\n\n    transLogPath = createTempDir(\"NRTReplication\").resolve(\"translog\");\n    transLog = new SimpleTransLog(transLogPath);\n\n    //state.rateLimiters = new RateLimiter[numNodes];\n    indexPaths = new Path[numNodes];\n    nodes = new NodeProcess[numNodes];\n    nodeTimeStamps = new long[numNodes];\n    Arrays.fill(nodeTimeStamps, Node.globalStartNS);\n    starting = new boolean[numNodes];\n    \n    for(int i=0;i<numNodes;i++) {\n      indexPaths[i] = createTempDir(\"index\" + i);\n    }\n\n    Thread[] indexers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + indexers.length + \" indexer threads\");\n    for(int i=0;i<indexers.length;i++) {\n      indexers[i] = new IndexThread();\n      indexers[i].setName(\"indexer\" + i);\n      indexers[i].setDaemon(true);\n      indexers[i].start();\n    }\n\n    Thread[] searchers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + searchers.length + \" searcher threads\");\n    for(int i=0;i<searchers.length;i++) {\n      searchers[i] = new SearchThread();\n      searchers[i].setName(\"searcher\" + i);\n      searchers[i].setDaemon(true);\n      searchers[i].start();\n    }\n\n    Thread restarter = new RestartThread();\n    restarter.setName(\"restarter\");\n    restarter.setDaemon(true);\n    restarter.start();\n\n    int runTimeSec;\n    if (TEST_NIGHTLY) {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 120, 240);\n    } else {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 45, 120);\n    }\n\n    System.out.println(\"TEST: will run for \" + runTimeSec + \" sec\");\n\n    long endTime = System.nanoTime() + runTimeSec*1000000000L;\n\n    sendReplicasToPrimary();\n\n    while (failed.get() == false && System.nanoTime() < endTime) {\n\n      // Wait a bit:\n      Thread.sleep(TestUtil.nextInt(random(), Math.min(runTimeSec*4, 200), runTimeSec*4));\n      if (primary != null && random().nextBoolean()) {\n        NodeProcess curPrimary = primary;\n        if (curPrimary != null) {\n\n          // Save these before we start flush:\n          long nextTransLogLoc = transLog.getNextLocation();\n          int markerUptoSav = markerUpto.get();\n          message(\"top: now flush primary; at least marker count=\" + markerUptoSav);\n\n          long result;\n          try {\n            result = primary.flush(markerUptoSav);\n          } catch (Throwable t) {\n            message(\"top: flush failed; skipping: \" + t.getMessage());\n            result = -1;\n          }\n          if (result > 0) {\n            // There were changes\n            message(\"top: flush finished with changed; new primary version=\" + result);\n            lastPrimaryVersion = result;\n            addTransLogLoc(lastPrimaryVersion, nextTransLogLoc);\n            addVersionMarker(lastPrimaryVersion, markerUptoSav);\n          }\n        }\n      }\n\n      StringBuilder sb = new StringBuilder();\n      int liveCount = 0;\n      for(int i=0;i<nodes.length;i++) {\n        NodeProcess node = nodes[i];\n        if (node != null) {\n          if (sb.length() != 0) {\n            sb.append(\" \");\n          }\n          liveCount++;\n          if (node.isPrimary) {\n            sb.append('P');\n          } else {\n            sb.append('R');\n          }\n          sb.append(i);\n        }\n      }\n\n      message(\"PG=\" + (primary == null ? \"X\" : primaryGen) + \" \" + liveCount + \" (of \" + nodes.length + \") nodes running: \" + sb);\n\n      // Commit a random node, primary or replica\n\n      if (random().nextInt(10) == 1) {\n        NodeProcess node = nodes[random().nextInt(nodes.length)];\n        if (node != null && node.nodeIsClosing.get() == false) {\n          // TODO: if this node is primary, it means we committed an unpublished version (not exposed as an NRT point)... not sure it matters.\n          // maybe we somehow allow IW to commit a specific sis (the one we just flushed)?\n          message(\"top: now commit node=\" + node);\n          try {\n            node.commitAsync();\n          } catch (Throwable t) {\n            message(\"top: hit exception during commit with R\" + node.id + \"; skipping\");\n            t.printStackTrace(System.out);\n          }\n        }\n      }\n    }\n\n    message(\"TEST: top: test done, now close\");\n    stop.set(true);\n    for(Thread thread : indexers) {\n      thread.join();\n    }\n    for(Thread thread : searchers) {\n      thread.join();\n    }\n    restarter.join();\n\n    // Close replicas before primary so we cancel any in-progres replications:\n    System.out.println(\"TEST: top: now close replicas\");\n    List<Closeable> toClose = new ArrayList<>();\n    for(NodeProcess node : nodes) {\n      if (node != primary && node != null) {\n        toClose.add(node);\n      }\n    }\n    IOUtils.close(toClose);\n    IOUtils.close(primary);\n    IOUtils.close(transLog);\n\n    if (failed.get() == false) {\n      message(\"TEST: top: now checkIndex\");    \n      for(Path path : indexPaths) {\n        message(\"TEST: check \" + path);\n        MockDirectoryWrapper dir = newMockFSDirectory(path);\n        // Just too slow otherwise\n        dir.setCrossCheckTermVectorsOnClose(false);\n        dir.close();\n      }\n    } else {\n      message(\"TEST: failed; skip checkIndex\");\n    }\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    Node.globalStartNS = System.nanoTime();\n\n    message(\"change thread name from \" + Thread.currentThread().getName());\n    Thread.currentThread().setName(\"main\");\n\n    childTempDir = createTempDir(\"child\");\n\n    // We are parent process:\n\n    // Silly bootstrapping:\n    versionToTransLogLocation.put(0L, 0L);\n\n    versionToMarker.put(0L, 0);\n\n    int numNodes;\n\n    if (NUM_NODES == null) {\n      numNodes = TestUtil.nextInt(random(), 2, 10);\n    } else {\n      numNodes = NUM_NODES.intValue();\n    }\n\n    System.out.println(\"TEST: using \" + numNodes + \" nodes\");\n\n    transLogPath = createTempDir(\"NRTReplication\").resolve(\"translog\");\n    transLog = new SimpleTransLog(transLogPath);\n\n    //state.rateLimiters = new RateLimiter[numNodes];\n    indexPaths = new Path[numNodes];\n    nodes = new NodeProcess[numNodes];\n    nodeTimeStamps = new long[numNodes];\n    Arrays.fill(nodeTimeStamps, Node.globalStartNS);\n    starting = new boolean[numNodes];\n    \n    for(int i=0;i<numNodes;i++) {\n      indexPaths[i] = createTempDir(\"index\" + i);\n    }\n\n    Thread[] indexers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + indexers.length + \" indexer threads\");\n    for(int i=0;i<indexers.length;i++) {\n      indexers[i] = new IndexThread();\n      indexers[i].setName(\"indexer\" + i);\n      indexers[i].setDaemon(true);\n      indexers[i].start();\n    }\n\n    Thread[] searchers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + searchers.length + \" searcher threads\");\n    for(int i=0;i<searchers.length;i++) {\n      searchers[i] = new SearchThread();\n      searchers[i].setName(\"searcher\" + i);\n      searchers[i].setDaemon(true);\n      searchers[i].start();\n    }\n\n    Thread restarter = new RestartThread();\n    restarter.setName(\"restarter\");\n    restarter.setDaemon(true);\n    restarter.start();\n\n    int runTimeSec;\n    if (TEST_NIGHTLY) {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 120, 240);\n    } else {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 45, 120);\n    }\n\n    System.out.println(\"TEST: will run for \" + runTimeSec + \" sec\");\n\n    long endTime = System.nanoTime() + runTimeSec*1000000000L;\n\n    sendReplicasToPrimary();\n\n    while (failed.get() == false && System.nanoTime() < endTime) {\n\n      // Wait a bit:\n      Thread.sleep(TestUtil.nextInt(random(), Math.min(runTimeSec*4, 200), runTimeSec*4));\n      if (primary != null && random().nextBoolean()) {\n        NodeProcess curPrimary = primary;\n        if (curPrimary != null) {\n\n          // Save these before we start flush:\n          long nextTransLogLoc = transLog.getNextLocation();\n          int markerUptoSav = markerUpto.get();\n          message(\"top: now flush primary; at least marker count=\" + markerUptoSav);\n\n          long result;\n          try {\n            result = primary.flush(markerUptoSav);\n          } catch (Throwable t) {\n            message(\"top: flush failed; skipping: \" + t.getMessage());\n            result = -1;\n          }\n          if (result > 0) {\n            // There were changes\n            message(\"top: flush finished with changed; new primary version=\" + result);\n            lastPrimaryVersion = result;\n            addTransLogLoc(lastPrimaryVersion, nextTransLogLoc);\n            addVersionMarker(lastPrimaryVersion, markerUptoSav);\n          }\n        }\n      }\n\n      StringBuilder sb = new StringBuilder();\n      int liveCount = 0;\n      for(int i=0;i<nodes.length;i++) {\n        NodeProcess node = nodes[i];\n        if (node != null) {\n          if (sb.length() != 0) {\n            sb.append(\" \");\n          }\n          liveCount++;\n          if (node.isPrimary) {\n            sb.append('P');\n          } else {\n            sb.append('R');\n          }\n          sb.append(i);\n        }\n      }\n\n      message(\"PG=\" + (primary == null ? \"X\" : primaryGen) + \" \" + liveCount + \" (of \" + nodes.length + \") nodes running: \" + sb);\n\n      // Commit a random node, primary or replica\n\n      {\n        NodeProcess node = nodes[random().nextInt(nodes.length)];\n        if (node != null && node.nodeIsClosing.get() == false) {\n          // TODO: if this node is primary, it means we committed an unpublished version (not exposed as an NRT point)... not sure it matters.\n          // maybe we somehow allow IW to commit a specific sis (the one we just flushed)?\n          message(\"top: now commit node=\" + node);\n          try {\n            node.commitAsync();\n          } catch (Throwable t) {\n            message(\"top: hit exception during commit with R\" + node.id + \"; skipping\");\n            t.printStackTrace(System.out);\n          }\n        }\n      }\n    }\n\n    message(\"TEST: top: test done, now close\");\n    stop.set(true);\n    for(Thread thread : indexers) {\n      thread.join();\n    }\n    for(Thread thread : searchers) {\n      thread.join();\n    }\n    restarter.join();\n\n    // Close replicas before primary so we cancel any in-progres replications:\n    System.out.println(\"TEST: top: now close replicas\");\n    List<Closeable> toClose = new ArrayList<>();\n    for(NodeProcess node : nodes) {\n      if (node != primary && node != null) {\n        toClose.add(node);\n      }\n    }\n    IOUtils.close(toClose);\n    IOUtils.close(primary);\n    IOUtils.close(transLog);\n\n    if (failed.get() == false) {\n      message(\"TEST: top: now checkIndex\");    \n      for(Path path : indexPaths) {\n        message(\"TEST: check \" + path);\n        MockDirectoryWrapper dir = newMockFSDirectory(path);\n        // Just too slow otherwise\n        dir.setCrossCheckTermVectorsOnClose(false);\n        dir.close();\n      }\n    } else {\n      message(\"TEST: failed; skip checkIndex\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"33b6213064c76adb293e52f03a3eb1528c5b1858","date":1454977105,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#test().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    Node.globalStartNS = System.nanoTime();\n\n    message(\"change thread name from \" + Thread.currentThread().getName());\n    Thread.currentThread().setName(\"main\");\n\n    childTempDir = createTempDir(\"child\");\n\n    // We are parent process:\n\n    // Silly bootstrapping:\n    versionToTransLogLocation.put(0L, 0L);\n\n    versionToMarker.put(0L, 0);\n\n    int numNodes;\n\n    if (NUM_NODES == null) {\n      numNodes = TestUtil.nextInt(random(), 2, 10);\n    } else {\n      numNodes = NUM_NODES.intValue();\n    }\n\n    System.out.println(\"TEST: using \" + numNodes + \" nodes\");\n\n    transLogPath = createTempDir(\"NRTReplication\").resolve(\"translog\");\n    transLog = new SimpleTransLog(transLogPath);\n\n    //state.rateLimiters = new RateLimiter[numNodes];\n    indexPaths = new Path[numNodes];\n    nodes = new NodeProcess[numNodes];\n    nodeTimeStamps = new long[numNodes];\n    Arrays.fill(nodeTimeStamps, Node.globalStartNS);\n    starting = new boolean[numNodes];\n    \n    for(int i=0;i<numNodes;i++) {\n      indexPaths[i] = createTempDir(\"index\" + i);\n    }\n\n    Thread[] indexers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + indexers.length + \" indexer threads\");\n    for(int i=0;i<indexers.length;i++) {\n      indexers[i] = new IndexThread();\n      indexers[i].setName(\"indexer\" + i);\n      indexers[i].setDaemon(true);\n      indexers[i].start();\n    }\n\n    Thread[] searchers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + searchers.length + \" searcher threads\");\n    for(int i=0;i<searchers.length;i++) {\n      searchers[i] = new SearchThread();\n      searchers[i].setName(\"searcher\" + i);\n      searchers[i].setDaemon(true);\n      searchers[i].start();\n    }\n\n    Thread restarter = new RestartThread();\n    restarter.setName(\"restarter\");\n    restarter.setDaemon(true);\n    restarter.start();\n\n    int runTimeSec;\n    if (TEST_NIGHTLY) {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 120, 240);\n    } else {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 45, 120);\n    }\n\n    System.out.println(\"TEST: will run for \" + runTimeSec + \" sec\");\n\n    long endTime = System.nanoTime() + runTimeSec*1000000000L;\n\n    sendReplicasToPrimary();\n\n    while (failed.get() == false && System.nanoTime() < endTime) {\n\n      // Wait a bit:\n      Thread.sleep(TestUtil.nextInt(random(), Math.min(runTimeSec*4, 200), runTimeSec*4));\n      if (primary != null && random().nextBoolean()) {\n        NodeProcess curPrimary = primary;\n        if (curPrimary != null) {\n\n          // Save these before we start flush:\n          long nextTransLogLoc = transLog.getNextLocation();\n          int markerUptoSav = markerUpto.get();\n          message(\"top: now flush primary; at least marker count=\" + markerUptoSav);\n\n          long result;\n          try {\n            result = primary.flush(markerUptoSav);\n          } catch (Throwable t) {\n            message(\"top: flush failed; skipping: \" + t.getMessage());\n            result = -1;\n          }\n          if (result > 0) {\n            // There were changes\n            message(\"top: flush finished with changed; new primary version=\" + result);\n            lastPrimaryVersion = result;\n            addTransLogLoc(lastPrimaryVersion, nextTransLogLoc);\n            addVersionMarker(lastPrimaryVersion, markerUptoSav);\n          }\n        }\n      }\n\n      StringBuilder sb = new StringBuilder();\n      int liveCount = 0;\n      for(int i=0;i<nodes.length;i++) {\n        NodeProcess node = nodes[i];\n        if (node != null) {\n          if (sb.length() != 0) {\n            sb.append(\" \");\n          }\n          liveCount++;\n          if (node.isPrimary) {\n            sb.append('P');\n          } else {\n            sb.append('R');\n          }\n          sb.append(i);\n        }\n      }\n\n      message(\"PG=\" + (primary == null ? \"X\" : primaryGen) + \" \" + liveCount + \" (of \" + nodes.length + \") nodes running: \" + sb);\n\n      // Commit a random node, primary or replica\n\n      if (random().nextInt(10) == 1) {\n        NodeProcess node = nodes[random().nextInt(nodes.length)];\n        if (node != null && node.nodeIsClosing.get() == false) {\n          // TODO: if this node is primary, it means we committed an unpublished version (not exposed as an NRT point)... not sure it matters.\n          // maybe we somehow allow IW to commit a specific sis (the one we just flushed)?\n          message(\"top: now commit node=\" + node);\n          try {\n            node.commitAsync();\n          } catch (Throwable t) {\n            message(\"top: hit exception during commit with R\" + node.id + \"; skipping\");\n            t.printStackTrace(System.out);\n          }\n        }\n      }\n    }\n\n    message(\"TEST: top: test done, now close\");\n    stop.set(true);\n    for(Thread thread : indexers) {\n      thread.join();\n    }\n    for(Thread thread : searchers) {\n      thread.join();\n    }\n    restarter.join();\n\n    // Close replicas before primary so we cancel any in-progres replications:\n    System.out.println(\"TEST: top: now close replicas\");\n    List<Closeable> toClose = new ArrayList<>();\n    for(NodeProcess node : nodes) {\n      if (node != primary && node != null) {\n        toClose.add(node);\n      }\n    }\n    IOUtils.close(toClose);\n    IOUtils.close(primary);\n    IOUtils.close(transLog);\n\n    if (failed.get() == false) {\n      message(\"TEST: top: now checkIndex\");    \n      for(Path path : indexPaths) {\n        message(\"TEST: check \" + path);\n        MockDirectoryWrapper dir = newMockFSDirectory(path);\n        // Just too slow otherwise\n        dir.setCrossCheckTermVectorsOnClose(false);\n        dir.close();\n      }\n    } else {\n      message(\"TEST: failed; skip checkIndex\");\n    }\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    Node.globalStartNS = System.nanoTime();\n\n    message(\"change thread name from \" + Thread.currentThread().getName());\n    Thread.currentThread().setName(\"main\");\n\n    childTempDir = createTempDir(\"child\");\n\n    // We are parent process:\n\n    // Silly bootstrapping:\n    versionToTransLogLocation.put(0L, 0L);\n\n    versionToMarker.put(0L, 0);\n\n    int numNodes;\n\n    if (NUM_NODES == null) {\n      numNodes = TestUtil.nextInt(random(), 2, 10);\n    } else {\n      numNodes = NUM_NODES.intValue();\n    }\n\n    System.out.println(\"TEST: using \" + numNodes + \" nodes\");\n\n    transLogPath = createTempDir(\"NRTReplication\").resolve(\"translog\");\n    transLog = new SimpleTransLog(transLogPath);\n\n    //state.rateLimiters = new RateLimiter[numNodes];\n    indexPaths = new Path[numNodes];\n    nodes = new NodeProcess[numNodes];\n    nodeTimeStamps = new long[numNodes];\n    Arrays.fill(nodeTimeStamps, Node.globalStartNS);\n    starting = new boolean[numNodes];\n    \n    for(int i=0;i<numNodes;i++) {\n      indexPaths[i] = createTempDir(\"index\" + i);\n    }\n\n    Thread[] indexers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + indexers.length + \" indexer threads\");\n    for(int i=0;i<indexers.length;i++) {\n      indexers[i] = new IndexThread();\n      indexers[i].setName(\"indexer\" + i);\n      indexers[i].setDaemon(true);\n      indexers[i].start();\n    }\n\n    Thread[] searchers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + searchers.length + \" searcher threads\");\n    for(int i=0;i<searchers.length;i++) {\n      searchers[i] = new SearchThread();\n      searchers[i].setName(\"searcher\" + i);\n      searchers[i].setDaemon(true);\n      searchers[i].start();\n    }\n\n    Thread restarter = new RestartThread();\n    restarter.setName(\"restarter\");\n    restarter.setDaemon(true);\n    restarter.start();\n\n    int runTimeSec;\n    if (TEST_NIGHTLY) {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 120, 240);\n    } else {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 45, 120);\n    }\n\n    System.out.println(\"TEST: will run for \" + runTimeSec + \" sec\");\n\n    long endTime = System.nanoTime() + runTimeSec*1000000000L;\n\n    sendReplicasToPrimary();\n\n    while (failed.get() == false && System.nanoTime() < endTime) {\n\n      // Wait a bit:\n      Thread.sleep(TestUtil.nextInt(random(), Math.min(runTimeSec*4, 200), runTimeSec*4));\n      if (primary != null && random().nextBoolean()) {\n        NodeProcess curPrimary = primary;\n        if (curPrimary != null) {\n\n          // Save these before we start flush:\n          long nextTransLogLoc = transLog.getNextLocation();\n          int markerUptoSav = markerUpto.get();\n          message(\"top: now flush primary; at least marker count=\" + markerUptoSav);\n\n          long result;\n          try {\n            result = primary.flush(markerUptoSav);\n          } catch (Throwable t) {\n            message(\"top: flush failed; skipping: \" + t.getMessage());\n            result = -1;\n          }\n          if (result > 0) {\n            // There were changes\n            message(\"top: flush finished with changed; new primary version=\" + result);\n            lastPrimaryVersion = result;\n            addTransLogLoc(lastPrimaryVersion, nextTransLogLoc);\n            addVersionMarker(lastPrimaryVersion, markerUptoSav);\n          }\n        }\n      }\n\n      StringBuilder sb = new StringBuilder();\n      int liveCount = 0;\n      for(int i=0;i<nodes.length;i++) {\n        NodeProcess node = nodes[i];\n        if (node != null) {\n          if (sb.length() != 0) {\n            sb.append(\" \");\n          }\n          liveCount++;\n          if (node.isPrimary) {\n            sb.append('P');\n          } else {\n            sb.append('R');\n          }\n          sb.append(i);\n        }\n      }\n\n      message(\"PG=\" + (primary == null ? \"X\" : primaryGen) + \" \" + liveCount + \" (of \" + nodes.length + \") nodes running: \" + sb);\n\n      // Commit a random node, primary or replica\n\n      {\n        NodeProcess node = nodes[random().nextInt(nodes.length)];\n        if (node != null && node.nodeIsClosing.get() == false) {\n          // TODO: if this node is primary, it means we committed an unpublished version (not exposed as an NRT point)... not sure it matters.\n          // maybe we somehow allow IW to commit a specific sis (the one we just flushed)?\n          message(\"top: now commit node=\" + node);\n          try {\n            node.commitAsync();\n          } catch (Throwable t) {\n            message(\"top: hit exception during commit with R\" + node.id + \"; skipping\");\n            t.printStackTrace(System.out);\n          }\n        }\n      }\n    }\n\n    message(\"TEST: top: test done, now close\");\n    stop.set(true);\n    for(Thread thread : indexers) {\n      thread.join();\n    }\n    for(Thread thread : searchers) {\n      thread.join();\n    }\n    restarter.join();\n\n    // Close replicas before primary so we cancel any in-progres replications:\n    System.out.println(\"TEST: top: now close replicas\");\n    List<Closeable> toClose = new ArrayList<>();\n    for(NodeProcess node : nodes) {\n      if (node != primary && node != null) {\n        toClose.add(node);\n      }\n    }\n    IOUtils.close(toClose);\n    IOUtils.close(primary);\n    IOUtils.close(transLog);\n\n    if (failed.get() == false) {\n      message(\"TEST: top: now checkIndex\");    \n      for(Path path : indexPaths) {\n        message(\"TEST: check \" + path);\n        MockDirectoryWrapper dir = newMockFSDirectory(path);\n        // Just too slow otherwise\n        dir.setCrossCheckTermVectorsOnClose(false);\n        dir.close();\n      }\n    } else {\n      message(\"TEST: failed; skip checkIndex\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2b844e2ae5435a8d4d925003c10027c25e26e02d","date":1455044345,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#test().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#test().mjava","sourceNew":"  @Nightly\n  public void test() throws Exception {\n\n    Node.globalStartNS = System.nanoTime();\n\n    message(\"change thread name from \" + Thread.currentThread().getName());\n    Thread.currentThread().setName(\"main\");\n\n    childTempDir = createTempDir(\"child\");\n\n    // We are parent process:\n\n    // Silly bootstrapping:\n    versionToTransLogLocation.put(0L, 0L);\n\n    versionToMarker.put(0L, 0);\n\n    int numNodes;\n\n    if (NUM_NODES == null) {\n      numNodes = TestUtil.nextInt(random(), 2, 10);\n    } else {\n      numNodes = NUM_NODES.intValue();\n    }\n\n    System.out.println(\"TEST: using \" + numNodes + \" nodes\");\n\n    transLogPath = createTempDir(\"NRTReplication\").resolve(\"translog\");\n    transLog = new SimpleTransLog(transLogPath);\n\n    //state.rateLimiters = new RateLimiter[numNodes];\n    indexPaths = new Path[numNodes];\n    nodes = new NodeProcess[numNodes];\n    nodeTimeStamps = new long[numNodes];\n    Arrays.fill(nodeTimeStamps, Node.globalStartNS);\n    starting = new boolean[numNodes];\n    \n    for(int i=0;i<numNodes;i++) {\n      indexPaths[i] = createTempDir(\"index\" + i);\n    }\n\n    Thread[] indexers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + indexers.length + \" indexer threads\");\n    for(int i=0;i<indexers.length;i++) {\n      indexers[i] = new IndexThread();\n      indexers[i].setName(\"indexer\" + i);\n      indexers[i].setDaemon(true);\n      indexers[i].start();\n    }\n\n    Thread[] searchers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + searchers.length + \" searcher threads\");\n    for(int i=0;i<searchers.length;i++) {\n      searchers[i] = new SearchThread();\n      searchers[i].setName(\"searcher\" + i);\n      searchers[i].setDaemon(true);\n      searchers[i].start();\n    }\n\n    Thread restarter = new RestartThread();\n    restarter.setName(\"restarter\");\n    restarter.setDaemon(true);\n    restarter.start();\n\n    int runTimeSec;\n    if (TEST_NIGHTLY) {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 120, 240);\n    } else {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 45, 120);\n    }\n\n    System.out.println(\"TEST: will run for \" + runTimeSec + \" sec\");\n\n    long endTime = System.nanoTime() + runTimeSec*1000000000L;\n\n    sendReplicasToPrimary();\n\n    while (failed.get() == false && System.nanoTime() < endTime) {\n\n      // Wait a bit:\n      Thread.sleep(TestUtil.nextInt(random(), Math.min(runTimeSec*4, 200), runTimeSec*4));\n      if (primary != null && random().nextBoolean()) {\n        NodeProcess curPrimary = primary;\n        if (curPrimary != null) {\n\n          // Save these before we start flush:\n          long nextTransLogLoc = transLog.getNextLocation();\n          int markerUptoSav = markerUpto.get();\n          message(\"top: now flush primary; at least marker count=\" + markerUptoSav);\n\n          long result;\n          try {\n            result = primary.flush(markerUptoSav);\n          } catch (Throwable t) {\n            message(\"top: flush failed; skipping: \" + t.getMessage());\n            result = -1;\n          }\n          if (result > 0) {\n            // There were changes\n            message(\"top: flush finished with changed; new primary version=\" + result);\n            lastPrimaryVersion = result;\n            addTransLogLoc(lastPrimaryVersion, nextTransLogLoc);\n            addVersionMarker(lastPrimaryVersion, markerUptoSav);\n          }\n        }\n      }\n\n      StringBuilder sb = new StringBuilder();\n      int liveCount = 0;\n      for(int i=0;i<nodes.length;i++) {\n        NodeProcess node = nodes[i];\n        if (node != null) {\n          if (sb.length() != 0) {\n            sb.append(\" \");\n          }\n          liveCount++;\n          if (node.isPrimary) {\n            sb.append('P');\n          } else {\n            sb.append('R');\n          }\n          sb.append(i);\n        }\n      }\n\n      message(\"PG=\" + (primary == null ? \"X\" : primaryGen) + \" \" + liveCount + \" (of \" + nodes.length + \") nodes running: \" + sb);\n\n      // Commit a random node, primary or replica\n\n      if (random().nextInt(10) == 1) {\n        NodeProcess node = nodes[random().nextInt(nodes.length)];\n        if (node != null && node.nodeIsClosing.get() == false) {\n          // TODO: if this node is primary, it means we committed an unpublished version (not exposed as an NRT point)... not sure it matters.\n          // maybe we somehow allow IW to commit a specific sis (the one we just flushed)?\n          message(\"top: now commit node=\" + node);\n          try {\n            node.commitAsync();\n          } catch (Throwable t) {\n            message(\"top: hit exception during commit with R\" + node.id + \"; skipping\");\n            t.printStackTrace(System.out);\n          }\n        }\n      }\n    }\n\n    message(\"TEST: top: test done, now close\");\n    stop.set(true);\n    for(Thread thread : indexers) {\n      thread.join();\n    }\n    for(Thread thread : searchers) {\n      thread.join();\n    }\n    restarter.join();\n\n    // Close replicas before primary so we cancel any in-progres replications:\n    System.out.println(\"TEST: top: now close replicas\");\n    List<Closeable> toClose = new ArrayList<>();\n    for(NodeProcess node : nodes) {\n      if (node != primary && node != null) {\n        toClose.add(node);\n      }\n    }\n    IOUtils.close(toClose);\n    IOUtils.close(primary);\n    IOUtils.close(transLog);\n\n    if (failed.get() == false) {\n      message(\"TEST: top: now checkIndex\");    \n      for(Path path : indexPaths) {\n        message(\"TEST: check \" + path);\n        MockDirectoryWrapper dir = newMockFSDirectory(path);\n        // Just too slow otherwise\n        dir.setCrossCheckTermVectorsOnClose(false);\n        dir.close();\n      }\n    } else {\n      message(\"TEST: failed; skip checkIndex\");\n    }\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    Node.globalStartNS = System.nanoTime();\n\n    message(\"change thread name from \" + Thread.currentThread().getName());\n    Thread.currentThread().setName(\"main\");\n\n    childTempDir = createTempDir(\"child\");\n\n    // We are parent process:\n\n    // Silly bootstrapping:\n    versionToTransLogLocation.put(0L, 0L);\n\n    versionToMarker.put(0L, 0);\n\n    int numNodes;\n\n    if (NUM_NODES == null) {\n      numNodes = TestUtil.nextInt(random(), 2, 10);\n    } else {\n      numNodes = NUM_NODES.intValue();\n    }\n\n    System.out.println(\"TEST: using \" + numNodes + \" nodes\");\n\n    transLogPath = createTempDir(\"NRTReplication\").resolve(\"translog\");\n    transLog = new SimpleTransLog(transLogPath);\n\n    //state.rateLimiters = new RateLimiter[numNodes];\n    indexPaths = new Path[numNodes];\n    nodes = new NodeProcess[numNodes];\n    nodeTimeStamps = new long[numNodes];\n    Arrays.fill(nodeTimeStamps, Node.globalStartNS);\n    starting = new boolean[numNodes];\n    \n    for(int i=0;i<numNodes;i++) {\n      indexPaths[i] = createTempDir(\"index\" + i);\n    }\n\n    Thread[] indexers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + indexers.length + \" indexer threads\");\n    for(int i=0;i<indexers.length;i++) {\n      indexers[i] = new IndexThread();\n      indexers[i].setName(\"indexer\" + i);\n      indexers[i].setDaemon(true);\n      indexers[i].start();\n    }\n\n    Thread[] searchers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + searchers.length + \" searcher threads\");\n    for(int i=0;i<searchers.length;i++) {\n      searchers[i] = new SearchThread();\n      searchers[i].setName(\"searcher\" + i);\n      searchers[i].setDaemon(true);\n      searchers[i].start();\n    }\n\n    Thread restarter = new RestartThread();\n    restarter.setName(\"restarter\");\n    restarter.setDaemon(true);\n    restarter.start();\n\n    int runTimeSec;\n    if (TEST_NIGHTLY) {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 120, 240);\n    } else {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 45, 120);\n    }\n\n    System.out.println(\"TEST: will run for \" + runTimeSec + \" sec\");\n\n    long endTime = System.nanoTime() + runTimeSec*1000000000L;\n\n    sendReplicasToPrimary();\n\n    while (failed.get() == false && System.nanoTime() < endTime) {\n\n      // Wait a bit:\n      Thread.sleep(TestUtil.nextInt(random(), Math.min(runTimeSec*4, 200), runTimeSec*4));\n      if (primary != null && random().nextBoolean()) {\n        NodeProcess curPrimary = primary;\n        if (curPrimary != null) {\n\n          // Save these before we start flush:\n          long nextTransLogLoc = transLog.getNextLocation();\n          int markerUptoSav = markerUpto.get();\n          message(\"top: now flush primary; at least marker count=\" + markerUptoSav);\n\n          long result;\n          try {\n            result = primary.flush(markerUptoSav);\n          } catch (Throwable t) {\n            message(\"top: flush failed; skipping: \" + t.getMessage());\n            result = -1;\n          }\n          if (result > 0) {\n            // There were changes\n            message(\"top: flush finished with changed; new primary version=\" + result);\n            lastPrimaryVersion = result;\n            addTransLogLoc(lastPrimaryVersion, nextTransLogLoc);\n            addVersionMarker(lastPrimaryVersion, markerUptoSav);\n          }\n        }\n      }\n\n      StringBuilder sb = new StringBuilder();\n      int liveCount = 0;\n      for(int i=0;i<nodes.length;i++) {\n        NodeProcess node = nodes[i];\n        if (node != null) {\n          if (sb.length() != 0) {\n            sb.append(\" \");\n          }\n          liveCount++;\n          if (node.isPrimary) {\n            sb.append('P');\n          } else {\n            sb.append('R');\n          }\n          sb.append(i);\n        }\n      }\n\n      message(\"PG=\" + (primary == null ? \"X\" : primaryGen) + \" \" + liveCount + \" (of \" + nodes.length + \") nodes running: \" + sb);\n\n      // Commit a random node, primary or replica\n\n      if (random().nextInt(10) == 1) {\n        NodeProcess node = nodes[random().nextInt(nodes.length)];\n        if (node != null && node.nodeIsClosing.get() == false) {\n          // TODO: if this node is primary, it means we committed an unpublished version (not exposed as an NRT point)... not sure it matters.\n          // maybe we somehow allow IW to commit a specific sis (the one we just flushed)?\n          message(\"top: now commit node=\" + node);\n          try {\n            node.commitAsync();\n          } catch (Throwable t) {\n            message(\"top: hit exception during commit with R\" + node.id + \"; skipping\");\n            t.printStackTrace(System.out);\n          }\n        }\n      }\n    }\n\n    message(\"TEST: top: test done, now close\");\n    stop.set(true);\n    for(Thread thread : indexers) {\n      thread.join();\n    }\n    for(Thread thread : searchers) {\n      thread.join();\n    }\n    restarter.join();\n\n    // Close replicas before primary so we cancel any in-progres replications:\n    System.out.println(\"TEST: top: now close replicas\");\n    List<Closeable> toClose = new ArrayList<>();\n    for(NodeProcess node : nodes) {\n      if (node != primary && node != null) {\n        toClose.add(node);\n      }\n    }\n    IOUtils.close(toClose);\n    IOUtils.close(primary);\n    IOUtils.close(transLog);\n\n    if (failed.get() == false) {\n      message(\"TEST: top: now checkIndex\");    \n      for(Path path : indexPaths) {\n        message(\"TEST: check \" + path);\n        MockDirectoryWrapper dir = newMockFSDirectory(path);\n        // Just too slow otherwise\n        dir.setCrossCheckTermVectorsOnClose(false);\n        dir.close();\n      }\n    } else {\n      message(\"TEST: failed; skip checkIndex\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#test().mjava","pathOld":"/dev/null","sourceNew":"  @Nightly\n  public void test() throws Exception {\n\n    Node.globalStartNS = System.nanoTime();\n\n    message(\"change thread name from \" + Thread.currentThread().getName());\n    Thread.currentThread().setName(\"main\");\n\n    childTempDir = createTempDir(\"child\");\n\n    // We are parent process:\n\n    // Silly bootstrapping:\n    versionToTransLogLocation.put(0L, 0L);\n\n    versionToMarker.put(0L, 0);\n\n    int numNodes;\n\n    if (NUM_NODES == null) {\n      numNodes = TestUtil.nextInt(random(), 2, 10);\n    } else {\n      numNodes = NUM_NODES.intValue();\n    }\n\n    System.out.println(\"TEST: using \" + numNodes + \" nodes\");\n\n    transLogPath = createTempDir(\"NRTReplication\").resolve(\"translog\");\n    transLog = new SimpleTransLog(transLogPath);\n\n    //state.rateLimiters = new RateLimiter[numNodes];\n    indexPaths = new Path[numNodes];\n    nodes = new NodeProcess[numNodes];\n    nodeTimeStamps = new long[numNodes];\n    Arrays.fill(nodeTimeStamps, Node.globalStartNS);\n    starting = new boolean[numNodes];\n    \n    for(int i=0;i<numNodes;i++) {\n      indexPaths[i] = createTempDir(\"index\" + i);\n    }\n\n    Thread[] indexers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + indexers.length + \" indexer threads\");\n    for(int i=0;i<indexers.length;i++) {\n      indexers[i] = new IndexThread();\n      indexers[i].setName(\"indexer\" + i);\n      indexers[i].setDaemon(true);\n      indexers[i].start();\n    }\n\n    Thread[] searchers = new Thread[TestUtil.nextInt(random(), 1, 3)];\n    System.out.println(\"TEST: launch \" + searchers.length + \" searcher threads\");\n    for(int i=0;i<searchers.length;i++) {\n      searchers[i] = new SearchThread();\n      searchers[i].setName(\"searcher\" + i);\n      searchers[i].setDaemon(true);\n      searchers[i].start();\n    }\n\n    Thread restarter = new RestartThread();\n    restarter.setName(\"restarter\");\n    restarter.setDaemon(true);\n    restarter.start();\n\n    int runTimeSec;\n    if (TEST_NIGHTLY) {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 120, 240);\n    } else {\n      runTimeSec = RANDOM_MULTIPLIER * TestUtil.nextInt(random(), 45, 120);\n    }\n\n    System.out.println(\"TEST: will run for \" + runTimeSec + \" sec\");\n\n    long endTime = System.nanoTime() + runTimeSec*1000000000L;\n\n    sendReplicasToPrimary();\n\n    while (failed.get() == false && System.nanoTime() < endTime) {\n\n      // Wait a bit:\n      Thread.sleep(TestUtil.nextInt(random(), Math.min(runTimeSec*4, 200), runTimeSec*4));\n      if (primary != null && random().nextBoolean()) {\n        NodeProcess curPrimary = primary;\n        if (curPrimary != null) {\n\n          // Save these before we start flush:\n          long nextTransLogLoc = transLog.getNextLocation();\n          int markerUptoSav = markerUpto.get();\n          message(\"top: now flush primary; at least marker count=\" + markerUptoSav);\n\n          long result;\n          try {\n            result = primary.flush(markerUptoSav);\n          } catch (Throwable t) {\n            message(\"top: flush failed; skipping: \" + t.getMessage());\n            result = -1;\n          }\n          if (result > 0) {\n            // There were changes\n            message(\"top: flush finished with changed; new primary version=\" + result);\n            lastPrimaryVersion = result;\n            addTransLogLoc(lastPrimaryVersion, nextTransLogLoc);\n            addVersionMarker(lastPrimaryVersion, markerUptoSav);\n          }\n        }\n      }\n\n      StringBuilder sb = new StringBuilder();\n      int liveCount = 0;\n      for(int i=0;i<nodes.length;i++) {\n        NodeProcess node = nodes[i];\n        if (node != null) {\n          if (sb.length() != 0) {\n            sb.append(\" \");\n          }\n          liveCount++;\n          if (node.isPrimary) {\n            sb.append('P');\n          } else {\n            sb.append('R');\n          }\n          sb.append(i);\n        }\n      }\n\n      message(\"PG=\" + (primary == null ? \"X\" : primaryGen) + \" \" + liveCount + \" (of \" + nodes.length + \") nodes running: \" + sb);\n\n      // Commit a random node, primary or replica\n\n      if (random().nextInt(10) == 1) {\n        NodeProcess node = nodes[random().nextInt(nodes.length)];\n        if (node != null && node.nodeIsClosing.get() == false) {\n          // TODO: if this node is primary, it means we committed an unpublished version (not exposed as an NRT point)... not sure it matters.\n          // maybe we somehow allow IW to commit a specific sis (the one we just flushed)?\n          message(\"top: now commit node=\" + node);\n          try {\n            node.commitAsync();\n          } catch (Throwable t) {\n            message(\"top: hit exception during commit with R\" + node.id + \"; skipping\");\n            t.printStackTrace(System.out);\n          }\n        }\n      }\n    }\n\n    message(\"TEST: top: test done, now close\");\n    stop.set(true);\n    for(Thread thread : indexers) {\n      thread.join();\n    }\n    for(Thread thread : searchers) {\n      thread.join();\n    }\n    restarter.join();\n\n    // Close replicas before primary so we cancel any in-progres replications:\n    System.out.println(\"TEST: top: now close replicas\");\n    List<Closeable> toClose = new ArrayList<>();\n    for(NodeProcess node : nodes) {\n      if (node != primary && node != null) {\n        toClose.add(node);\n      }\n    }\n    IOUtils.close(toClose);\n    IOUtils.close(primary);\n    IOUtils.close(transLog);\n\n    if (failed.get() == false) {\n      message(\"TEST: top: now checkIndex\");    \n      for(Path path : indexPaths) {\n        message(\"TEST: check \" + path);\n        MockDirectoryWrapper dir = newMockFSDirectory(path);\n        // Just too slow otherwise\n        dir.setCrossCheckTermVectorsOnClose(false);\n        dir.close();\n      }\n    } else {\n      message(\"TEST: failed; skip checkIndex\");\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1b0febf62c2d9baeee7db38998d9197700ccbab9":["ec317d5d3de749e12abcc9e6f976d765638fe9e2","13ea66b549e25413e4e3057bf3492ab828899110"],"2b844e2ae5435a8d4d925003c10027c25e26e02d":["33b6213064c76adb293e52f03a3eb1528c5b1858"],"ec317d5d3de749e12abcc9e6f976d765638fe9e2":["1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9"],"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c3d0d2e502d016d967c45c0c972ace4d02885e07":["1b0febf62c2d9baeee7db38998d9197700ccbab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"68496c2200e559fb7802f7575427b7a482659afb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2b844e2ae5435a8d4d925003c10027c25e26e02d"],"33b6213064c76adb293e52f03a3eb1528c5b1858":["13ea66b549e25413e4e3057bf3492ab828899110","c3d0d2e502d016d967c45c0c972ace4d02885e07"],"13ea66b549e25413e4e3057bf3492ab828899110":["ec317d5d3de749e12abcc9e6f976d765638fe9e2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["68496c2200e559fb7802f7575427b7a482659afb"]},"commit2Childs":{"1b0febf62c2d9baeee7db38998d9197700ccbab9":["c3d0d2e502d016d967c45c0c972ace4d02885e07"],"2b844e2ae5435a8d4d925003c10027c25e26e02d":["68496c2200e559fb7802f7575427b7a482659afb"],"ec317d5d3de749e12abcc9e6f976d765638fe9e2":["1b0febf62c2d9baeee7db38998d9197700ccbab9","13ea66b549e25413e4e3057bf3492ab828899110"],"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9":["ec317d5d3de749e12abcc9e6f976d765638fe9e2"],"c3d0d2e502d016d967c45c0c972ace4d02885e07":["33b6213064c76adb293e52f03a3eb1528c5b1858"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9","68496c2200e559fb7802f7575427b7a482659afb"],"33b6213064c76adb293e52f03a3eb1528c5b1858":["2b844e2ae5435a8d4d925003c10027c25e26e02d"],"68496c2200e559fb7802f7575427b7a482659afb":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"13ea66b549e25413e4e3057bf3492ab828899110":["1b0febf62c2d9baeee7db38998d9197700ccbab9","33b6213064c76adb293e52f03a3eb1528c5b1858"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}