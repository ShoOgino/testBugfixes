{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#returnSession(SessionWrapper).mjava","commits":[{"id":"d907c28c7fe6305eaec1756d51365f5149e1e41d","date":1512533044,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#returnSession(SessionWrapper).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Computing is over for this session and it may contain a new session with new state\n     * The session can be used by others while the caller is performing operations\n     *\n     */\n    private void returnSession(SessionWrapper sessionWrapper) {\n      synchronized (lockObj) {\n        sessionWrapper.status = Status.EXECUTING;\n        log.info(\"returnSession, curr-time {} sessionWrapper.createTime {}, this.sessionWrapper.createTime {} \", time(MILLISECONDS),\n            sessionWrapper.createTime,\n            this.sessionWrapper.createTime);\n        if (sessionWrapper.createTime == this.sessionWrapper.createTime) {\n          //this session was used for computing new operations and this can now be used for other\n          // computing\n          this.sessionWrapper = sessionWrapper;\n\n          //one thread who is waiting for this need to be notified.\n          lockObj.notify();\n        } else {\n          log.info(\"create time NOT SAME {} \", SessionWrapper.DEF_INST.createTime);\n          //else just ignore it\n        }\n      }\n\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","date":1513252583,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#returnSession(SessionWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#returnSession(SessionWrapper).mjava","sourceNew":"    /**\n     * Computing is over for this session and it may contain a new session with new state\n     * The session can be used by others while the caller is performing operations\n     *\n     */\n    private void returnSession(SessionWrapper sessionWrapper) {\n      TimeSource timeSource = sessionWrapper.session.cloudManager.getTimeSource();\n      synchronized (lockObj) {\n        sessionWrapper.status = Status.EXECUTING;\n        log.info(\"returnSession, curr-time {} sessionWrapper.createTime {}, this.sessionWrapper.createTime {} \", time(timeSource, MILLISECONDS),\n            sessionWrapper.createTime,\n            this.sessionWrapper.createTime);\n        if (sessionWrapper.createTime == this.sessionWrapper.createTime) {\n          //this session was used for computing new operations and this can now be used for other\n          // computing\n          this.sessionWrapper = sessionWrapper;\n\n          //one thread who is waiting for this need to be notified.\n          lockObj.notify();\n        } else {\n          log.info(\"create time NOT SAME {} \", SessionWrapper.DEF_INST.createTime);\n          //else just ignore it\n        }\n      }\n\n    }\n\n","sourceOld":"    /**\n     * Computing is over for this session and it may contain a new session with new state\n     * The session can be used by others while the caller is performing operations\n     *\n     */\n    private void returnSession(SessionWrapper sessionWrapper) {\n      synchronized (lockObj) {\n        sessionWrapper.status = Status.EXECUTING;\n        log.info(\"returnSession, curr-time {} sessionWrapper.createTime {}, this.sessionWrapper.createTime {} \", time(MILLISECONDS),\n            sessionWrapper.createTime,\n            this.sessionWrapper.createTime);\n        if (sessionWrapper.createTime == this.sessionWrapper.createTime) {\n          //this session was used for computing new operations and this can now be used for other\n          // computing\n          this.sessionWrapper = sessionWrapper;\n\n          //one thread who is waiting for this need to be notified.\n          lockObj.notify();\n        } else {\n          log.info(\"create time NOT SAME {} \", SessionWrapper.DEF_INST.createTime);\n          //else just ignore it\n        }\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9ccfe45460d496c5e5e1b70396521dac842d966","date":1516798975,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#returnSession(SessionWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#returnSession(SessionWrapper).mjava","sourceNew":"    /**\n     * Computing is over for this session and it may contain a new session with new state\n     * The session can be used by others while the caller is performing operations\n     *\n     */\n    private void returnSession(SessionWrapper sessionWrapper) {\n      TimeSource timeSource = sessionWrapper.session != null ? sessionWrapper.session.cloudManager.getTimeSource() : TimeSource.NANO_TIME;\n      synchronized (lockObj) {\n        sessionWrapper.status = Status.EXECUTING;\n        log.info(\"returnSession, curr-time {} sessionWrapper.createTime {}, this.sessionWrapper.createTime {} \", time(timeSource, MILLISECONDS),\n            sessionWrapper.createTime,\n            this.sessionWrapper.createTime);\n        if (sessionWrapper.createTime == this.sessionWrapper.createTime) {\n          //this session was used for computing new operations and this can now be used for other\n          // computing\n          this.sessionWrapper = sessionWrapper;\n\n          //one thread who is waiting for this need to be notified.\n          lockObj.notify();\n        } else {\n          log.info(\"create time NOT SAME {} \", SessionWrapper.DEF_INST.createTime);\n          //else just ignore it\n        }\n      }\n\n    }\n\n","sourceOld":"    /**\n     * Computing is over for this session and it may contain a new session with new state\n     * The session can be used by others while the caller is performing operations\n     *\n     */\n    private void returnSession(SessionWrapper sessionWrapper) {\n      TimeSource timeSource = sessionWrapper.session.cloudManager.getTimeSource();\n      synchronized (lockObj) {\n        sessionWrapper.status = Status.EXECUTING;\n        log.info(\"returnSession, curr-time {} sessionWrapper.createTime {}, this.sessionWrapper.createTime {} \", time(timeSource, MILLISECONDS),\n            sessionWrapper.createTime,\n            this.sessionWrapper.createTime);\n        if (sessionWrapper.createTime == this.sessionWrapper.createTime) {\n          //this session was used for computing new operations and this can now be used for other\n          // computing\n          this.sessionWrapper = sessionWrapper;\n\n          //one thread who is waiting for this need to be notified.\n          lockObj.notify();\n        } else {\n          log.info(\"create time NOT SAME {} \", SessionWrapper.DEF_INST.createTime);\n          //else just ignore it\n        }\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43a787a75ad72a9bf26e8ff714d8b6d01f9eb441","date":1516881857,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#returnSession(SessionWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#returnSession(SessionWrapper).mjava","sourceNew":"    /**\n     * Computing is over for this session and it may contain a new session with new state\n     * The session can be used by others while the caller is performing operations\n     *\n     */\n    private void returnSession(SessionWrapper sessionWrapper) {\n      TimeSource timeSource = sessionWrapper.session != null ? sessionWrapper.session.cloudManager.getTimeSource() : TimeSource.NANO_TIME;\n      synchronized (lockObj) {\n        sessionWrapper.status = Status.EXECUTING;\n        log.info(\"returnSession, curr-time {} sessionWrapper.createTime {}, this.sessionWrapper.createTime {} \", time(timeSource, MILLISECONDS),\n            sessionWrapper.createTime,\n            this.sessionWrapper.createTime);\n        if (sessionWrapper.createTime == this.sessionWrapper.createTime) {\n          //this session was used for computing new operations and this can now be used for other\n          // computing\n          this.sessionWrapper = sessionWrapper;\n\n          //one thread who is waiting for this need to be notified.\n          lockObj.notify();\n        } else {\n          log.info(\"create time NOT SAME {} \", SessionWrapper.DEF_INST.createTime);\n          //else just ignore it\n        }\n      }\n\n    }\n\n","sourceOld":"    /**\n     * Computing is over for this session and it may contain a new session with new state\n     * The session can be used by others while the caller is performing operations\n     *\n     */\n    private void returnSession(SessionWrapper sessionWrapper) {\n      TimeSource timeSource = sessionWrapper.session.cloudManager.getTimeSource();\n      synchronized (lockObj) {\n        sessionWrapper.status = Status.EXECUTING;\n        log.info(\"returnSession, curr-time {} sessionWrapper.createTime {}, this.sessionWrapper.createTime {} \", time(timeSource, MILLISECONDS),\n            sessionWrapper.createTime,\n            this.sessionWrapper.createTime);\n        if (sessionWrapper.createTime == this.sessionWrapper.createTime) {\n          //this session was used for computing new operations and this can now be used for other\n          // computing\n          this.sessionWrapper = sessionWrapper;\n\n          //one thread who is waiting for this need to be notified.\n          lockObj.notify();\n        } else {\n          log.info(\"create time NOT SAME {} \", SessionWrapper.DEF_INST.createTime);\n          //else just ignore it\n        }\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"27639bb5e041490ce599065875dd2f6d8beef62a","date":1532829373,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#returnSession(SessionWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#returnSession(SessionWrapper).mjava","sourceNew":"    /**\n     * Computing is over for this session and it may contain a new session with new state\n     * The session can be used by others while the caller is performing operations\n     *\n     */\n    private void returnSession(SessionWrapper sessionWrapper) {\n      TimeSource timeSource = sessionWrapper.session != null ? sessionWrapper.session.cloudManager.getTimeSource() : TimeSource.NANO_TIME;\n      synchronized (lockObj) {\n        sessionWrapper.status = Status.EXECUTING;\n        log.info(\"returnSession, curr-time {} sessionWrapper.createTime {}, this.sessionWrapper.createTime {} \", time(timeSource, MILLISECONDS),\n            sessionWrapper.createTime,\n            this.sessionWrapper.createTime);\n        if (sessionWrapper.createTime == this.sessionWrapper.createTime) {\n          //this session was used for computing new operations and this can now be used for other\n          // computing\n          this.sessionWrapper = sessionWrapper;\n\n          //one thread who is waiting for this need to be notified.\n          lockObj.notify();\n        } else {\n          log.info(\"create time NOT SAME {} \", SessionWrapper.DEFAULT_INSTANCE.createTime);\n          //else just ignore it\n        }\n      }\n\n    }\n\n","sourceOld":"    /**\n     * Computing is over for this session and it may contain a new session with new state\n     * The session can be used by others while the caller is performing operations\n     *\n     */\n    private void returnSession(SessionWrapper sessionWrapper) {\n      TimeSource timeSource = sessionWrapper.session != null ? sessionWrapper.session.cloudManager.getTimeSource() : TimeSource.NANO_TIME;\n      synchronized (lockObj) {\n        sessionWrapper.status = Status.EXECUTING;\n        log.info(\"returnSession, curr-time {} sessionWrapper.createTime {}, this.sessionWrapper.createTime {} \", time(timeSource, MILLISECONDS),\n            sessionWrapper.createTime,\n            this.sessionWrapper.createTime);\n        if (sessionWrapper.createTime == this.sessionWrapper.createTime) {\n          //this session was used for computing new operations and this can now be used for other\n          // computing\n          this.sessionWrapper = sessionWrapper;\n\n          //one thread who is waiting for this need to be notified.\n          lockObj.notify();\n        } else {\n          log.info(\"create time NOT SAME {} \", SessionWrapper.DEF_INST.createTime);\n          //else just ignore it\n        }\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6428b274f6593f368c4f838379620e7f5d196d65","date":1537799661,"type":3,"author":"noble","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#returnSession(SessionWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#returnSession(SessionWrapper).mjava","sourceNew":"    /**\n     * Computing is over for this session and it may contain a new session with new state\n     * The session can be used by others while the caller is performing operations\n     */\n    private void returnSession(SessionWrapper sessionWrapper) {\n      TimeSource timeSource = sessionWrapper.session != null ? sessionWrapper.session.cloudManager.getTimeSource() : TimeSource.NANO_TIME;\n      synchronized (lockObj) {\n        sessionWrapper.status = Status.EXECUTING;\n        log.info(\"returnSession, curr-time {} sessionWrapper.createTime {}, this.sessionWrapper.createTime {} \", time(timeSource, MILLISECONDS),\n            sessionWrapper.createTime,\n            this.sessionWrapper.createTime);\n        if (sessionWrapper.createTime == this.sessionWrapper.createTime) {\n          //this session was used for computing new operations and this can now be used for other\n          // computing\n          this.sessionWrapper = sessionWrapper;\n\n          //one thread who is waiting for this need to be notified.\n          lockObj.notify();\n        } else {\n          log.info(\"create time NOT SAME {} \", SessionWrapper.DEFAULT_INSTANCE.createTime);\n          //else just ignore it\n        }\n      }\n\n    }\n\n","sourceOld":"    /**\n     * Computing is over for this session and it may contain a new session with new state\n     * The session can be used by others while the caller is performing operations\n     *\n     */\n    private void returnSession(SessionWrapper sessionWrapper) {\n      TimeSource timeSource = sessionWrapper.session != null ? sessionWrapper.session.cloudManager.getTimeSource() : TimeSource.NANO_TIME;\n      synchronized (lockObj) {\n        sessionWrapper.status = Status.EXECUTING;\n        log.info(\"returnSession, curr-time {} sessionWrapper.createTime {}, this.sessionWrapper.createTime {} \", time(timeSource, MILLISECONDS),\n            sessionWrapper.createTime,\n            this.sessionWrapper.createTime);\n        if (sessionWrapper.createTime == this.sessionWrapper.createTime) {\n          //this session was used for computing new operations and this can now be used for other\n          // computing\n          this.sessionWrapper = sessionWrapper;\n\n          //one thread who is waiting for this need to be notified.\n          lockObj.notify();\n        } else {\n          log.info(\"create time NOT SAME {} \", SessionWrapper.DEFAULT_INSTANCE.createTime);\n          //else just ignore it\n        }\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc18bc8ea2e2c1e308757ff50671c774438e9f3e","date":1538052583,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#returnSession(SessionWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#returnSession(SessionWrapper).mjava","sourceNew":"    /**\n     * Computing is over for this session and it may contain a new session with new state\n     * The session can be used by others while the caller is performing operations\n     */\n    private void returnSession(SessionWrapper sessionWrapper) {\n      TimeSource timeSource = sessionWrapper.session != null ? sessionWrapper.session.cloudManager.getTimeSource() : TimeSource.NANO_TIME;\n      synchronized (lockObj) {\n        sessionWrapper.status = Status.EXECUTING;\n        log.debug(\"returnSession, curr-time {} sessionWrapper.createTime {}, this.sessionWrapper.createTime {} \", time(timeSource, MILLISECONDS),\n            sessionWrapper.createTime,\n            this.sessionWrapper.createTime);\n        if (sessionWrapper.createTime == this.sessionWrapper.createTime) {\n          //this session was used for computing new operations and this can now be used for other\n          // computing\n          this.sessionWrapper = sessionWrapper;\n\n          //one thread who is waiting for this need to be notified.\n          lockObj.notify();\n        } else {\n          log.debug(\"create time NOT SAME {} \", SessionWrapper.DEFAULT_INSTANCE.createTime);\n          //else just ignore it\n        }\n      }\n\n    }\n\n","sourceOld":"    /**\n     * Computing is over for this session and it may contain a new session with new state\n     * The session can be used by others while the caller is performing operations\n     */\n    private void returnSession(SessionWrapper sessionWrapper) {\n      TimeSource timeSource = sessionWrapper.session != null ? sessionWrapper.session.cloudManager.getTimeSource() : TimeSource.NANO_TIME;\n      synchronized (lockObj) {\n        sessionWrapper.status = Status.EXECUTING;\n        log.info(\"returnSession, curr-time {} sessionWrapper.createTime {}, this.sessionWrapper.createTime {} \", time(timeSource, MILLISECONDS),\n            sessionWrapper.createTime,\n            this.sessionWrapper.createTime);\n        if (sessionWrapper.createTime == this.sessionWrapper.createTime) {\n          //this session was used for computing new operations and this can now be used for other\n          // computing\n          this.sessionWrapper = sessionWrapper;\n\n          //one thread who is waiting for this need to be notified.\n          lockObj.notify();\n        } else {\n          log.info(\"create time NOT SAME {} \", SessionWrapper.DEFAULT_INSTANCE.createTime);\n          //else just ignore it\n        }\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6dc613ed6f75d1988140301ee8de8fdb056fa337","date":1588034757,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#returnSession(SessionWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#returnSession(SessionWrapper).mjava","sourceNew":"    /**\n     * Computing is over for this session and it may contain a new session with new state\n     * The session can be used by others while the caller is performing operations\n     */\n    private void returnSession(SessionWrapper sessionWrapper) {\n      TimeSource timeSource = sessionWrapper.session != null ? sessionWrapper.session.cloudManager.getTimeSource() : TimeSource.NANO_TIME;\n      synchronized (lockObj) {\n        sessionWrapper.status = Status.EXECUTING;\n        if (log.isDebugEnabled()) {\n          log.debug(\"returnSession, curr-time {} sessionWrapper.createTime {}, this.sessionWrapper.createTime {} \"\n              , time(timeSource, MILLISECONDS),\n              sessionWrapper.createTime,\n              this.sessionWrapper.createTime);\n        }\n        if (sessionWrapper.createTime == this.sessionWrapper.createTime) {\n          //this session was used for computing new operations and this can now be used for other\n          // computing\n          this.sessionWrapper = sessionWrapper;\n\n          //one thread who is waiting for this need to be notified.\n          lockObj.notify();\n        } else {\n          log.debug(\"create time NOT SAME {} \", SessionWrapper.DEFAULT_INSTANCE.createTime);\n          //else just ignore it\n        }\n      }\n\n    }\n\n","sourceOld":"    /**\n     * Computing is over for this session and it may contain a new session with new state\n     * The session can be used by others while the caller is performing operations\n     */\n    private void returnSession(SessionWrapper sessionWrapper) {\n      TimeSource timeSource = sessionWrapper.session != null ? sessionWrapper.session.cloudManager.getTimeSource() : TimeSource.NANO_TIME;\n      synchronized (lockObj) {\n        sessionWrapper.status = Status.EXECUTING;\n        log.debug(\"returnSession, curr-time {} sessionWrapper.createTime {}, this.sessionWrapper.createTime {} \", time(timeSource, MILLISECONDS),\n            sessionWrapper.createTime,\n            this.sessionWrapper.createTime);\n        if (sessionWrapper.createTime == this.sessionWrapper.createTime) {\n          //this session was used for computing new operations and this can now be used for other\n          // computing\n          this.sessionWrapper = sessionWrapper;\n\n          //one thread who is waiting for this need to be notified.\n          lockObj.notify();\n        } else {\n          log.debug(\"create time NOT SAME {} \", SessionWrapper.DEFAULT_INSTANCE.createTime);\n          //else just ignore it\n        }\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e17627eb9673daf01d17fdfb583c621c55c34208","date":1593028963,"type":3,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#returnSession(SessionWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#returnSession(SessionWrapper).mjava","sourceNew":"    /**\n     * Computing is over for this session and it may contain a new session with new state\n     * The session can be used by others while the caller is performing operations\n     */\n    private void returnSession(SessionWrapper sessionWrapper) {\n      boolean present;\n      synchronized (lockObj) {\n        sessionWrapper.status = Status.EXECUTING;\n        present = sessionWrapperSet.contains(sessionWrapper);\n\n        // wake up single thread waiting for a session return (ok if not woken up, wait is short)\n        // Important to wake up a single one, otherwise of multiple waiting threads, all but one will immediately create new sessions\n        lockObj.notify();\n      }\n\n      // Logging\n      if (present) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"returnSession {}\", sessionWrapper.getCreateTime());\n        }\n      } else {\n        log.warn(\"returning unknown session {} \", sessionWrapper.getCreateTime());\n      }\n    }\n\n","sourceOld":"    /**\n     * Computing is over for this session and it may contain a new session with new state\n     * The session can be used by others while the caller is performing operations\n     */\n    private void returnSession(SessionWrapper sessionWrapper) {\n      TimeSource timeSource = sessionWrapper.session != null ? sessionWrapper.session.cloudManager.getTimeSource() : TimeSource.NANO_TIME;\n      synchronized (lockObj) {\n        sessionWrapper.status = Status.EXECUTING;\n        if (log.isDebugEnabled()) {\n          log.debug(\"returnSession, curr-time {} sessionWrapper.createTime {}, this.sessionWrapper.createTime {} \"\n              , time(timeSource, MILLISECONDS),\n              sessionWrapper.createTime,\n              this.sessionWrapper.createTime);\n        }\n        if (sessionWrapper.createTime == this.sessionWrapper.createTime) {\n          //this session was used for computing new operations and this can now be used for other\n          // computing\n          this.sessionWrapper = sessionWrapper;\n\n          //one thread who is waiting for this need to be notified.\n          lockObj.notify();\n        } else {\n          log.debug(\"create time NOT SAME {} \", SessionWrapper.DEFAULT_INSTANCE.createTime);\n          //else just ignore it\n        }\n      }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.SessionRef#returnSession(SessionWrapper).mjava","sourceNew":null,"sourceOld":"    /**\n     * Computing is over for this session and it may contain a new session with new state\n     * The session can be used by others while the caller is performing operations\n     */\n    private void returnSession(SessionWrapper sessionWrapper) {\n      boolean present;\n      synchronized (lockObj) {\n        sessionWrapper.status = Status.EXECUTING;\n        present = sessionWrapperSet.contains(sessionWrapper);\n\n        // wake up single thread waiting for a session return (ok if not woken up, wait is short)\n        // Important to wake up a single one, otherwise of multiple waiting threads, all but one will immediately create new sessions\n        lockObj.notify();\n      }\n\n      // Logging\n      if (present) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"returnSession {}\", sessionWrapper.getCreateTime());\n        }\n      } else {\n        log.warn(\"returning unknown session {} \", sessionWrapper.getCreateTime());\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fc18bc8ea2e2c1e308757ff50671c774438e9f3e":["6428b274f6593f368c4f838379620e7f5d196d65"],"e17627eb9673daf01d17fdfb583c621c55c34208":["6dc613ed6f75d1988140301ee8de8fdb056fa337"],"6dc613ed6f75d1988140301ee8de8fdb056fa337":["fc18bc8ea2e2c1e308757ff50671c774438e9f3e"],"3f504512a03d978990cbff30db0522b354e846db":["e17627eb9673daf01d17fdfb583c621c55c34208"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6428b274f6593f368c4f838379620e7f5d196d65":["27639bb5e041490ce599065875dd2f6d8beef62a"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["d907c28c7fe6305eaec1756d51365f5149e1e41d"],"27639bb5e041490ce599065875dd2f6d8beef62a":["43a787a75ad72a9bf26e8ff714d8b6d01f9eb441"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"],"d907c28c7fe6305eaec1756d51365f5149e1e41d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"43a787a75ad72a9bf26e8ff714d8b6d01f9eb441":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","d9ccfe45460d496c5e5e1b70396521dac842d966"],"d9ccfe45460d496c5e5e1b70396521dac842d966":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"]},"commit2Childs":{"fc18bc8ea2e2c1e308757ff50671c774438e9f3e":["6dc613ed6f75d1988140301ee8de8fdb056fa337"],"e17627eb9673daf01d17fdfb583c621c55c34208":["3f504512a03d978990cbff30db0522b354e846db"],"6dc613ed6f75d1988140301ee8de8fdb056fa337":["e17627eb9673daf01d17fdfb583c621c55c34208"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d907c28c7fe6305eaec1756d51365f5149e1e41d"],"6428b274f6593f368c4f838379620e7f5d196d65":["fc18bc8ea2e2c1e308757ff50671c774438e9f3e"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["43a787a75ad72a9bf26e8ff714d8b6d01f9eb441","d9ccfe45460d496c5e5e1b70396521dac842d966"],"27639bb5e041490ce599065875dd2f6d8beef62a":["6428b274f6593f368c4f838379620e7f5d196d65"],"d907c28c7fe6305eaec1756d51365f5149e1e41d":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"43a787a75ad72a9bf26e8ff714d8b6d01f9eb441":["27639bb5e041490ce599065875dd2f6d8beef62a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"d9ccfe45460d496c5e5e1b70396521dac842d966":["43a787a75ad72a9bf26e8ff714d8b6d01f9eb441"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}