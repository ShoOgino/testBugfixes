{"path":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","commits":[{"id":"c1a89fbf5a750bffb59fe3bf0779dd9fb5ee0c4d","date":1382570352,"type":0,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","pathOld":"/dev/null","sourceNew":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n        IntOpenHashSet boostDocs = getBoostDocs(indexSearcher, (Set<String>) (this.context.get(QueryElevationComponent.BOOSTED)));\n\n        if(this.min != null || this.max != null) {\n\n          return new CollapsingFieldValueCollector(this.maxDoc,\n              this.leafCount,\n              this.docValues,\n              this.searcher,\n              this.nullPolicy,\n              max != null ? this.max : this.min,\n              max != null,\n              needsScores(this.solrParams),\n              this.fieldType,\n              boostDocs);\n        } else {\n          return new CollapsingScoreCollector(this.maxDoc, this.leafCount, this.docValues, this.nullPolicy, boostDocs);\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["432fdfa612cbca5b4cf9125a2c6aa055cd53cadb","ceae51e37bbff02dcdeaa12303fec10d3eaaa004"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ceae51e37bbff02dcdeaa12303fec10d3eaaa004","date":1387382773,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","sourceNew":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        IndexSchema schema = searcher.getSchema();\n        SchemaField schemaField = schema.getField(this.field);\n\n        SortedDocValues docValues = null;\n\n        if(schemaField.hasDocValues()) {\n          docValues = searcher.getAtomicReader().getSortedDocValues(this.field);\n        } else {\n          docValues = FieldCache.DEFAULT.getTermsIndex(searcher.getAtomicReader(), this.field);\n        }\n\n        FieldType fieldType = null;\n\n        if(this.max != null) {\n          fieldType = searcher.getSchema().getField(this.max).getType();\n        }\n\n        if(this.min != null) {\n          fieldType = searcher.getSchema().getField(this.min).getType();\n        }\n\n        int maxDoc = searcher.maxDoc();\n        int leafCount = searcher.getTopReaderContext().leaves().size();\n\n        IntOpenHashSet boostDocs = getBoostDocs(searcher, (Set<String>) (this.context.get(QueryElevationComponent.BOOSTED)));\n\n        if(this.min != null || this.max != null) {\n\n          return new CollapsingFieldValueCollector(maxDoc,\n                                                   leafCount,\n                                                   docValues,\n                                                   this.nullPolicy,\n                                                   max != null ? this.max : this.min,\n                                                   max != null,\n                                                   this.needsScores,\n                                                   fieldType,\n                                                   boostDocs);\n        } else {\n          return new CollapsingScoreCollector(maxDoc, leafCount, docValues, this.nullPolicy, boostDocs);\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n        IntOpenHashSet boostDocs = getBoostDocs(indexSearcher, (Set<String>) (this.context.get(QueryElevationComponent.BOOSTED)));\n\n        if(this.min != null || this.max != null) {\n\n          return new CollapsingFieldValueCollector(this.maxDoc,\n              this.leafCount,\n              this.docValues,\n              this.searcher,\n              this.nullPolicy,\n              max != null ? this.max : this.min,\n              max != null,\n              needsScores(this.solrParams),\n              this.fieldType,\n              boostDocs);\n        } else {\n          return new CollapsingScoreCollector(this.maxDoc, this.leafCount, this.docValues, this.nullPolicy, boostDocs);\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":["c1a89fbf5a750bffb59fe3bf0779dd9fb5ee0c4d"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","sourceNew":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        IndexSchema schema = searcher.getSchema();\n        SchemaField schemaField = schema.getField(this.field);\n\n        SortedDocValues docValues = null;\n\n        if(schemaField.hasDocValues()) {\n          docValues = searcher.getAtomicReader().getSortedDocValues(this.field);\n        } else {\n          docValues = FieldCache.DEFAULT.getTermsIndex(searcher.getAtomicReader(), this.field);\n        }\n\n        FieldType fieldType = null;\n\n        if(this.max != null) {\n          fieldType = searcher.getSchema().getField(this.max).getType();\n        }\n\n        if(this.min != null) {\n          fieldType = searcher.getSchema().getField(this.min).getType();\n        }\n\n        int maxDoc = searcher.maxDoc();\n        int leafCount = searcher.getTopReaderContext().leaves().size();\n\n        IntOpenHashSet boostDocs = getBoostDocs(searcher, (Set<String>) (this.context.get(QueryElevationComponent.BOOSTED)));\n\n        if(this.min != null || this.max != null) {\n\n          return new CollapsingFieldValueCollector(maxDoc,\n                                                   leafCount,\n                                                   docValues,\n                                                   this.nullPolicy,\n                                                   max != null ? this.max : this.min,\n                                                   max != null,\n                                                   this.needsScores,\n                                                   fieldType,\n                                                   boostDocs);\n        } else {\n          return new CollapsingScoreCollector(maxDoc, leafCount, docValues, this.nullPolicy, boostDocs);\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n        IntOpenHashSet boostDocs = getBoostDocs(indexSearcher, (Set<String>) (this.context.get(QueryElevationComponent.BOOSTED)));\n\n        if(this.min != null || this.max != null) {\n\n          return new CollapsingFieldValueCollector(this.maxDoc,\n              this.leafCount,\n              this.docValues,\n              this.searcher,\n              this.nullPolicy,\n              max != null ? this.max : this.min,\n              max != null,\n              needsScores(this.solrParams),\n              this.fieldType,\n              boostDocs);\n        } else {\n          return new CollapsingScoreCollector(this.maxDoc, this.leafCount, this.docValues, this.nullPolicy, boostDocs);\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"51e87f816b84771636e67fc67039925030ebe671","date":1388500548,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","sourceNew":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        IndexSchema schema = searcher.getSchema();\n        SchemaField schemaField = schema.getField(this.field);\n\n        SortedDocValues docValues = null;\n        FunctionQuery funcQuery = null;\n        if(schemaField.hasDocValues()) {\n          docValues = searcher.getAtomicReader().getSortedDocValues(this.field);\n        } else {\n          docValues = FieldCache.DEFAULT.getTermsIndex(searcher.getAtomicReader(), this.field);\n        }\n\n        FieldType fieldType = null;\n\n        if(this.max != null) {\n          if(this.max.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.max).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.max, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        if(this.min != null) {\n          if(this.min.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.min).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.min, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        int maxDoc = searcher.maxDoc();\n        int leafCount = searcher.getTopReaderContext().leaves().size();\n\n        IntOpenHashSet boostDocs = getBoostDocs(searcher, (Set<String>) (this.context.get(QueryElevationComponent.BOOSTED)));\n\n        if(this.min != null || this.max != null) {\n\n          return new CollapsingFieldValueCollector(maxDoc,\n                                                   leafCount,\n                                                   docValues,\n                                                   this.nullPolicy,\n                                                   max != null ? this.max : this.min,\n                                                   max != null,\n                                                   this.needsScores,\n                                                   fieldType,\n                                                   boostDocs,\n                                                   funcQuery);\n        } else {\n          return new CollapsingScoreCollector(maxDoc, leafCount, docValues, this.nullPolicy, boostDocs);\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        IndexSchema schema = searcher.getSchema();\n        SchemaField schemaField = schema.getField(this.field);\n\n        SortedDocValues docValues = null;\n\n        if(schemaField.hasDocValues()) {\n          docValues = searcher.getAtomicReader().getSortedDocValues(this.field);\n        } else {\n          docValues = FieldCache.DEFAULT.getTermsIndex(searcher.getAtomicReader(), this.field);\n        }\n\n        FieldType fieldType = null;\n\n        if(this.max != null) {\n          fieldType = searcher.getSchema().getField(this.max).getType();\n        }\n\n        if(this.min != null) {\n          fieldType = searcher.getSchema().getField(this.min).getType();\n        }\n\n        int maxDoc = searcher.maxDoc();\n        int leafCount = searcher.getTopReaderContext().leaves().size();\n\n        IntOpenHashSet boostDocs = getBoostDocs(searcher, (Set<String>) (this.context.get(QueryElevationComponent.BOOSTED)));\n\n        if(this.min != null || this.max != null) {\n\n          return new CollapsingFieldValueCollector(maxDoc,\n                                                   leafCount,\n                                                   docValues,\n                                                   this.nullPolicy,\n                                                   max != null ? this.max : this.min,\n                                                   max != null,\n                                                   this.needsScores,\n                                                   fieldType,\n                                                   boostDocs);\n        } else {\n          return new CollapsingScoreCollector(maxDoc, leafCount, docValues, this.nullPolicy, boostDocs);\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6f9eac2f0b568b3694682edb863185a273fbbc6f","date":1391883217,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","sourceNew":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        IndexSchema schema = searcher.getSchema();\n        SchemaField schemaField = schema.getField(this.field);\n\n        SortedDocValues docValues = null;\n        FunctionQuery funcQuery = null;\n        if(schemaField.hasDocValues()) {\n          docValues = searcher.getAtomicReader().getSortedDocValues(this.field);\n        } else {\n          docValues = FieldCache.DEFAULT.getTermsIndex(searcher.getAtomicReader(), this.field);\n        }\n\n        FieldType fieldType = null;\n\n        if(this.max != null) {\n          if(this.max.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.max).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.max, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        if(this.min != null) {\n          if(this.min.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.min).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.min, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        int maxDoc = searcher.maxDoc();\n        int leafCount = searcher.getTopReaderContext().leaves().size();\n\n        SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        this.boosted = (Set<String>)info.getReq().getContext().get(QueryElevationComponent.BOOSTED);\n\n        IntOpenHashSet boostDocs = getBoostDocs(searcher, this.boosted);\n\n        if(this.min != null || this.max != null) {\n\n          return new CollapsingFieldValueCollector(maxDoc,\n                                                   leafCount,\n                                                   docValues,\n                                                   this.nullPolicy,\n                                                   max != null ? this.max : this.min,\n                                                   max != null,\n                                                   this.needsScores,\n                                                   fieldType,\n                                                   boostDocs,\n                                                   funcQuery);\n        } else {\n          return new CollapsingScoreCollector(maxDoc, leafCount, docValues, this.nullPolicy, boostDocs);\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        IndexSchema schema = searcher.getSchema();\n        SchemaField schemaField = schema.getField(this.field);\n\n        SortedDocValues docValues = null;\n        FunctionQuery funcQuery = null;\n        if(schemaField.hasDocValues()) {\n          docValues = searcher.getAtomicReader().getSortedDocValues(this.field);\n        } else {\n          docValues = FieldCache.DEFAULT.getTermsIndex(searcher.getAtomicReader(), this.field);\n        }\n\n        FieldType fieldType = null;\n\n        if(this.max != null) {\n          if(this.max.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.max).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.max, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        if(this.min != null) {\n          if(this.min.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.min).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.min, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        int maxDoc = searcher.maxDoc();\n        int leafCount = searcher.getTopReaderContext().leaves().size();\n\n        IntOpenHashSet boostDocs = getBoostDocs(searcher, (Set<String>) (this.context.get(QueryElevationComponent.BOOSTED)));\n\n        if(this.min != null || this.max != null) {\n\n          return new CollapsingFieldValueCollector(maxDoc,\n                                                   leafCount,\n                                                   docValues,\n                                                   this.nullPolicy,\n                                                   max != null ? this.max : this.min,\n                                                   max != null,\n                                                   this.needsScores,\n                                                   fieldType,\n                                                   boostDocs,\n                                                   funcQuery);\n        } else {\n          return new CollapsingScoreCollector(maxDoc, leafCount, docValues, this.nullPolicy, boostDocs);\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"10e22ca394550f9249a31b316dcf1cf70408da17","date":1391963676,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","sourceNew":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        IndexSchema schema = searcher.getSchema();\n        SchemaField schemaField = schema.getField(this.field);\n\n        SortedDocValues docValues = null;\n        FunctionQuery funcQuery = null;\n        if(schemaField.hasDocValues()) {\n          docValues = searcher.getAtomicReader().getSortedDocValues(this.field);\n        } else {\n          docValues = FieldCache.DEFAULT.getTermsIndex(searcher.getAtomicReader(), this.field);\n        }\n\n        FieldType fieldType = null;\n\n        if(this.max != null) {\n          if(this.max.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.max).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.max, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        if(this.min != null) {\n          if(this.min.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.min).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.min, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        int maxDoc = searcher.maxDoc();\n        int leafCount = searcher.getTopReaderContext().leaves().size();\n\n        if(this.boosted == null) {\n          SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n          if(info != null) {\n            this.boosted = (Set<String>)info.getReq().getContext().get(QueryElevationComponent.BOOSTED);\n          }\n        }\n\n        IntOpenHashSet boostDocs = getBoostDocs(searcher, this.boosted);\n\n        if(this.min != null || this.max != null) {\n\n          return new CollapsingFieldValueCollector(maxDoc,\n                                                   leafCount,\n                                                   docValues,\n                                                   this.nullPolicy,\n                                                   max != null ? this.max : this.min,\n                                                   max != null,\n                                                   this.needsScores,\n                                                   fieldType,\n                                                   boostDocs,\n                                                   funcQuery);\n        } else {\n          return new CollapsingScoreCollector(maxDoc, leafCount, docValues, this.nullPolicy, boostDocs);\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        IndexSchema schema = searcher.getSchema();\n        SchemaField schemaField = schema.getField(this.field);\n\n        SortedDocValues docValues = null;\n        FunctionQuery funcQuery = null;\n        if(schemaField.hasDocValues()) {\n          docValues = searcher.getAtomicReader().getSortedDocValues(this.field);\n        } else {\n          docValues = FieldCache.DEFAULT.getTermsIndex(searcher.getAtomicReader(), this.field);\n        }\n\n        FieldType fieldType = null;\n\n        if(this.max != null) {\n          if(this.max.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.max).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.max, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        if(this.min != null) {\n          if(this.min.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.min).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.min, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        int maxDoc = searcher.maxDoc();\n        int leafCount = searcher.getTopReaderContext().leaves().size();\n\n        SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        this.boosted = (Set<String>)info.getReq().getContext().get(QueryElevationComponent.BOOSTED);\n\n        IntOpenHashSet boostDocs = getBoostDocs(searcher, this.boosted);\n\n        if(this.min != null || this.max != null) {\n\n          return new CollapsingFieldValueCollector(maxDoc,\n                                                   leafCount,\n                                                   docValues,\n                                                   this.nullPolicy,\n                                                   max != null ? this.max : this.min,\n                                                   max != null,\n                                                   this.needsScores,\n                                                   fieldType,\n                                                   boostDocs,\n                                                   funcQuery);\n        } else {\n          return new CollapsingScoreCollector(maxDoc, leafCount, docValues, this.nullPolicy, boostDocs);\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"224952d10f823935a2a836d4072cb5bd6ac33e3e","date":1392068030,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","sourceNew":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        IndexSchema schema = searcher.getSchema();\n        SchemaField schemaField = schema.getField(this.field);\n\n        SortedDocValues docValues = null;\n        FunctionQuery funcQuery = null;\n        if(schemaField.hasDocValues()) {\n          docValues = searcher.getAtomicReader().getSortedDocValues(this.field);\n        } else {\n          docValues = FieldCache.DEFAULT.getTermsIndex(searcher.getAtomicReader(), this.field);\n        }\n\n        FieldType fieldType = null;\n\n        if(this.max != null) {\n          if(this.max.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.max).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.max, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        if(this.min != null) {\n          if(this.min.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.min).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.min, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        int maxDoc = searcher.maxDoc();\n        int leafCount = searcher.getTopReaderContext().leaves().size();\n\n        if(this.boosted == null) {\n          SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n          if(info != null) {\n            this.boosted = (Set<String>)info.getReq().getContext().get(QueryElevationComponent.BOOSTED);\n          }\n        }\n\n        IntOpenHashSet boostDocs = getBoostDocs(searcher, this.boosted);\n\n        if(this.min != null || this.max != null) {\n\n          return new CollapsingFieldValueCollector(maxDoc,\n                                                   leafCount,\n                                                   docValues,\n                                                   this.nullPolicy,\n                                                   max != null ? this.max : this.min,\n                                                   max != null,\n                                                   this.needsScores,\n                                                   fieldType,\n                                                   boostDocs,\n                                                   funcQuery, searcher);\n        } else {\n          return new CollapsingScoreCollector(maxDoc, leafCount, docValues, this.nullPolicy, boostDocs);\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        IndexSchema schema = searcher.getSchema();\n        SchemaField schemaField = schema.getField(this.field);\n\n        SortedDocValues docValues = null;\n        FunctionQuery funcQuery = null;\n        if(schemaField.hasDocValues()) {\n          docValues = searcher.getAtomicReader().getSortedDocValues(this.field);\n        } else {\n          docValues = FieldCache.DEFAULT.getTermsIndex(searcher.getAtomicReader(), this.field);\n        }\n\n        FieldType fieldType = null;\n\n        if(this.max != null) {\n          if(this.max.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.max).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.max, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        if(this.min != null) {\n          if(this.min.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.min).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.min, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        int maxDoc = searcher.maxDoc();\n        int leafCount = searcher.getTopReaderContext().leaves().size();\n\n        if(this.boosted == null) {\n          SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n          if(info != null) {\n            this.boosted = (Set<String>)info.getReq().getContext().get(QueryElevationComponent.BOOSTED);\n          }\n        }\n\n        IntOpenHashSet boostDocs = getBoostDocs(searcher, this.boosted);\n\n        if(this.min != null || this.max != null) {\n\n          return new CollapsingFieldValueCollector(maxDoc,\n                                                   leafCount,\n                                                   docValues,\n                                                   this.nullPolicy,\n                                                   max != null ? this.max : this.min,\n                                                   max != null,\n                                                   this.needsScores,\n                                                   fieldType,\n                                                   boostDocs,\n                                                   funcQuery);\n        } else {\n          return new CollapsingScoreCollector(maxDoc, leafCount, docValues, this.nullPolicy, boostDocs);\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae73da626f97850c922c42736f808d0378e165f0","date":1396625460,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","sourceNew":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        IndexSchema schema = searcher.getSchema();\n        SchemaField schemaField = schema.getField(this.field);\n\n        SortedDocValues docValues = null;\n        FunctionQuery funcQuery = null;\n        if(schemaField.hasDocValues()) {\n          docValues = searcher.getAtomicReader().getSortedDocValues(this.field);\n        } else {\n          docValues = FieldCache.DEFAULT.getTermsIndex(searcher.getAtomicReader(), this.field);\n        }\n\n        FieldType fieldType = null;\n\n        if(this.max != null) {\n          if(this.max.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.max).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.max, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        if(this.min != null) {\n          if(this.min.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.min).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.min, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        int maxDoc = searcher.maxDoc();\n        int leafCount = searcher.getTopReaderContext().leaves().size();\n\n        if(this.boosted == null) {\n          SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n          if(info != null) {\n            this.boosted = (Set<String>)info.getReq().getContext().get(QueryElevationComponent.BOOSTED);\n          }\n        }\n\n        IntOpenHashSet boostDocs = getBoostDocs(searcher, this.boosted);\n\n        if (this.min != null || this.max != null) {\n\n          return new CollapsingFieldValueCollector(maxDoc,\n                                                   leafCount,\n                                                   docValues,\n                                                   this.nullPolicy,\n                                                   max != null ? this.max : this.min,\n                                                   max != null,\n                                                   this.needsScores,\n                                                   fieldType,\n                                                   boostDocs,\n                                                   funcQuery, searcher);\n        } else {\n          return new CollapsingScoreCollector(maxDoc, leafCount, docValues, this.nullPolicy, boostDocs);\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        IndexSchema schema = searcher.getSchema();\n        SchemaField schemaField = schema.getField(this.field);\n\n        SortedDocValues docValues = null;\n        FunctionQuery funcQuery = null;\n        if(schemaField.hasDocValues()) {\n          docValues = searcher.getAtomicReader().getSortedDocValues(this.field);\n        } else {\n          docValues = FieldCache.DEFAULT.getTermsIndex(searcher.getAtomicReader(), this.field);\n        }\n\n        FieldType fieldType = null;\n\n        if(this.max != null) {\n          if(this.max.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.max).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.max, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        if(this.min != null) {\n          if(this.min.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.min).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.min, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        int maxDoc = searcher.maxDoc();\n        int leafCount = searcher.getTopReaderContext().leaves().size();\n\n        if(this.boosted == null) {\n          SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n          if(info != null) {\n            this.boosted = (Set<String>)info.getReq().getContext().get(QueryElevationComponent.BOOSTED);\n          }\n        }\n\n        IntOpenHashSet boostDocs = getBoostDocs(searcher, this.boosted);\n\n        if(this.min != null || this.max != null) {\n\n          return new CollapsingFieldValueCollector(maxDoc,\n                                                   leafCount,\n                                                   docValues,\n                                                   this.nullPolicy,\n                                                   max != null ? this.max : this.min,\n                                                   max != null,\n                                                   this.needsScores,\n                                                   fieldType,\n                                                   boostDocs,\n                                                   funcQuery, searcher);\n        } else {\n          return new CollapsingScoreCollector(maxDoc, leafCount, docValues, this.nullPolicy, boostDocs);\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15e323346eac5e4685c0a9f2df85eb96b4239bbb","date":1396688577,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","sourceNew":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        IndexSchema schema = searcher.getSchema();\n        SchemaField schemaField = schema.getField(this.field);\n\n        SortedDocValues docValues = null;\n        FunctionQuery funcQuery = null;\n        if(schemaField.hasDocValues()) {\n          docValues = searcher.getAtomicReader().getSortedDocValues(this.field);\n        } else {\n          docValues = FieldCache.DEFAULT.getTermsIndex(searcher.getAtomicReader(), this.field);\n        }\n\n        FieldType fieldType = null;\n\n        if(this.max != null) {\n          if(this.max.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.max).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.max, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        if(this.min != null) {\n          if(this.min.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.min).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.min, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        int maxDoc = searcher.maxDoc();\n        int leafCount = searcher.getTopReaderContext().leaves().size();\n\n        if(this.boosted == null) {\n          SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n          if(info != null) {\n            this.boosted = (Set<String>)info.getReq().getContext().get(QueryElevationComponent.BOOSTED);\n          }\n        }\n\n        IntOpenHashSet boostDocs = getBoostDocs(searcher, this.boosted);\n\n        if (this.min != null || this.max != null) {\n\n          return new CollapsingFieldValueCollector(maxDoc,\n                                                   leafCount,\n                                                   docValues,\n                                                   this.nullPolicy,\n                                                   max != null ? this.max : this.min,\n                                                   max != null,\n                                                   this.needsScores,\n                                                   fieldType,\n                                                   boostDocs,\n                                                   funcQuery, searcher);\n        } else {\n          return new CollapsingScoreCollector(maxDoc, leafCount, docValues, this.nullPolicy, boostDocs);\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        IndexSchema schema = searcher.getSchema();\n        SchemaField schemaField = schema.getField(this.field);\n\n        SortedDocValues docValues = null;\n        FunctionQuery funcQuery = null;\n        if(schemaField.hasDocValues()) {\n          docValues = searcher.getAtomicReader().getSortedDocValues(this.field);\n        } else {\n          docValues = FieldCache.DEFAULT.getTermsIndex(searcher.getAtomicReader(), this.field);\n        }\n\n        FieldType fieldType = null;\n\n        if(this.max != null) {\n          if(this.max.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.max).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.max, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        if(this.min != null) {\n          if(this.min.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.min).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.min, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        int maxDoc = searcher.maxDoc();\n        int leafCount = searcher.getTopReaderContext().leaves().size();\n\n        if(this.boosted == null) {\n          SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n          if(info != null) {\n            this.boosted = (Set<String>)info.getReq().getContext().get(QueryElevationComponent.BOOSTED);\n          }\n        }\n\n        IntOpenHashSet boostDocs = getBoostDocs(searcher, this.boosted);\n\n        if(this.min != null || this.max != null) {\n\n          return new CollapsingFieldValueCollector(maxDoc,\n                                                   leafCount,\n                                                   docValues,\n                                                   this.nullPolicy,\n                                                   max != null ? this.max : this.min,\n                                                   max != null,\n                                                   this.needsScores,\n                                                   fieldType,\n                                                   boostDocs,\n                                                   funcQuery, searcher);\n        } else {\n          return new CollapsingScoreCollector(maxDoc, leafCount, docValues, this.nullPolicy, boostDocs);\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e28b14e7783d24ca69089f13ddadadbd2afdcb29","date":1399840701,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","sourceNew":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        IndexSchema schema = searcher.getSchema();\n        SchemaField schemaField = schema.getField(this.field);\n\n        SortedDocValues docValues = null;\n        FunctionQuery funcQuery = null;\n        docValues = DocValues.getSorted(searcher.getAtomicReader(), this.field);\n\n        FieldType fieldType = null;\n\n        if(this.max != null) {\n          if(this.max.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.max).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.max, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        if(this.min != null) {\n          if(this.min.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.min).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.min, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        int maxDoc = searcher.maxDoc();\n        int leafCount = searcher.getTopReaderContext().leaves().size();\n\n        if(this.boosted == null) {\n          SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n          if(info != null) {\n            this.boosted = (Set<String>)info.getReq().getContext().get(QueryElevationComponent.BOOSTED);\n          }\n        }\n\n        IntOpenHashSet boostDocs = getBoostDocs(searcher, this.boosted);\n\n        if (this.min != null || this.max != null) {\n\n          return new CollapsingFieldValueCollector(maxDoc,\n                                                   leafCount,\n                                                   docValues,\n                                                   this.nullPolicy,\n                                                   max != null ? this.max : this.min,\n                                                   max != null,\n                                                   this.needsScores,\n                                                   fieldType,\n                                                   boostDocs,\n                                                   funcQuery, searcher);\n        } else {\n          return new CollapsingScoreCollector(maxDoc, leafCount, docValues, this.nullPolicy, boostDocs);\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        IndexSchema schema = searcher.getSchema();\n        SchemaField schemaField = schema.getField(this.field);\n\n        SortedDocValues docValues = null;\n        FunctionQuery funcQuery = null;\n        if(schemaField.hasDocValues()) {\n          docValues = searcher.getAtomicReader().getSortedDocValues(this.field);\n        } else {\n          docValues = FieldCache.DEFAULT.getTermsIndex(searcher.getAtomicReader(), this.field);\n        }\n\n        FieldType fieldType = null;\n\n        if(this.max != null) {\n          if(this.max.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.max).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.max, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        if(this.min != null) {\n          if(this.min.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.min).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.min, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        int maxDoc = searcher.maxDoc();\n        int leafCount = searcher.getTopReaderContext().leaves().size();\n\n        if(this.boosted == null) {\n          SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n          if(info != null) {\n            this.boosted = (Set<String>)info.getReq().getContext().get(QueryElevationComponent.BOOSTED);\n          }\n        }\n\n        IntOpenHashSet boostDocs = getBoostDocs(searcher, this.boosted);\n\n        if (this.min != null || this.max != null) {\n\n          return new CollapsingFieldValueCollector(maxDoc,\n                                                   leafCount,\n                                                   docValues,\n                                                   this.nullPolicy,\n                                                   max != null ? this.max : this.min,\n                                                   max != null,\n                                                   this.needsScores,\n                                                   fieldType,\n                                                   boostDocs,\n                                                   funcQuery, searcher);\n        } else {\n          return new CollapsingScoreCollector(maxDoc, leafCount, docValues, this.nullPolicy, boostDocs);\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93dd449115a9247533e44bab47e8429e5dccbc6d","date":1400258396,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","sourceNew":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        IndexSchema schema = searcher.getSchema();\n        SchemaField schemaField = schema.getField(this.field);\n\n        SortedDocValues docValues = null;\n        FunctionQuery funcQuery = null;\n        docValues = DocValues.getSorted(searcher.getAtomicReader(), this.field);\n\n        FieldType fieldType = null;\n\n        if(this.max != null) {\n          if(this.max.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.max).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.max, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        if(this.min != null) {\n          if(this.min.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.min).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.min, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        int maxDoc = searcher.maxDoc();\n        int leafCount = searcher.getTopReaderContext().leaves().size();\n\n        if(this.boosted == null) {\n          SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n          if(info != null) {\n            this.boosted = (Set<String>)info.getReq().getContext().get(QueryElevationComponent.BOOSTED);\n          }\n        }\n\n        IntOpenHashSet boostDocs = getBoostDocs(searcher, this.boosted);\n\n        if (this.min != null || this.max != null) {\n\n          return new CollapsingFieldValueCollector(maxDoc,\n                                                   leafCount,\n                                                   docValues,\n                                                   this.nullPolicy,\n                                                   max != null ? this.max : this.min,\n                                                   max != null,\n                                                   this.needsScores,\n                                                   fieldType,\n                                                   boostDocs,\n                                                   funcQuery, searcher);\n        } else {\n          return new CollapsingScoreCollector(maxDoc, leafCount, docValues, this.nullPolicy, boostDocs);\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        IndexSchema schema = searcher.getSchema();\n        SchemaField schemaField = schema.getField(this.field);\n\n        SortedDocValues docValues = null;\n        FunctionQuery funcQuery = null;\n        if(schemaField.hasDocValues()) {\n          docValues = searcher.getAtomicReader().getSortedDocValues(this.field);\n        } else {\n          docValues = FieldCache.DEFAULT.getTermsIndex(searcher.getAtomicReader(), this.field);\n        }\n\n        FieldType fieldType = null;\n\n        if(this.max != null) {\n          if(this.max.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.max).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.max, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        if(this.min != null) {\n          if(this.min.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.min).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.min, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        int maxDoc = searcher.maxDoc();\n        int leafCount = searcher.getTopReaderContext().leaves().size();\n\n        if(this.boosted == null) {\n          SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n          if(info != null) {\n            this.boosted = (Set<String>)info.getReq().getContext().get(QueryElevationComponent.BOOSTED);\n          }\n        }\n\n        IntOpenHashSet boostDocs = getBoostDocs(searcher, this.boosted);\n\n        if (this.min != null || this.max != null) {\n\n          return new CollapsingFieldValueCollector(maxDoc,\n                                                   leafCount,\n                                                   docValues,\n                                                   this.nullPolicy,\n                                                   max != null ? this.max : this.min,\n                                                   max != null,\n                                                   this.needsScores,\n                                                   fieldType,\n                                                   boostDocs,\n                                                   funcQuery, searcher);\n        } else {\n          return new CollapsingScoreCollector(maxDoc, leafCount, docValues, this.nullPolicy, boostDocs);\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","sourceNew":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        IndexSchema schema = searcher.getSchema();\n        SchemaField schemaField = schema.getField(this.field);\n\n        SortedDocValues docValues = null;\n        FunctionQuery funcQuery = null;\n        docValues = DocValues.getSorted(searcher.getAtomicReader(), this.field);\n\n        FieldType fieldType = null;\n\n        if(this.max != null) {\n          if(this.max.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.max).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.max, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        if(this.min != null) {\n          if(this.min.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.min).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.min, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        int maxDoc = searcher.maxDoc();\n        int leafCount = searcher.getTopReaderContext().leaves().size();\n\n        if(this.boosted == null) {\n          SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n          if(info != null) {\n            this.boosted = (Set<String>)info.getReq().getContext().get(QueryElevationComponent.BOOSTED);\n          }\n        }\n\n        IntOpenHashSet boostDocs = getBoostDocs(searcher, this.boosted);\n\n        if (this.min != null || this.max != null) {\n\n          return new CollapsingFieldValueCollector(maxDoc,\n                                                   leafCount,\n                                                   docValues,\n                                                   this.nullPolicy,\n                                                   max != null ? this.max : this.min,\n                                                   max != null,\n                                                   this.needsScores,\n                                                   fieldType,\n                                                   boostDocs,\n                                                   funcQuery, searcher);\n        } else {\n          return new CollapsingScoreCollector(maxDoc, leafCount, docValues, this.nullPolicy, boostDocs);\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        IndexSchema schema = searcher.getSchema();\n        SchemaField schemaField = schema.getField(this.field);\n\n        SortedDocValues docValues = null;\n        FunctionQuery funcQuery = null;\n        if(schemaField.hasDocValues()) {\n          docValues = searcher.getAtomicReader().getSortedDocValues(this.field);\n        } else {\n          docValues = FieldCache.DEFAULT.getTermsIndex(searcher.getAtomicReader(), this.field);\n        }\n\n        FieldType fieldType = null;\n\n        if(this.max != null) {\n          if(this.max.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.max).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.max, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        if(this.min != null) {\n          if(this.min.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.min).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.min, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        int maxDoc = searcher.maxDoc();\n        int leafCount = searcher.getTopReaderContext().leaves().size();\n\n        if(this.boosted == null) {\n          SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n          if(info != null) {\n            this.boosted = (Set<String>)info.getReq().getContext().get(QueryElevationComponent.BOOSTED);\n          }\n        }\n\n        IntOpenHashSet boostDocs = getBoostDocs(searcher, this.boosted);\n\n        if (this.min != null || this.max != null) {\n\n          return new CollapsingFieldValueCollector(maxDoc,\n                                                   leafCount,\n                                                   docValues,\n                                                   this.nullPolicy,\n                                                   max != null ? this.max : this.min,\n                                                   max != null,\n                                                   this.needsScores,\n                                                   fieldType,\n                                                   boostDocs,\n                                                   funcQuery, searcher);\n        } else {\n          return new CollapsingScoreCollector(maxDoc, leafCount, docValues, this.nullPolicy, boostDocs);\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a667f95e8b4d25c8e45a6bb9ba8ce9654e7858d7","date":1401992910,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","sourceNew":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n\n        SortedDocValues docValues = null;\n        FunctionQuery funcQuery = null;\n        docValues = DocValues.getSorted(searcher.getAtomicReader(), this.field);\n\n        FieldType fieldType = null;\n\n        if(this.max != null) {\n          if(this.max.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.max).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.max, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        if(this.min != null) {\n          if(this.min.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.min).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.min, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        int maxDoc = searcher.maxDoc();\n        int leafCount = searcher.getTopReaderContext().leaves().size();\n\n        //Deal with boosted docs.\n        //We have to deal with it here rather then the constructor because\n        //because the QueryElevationComponent runs after the Queries are constructed.\n\n        IntIntOpenHashMap boostDocs = null;\n        Map context = null;\n        SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        if(info != null) {\n          context = info.getReq().getContext();\n        }\n\n        if(this.boosted == null && context != null) {\n          this.boosted = (Map<BytesRef, Integer>)context.get(QueryElevationComponent.BOOSTED_PRIORITY);\n        }\n\n        boostDocs = getBoostDocs(searcher, this.boosted, context);\n\n        if (this.min != null || this.max != null) {\n\n          return new CollapsingFieldValueCollector(maxDoc,\n                                                   leafCount,\n                                                   docValues,\n                                                   this.nullPolicy,\n                                                   max != null ? this.max : this.min,\n                                                   max != null,\n                                                   this.needsScores,\n                                                   fieldType,\n                                                   boostDocs,\n                                                   funcQuery, searcher);\n        } else {\n          return new CollapsingScoreCollector(maxDoc, leafCount, docValues, this.nullPolicy, boostDocs);\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        IndexSchema schema = searcher.getSchema();\n        SchemaField schemaField = schema.getField(this.field);\n\n        SortedDocValues docValues = null;\n        FunctionQuery funcQuery = null;\n        docValues = DocValues.getSorted(searcher.getAtomicReader(), this.field);\n\n        FieldType fieldType = null;\n\n        if(this.max != null) {\n          if(this.max.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.max).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.max, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        if(this.min != null) {\n          if(this.min.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.min).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.min, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        int maxDoc = searcher.maxDoc();\n        int leafCount = searcher.getTopReaderContext().leaves().size();\n\n        if(this.boosted == null) {\n          SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n          if(info != null) {\n            this.boosted = (Set<String>)info.getReq().getContext().get(QueryElevationComponent.BOOSTED);\n          }\n        }\n\n        IntOpenHashSet boostDocs = getBoostDocs(searcher, this.boosted);\n\n        if (this.min != null || this.max != null) {\n\n          return new CollapsingFieldValueCollector(maxDoc,\n                                                   leafCount,\n                                                   docValues,\n                                                   this.nullPolicy,\n                                                   max != null ? this.max : this.min,\n                                                   max != null,\n                                                   this.needsScores,\n                                                   fieldType,\n                                                   boostDocs,\n                                                   funcQuery, searcher);\n        } else {\n          return new CollapsingScoreCollector(maxDoc, leafCount, docValues, this.nullPolicy, boostDocs);\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","sourceNew":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n\n        SortedDocValues docValues = null;\n        FunctionQuery funcQuery = null;\n        docValues = DocValues.getSorted(searcher.getLeafReader(), this.field);\n\n        FieldType fieldType = null;\n\n        if(this.max != null) {\n          if(this.max.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.max).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.max, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        if(this.min != null) {\n          if(this.min.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.min).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.min, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        int maxDoc = searcher.maxDoc();\n        int leafCount = searcher.getTopReaderContext().leaves().size();\n\n        //Deal with boosted docs.\n        //We have to deal with it here rather then the constructor because\n        //because the QueryElevationComponent runs after the Queries are constructed.\n\n        IntIntOpenHashMap boostDocs = null;\n        Map context = null;\n        SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        if(info != null) {\n          context = info.getReq().getContext();\n        }\n\n        if(this.boosted == null && context != null) {\n          this.boosted = (Map<BytesRef, Integer>)context.get(QueryElevationComponent.BOOSTED_PRIORITY);\n        }\n\n        boostDocs = getBoostDocs(searcher, this.boosted, context);\n\n        if (this.min != null || this.max != null) {\n\n          return new CollapsingFieldValueCollector(maxDoc,\n                                                   leafCount,\n                                                   docValues,\n                                                   this.nullPolicy,\n                                                   max != null ? this.max : this.min,\n                                                   max != null,\n                                                   this.needsScores,\n                                                   fieldType,\n                                                   boostDocs,\n                                                   funcQuery, searcher);\n        } else {\n          return new CollapsingScoreCollector(maxDoc, leafCount, docValues, this.nullPolicy, boostDocs);\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n\n        SortedDocValues docValues = null;\n        FunctionQuery funcQuery = null;\n        docValues = DocValues.getSorted(searcher.getAtomicReader(), this.field);\n\n        FieldType fieldType = null;\n\n        if(this.max != null) {\n          if(this.max.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.max).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.max, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        if(this.min != null) {\n          if(this.min.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.min).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.min, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        int maxDoc = searcher.maxDoc();\n        int leafCount = searcher.getTopReaderContext().leaves().size();\n\n        //Deal with boosted docs.\n        //We have to deal with it here rather then the constructor because\n        //because the QueryElevationComponent runs after the Queries are constructed.\n\n        IntIntOpenHashMap boostDocs = null;\n        Map context = null;\n        SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        if(info != null) {\n          context = info.getReq().getContext();\n        }\n\n        if(this.boosted == null && context != null) {\n          this.boosted = (Map<BytesRef, Integer>)context.get(QueryElevationComponent.BOOSTED_PRIORITY);\n        }\n\n        boostDocs = getBoostDocs(searcher, this.boosted, context);\n\n        if (this.min != null || this.max != null) {\n\n          return new CollapsingFieldValueCollector(maxDoc,\n                                                   leafCount,\n                                                   docValues,\n                                                   this.nullPolicy,\n                                                   max != null ? this.max : this.min,\n                                                   max != null,\n                                                   this.needsScores,\n                                                   fieldType,\n                                                   boostDocs,\n                                                   funcQuery, searcher);\n        } else {\n          return new CollapsingScoreCollector(maxDoc, leafCount, docValues, this.nullPolicy, boostDocs);\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8ced52befdc8d88d90766aadbaac496f3fd0e4ee","date":1421070034,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","sourceNew":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        CollectorFactory collectorFactory = new CollectorFactory();\n        //Deal with boosted docs.\n        //We have to deal with it here rather then the constructor because\n        //because the QueryElevationComponent runs after the Queries are constructed.\n\n        IntIntOpenHashMap boostDocsMap = null;\n        Map context = null;\n        SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        if(info != null) {\n          context = info.getReq().getContext();\n        }\n\n        if(this.boosted == null && context != null) {\n          this.boosted = (Map<BytesRef, Integer>)context.get(QueryElevationComponent.BOOSTED_PRIORITY);\n        }\n\n        boostDocsMap = getBoostDocs(searcher, this.boosted, context);\n        return collectorFactory.getCollector(this.collapseField,\n                                             this.min,\n                                             this.max,\n                                             this.nullPolicy,\n                                             this.hint,\n                                             this.needsScores,\n                                             this.size,\n                                             boostDocsMap,\n                                             searcher);\n\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n\n        SortedDocValues docValues = null;\n        FunctionQuery funcQuery = null;\n        docValues = DocValues.getSorted(searcher.getLeafReader(), this.field);\n\n        FieldType fieldType = null;\n\n        if(this.max != null) {\n          if(this.max.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.max).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.max, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        if(this.min != null) {\n          if(this.min.indexOf(\"(\") == -1) {\n            fieldType = searcher.getSchema().getField(this.min).getType();\n          } else {\n            LocalSolrQueryRequest request = null;\n            try {\n              SolrParams params = new ModifiableSolrParams();\n              request = new LocalSolrQueryRequest(searcher.getCore(), params);\n              FunctionQParser functionQParser = new FunctionQParser(this.min, null, null,request);\n              funcQuery = (FunctionQuery)functionQParser.parse();\n            } catch (Exception e) {\n              throw new IOException(e);\n            } finally {\n              request.close();\n            }\n          }\n        }\n\n        int maxDoc = searcher.maxDoc();\n        int leafCount = searcher.getTopReaderContext().leaves().size();\n\n        //Deal with boosted docs.\n        //We have to deal with it here rather then the constructor because\n        //because the QueryElevationComponent runs after the Queries are constructed.\n\n        IntIntOpenHashMap boostDocs = null;\n        Map context = null;\n        SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        if(info != null) {\n          context = info.getReq().getContext();\n        }\n\n        if(this.boosted == null && context != null) {\n          this.boosted = (Map<BytesRef, Integer>)context.get(QueryElevationComponent.BOOSTED_PRIORITY);\n        }\n\n        boostDocs = getBoostDocs(searcher, this.boosted, context);\n\n        if (this.min != null || this.max != null) {\n\n          return new CollapsingFieldValueCollector(maxDoc,\n                                                   leafCount,\n                                                   docValues,\n                                                   this.nullPolicy,\n                                                   max != null ? this.max : this.min,\n                                                   max != null,\n                                                   this.needsScores,\n                                                   fieldType,\n                                                   boostDocs,\n                                                   funcQuery, searcher);\n        } else {\n          return new CollapsingScoreCollector(maxDoc, leafCount, docValues, this.nullPolicy, boostDocs);\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1fcee2c3acd9aa64a73a3b441b3f6cb492af0b87","date":1440409984,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","sourceNew":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        CollectorFactory collectorFactory = new CollectorFactory();\n        //Deal with boosted docs.\n        //We have to deal with it here rather then the constructor because\n        //because the QueryElevationComponent runs after the Queries are constructed.\n\n        IntIntHashMap boostDocsMap = null;\n        Map context = null;\n        SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        if(info != null) {\n          context = info.getReq().getContext();\n        }\n\n        if(this.boosted == null && context != null) {\n          this.boosted = (Map<BytesRef, Integer>)context.get(QueryElevationComponent.BOOSTED_PRIORITY);\n        }\n\n        boostDocsMap = getBoostDocs(searcher, this.boosted, context);\n        return collectorFactory.getCollector(this.collapseField,\n                                             this.min,\n                                             this.max,\n                                             this.nullPolicy,\n                                             this.hint,\n                                             this.needsScores,\n                                             this.size,\n                                             boostDocsMap,\n                                             searcher);\n\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        CollectorFactory collectorFactory = new CollectorFactory();\n        //Deal with boosted docs.\n        //We have to deal with it here rather then the constructor because\n        //because the QueryElevationComponent runs after the Queries are constructed.\n\n        IntIntOpenHashMap boostDocsMap = null;\n        Map context = null;\n        SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        if(info != null) {\n          context = info.getReq().getContext();\n        }\n\n        if(this.boosted == null && context != null) {\n          this.boosted = (Map<BytesRef, Integer>)context.get(QueryElevationComponent.BOOSTED_PRIORITY);\n        }\n\n        boostDocsMap = getBoostDocs(searcher, this.boosted, context);\n        return collectorFactory.getCollector(this.collapseField,\n                                             this.min,\n                                             this.max,\n                                             this.nullPolicy,\n                                             this.hint,\n                                             this.needsScores,\n                                             this.size,\n                                             boostDocsMap,\n                                             searcher);\n\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0325de99180d346d61d36938843a5c8451fe26ae","date":1447368726,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","sourceNew":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        CollectorFactory collectorFactory = new CollectorFactory();\n        //Deal with boosted docs.\n        //We have to deal with it here rather then the constructor because\n        //because the QueryElevationComponent runs after the Queries are constructed.\n\n        IntIntHashMap boostDocsMap = null;\n        Map context = null;\n        SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        if(info != null) {\n          context = info.getReq().getContext();\n        }\n\n        if(this.boosted == null && context != null) {\n          this.boosted = (Map<BytesRef, Integer>)context.get(QueryElevationComponent.BOOSTED_PRIORITY);\n        }\n\n        boostDocsMap = getBoostDocs(searcher, this.boosted, context);\n        return collectorFactory.getCollector(this.collapseField,\n                                             this.groupHeadSelector,\n                                             this.sortSpec,\n                                             this.nullPolicy,\n                                             this.hint,\n                                             this.needsScores,\n                                             this.size,\n                                             boostDocsMap,\n                                             searcher);\n\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        CollectorFactory collectorFactory = new CollectorFactory();\n        //Deal with boosted docs.\n        //We have to deal with it here rather then the constructor because\n        //because the QueryElevationComponent runs after the Queries are constructed.\n\n        IntIntHashMap boostDocsMap = null;\n        Map context = null;\n        SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        if(info != null) {\n          context = info.getReq().getContext();\n        }\n\n        if(this.boosted == null && context != null) {\n          this.boosted = (Map<BytesRef, Integer>)context.get(QueryElevationComponent.BOOSTED_PRIORITY);\n        }\n\n        boostDocsMap = getBoostDocs(searcher, this.boosted, context);\n        return collectorFactory.getCollector(this.collapseField,\n                                             this.min,\n                                             this.max,\n                                             this.nullPolicy,\n                                             this.hint,\n                                             this.needsScores,\n                                             this.size,\n                                             boostDocsMap,\n                                             searcher);\n\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2ad458affd82a1d762eb506003907d9363a333cb","date":1528558344,"type":3,"author":"broustant","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","sourceNew":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        CollectorFactory collectorFactory = new CollectorFactory();\n        //Deal with boosted docs.\n        //We have to deal with it here rather then the constructor because\n        //because the QueryElevationComponent runs after the Queries are constructed.\n\n        IntIntHashMap boostDocsMap = null;\n        Map context = null;\n        SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        if(info != null) {\n          context = info.getReq().getContext();\n        }\n\n        if(this.boosted == null && context != null) {\n          this.boosted = (Set<BytesRef>)context.get(QueryElevationComponent.BOOSTED);\n        }\n\n        boostDocsMap = QueryElevationComponent.getBoostDocs(searcher, this.boosted, context);\n        return collectorFactory.getCollector(this.collapseField,\n                                             this.groupHeadSelector,\n                                             this.sortSpec,\n                                             this.nullPolicy,\n                                             this.hint,\n                                             this.needsScores,\n                                             this.size,\n                                             boostDocsMap,\n                                             searcher);\n\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        CollectorFactory collectorFactory = new CollectorFactory();\n        //Deal with boosted docs.\n        //We have to deal with it here rather then the constructor because\n        //because the QueryElevationComponent runs after the Queries are constructed.\n\n        IntIntHashMap boostDocsMap = null;\n        Map context = null;\n        SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        if(info != null) {\n          context = info.getReq().getContext();\n        }\n\n        if(this.boosted == null && context != null) {\n          this.boosted = (Map<BytesRef, Integer>)context.get(QueryElevationComponent.BOOSTED_PRIORITY);\n        }\n\n        boostDocsMap = getBoostDocs(searcher, this.boosted, context);\n        return collectorFactory.getCollector(this.collapseField,\n                                             this.groupHeadSelector,\n                                             this.sortSpec,\n                                             this.nullPolicy,\n                                             this.hint,\n                                             this.needsScores,\n                                             this.size,\n                                             boostDocsMap,\n                                             searcher);\n\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","sourceNew":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        CollectorFactory collectorFactory = new CollectorFactory();\n        //Deal with boosted docs.\n        //We have to deal with it here rather then the constructor because\n        //because the QueryElevationComponent runs after the Queries are constructed.\n\n        IntIntHashMap boostDocsMap = null;\n        Map context = null;\n        SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        if(info != null) {\n          context = info.getReq().getContext();\n        }\n\n        if(this.boosted == null && context != null) {\n          this.boosted = (Set<BytesRef>)context.get(QueryElevationComponent.BOOSTED);\n        }\n\n        boostDocsMap = QueryElevationComponent.getBoostDocs(searcher, this.boosted, context);\n        return collectorFactory.getCollector(this.collapseField,\n                                             this.groupHeadSelector,\n                                             this.sortSpec,\n                                             this.nullPolicy,\n                                             this.hint,\n                                             this.needsScores,\n                                             this.size,\n                                             boostDocsMap,\n                                             searcher);\n\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        CollectorFactory collectorFactory = new CollectorFactory();\n        //Deal with boosted docs.\n        //We have to deal with it here rather then the constructor because\n        //because the QueryElevationComponent runs after the Queries are constructed.\n\n        IntIntHashMap boostDocsMap = null;\n        Map context = null;\n        SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        if(info != null) {\n          context = info.getReq().getContext();\n        }\n\n        if(this.boosted == null && context != null) {\n          this.boosted = (Map<BytesRef, Integer>)context.get(QueryElevationComponent.BOOSTED_PRIORITY);\n        }\n\n        boostDocsMap = getBoostDocs(searcher, this.boosted, context);\n        return collectorFactory.getCollector(this.collapseField,\n                                             this.groupHeadSelector,\n                                             this.sortSpec,\n                                             this.nullPolicy,\n                                             this.hint,\n                                             this.needsScores,\n                                             this.size,\n                                             boostDocsMap,\n                                             searcher);\n\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","sourceNew":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        CollectorFactory collectorFactory = new CollectorFactory();\n        //Deal with boosted docs.\n        //We have to deal with it here rather then the constructor because\n        //because the QueryElevationComponent runs after the Queries are constructed.\n\n        IntIntHashMap boostDocsMap = null;\n        Map context = null;\n        SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        if(info != null) {\n          context = info.getReq().getContext();\n        }\n\n        if(this.boosted == null && context != null) {\n          this.boosted = (Set<BytesRef>)context.get(QueryElevationComponent.BOOSTED);\n        }\n\n        boostDocsMap = QueryElevationComponent.getBoostDocs(searcher, this.boosted, context);\n        return collectorFactory.getCollector(this.collapseField,\n                                             this.groupHeadSelector,\n                                             this.sortSpec,\n                                             this.nullPolicy,\n                                             this.hint,\n                                             this.needsScores,\n                                             this.size,\n                                             boostDocsMap,\n                                             searcher);\n\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        CollectorFactory collectorFactory = new CollectorFactory();\n        //Deal with boosted docs.\n        //We have to deal with it here rather then the constructor because\n        //because the QueryElevationComponent runs after the Queries are constructed.\n\n        IntIntHashMap boostDocsMap = null;\n        Map context = null;\n        SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        if(info != null) {\n          context = info.getReq().getContext();\n        }\n\n        if(this.boosted == null && context != null) {\n          this.boosted = (Map<BytesRef, Integer>)context.get(QueryElevationComponent.BOOSTED_PRIORITY);\n        }\n\n        boostDocsMap = getBoostDocs(searcher, this.boosted, context);\n        return collectorFactory.getCollector(this.collapseField,\n                                             this.groupHeadSelector,\n                                             this.sortSpec,\n                                             this.nullPolicy,\n                                             this.hint,\n                                             this.needsScores,\n                                             this.size,\n                                             boostDocsMap,\n                                             searcher);\n\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89261f2e2f1daac6de850bf45b31f5b8d3573f29","date":1537189734,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","sourceNew":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        CollectorFactory collectorFactory = new CollectorFactory();\n        //Deal with boosted docs.\n        //We have to deal with it here rather then the constructor because\n        //because the QueryElevationComponent runs after the Queries are constructed.\n\n        IntIntHashMap boostDocsMap = null;\n        Map context = null;\n        SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        if(info != null) {\n          context = info.getReq().getContext();\n        }\n\n        if(this.boosted == null && context != null) {\n          this.boosted = (Set<BytesRef>)context.get(QueryElevationComponent.BOOSTED);\n        }\n\n        boostDocsMap = QueryElevationComponent.getBoostDocs(searcher, this.boosted, context);\n        return collectorFactory.getCollector(this.collapseField,\n                                             this.groupHeadSelector,\n                                             this.sortSpec,\n                                             this.nullPolicy,\n                                             this.hint,\n                                             this.needsScores,\n                                             this.size,\n                                             boostDocsMap,\n                                             searcher);\n\n      } catch (SolrException e) {\n        // handle SolrException separately\n        throw e;\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        CollectorFactory collectorFactory = new CollectorFactory();\n        //Deal with boosted docs.\n        //We have to deal with it here rather then the constructor because\n        //because the QueryElevationComponent runs after the Queries are constructed.\n\n        IntIntHashMap boostDocsMap = null;\n        Map context = null;\n        SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        if(info != null) {\n          context = info.getReq().getContext();\n        }\n\n        if(this.boosted == null && context != null) {\n          this.boosted = (Set<BytesRef>)context.get(QueryElevationComponent.BOOSTED);\n        }\n\n        boostDocsMap = QueryElevationComponent.getBoostDocs(searcher, this.boosted, context);\n        return collectorFactory.getCollector(this.collapseField,\n                                             this.groupHeadSelector,\n                                             this.sortSpec,\n                                             this.nullPolicy,\n                                             this.hint,\n                                             this.needsScores,\n                                             this.size,\n                                             boostDocsMap,\n                                             searcher);\n\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":["432fdfa612cbca5b4cf9125a2c6aa055cd53cadb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"446ec69a32a7e8cb8bf6eb8be693e96ab5f5a0d3","date":1556831715,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","sourceNew":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        CollectorFactory collectorFactory = new CollectorFactory();\n        //Deal with boosted docs.\n        //We have to deal with it here rather then the constructor because\n        //because the QueryElevationComponent runs after the Queries are constructed.\n\n        IntIntHashMap boostDocsMap = null;\n        Map context = null;\n        SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        if(info != null) {\n          context = info.getReq().getContext();\n        }\n\n        if(this.boosted == null && context != null) {\n          this.boosted = (Set<BytesRef>)context.get(QueryElevationComponent.BOOSTED);\n        }\n\n        boostDocsMap = QueryElevationComponent.getBoostDocs(searcher, this.boosted, context);\n        return collectorFactory.getCollector(this.collapseField,\n                                             this.groupHeadSelector,\n                                             this.sortSpec,\n                                             this.nullPolicy,\n                                             this.hint,\n                                             this.needsScores4Collapsing,\n                                             this.needsScores,\n                                             this.size,\n                                             boostDocsMap,\n                                             searcher);\n\n      } catch (SolrException e) {\n        // handle SolrException separately\n        throw e;\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        CollectorFactory collectorFactory = new CollectorFactory();\n        //Deal with boosted docs.\n        //We have to deal with it here rather then the constructor because\n        //because the QueryElevationComponent runs after the Queries are constructed.\n\n        IntIntHashMap boostDocsMap = null;\n        Map context = null;\n        SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        if(info != null) {\n          context = info.getReq().getContext();\n        }\n\n        if(this.boosted == null && context != null) {\n          this.boosted = (Set<BytesRef>)context.get(QueryElevationComponent.BOOSTED);\n        }\n\n        boostDocsMap = QueryElevationComponent.getBoostDocs(searcher, this.boosted, context);\n        return collectorFactory.getCollector(this.collapseField,\n                                             this.groupHeadSelector,\n                                             this.sortSpec,\n                                             this.nullPolicy,\n                                             this.hint,\n                                             this.needsScores,\n                                             this.size,\n                                             boostDocsMap,\n                                             searcher);\n\n      } catch (SolrException e) {\n        // handle SolrException separately\n        throw e;\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"432fdfa612cbca5b4cf9125a2c6aa055cd53cadb","date":1561824429,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","sourceNew":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        CollectorFactory collectorFactory = new CollectorFactory();\n        //Deal with boosted docs.\n        //We have to deal with it here rather then the constructor because\n        //because the QueryElevationComponent runs after the Queries are constructed.\n\n        IntIntHashMap boostDocsMap = null;\n        Map context = null;\n        SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        if(info != null) {\n          context = info.getReq().getContext();\n        }\n\n        if(this.boosted == null && context != null) {\n          this.boosted = (Set<BytesRef>)context.get(QueryElevationComponent.BOOSTED);\n        }\n\n        boostDocsMap = QueryElevationComponent.getBoostDocs(searcher, this.boosted, context);\n        return collectorFactory.getCollector(this.collapseField,\n                                             this.groupHeadSelector,\n                                             this.sortSpec,\n                                             this.nullPolicy,\n                                             this.hint,\n                                             this.needsScores4Collapsing,\n                                             this.needsScores,\n                                             this.size,\n                                             boostDocsMap,\n                                             searcher);\n\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        CollectorFactory collectorFactory = new CollectorFactory();\n        //Deal with boosted docs.\n        //We have to deal with it here rather then the constructor because\n        //because the QueryElevationComponent runs after the Queries are constructed.\n\n        IntIntHashMap boostDocsMap = null;\n        Map context = null;\n        SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        if(info != null) {\n          context = info.getReq().getContext();\n        }\n\n        if(this.boosted == null && context != null) {\n          this.boosted = (Set<BytesRef>)context.get(QueryElevationComponent.BOOSTED);\n        }\n\n        boostDocsMap = QueryElevationComponent.getBoostDocs(searcher, this.boosted, context);\n        return collectorFactory.getCollector(this.collapseField,\n                                             this.groupHeadSelector,\n                                             this.sortSpec,\n                                             this.nullPolicy,\n                                             this.hint,\n                                             this.needsScores4Collapsing,\n                                             this.needsScores,\n                                             this.size,\n                                             boostDocsMap,\n                                             searcher);\n\n      } catch (SolrException e) {\n        // handle SolrException separately\n        throw e;\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":["c1a89fbf5a750bffb59fe3bf0779dd9fb5ee0c4d","89261f2e2f1daac6de850bf45b31f5b8d3573f29"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"50dfd19525c8d73e856dca6edb64b7aea074037f","date":1591579225,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","sourceNew":"    @SuppressWarnings({\"unchecked\"})\n    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        CollectorFactory collectorFactory = new CollectorFactory();\n        //Deal with boosted docs.\n        //We have to deal with it here rather then the constructor because\n        //because the QueryElevationComponent runs after the Queries are constructed.\n\n        IntIntHashMap boostDocsMap = null;\n        @SuppressWarnings({\"rawtypes\"})\n        Map context = null;\n        SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        if(info != null) {\n          context = info.getReq().getContext();\n        }\n\n        if(this.boosted == null && context != null) {\n          this.boosted = (Set<BytesRef>)context.get(QueryElevationComponent.BOOSTED);\n        }\n\n        boostDocsMap = QueryElevationComponent.getBoostDocs(searcher, this.boosted, context);\n        return collectorFactory.getCollector(this.collapseField,\n                                             this.groupHeadSelector,\n                                             this.sortSpec,\n                                             this.nullPolicy,\n                                             this.hint,\n                                             this.needsScores4Collapsing,\n                                             this.needsScores,\n                                             this.size,\n                                             boostDocsMap,\n                                             searcher);\n\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        CollectorFactory collectorFactory = new CollectorFactory();\n        //Deal with boosted docs.\n        //We have to deal with it here rather then the constructor because\n        //because the QueryElevationComponent runs after the Queries are constructed.\n\n        IntIntHashMap boostDocsMap = null;\n        Map context = null;\n        SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        if(info != null) {\n          context = info.getReq().getContext();\n        }\n\n        if(this.boosted == null && context != null) {\n          this.boosted = (Set<BytesRef>)context.get(QueryElevationComponent.BOOSTED);\n        }\n\n        boostDocsMap = QueryElevationComponent.getBoostDocs(searcher, this.boosted, context);\n        return collectorFactory.getCollector(this.collapseField,\n                                             this.groupHeadSelector,\n                                             this.sortSpec,\n                                             this.nullPolicy,\n                                             this.hint,\n                                             this.needsScores4Collapsing,\n                                             this.needsScores,\n                                             this.size,\n                                             boostDocsMap,\n                                             searcher);\n\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a813b523bf76aa0a68013d636b6eb53cedb142a4","date":1601387389,"type":3,"author":"Guna Sekhar Dora Kovvuru","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollapsingPostFilter#getFilterCollector(IndexSearcher).mjava","sourceNew":"    @SuppressWarnings({\"unchecked\"})\n    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        CollectorFactory collectorFactory = new CollectorFactory();\n        //Deal with boosted docs.\n        //We have to deal with it here rather then the constructor because\n        //because the QueryElevationComponent runs after the Queries are constructed.\n\n        IntIntHashMap boostDocsMap = null;\n        @SuppressWarnings({\"rawtypes\"})\n        Map context = null;\n        SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        if(info != null) {\n          context = info.getReq().getContext();\n        }\n\n        if(this.boosted == null && context != null) {\n          this.boosted = (Set<BytesRef>)context.get(QueryElevationComponent.BOOSTED);\n        }\n\n        boostDocsMap = QueryElevationComponent.getBoostDocs(searcher, this.boosted, context);\n        return collectorFactory.getCollector(this.collapseField,\n                                             this.groupHeadSelector,\n                                             this.sortSpec,\n                                             this.nullPolicy.getCode(),\n                                             this.hint,\n                                             this.needsScores4Collapsing,\n                                             this.needsScores,\n                                             this.size,\n                                             boostDocsMap,\n                                             searcher);\n\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @SuppressWarnings({\"unchecked\"})\n    public DelegatingCollector getFilterCollector(IndexSearcher indexSearcher) {\n      try {\n\n        SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;\n        CollectorFactory collectorFactory = new CollectorFactory();\n        //Deal with boosted docs.\n        //We have to deal with it here rather then the constructor because\n        //because the QueryElevationComponent runs after the Queries are constructed.\n\n        IntIntHashMap boostDocsMap = null;\n        @SuppressWarnings({\"rawtypes\"})\n        Map context = null;\n        SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n        if(info != null) {\n          context = info.getReq().getContext();\n        }\n\n        if(this.boosted == null && context != null) {\n          this.boosted = (Set<BytesRef>)context.get(QueryElevationComponent.BOOSTED);\n        }\n\n        boostDocsMap = QueryElevationComponent.getBoostDocs(searcher, this.boosted, context);\n        return collectorFactory.getCollector(this.collapseField,\n                                             this.groupHeadSelector,\n                                             this.sortSpec,\n                                             this.nullPolicy,\n                                             this.hint,\n                                             this.needsScores4Collapsing,\n                                             this.needsScores,\n                                             this.size,\n                                             boostDocsMap,\n                                             searcher);\n\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"224952d10f823935a2a836d4072cb5bd6ac33e3e":["10e22ca394550f9249a31b316dcf1cf70408da17"],"89261f2e2f1daac6de850bf45b31f5b8d3573f29":["2ad458affd82a1d762eb506003907d9363a333cb"],"56572ec06f1407c066d6b7399413178b33176cd8":["ae73da626f97850c922c42736f808d0378e165f0","93dd449115a9247533e44bab47e8429e5dccbc6d"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["a667f95e8b4d25c8e45a6bb9ba8ce9654e7858d7"],"a813b523bf76aa0a68013d636b6eb53cedb142a4":["50dfd19525c8d73e856dca6edb64b7aea074037f"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["0325de99180d346d61d36938843a5c8451fe26ae","2ad458affd82a1d762eb506003907d9363a333cb"],"8ced52befdc8d88d90766aadbaac496f3fd0e4ee":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":["224952d10f823935a2a836d4072cb5bd6ac33e3e","ae73da626f97850c922c42736f808d0378e165f0"],"51e87f816b84771636e67fc67039925030ebe671":["ceae51e37bbff02dcdeaa12303fec10d3eaaa004"],"c1a89fbf5a750bffb59fe3bf0779dd9fb5ee0c4d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2ad458affd82a1d762eb506003907d9363a333cb":["0325de99180d346d61d36938843a5c8451fe26ae"],"0325de99180d346d61d36938843a5c8451fe26ae":["1fcee2c3acd9aa64a73a3b441b3f6cb492af0b87"],"ceae51e37bbff02dcdeaa12303fec10d3eaaa004":["c1a89fbf5a750bffb59fe3bf0779dd9fb5ee0c4d"],"e28b14e7783d24ca69089f13ddadadbd2afdcb29":["ae73da626f97850c922c42736f808d0378e165f0"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["0325de99180d346d61d36938843a5c8451fe26ae","2ad458affd82a1d762eb506003907d9363a333cb"],"432fdfa612cbca5b4cf9125a2c6aa055cd53cadb":["446ec69a32a7e8cb8bf6eb8be693e96ab5f5a0d3"],"10e22ca394550f9249a31b316dcf1cf70408da17":["6f9eac2f0b568b3694682edb863185a273fbbc6f"],"446ec69a32a7e8cb8bf6eb8be693e96ab5f5a0d3":["89261f2e2f1daac6de850bf45b31f5b8d3573f29"],"a667f95e8b4d25c8e45a6bb9ba8ce9654e7858d7":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"50dfd19525c8d73e856dca6edb64b7aea074037f":["432fdfa612cbca5b4cf9125a2c6aa055cd53cadb"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["ae73da626f97850c922c42736f808d0378e165f0","e28b14e7783d24ca69089f13ddadadbd2afdcb29"],"ae73da626f97850c922c42736f808d0378e165f0":["224952d10f823935a2a836d4072cb5bd6ac33e3e"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["c1a89fbf5a750bffb59fe3bf0779dd9fb5ee0c4d","ceae51e37bbff02dcdeaa12303fec10d3eaaa004"],"6f9eac2f0b568b3694682edb863185a273fbbc6f":["51e87f816b84771636e67fc67039925030ebe671"],"1fcee2c3acd9aa64a73a3b441b3f6cb492af0b87":["8ced52befdc8d88d90766aadbaac496f3fd0e4ee"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a813b523bf76aa0a68013d636b6eb53cedb142a4"]},"commit2Childs":{"224952d10f823935a2a836d4072cb5bd6ac33e3e":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","ae73da626f97850c922c42736f808d0378e165f0"],"89261f2e2f1daac6de850bf45b31f5b8d3573f29":["446ec69a32a7e8cb8bf6eb8be693e96ab5f5a0d3"],"56572ec06f1407c066d6b7399413178b33176cd8":[],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["8ced52befdc8d88d90766aadbaac496f3fd0e4ee"],"a813b523bf76aa0a68013d636b6eb53cedb142a4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"8ced52befdc8d88d90766aadbaac496f3fd0e4ee":["1fcee2c3acd9aa64a73a3b441b3f6cb492af0b87"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":[],"51e87f816b84771636e67fc67039925030ebe671":["6f9eac2f0b568b3694682edb863185a273fbbc6f"],"c1a89fbf5a750bffb59fe3bf0779dd9fb5ee0c4d":["ceae51e37bbff02dcdeaa12303fec10d3eaaa004","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c1a89fbf5a750bffb59fe3bf0779dd9fb5ee0c4d"],"2ad458affd82a1d762eb506003907d9363a333cb":["89261f2e2f1daac6de850bf45b31f5b8d3573f29","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"0325de99180d346d61d36938843a5c8451fe26ae":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","2ad458affd82a1d762eb506003907d9363a333cb","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"ceae51e37bbff02dcdeaa12303fec10d3eaaa004":["51e87f816b84771636e67fc67039925030ebe671","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"e28b14e7783d24ca69089f13ddadadbd2afdcb29":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[],"432fdfa612cbca5b4cf9125a2c6aa055cd53cadb":["50dfd19525c8d73e856dca6edb64b7aea074037f"],"10e22ca394550f9249a31b316dcf1cf70408da17":["224952d10f823935a2a836d4072cb5bd6ac33e3e"],"446ec69a32a7e8cb8bf6eb8be693e96ab5f5a0d3":["432fdfa612cbca5b4cf9125a2c6aa055cd53cadb"],"a667f95e8b4d25c8e45a6bb9ba8ce9654e7858d7":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["56572ec06f1407c066d6b7399413178b33176cd8","a667f95e8b4d25c8e45a6bb9ba8ce9654e7858d7"],"50dfd19525c8d73e856dca6edb64b7aea074037f":["a813b523bf76aa0a68013d636b6eb53cedb142a4"],"ae73da626f97850c922c42736f808d0378e165f0":["56572ec06f1407c066d6b7399413178b33176cd8","15e323346eac5e4685c0a9f2df85eb96b4239bbb","e28b14e7783d24ca69089f13ddadadbd2afdcb29","93dd449115a9247533e44bab47e8429e5dccbc6d"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"6f9eac2f0b568b3694682edb863185a273fbbc6f":["10e22ca394550f9249a31b316dcf1cf70408da17"],"1fcee2c3acd9aa64a73a3b441b3f6cb492af0b87":["0325de99180d346d61d36938843a5c8451fe26ae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["56572ec06f1407c066d6b7399413178b33176cd8","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","15e323346eac5e4685c0a9f2df85eb96b4239bbb","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}