{"path":"solr/core/src/java/org/apache/solr/handler/component/PhrasesIdentificationComponent.PhrasesContextData#PhrasesContextData(SolrQueryRequest).mjava","commits":[{"id":"0d1411e62d30c460b09c6f3643df82daa10a27cc","date":1536256256,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PhrasesIdentificationComponent.PhrasesContextData#PhrasesContextData(SolrQueryRequest).mjava","pathOld":"/dev/null","sourceNew":"    private PhrasesContextData(final SolrQueryRequest req) throws SolrException {\n      final SolrParams params = req.getParams();\n\n      this.rawInput = params.get(PHRASE_INPUT, params.get(CommonParams.Q));\n      if (null == this.rawInput) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"phrase identification requires a query string or \"\n                                + PHRASE_INPUT + \" param override\");\n      }\n\n      { // field weights & analysis field...\n        \n        SchemaField tmpAnalysisField = null;\n        Map<String,Double> tmpWeights = new TreeMap<>();\n        \n        final String analysisFieldName = params.get(PHRASE_ANALYSIS_FIELD);\n        if (null != analysisFieldName) {\n          tmpAnalysisField = req.getSchema().getFieldOrNull(analysisFieldName);\n          if (null == tmpAnalysisField) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\n                                    PHRASE_ANALYSIS_FIELD + \" param specifies a field name that does not exist: \" +\n                                    analysisFieldName);\n          }\n        }\n        \n        final Map<String,Float> rawFields = SolrPluginUtils.parseFieldBoosts(params.getParams(PHRASE_FIELDS));\n        if (rawFields.isEmpty()) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n                                  PHRASE_FIELDS + \" param must specify a (weighted) list of fields \" +\n                                  \"to evaluate for phrase identification\");\n        }\n        \n        for (Map.Entry<String,Float> entry : rawFields.entrySet()) {\n          final SchemaField field = req.getSchema().getFieldOrNull(entry.getKey());\n          if (null == field) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n                                  PHRASE_FIELDS + \" param contains a field name that does not exist: \" +\n                                  entry.getKey());\n          }\n          if (null == tmpAnalysisField) {\n            tmpAnalysisField = field;\n          }\n          if ( null == analysisFieldName ) {\n            if (! field.getType().equals(tmpAnalysisField.getType())) {\n              throw new SolrException\n                (ErrorCode.BAD_REQUEST,\n                 \"All fields specified in \" + PHRASE_FIELDS + \" must have the same fieldType, \" +\n                 \"or the advanced \" + PHRASE_ANALYSIS_FIELD + \" option must specify an override\");\n            }\n          }\n          // if a weight isn't specified, assume \"1.0\" \n          final double weight = null == entry.getValue() ? 1.0D : entry.getValue();\n          if (weight < 0) {\n            throw new SolrException(ErrorCode.BAD_REQUEST,\n                                    PHRASE_FIELDS + \" param must use non-negative weight value for field \" + field.getName());\n          }\n          tmpWeights.put(entry.getKey(), weight);\n        }\n        assert null != tmpAnalysisField;\n        \n        this.analysisField = tmpAnalysisField;\n        this.fieldWeights = Collections.unmodifiableMap(tmpWeights);\n      }\n\n      { // index/query max phrase sizes...\n        final FieldType ft = analysisField.getType();\n        this.maxIndexedPositionLength = req.getParams().getInt(PHRASE_INDEX_MAXLEN,\n                                                               getMaxShingleSize(ft.getIndexAnalyzer()));\n        if (this.maxIndexedPositionLength < 0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n                                  \"Unable to determine max position length of indexed phrases using \" +\n                                  \"index analyzer for analysis field: \" + analysisField.getName() +\n                                  \" and no override detected using param: \" + PHRASE_INDEX_MAXLEN);\n        }\n        this.maxQueryPositionLength = req.getParams().getInt(PHRASE_QUERY_MAXLEN,\n                                                             getMaxShingleSize(ft.getQueryAnalyzer()));\n        if (this.maxQueryPositionLength < 0) {\n          throw new SolrException(ErrorCode.BAD_REQUEST,\n                                  \"Unable to determine max position length of query phrases using \" +\n                                  \"query analyzer for analysis field: \" + analysisField.getName() +\n                                  \" and no override detected using param: \" + PHRASE_QUERY_MAXLEN);\n        }\n        if (this.maxQueryPositionLength < this.maxIndexedPositionLength) {\n          throw new SolrException\n            (ErrorCode.BAD_REQUEST,\n             \"Effective value of \" + PHRASE_INDEX_MAXLEN + \" (either from index analyzer shingle factory, \" +\n             \" or expert param override) must be less then or equal to the effective value of \" +\n             PHRASE_QUERY_MAXLEN + \" (either from query analyzer shingle factory, or expert param override)\");\n        }\n      }\n      \n      this.summaryPre = params.get(PHRASE_SUMMARY_PRE, \"{\");\n      this.summaryPost = params.get(PHRASE_SUMMARY_POST, \"}\");\n\n      this.allPhrases = Phrase.extractPhrases(this.rawInput, this.analysisField,\n                                              this.maxIndexedPositionLength,\n                                              this.maxQueryPositionLength);\n        \n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0d1411e62d30c460b09c6f3643df82daa10a27cc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0d1411e62d30c460b09c6f3643df82daa10a27cc"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0d1411e62d30c460b09c6f3643df82daa10a27cc"],"0d1411e62d30c460b09c6f3643df82daa10a27cc":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}