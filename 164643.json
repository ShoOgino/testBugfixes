{"path":"src/java/org/apache/solr/handler/DocumentAnalysisRequestHandler#handleAnalysisRequest(DocumentAnalysisRequest,IndexSchema).mjava","commits":[{"id":"68df8db3f6c0c0ebbd1e40ba638115a748fb6a2a","date":1240390408,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/DocumentAnalysisRequestHandler#handleAnalysisRequest(DocumentAnalysisRequest,IndexSchema).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Handles the resolved {@link DocumentAnalysisRequest} and returns the analysis response as a named list.\n   *\n   * @param request The {@link DocumentAnalysisRequest} to be handled.\n   * @param schema  The index schema.\n   *\n   * @return The analysis response as a named list.\n   */\n  NamedList<Object> handleAnalysisRequest(DocumentAnalysisRequest request, IndexSchema schema) {\n\n    SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    NamedList<Object> result = new SimpleOrderedMap<Object>();\n\n    for (SolrInputDocument document : request.getDocuments()) {\n\n      NamedList<NamedList> theTokens = new SimpleOrderedMap<NamedList>();\n      result.add(document.getFieldValue(uniqueKeyField.getName()).toString(), theTokens);\n      for (String name : document.getFieldNames()) {\n\n        // there's no point of providing analysis to unindexed fields.\n        SchemaField field = schema.getField(name);\n        if (!field.indexed()) {\n          continue;\n        }\n\n        NamedList<Object> fieldTokens = new SimpleOrderedMap<Object>();\n        theTokens.add(name, fieldTokens);\n\n        FieldType fieldType = schema.getFieldType(name);\n\n        Set<String> termsToMatch = new HashSet<String>();\n        if (request.getQuery() != null && request.isShowMatch()) {\n          List<Token> tokens = analyzeValue(request.getQuery(), fieldType.getQueryAnalyzer());\n          for (Token token : tokens) {\n            termsToMatch.add(token.term());\n          }\n        }\n\n        if (request.getQuery() != null) {\n          AnalysisContext analysisContext = new AnalysisContext(fieldType, fieldType.getQueryAnalyzer(), Collections.EMPTY_SET);\n          NamedList<List<NamedList>> tokens = analyzeValue(request.getQuery(), analysisContext);\n          fieldTokens.add(\"query\", tokens);\n        }\n\n        Analyzer analyzer = fieldType.getAnalyzer();\n        AnalysisContext analysisContext = new AnalysisContext(fieldType, analyzer, termsToMatch);\n        Collection<Object> fieldValues = document.getFieldValues(name);\n        NamedList<NamedList<List<NamedList>>> indexTokens = new SimpleOrderedMap<NamedList<List<NamedList>>>();\n        for (Object fieldValue : fieldValues) {\n          NamedList<List<NamedList>> tokens = analyzeValue(fieldValue.toString(), analysisContext);\n          indexTokens.add(String.valueOf(fieldValue), tokens);\n        }\n        fieldTokens.add(\"index\", indexTokens);\n      }\n    }\n\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["27be4bdc55e85b001df476616dc1f6e68c3148e6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"27be4bdc55e85b001df476616dc1f6e68c3148e6","date":1249587040,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/DocumentAnalysisRequestHandler#handleAnalysisRequest(DocumentAnalysisRequest,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/handler/DocumentAnalysisRequestHandler#handleAnalysisRequest(DocumentAnalysisRequest,IndexSchema).mjava","sourceNew":"  /**\n   * Handles the resolved {@link DocumentAnalysisRequest} and returns the analysis response as a named list.\n   *\n   * @param request The {@link DocumentAnalysisRequest} to be handled.\n   * @param schema  The index schema.\n   *\n   * @return The analysis response as a named list.\n   */\n  NamedList<Object> handleAnalysisRequest(DocumentAnalysisRequest request, IndexSchema schema) {\n\n    SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    NamedList<Object> result = new SimpleOrderedMap<Object>();\n\n    for (SolrInputDocument document : request.getDocuments()) {\n\n      NamedList<NamedList> theTokens = new SimpleOrderedMap<NamedList>();\n      result.add(document.getFieldValue(uniqueKeyField.getName()).toString(), theTokens);\n      for (String name : document.getFieldNames()) {\n\n        // there's no point of providing analysis to unindexed fields.\n        SchemaField field = schema.getField(name);\n        if (!field.indexed()) {\n          continue;\n        }\n\n        NamedList<Object> fieldTokens = new SimpleOrderedMap<Object>();\n        theTokens.add(name, fieldTokens);\n\n        FieldType fieldType = schema.getFieldType(name);\n\n        Set<String> termsToMatch = new HashSet<String>();\n        if (request.getQuery() != null && request.isShowMatch()) {\n          try {\n            List<Token> tokens = analyzeValue(request.getQuery(), fieldType.getQueryAnalyzer());\n            for (Token token : tokens) {\n              termsToMatch.add(token.term());\n            }\n          } catch (Exception e) {\n            // ignore analysis exceptions since we are applying arbitrary text to all fields\n          }\n        }\n\n        if (request.getQuery() != null) {\n          try {\n            AnalysisContext analysisContext = new AnalysisContext(fieldType, fieldType.getQueryAnalyzer(), Collections.EMPTY_SET);\n            NamedList<List<NamedList>> tokens = analyzeValue(request.getQuery(), analysisContext);\n            fieldTokens.add(\"query\", tokens);\n          } catch (Exception e) {\n            // ignore analysis exceptions since we are applying arbitrary text to all fields\n          }\n        }\n\n        Analyzer analyzer = fieldType.getAnalyzer();\n        AnalysisContext analysisContext = new AnalysisContext(fieldType, analyzer, termsToMatch);\n        Collection<Object> fieldValues = document.getFieldValues(name);\n        NamedList<NamedList<List<NamedList>>> indexTokens = new SimpleOrderedMap<NamedList<List<NamedList>>>();\n        for (Object fieldValue : fieldValues) {\n          NamedList<List<NamedList>> tokens = analyzeValue(fieldValue.toString(), analysisContext);\n          indexTokens.add(String.valueOf(fieldValue), tokens);\n        }\n        fieldTokens.add(\"index\", indexTokens);\n      }\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Handles the resolved {@link DocumentAnalysisRequest} and returns the analysis response as a named list.\n   *\n   * @param request The {@link DocumentAnalysisRequest} to be handled.\n   * @param schema  The index schema.\n   *\n   * @return The analysis response as a named list.\n   */\n  NamedList<Object> handleAnalysisRequest(DocumentAnalysisRequest request, IndexSchema schema) {\n\n    SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    NamedList<Object> result = new SimpleOrderedMap<Object>();\n\n    for (SolrInputDocument document : request.getDocuments()) {\n\n      NamedList<NamedList> theTokens = new SimpleOrderedMap<NamedList>();\n      result.add(document.getFieldValue(uniqueKeyField.getName()).toString(), theTokens);\n      for (String name : document.getFieldNames()) {\n\n        // there's no point of providing analysis to unindexed fields.\n        SchemaField field = schema.getField(name);\n        if (!field.indexed()) {\n          continue;\n        }\n\n        NamedList<Object> fieldTokens = new SimpleOrderedMap<Object>();\n        theTokens.add(name, fieldTokens);\n\n        FieldType fieldType = schema.getFieldType(name);\n\n        Set<String> termsToMatch = new HashSet<String>();\n        if (request.getQuery() != null && request.isShowMatch()) {\n          List<Token> tokens = analyzeValue(request.getQuery(), fieldType.getQueryAnalyzer());\n          for (Token token : tokens) {\n            termsToMatch.add(token.term());\n          }\n        }\n\n        if (request.getQuery() != null) {\n          AnalysisContext analysisContext = new AnalysisContext(fieldType, fieldType.getQueryAnalyzer(), Collections.EMPTY_SET);\n          NamedList<List<NamedList>> tokens = analyzeValue(request.getQuery(), analysisContext);\n          fieldTokens.add(\"query\", tokens);\n        }\n\n        Analyzer analyzer = fieldType.getAnalyzer();\n        AnalysisContext analysisContext = new AnalysisContext(fieldType, analyzer, termsToMatch);\n        Collection<Object> fieldValues = document.getFieldValues(name);\n        NamedList<NamedList<List<NamedList>>> indexTokens = new SimpleOrderedMap<NamedList<List<NamedList>>>();\n        for (Object fieldValue : fieldValues) {\n          NamedList<List<NamedList>> tokens = analyzeValue(fieldValue.toString(), analysisContext);\n          indexTokens.add(String.valueOf(fieldValue), tokens);\n        }\n        fieldTokens.add(\"index\", indexTokens);\n      }\n    }\n\n    return result;\n  }\n\n","bugFix":["68df8db3f6c0c0ebbd1e40ba638115a748fb6a2a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/DocumentAnalysisRequestHandler#handleAnalysisRequest(DocumentAnalysisRequest,IndexSchema).mjava","pathOld":"src/java/org/apache/solr/handler/DocumentAnalysisRequestHandler#handleAnalysisRequest(DocumentAnalysisRequest,IndexSchema).mjava","sourceNew":"  /**\n   * Handles the resolved {@link DocumentAnalysisRequest} and returns the analysis response as a named list.\n   *\n   * @param request The {@link DocumentAnalysisRequest} to be handled.\n   * @param schema  The index schema.\n   *\n   * @return The analysis response as a named list.\n   */\n  NamedList<Object> handleAnalysisRequest(DocumentAnalysisRequest request, IndexSchema schema) {\n\n    SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    NamedList<Object> result = new SimpleOrderedMap<Object>();\n\n    for (SolrInputDocument document : request.getDocuments()) {\n\n      NamedList<NamedList> theTokens = new SimpleOrderedMap<NamedList>();\n      result.add(document.getFieldValue(uniqueKeyField.getName()).toString(), theTokens);\n      for (String name : document.getFieldNames()) {\n\n        // there's no point of providing analysis to unindexed fields.\n        SchemaField field = schema.getField(name);\n        if (!field.indexed()) {\n          continue;\n        }\n\n        NamedList<Object> fieldTokens = new SimpleOrderedMap<Object>();\n        theTokens.add(name, fieldTokens);\n\n        FieldType fieldType = schema.getFieldType(name);\n\n        Set<String> termsToMatch = new HashSet<String>();\n        if (request.getQuery() != null && request.isShowMatch()) {\n          try {\n            List<Token> tokens = analyzeValue(request.getQuery(), fieldType.getQueryAnalyzer());\n            for (Token token : tokens) {\n              termsToMatch.add(token.term());\n            }\n          } catch (Exception e) {\n            // ignore analysis exceptions since we are applying arbitrary text to all fields\n          }\n        }\n\n        if (request.getQuery() != null) {\n          try {\n            AnalysisContext analysisContext = new AnalysisContext(fieldType, fieldType.getQueryAnalyzer(), Collections.EMPTY_SET);\n            NamedList<List<NamedList>> tokens = analyzeValue(request.getQuery(), analysisContext);\n            fieldTokens.add(\"query\", tokens);\n          } catch (Exception e) {\n            // ignore analysis exceptions since we are applying arbitrary text to all fields\n          }\n        }\n\n        Analyzer analyzer = fieldType.getAnalyzer();\n        AnalysisContext analysisContext = new AnalysisContext(fieldType, analyzer, termsToMatch);\n        Collection<Object> fieldValues = document.getFieldValues(name);\n        NamedList<NamedList<List<NamedList>>> indexTokens = new SimpleOrderedMap<NamedList<List<NamedList>>>();\n        for (Object fieldValue : fieldValues) {\n          NamedList<List<NamedList>> tokens = analyzeValue(fieldValue.toString(), analysisContext);\n          indexTokens.add(String.valueOf(fieldValue), tokens);\n        }\n        fieldTokens.add(\"index\", indexTokens);\n      }\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Handles the resolved {@link DocumentAnalysisRequest} and returns the analysis response as a named list.\n   *\n   * @param request The {@link DocumentAnalysisRequest} to be handled.\n   * @param schema  The index schema.\n   *\n   * @return The analysis response as a named list.\n   */\n  NamedList<Object> handleAnalysisRequest(DocumentAnalysisRequest request, IndexSchema schema) {\n\n    SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    NamedList<Object> result = new SimpleOrderedMap<Object>();\n\n    for (SolrInputDocument document : request.getDocuments()) {\n\n      NamedList<NamedList> theTokens = new SimpleOrderedMap<NamedList>();\n      result.add(document.getFieldValue(uniqueKeyField.getName()).toString(), theTokens);\n      for (String name : document.getFieldNames()) {\n\n        // there's no point of providing analysis to unindexed fields.\n        SchemaField field = schema.getField(name);\n        if (!field.indexed()) {\n          continue;\n        }\n\n        NamedList<Object> fieldTokens = new SimpleOrderedMap<Object>();\n        theTokens.add(name, fieldTokens);\n\n        FieldType fieldType = schema.getFieldType(name);\n\n        Set<String> termsToMatch = new HashSet<String>();\n        if (request.getQuery() != null && request.isShowMatch()) {\n          try {\n            List<Token> tokens = analyzeValue(request.getQuery(), fieldType.getQueryAnalyzer());\n            for (Token token : tokens) {\n              termsToMatch.add(token.term());\n            }\n          } catch (Exception e) {\n            // ignore analysis exceptions since we are applying arbitrary text to all fields\n          }\n        }\n\n        if (request.getQuery() != null) {\n          try {\n            AnalysisContext analysisContext = new AnalysisContext(fieldType, fieldType.getQueryAnalyzer(), Collections.EMPTY_SET);\n            NamedList<List<NamedList>> tokens = analyzeValue(request.getQuery(), analysisContext);\n            fieldTokens.add(\"query\", tokens);\n          } catch (Exception e) {\n            // ignore analysis exceptions since we are applying arbitrary text to all fields\n          }\n        }\n\n        Analyzer analyzer = fieldType.getAnalyzer();\n        AnalysisContext analysisContext = new AnalysisContext(fieldType, analyzer, termsToMatch);\n        Collection<Object> fieldValues = document.getFieldValues(name);\n        NamedList<NamedList<List<NamedList>>> indexTokens = new SimpleOrderedMap<NamedList<List<NamedList>>>();\n        for (Object fieldValue : fieldValues) {\n          NamedList<List<NamedList>> tokens = analyzeValue(fieldValue.toString(), analysisContext);\n          indexTokens.add(String.valueOf(fieldValue), tokens);\n        }\n        fieldTokens.add(\"index\", indexTokens);\n      }\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"68df8db3f6c0c0ebbd1e40ba638115a748fb6a2a":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"ad94625fb8d088209f46650c8097196fec67f00c":["27be4bdc55e85b001df476616dc1f6e68c3148e6"],"27be4bdc55e85b001df476616dc1f6e68c3148e6":["68df8db3f6c0c0ebbd1e40ba638115a748fb6a2a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"68df8db3f6c0c0ebbd1e40ba638115a748fb6a2a":["27be4bdc55e85b001df476616dc1f6e68c3148e6"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["68df8db3f6c0c0ebbd1e40ba638115a748fb6a2a"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"27be4bdc55e85b001df476616dc1f6e68c3148e6":["ad94625fb8d088209f46650c8097196fec67f00c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}