{"path":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/Node#readLocalFileMetaData(String).mjava","commits":[{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/Node#readLocalFileMetaData(String).mjava","pathOld":"/dev/null","sourceNew":"  /** Opens the specified file, reads its identifying information, including file length, full index header (includes the unique segment\n   *  ID) and the full footer (includes checksum), and returns the resulting {@link FileMetaData}.\n   *\n   *  <p>This returns null, logging a message, if there are any problems (the file does not exist, is corrupt, truncated, etc.).</p> */\n  public FileMetaData readLocalFileMetaData(String fileName) throws IOException {\n\n    Map<String,FileMetaData> cache = lastFileMetaData;\n    FileMetaData result;\n    if (cache != null) {\n      // We may already have this file cached from the last NRT point:\n      result = cache.get(fileName);\n    } else {\n      result = null;\n    }\n\n    if (result == null) {\n      // Pull from the filesystem\n      long checksum;\n      long length;\n      byte[] header;\n      byte[] footer;\n      try (IndexInput in = dir.openInput(fileName, IOContext.DEFAULT)) {\n          try {\n            length = in.length();\n            header = CodecUtil.readIndexHeader(in);\n            footer = CodecUtil.readFooter(in);\n            checksum = CodecUtil.retrieveChecksum(in);\n          } catch (EOFException | CorruptIndexException cie) {\n            // File exists but is busted: we must copy it.  This happens when node had crashed, corrupting an un-fsync'd file.  On init we try\n            // to delete such unreferenced files, but virus checker can block that, leaving this bad file.\n            if (VERBOSE_FILES) {\n              message(\"file \" + fileName + \": will copy [existing file is corrupt]\");\n            }\n            return null;\n          }\n          if (VERBOSE_FILES) {\n            message(\"file \" + fileName + \" has length=\" + bytesToString(length));\n          }\n        } catch (FileNotFoundException | NoSuchFileException e) {\n        if (VERBOSE_FILES) {\n          message(\"file \" + fileName + \": will copy [file does not exist]\");\n        }\n        return null;\n      }\n\n      // NOTE: checksum is redundant w/ footer, but we break it out separately because when the bits cross the wire we need direct access to\n      // checksum when copying to catch bit flips:\n      result = new FileMetaData(header, footer, length, checksum);\n    }\n\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/Node#readLocalFileMetaData(String).mjava","pathOld":"/dev/null","sourceNew":"  /** Opens the specified file, reads its identifying information, including file length, full index header (includes the unique segment\n   *  ID) and the full footer (includes checksum), and returns the resulting {@link FileMetaData}.\n   *\n   *  <p>This returns null, logging a message, if there are any problems (the file does not exist, is corrupt, truncated, etc.).</p> */\n  public FileMetaData readLocalFileMetaData(String fileName) throws IOException {\n\n    Map<String,FileMetaData> cache = lastFileMetaData;\n    FileMetaData result;\n    if (cache != null) {\n      // We may already have this file cached from the last NRT point:\n      result = cache.get(fileName);\n    } else {\n      result = null;\n    }\n\n    if (result == null) {\n      // Pull from the filesystem\n      long checksum;\n      long length;\n      byte[] header;\n      byte[] footer;\n      try (IndexInput in = dir.openInput(fileName, IOContext.DEFAULT)) {\n          try {\n            length = in.length();\n            header = CodecUtil.readIndexHeader(in);\n            footer = CodecUtil.readFooter(in);\n            checksum = CodecUtil.retrieveChecksum(in);\n          } catch (EOFException | CorruptIndexException cie) {\n            // File exists but is busted: we must copy it.  This happens when node had crashed, corrupting an un-fsync'd file.  On init we try\n            // to delete such unreferenced files, but virus checker can block that, leaving this bad file.\n            if (VERBOSE_FILES) {\n              message(\"file \" + fileName + \": will copy [existing file is corrupt]\");\n            }\n            return null;\n          }\n          if (VERBOSE_FILES) {\n            message(\"file \" + fileName + \" has length=\" + bytesToString(length));\n          }\n        } catch (FileNotFoundException | NoSuchFileException e) {\n        if (VERBOSE_FILES) {\n          message(\"file \" + fileName + \": will copy [file does not exist]\");\n        }\n        return null;\n      }\n\n      // NOTE: checksum is redundant w/ footer, but we break it out separately because when the bits cross the wire we need direct access to\n      // checksum when copying to catch bit flips:\n      result = new FileMetaData(header, footer, length, checksum);\n    }\n\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"68496c2200e559fb7802f7575427b7a482659afb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["68496c2200e559fb7802f7575427b7a482659afb"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["68496c2200e559fb7802f7575427b7a482659afb","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"68496c2200e559fb7802f7575427b7a482659afb":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["68496c2200e559fb7802f7575427b7a482659afb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}