{"path":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","pathOld":"contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      FakeReader fReader = new FakeReader();\n      MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE.rewrite(fReader, mtq);\n      if (fReader.field != null) {\n        IndexReader ir = getReaderForField(fReader.field);\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      FakeReader fReader = new FakeReader();\n      MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE.rewrite(fReader, mtq);\n      if (fReader.field != null) {\n        IndexReader ir = getReaderForField(fReader.field);\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getReaderForField(mtq.getField());\n        extract(query.rewrite(ir), terms);\n      } else {\n        FakeReader fReader = new FakeReader();\n        MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE.rewrite(fReader, mtq);\n        if (fReader.field != null) {\n          IndexReader ir = getReaderForField(fReader.field);\n          extract(query.rewrite(ir), terms);\n        }\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      FakeReader fReader = new FakeReader();\n      MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE.rewrite(fReader, mtq);\n      if (fReader.field != null) {\n        IndexReader ir = getReaderForField(fReader.field);\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"20cf910d1892b0a0ff8543ec4551b6df2dc3de40","date":1275769896,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getReaderForField(mtq.getField());\n        extract(query.rewrite(ir), terms);\n      }\n      // nocommit is this needed anymore?\n      /*\n      else {\n        FakeReader fReader = new FakeReader();\n        MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE.rewrite(fReader, mtq);\n        if (fReader.field != null) {\n          IndexReader ir = getReaderForField(fReader.field);\n          extract(query.rewrite(ir), terms);\n        }\n      }\n      */\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getReaderForField(mtq.getField());\n        extract(query.rewrite(ir), terms);\n      } else {\n        FakeReader fReader = new FakeReader();\n        MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE.rewrite(fReader, mtq);\n        if (fReader.field != null) {\n          IndexReader ir = getReaderForField(fReader.field);\n          extract(query.rewrite(ir), terms);\n        }\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d7a70709df2f3ba961939504c75098e92da8b99","date":1286120517,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getReaderForField(mtq.getField());\n        extract(query.rewrite(ir), terms);\n      }\n      // nocommit is this needed anymore?\n      /*\n      else {\n        FakeReader fReader = new FakeReader();\n        MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE.rewrite(fReader, mtq);\n        if (fReader.field != null) {\n          IndexReader ir = getReaderForField(fReader.field);\n          extract(query.rewrite(ir), terms);\n        }\n      }\n      */\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getReaderForField(mtq.getField());\n        extract(query.rewrite(ir), terms);\n      }\n      // nocommit is this needed anymore?\n      /*\n      else {\n        FakeReader fReader = new FakeReader();\n        MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE.rewrite(fReader, mtq);\n        if (fReader.field != null) {\n          IndexReader ir = getReaderForField(fReader.field);\n          extract(query.rewrite(ir), terms);\n        }\n      }\n      */\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4ceadc715fa91b2886cc6f8c05025c623b3422fc","date":1287918215,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getReaderForField(mtq.getField());\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getReaderForField(mtq.getField());\n        extract(query.rewrite(ir), terms);\n      }\n      // nocommit is this needed anymore?\n      /*\n      else {\n        FakeReader fReader = new FakeReader();\n        MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE.rewrite(fReader, mtq);\n        if (fReader.field != null) {\n          IndexReader ir = getReaderForField(fReader.field);\n          extract(query.rewrite(ir), terms);\n        }\n      }\n      */\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b12d3e81e0f95a4527b5703953c503f71120ffcc","date":1288080933,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getReaderForField(mtq.getField());\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getReaderForField(mtq.getField());\n        extract(query.rewrite(ir), terms);\n      }\n      // nocommit is this needed anymore?\n      /*\n      else {\n        FakeReader fReader = new FakeReader();\n        MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE.rewrite(fReader, mtq);\n        if (fReader.field != null) {\n          IndexReader ir = getReaderForField(fReader.field);\n          extract(query.rewrite(ir), terms);\n        }\n      }\n      */\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getReaderForField(mtq.getField());\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getReaderForField(mtq.getField());\n        extract(query.rewrite(ir), terms);\n      }\n      // nocommit is this needed anymore?\n      /*\n      else {\n        FakeReader fReader = new FakeReader();\n        MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE.rewrite(fReader, mtq);\n        if (fReader.field != null) {\n          IndexReader ir = getReaderForField(fReader.field);\n          extract(query.rewrite(ir), terms);\n        }\n      }\n      */\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c8323d210478d76a02372693d254b69aac614689","date":1295877066,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getLeafContextForField(mtq.getField()).reader;\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getReaderForField(mtq.getField());\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb9b72f7c3d7827c64dd4ec580ded81778da361d","date":1295897920,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getLeafContextForField(mtq.getField()).reader;\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getReaderForField(mtq.getField());\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getLeafContextForField(mtq.getField()).reader;\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getReaderForField(mtq.getField());\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a00afb46b1a8a7ee8772ebbd41076442006ce5e4","date":1325512163,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getLeafContextForField(mtq.getField()).reader;\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  private void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getLeafContextForField(mtq.getField()).reader;\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["eb9ee9de2835c3956662372b9e2407fe0e0fb731"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7355c699afc4eb0400bbd33c1fc216fe31f5d009","date":1327855787,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getLeafContextForField(mtq.getField()).reader();\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getLeafContextForField(mtq.getField()).reader;\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getLeafContextForField(mtq.getField()).reader();\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getLeafContextForField(mtq.getField()).reader;\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","pathOld":"lucene/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor#extract(Query,Map[String,WeightedSpanTerm]).mjava","sourceNew":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getLeafContextForField(mtq.getField()).reader();\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","sourceOld":"  /**\n   * Fills a <code>Map</code> with <@link WeightedSpanTerm>s using the terms from the supplied <code>Query</code>.\n   * \n   * @param query\n   *          Query to extract Terms from\n   * @param terms\n   *          Map to place created WeightedSpanTerms in\n   * @throws IOException\n   */\n  protected void extract(Query query, Map<String,WeightedSpanTerm> terms) throws IOException {\n    if (query instanceof BooleanQuery) {\n      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();\n\n      for (int i = 0; i < queryClauses.length; i++) {\n        if (!queryClauses[i].isProhibited()) {\n          extract(queryClauses[i].getQuery(), terms);\n        }\n      }\n    } else if (query instanceof PhraseQuery) {\n      PhraseQuery phraseQuery = ((PhraseQuery) query);\n      Term[] phraseQueryTerms = phraseQuery.getTerms();\n      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];\n      for (int i = 0; i < phraseQueryTerms.length; i++) {\n        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);\n      }\n      int slop = phraseQuery.getSlop();\n      int[] positions = phraseQuery.getPositions();\n      // add largest position increment to slop\n      if (positions.length > 0) {\n        int lastPos = positions[0];\n        int largestInc = 0;\n        int sz = positions.length;\n        for (int i = 1; i < sz; i++) {\n          int pos = positions[i];\n          int inc = pos - lastPos;\n          if (inc > largestInc) {\n            largestInc = inc;\n          }\n          lastPos = pos;\n        }\n        if(largestInc > 1) {\n          slop += largestInc;\n        }\n      }\n\n      boolean inorder = false;\n\n      if (slop == 0) {\n        inorder = true;\n      }\n\n      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);\n      sp.setBoost(query.getBoost());\n      extractWeightedSpanTerms(terms, sp);\n    } else if (query instanceof TermQuery) {\n      extractWeightedTerms(terms, query);\n    } else if (query instanceof SpanQuery) {\n      extractWeightedSpanTerms(terms, (SpanQuery) query);\n    } else if (query instanceof FilteredQuery) {\n      extract(((FilteredQuery) query).getQuery(), terms);\n    } else if (query instanceof DisjunctionMaxQuery) {\n      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n        extract(iterator.next(), terms);\n      }\n    } else if (query instanceof MultiTermQuery && expandMultiTermQuery) {\n      MultiTermQuery mtq = ((MultiTermQuery)query);\n      if(mtq.getRewriteMethod() != MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE) {\n        mtq = (MultiTermQuery) mtq.clone();\n        mtq.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);\n        query = mtq;\n      }\n      if (mtq.getField() != null) {\n        IndexReader ir = getLeafContextForField(mtq.getField()).reader();\n        extract(query.rewrite(ir), terms);\n      }\n    } else if (query instanceof MultiPhraseQuery) {\n      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;\n      final List<Term[]> termArrays = mpq.getTermArrays();\n      final int[] positions = mpq.getPositions();\n      if (positions.length > 0) {\n\n        int maxPosition = positions[positions.length - 1];\n        for (int i = 0; i < positions.length - 1; ++i) {\n          if (positions[i] > maxPosition) {\n            maxPosition = positions[i];\n          }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];\n        int distinctPositions = 0;\n\n        for (int i = 0; i < termArrays.size(); ++i) {\n          final Term[] termArray = termArrays.get(i);\n          List<SpanQuery> disjuncts = disjunctLists[positions[i]];\n          if (disjuncts == null) {\n            disjuncts = (disjunctLists[positions[i]] = new ArrayList<SpanQuery>(termArray.length));\n            ++distinctPositions;\n          }\n          for (int j = 0; j < termArray.length; ++j) {\n            disjuncts.add(new SpanTermQuery(termArray[j]));\n          }\n        }\n\n        int positionGaps = 0;\n        int position = 0;\n        final SpanQuery[] clauses = new SpanQuery[distinctPositions];\n        for (int i = 0; i < disjunctLists.length; ++i) {\n          List<SpanQuery> disjuncts = disjunctLists[i];\n          if (disjuncts != null) {\n            clauses[position++] = new SpanOrQuery(disjuncts\n                .toArray(new SpanQuery[disjuncts.size()]));\n          } else {\n            ++positionGaps;\n          }\n        }\n\n        final int slop = mpq.getSlop();\n        final boolean inorder = (slop == 0);\n\n        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);\n        sp.setBoost(query.getBoost());\n        extractWeightedSpanTerms(terms, sp);\n      }\n    }\n    extractUnknownQuery(query, terms);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"c8323d210478d76a02372693d254b69aac614689":["4ceadc715fa91b2886cc6f8c05025c623b3422fc"],"4d7a70709df2f3ba961939504c75098e92da8b99":["20cf910d1892b0a0ff8543ec4551b6df2dc3de40"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"b12d3e81e0f95a4527b5703953c503f71120ffcc":["4d7a70709df2f3ba961939504c75098e92da8b99","4ceadc715fa91b2886cc6f8c05025c623b3422fc"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["20cf910d1892b0a0ff8543ec4551b6df2dc3de40","4ceadc715fa91b2886cc6f8c05025c623b3422fc"],"7355c699afc4eb0400bbd33c1fc216fe31f5d009":["a00afb46b1a8a7ee8772ebbd41076442006ce5e4"],"4ceadc715fa91b2886cc6f8c05025c623b3422fc":["4d7a70709df2f3ba961939504c75098e92da8b99"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["a00afb46b1a8a7ee8772ebbd41076442006ce5e4","7355c699afc4eb0400bbd33c1fc216fe31f5d009"],"a00afb46b1a8a7ee8772ebbd41076442006ce5e4":["c8323d210478d76a02372693d254b69aac614689"],"bb9b72f7c3d7827c64dd4ec580ded81778da361d":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","c8323d210478d76a02372693d254b69aac614689"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["b12d3e81e0f95a4527b5703953c503f71120ffcc","c8323d210478d76a02372693d254b69aac614689"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"20cf910d1892b0a0ff8543ec4551b6df2dc3de40":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"c8323d210478d76a02372693d254b69aac614689":["a00afb46b1a8a7ee8772ebbd41076442006ce5e4","bb9b72f7c3d7827c64dd4ec580ded81778da361d","29ef99d61cda9641b6250bf9567329a6e65f901d"],"4d7a70709df2f3ba961939504c75098e92da8b99":["b12d3e81e0f95a4527b5703953c503f71120ffcc","4ceadc715fa91b2886cc6f8c05025c623b3422fc"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["20cf910d1892b0a0ff8543ec4551b6df2dc3de40"],"b12d3e81e0f95a4527b5703953c503f71120ffcc":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["bb9b72f7c3d7827c64dd4ec580ded81778da361d"],"7355c699afc4eb0400bbd33c1fc216fe31f5d009":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"4ceadc715fa91b2886cc6f8c05025c623b3422fc":["c8323d210478d76a02372693d254b69aac614689","b12d3e81e0f95a4527b5703953c503f71120ffcc","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"a00afb46b1a8a7ee8772ebbd41076442006ce5e4":["7355c699afc4eb0400bbd33c1fc216fe31f5d009","5cab9a86bd67202d20b6adc463008c8e982b070a"],"bb9b72f7c3d7827c64dd4ec580ded81778da361d":[],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"20cf910d1892b0a0ff8543ec4551b6df2dc3de40":["4d7a70709df2f3ba961939504c75098e92da8b99","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["bb9b72f7c3d7827c64dd4ec580ded81778da361d","29ef99d61cda9641b6250bf9567329a6e65f901d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}