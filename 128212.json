{"path":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","commits":[{"id":"74799e1ff172d6be3cf96eb89c15cdbb96bfe0d9","date":1395396517,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs topDocs, int topN) throws IOException {\n    int[] docIDs = new int[topDocs.scoreDocs.length];\n    for(int i=0;i<docIDs.length;i++) {\n      docIDs[i] = topDocs.scoreDocs[i].doc;\n    }\n\n    TopDocs topDocs2 = searcher.search(query, new OnlyDocIDsFilter(docIDs), topDocs.scoreDocs.length);\n\n    // TODO: we could save small young GC cost here if we\n    // cloned the incoming ScoreDoc[], sorted that by doc,\n    // passed that to OnlyDocIDsFilter, sorted 2nd pass\n    // TopDocs by doc, did a merge sort to combine the\n    // scores, and finally re-sorted by the combined score,\n    // but that is sizable added code complexity for minor\n    // GC savings:\n    Map<Integer,Float> newScores = new HashMap<Integer,Float>();\n    for(ScoreDoc sd : topDocs2.scoreDocs) {\n      newScores.put(sd.doc, sd.score);\n    }\n\n    ScoreDoc[] newHits = new ScoreDoc[topDocs.scoreDocs.length];\n    for(int i=0;i<topDocs.scoreDocs.length;i++) {\n      ScoreDoc sd = topDocs.scoreDocs[i];\n      Float newScore = newScores.get(sd.doc);\n      float combinedScore;\n      if (newScore == null) {\n        combinedScore = combine(sd.score, false, 0.0f);\n      } else {\n        combinedScore = combine(sd.score, true, newScore.floatValue());\n      }\n      newHits[i] = new ScoreDoc(sd.doc, combinedScore);\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(newHits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < newHits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(newHits, 0, subset, 0, topN);\n      newHits = subset;\n    }\n\n    return new TopDocs(topDocs.totalHits, newHits, newHits[0].score);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"222ff577a0e1b2399d3151966bf561ecd7a0b7d0","date":1395575041,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<AtomicReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Weight weight = searcher.createNormalizedWeight(query);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      AtomicReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext, null);\n      }\n\n      int targetDoc = docID - docBase;\n      int actualDoc = scorer.docID();\n      if (actualDoc < targetDoc) {\n        actualDoc = scorer.advance(targetDoc);\n      }\n\n      if (actualDoc == targetDoc) {\n        // Query did match this doc:\n        hit.score = combine(hit.score, true, scorer.score());\n      } else {\n        // Query did not match this doc:\n        assert actualDoc > targetDoc;\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits, hits[0].score);\n  }\n\n","sourceOld":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs topDocs, int topN) throws IOException {\n    int[] docIDs = new int[topDocs.scoreDocs.length];\n    for(int i=0;i<docIDs.length;i++) {\n      docIDs[i] = topDocs.scoreDocs[i].doc;\n    }\n\n    TopDocs topDocs2 = searcher.search(query, new OnlyDocIDsFilter(docIDs), topDocs.scoreDocs.length);\n\n    // TODO: we could save small young GC cost here if we\n    // cloned the incoming ScoreDoc[], sorted that by doc,\n    // passed that to OnlyDocIDsFilter, sorted 2nd pass\n    // TopDocs by doc, did a merge sort to combine the\n    // scores, and finally re-sorted by the combined score,\n    // but that is sizable added code complexity for minor\n    // GC savings:\n    Map<Integer,Float> newScores = new HashMap<Integer,Float>();\n    for(ScoreDoc sd : topDocs2.scoreDocs) {\n      newScores.put(sd.doc, sd.score);\n    }\n\n    ScoreDoc[] newHits = new ScoreDoc[topDocs.scoreDocs.length];\n    for(int i=0;i<topDocs.scoreDocs.length;i++) {\n      ScoreDoc sd = topDocs.scoreDocs[i];\n      Float newScore = newScores.get(sd.doc);\n      float combinedScore;\n      if (newScore == null) {\n        combinedScore = combine(sd.score, false, 0.0f);\n      } else {\n        combinedScore = combine(sd.score, true, newScore.floatValue());\n      }\n      newHits[i] = new ScoreDoc(sd.doc, combinedScore);\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(newHits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < newHits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(newHits, 0, subset, 0, topN);\n      newHits = subset;\n    }\n\n    return new TopDocs(topDocs.totalHits, newHits, newHits[0].score);\n  }\n\n","bugFix":null,"bugIntro":["a978b9bccbf0029e9f1e8930aae1305cf4fdd442","781239fc84d36be12b84e4d3e2618f5f07a182e3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a978b9bccbf0029e9f1e8930aae1305cf4fdd442","date":1400521236,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<AtomicReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Weight weight = searcher.createNormalizedWeight(query);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      AtomicReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext, null);\n      }\n\n      if(scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits, hits[0].score);\n  }\n\n","sourceOld":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<AtomicReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Weight weight = searcher.createNormalizedWeight(query);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      AtomicReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext, null);\n      }\n\n      int targetDoc = docID - docBase;\n      int actualDoc = scorer.docID();\n      if (actualDoc < targetDoc) {\n        actualDoc = scorer.advance(targetDoc);\n      }\n\n      if (actualDoc == targetDoc) {\n        // Query did match this doc:\n        hit.score = combine(hit.score, true, scorer.score());\n      } else {\n        // Query did not match this doc:\n        assert actualDoc > targetDoc;\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits, hits[0].score);\n  }\n\n","bugFix":["222ff577a0e1b2399d3151966bf561ecd7a0b7d0"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7605579001505896d48b07160075a5c8b8e128e","date":1400758727,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<AtomicReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Weight weight = searcher.createNormalizedWeight(query);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      AtomicReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext, null);\n      }\n\n      if(scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits, hits[0].score);\n  }\n\n","sourceOld":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<AtomicReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Weight weight = searcher.createNormalizedWeight(query);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      AtomicReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext, null);\n      }\n\n      int targetDoc = docID - docBase;\n      int actualDoc = scorer.docID();\n      if (actualDoc < targetDoc) {\n        actualDoc = scorer.advance(targetDoc);\n      }\n\n      if (actualDoc == targetDoc) {\n        // Query did match this doc:\n        hit.score = combine(hit.score, true, scorer.score());\n      } else {\n        // Query did not match this doc:\n        assert actualDoc > targetDoc;\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits, hits[0].score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Weight weight = searcher.createNormalizedWeight(query);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext, null);\n      }\n\n      if(scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits, hits[0].score);\n  }\n\n","sourceOld":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<AtomicReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Weight weight = searcher.createNormalizedWeight(query);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      AtomicReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext, null);\n      }\n\n      if(scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits, hits[0].score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"781239fc84d36be12b84e4d3e2618f5f07a182e3","date":1423139668,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Weight weight = searcher.createNormalizedWeight(query);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext, null, true);\n      }\n\n      if(scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits, hits[0].score);\n  }\n\n","sourceOld":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Weight weight = searcher.createNormalizedWeight(query);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext, null);\n      }\n\n      if(scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits, hits[0].score);\n  }\n\n","bugFix":["222ff577a0e1b2399d3151966bf561ecd7a0b7d0"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb17639909a369c1e64866842e5c213440acc17e","date":1423238093,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Weight weight = searcher.createNormalizedWeight(query, true);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext, null);\n      }\n\n      if(scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits, hits[0].score);\n  }\n\n","sourceOld":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Weight weight = searcher.createNormalizedWeight(query);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext, null, true);\n      }\n\n      if(scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits, hits[0].score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"954e59be3da8dc1b046646ad7af4b466852009d3","date":1423482367,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Weight weight = searcher.createNormalizedWeight(query, PostingsEnum.FLAG_FREQS);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext, null);\n      }\n\n      if(scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits, hits[0].score);\n  }\n\n","sourceOld":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Weight weight = searcher.createNormalizedWeight(query, true);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext, null);\n      }\n\n      if(scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits, hits[0].score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6a47d642ab24da1a811adce4bda9cc52c520ca13","date":1423483323,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Weight weight = searcher.createNormalizedWeight(query, true);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext, null);\n      }\n\n      if(scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits, hits[0].score);\n  }\n\n","sourceOld":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Weight weight = searcher.createNormalizedWeight(query, PostingsEnum.FLAG_FREQS);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext, null);\n      }\n\n      if(scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits, hits[0].score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Weight weight = searcher.createNormalizedWeight(query, true);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext);\n      }\n\n      if(scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits, hits[0].score);\n  }\n\n","sourceOld":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Weight weight = searcher.createNormalizedWeight(query, true);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext, null);\n      }\n\n      if(scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits, hits[0].score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7dd748bb245633a8195281556bb0e68a6ea97d18","date":1449755030,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Weight weight = searcher.createNormalizedWeight(query, true);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext);\n      }\n\n      if(scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.iterator().advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits, hits[0].score);\n  }\n\n","sourceOld":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Weight weight = searcher.createNormalizedWeight(query, true);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext);\n      }\n\n      if(scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits, hits[0].score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"10b1c9af2d877ca8d718a359a4e5b285fe33b6f7","date":1509555533,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Weight weight = searcher.createNormalizedWeight(query, true);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext);\n      }\n\n      if (scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.iterator().advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits, hits[0].score);\n  }\n\n","sourceOld":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Weight weight = searcher.createNormalizedWeight(query, true);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext);\n      }\n\n      if(scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.iterator().advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits, hits[0].score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fc47cb7b4346802411bb432f501ed0673d7119e","date":1512640179,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Weight weight = searcher.createNormalizedWeight(query, ScoreMode.COMPLETE);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext);\n      }\n\n      if (scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.iterator().advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits, hits[0].score);\n  }\n\n","sourceOld":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Weight weight = searcher.createNormalizedWeight(query, true);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext);\n      }\n\n      if (scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.iterator().advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits, hits[0].score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Weight weight = searcher.createNormalizedWeight(query, ScoreMode.COMPLETE);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext);\n      }\n\n      if (scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.iterator().advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits, hits[0].score);\n  }\n\n","sourceOld":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Weight weight = searcher.createNormalizedWeight(query, true);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext);\n      }\n\n      if (scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.iterator().advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits, hits[0].score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"475584d5e08a22ad3fc7babefe006d77bc744567","date":1523282824,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Query rewritten = searcher.rewrite(query);\n    Weight weight = searcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext);\n      }\n\n      if (scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.iterator().advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits, hits[0].score);\n  }\n\n","sourceOld":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Weight weight = searcher.createNormalizedWeight(query, ScoreMode.COMPLETE);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext);\n      }\n\n      if (scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.iterator().advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits, hits[0].score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d58e44159788900f4a2113b84463dc3fbbf80f20","date":1523319203,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Query rewritten = searcher.rewrite(query);\n    Weight weight = searcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext);\n      }\n\n      if (scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.iterator().advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits, hits[0].score);\n  }\n\n","sourceOld":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Weight weight = searcher.createNormalizedWeight(query, ScoreMode.COMPLETE);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext);\n      }\n\n      if (scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.iterator().advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits, hits[0].score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81fff83bdb893c1471efd78f6a9a3ce4f98120b9","date":1531895937,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Query rewritten = searcher.rewrite(query);\n    Weight weight = searcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext);\n      }\n\n      if (scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.iterator().advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits);\n  }\n\n","sourceOld":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Query rewritten = searcher.rewrite(query);\n    Weight weight = searcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext);\n      }\n\n      if (scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.iterator().advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits, hits[0].score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Query rewritten = searcher.rewrite(query);\n    Weight weight = searcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext);\n      }\n\n      if (scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.iterator().advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits);\n  }\n\n","sourceOld":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Query rewritten = searcher.rewrite(query);\n    Weight weight = searcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext);\n      }\n\n      if (scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.iterator().advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits, hits[0].score);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe442914a786fcba929cedd8a1715fdd9c0c2dae","date":1567667544,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Query rewritten = searcher.rewrite(query);\n    Weight weight = searcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext);\n      }\n\n      if (scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.iterator().advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    Comparator<ScoreDoc> sortDocComparator = new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        // Sort by score descending, then docID ascending:\n        if (a.score > b.score) {\n          return -1;\n        } else if (a.score < b.score) {\n          return 1;\n        } else {\n          // This subtraction can't overflow int\n          // because docIDs are >= 0:\n          return a.doc - b.doc;\n        }\n      }\n    };\n\n    if (topN < hits.length) {\n      ArrayUtil.select(hits, 0, hits.length, topN, sortDocComparator);\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    Arrays.sort(hits, sortDocComparator);\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits);\n  }\n\n","sourceOld":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Query rewritten = searcher.rewrite(query);\n    Weight weight = searcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext);\n      }\n\n      if (scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.iterator().advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"460728fc2f8c1aae84c0562b509c778faf625103","date":1567695577,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Query rewritten = searcher.rewrite(query);\n    Weight weight = searcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext);\n      }\n\n      if (scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.iterator().advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits);\n  }\n\n","sourceOld":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Query rewritten = searcher.rewrite(query);\n    Weight weight = searcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext);\n      }\n\n      if (scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.iterator().advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    Comparator<ScoreDoc> sortDocComparator = new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        // Sort by score descending, then docID ascending:\n        if (a.score > b.score) {\n          return -1;\n        } else if (a.score < b.score) {\n          return 1;\n        } else {\n          // This subtraction can't overflow int\n          // because docIDs are >= 0:\n          return a.doc - b.doc;\n        }\n      }\n    };\n\n    if (topN < hits.length) {\n      ArrayUtil.select(hits, 0, hits.length, topN, sortDocComparator);\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    Arrays.sort(hits, sortDocComparator);\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9f89859d16ab335d18913323f0af3fcb7b580917","date":1567704488,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/QueryRescorer#rescore(IndexSearcher,TopDocs,int).mjava","sourceNew":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Query rewritten = searcher.rewrite(query);\n    Weight weight = searcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext);\n      }\n\n      if (scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.iterator().advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    Comparator<ScoreDoc> sortDocComparator = new Comparator<ScoreDoc>() {\n      @Override\n      public int compare(ScoreDoc a, ScoreDoc b) {\n        // Sort by score descending, then docID ascending:\n        if (a.score > b.score) {\n          return -1;\n        } else if (a.score < b.score) {\n          return 1;\n        } else {\n          // This subtraction can't overflow int\n          // because docIDs are >= 0:\n          return a.doc - b.doc;\n        }\n      }\n    };\n\n    if (topN < hits.length) {\n      ArrayUtil.select(hits, 0, hits.length, topN, sortDocComparator);\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    Arrays.sort(hits, sortDocComparator);\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits);\n  }\n\n","sourceOld":"  @Override\n  public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) throws IOException {\n    ScoreDoc[] hits = firstPassTopDocs.scoreDocs.clone();\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    return a.doc - b.doc;\n                  }\n                });\n\n    List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n\n    Query rewritten = searcher.rewrite(query);\n    Weight weight = searcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n\n    // Now merge sort docIDs from hits, with reader's leaves:\n    int hitUpto = 0;\n    int readerUpto = -1;\n    int endDoc = 0;\n    int docBase = 0;\n    Scorer scorer = null;\n\n    while (hitUpto < hits.length) {\n      ScoreDoc hit = hits[hitUpto];\n      int docID = hit.doc;\n      LeafReaderContext readerContext = null;\n      while (docID >= endDoc) {\n        readerUpto++;\n        readerContext = leaves.get(readerUpto);\n        endDoc = readerContext.docBase + readerContext.reader().maxDoc();\n      }\n\n      if (readerContext != null) {\n        // We advanced to another segment:\n        docBase = readerContext.docBase;\n        scorer = weight.scorer(readerContext);\n      }\n\n      if (scorer != null) {\n        int targetDoc = docID - docBase;\n        int actualDoc = scorer.docID();\n        if (actualDoc < targetDoc) {\n          actualDoc = scorer.iterator().advance(targetDoc);\n        }\n\n        if (actualDoc == targetDoc) {\n          // Query did match this doc:\n          hit.score = combine(hit.score, true, scorer.score());\n        } else {\n          // Query did not match this doc:\n          assert actualDoc > targetDoc;\n          hit.score = combine(hit.score, false, 0.0f);\n        }\n      } else {\n        // Query did not match this doc:\n        hit.score = combine(hit.score, false, 0.0f);\n      }\n\n      hitUpto++;\n    }\n\n    // TODO: we should do a partial sort (of only topN)\n    // instead, but typically the number of hits is\n    // smallish:\n    Arrays.sort(hits,\n                new Comparator<ScoreDoc>() {\n                  @Override\n                  public int compare(ScoreDoc a, ScoreDoc b) {\n                    // Sort by score descending, then docID ascending:\n                    if (a.score > b.score) {\n                      return -1;\n                    } else if (a.score < b.score) {\n                      return 1;\n                    } else {\n                      // This subtraction can't overflow int\n                      // because docIDs are >= 0:\n                      return a.doc - b.doc;\n                    }\n                  }\n                });\n\n    if (topN < hits.length) {\n      ScoreDoc[] subset = new ScoreDoc[topN];\n      System.arraycopy(hits, 0, subset, 0, topN);\n      hits = subset;\n    }\n\n    return new TopDocs(firstPassTopDocs.totalHits, hits);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"222ff577a0e1b2399d3151966bf561ecd7a0b7d0":["74799e1ff172d6be3cf96eb89c15cdbb96bfe0d9"],"6a47d642ab24da1a811adce4bda9cc52c520ca13":["954e59be3da8dc1b046646ad7af4b466852009d3"],"fb17639909a369c1e64866842e5c213440acc17e":["781239fc84d36be12b84e4d3e2618f5f07a182e3"],"475584d5e08a22ad3fc7babefe006d77bc744567":["417142ff08fda9cf0b72d5133e63097a166c6458"],"781239fc84d36be12b84e4d3e2618f5f07a182e3":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"b7605579001505896d48b07160075a5c8b8e128e":["222ff577a0e1b2399d3151966bf561ecd7a0b7d0","a978b9bccbf0029e9f1e8930aae1305cf4fdd442"],"fe442914a786fcba929cedd8a1715fdd9c0c2dae":["81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"954e59be3da8dc1b046646ad7af4b466852009d3":["fb17639909a369c1e64866842e5c213440acc17e"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["a978b9bccbf0029e9f1e8930aae1305cf4fdd442"],"417142ff08fda9cf0b72d5133e63097a166c6458":["10b1c9af2d877ca8d718a359a4e5b285fe33b6f7","9fc47cb7b4346802411bb432f501ed0673d7119e"],"d58e44159788900f4a2113b84463dc3fbbf80f20":["417142ff08fda9cf0b72d5133e63097a166c6458","475584d5e08a22ad3fc7babefe006d77bc744567"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["6a47d642ab24da1a811adce4bda9cc52c520ca13"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["d58e44159788900f4a2113b84463dc3fbbf80f20","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"460728fc2f8c1aae84c0562b509c778faf625103":["fe442914a786fcba929cedd8a1715fdd9c0c2dae"],"a978b9bccbf0029e9f1e8930aae1305cf4fdd442":["222ff577a0e1b2399d3151966bf561ecd7a0b7d0"],"9f89859d16ab335d18913323f0af3fcb7b580917":["460728fc2f8c1aae84c0562b509c778faf625103"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["d58e44159788900f4a2113b84463dc3fbbf80f20"],"74799e1ff172d6be3cf96eb89c15cdbb96bfe0d9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["10b1c9af2d877ca8d718a359a4e5b285fe33b6f7"],"7dd748bb245633a8195281556bb0e68a6ea97d18":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9f89859d16ab335d18913323f0af3fcb7b580917"],"10b1c9af2d877ca8d718a359a4e5b285fe33b6f7":["7dd748bb245633a8195281556bb0e68a6ea97d18"]},"commit2Childs":{"222ff577a0e1b2399d3151966bf561ecd7a0b7d0":["b7605579001505896d48b07160075a5c8b8e128e","a978b9bccbf0029e9f1e8930aae1305cf4fdd442"],"6a47d642ab24da1a811adce4bda9cc52c520ca13":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"fb17639909a369c1e64866842e5c213440acc17e":["954e59be3da8dc1b046646ad7af4b466852009d3"],"475584d5e08a22ad3fc7babefe006d77bc744567":["d58e44159788900f4a2113b84463dc3fbbf80f20"],"781239fc84d36be12b84e4d3e2618f5f07a182e3":["fb17639909a369c1e64866842e5c213440acc17e"],"b7605579001505896d48b07160075a5c8b8e128e":[],"954e59be3da8dc1b046646ad7af4b466852009d3":["6a47d642ab24da1a811adce4bda9cc52c520ca13"],"fe442914a786fcba929cedd8a1715fdd9c0c2dae":["460728fc2f8c1aae84c0562b509c778faf625103"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["781239fc84d36be12b84e4d3e2618f5f07a182e3"],"417142ff08fda9cf0b72d5133e63097a166c6458":["475584d5e08a22ad3fc7babefe006d77bc744567","d58e44159788900f4a2113b84463dc3fbbf80f20"],"d58e44159788900f4a2113b84463dc3fbbf80f20":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["7dd748bb245633a8195281556bb0e68a6ea97d18"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"460728fc2f8c1aae84c0562b509c778faf625103":["9f89859d16ab335d18913323f0af3fcb7b580917"],"a978b9bccbf0029e9f1e8930aae1305cf4fdd442":["b7605579001505896d48b07160075a5c8b8e128e","c9fb5f46e264daf5ba3860defe623a89d202dd87"],"9f89859d16ab335d18913323f0af3fcb7b580917":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["74799e1ff172d6be3cf96eb89c15cdbb96bfe0d9"],"74799e1ff172d6be3cf96eb89c15cdbb96bfe0d9":["222ff577a0e1b2399d3151966bf561ecd7a0b7d0"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["fe442914a786fcba929cedd8a1715fdd9c0c2dae","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["417142ff08fda9cf0b72d5133e63097a166c6458"],"7dd748bb245633a8195281556bb0e68a6ea97d18":["10b1c9af2d877ca8d718a359a4e5b285fe33b6f7"],"10b1c9af2d877ca8d718a359a4e5b285fe33b6f7":["417142ff08fda9cf0b72d5133e63097a166c6458","9fc47cb7b4346802411bb432f501ed0673d7119e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b7605579001505896d48b07160075a5c8b8e128e","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}