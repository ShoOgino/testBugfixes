{"path":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testCloseIndexWriterOnBuild().mjava","commits":[{"id":"e15af9ab52794c4f3888b19ff3cf55ccea043db2","date":1479337431,"type":0,"author":"Steve Rowe","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testCloseIndexWriterOnBuild().mjava","pathOld":"/dev/null","sourceNew":"  public void testCloseIndexWriterOnBuild() throws Exception {\n    class MyAnalyzingInfixSuggester extends AnalyzingInfixSuggester {\n      public MyAnalyzingInfixSuggester(Directory dir, Analyzer indexAnalyzer, Analyzer queryAnalyzer, \n                                       int minPrefixChars, boolean commitOnBuild, boolean allTermsRequired,\n                                       boolean highlight, boolean closeIndexWriterOnBuild) throws IOException {\n        super(dir, indexAnalyzer, queryAnalyzer, minPrefixChars, commitOnBuild, \n              allTermsRequired, highlight, closeIndexWriterOnBuild);\n      }\n      public IndexWriter getIndexWriter() {\n        return writer;\n      } \n      public SearcherManager getSearcherManager() {\n        return searcherMgr;\n      }\n    }\n\n    // After build(), when closeIndexWriterOnBuild = true: \n    // * The IndexWriter should be null \n    // * The SearcherManager should be non-null\n    // * SearcherManager's IndexWriter reference should be closed \n    //   (as evidenced by maybeRefreshBlocking() throwing AlreadyClosedException)\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    MyAnalyzingInfixSuggester suggester = new MyAnalyzingInfixSuggester(newDirectory(), a, a, 3, false,\n        AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED, AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT, true);\n    suggester.build(new InputArrayIterator(sharedInputs));\n    assertNull(suggester.getIndexWriter());\n    assertNotNull(suggester.getSearcherManager());\n    expectThrows(AlreadyClosedException.class, () -> suggester.getSearcherManager().maybeRefreshBlocking());\n    \n    suggester.close();\n    a.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e859e664a65796dadf8aaf65db6f66f3a885368","date":1479487334,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testCloseIndexWriterOnBuild().mjava","pathOld":"/dev/null","sourceNew":"  public void testCloseIndexWriterOnBuild() throws Exception {\n    class MyAnalyzingInfixSuggester extends AnalyzingInfixSuggester {\n      public MyAnalyzingInfixSuggester(Directory dir, Analyzer indexAnalyzer, Analyzer queryAnalyzer, \n                                       int minPrefixChars, boolean commitOnBuild, boolean allTermsRequired,\n                                       boolean highlight, boolean closeIndexWriterOnBuild) throws IOException {\n        super(dir, indexAnalyzer, queryAnalyzer, minPrefixChars, commitOnBuild, \n              allTermsRequired, highlight, closeIndexWriterOnBuild);\n      }\n      public IndexWriter getIndexWriter() {\n        return writer;\n      } \n      public SearcherManager getSearcherManager() {\n        return searcherMgr;\n      }\n    }\n\n    // After build(), when closeIndexWriterOnBuild = true: \n    // * The IndexWriter should be null \n    // * The SearcherManager should be non-null\n    // * SearcherManager's IndexWriter reference should be closed \n    //   (as evidenced by maybeRefreshBlocking() throwing AlreadyClosedException)\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    MyAnalyzingInfixSuggester suggester = new MyAnalyzingInfixSuggester(newDirectory(), a, a, 3, false,\n        AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED, AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT, true);\n    suggester.build(new InputArrayIterator(sharedInputs));\n    assertNull(suggester.getIndexWriter());\n    assertNotNull(suggester.getSearcherManager());\n    expectThrows(AlreadyClosedException.class, () -> suggester.getSearcherManager().maybeRefreshBlocking());\n    \n    suggester.close();\n    a.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"21fc4540234a8ebf9228a85e621322fbf0592153","date":1485843191,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testCloseIndexWriterOnBuild().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testCloseIndexWriterOnBuild().mjava","sourceNew":"  public void testCloseIndexWriterOnBuild() throws Exception {\n    class MyAnalyzingInfixSuggester extends AnalyzingInfixSuggester {\n      public MyAnalyzingInfixSuggester(Directory dir, Analyzer indexAnalyzer, Analyzer queryAnalyzer, \n                                       int minPrefixChars, boolean commitOnBuild, boolean allTermsRequired,\n                                       boolean highlight, boolean closeIndexWriterOnBuild) throws IOException {\n        super(dir, indexAnalyzer, queryAnalyzer, minPrefixChars, commitOnBuild, \n              allTermsRequired, highlight, closeIndexWriterOnBuild);\n      }\n      public IndexWriter getIndexWriter() {\n        return writer;\n      } \n      public SearcherManager getSearcherManager() {\n        return searcherMgr;\n      }\n    }\n\n    // After build(), when closeIndexWriterOnBuild = true: \n    // * The IndexWriter should be null \n    // * The SearcherManager should be non-null\n    // * SearcherManager's IndexWriter reference should be closed \n    //   (as evidenced by maybeRefreshBlocking() throwing AlreadyClosedException)\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    Path tempDir = createTempDir(\"analyzingInfixContext\");\n    final MyAnalyzingInfixSuggester suggester = new MyAnalyzingInfixSuggester(newFSDirectory(tempDir), a, a, 3, false,\n        AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED, AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT, true);\n    suggester.build(new InputArrayIterator(sharedInputs));\n    assertNull(suggester.getIndexWriter());\n    assertNotNull(suggester.getSearcherManager());\n    expectThrows(AlreadyClosedException.class, () -> suggester.getSearcherManager().maybeRefreshBlocking());\n    \n    suggester.close();\n\n    // After instantiating from an already-built suggester dir:\n    // * The IndexWriter should be null\n    // * The SearcherManager should be non-null\n    final MyAnalyzingInfixSuggester suggester2 = new MyAnalyzingInfixSuggester(newFSDirectory(tempDir), a, a, 3, false,\n        AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED, AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT, true);\n    assertNull(suggester2.getIndexWriter());\n    assertNotNull(suggester2.getSearcherManager());\n\n    suggester2.close();\n    a.close();\n  }\n\n","sourceOld":"  public void testCloseIndexWriterOnBuild() throws Exception {\n    class MyAnalyzingInfixSuggester extends AnalyzingInfixSuggester {\n      public MyAnalyzingInfixSuggester(Directory dir, Analyzer indexAnalyzer, Analyzer queryAnalyzer, \n                                       int minPrefixChars, boolean commitOnBuild, boolean allTermsRequired,\n                                       boolean highlight, boolean closeIndexWriterOnBuild) throws IOException {\n        super(dir, indexAnalyzer, queryAnalyzer, minPrefixChars, commitOnBuild, \n              allTermsRequired, highlight, closeIndexWriterOnBuild);\n      }\n      public IndexWriter getIndexWriter() {\n        return writer;\n      } \n      public SearcherManager getSearcherManager() {\n        return searcherMgr;\n      }\n    }\n\n    // After build(), when closeIndexWriterOnBuild = true: \n    // * The IndexWriter should be null \n    // * The SearcherManager should be non-null\n    // * SearcherManager's IndexWriter reference should be closed \n    //   (as evidenced by maybeRefreshBlocking() throwing AlreadyClosedException)\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    MyAnalyzingInfixSuggester suggester = new MyAnalyzingInfixSuggester(newDirectory(), a, a, 3, false,\n        AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED, AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT, true);\n    suggester.build(new InputArrayIterator(sharedInputs));\n    assertNull(suggester.getIndexWriter());\n    assertNotNull(suggester.getSearcherManager());\n    expectThrows(AlreadyClosedException.class, () -> suggester.getSearcherManager().maybeRefreshBlocking());\n    \n    suggester.close();\n    a.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0debbe3b933db3b47fdc5984fbe24e55324d3ed4","date":1485866433,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testCloseIndexWriterOnBuild().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testCloseIndexWriterOnBuild().mjava","sourceNew":"  public void testCloseIndexWriterOnBuild() throws Exception {\n    class MyAnalyzingInfixSuggester extends AnalyzingInfixSuggester {\n      public MyAnalyzingInfixSuggester(Directory dir, Analyzer indexAnalyzer, Analyzer queryAnalyzer, \n                                       int minPrefixChars, boolean commitOnBuild, boolean allTermsRequired,\n                                       boolean highlight, boolean closeIndexWriterOnBuild) throws IOException {\n        super(dir, indexAnalyzer, queryAnalyzer, minPrefixChars, commitOnBuild, \n              allTermsRequired, highlight, closeIndexWriterOnBuild);\n      }\n      public IndexWriter getIndexWriter() {\n        return writer;\n      } \n      public SearcherManager getSearcherManager() {\n        return searcherMgr;\n      }\n    }\n\n    // After build(), when closeIndexWriterOnBuild = true: \n    // * The IndexWriter should be null \n    // * The SearcherManager should be non-null\n    // * SearcherManager's IndexWriter reference should be closed \n    //   (as evidenced by maybeRefreshBlocking() throwing AlreadyClosedException)\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    Path tempDir = createTempDir(\"analyzingInfixContext\");\n    final MyAnalyzingInfixSuggester suggester = new MyAnalyzingInfixSuggester(newFSDirectory(tempDir), a, a, 3, false,\n        AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED, AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT, true);\n    suggester.build(new InputArrayIterator(sharedInputs));\n    assertNull(suggester.getIndexWriter());\n    assertNotNull(suggester.getSearcherManager());\n    expectThrows(AlreadyClosedException.class, () -> suggester.getSearcherManager().maybeRefreshBlocking());\n    \n    suggester.close();\n\n    // After instantiating from an already-built suggester dir:\n    // * The IndexWriter should be null\n    // * The SearcherManager should be non-null\n    final MyAnalyzingInfixSuggester suggester2 = new MyAnalyzingInfixSuggester(newFSDirectory(tempDir), a, a, 3, false,\n        AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED, AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT, true);\n    assertNull(suggester2.getIndexWriter());\n    assertNotNull(suggester2.getSearcherManager());\n\n    suggester2.close();\n    a.close();\n  }\n\n","sourceOld":"  public void testCloseIndexWriterOnBuild() throws Exception {\n    class MyAnalyzingInfixSuggester extends AnalyzingInfixSuggester {\n      public MyAnalyzingInfixSuggester(Directory dir, Analyzer indexAnalyzer, Analyzer queryAnalyzer, \n                                       int minPrefixChars, boolean commitOnBuild, boolean allTermsRequired,\n                                       boolean highlight, boolean closeIndexWriterOnBuild) throws IOException {\n        super(dir, indexAnalyzer, queryAnalyzer, minPrefixChars, commitOnBuild, \n              allTermsRequired, highlight, closeIndexWriterOnBuild);\n      }\n      public IndexWriter getIndexWriter() {\n        return writer;\n      } \n      public SearcherManager getSearcherManager() {\n        return searcherMgr;\n      }\n    }\n\n    // After build(), when closeIndexWriterOnBuild = true: \n    // * The IndexWriter should be null \n    // * The SearcherManager should be non-null\n    // * SearcherManager's IndexWriter reference should be closed \n    //   (as evidenced by maybeRefreshBlocking() throwing AlreadyClosedException)\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    MyAnalyzingInfixSuggester suggester = new MyAnalyzingInfixSuggester(newDirectory(), a, a, 3, false,\n        AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED, AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT, true);\n    suggester.build(new InputArrayIterator(sharedInputs));\n    assertNull(suggester.getIndexWriter());\n    assertNotNull(suggester.getSearcherManager());\n    expectThrows(AlreadyClosedException.class, () -> suggester.getSearcherManager().maybeRefreshBlocking());\n    \n    suggester.close();\n    a.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c3523a0ab04c3002eee3896c75ea5f10f388bcc","date":1485968422,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testCloseIndexWriterOnBuild().mjava","pathOld":"lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest#testCloseIndexWriterOnBuild().mjava","sourceNew":"  public void testCloseIndexWriterOnBuild() throws Exception {\n    class MyAnalyzingInfixSuggester extends AnalyzingInfixSuggester {\n      public MyAnalyzingInfixSuggester(Directory dir, Analyzer indexAnalyzer, Analyzer queryAnalyzer, \n                                       int minPrefixChars, boolean commitOnBuild, boolean allTermsRequired,\n                                       boolean highlight, boolean closeIndexWriterOnBuild) throws IOException {\n        super(dir, indexAnalyzer, queryAnalyzer, minPrefixChars, commitOnBuild, \n              allTermsRequired, highlight, closeIndexWriterOnBuild);\n      }\n      public IndexWriter getIndexWriter() {\n        return writer;\n      } \n      public SearcherManager getSearcherManager() {\n        return searcherMgr;\n      }\n    }\n\n    // After build(), when closeIndexWriterOnBuild = true: \n    // * The IndexWriter should be null \n    // * The SearcherManager should be non-null\n    // * SearcherManager's IndexWriter reference should be closed \n    //   (as evidenced by maybeRefreshBlocking() throwing AlreadyClosedException)\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    Path tempDir = createTempDir(\"analyzingInfixContext\");\n    final MyAnalyzingInfixSuggester suggester = new MyAnalyzingInfixSuggester(newFSDirectory(tempDir), a, a, 3, false,\n        AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED, AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT, true);\n    suggester.build(new InputArrayIterator(sharedInputs));\n    assertNull(suggester.getIndexWriter());\n    assertNotNull(suggester.getSearcherManager());\n    expectThrows(AlreadyClosedException.class, () -> suggester.getSearcherManager().maybeRefreshBlocking());\n    \n    suggester.close();\n\n    // After instantiating from an already-built suggester dir:\n    // * The IndexWriter should be null\n    // * The SearcherManager should be non-null\n    final MyAnalyzingInfixSuggester suggester2 = new MyAnalyzingInfixSuggester(newFSDirectory(tempDir), a, a, 3, false,\n        AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED, AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT, true);\n    assertNull(suggester2.getIndexWriter());\n    assertNotNull(suggester2.getSearcherManager());\n\n    suggester2.close();\n    a.close();\n  }\n\n","sourceOld":"  public void testCloseIndexWriterOnBuild() throws Exception {\n    class MyAnalyzingInfixSuggester extends AnalyzingInfixSuggester {\n      public MyAnalyzingInfixSuggester(Directory dir, Analyzer indexAnalyzer, Analyzer queryAnalyzer, \n                                       int minPrefixChars, boolean commitOnBuild, boolean allTermsRequired,\n                                       boolean highlight, boolean closeIndexWriterOnBuild) throws IOException {\n        super(dir, indexAnalyzer, queryAnalyzer, minPrefixChars, commitOnBuild, \n              allTermsRequired, highlight, closeIndexWriterOnBuild);\n      }\n      public IndexWriter getIndexWriter() {\n        return writer;\n      } \n      public SearcherManager getSearcherManager() {\n        return searcherMgr;\n      }\n    }\n\n    // After build(), when closeIndexWriterOnBuild = true: \n    // * The IndexWriter should be null \n    // * The SearcherManager should be non-null\n    // * SearcherManager's IndexWriter reference should be closed \n    //   (as evidenced by maybeRefreshBlocking() throwing AlreadyClosedException)\n    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);\n    MyAnalyzingInfixSuggester suggester = new MyAnalyzingInfixSuggester(newDirectory(), a, a, 3, false,\n        AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED, AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT, true);\n    suggester.build(new InputArrayIterator(sharedInputs));\n    assertNull(suggester.getIndexWriter());\n    assertNotNull(suggester.getSearcherManager());\n    expectThrows(AlreadyClosedException.class, () -> suggester.getSearcherManager().maybeRefreshBlocking());\n    \n    suggester.close();\n    a.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":["2e859e664a65796dadf8aaf65db6f66f3a885368","0debbe3b933db3b47fdc5984fbe24e55324d3ed4"],"0debbe3b933db3b47fdc5984fbe24e55324d3ed4":["e15af9ab52794c4f3888b19ff3cf55ccea043db2","21fc4540234a8ebf9228a85e621322fbf0592153"],"e15af9ab52794c4f3888b19ff3cf55ccea043db2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2e859e664a65796dadf8aaf65db6f66f3a885368":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e15af9ab52794c4f3888b19ff3cf55ccea043db2"],"21fc4540234a8ebf9228a85e621322fbf0592153":["e15af9ab52794c4f3888b19ff3cf55ccea043db2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0debbe3b933db3b47fdc5984fbe24e55324d3ed4"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e15af9ab52794c4f3888b19ff3cf55ccea043db2","2e859e664a65796dadf8aaf65db6f66f3a885368"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":[],"0debbe3b933db3b47fdc5984fbe24e55324d3ed4":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e15af9ab52794c4f3888b19ff3cf55ccea043db2":["0debbe3b933db3b47fdc5984fbe24e55324d3ed4","2e859e664a65796dadf8aaf65db6f66f3a885368","21fc4540234a8ebf9228a85e621322fbf0592153"],"2e859e664a65796dadf8aaf65db6f66f3a885368":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc"],"21fc4540234a8ebf9228a85e621322fbf0592153":["0debbe3b933db3b47fdc5984fbe24e55324d3ed4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}