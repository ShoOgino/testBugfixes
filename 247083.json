{"path":"solr/core/src/test/org/apache/solr/search/TestLFUCache#testConcurrentAccess().mjava","commits":[{"id":"2bb583c6ee51389f2d0a7def839c425969b85fee","date":1432473604,"type":0,"author":"Shawn Heisey","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestLFUCache#testConcurrentAccess().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testConcurrentAccess() throws InterruptedException {\n    /* Set up a thread pool with twice as many threads as there are CPUs. */\n    final ConcurrentLFUCache<Integer,Long> cache = new ConcurrentLFUCache<>(10, 9);\n    ExecutorService executorService = ExecutorUtil.newMDCAwareFixedThreadPool(10,\n        new DefaultSolrThreadFactory(\"testConcurrentAccess\"));\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    \n    /*\n     * Use the thread pool to execute at least two million puts into the cache.\n     * Without the fix on SOLR-7585, NoSuchElementException is thrown.\n     * Simultaneous calls to markAndSweep are protected from each other by a\n     * lock, so they run sequentially, and due to a problem in the previous\n     * design, the cache eviction doesn't work right.\n     */\n    for (int i = 0; i < atLeast(2_000_000); ++i) {\n      executorService.submit(new Runnable() {\n        @Override\n        public void run() {\n          try {\n            cache.put(random().nextInt(100), random().nextLong());\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n          }\n        }\n      });\n    }\n    \n    executorService.shutdown();\n    executorService.awaitTermination(1, TimeUnit.MINUTES);\n    \n    // then:\n    assertNull(\"Exception during concurrent access: \" + error.get(), error.get());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a0c04b71951333291abc7f317109a6a5957bd28","date":1457097827,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestLFUCache#testConcurrentAccess().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestLFUCache#testConcurrentAccess().mjava","sourceNew":"  @Test\n  public void testConcurrentAccess() throws InterruptedException {\n    /* Set up a thread pool with twice as many threads as there are CPUs. */\n    final ConcurrentLFUCache<Integer,Long> cache = new ConcurrentLFUCache<>(10, 9);\n    ExecutorService executorService = ExecutorUtil.newMDCAwareFixedThreadPool(10,\n        new DefaultSolrThreadFactory(\"testConcurrentAccess\"));\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    \n    /*\n     * Use the thread pool to execute at least two million puts into the cache.\n     * Without the fix on SOLR-7585, NoSuchElementException is thrown.\n     * Simultaneous calls to markAndSweep are protected from each other by a\n     * lock, so they run sequentially, and due to a problem in the previous\n     * design, the cache eviction doesn't work right.\n     */\n    for (int i = 0; i < atLeast(2_000_000); ++i) {\n      executorService.submit(() -> {\n        try {\n          cache.put(random().nextInt(100), random().nextLong());\n        } catch (Throwable t) {\n          error.compareAndSet(null, t);\n        }\n      });\n    }\n    \n    executorService.shutdown();\n    executorService.awaitTermination(1, TimeUnit.MINUTES);\n    \n    // then:\n    assertNull(\"Exception during concurrent access: \" + error.get(), error.get());\n  }\n\n","sourceOld":"  @Test\n  public void testConcurrentAccess() throws InterruptedException {\n    /* Set up a thread pool with twice as many threads as there are CPUs. */\n    final ConcurrentLFUCache<Integer,Long> cache = new ConcurrentLFUCache<>(10, 9);\n    ExecutorService executorService = ExecutorUtil.newMDCAwareFixedThreadPool(10,\n        new DefaultSolrThreadFactory(\"testConcurrentAccess\"));\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    \n    /*\n     * Use the thread pool to execute at least two million puts into the cache.\n     * Without the fix on SOLR-7585, NoSuchElementException is thrown.\n     * Simultaneous calls to markAndSweep are protected from each other by a\n     * lock, so they run sequentially, and due to a problem in the previous\n     * design, the cache eviction doesn't work right.\n     */\n    for (int i = 0; i < atLeast(2_000_000); ++i) {\n      executorService.submit(new Runnable() {\n        @Override\n        public void run() {\n          try {\n            cache.put(random().nextInt(100), random().nextLong());\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n          }\n        }\n      });\n    }\n    \n    executorService.shutdown();\n    executorService.awaitTermination(1, TimeUnit.MINUTES);\n    \n    // then:\n    assertNull(\"Exception during concurrent access: \" + error.get(), error.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d7d3943904804560937e6239effeebda0f920e4","date":1573762904,"type":4,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/search/TestLFUCache#testConcurrentAccess().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void testConcurrentAccess() throws InterruptedException {\n    /* Set up a thread pool with twice as many threads as there are CPUs. */\n    final ConcurrentLFUCache<Integer,Long> cache = new ConcurrentLFUCache<>(10, 9);\n    ExecutorService executorService = ExecutorUtil.newMDCAwareFixedThreadPool(10,\n        new DefaultSolrThreadFactory(\"testConcurrentAccess\"));\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    \n    /*\n     * Use the thread pool to execute at least two million puts into the cache.\n     * Without the fix on SOLR-7585, NoSuchElementException is thrown.\n     * Simultaneous calls to markAndSweep are protected from each other by a\n     * lock, so they run sequentially, and due to a problem in the previous\n     * design, the cache eviction doesn't work right.\n     */\n    for (int i = 0; i < atLeast(2_000_000); ++i) {\n      executorService.submit(() -> {\n        try {\n          cache.put(random().nextInt(100), random().nextLong());\n        } catch (Throwable t) {\n          error.compareAndSet(null, t);\n        }\n      });\n    }\n    \n    executorService.shutdown();\n    executorService.awaitTermination(1, TimeUnit.MINUTES);\n    \n    // then:\n    assertNull(\"Exception during concurrent access: \" + error.get(), error.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2bb583c6ee51389f2d0a7def839c425969b85fee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4d7d3943904804560937e6239effeebda0f920e4":["3a0c04b71951333291abc7f317109a6a5957bd28"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3a0c04b71951333291abc7f317109a6a5957bd28":["2bb583c6ee51389f2d0a7def839c425969b85fee"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4d7d3943904804560937e6239effeebda0f920e4"]},"commit2Childs":{"2bb583c6ee51389f2d0a7def839c425969b85fee":["3a0c04b71951333291abc7f317109a6a5957bd28"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2bb583c6ee51389f2d0a7def839c425969b85fee"],"4d7d3943904804560937e6239effeebda0f920e4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3a0c04b71951333291abc7f317109a6a5957bd28":["4d7d3943904804560937e6239effeebda0f920e4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}