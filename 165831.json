{"path":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","commits":[{"id":"bede0ec3497c48e70d55196c5065d97a4bc1db3d","date":1329668585,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","pathOld":"/dev/null","sourceNew":"    public MinResult[] search() throws IOException {\n      //System.out.println(\"  search topN=\" + topN);\n      final FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n      final List<MinResult> results = new ArrayList<MinResult>();\n\n      final Long NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path\");\n\n        FSTPath path;\n\n        if (queue == null) {\n\n          if (results.size() != 0) {\n            // Ran out of paths\n            break;\n          }\n\n          // First pass (top path): start from original fromNode\n          if (topN > 1) {\n            queue = new TreeSet<FSTPath>();\n          }\n\n          long minArcCost = Long.MAX_VALUE;\n          FST.Arc<Long> minArc = null;\n\n          path = new FSTPath(0, fromNode);\n          fst.readFirstTargetArc(fromNode, path.arc);\n\n          // Bootstrap: find the min starting arc\n          while (true) {\n            long arcScore = path.arc.output;\n            //System.out.println(\"  arc=\" + (char) path.arc.label + \" cost=\" + arcScore);\n            if (arcScore < minArcCost) {\n              minArcCost = arcScore;\n              minArc = scratchArc.copyFrom(path.arc);\n              //System.out.println(\"    **\");\n            }\n            if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc);\n          }\n\n          assert minArc != null;\n\n          if (queue != null) {\n            // Remove top path since we are now going to\n            // pursue it:\n            path = queue.pollFirst();\n            //System.out.println(\"  remove init path=\" + path);\n            assert path.arc.label == minArc.label;\n            if (bottom != null && queue.size() == topN-1) {\n              bottom = queue.last();\n              //System.out.println(\"    set init bottom: \" + bottom);\n            }\n          } else {\n            path.arc.copyFrom(minArc);\n            path.input.grow(1);\n            path.input.ints[0] = minArc.label;\n            path.input.length = 1;\n            path.cost = minArc.output;\n          }\n\n        } else {\n          path = queue.pollFirst();\n          if (path == null) {\n            // There were less than topN paths available:\n            break;\n          }\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult(path.input, path.cost));\n          continue;\n        }\n\n        if (results.size() == topN-1) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);\n\n          fst.readFirstTargetArc(path.arc, path.arc);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            if (path.arc.output == NO_OUTPUT) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            results.add(new MinResult(path.input, path.cost + path.arc.output));\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost += path.arc.output;\n          }\n        }\n      }\n    \n      return results.toArray(new MinResult[results.size()]);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["06086b5bd0f0d57858f0675becc58edf1f6b7c11","414aae1db83a83d247caa9514e383e4ca3d43da5","7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","32eace34e207608926e4c83409c65d968e530bf2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2a6ee6c302710254b6c2474ccd2755f9f2323ee3","date":1330700384,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","sourceNew":"    public MinResult<T>[] search() throws IOException {\n      //System.out.println(\"  search topN=\" + topN);\n      final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path\");\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n\n          if (results.size() != 0) {\n            // Ran out of paths\n            break;\n          }\n\n          // First pass (top path): start from original fromNode\n          if (topN > 1) {\n            queue = new TreeSet<FSTPath<T>>();\n          }\n\n          T minArcCost = null;\n          FST.Arc<T> minArc = null;\n\n          path = new FSTPath<T>(NO_OUTPUT, fromNode, comparator);\n          fst.readFirstTargetArc(fromNode, path.arc);\n\n          // Bootstrap: find the min starting arc\n          while (true) {\n            T arcScore = path.arc.output;\n            //System.out.println(\"  arc=\" + (char) path.arc.label + \" cost=\" + arcScore);\n            if (minArcCost == null || comparator.compare(arcScore, minArcCost) < 0) {\n              minArcCost = arcScore;\n              minArc = scratchArc.copyFrom(path.arc);\n              //System.out.println(\"    **\");\n            }\n            if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc);\n          }\n\n          assert minArc != null;\n\n          if (queue != null) {\n            // Remove top path since we are now going to\n            // pursue it:\n            path = queue.pollFirst();\n            //System.out.println(\"  remove init path=\" + path);\n            assert path.arc.label == minArc.label;\n            if (bottom != null && queue.size() == topN-1) {\n              bottom = queue.last();\n              //System.out.println(\"    set init bottom: \" + bottom);\n            }\n          } else {\n            path.arc.copyFrom(minArc);\n            path.input.grow(1);\n            path.input.ints[0] = minArc.label;\n            path.input.length = 1;\n            path.cost = minArc.output;\n          }\n\n        } else {\n          path = queue.pollFirst();\n          if (path == null) {\n            // There were less than topN paths available:\n            break;\n          }\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost, comparator));\n          continue;\n        }\n\n        if (results.size() == topN-1) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            results.add(new MinResult<T>(path.input, fst.outputs.add(path.cost, path.arc.output), comparator));\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      return results.toArray(new MinResult[results.size()]);\n    }\n\n","sourceOld":"    public MinResult[] search() throws IOException {\n      //System.out.println(\"  search topN=\" + topN);\n      final FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n      final List<MinResult> results = new ArrayList<MinResult>();\n\n      final Long NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path\");\n\n        FSTPath path;\n\n        if (queue == null) {\n\n          if (results.size() != 0) {\n            // Ran out of paths\n            break;\n          }\n\n          // First pass (top path): start from original fromNode\n          if (topN > 1) {\n            queue = new TreeSet<FSTPath>();\n          }\n\n          long minArcCost = Long.MAX_VALUE;\n          FST.Arc<Long> minArc = null;\n\n          path = new FSTPath(0, fromNode);\n          fst.readFirstTargetArc(fromNode, path.arc);\n\n          // Bootstrap: find the min starting arc\n          while (true) {\n            long arcScore = path.arc.output;\n            //System.out.println(\"  arc=\" + (char) path.arc.label + \" cost=\" + arcScore);\n            if (arcScore < minArcCost) {\n              minArcCost = arcScore;\n              minArc = scratchArc.copyFrom(path.arc);\n              //System.out.println(\"    **\");\n            }\n            if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc);\n          }\n\n          assert minArc != null;\n\n          if (queue != null) {\n            // Remove top path since we are now going to\n            // pursue it:\n            path = queue.pollFirst();\n            //System.out.println(\"  remove init path=\" + path);\n            assert path.arc.label == minArc.label;\n            if (bottom != null && queue.size() == topN-1) {\n              bottom = queue.last();\n              //System.out.println(\"    set init bottom: \" + bottom);\n            }\n          } else {\n            path.arc.copyFrom(minArc);\n            path.input.grow(1);\n            path.input.ints[0] = minArc.label;\n            path.input.length = 1;\n            path.cost = minArc.output;\n          }\n\n        } else {\n          path = queue.pollFirst();\n          if (path == null) {\n            // There were less than topN paths available:\n            break;\n          }\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult(path.input, path.cost));\n          continue;\n        }\n\n        if (results.size() == topN-1) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);\n\n          fst.readFirstTargetArc(path.arc, path.arc);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            if (path.arc.output == NO_OUTPUT) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            results.add(new MinResult(path.input, path.cost + path.arc.output));\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost += path.arc.output;\n          }\n        }\n      }\n    \n      return results.toArray(new MinResult[results.size()]);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5bd0058ffa806ba5d3b6cb38ab7de828d8b46970","date":1330944689,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","sourceNew":"    public MinResult<T>[] search() throws IOException {\n      //System.out.println(\"  search topN=\" + topN);\n      final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path\");\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n\n          if (results.size() != 0) {\n            // Ran out of paths\n            break;\n          }\n\n          // First pass (top path): start from original fromNode\n          if (topN > 1) {\n            queue = new TreeSet<FSTPath<T>>();\n          }\n\n          T minArcCost = null;\n          FST.Arc<T> minArc = null;\n\n          path = new FSTPath<T>(NO_OUTPUT, fromNode, comparator);\n          fst.readFirstTargetArc(fromNode, path.arc);\n\n          // Bootstrap: find the min starting arc\n          while (true) {\n            T arcScore = path.arc.output;\n            //System.out.println(\"  arc=\" + (char) path.arc.label + \" cost=\" + arcScore);\n            if (minArcCost == null || comparator.compare(arcScore, minArcCost) < 0) {\n              minArcCost = arcScore;\n              minArc = scratchArc.copyFrom(path.arc);\n              //System.out.println(\"    **\");\n            }\n            if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc);\n          }\n\n          assert minArc != null;\n\n          if (queue != null) {\n            // Remove top path since we are now going to\n            // pursue it:\n            path = queue.pollFirst();\n            //System.out.println(\"  remove init path=\" + path);\n            assert path.arc.label == minArc.label;\n            if (bottom != null && queue.size() == topN-1) {\n              bottom = queue.last();\n              //System.out.println(\"    set init bottom: \" + bottom);\n            }\n          } else {\n            path.arc.copyFrom(minArc);\n            path.input.grow(1);\n            path.input.ints[0] = minArc.label;\n            path.input.length = 1;\n            path.cost = minArc.output;\n          }\n\n        } else {\n          path = queue.pollFirst();\n          if (path == null) {\n            // There were less than topN paths available:\n            break;\n          }\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost, comparator));\n          continue;\n        }\n\n        if (results.size() == topN-1) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            results.add(new MinResult<T>(path.input, fst.outputs.add(path.cost, path.arc.output), comparator));\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","sourceOld":"    public MinResult<T>[] search() throws IOException {\n      //System.out.println(\"  search topN=\" + topN);\n      final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path\");\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n\n          if (results.size() != 0) {\n            // Ran out of paths\n            break;\n          }\n\n          // First pass (top path): start from original fromNode\n          if (topN > 1) {\n            queue = new TreeSet<FSTPath<T>>();\n          }\n\n          T minArcCost = null;\n          FST.Arc<T> minArc = null;\n\n          path = new FSTPath<T>(NO_OUTPUT, fromNode, comparator);\n          fst.readFirstTargetArc(fromNode, path.arc);\n\n          // Bootstrap: find the min starting arc\n          while (true) {\n            T arcScore = path.arc.output;\n            //System.out.println(\"  arc=\" + (char) path.arc.label + \" cost=\" + arcScore);\n            if (minArcCost == null || comparator.compare(arcScore, minArcCost) < 0) {\n              minArcCost = arcScore;\n              minArc = scratchArc.copyFrom(path.arc);\n              //System.out.println(\"    **\");\n            }\n            if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc);\n          }\n\n          assert minArc != null;\n\n          if (queue != null) {\n            // Remove top path since we are now going to\n            // pursue it:\n            path = queue.pollFirst();\n            //System.out.println(\"  remove init path=\" + path);\n            assert path.arc.label == minArc.label;\n            if (bottom != null && queue.size() == topN-1) {\n              bottom = queue.last();\n              //System.out.println(\"    set init bottom: \" + bottom);\n            }\n          } else {\n            path.arc.copyFrom(minArc);\n            path.input.grow(1);\n            path.input.ints[0] = minArc.label;\n            path.input.length = 1;\n            path.cost = minArc.output;\n          }\n\n        } else {\n          path = queue.pollFirst();\n          if (path == null) {\n            // There were less than topN paths available:\n            break;\n          }\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost, comparator));\n          continue;\n        }\n\n        if (results.size() == topN-1) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            results.add(new MinResult<T>(path.input, fst.outputs.add(path.cost, path.arc.output), comparator));\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      return results.toArray(new MinResult[results.size()]);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","sourceNew":"    public MinResult<T>[] search() throws IOException {\n      //System.out.println(\"  search topN=\" + topN);\n      final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path\");\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n\n          if (results.size() != 0) {\n            // Ran out of paths\n            break;\n          }\n\n          // First pass (top path): start from original fromNode\n          if (topN > 1) {\n            queue = new TreeSet<FSTPath<T>>();\n          }\n\n          T minArcCost = null;\n          FST.Arc<T> minArc = null;\n\n          path = new FSTPath<T>(NO_OUTPUT, fromNode, comparator);\n          fst.readFirstTargetArc(fromNode, path.arc);\n\n          // Bootstrap: find the min starting arc\n          while (true) {\n            T arcScore = path.arc.output;\n            //System.out.println(\"  arc=\" + (char) path.arc.label + \" cost=\" + arcScore);\n            if (minArcCost == null || comparator.compare(arcScore, minArcCost) < 0) {\n              minArcCost = arcScore;\n              minArc = scratchArc.copyFrom(path.arc);\n              //System.out.println(\"    **\");\n            }\n            if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc);\n          }\n\n          assert minArc != null;\n\n          if (queue != null) {\n            // Remove top path since we are now going to\n            // pursue it:\n            path = queue.pollFirst();\n            //System.out.println(\"  remove init path=\" + path);\n            assert path.arc.label == minArc.label;\n            if (bottom != null && queue.size() == topN-1) {\n              bottom = queue.last();\n              //System.out.println(\"    set init bottom: \" + bottom);\n            }\n          } else {\n            path.arc.copyFrom(minArc);\n            path.input.grow(1);\n            path.input.ints[0] = minArc.label;\n            path.input.length = 1;\n            path.cost = minArc.output;\n          }\n\n        } else {\n          path = queue.pollFirst();\n          if (path == null) {\n            // There were less than topN paths available:\n            break;\n          }\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost, comparator));\n          continue;\n        }\n\n        if (results.size() == topN-1) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            results.add(new MinResult<T>(path.input, fst.outputs.add(path.cost, path.arc.output), comparator));\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","sourceOld":"    public MinResult[] search() throws IOException {\n      //System.out.println(\"  search topN=\" + topN);\n      final FST.Arc<Long> scratchArc = new FST.Arc<Long>();\n\n      final List<MinResult> results = new ArrayList<MinResult>();\n\n      final Long NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path\");\n\n        FSTPath path;\n\n        if (queue == null) {\n\n          if (results.size() != 0) {\n            // Ran out of paths\n            break;\n          }\n\n          // First pass (top path): start from original fromNode\n          if (topN > 1) {\n            queue = new TreeSet<FSTPath>();\n          }\n\n          long minArcCost = Long.MAX_VALUE;\n          FST.Arc<Long> minArc = null;\n\n          path = new FSTPath(0, fromNode);\n          fst.readFirstTargetArc(fromNode, path.arc);\n\n          // Bootstrap: find the min starting arc\n          while (true) {\n            long arcScore = path.arc.output;\n            //System.out.println(\"  arc=\" + (char) path.arc.label + \" cost=\" + arcScore);\n            if (arcScore < minArcCost) {\n              minArcCost = arcScore;\n              minArc = scratchArc.copyFrom(path.arc);\n              //System.out.println(\"    **\");\n            }\n            if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc);\n          }\n\n          assert minArc != null;\n\n          if (queue != null) {\n            // Remove top path since we are now going to\n            // pursue it:\n            path = queue.pollFirst();\n            //System.out.println(\"  remove init path=\" + path);\n            assert path.arc.label == minArc.label;\n            if (bottom != null && queue.size() == topN-1) {\n              bottom = queue.last();\n              //System.out.println(\"    set init bottom: \" + bottom);\n            }\n          } else {\n            path.arc.copyFrom(minArc);\n            path.input.grow(1);\n            path.input.ints[0] = minArc.label;\n            path.input.length = 1;\n            path.cost = minArc.output;\n          }\n\n        } else {\n          path = queue.pollFirst();\n          if (path == null) {\n            // There were less than topN paths available:\n            break;\n          }\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult(path.input, path.cost));\n          continue;\n        }\n\n        if (results.size() == topN-1) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);\n\n          fst.readFirstTargetArc(path.arc, path.arc);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            if (path.arc.output == NO_OUTPUT) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            results.add(new MinResult(path.input, path.cost + path.arc.output));\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost += path.arc.output;\n          }\n        }\n      }\n    \n      return results.toArray(new MinResult[results.size()]);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b9fb5afeea0288262bffcc55bdcda8b5fa272c8","date":1339238489,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","sourceNew":"    public MinResult<T>[] search() throws IOException {\n      //System.out.println(\"  search topN=\" + topN);\n      final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      final FST.BytesReader fstReader = fst.getBytesReader(0);\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path\");\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n\n          if (results.size() != 0) {\n            // Ran out of paths\n            break;\n          }\n\n          // First pass (top path): start from original fromNode\n          if (topN > 1) {\n            queue = new TreeSet<FSTPath<T>>();\n          }\n\n          T minArcCost = null;\n          FST.Arc<T> minArc = null;\n\n          path = new FSTPath<T>(NO_OUTPUT, fromNode, comparator);\n          fst.readFirstTargetArc(fromNode, path.arc, fstReader);\n\n          // Bootstrap: find the min starting arc\n          while (true) {\n            T arcScore = path.arc.output;\n            //System.out.println(\"  arc=\" + (char) path.arc.label + \" cost=\" + arcScore);\n            if (minArcCost == null || comparator.compare(arcScore, minArcCost) < 0) {\n              minArcCost = arcScore;\n              minArc = scratchArc.copyFrom(path.arc);\n              //System.out.println(\"    **\");\n            }\n            if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert minArc != null;\n\n          if (queue != null) {\n            // Remove top path since we are now going to\n            // pursue it:\n            path = queue.pollFirst();\n            //System.out.println(\"  remove init path=\" + path);\n            assert path.arc.label == minArc.label;\n            if (bottom != null && queue.size() == topN-1) {\n              bottom = queue.last();\n              //System.out.println(\"    set init bottom: \" + bottom);\n            }\n          } else {\n            path.arc.copyFrom(minArc);\n            path.input.grow(1);\n            path.input.ints[0] = minArc.label;\n            path.input.length = 1;\n            path.cost = minArc.output;\n          }\n\n        } else {\n          path = queue.pollFirst();\n          if (path == null) {\n            // There were less than topN paths available:\n            break;\n          }\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost, comparator));\n          continue;\n        }\n\n        if (results.size() == topN-1) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            results.add(new MinResult<T>(path.input, fst.outputs.add(path.cost, path.arc.output), comparator));\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","sourceOld":"    public MinResult<T>[] search() throws IOException {\n      //System.out.println(\"  search topN=\" + topN);\n      final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path\");\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n\n          if (results.size() != 0) {\n            // Ran out of paths\n            break;\n          }\n\n          // First pass (top path): start from original fromNode\n          if (topN > 1) {\n            queue = new TreeSet<FSTPath<T>>();\n          }\n\n          T minArcCost = null;\n          FST.Arc<T> minArc = null;\n\n          path = new FSTPath<T>(NO_OUTPUT, fromNode, comparator);\n          fst.readFirstTargetArc(fromNode, path.arc);\n\n          // Bootstrap: find the min starting arc\n          while (true) {\n            T arcScore = path.arc.output;\n            //System.out.println(\"  arc=\" + (char) path.arc.label + \" cost=\" + arcScore);\n            if (minArcCost == null || comparator.compare(arcScore, minArcCost) < 0) {\n              minArcCost = arcScore;\n              minArc = scratchArc.copyFrom(path.arc);\n              //System.out.println(\"    **\");\n            }\n            if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc);\n          }\n\n          assert minArc != null;\n\n          if (queue != null) {\n            // Remove top path since we are now going to\n            // pursue it:\n            path = queue.pollFirst();\n            //System.out.println(\"  remove init path=\" + path);\n            assert path.arc.label == minArc.label;\n            if (bottom != null && queue.size() == topN-1) {\n              bottom = queue.last();\n              //System.out.println(\"    set init bottom: \" + bottom);\n            }\n          } else {\n            path.arc.copyFrom(minArc);\n            path.input.grow(1);\n            path.input.ints[0] = minArc.label;\n            path.input.length = 1;\n            path.cost = minArc.output;\n          }\n\n        } else {\n          path = queue.pollFirst();\n          if (path == null) {\n            // There were less than topN paths available:\n            break;\n          }\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost, comparator));\n          continue;\n        }\n\n        if (results.size() == topN-1) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            results.add(new MinResult<T>(path.input, fst.outputs.add(path.cost, path.arc.output), comparator));\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6ce825e9276493231308229152c48f755ce1a0a5","date":1348871483,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","sourceNew":"    public MinResult<T>[] search() throws IOException {\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final FST.BytesReader fstReader = fst.getBytesReader(0);\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path\");\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n\n        //System.out.println(\"  remove init path=\" + path);\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost, comparator));\n          continue;\n        }\n\n        if (results.size() == topN-1) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              results.add(new MinResult<T>(path.input, finalOutput, comparator));\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","sourceOld":"    public MinResult<T>[] search() throws IOException {\n      //System.out.println(\"  search topN=\" + topN);\n      final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      final FST.BytesReader fstReader = fst.getBytesReader(0);\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path\");\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n\n          if (results.size() != 0) {\n            // Ran out of paths\n            break;\n          }\n\n          // First pass (top path): start from original fromNode\n          if (topN > 1) {\n            queue = new TreeSet<FSTPath<T>>();\n          }\n\n          T minArcCost = null;\n          FST.Arc<T> minArc = null;\n\n          path = new FSTPath<T>(NO_OUTPUT, fromNode, comparator);\n          fst.readFirstTargetArc(fromNode, path.arc, fstReader);\n\n          // Bootstrap: find the min starting arc\n          while (true) {\n            T arcScore = path.arc.output;\n            //System.out.println(\"  arc=\" + (char) path.arc.label + \" cost=\" + arcScore);\n            if (minArcCost == null || comparator.compare(arcScore, minArcCost) < 0) {\n              minArcCost = arcScore;\n              minArc = scratchArc.copyFrom(path.arc);\n              //System.out.println(\"    **\");\n            }\n            if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert minArc != null;\n\n          if (queue != null) {\n            // Remove top path since we are now going to\n            // pursue it:\n            path = queue.pollFirst();\n            //System.out.println(\"  remove init path=\" + path);\n            assert path.arc.label == minArc.label;\n            if (bottom != null && queue.size() == topN-1) {\n              bottom = queue.last();\n              //System.out.println(\"    set init bottom: \" + bottom);\n            }\n          } else {\n            path.arc.copyFrom(minArc);\n            path.input.grow(1);\n            path.input.ints[0] = minArc.label;\n            path.input.length = 1;\n            path.cost = minArc.output;\n          }\n\n        } else {\n          path = queue.pollFirst();\n          if (path == null) {\n            // There were less than topN paths available:\n            break;\n          }\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost, comparator));\n          continue;\n        }\n\n        if (results.size() == topN-1) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            results.add(new MinResult<T>(path.input, fst.outputs.add(path.cost, path.arc.output), comparator));\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"32eace34e207608926e4c83409c65d968e530bf2","date":1350054443,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","sourceNew":"    public MinResult<T>[] search() throws IOException {\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final FST.BytesReader fstReader = fst.getBytesReader(0);\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n\n        //System.out.println(\"  remove init path=\" + path);\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost, comparator));\n          continue;\n        }\n\n        if (results.size() == topN-1) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              results.add(new MinResult<T>(path.input, finalOutput, comparator));\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","sourceOld":"    public MinResult<T>[] search() throws IOException {\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final FST.BytesReader fstReader = fst.getBytesReader(0);\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path\");\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n\n        //System.out.println(\"  remove init path=\" + path);\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost, comparator));\n          continue;\n        }\n\n        if (results.size() == topN-1) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              results.add(new MinResult<T>(path.input, finalOutput, comparator));\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","bugFix":["bede0ec3497c48e70d55196c5065d97a4bc1db3d"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6efad415dcdbcca7d440f909743e6e3152eeb6c0","date":1350055371,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","sourceNew":"    public MinResult<T>[] search() throws IOException {\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final FST.BytesReader fstReader = fst.getBytesReader(0);\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n\n        //System.out.println(\"  remove init path=\" + path);\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost, comparator));\n          continue;\n        }\n\n        if (results.size() == topN-1) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              results.add(new MinResult<T>(path.input, finalOutput, comparator));\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","sourceOld":"    public MinResult<T>[] search() throws IOException {\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final FST.BytesReader fstReader = fst.getBytesReader(0);\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path\");\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n\n        //System.out.println(\"  remove init path=\" + path);\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost, comparator));\n          continue;\n        }\n\n        if (results.size() == topN-1) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              results.add(new MinResult<T>(path.input, finalOutput, comparator));\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d82832af39f94dbb58a3130fd216ff1d49435589","date":1350147242,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","sourceNew":"    public MinResult<T>[] search() throws IOException {\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final FST.BytesReader fstReader = fst.getBytesReader(0);\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n\n        //System.out.println(\"  remove init path=\" + path);\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost, comparator));\n          continue;\n        }\n\n        if (results.size() == topN-1) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              results.add(new MinResult<T>(path.input, finalOutput, comparator));\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","sourceOld":"    public MinResult<T>[] search() throws IOException {\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final FST.BytesReader fstReader = fst.getBytesReader(0);\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path\");\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n\n        //System.out.println(\"  remove init path=\" + path);\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost, comparator));\n          continue;\n        }\n\n        if (results.size() == topN-1) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              results.add(new MinResult<T>(path.input, finalOutput, comparator));\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56f67b2f1d8c5140b4f57f0c01298df5cf8021c4","date":1350584314,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","sourceNew":"    public MinResult<T>[] search() throws IOException {\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final FST.BytesReader fstReader = fst.getBytesReader(0);\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n\n        //System.out.println(\"  remove init path=\" + path);\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost, comparator));\n          continue;\n        }\n\n        // nocommit this isn't safe?  last path could be rejected?\n        if (results.size() == topN-1) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              results.add(new MinResult<T>(path.input, finalOutput, comparator));\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","sourceOld":"    public MinResult<T>[] search() throws IOException {\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final FST.BytesReader fstReader = fst.getBytesReader(0);\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n\n        //System.out.println(\"  remove init path=\" + path);\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost, comparator));\n          continue;\n        }\n\n        if (results.size() == topN-1) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              results.add(new MinResult<T>(path.input, finalOutput, comparator));\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"540a35dcd44dcf1fbbe1821d931abb31e10935c7","date":1350584353,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","sourceNew":"    public MinResult<T>[] search() throws IOException {\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final FST.BytesReader fstReader = fst.getBytesReader(0);\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n\n        //System.out.println(\"  remove init path=\" + path);\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost, comparator));\n          continue;\n        }\n\n        if (results.size() == topN-1) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              results.add(new MinResult<T>(path.input, finalOutput, comparator));\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","sourceOld":"    public MinResult<T>[] search() throws IOException {\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final FST.BytesReader fstReader = fst.getBytesReader(0);\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n\n        //System.out.println(\"  remove init path=\" + path);\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost, comparator));\n          continue;\n        }\n\n        // nocommit this isn't safe?  last path could be rejected?\n        if (results.size() == topN-1) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              results.add(new MinResult<T>(path.input, finalOutput, comparator));\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"59aedb6464136dd3cd73d343e814ba8acf3da155","date":1350729779,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","sourceNew":"    public MinResult<T>[] search() throws IOException {\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final FST.BytesReader fstReader = fst.getBytesReader(0);\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost, comparator));\n          continue;\n        }\n\n        // LUCENE-4481: TODO: re-enable this pruning if we can make this admissible:\n        /*\n        if (results.size() == topN-1) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n        */\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              results.add(new MinResult<T>(path.input, finalOutput, comparator));\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","sourceOld":"    public MinResult<T>[] search() throws IOException {\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final FST.BytesReader fstReader = fst.getBytesReader(0);\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n\n        //System.out.println(\"  remove init path=\" + path);\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost, comparator));\n          continue;\n        }\n\n        if (results.size() == topN-1) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              results.add(new MinResult<T>(path.input, finalOutput, comparator));\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","bugFix":null,"bugIntro":["414aae1db83a83d247caa9514e383e4ca3d43da5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"414aae1db83a83d247caa9514e383e4ca3d43da5","date":1350824365,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","sourceNew":"    public MinResult<T>[] search() throws IOException {\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final FST.BytesReader fstReader = fst.getBytesReader(0);\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n      int rejectCount = 0;\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost, comparator));\n          continue;\n        }\n\n        if (results.size() == topN-1 && maxQueueDepth == topN) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              results.add(new MinResult<T>(path.input, finalOutput, comparator));\n            } else {\n              rejectCount++;\n              assert rejectCount + topN <= maxQueueDepth: \"maxQueueDepth (\" + maxQueueDepth + \") is too small for topN (\" + topN + \"): rejected \" + rejectCount + \" paths\";\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","sourceOld":"    public MinResult<T>[] search() throws IOException {\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final FST.BytesReader fstReader = fst.getBytesReader(0);\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost, comparator));\n          continue;\n        }\n\n        // LUCENE-4481: TODO: re-enable this pruning if we can make this admissible:\n        /*\n        if (results.size() == topN-1) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n        */\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              results.add(new MinResult<T>(path.input, finalOutput, comparator));\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","bugFix":["59aedb6464136dd3cd73d343e814ba8acf3da155","bede0ec3497c48e70d55196c5065d97a4bc1db3d"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"62e52115b56781006682fd92c6938efaf174304d","date":1351014780,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","sourceNew":"    public MinResult<T>[] search() throws IOException {\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final FST.BytesReader fstReader = fst.getBytesReader(0);\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n      int rejectCount = 0;\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost, comparator));\n          continue;\n        }\n\n        if (results.size() == topN-1 && maxQueueDepth == topN) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              results.add(new MinResult<T>(path.input, finalOutput, comparator));\n            } else {\n              rejectCount++;\n              assert rejectCount + topN <= maxQueueDepth: \"maxQueueDepth (\" + maxQueueDepth + \") is too small for topN (\" + topN + \"): rejected \" + rejectCount + \" paths\";\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","sourceOld":"    public MinResult<T>[] search() throws IOException {\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final FST.BytesReader fstReader = fst.getBytesReader(0);\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n\n        //System.out.println(\"  remove init path=\" + path);\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost, comparator));\n          continue;\n        }\n\n        if (results.size() == topN-1) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              results.add(new MinResult<T>(path.input, finalOutput, comparator));\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a81c53232b7a347a2a79b731a0b152059237a4b5","date":1351810824,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","sourceNew":"    public MinResult<T>[] search() throws IOException {\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final FST.BytesReader fstReader = fst.getBytesReader(0);\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n      int rejectCount = 0;\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost));\n          continue;\n        }\n\n        if (results.size() == topN-1 && maxQueueDepth == topN) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              results.add(new MinResult<T>(path.input, finalOutput));\n            } else {\n              rejectCount++;\n              assert rejectCount + topN <= maxQueueDepth: \"maxQueueDepth (\" + maxQueueDepth + \") is too small for topN (\" + topN + \"): rejected \" + rejectCount + \" paths\";\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","sourceOld":"    public MinResult<T>[] search() throws IOException {\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final FST.BytesReader fstReader = fst.getBytesReader(0);\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n      int rejectCount = 0;\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost, comparator));\n          continue;\n        }\n\n        if (results.size() == topN-1 && maxQueueDepth == topN) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              results.add(new MinResult<T>(path.input, finalOutput, comparator));\n            } else {\n              rejectCount++;\n              assert rejectCount + topN <= maxQueueDepth: \"maxQueueDepth (\" + maxQueueDepth + \") is too small for topN (\" + topN + \"): rejected \" + rejectCount + \" paths\";\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"87e78f3c129251e74ecc2ff73a32de0f27cf09d5","date":1358006150,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","sourceNew":"    public MinResult<T>[] search() throws IOException {\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final BytesReader fstReader = fst.getBytesReader(0);\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n      int rejectCount = 0;\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost));\n          continue;\n        }\n\n        if (results.size() == topN-1 && maxQueueDepth == topN) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              results.add(new MinResult<T>(path.input, finalOutput));\n            } else {\n              rejectCount++;\n              assert rejectCount + topN <= maxQueueDepth: \"maxQueueDepth (\" + maxQueueDepth + \") is too small for topN (\" + topN + \"): rejected \" + rejectCount + \" paths\";\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","sourceOld":"    public MinResult<T>[] search() throws IOException {\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final FST.BytesReader fstReader = fst.getBytesReader(0);\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n      int rejectCount = 0;\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost));\n          continue;\n        }\n\n        if (results.size() == topN-1 && maxQueueDepth == topN) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              results.add(new MinResult<T>(path.input, finalOutput));\n            } else {\n              rejectCount++;\n              assert rejectCount + topN <= maxQueueDepth: \"maxQueueDepth (\" + maxQueueDepth + \") is too small for topN (\" + topN + \"): rejected \" + rejectCount + \" paths\";\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8917bfede3b4ca30f4305c1e391e9218959cd723","date":1358189662,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","sourceNew":"    public MinResult<T>[] search() throws IOException {\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final BytesReader fstReader = fst.getBytesReader(0);\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n      int rejectCount = 0;\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost));\n          continue;\n        }\n\n        if (results.size() == topN-1 && maxQueueDepth == topN) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              results.add(new MinResult<T>(path.input, finalOutput));\n            } else {\n              rejectCount++;\n              assert rejectCount + topN <= maxQueueDepth: \"maxQueueDepth (\" + maxQueueDepth + \") is too small for topN (\" + topN + \"): rejected \" + rejectCount + \" paths\";\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","sourceOld":"    public MinResult<T>[] search() throws IOException {\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final FST.BytesReader fstReader = fst.getBytesReader(0);\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n      int rejectCount = 0;\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost));\n          continue;\n        }\n\n        if (results.size() == topN-1 && maxQueueDepth == topN) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              results.add(new MinResult<T>(path.input, finalOutput));\n            } else {\n              rejectCount++;\n              assert rejectCount + topN <= maxQueueDepth: \"maxQueueDepth (\" + maxQueueDepth + \") is too small for topN (\" + topN + \"): rejected \" + rejectCount + \" paths\";\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"82557a475db3e0849171dc0be5b02e3ae0745ddb","date":1358195918,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","sourceNew":"    public MinResult<T>[] search() throws IOException {\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final BytesReader fstReader = fst.getBytesReader();\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n      int rejectCount = 0;\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost));\n          continue;\n        }\n\n        if (results.size() == topN-1 && maxQueueDepth == topN) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              results.add(new MinResult<T>(path.input, finalOutput));\n            } else {\n              rejectCount++;\n              assert rejectCount + topN <= maxQueueDepth: \"maxQueueDepth (\" + maxQueueDepth + \") is too small for topN (\" + topN + \"): rejected \" + rejectCount + \" paths\";\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","sourceOld":"    public MinResult<T>[] search() throws IOException {\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final BytesReader fstReader = fst.getBytesReader(0);\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n      int rejectCount = 0;\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost));\n          continue;\n        }\n\n        if (results.size() == topN-1 && maxQueueDepth == topN) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              results.add(new MinResult<T>(path.input, finalOutput));\n            } else {\n              rejectCount++;\n              assert rejectCount + topN <= maxQueueDepth: \"maxQueueDepth (\" + maxQueueDepth + \") is too small for topN (\" + topN + \"): rejected \" + rejectCount + \" paths\";\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c4015cd39dff8d4dec562d909f9766debac53aa6","date":1358548736,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","sourceNew":"    public MinResult<T>[] search() throws IOException {\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final BytesReader fstReader = fst.getBytesReader();\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n      int rejectCount = 0;\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost));\n          continue;\n        }\n\n        if (results.size() == topN-1 && maxQueueDepth == topN) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              results.add(new MinResult<T>(path.input, finalOutput));\n            } else {\n              rejectCount++;\n              assert rejectCount + topN <= maxQueueDepth: \"maxQueueDepth (\" + maxQueueDepth + \") is too small for topN (\" + topN + \"): rejected \" + rejectCount + \" paths\";\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","sourceOld":"    public MinResult<T>[] search() throws IOException {\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final BytesReader fstReader = fst.getBytesReader(0);\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n      int rejectCount = 0;\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost));\n          continue;\n        }\n\n        if (results.size() == topN-1 && maxQueueDepth == topN) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              results.add(new MinResult<T>(path.input, finalOutput));\n            } else {\n              rejectCount++;\n              assert rejectCount + topN <= maxQueueDepth: \"maxQueueDepth (\" + maxQueueDepth + \") is too small for topN (\" + topN + \"): rejected \" + rejectCount + \" paths\";\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0af0c31a687dd847212ae59f661152896c76516","date":1380727430,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","sourceNew":"    public MinResult<T>[] search() throws IOException {\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final BytesReader fstReader = fst.getBytesReader();\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n      int rejectCount = 0;\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          //System.out.println(\"  break queue=null\");\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          //System.out.println(\"  break no more paths\");\n          break;\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost));\n          continue;\n        }\n\n        if (results.size() == topN-1 && maxQueueDepth == topN) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              //System.out.println(\"    add result: \" + path);\n              results.add(new MinResult<T>(path.input, finalOutput));\n            } else {\n              rejectCount++;\n              assert rejectCount + topN <= maxQueueDepth: \"maxQueueDepth (\" + maxQueueDepth + \") is too small for topN (\" + topN + \"): rejected \" + rejectCount + \" paths\";\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","sourceOld":"    public MinResult<T>[] search() throws IOException {\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final BytesReader fstReader = fst.getBytesReader();\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n      int rejectCount = 0;\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost));\n          continue;\n        }\n\n        if (results.size() == topN-1 && maxQueueDepth == topN) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              results.add(new MinResult<T>(path.input, finalOutput));\n            } else {\n              rejectCount++;\n              assert rejectCount + topN <= maxQueueDepth: \"maxQueueDepth (\" + maxQueueDepth + \") is too small for topN (\" + topN + \"): rejected \" + rejectCount + \" paths\";\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","sourceNew":"    public MinResult<T>[] search() throws IOException {\n\n      final List<MinResult<T>> results = new ArrayList<>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final BytesReader fstReader = fst.getBytesReader();\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n      int rejectCount = 0;\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          //System.out.println(\"  break queue=null\");\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          //System.out.println(\"  break no more paths\");\n          break;\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<>(path.input, path.cost));\n          continue;\n        }\n\n        if (results.size() == topN-1 && maxQueueDepth == topN) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              //System.out.println(\"    add result: \" + path);\n              results.add(new MinResult<>(path.input, finalOutput));\n            } else {\n              rejectCount++;\n              assert rejectCount + topN <= maxQueueDepth: \"maxQueueDepth (\" + maxQueueDepth + \") is too small for topN (\" + topN + \"): rejected \" + rejectCount + \" paths\";\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","sourceOld":"    public MinResult<T>[] search() throws IOException {\n\n      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final BytesReader fstReader = fst.getBytesReader();\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n      int rejectCount = 0;\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          //System.out.println(\"  break queue=null\");\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          //System.out.println(\"  break no more paths\");\n          break;\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<T>(path.input, path.cost));\n          continue;\n        }\n\n        if (results.size() == topN-1 && maxQueueDepth == topN) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              //System.out.println(\"    add result: \" + path);\n              results.add(new MinResult<T>(path.input, finalOutput));\n            } else {\n              rejectCount++;\n              assert rejectCount + topN <= maxQueueDepth: \"maxQueueDepth (\" + maxQueueDepth + \") is too small for topN (\" + topN + \"): rejected \" + rejectCount + \" paths\";\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d245db17aaa41b338dae9da5d4edba4dd6f61612","date":1394644847,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","sourceNew":"    public TopResults<T> search() throws IOException {\n\n      final List<Result<T>> results = new ArrayList<>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final BytesReader fstReader = fst.getBytesReader();\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n      int rejectCount = 0;\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          //System.out.println(\"  break queue=null\");\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          //System.out.println(\"  break no more paths\");\n          break;\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new Result<>(path.input, path.cost));\n          continue;\n        }\n\n        if (results.size() == topN-1 && maxQueueDepth == topN) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              //System.out.println(\"    add result: \" + path);\n              results.add(new Result(path.input, finalOutput));\n            } else {\n              rejectCount++;\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n      return new TopResults(rejectCount + topN <= maxQueueDepth, results);\n    }\n\n","sourceOld":"    public MinResult<T>[] search() throws IOException {\n\n      final List<MinResult<T>> results = new ArrayList<>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final BytesReader fstReader = fst.getBytesReader();\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n      int rejectCount = 0;\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          //System.out.println(\"  break queue=null\");\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          //System.out.println(\"  break no more paths\");\n          break;\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new MinResult<>(path.input, path.cost));\n          continue;\n        }\n\n        if (results.size() == topN-1 && maxQueueDepth == topN) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              //System.out.println(\"    add result: \" + path);\n              results.add(new MinResult<>(path.input, finalOutput));\n            } else {\n              rejectCount++;\n              assert rejectCount + topN <= maxQueueDepth: \"maxQueueDepth (\" + maxQueueDepth + \") is too small for topN (\" + topN + \"): rejected \" + rejectCount + \" paths\";\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n    \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final MinResult<T>[] arr =\n        (MinResult<T>[]) new MinResult[results.size()];\n      return results.toArray(arr);\n    }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"122574a95710afd6a0af00c4d1aea9f6fcaeab96","date":1394699691,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","sourceNew":"    public TopResults<T> search() throws IOException {\n\n      final List<Result<T>> results = new ArrayList<>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final BytesReader fstReader = fst.getBytesReader();\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n      int rejectCount = 0;\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          //System.out.println(\"  break queue=null\");\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          //System.out.println(\"  break no more paths\");\n          break;\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new Result<>(path.input, path.cost));\n          continue;\n        }\n\n        if (results.size() == topN-1 && maxQueueDepth == topN) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              //System.out.println(\"    add result: \" + path);\n              results.add(new Result<>(path.input, finalOutput));\n            } else {\n              rejectCount++;\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n      return new TopResults<>(rejectCount + topN <= maxQueueDepth, results);\n    }\n\n","sourceOld":"    public TopResults<T> search() throws IOException {\n\n      final List<Result<T>> results = new ArrayList<>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final BytesReader fstReader = fst.getBytesReader();\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n      int rejectCount = 0;\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          //System.out.println(\"  break queue=null\");\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          //System.out.println(\"  break no more paths\");\n          break;\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new Result<>(path.input, path.cost));\n          continue;\n        }\n\n        if (results.size() == topN-1 && maxQueueDepth == topN) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              //System.out.println(\"    add result: \" + path);\n              results.add(new Result(path.input, finalOutput));\n            } else {\n              rejectCount++;\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n      return new TopResults(rejectCount + topN <= maxQueueDepth, results);\n    }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","sourceNew":"    public TopResults<T> search() throws IOException {\n\n      final List<Result<T>> results = new ArrayList<>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final BytesReader fstReader = fst.getBytesReader();\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n      int rejectCount = 0;\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          //System.out.println(\"  break queue=null\");\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          //System.out.println(\"  break no more paths\");\n          break;\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.setLength(path.input.length() - 1);\n          results.add(new Result<>(path.input.get(), path.cost));\n          continue;\n        }\n\n        if (results.size() == topN-1 && maxQueueDepth == topN) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input.get(), finalOutput)) {\n              //System.out.println(\"    add result: \" + path);\n              results.add(new Result<>(path.input.get(), finalOutput));\n            } else {\n              rejectCount++;\n            }\n            break;\n          } else {\n            path.input.append(path.arc.label);\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n      return new TopResults<>(rejectCount + topN <= maxQueueDepth, results);\n    }\n\n","sourceOld":"    public TopResults<T> search() throws IOException {\n\n      final List<Result<T>> results = new ArrayList<>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final BytesReader fstReader = fst.getBytesReader();\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n      int rejectCount = 0;\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          //System.out.println(\"  break queue=null\");\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          //System.out.println(\"  break no more paths\");\n          break;\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.length--;\n          results.add(new Result<>(path.input, path.cost));\n          continue;\n        }\n\n        if (results.size() == topN-1 && maxQueueDepth == topN) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input, finalOutput)) {\n              //System.out.println(\"    add result: \" + path);\n              results.add(new Result<>(path.input, finalOutput));\n            } else {\n              rejectCount++;\n            }\n            break;\n          } else {\n            path.input.grow(1+path.input.length);\n            path.input.ints[path.input.length] = path.arc.label;\n            path.input.length++;\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n      return new TopResults<>(rejectCount + topN <= maxQueueDepth, results);\n    }\n\n","bugFix":["122574a95710afd6a0af00c4d1aea9f6fcaeab96","d245db17aaa41b338dae9da5d4edba4dd6f61612","6ce825e9276493231308229152c48f755ce1a0a5","bede0ec3497c48e70d55196c5065d97a4bc1db3d"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8c33f6677a2078739058f81eca1df69d12cd62b0","date":1432799589,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","sourceNew":"    public TopResults<T> search() throws IOException {\n\n      final List<Result<T>> results = new ArrayList<>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final BytesReader fstReader = fst.getBytesReader();\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n      int rejectCount = 0;\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          //System.out.println(\"  break queue=null\");\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          //System.out.println(\"  break no more paths\");\n          break;\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.setLength(path.input.length() - 1);\n          results.add(new Result<>(path.input.get(), path.cost));\n          continue;\n        }\n\n        if (results.size() == topN-1 && maxQueueDepth == topN) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path)) {\n              //System.out.println(\"    add result: \" + path);\n              results.add(new Result<>(path.input.get(), path.cost));\n            } else {\n              rejectCount++;\n            }\n            break;\n          } else {\n            path.input.append(path.arc.label);\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n      return new TopResults<>(rejectCount + topN <= maxQueueDepth, results);\n    }\n\n","sourceOld":"    public TopResults<T> search() throws IOException {\n\n      final List<Result<T>> results = new ArrayList<>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final BytesReader fstReader = fst.getBytesReader();\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n      int rejectCount = 0;\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          //System.out.println(\"  break queue=null\");\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          //System.out.println(\"  break no more paths\");\n          break;\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.setLength(path.input.length() - 1);\n          results.add(new Result<>(path.input.get(), path.cost));\n          continue;\n        }\n\n        if (results.size() == topN-1 && maxQueueDepth == topN) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            T finalOutput = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path.input.get(), finalOutput)) {\n              //System.out.println(\"    add result: \" + path);\n              results.add(new Result<>(path.input.get(), finalOutput));\n            } else {\n              rejectCount++;\n            }\n            break;\n          } else {\n            path.input.append(path.arc.label);\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n      return new TopResults<>(rejectCount + topN <= maxQueueDepth, results);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"902a92b60648a8925bfd9bb53a78669cd2ea98fd","date":1487797466,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","sourceNew":"    public TopResults<T> search() throws IOException {\n\n      final List<Result<T>> results = new ArrayList<>();\n\n      final BytesReader fstReader = fst.getBytesReader();\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n      int rejectCount = 0;\n\n      // For each top N path:\n      while (results.size() < topN) {\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n        //System.out.println(\"pop path=\" + path + \" arc=\" + path.arc.output);\n\n        if (acceptPartialPath(path) == false) {\n          continue;\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          // Empty string!\n          path.input.setLength(path.input.length() - 1);\n          results.add(new Result<>(path.input.get(), path.output));\n          continue;\n        }\n\n        if (results.size() == topN-1 && maxQueueDepth == topN) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            path.output = fst.outputs.add(path.output, path.arc.output);\n            if (acceptResult(path)) {\n              results.add(new Result<>(path.input.get(), path.output));\n            } else {\n              rejectCount++;\n            }\n            break;\n          } else {\n            path.input.append(path.arc.label);\n            path.output = fst.outputs.add(path.output, path.arc.output);\n            if (acceptPartialPath(path) == false) {\n              break;\n            }\n          }\n        }\n      }\n      return new TopResults<>(rejectCount + topN <= maxQueueDepth, results);\n    }\n\n","sourceOld":"    public TopResults<T> search() throws IOException {\n\n      final List<Result<T>> results = new ArrayList<>();\n\n      //System.out.println(\"search topN=\" + topN);\n\n      final BytesReader fstReader = fst.getBytesReader();\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n      int rejectCount = 0;\n\n      // For each top N path:\n      while (results.size() < topN) {\n        //System.out.println(\"\\nfind next path: queue.size=\" + queue.size());\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          //System.out.println(\"  break queue=null\");\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          //System.out.println(\"  break no more paths\");\n          break;\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          //System.out.println(\"    empty string!  cost=\" + path.cost);\n          // Empty string!\n          path.input.setLength(path.input.length() - 1);\n          results.add(new Result<>(path.input.get(), path.cost));\n          continue;\n        }\n\n        if (results.size() == topN-1 && maxQueueDepth == topN) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        //System.out.println(\"  path: \" + path);\n        \n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          //System.out.println(\"\\n    cycle path: \" + path);         \n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            //System.out.println(\"      arc=\" + (char) path.arc.label + \" cost=\" + path.arc.output);\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            //System.out.println(\"    done!: \" + path);\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n            if (acceptResult(path)) {\n              //System.out.println(\"    add result: \" + path);\n              results.add(new Result<>(path.input.get(), path.cost));\n            } else {\n              rejectCount++;\n            }\n            break;\n          } else {\n            path.input.append(path.arc.label);\n            path.cost = fst.outputs.add(path.cost, path.arc.output);\n          }\n        }\n      }\n      return new TopResults<>(rejectCount + topN <= maxQueueDepth, results);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54204c8a3ca26aeafd273139fc29baf70d0f6786","date":1564170395,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","sourceNew":"    public TopResults<T> search() throws IOException {\n\n      final List<Result<T>> results = new ArrayList<>();\n\n      final BytesReader fstReader = fst.getBytesReader();\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n      int rejectCount = 0;\n\n      // For each top N path:\n      while (results.size() < topN) {\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n        //System.out.println(\"pop path=\" + path + \" arc=\" + path.arc.output);\n\n        if (acceptPartialPath(path) == false) {\n          continue;\n        }\n\n        if (path.arc.label() == FST.END_LABEL) {\n          // Empty string!\n          path.input.setLength(path.input.length() - 1);\n          results.add(new Result<>(path.input.get(), path.output));\n          continue;\n        }\n\n        if (results.size() == topN-1 && maxQueueDepth == topN) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output()) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label() == FST.END_LABEL) {\n            // Add final output:\n            path.output = fst.outputs.add(path.output, path.arc.output());\n            if (acceptResult(path)) {\n              results.add(new Result<>(path.input.get(), path.output));\n            } else {\n              rejectCount++;\n            }\n            break;\n          } else {\n            path.input.append(path.arc.label());\n            path.output = fst.outputs.add(path.output, path.arc.output());\n            if (acceptPartialPath(path) == false) {\n              break;\n            }\n          }\n        }\n      }\n      return new TopResults<>(rejectCount + topN <= maxQueueDepth, results);\n    }\n\n","sourceOld":"    public TopResults<T> search() throws IOException {\n\n      final List<Result<T>> results = new ArrayList<>();\n\n      final BytesReader fstReader = fst.getBytesReader();\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n      int rejectCount = 0;\n\n      // For each top N path:\n      while (results.size() < topN) {\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n        //System.out.println(\"pop path=\" + path + \" arc=\" + path.arc.output);\n\n        if (acceptPartialPath(path) == false) {\n          continue;\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          // Empty string!\n          path.input.setLength(path.input.length() - 1);\n          results.add(new Result<>(path.input.get(), path.output));\n          continue;\n        }\n\n        if (results.size() == topN-1 && maxQueueDepth == topN) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            path.output = fst.outputs.add(path.output, path.arc.output);\n            if (acceptResult(path)) {\n              results.add(new Result<>(path.input.get(), path.output));\n            } else {\n              rejectCount++;\n            }\n            break;\n          } else {\n            path.input.append(path.arc.label);\n            path.output = fst.outputs.add(path.output, path.arc.output);\n            if (acceptPartialPath(path) == false) {\n              break;\n            }\n          }\n        }\n      }\n      return new TopResults<>(rejectCount + topN <= maxQueueDepth, results);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f8061ddd97f3352007d927dae445884a6f3d857b","date":1564988276,"type":3,"author":"Atri Sharma","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","sourceNew":"    public TopResults<T> search() throws IOException {\n\n      final List<Result<T>> results = new ArrayList<>();\n\n      final BytesReader fstReader = fst.getBytesReader();\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n      int rejectCount = 0;\n\n      // For each top N path:\n      while (results.size() < topN) {\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n        //System.out.println(\"pop path=\" + path + \" arc=\" + path.arc.output);\n\n        if (acceptPartialPath(path) == false) {\n          continue;\n        }\n\n        if (path.arc.label() == FST.END_LABEL) {\n          // Empty string!\n          path.input.setLength(path.input.length() - 1);\n          results.add(new Result<>(path.input.get(), path.output));\n          continue;\n        }\n\n        if (results.size() == topN-1 && maxQueueDepth == topN) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output()) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label() == FST.END_LABEL) {\n            // Add final output:\n            path.output = fst.outputs.add(path.output, path.arc.output());\n            if (acceptResult(path)) {\n              results.add(new Result<>(path.input.get(), path.output));\n            } else {\n              rejectCount++;\n            }\n            break;\n          } else {\n            path.input.append(path.arc.label());\n            path.output = fst.outputs.add(path.output, path.arc.output());\n            if (acceptPartialPath(path) == false) {\n              break;\n            }\n          }\n        }\n      }\n      return new TopResults<>(rejectCount + topN <= maxQueueDepth, results);\n    }\n\n","sourceOld":"    public TopResults<T> search() throws IOException {\n\n      final List<Result<T>> results = new ArrayList<>();\n\n      final BytesReader fstReader = fst.getBytesReader();\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n      int rejectCount = 0;\n\n      // For each top N path:\n      while (results.size() < topN) {\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n        //System.out.println(\"pop path=\" + path + \" arc=\" + path.arc.output);\n\n        if (acceptPartialPath(path) == false) {\n          continue;\n        }\n\n        if (path.arc.label == FST.END_LABEL) {\n          // Empty string!\n          path.input.setLength(path.input.length() - 1);\n          results.add(new Result<>(path.input.get(), path.output));\n          continue;\n        }\n\n        if (results.size() == topN-1 && maxQueueDepth == topN) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label == FST.END_LABEL) {\n            // Add final output:\n            path.output = fst.outputs.add(path.output, path.arc.output);\n            if (acceptResult(path)) {\n              results.add(new Result<>(path.input.get(), path.output));\n            } else {\n              rejectCount++;\n            }\n            break;\n          } else {\n            path.input.append(path.arc.label);\n            path.output = fst.outputs.add(path.output, path.arc.output);\n            if (acceptPartialPath(path) == false) {\n              break;\n            }\n          }\n        }\n      }\n      return new TopResults<>(rejectCount + topN <= maxQueueDepth, results);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06086b5bd0f0d57858f0675becc58edf1f6b7c11","date":1586421397,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util.TopNSearcher#search().mjava","sourceNew":"    public TopResults<T> search() throws IOException {\n\n      final List<Result<T>> results = new ArrayList<>();\n\n      final BytesReader fstReader = fst.getBytesReader();\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n      int rejectCount = 0;\n\n      // For each top N path:\n      while (results.size() < topN) {\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n        //System.out.println(\"pop path=\" + path + \" arc=\" + path.arc.output);\n\n        if (acceptPartialPath(path) == false) {\n          continue;\n        }\n\n        if (path.arc.label() == FST.END_LABEL) {\n          // Empty string!\n          path.input.setLength(path.input.length() - 1);\n          results.add(new Result<>(path.input.get(), path.output));\n          continue;\n        }\n\n        if (results.size() == topN-1 && maxQueueDepth == topN) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          boolean arcCopyIsPending = false;\n          while(true) {\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output()) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                arcCopyIsPending = true;\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            if (arcCopyIsPending) {\n              scratchArc.copyFrom(path.arc);\n              arcCopyIsPending = false;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null && !arcCopyIsPending) {\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label() == FST.END_LABEL) {\n            // Add final output:\n            path.output = fst.outputs.add(path.output, path.arc.output());\n            if (acceptResult(path)) {\n              results.add(new Result<>(path.input.get(), path.output));\n            } else {\n              rejectCount++;\n            }\n            break;\n          } else {\n            path.input.append(path.arc.label());\n            path.output = fst.outputs.add(path.output, path.arc.output());\n            if (acceptPartialPath(path) == false) {\n              break;\n            }\n          }\n        }\n      }\n      return new TopResults<>(rejectCount + topN <= maxQueueDepth, results);\n    }\n\n","sourceOld":"    public TopResults<T> search() throws IOException {\n\n      final List<Result<T>> results = new ArrayList<>();\n\n      final BytesReader fstReader = fst.getBytesReader();\n      final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n      // TODO: we could enable FST to sorting arcs by weight\n      // as it freezes... can easily do this on first pass\n      // (w/o requiring rewrite)\n\n      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?\n      // (nibbles)\n      int rejectCount = 0;\n\n      // For each top N path:\n      while (results.size() < topN) {\n\n        FSTPath<T> path;\n\n        if (queue == null) {\n          // Ran out of paths\n          break;\n        }\n\n        // Remove top path since we are now going to\n        // pursue it:\n        path = queue.pollFirst();\n\n        if (path == null) {\n          // There were less than topN paths available:\n          break;\n        }\n        //System.out.println(\"pop path=\" + path + \" arc=\" + path.arc.output);\n\n        if (acceptPartialPath(path) == false) {\n          continue;\n        }\n\n        if (path.arc.label() == FST.END_LABEL) {\n          // Empty string!\n          path.input.setLength(path.input.length() - 1);\n          results.add(new Result<>(path.input.get(), path.output));\n          continue;\n        }\n\n        if (results.size() == topN-1 && maxQueueDepth == topN) {\n          // Last path -- don't bother w/ queue anymore:\n          queue = null;\n        }\n\n        // We take path and find its \"0 output completion\",\n        // ie, just keep traversing the first arc with\n        // NO_OUTPUT that we can find, since this must lead\n        // to the minimum path that completes from\n        // path.arc.\n\n        // For each input letter:\n        while (true) {\n\n          fst.readFirstTargetArc(path.arc, path.arc, fstReader);\n\n          // For each arc leaving this node:\n          boolean foundZero = false;\n          while(true) {\n            // tricky: instead of comparing output == 0, we must\n            // express it via the comparator compare(output, 0) == 0\n            if (comparator.compare(NO_OUTPUT, path.arc.output()) == 0) {\n              if (queue == null) {\n                foundZero = true;\n                break;\n              } else if (!foundZero) {\n                scratchArc.copyFrom(path.arc);\n                foundZero = true;\n              } else {\n                addIfCompetitive(path);\n              }\n            } else if (queue != null) {\n              addIfCompetitive(path);\n            }\n            if (path.arc.isLast()) {\n              break;\n            }\n            fst.readNextArc(path.arc, fstReader);\n          }\n\n          assert foundZero;\n\n          if (queue != null) {\n            // TODO: maybe we can save this copyFrom if we\n            // are more clever above... eg on finding the\n            // first NO_OUTPUT arc we'd switch to using\n            // scratchArc\n            path.arc.copyFrom(scratchArc);\n          }\n\n          if (path.arc.label() == FST.END_LABEL) {\n            // Add final output:\n            path.output = fst.outputs.add(path.output, path.arc.output());\n            if (acceptResult(path)) {\n              results.add(new Result<>(path.input.get(), path.output));\n            } else {\n              rejectCount++;\n            }\n            break;\n          } else {\n            path.input.append(path.arc.label());\n            path.output = fst.outputs.add(path.output, path.arc.output());\n            if (acceptPartialPath(path) == false) {\n              break;\n            }\n          }\n        }\n      }\n      return new TopResults<>(rejectCount + topN <= maxQueueDepth, results);\n    }\n\n","bugFix":["bede0ec3497c48e70d55196c5065d97a4bc1db3d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"82557a475db3e0849171dc0be5b02e3ae0745ddb":["87e78f3c129251e74ecc2ff73a32de0f27cf09d5"],"d245db17aaa41b338dae9da5d4edba4dd6f61612":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"59aedb6464136dd3cd73d343e814ba8acf3da155":["540a35dcd44dcf1fbbe1821d931abb31e10935c7"],"8b9fb5afeea0288262bffcc55bdcda8b5fa272c8":["5bd0058ffa806ba5d3b6cb38ab7de828d8b46970"],"c4015cd39dff8d4dec562d909f9766debac53aa6":["8917bfede3b4ca30f4305c1e391e9218959cd723","82557a475db3e0849171dc0be5b02e3ae0745ddb"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["bede0ec3497c48e70d55196c5065d97a4bc1db3d","5bd0058ffa806ba5d3b6cb38ab7de828d8b46970"],"8917bfede3b4ca30f4305c1e391e9218959cd723":["a81c53232b7a347a2a79b731a0b152059237a4b5","87e78f3c129251e74ecc2ff73a32de0f27cf09d5"],"414aae1db83a83d247caa9514e383e4ca3d43da5":["59aedb6464136dd3cd73d343e814ba8acf3da155"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["122574a95710afd6a0af00c4d1aea9f6fcaeab96"],"902a92b60648a8925bfd9bb53a78669cd2ea98fd":["8c33f6677a2078739058f81eca1df69d12cd62b0"],"2a6ee6c302710254b6c2474ccd2755f9f2323ee3":["bede0ec3497c48e70d55196c5065d97a4bc1db3d"],"56f67b2f1d8c5140b4f57f0c01298df5cf8021c4":["32eace34e207608926e4c83409c65d968e530bf2"],"d82832af39f94dbb58a3130fd216ff1d49435589":["6ce825e9276493231308229152c48f755ce1a0a5","32eace34e207608926e4c83409c65d968e530bf2"],"06086b5bd0f0d57858f0675becc58edf1f6b7c11":["54204c8a3ca26aeafd273139fc29baf70d0f6786"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6ce825e9276493231308229152c48f755ce1a0a5":["8b9fb5afeea0288262bffcc55bdcda8b5fa272c8"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["d0af0c31a687dd847212ae59f661152896c76516"],"a81c53232b7a347a2a79b731a0b152059237a4b5":["414aae1db83a83d247caa9514e383e4ca3d43da5"],"540a35dcd44dcf1fbbe1821d931abb31e10935c7":["56f67b2f1d8c5140b4f57f0c01298df5cf8021c4"],"87e78f3c129251e74ecc2ff73a32de0f27cf09d5":["a81c53232b7a347a2a79b731a0b152059237a4b5"],"32eace34e207608926e4c83409c65d968e530bf2":["6ce825e9276493231308229152c48f755ce1a0a5"],"f8061ddd97f3352007d927dae445884a6f3d857b":["902a92b60648a8925bfd9bb53a78669cd2ea98fd","54204c8a3ca26aeafd273139fc29baf70d0f6786"],"6efad415dcdbcca7d440f909743e6e3152eeb6c0":["6ce825e9276493231308229152c48f755ce1a0a5","32eace34e207608926e4c83409c65d968e530bf2"],"54204c8a3ca26aeafd273139fc29baf70d0f6786":["902a92b60648a8925bfd9bb53a78669cd2ea98fd"],"62e52115b56781006682fd92c6938efaf174304d":["6efad415dcdbcca7d440f909743e6e3152eeb6c0","414aae1db83a83d247caa9514e383e4ca3d43da5"],"d0af0c31a687dd847212ae59f661152896c76516":["82557a475db3e0849171dc0be5b02e3ae0745ddb"],"5bd0058ffa806ba5d3b6cb38ab7de828d8b46970":["2a6ee6c302710254b6c2474ccd2755f9f2323ee3"],"122574a95710afd6a0af00c4d1aea9f6fcaeab96":["d245db17aaa41b338dae9da5d4edba4dd6f61612"],"8c33f6677a2078739058f81eca1df69d12cd62b0":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"bede0ec3497c48e70d55196c5065d97a4bc1db3d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["06086b5bd0f0d57858f0675becc58edf1f6b7c11"]},"commit2Childs":{"82557a475db3e0849171dc0be5b02e3ae0745ddb":["c4015cd39dff8d4dec562d909f9766debac53aa6","d0af0c31a687dd847212ae59f661152896c76516"],"d245db17aaa41b338dae9da5d4edba4dd6f61612":["122574a95710afd6a0af00c4d1aea9f6fcaeab96"],"59aedb6464136dd3cd73d343e814ba8acf3da155":["414aae1db83a83d247caa9514e383e4ca3d43da5"],"8b9fb5afeea0288262bffcc55bdcda8b5fa272c8":["6ce825e9276493231308229152c48f755ce1a0a5"],"c4015cd39dff8d4dec562d909f9766debac53aa6":[],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"8917bfede3b4ca30f4305c1e391e9218959cd723":["c4015cd39dff8d4dec562d909f9766debac53aa6"],"414aae1db83a83d247caa9514e383e4ca3d43da5":["a81c53232b7a347a2a79b731a0b152059237a4b5","62e52115b56781006682fd92c6938efaf174304d"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["8c33f6677a2078739058f81eca1df69d12cd62b0"],"902a92b60648a8925bfd9bb53a78669cd2ea98fd":["f8061ddd97f3352007d927dae445884a6f3d857b","54204c8a3ca26aeafd273139fc29baf70d0f6786"],"2a6ee6c302710254b6c2474ccd2755f9f2323ee3":["5bd0058ffa806ba5d3b6cb38ab7de828d8b46970"],"56f67b2f1d8c5140b4f57f0c01298df5cf8021c4":["540a35dcd44dcf1fbbe1821d931abb31e10935c7"],"d82832af39f94dbb58a3130fd216ff1d49435589":[],"06086b5bd0f0d57858f0675becc58edf1f6b7c11":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bede0ec3497c48e70d55196c5065d97a4bc1db3d"],"6ce825e9276493231308229152c48f755ce1a0a5":["d82832af39f94dbb58a3130fd216ff1d49435589","32eace34e207608926e4c83409c65d968e530bf2","6efad415dcdbcca7d440f909743e6e3152eeb6c0"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["d245db17aaa41b338dae9da5d4edba4dd6f61612"],"540a35dcd44dcf1fbbe1821d931abb31e10935c7":["59aedb6464136dd3cd73d343e814ba8acf3da155"],"a81c53232b7a347a2a79b731a0b152059237a4b5":["8917bfede3b4ca30f4305c1e391e9218959cd723","87e78f3c129251e74ecc2ff73a32de0f27cf09d5"],"87e78f3c129251e74ecc2ff73a32de0f27cf09d5":["82557a475db3e0849171dc0be5b02e3ae0745ddb","8917bfede3b4ca30f4305c1e391e9218959cd723"],"32eace34e207608926e4c83409c65d968e530bf2":["56f67b2f1d8c5140b4f57f0c01298df5cf8021c4","d82832af39f94dbb58a3130fd216ff1d49435589","6efad415dcdbcca7d440f909743e6e3152eeb6c0"],"f8061ddd97f3352007d927dae445884a6f3d857b":[],"6efad415dcdbcca7d440f909743e6e3152eeb6c0":["62e52115b56781006682fd92c6938efaf174304d"],"54204c8a3ca26aeafd273139fc29baf70d0f6786":["06086b5bd0f0d57858f0675becc58edf1f6b7c11","f8061ddd97f3352007d927dae445884a6f3d857b"],"62e52115b56781006682fd92c6938efaf174304d":[],"5bd0058ffa806ba5d3b6cb38ab7de828d8b46970":["8b9fb5afeea0288262bffcc55bdcda8b5fa272c8","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab"],"d0af0c31a687dd847212ae59f661152896c76516":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"122574a95710afd6a0af00c4d1aea9f6fcaeab96":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"8c33f6677a2078739058f81eca1df69d12cd62b0":["902a92b60648a8925bfd9bb53a78669cd2ea98fd"],"bede0ec3497c48e70d55196c5065d97a4bc1db3d":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","2a6ee6c302710254b6c2474ccd2755f9f2323ee3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c4015cd39dff8d4dec562d909f9766debac53aa6","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","d82832af39f94dbb58a3130fd216ff1d49435589","f8061ddd97f3352007d927dae445884a6f3d857b","62e52115b56781006682fd92c6938efaf174304d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}