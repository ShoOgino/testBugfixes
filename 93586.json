{"path":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","sourceNew":"  /**\n   * Returns a reasonable approximation of the main memory [bytes] consumed by\n   * this instance. Useful for smart memory sensititive caches/pools. Assumes\n   * fieldNames are interned, whereas tokenized terms are memory-overlaid.\n   * \n   * @return the main memory consumption\n   */\n  public int getMemorySize() {\n    // for example usage in a smart cache see nux.xom.pool.Pool    \n    int PTR = VM.PTR;\n    int INT = VM.INT;\n    int size = 0;\n    size += VM.sizeOfObject(2*PTR + INT); // memory index\n    if (sortedFields != null) size += VM.sizeOfObjectArray(sortedFields.length);\n    \n    size += VM.sizeOfHashMap(fields.size());\n    for (Map.Entry<String, Info> entry : fields.entrySet()) { // for each Field Info\n      Info info = entry.getValue();\n      size += VM.sizeOfObject(2*INT + 3*PTR); // Info instance vars\n      if (info.sortedTerms != null) size += VM.sizeOfObjectArray(info.sortedTerms.length);\n      \n      int len = info.terms.size();\n      size += VM.sizeOfHashMap(len);\n      Iterator<Map.Entry<String,ArrayIntList>> iter2 = info.terms.entrySet().iterator();\n      while (--len >= 0) { // for each term\n        Map.Entry<String,ArrayIntList> e = iter2.next();\n        size += VM.sizeOfObject(PTR + 3*INT); // assumes substring() memory overlay\n//        size += STR + 2 * ((String) e.getKey()).length();\n        ArrayIntList positions = e.getValue();\n        size += VM.sizeOfArrayIntList(positions.size());\n      }\n    }\n    return size;\n  } \n\n","sourceOld":"  /**\n   * Returns a reasonable approximation of the main memory [bytes] consumed by\n   * this instance. Useful for smart memory sensititive caches/pools. Assumes\n   * fieldNames are interned, whereas tokenized terms are memory-overlaid.\n   * \n   * @return the main memory consumption\n   */\n  public int getMemorySize() {\n    // for example usage in a smart cache see nux.xom.pool.Pool    \n    int PTR = VM.PTR;\n    int INT = VM.INT;\n    int size = 0;\n    size += VM.sizeOfObject(2*PTR + INT); // memory index\n    if (sortedFields != null) size += VM.sizeOfObjectArray(sortedFields.length);\n    \n    size += VM.sizeOfHashMap(fields.size());\n    for (Map.Entry<String, Info> entry : fields.entrySet()) { // for each Field Info\n      Info info = entry.getValue();\n      size += VM.sizeOfObject(2*INT + 3*PTR); // Info instance vars\n      if (info.sortedTerms != null) size += VM.sizeOfObjectArray(info.sortedTerms.length);\n      \n      int len = info.terms.size();\n      size += VM.sizeOfHashMap(len);\n      Iterator<Map.Entry<String,ArrayIntList>> iter2 = info.terms.entrySet().iterator();\n      while (--len >= 0) { // for each term\n        Map.Entry<String,ArrayIntList> e = iter2.next();\n        size += VM.sizeOfObject(PTR + 3*INT); // assumes substring() memory overlay\n//        size += STR + 2 * ((String) e.getKey()).length();\n        ArrayIntList positions = e.getValue();\n        size += VM.sizeOfArrayIntList(positions.size());\n      }\n    }\n    return size;\n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4f29ba80b723649f5feb7e37afe1a558dd2c1304","date":1278318805,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","pathOld":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","sourceNew":"  /**\n   * Returns a reasonable approximation of the main memory [bytes] consumed by\n   * this instance. Useful for smart memory sensititive caches/pools. Assumes\n   * fieldNames are interned, whereas tokenized terms are memory-overlaid.\n   * \n   * @return the main memory consumption\n   */\n  public int getMemorySize() {\n    // for example usage in a smart cache see nux.xom.pool.Pool    \n    int PTR = VM.PTR;\n    int INT = VM.INT;\n    int size = 0;\n    size += VM.sizeOfObject(2*PTR + INT); // memory index\n    if (sortedFields != null) size += VM.sizeOfObjectArray(sortedFields.length);\n    \n    size += VM.sizeOfHashMap(fields.size());\n    for (Map.Entry<String, Info> entry : fields.entrySet()) { // for each Field Info\n      Info info = entry.getValue();\n      size += VM.sizeOfObject(2*INT + 3*PTR); // Info instance vars\n      if (info.sortedTerms != null) size += VM.sizeOfObjectArray(info.sortedTerms.length);\n      \n      int len = info.terms.size();\n      size += VM.sizeOfHashMap(len);\n      Iterator<Map.Entry<BytesRef,ArrayIntList>> iter2 = info.terms.entrySet().iterator();\n      while (--len >= 0) { // for each term\n        Map.Entry<BytesRef,ArrayIntList> e = iter2.next();\n        // FIXME: this calculation is probably not correct since we use bytes now.\n        size += VM.sizeOfObject(PTR + 3*INT); // assumes substring() memory overlay\n//        size += STR + 2 * ((String) e.getKey()).length();\n        ArrayIntList positions = e.getValue();\n        size += VM.sizeOfArrayIntList(positions.size());\n      }\n    }\n    return size;\n  } \n\n","sourceOld":"  /**\n   * Returns a reasonable approximation of the main memory [bytes] consumed by\n   * this instance. Useful for smart memory sensititive caches/pools. Assumes\n   * fieldNames are interned, whereas tokenized terms are memory-overlaid.\n   * \n   * @return the main memory consumption\n   */\n  public int getMemorySize() {\n    // for example usage in a smart cache see nux.xom.pool.Pool    \n    int PTR = VM.PTR;\n    int INT = VM.INT;\n    int size = 0;\n    size += VM.sizeOfObject(2*PTR + INT); // memory index\n    if (sortedFields != null) size += VM.sizeOfObjectArray(sortedFields.length);\n    \n    size += VM.sizeOfHashMap(fields.size());\n    for (Map.Entry<String, Info> entry : fields.entrySet()) { // for each Field Info\n      Info info = entry.getValue();\n      size += VM.sizeOfObject(2*INT + 3*PTR); // Info instance vars\n      if (info.sortedTerms != null) size += VM.sizeOfObjectArray(info.sortedTerms.length);\n      \n      int len = info.terms.size();\n      size += VM.sizeOfHashMap(len);\n      Iterator<Map.Entry<String,ArrayIntList>> iter2 = info.terms.entrySet().iterator();\n      while (--len >= 0) { // for each term\n        Map.Entry<String,ArrayIntList> e = iter2.next();\n        size += VM.sizeOfObject(PTR + 3*INT); // assumes substring() memory overlay\n//        size += STR + 2 * ((String) e.getKey()).length();\n        ArrayIntList positions = e.getValue();\n        size += VM.sizeOfArrayIntList(positions.size());\n      }\n    }\n    return size;\n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","pathOld":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","sourceNew":"  /**\n   * Returns a reasonable approximation of the main memory [bytes] consumed by\n   * this instance. Useful for smart memory sensititive caches/pools. Assumes\n   * fieldNames are interned, whereas tokenized terms are memory-overlaid.\n   * \n   * @return the main memory consumption\n   */\n  public int getMemorySize() {\n    // for example usage in a smart cache see nux.xom.pool.Pool    \n    int PTR = VM.PTR;\n    int INT = VM.INT;\n    int size = 0;\n    size += VM.sizeOfObject(2*PTR + INT); // memory index\n    if (sortedFields != null) size += VM.sizeOfObjectArray(sortedFields.length);\n    \n    size += VM.sizeOfHashMap(fields.size());\n    for (Map.Entry<String, Info> entry : fields.entrySet()) { // for each Field Info\n      Info info = entry.getValue();\n      size += VM.sizeOfObject(2*INT + 3*PTR); // Info instance vars\n      if (info.sortedTerms != null) size += VM.sizeOfObjectArray(info.sortedTerms.length);\n      \n      int len = info.terms.size();\n      size += VM.sizeOfHashMap(len);\n      Iterator<Map.Entry<BytesRef,ArrayIntList>> iter2 = info.terms.entrySet().iterator();\n      while (--len >= 0) { // for each term\n        Map.Entry<BytesRef,ArrayIntList> e = iter2.next();\n        // FIXME: this calculation is probably not correct since we use bytes now.\n        size += VM.sizeOfObject(PTR + 3*INT); // assumes substring() memory overlay\n//        size += STR + 2 * ((String) e.getKey()).length();\n        ArrayIntList positions = e.getValue();\n        size += VM.sizeOfArrayIntList(positions.size());\n      }\n    }\n    return size;\n  } \n\n","sourceOld":"  /**\n   * Returns a reasonable approximation of the main memory [bytes] consumed by\n   * this instance. Useful for smart memory sensititive caches/pools. Assumes\n   * fieldNames are interned, whereas tokenized terms are memory-overlaid.\n   * \n   * @return the main memory consumption\n   */\n  public int getMemorySize() {\n    // for example usage in a smart cache see nux.xom.pool.Pool    \n    int PTR = VM.PTR;\n    int INT = VM.INT;\n    int size = 0;\n    size += VM.sizeOfObject(2*PTR + INT); // memory index\n    if (sortedFields != null) size += VM.sizeOfObjectArray(sortedFields.length);\n    \n    size += VM.sizeOfHashMap(fields.size());\n    for (Map.Entry<String, Info> entry : fields.entrySet()) { // for each Field Info\n      Info info = entry.getValue();\n      size += VM.sizeOfObject(2*INT + 3*PTR); // Info instance vars\n      if (info.sortedTerms != null) size += VM.sizeOfObjectArray(info.sortedTerms.length);\n      \n      int len = info.terms.size();\n      size += VM.sizeOfHashMap(len);\n      Iterator<Map.Entry<String,ArrayIntList>> iter2 = info.terms.entrySet().iterator();\n      while (--len >= 0) { // for each term\n        Map.Entry<String,ArrayIntList> e = iter2.next();\n        size += VM.sizeOfObject(PTR + 3*INT); // assumes substring() memory overlay\n//        size += STR + 2 * ((String) e.getKey()).length();\n        ArrayIntList positions = e.getValue();\n        size += VM.sizeOfArrayIntList(positions.size());\n      }\n    }\n    return size;\n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd6c9e9b1251473f465b0443b56046b2658402da","date":1332082750,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","pathOld":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","sourceNew":"  /**\n   * Returns a reasonable approximation of the main memory [bytes] consumed by\n   * this instance. Useful for smart memory sensititive caches/pools.\n   * @return the main memory consumption\n   */\n  public long getMemorySize() {\n    return RamUsageEstimator.sizeOf(this);\n  }\n\n","sourceOld":"  /**\n   * Returns a reasonable approximation of the main memory [bytes] consumed by\n   * this instance. Useful for smart memory sensititive caches/pools. Assumes\n   * fieldNames are interned, whereas tokenized terms are memory-overlaid.\n   * \n   * @return the main memory consumption\n   */\n  public int getMemorySize() {\n    // for example usage in a smart cache see nux.xom.pool.Pool    \n    int PTR = VM.PTR;\n    int INT = VM.INT;\n    int size = 0;\n    size += VM.sizeOfObject(2*PTR + INT); // memory index\n    if (sortedFields != null) size += VM.sizeOfObjectArray(sortedFields.length);\n    \n    size += VM.sizeOfHashMap(fields.size());\n    for (Map.Entry<String, Info> entry : fields.entrySet()) { // for each Field Info\n      Info info = entry.getValue();\n      size += VM.sizeOfObject(2*INT + 3*PTR); // Info instance vars\n      if (info.sortedTerms != null) size += VM.sizeOfObjectArray(info.sortedTerms.length);\n      \n      int len = info.terms.size();\n      size += VM.sizeOfHashMap(len);\n      Iterator<Map.Entry<BytesRef,ArrayIntList>> iter2 = info.terms.entrySet().iterator();\n      while (--len >= 0) { // for each term\n        Map.Entry<BytesRef,ArrayIntList> e = iter2.next();\n        // FIXME: this calculation is probably not correct since we use bytes now.\n        size += VM.sizeOfObject(PTR + 3*INT); // assumes substring() memory overlay\n//        size += STR + 2 * ((String) e.getKey()).length();\n        ArrayIntList positions = e.getValue();\n        size += VM.sizeOfArrayIntList(positions.size());\n      }\n    }\n    return size;\n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","pathOld":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#getMemorySize().mjava","sourceNew":"  /**\n   * Returns a reasonable approximation of the main memory [bytes] consumed by\n   * this instance. Useful for smart memory sensititive caches/pools.\n   * @return the main memory consumption\n   */\n  public long getMemorySize() {\n    return RamUsageEstimator.sizeOf(this);\n  }\n\n","sourceOld":"  /**\n   * Returns a reasonable approximation of the main memory [bytes] consumed by\n   * this instance. Useful for smart memory sensititive caches/pools.\n   * @return the main memory consumption\n   */\n  public long getMemorySize() {\n    return RamUsageEstimator.sizeOf(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["dd6c9e9b1251473f465b0443b56046b2658402da"],"4f29ba80b723649f5feb7e37afe1a558dd2c1304":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"dd6c9e9b1251473f465b0443b56046b2658402da":["4f29ba80b723649f5feb7e37afe1a558dd2c1304"],"5f4e87790277826a2aea119328600dfb07761f32":["9454a6510e2db155fb01faa5c049b06ece95fab9","4f29ba80b723649f5feb7e37afe1a558dd2c1304"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4f29ba80b723649f5feb7e37afe1a558dd2c1304":["dd6c9e9b1251473f465b0443b56046b2658402da","5f4e87790277826a2aea119328600dfb07761f32"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"dd6c9e9b1251473f465b0443b56046b2658402da":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"5f4e87790277826a2aea119328600dfb07761f32":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["4f29ba80b723649f5feb7e37afe1a558dd2c1304","5f4e87790277826a2aea119328600dfb07761f32"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5f4e87790277826a2aea119328600dfb07761f32","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}