{"path":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));    \n    synchronized(cores) {\n      try {\n        for(SolrCore core : cores.values()) {\n          core.close();\n        }\n        cores.clear();\n      } finally {\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n        isShutDown = true;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));    \n    synchronized(cores) {\n      try {\n        for(SolrCore core : cores.values()) {\n          core.close();\n        }\n        cores.clear();\n      } finally {\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n        isShutDown = true;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));    \n    synchronized(cores) {\n      try {\n        for(SolrCore core : cores.values()) {\n          core.close();\n        }\n        cores.clear();\n      } finally {\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n        isShutDown = true;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));    \n    synchronized(cores) {\n      try {\n        for(SolrCore core : cores.values()) {\n          core.close();\n        }\n        cores.clear();\n      } finally {\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n        isShutDown = true;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));    \n    synchronized(cores) {\n      try {\n        for(SolrCore core : cores.values()) {\n          core.close();\n        }\n        cores.clear();\n      } finally {\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n        isShutDown = true;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));    \n    synchronized(cores) {\n      try {\n        for(SolrCore core : cores.values()) {\n          core.close();\n        }\n        cores.clear();\n      } finally {\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n        isShutDown = true;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));    \n    synchronized(cores) {\n      try {\n        for (SolrCore core : cores.values()) {\n          try {\n            if (!core.isClosed()) {\n              core.close();\n            }\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      } finally {\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n        isShutDown = true;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));    \n    synchronized(cores) {\n      try {\n        for(SolrCore core : cores.values()) {\n          core.close();\n        }\n        cores.clear();\n      } finally {\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n        isShutDown = true;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));    \n    synchronized(cores) {\n      try {\n        for (SolrCore core : cores.values()) {\n          try {\n            if (!core.isClosed()) {\n              core.close();\n            }\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      } finally {\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n        isShutDown = true;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));    \n    synchronized(cores) {\n      try {\n        for(SolrCore core : cores.values()) {\n          core.close();\n        }\n        cores.clear();\n      } finally {\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n        isShutDown = true;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));    \n    synchronized(cores) {\n      try {\n        for (SolrCore core : cores.values()) {\n          try {\n            if (!core.isClosed()) {\n              core.close();\n            }\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      } finally {\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n        isShutDown = true;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));    \n    synchronized(cores) {\n      try {\n        for(SolrCore core : cores.values()) {\n          core.close();\n        }\n        cores.clear();\n      } finally {\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n        isShutDown = true;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"512478b5e909ce226fd08d07746564a7d17ea1b6","date":1327698151,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));    \n    synchronized(cores) {\n      try {\n        for (SolrCore core : cores.values()) {\n          try {\n             core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      } finally {\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n        isShutDown = true;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));    \n    synchronized(cores) {\n      try {\n        for (SolrCore core : cores.values()) {\n          try {\n            if (!core.isClosed()) {\n              core.close();\n            }\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      } finally {\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n        isShutDown = true;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["a6378064655e76cd7b908b1cab4ce425b384b508"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"da2a6d8e77af99237dccb61ffaadcf0578f91903","date":1327717182,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));    \n    synchronized(cores) {\n      try {\n        for (SolrCore core : cores.values()) {\n          try {\n             core.close();\n             // make sure we wait for any recoveries to stop\n             core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      } finally {\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n        isShutDown = true;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));    \n    synchronized(cores) {\n      try {\n        for (SolrCore core : cores.values()) {\n          try {\n             core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      } finally {\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n        isShutDown = true;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"014f4a9c44ade09ba9dc8a50d2690f1303cbfaf7","date":1327763052,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));    \n    synchronized(cores) {\n      try {\n        for (SolrCore core : cores.values()) {\n          try {\n             core.close();\n             // make sure we wait for any recoveries to stop\n             core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      } finally {\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n        isShutDown = true;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));    \n    synchronized(cores) {\n      try {\n        for (SolrCore core : cores.values()) {\n          try {\n            if (!core.isClosed()) {\n              core.close();\n            }\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      } finally {\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n        isShutDown = true;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd92b8bcc88e969302510acf77bd6970da3994c4","date":1327839530,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));    \n    synchronized(cores) {\n      try {\n        for (SolrCore core : cores.values()) {\n          try {\n             core.close();\n             // make sure we wait for any recoveries to stop\n             core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      } finally {\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n        isShutDown = true;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));    \n    synchronized(cores) {\n      try {\n        for (SolrCore core : cores.values()) {\n          try {\n            if (!core.isClosed()) {\n              core.close();\n            }\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      } finally {\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n        isShutDown = true;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af02ebb711553a2cc1969b3ccd4997202c6b50ff","date":1330311169,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n    }\n    \n    synchronized(cores) {\n      try {\n        for (SolrCore core : cores.values()) {\n          try {\n             core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      } finally {\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n        isShutDown = true;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));    \n    synchronized(cores) {\n      try {\n        for (SolrCore core : cores.values()) {\n          try {\n             core.close();\n             // make sure we wait for any recoveries to stop\n             core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      } finally {\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n        isShutDown = true;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["a6378064655e76cd7b908b1cab4ce425b384b508","bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n    }\n    \n    synchronized(cores) {\n      try {\n        for (SolrCore core : cores.values()) {\n          try {\n             core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      } finally {\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n        isShutDown = true;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));    \n    synchronized(cores) {\n      try {\n        for (SolrCore core : cores.values()) {\n          try {\n             core.close();\n             // make sure we wait for any recoveries to stop\n             core.getUpdateHandler().getSolrCoreState().cancelRecovery();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      } finally {\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n        isShutDown = true;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"63fce89dfe8a5dcba79c726470441c175441f122","date":1342202709,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));\n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n    }\n    \n    synchronized(cores) {\n      try {\n        for (SolrCore core : cores.values()) {\n          try {\n             core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      } finally {\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n    }\n    \n    synchronized(cores) {\n      try {\n        for (SolrCore core : cores.values()) {\n          try {\n             core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      } finally {\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n        isShutDown = true;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));\n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n    }\n    \n    synchronized(cores) {\n      try {\n        for (SolrCore core : cores.values()) {\n          try {\n             core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      } finally {\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n    }\n    \n    synchronized(cores) {\n      try {\n        for (SolrCore core : cores.values()) {\n          try {\n             core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      } finally {\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n        isShutDown = true;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));\n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n    }\n    \n    synchronized(cores) {\n      try {\n        for (SolrCore core : cores.values()) {\n          try {\n             core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      } finally {\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n    }\n    \n    synchronized(cores) {\n      try {\n        for (SolrCore core : cores.values()) {\n          try {\n             core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      } finally {\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n        isShutDown = true;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6013b4c7388f1627659c8f96c44abd10a294d3a6","date":1346343796,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));\n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n    }\n    \n    synchronized(cores) {\n      try {\n        for (SolrCore core : cores.values()) {\n          try {\n             core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      } finally {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n        // we want to close zk stuff last\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));\n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n    }\n    \n    synchronized(cores) {\n      try {\n        for (SolrCore core : cores.values()) {\n          try {\n             core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      } finally {\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["a6378064655e76cd7b908b1cab4ce425b384b508"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"05a14b2611ead08655a2b2bdc61632eb31316e57","date":1346366621,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));\n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n    }\n    \n    synchronized(cores) {\n      try {\n        for (SolrCore core : cores.values()) {\n          try {\n             core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      } finally {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n        // we want to close zk stuff last\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));\n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n    }\n    \n    synchronized(cores) {\n      try {\n        for (SolrCore core : cores.values()) {\n          try {\n             core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      } finally {\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6","date":1346692465,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));\n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n    }\n    \n    synchronized(cores) {\n      try {\n        for (SolrCore core : cores.values()) {\n          try {\n             core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      } finally {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n        if (cmdDistribExecutor != null) {\n          try {\n            ExecutorUtil.shutdownAndAwaitTermination(cmdDistribExecutor);\n          } catch (Throwable e) {\n            SolrException.log(log, e);\n          }\n        }\n        // we want to close zk stuff last\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));\n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n    }\n    \n    synchronized(cores) {\n      try {\n        for (SolrCore core : cores.values()) {\n          try {\n             core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      } finally {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n        // we want to close zk stuff last\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1","date":1346817835,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));\n    isShutDown = true;\n    \n    if (cmdDistribExecutor != null) {\n      try {\n        ExecutorUtil.shutdownAndAwaitTermination(cmdDistribExecutor);\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n      }\n    }\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n    }\n    \n    synchronized(cores) {\n      try {\n        for (SolrCore core : cores.values()) {\n          try {\n             core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      } finally {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n\n        // we want to close zk stuff last\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));\n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n    }\n    \n    synchronized(cores) {\n      try {\n        for (SolrCore core : cores.values()) {\n          try {\n             core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      } finally {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n        if (cmdDistribExecutor != null) {\n          try {\n            ExecutorUtil.shutdownAndAwaitTermination(cmdDistribExecutor);\n          } catch (Throwable e) {\n            SolrException.log(log, e);\n          }\n        }\n        // we want to close zk stuff last\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n      }\n    }\n  }\n\n","bugFix":["7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6"],"bugIntro":["a6378064655e76cd7b908b1cab4ce425b384b508"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a6378064655e76cd7b908b1cab4ce425b384b508","date":1347656715,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n    }\n    try {\n      synchronized (cores) {\n        \n        for (SolrCore core : cores.values()) {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      }\n    } finally {\n      if (shardHandlerFactory != null) {\n        shardHandlerFactory.close();\n      }\n      \n      // we want to close zk stuff last\n      if (zkController != null) {\n        zkController.close();\n      }\n      if (zkServer != null) {\n        zkServer.stop();\n      }\n      \n    }\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"+System.identityHashCode(this));\n    isShutDown = true;\n    \n    if (cmdDistribExecutor != null) {\n      try {\n        ExecutorUtil.shutdownAndAwaitTermination(cmdDistribExecutor);\n      } catch (Throwable e) {\n        SolrException.log(log, e);\n      }\n    }\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n    }\n    \n    synchronized(cores) {\n      try {\n        for (SolrCore core : cores.values()) {\n          try {\n             core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      } finally {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n\n        // we want to close zk stuff last\n        if(zkController != null) {\n          zkController.close();\n        }\n        if (zkServer != null) {\n          zkServer.stop();\n        }\n      }\n    }\n  }\n\n","bugFix":["43adc163640856c8b07e4cf1b2046c9af56d3ae7","d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1","6013b4c7388f1627659c8f96c44abd10a294d3a6","af02ebb711553a2cc1969b3ccd4997202c6b50ff","048361614025800e582bfc7a7b0329dc6fd6a95e","512478b5e909ce226fd08d07746564a7d17ea1b6","c0d8dceae0594e66ce62ce0f775689af35a2266c"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b374d78db8148ec6796fdf37148b33897ab40a8c","date":1351606544,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n    }\n    try {\n      synchronized (cores) {\n\n        for (SolrCore core : cores.values()) {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      }\n      synchronized (swappableCores) {\n        for (SolrCore core : swappableCores.values()) {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        swappableCores.clear();\n      }\n    } finally {\n      if (shardHandlerFactory != null) {\n        shardHandlerFactory.close();\n      }\n      \n      // we want to close zk stuff last\n      if (zkController != null) {\n        zkController.close();\n      }\n      if (zkServer != null) {\n        zkServer.stop();\n      }\n      \n    }\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n    }\n    try {\n      synchronized (cores) {\n        \n        for (SolrCore core : cores.values()) {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      }\n    } finally {\n      if (shardHandlerFactory != null) {\n        shardHandlerFactory.close();\n      }\n      \n      // we want to close zk stuff last\n      if (zkController != null) {\n        zkController.close();\n      }\n      if (zkServer != null) {\n        zkServer.stop();\n      }\n      \n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c33399cc2618223f11ba493f9a3a2026fe05b579","date":1356813042,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n    }\n    try {\n      synchronized (cores) {\n\n        for (SolrCore core : cores.values()) {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      }\n      synchronized (transientCores) {\n        for (SolrCore core : transientCores.values()) {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        transientCores.clear();\n      }\n    } finally {\n      if (shardHandlerFactory != null) {\n        shardHandlerFactory.close();\n      }\n      \n      // we want to close zk stuff last\n      if (zkController != null) {\n        zkController.close();\n      }\n      if (zkServer != null) {\n        zkServer.stop();\n      }\n      \n    }\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n    }\n    try {\n      synchronized (cores) {\n\n        for (SolrCore core : cores.values()) {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      }\n      synchronized (swappableCores) {\n        for (SolrCore core : swappableCores.values()) {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        swappableCores.clear();\n      }\n    } finally {\n      if (shardHandlerFactory != null) {\n        shardHandlerFactory.close();\n      }\n      \n      // we want to close zk stuff last\n      if (zkController != null) {\n        zkController.close();\n      }\n      if (zkServer != null) {\n        zkServer.stop();\n      }\n      \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n    }\n    try {\n      synchronized (cores) {\n\n        for (SolrCore core : cores.values()) {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      }\n      synchronized (transientCores) {\n        for (SolrCore core : transientCores.values()) {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        transientCores.clear();\n      }\n    } finally {\n      if (shardHandlerFactory != null) {\n        shardHandlerFactory.close();\n      }\n      \n      // we want to close zk stuff last\n      if (zkController != null) {\n        zkController.close();\n      }\n      if (zkServer != null) {\n        zkServer.stop();\n      }\n      \n    }\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n    }\n    try {\n      synchronized (cores) {\n\n        for (SolrCore core : cores.values()) {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      }\n      synchronized (swappableCores) {\n        for (SolrCore core : swappableCores.values()) {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        swappableCores.clear();\n      }\n    } finally {\n      if (shardHandlerFactory != null) {\n        shardHandlerFactory.close();\n      }\n      \n      // we want to close zk stuff last\n      if (zkController != null) {\n        zkController.close();\n      }\n      if (zkServer != null) {\n        zkServer.stop();\n      }\n      \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"75de3186224c3841600321d68416c86a504aae43","date":1360359880,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      publishCoresAsDown();\n      cancelCoreRecoveries();\n    }\n    try {\n      synchronized (cores) {\n\n        for (SolrCore core : cores.values()) {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      }\n      synchronized (transientCores) {\n        for (SolrCore core : transientCores.values()) {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        transientCores.clear();\n      }\n    } finally {\n      if (shardHandlerFactory != null) {\n        shardHandlerFactory.close();\n      }\n      \n      // we want to close zk stuff last\n      if (zkController != null) {\n        zkController.close();\n      }\n      if (zkServer != null) {\n        zkServer.stop();\n      }\n      \n    }\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n    }\n    try {\n      synchronized (cores) {\n\n        for (SolrCore core : cores.values()) {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      }\n      synchronized (transientCores) {\n        for (SolrCore core : transientCores.values()) {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        transientCores.clear();\n      }\n    } finally {\n      if (shardHandlerFactory != null) {\n        shardHandlerFactory.close();\n      }\n      \n      // we want to close zk stuff last\n      if (zkController != null) {\n        zkController.close();\n      }\n      if (zkServer != null) {\n        zkServer.stop();\n      }\n      \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"474a065e1bf22f3551c2fd2c9e18bde479e5c3c5","date":1361033993,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    if (isZooKeeperAware()) {\n      try {\n        zkController.publishAndWaitForDownStates();\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      }\n    }\n    \n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n    }\n    \n    try {\n      synchronized (cores) {\n\n        for (SolrCore core : cores.values()) {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      }\n      synchronized (transientCores) {\n        for (SolrCore core : transientCores.values()) {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        transientCores.clear();\n      }\n    } finally {\n      if (shardHandlerFactory != null) {\n        shardHandlerFactory.close();\n      }\n      \n      // we want to close zk stuff last\n      if (zkController != null) {\n        zkController.close();\n      }\n      if (zkServer != null) {\n        zkServer.stop();\n      }\n      \n    }\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      publishCoresAsDown();\n      cancelCoreRecoveries();\n    }\n    try {\n      synchronized (cores) {\n\n        for (SolrCore core : cores.values()) {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      }\n      synchronized (transientCores) {\n        for (SolrCore core : transientCores.values()) {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        transientCores.clear();\n      }\n    } finally {\n      if (shardHandlerFactory != null) {\n        shardHandlerFactory.close();\n      }\n      \n      // we want to close zk stuff last\n      if (zkController != null) {\n        zkController.close();\n      }\n      if (zkServer != null) {\n        zkServer.stop();\n      }\n      \n    }\n  }\n\n","bugFix":null,"bugIntro":["1e1921d1a653059438f4c18a3dad07ff197b0cab"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"95303ff3749680c743b9425f9cf99e6e4065e8a8","date":1361061922,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    if (isZooKeeperAware()) {\n      try {\n        zkController.publishAndWaitForDownStates();\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      }\n    }\n    \n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n    }\n    \n    try {\n      synchronized (cores) {\n\n        for (SolrCore core : cores.values()) {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      }\n      synchronized (transientCores) {\n        for (SolrCore core : transientCores.values()) {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        transientCores.clear();\n      }\n    } finally {\n      if (shardHandlerFactory != null) {\n        shardHandlerFactory.close();\n      }\n      \n      // we want to close zk stuff last\n      if (zkController != null) {\n        zkController.close();\n      }\n      if (zkServer != null) {\n        zkServer.stop();\n      }\n      \n    }\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      publishCoresAsDown();\n      cancelCoreRecoveries();\n    }\n    try {\n      synchronized (cores) {\n\n        for (SolrCore core : cores.values()) {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      }\n      synchronized (transientCores) {\n        for (SolrCore core : transientCores.values()) {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        transientCores.clear();\n      }\n    } finally {\n      if (shardHandlerFactory != null) {\n        shardHandlerFactory.close();\n      }\n      \n      // we want to close zk stuff last\n      if (zkController != null) {\n        zkController.close();\n      }\n      if (zkServer != null) {\n        zkServer.stop();\n      }\n      \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a837c064b67fa63a9394136e31218b908cdcf783","date":1362186072,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    if (isZooKeeperAware()) {\n      try {\n        zkController.publishAndWaitForDownStates();\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      }\n    }\n    isShutDown = true;\n\n    if (isZooKeeperAware()) {\n      coreMaps.publishCoresAsDown(zkController);\n      cancelCoreRecoveries();\n    }\n\n\n    try {\n      // First allow the closer thread to drain all the pending closes it can.\n      synchronized (coreMaps.getLocker()) {\n        coreMaps.getLocker().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          ; // Don't much care if this gets interrupted\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      coreMaps.clearMaps(cfg);\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (coreMaps.getLocker()) {\n        coreMaps.getLocker().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      if (shardHandlerFactory != null) {\n        shardHandlerFactory.close();\n      }\n      \n      // we want to close zk stuff last\n      if (zkController != null) {\n        zkController.close();\n      }\n      if (zkServer != null) {\n        zkServer.stop();\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    if (isZooKeeperAware()) {\n      try {\n        zkController.publishAndWaitForDownStates();\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      }\n    }\n    \n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n    }\n    \n    try {\n      synchronized (cores) {\n\n        for (SolrCore core : cores.values()) {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        cores.clear();\n      }\n      synchronized (transientCores) {\n        for (SolrCore core : transientCores.values()) {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(log, \"Error shutting down core\", t);\n          }\n        }\n        transientCores.clear();\n      }\n    } finally {\n      if (shardHandlerFactory != null) {\n        shardHandlerFactory.close();\n      }\n      \n      // we want to close zk stuff last\n      if (zkController != null) {\n        zkController.close();\n      }\n      if (zkServer != null) {\n        zkServer.stop();\n      }\n      \n    }\n  }\n\n","bugFix":null,"bugIntro":["76634b4b1f858b91192740147c05b56c206d03fb","1e1921d1a653059438f4c18a3dad07ff197b0cab"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8b6f42dee5a60f46a3fdf3ab93b39aefb356e245","date":1363106546,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    if (isZooKeeperAware()) {\n      try {\n        zkController.publishAndWaitForDownStates();\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      }\n    }\n    isShutDown = true;\n\n    if (isZooKeeperAware()) {\n      coreMaps.publishCoresAsDown(zkController);\n      cancelCoreRecoveries();\n    }\n\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (coreMaps.getLocker()) {\n        coreMaps.getLocker().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          ; // Don't much care if this gets interrupted\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      coreMaps.clearMaps(cfg);\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (coreMaps.getLocker()) {\n        coreMaps.getLocker().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      if (shardHandlerFactory != null) {\n        shardHandlerFactory.close();\n      }\n      \n      // we want to close zk stuff last\n      if (zkController != null) {\n        zkController.close();\n      }\n      if (zkServer != null) {\n        zkServer.stop();\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    if (isZooKeeperAware()) {\n      try {\n        zkController.publishAndWaitForDownStates();\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      }\n    }\n    isShutDown = true;\n\n    if (isZooKeeperAware()) {\n      coreMaps.publishCoresAsDown(zkController);\n      cancelCoreRecoveries();\n    }\n\n\n    try {\n      // First allow the closer thread to drain all the pending closes it can.\n      synchronized (coreMaps.getLocker()) {\n        coreMaps.getLocker().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          ; // Don't much care if this gets interrupted\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      coreMaps.clearMaps(cfg);\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (coreMaps.getLocker()) {\n        coreMaps.getLocker().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      if (shardHandlerFactory != null) {\n        shardHandlerFactory.close();\n      }\n      \n      // we want to close zk stuff last\n      if (zkController != null) {\n        zkController.close();\n      }\n      if (zkServer != null) {\n        zkServer.stop();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3278df77f7f499b55fdb79861c0641450444e7d0","date":1366238988,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    if (isZooKeeperAware()) {\n      try {\n        zkController.publishAndWaitForDownStates();\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      }\n    }\n    isShutDown = true;\n\n    if (isZooKeeperAware()) {\n      coreMaps.publishCoresAsDown(zkController);\n      cancelCoreRecoveries();\n    }\n\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (coreMaps.getLocker()) {\n        coreMaps.getLocker().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      coreMaps.clearMaps(cfg);\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (coreMaps.getLocker()) {\n        coreMaps.getLocker().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      if (shardHandlerFactory != null) {\n        shardHandlerFactory.close();\n      }\n      \n      // we want to close zk stuff last\n      if (zkController != null) {\n        zkController.close();\n      }\n      if (zkServer != null) {\n        zkServer.stop();\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    if (isZooKeeperAware()) {\n      try {\n        zkController.publishAndWaitForDownStates();\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      }\n    }\n    isShutDown = true;\n\n    if (isZooKeeperAware()) {\n      coreMaps.publishCoresAsDown(zkController);\n      cancelCoreRecoveries();\n    }\n\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (coreMaps.getLocker()) {\n        coreMaps.getLocker().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          ; // Don't much care if this gets interrupted\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      coreMaps.clearMaps(cfg);\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (coreMaps.getLocker()) {\n        coreMaps.getLocker().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      if (shardHandlerFactory != null) {\n        shardHandlerFactory.close();\n      }\n      \n      // we want to close zk stuff last\n      if (zkController != null) {\n        zkController.close();\n      }\n      if (zkServer != null) {\n        zkServer.stop();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9409650933cc688e77e565092a25e58adfc2e18d","date":1366663164,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    if (isZooKeeperAware()) {\n      try {\n        zkController.publishAndWaitForDownStates();\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      }\n    }\n    isShutDown = true;\n\n    if (isZooKeeperAware()) {\n      publishCoresAsDown();\n      cancelCoreRecoveries();\n    }\n\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      if (shardHandlerFactory != null) {\n        shardHandlerFactory.close();\n      }\n      \n      // we want to close zk stuff last\n      if (zkController != null) {\n        zkController.close();\n      }\n      if (zkServer != null) {\n        zkServer.stop();\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    if (isZooKeeperAware()) {\n      try {\n        zkController.publishAndWaitForDownStates();\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      }\n    }\n    isShutDown = true;\n\n    if (isZooKeeperAware()) {\n      coreMaps.publishCoresAsDown(zkController);\n      cancelCoreRecoveries();\n    }\n\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (coreMaps.getLocker()) {\n        coreMaps.getLocker().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      coreMaps.clearMaps(cfg);\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (coreMaps.getLocker()) {\n        coreMaps.getLocker().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      if (shardHandlerFactory != null) {\n        shardHandlerFactory.close();\n      }\n      \n      // we want to close zk stuff last\n      if (zkController != null) {\n        zkController.close();\n      }\n      if (zkServer != null) {\n        zkServer.stop();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b29abed5661c7911e4b45d5a3d79a186268e28c4","date":1366675770,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    if (isZooKeeperAware()) {\n      try {\n        zkSys.getZkController().publishAndWaitForDownStates();\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      }\n    }\n    isShutDown = true;\n\n    if (isZooKeeperAware()) {\n      zkSys.publishCoresAsDown(solrCores.getCores());\n      cancelCoreRecoveries();\n    }\n\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      if (shardHandlerFactory != null) {\n        shardHandlerFactory.close();\n      }\n      \n      // we want to close zk stuff last\n\n      zkSys.close();\n\n    }\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    if (isZooKeeperAware()) {\n      try {\n        zkController.publishAndWaitForDownStates();\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      }\n    }\n    isShutDown = true;\n\n    if (isZooKeeperAware()) {\n      publishCoresAsDown();\n      cancelCoreRecoveries();\n    }\n\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      if (shardHandlerFactory != null) {\n        shardHandlerFactory.close();\n      }\n      \n      // we want to close zk stuff last\n      if (zkController != null) {\n        zkController.close();\n      }\n      if (zkServer != null) {\n        zkServer.stop();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["1e1921d1a653059438f4c18a3dad07ff197b0cab"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0d7032150736f83396eb1fd9fc65e18b918099be","date":1368033706,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    if (isZooKeeperAware()) {\n      try {\n        zkSys.getZkController().publishAndWaitForDownStates();\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      }\n    }\n    isShutDown = true;\n\n    if (isZooKeeperAware()) {\n      zkSys.publishCoresAsDown(solrCores.getCores());\n      cancelCoreRecoveries();\n    }\n\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      if (shardHandlerFactory != null) {\n        shardHandlerFactory.close();\n      }\n      \n      // we want to close zk stuff last\n\n      zkSys.close();\n\n    }\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    if (isZooKeeperAware()) {\n      try {\n        zkSys.getZkController().publishAndWaitForDownStates();\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      }\n    }\n    isShutDown = true;\n\n    if (isZooKeeperAware()) {\n      zkSys.publishCoresAsDown(solrCores.getCores());\n      cancelCoreRecoveries();\n    }\n\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      if (shardHandlerFactory != null) {\n        shardHandlerFactory.close();\n      }\n      \n      // we want to close zk stuff last\n\n      zkSys.close();\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"91e069c492cf4895697ef7b81df0ffb9a8bd4b48","date":1382134253,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    if (isZooKeeperAware()) {\n      try {\n        zkSys.getZkController().publishAndWaitForDownStates();\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      }\n    }\n    isShutDown = true;\n\n    if (isZooKeeperAware()) {\n      zkSys.publishCoresAsDown(solrCores.getCores());\n      cancelCoreRecoveries();\n    }\n\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      if (shardHandlerFactory != null) {\n        shardHandlerFactory.close();\n      }\n      \n      ExecutorUtil.shutdownAndAwaitTermination(updateExecutor);\n      \n      // we want to close zk stuff last\n\n      zkSys.close();\n\n    }\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    if (isZooKeeperAware()) {\n      try {\n        zkSys.getZkController().publishAndWaitForDownStates();\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      }\n    }\n    isShutDown = true;\n\n    if (isZooKeeperAware()) {\n      zkSys.publishCoresAsDown(solrCores.getCores());\n      cancelCoreRecoveries();\n    }\n\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      if (shardHandlerFactory != null) {\n        shardHandlerFactory.close();\n      }\n      \n      // we want to close zk stuff last\n\n      zkSys.close();\n\n    }\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a7035935aa89f6951286e9005cbeb16e89a082a2","date":1385258396,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    if (isZooKeeperAware()) {\n      try {\n        zkSys.getZkController().publishAndWaitForDownStates();\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      }\n    }\n    isShutDown = true;\n\n    if (isZooKeeperAware()) {\n      zkSys.publishCoresAsDown(solrCores.getCores());\n      cancelCoreRecoveries();\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    if (isZooKeeperAware()) {\n      try {\n        zkSys.getZkController().publishAndWaitForDownStates();\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      }\n    }\n    isShutDown = true;\n\n    if (isZooKeeperAware()) {\n      zkSys.publishCoresAsDown(solrCores.getCores());\n      cancelCoreRecoveries();\n    }\n\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      if (shardHandlerFactory != null) {\n        shardHandlerFactory.close();\n      }\n      \n      ExecutorUtil.shutdownAndAwaitTermination(updateExecutor);\n      \n      // we want to close zk stuff last\n\n      zkSys.close();\n\n    }\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    if (isZooKeeperAware()) {\n      try {\n        zkSys.getZkController().publishAndWaitForDownStates();\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      }\n    }\n    isShutDown = true;\n\n    if (isZooKeeperAware()) {\n      zkSys.publishCoresAsDown(solrCores.getCores());\n      cancelCoreRecoveries();\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    if (isZooKeeperAware()) {\n      try {\n        zkSys.getZkController().publishAndWaitForDownStates();\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      }\n    }\n    isShutDown = true;\n\n    if (isZooKeeperAware()) {\n      zkSys.publishCoresAsDown(solrCores.getCores());\n      cancelCoreRecoveries();\n    }\n\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      if (shardHandlerFactory != null) {\n        shardHandlerFactory.close();\n      }\n      \n      ExecutorUtil.shutdownAndAwaitTermination(updateExecutor);\n      \n      // we want to close zk stuff last\n\n      zkSys.close();\n\n    }\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e1921d1a653059438f4c18a3dad07ff197b0cab","date":1387819910,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.publishCoresAsDown(solrCores.getCores());\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    if (isZooKeeperAware()) {\n      try {\n        zkSys.getZkController().publishAndWaitForDownStates();\n      } catch (KeeperException e) {\n        log.error(\"\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.warn(\"\", e);\n      }\n    }\n    isShutDown = true;\n\n    if (isZooKeeperAware()) {\n      zkSys.publishCoresAsDown(solrCores.getCores());\n      cancelCoreRecoveries();\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":["a837c064b67fa63a9394136e31218b908cdcf783","474a065e1bf22f3551c2fd2c9e18bde479e5c3c5","b29abed5661c7911e4b45d5a3d79a186268e28c4"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"058f5a3debcfa0ea477da3eabb4cbe2ec0fac211","date":1394784078,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.publishCoresAsDown(solrCores.getCores());\n    }\n\n    try {\n      coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to shutdown CoreContainer.\");\n      e.printStackTrace();\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.publishCoresAsDown(solrCores.getCores());\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.publishCoresAsDown(solrCores.getCores());\n    }\n\n    try {\n      coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\");\n      e.printStackTrace();\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.publishCoresAsDown(solrCores.getCores());\n    }\n\n    try {\n      coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to shutdown CoreContainer.\");\n      e.printStackTrace();\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6784d0cc613dc1ee97030eaaa5e0754edc22d164","date":1420824784,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.publishCoresAsDown(solrCores.getCores());\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.publishCoresAsDown(solrCores.getCores());\n    }\n\n    try {\n      coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\");\n      e.printStackTrace();\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":["058f5a3debcfa0ea477da3eabb4cbe2ec0fac211","d0ef034a4f10871667ae75181537775ddcf8ade4"],"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"00e1c8e1340d9e31d2c6bee5f72d9040ce569049","date":1431584404,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.publishCoresAsDown(solrCores.getCores());\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n    \n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n    \n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.publishCoresAsDown(solrCores.getCores());\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"58b7eb80017f1c5b32035176b965fa0cc0287d04","date":1432069816,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.publishCoresAsDown(solrCores.getCores());\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n    \n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n    \n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.publishCoresAsDown(solrCores.getCores());\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n    \n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n    \n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"275019a81d0883a1db4560391b072d1fbe272ec4","date":1432741049,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    isShutDown = true;\n    \n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.publishCoresAsDown(solrCores.getCores());\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n    \n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n    \n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    isShutDown = true;\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.publishCoresAsDown(solrCores.getCores());\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n    \n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n    \n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6bdcb86c29922edae9a14852e636303bc52df094","date":1438887454,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    isShutDown = true;\n    \n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.publishCoresAsDown(solrCores.getCores());\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    isShutDown = true;\n    \n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.publishCoresAsDown(solrCores.getCores());\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n    \n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n    \n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fb65cc25534f4e0d77ed573d35995eb0b836b818","date":1454441028,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.publishCoresAsDown(solrCores.getCores());\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    isShutDown = true;\n    \n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.publishCoresAsDown(solrCores.getCores());\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"acd1f5a977dc3b97799ed300423294e2c457774f","date":1454537003,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.publishCoresAsDown(solrCores.getCores());\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    isShutDown = true;\n    \n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.publishCoresAsDown(solrCores.getCores());\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.publishCoresAsDown(solrCores.getCores());\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n    \n    isShutDown = true;\n    \n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n    \n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.publishCoresAsDown(solrCores.getCores());\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4820e7931c05e4eb25ac34917774fbacab59c3a3","date":1454991883,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName()); \n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.publishCoresAsDown(solrCores.getCores());\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0265144286422ad99682a00904cc2536b79c8535","date":1482222684,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName()); \n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    if (metricManager != null) {\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoMBean.Group.node));\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName()); \n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","date":1482251961,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName()); \n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    if (metricManager != null) {\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoMBean.Group.node));\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName()); \n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"76634b4b1f858b91192740147c05b56c206d03fb","date":1486850923,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName()); \n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    if (metricManager != null) {\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoMBean.Group.node));\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName()); \n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          backgroundCloser.join();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    if (metricManager != null) {\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoMBean.Group.node));\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":["a837c064b67fa63a9394136e31218b908cdcf783"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"073f1aa70444ec64f3e216816af2a3b43fa38fe7","date":1488920481,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n    if (metricManager != null) {\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoMBean.Group.node));\n    }\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoMBean.Group.cluster));\n      }\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName()); \n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    if (metricManager != null) {\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoMBean.Group.node));\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"816521ebaad5add9cb96bb88c577394e2938c40b","date":1491931343,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n    if (metricManager != null) {\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n    }\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n      }\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n    if (metricManager != null) {\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoMBean.Group.node));\n    }\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoMBean.Group.cluster));\n      }\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n    if (metricManager != null) {\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n    }\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n      }\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n    if (metricManager != null) {\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoMBean.Group.node));\n    }\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoMBean.Group.cluster));\n      }\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f9f72c9b3f95ea71c631268479ce720376c6f248","date":1508236500,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n    if (metricManager != null) {\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n    }\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n      try {\n        zkSys.zkController.removeEphemeralLiveNode();\n      } catch (Exception e) {\n        log.warn(\"Error removing live node. Continuing to close CoreContainer\", e);\n      }\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n      }\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n    if (metricManager != null) {\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n    }\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n      }\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2bc7a931e936fea6f08e59ae4de1a28e60b4009a","date":1508245524,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n    if (metricManager != null) {\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n    }\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n      try {\n        zkSys.zkController.removeEphemeralLiveNode();\n      } catch (Exception e) {\n        log.warn(\"Error removing live node. Continuing to close CoreContainer\", e);\n      }\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n      }\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n    if (metricManager != null) {\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n    }\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n      }\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bfc52860e6d13d034226a760813c59d984c6817a","date":1522229027,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n    if (metricManager != null) {\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n    }\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n      try {\n        zkSys.zkController.removeEphemeralLiveNode();\n      } catch (Exception e) {\n        log.warn(\"Error removing live node. Continuing to close CoreContainer\", e);\n      }\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n      }\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n    if (metricManager != null) {\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n    }\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n      try {\n        zkSys.zkController.removeEphemeralLiveNode();\n      } catch (Exception e) {\n        log.warn(\"Error removing live node. Continuing to close CoreContainer\", e);\n      }\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n      }\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"43564cbb30b064675027cfb569564e8531096e97","date":1522334265,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n    if (metricManager != null) {\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n    }\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n      try {\n        zkSys.zkController.removeEphemeralLiveNode();\n      } catch (Exception e) {\n        log.warn(\"Error removing live node. Continuing to close CoreContainer\", e);\n      }\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n      }\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n    if (metricManager != null) {\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n    }\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n      try {\n        zkSys.zkController.removeEphemeralLiveNode();\n      } catch (Exception e) {\n        log.warn(\"Error removing live node. Continuing to close CoreContainer\", e);\n      }\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n      }\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a","date":1527582939,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n    if (metricManager != null) {\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n    }\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n      try {\n        zkSys.zkController.removeEphemeralLiveNode();\n      } catch (Exception e) {\n        log.warn(\"Error removing live node. Continuing to close CoreContainer\", e);\n      }\n      if (metricsHistoryHandler != null) {\n        IOUtils.closeQuietly(metricsHistoryHandler.getSolrClient());\n        metricsHistoryHandler.close();\n      }\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n      }\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n    if (metricManager != null) {\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n    }\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n      try {\n        zkSys.zkController.removeEphemeralLiveNode();\n      } catch (Exception e) {\n        log.warn(\"Error removing live node. Continuing to close CoreContainer\", e);\n      }\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n      }\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":["f8f0f2472d437d44ec2144932e1d13fb494e82a3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"defa11d88d50ec356d5e7428f1ebc89623e840ac","date":1527653148,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n    replayUpdatesExecutor.shutdownAndAwaitTermination();\n    if (metricManager != null) {\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n    }\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n      try {\n        zkSys.zkController.removeEphemeralLiveNode();\n      } catch (Exception e) {\n        log.warn(\"Error removing live node. Continuing to close CoreContainer\", e);\n      }\n      if (metricsHistoryHandler != null) {\n        IOUtils.closeQuietly(metricsHistoryHandler.getSolrClient());\n        metricsHistoryHandler.close();\n      }\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n      }\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n    if (metricManager != null) {\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n    }\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n      try {\n        zkSys.zkController.removeEphemeralLiveNode();\n      } catch (Exception e) {\n        log.warn(\"Error removing live node. Continuing to close CoreContainer\", e);\n      }\n      if (metricsHistoryHandler != null) {\n        IOUtils.closeQuietly(metricsHistoryHandler.getSolrClient());\n        metricsHistoryHandler.close();\n      }\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n      }\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f8f0f2472d437d44ec2144932e1d13fb494e82a3","date":1528403207,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n    replayUpdatesExecutor.shutdownAndAwaitTermination();\n\n    if (metricsHistoryHandler != null) {\n      IOUtils.closeQuietly(metricsHistoryHandler.getSolrClient());\n      metricsHistoryHandler.close();\n    }\n\n    if (metricManager != null) {\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n    }\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n      try {\n        zkSys.zkController.removeEphemeralLiveNode();\n      } catch (Exception e) {\n        log.warn(\"Error removing live node. Continuing to close CoreContainer\", e);\n      }\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n      }\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n    replayUpdatesExecutor.shutdownAndAwaitTermination();\n    if (metricManager != null) {\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n    }\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n      try {\n        zkSys.zkController.removeEphemeralLiveNode();\n      } catch (Exception e) {\n        log.warn(\"Error removing live node. Continuing to close CoreContainer\", e);\n      }\n      if (metricsHistoryHandler != null) {\n        IOUtils.closeQuietly(metricsHistoryHandler.getSolrClient());\n        metricsHistoryHandler.close();\n      }\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n      }\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":["4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a"],"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n    replayUpdatesExecutor.shutdownAndAwaitTermination();\n\n    if (metricsHistoryHandler != null) {\n      IOUtils.closeQuietly(metricsHistoryHandler.getSolrClient());\n      metricsHistoryHandler.close();\n    }\n\n    if (metricManager != null) {\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n    }\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n      try {\n        zkSys.zkController.removeEphemeralLiveNode();\n      } catch (Exception e) {\n        log.warn(\"Error removing live node. Continuing to close CoreContainer\", e);\n      }\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n      }\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n    replayUpdatesExecutor.shutdownAndAwaitTermination();\n    if (metricManager != null) {\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n    }\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n      try {\n        zkSys.zkController.removeEphemeralLiveNode();\n      } catch (Exception e) {\n        log.warn(\"Error removing live node. Continuing to close CoreContainer\", e);\n      }\n      if (metricsHistoryHandler != null) {\n        IOUtils.closeQuietly(metricsHistoryHandler.getSolrClient());\n        metricsHistoryHandler.close();\n      }\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n      }\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n    replayUpdatesExecutor.shutdownAndAwaitTermination();\n\n    if (metricsHistoryHandler != null) {\n      IOUtils.closeQuietly(metricsHistoryHandler.getSolrClient());\n      metricsHistoryHandler.close();\n    }\n\n    if (metricManager != null) {\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n    }\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n      try {\n        zkSys.zkController.removeEphemeralLiveNode();\n      } catch (Exception e) {\n        log.warn(\"Error removing live node. Continuing to close CoreContainer\", e);\n      }\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n      }\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n    replayUpdatesExecutor.shutdownAndAwaitTermination();\n    if (metricManager != null) {\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n    }\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n      try {\n        zkSys.zkController.removeEphemeralLiveNode();\n      } catch (Exception e) {\n        log.warn(\"Error removing live node. Continuing to close CoreContainer\", e);\n      }\n      if (metricsHistoryHandler != null) {\n        IOUtils.closeQuietly(metricsHistoryHandler.getSolrClient());\n        metricsHistoryHandler.close();\n      }\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n      }\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    ForkJoinPool customThreadPool = new ForkJoinPool(6);\n\n    isShutDown = true;\n    try {\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (isZooKeeperAware()) {\n          cancelCoreRecoveries();\n          try {\n            zkSys.zkController.removeEphemeralLiveNode();\n          } catch (AlreadyClosedException | SessionExpiredException | ConnectionLossException e) {\n\n          } catch (Exception e) {\n            log.warn(\"Error removing live node. Continuing to close CoreContainer\", e);\n          }\n        }\n\n        try {\n          if (zkSys.zkController.getZkClient().getConnectionManager().isConnected()) {\n            log.info(\"Publish this node as DOWN...\");\n            zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n          }\n        } catch (Exception e) {\n          log.warn(\"Error publishing nodes as down. Continuing to close CoreContainer\", e);\n        }\n      }\n\n      ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n      \n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n      \n      customThreadPool.submit(() -> Collections.singleton(replayUpdatesExecutor).parallelStream().forEach(c -> {\n        c.shutdownAndAwaitTermination();\n      }));\n\n      if (metricsHistoryHandler != null) {\n        customThreadPool.submit(() -> Collections.singleton(metricsHistoryHandler).parallelStream().forEach(c -> {\n          IOUtils.closeQuietly(c);\n        }));\n        customThreadPool.submit(() -> Collections.singleton(metricsHistoryHandler.getSolrClient()).parallelStream().forEach(c -> {\n          IOUtils.closeQuietly(c);\n        }));\n      }\n\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n      }\n\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (metricManager != null) {\n          metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n        }\n      }\n\n      try {\n        if (coreAdminHandler != null) {\n          customThreadPool.submit(() -> Collections.singleton(coreAdminHandler).parallelStream().forEach(c -> {\n            c.shutdown();\n          }));\n        }\n      } catch (Exception e) {\n        log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          customThreadPool.submit(() -> Collections.singleton(shardHandlerFactory).parallelStream().forEach(c -> {\n            c.close();\n          }));\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            customThreadPool.submit(() -> Collections.singleton(shardHandlerFactory).parallelStream().forEach(c -> {\n              updateShardHandler.close();\n            }));\n          }\n        } finally {\n          try {\n            // we want to close zk stuff last\n            zkSys.close();\n          } finally {\n            ExecutorUtil.shutdownAndAwaitTermination(customThreadPool);\n          }\n        }\n\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if (authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if (authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  /**\n   * Stops all cores.\n   */\n  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    isShutDown = true;\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n    replayUpdatesExecutor.shutdownAndAwaitTermination();\n\n    if (metricsHistoryHandler != null) {\n      IOUtils.closeQuietly(metricsHistoryHandler.getSolrClient());\n      metricsHistoryHandler.close();\n    }\n\n    if (metricManager != null) {\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n      metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n      metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n    }\n\n    if (isZooKeeperAware()) {\n      cancelCoreRecoveries();\n      zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n      try {\n        zkSys.zkController.removeEphemeralLiveNode();\n      } catch (Exception e) {\n        log.warn(\"Error removing live node. Continuing to close CoreContainer\", e);\n      }\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n      }\n    }\n\n    try {\n      if (coreAdminHandler != null) coreAdminHandler.shutdown();\n    } catch (Exception e) {\n      log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n    }\n\n    try {\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          shardHandlerFactory.close();\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            updateShardHandler.close();\n          }\n        } finally {\n          // we want to close zk stuff last\n          zkSys.close();\n        }\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if(authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if(authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":["073f1aa70444ec64f3e216816af2a3b43fa38fe7","fb65cc25534f4e0d77ed573d35995eb0b836b818","f9f72c9b3f95ea71c631268479ce720376c6f248","58b7eb80017f1c5b32035176b965fa0cc0287d04","defa11d88d50ec356d5e7428f1ebc89623e840ac","058f5a3debcfa0ea477da3eabb4cbe2ec0fac211","f8f0f2472d437d44ec2144932e1d13fb494e82a3","275019a81d0883a1db4560391b072d1fbe272ec4","58b41d4093a9662306bdc051e4b46643deff70de","816521ebaad5add9cb96bb88c577394e2938c40b","bfc52860e6d13d034226a760813c59d984c6817a","b374d78db8148ec6796fdf37148b33897ab40a8c","6784d0cc613dc1ee97030eaaa5e0754edc22d164","af02ebb711553a2cc1969b3ccd4997202c6b50ff","a7035935aa89f6951286e9005cbeb16e89a082a2","00e1c8e1340d9e31d2c6bee5f72d9040ce569049"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"313ee4f8f743ad1a6a1d143fe720eeaa899a8fb1","date":1543623206,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    ForkJoinPool customThreadPool = new ForkJoinPool(6);\n\n    isShutDown = true;\n    try {\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (isZooKeeperAware()) {\n          cancelCoreRecoveries();\n          try {\n            zkSys.zkController.removeEphemeralLiveNode();\n          } catch (AlreadyClosedException | SessionExpiredException | ConnectionLossException e) {\n\n          } catch (Exception e) {\n            log.warn(\"Error removing live node. Continuing to close CoreContainer\", e);\n          }\n        }\n\n        try {\n          if (zkSys.zkController.getZkClient().getConnectionManager().isConnected()) {\n            log.info(\"Publish this node as DOWN...\");\n            zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n          }\n        } catch (Exception e) {\n          log.warn(\"Error publishing nodes as down. Continuing to close CoreContainer\", e);\n        }\n      }\n\n      ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n      \n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n      \n      customThreadPool.submit(() -> Collections.singleton(replayUpdatesExecutor).parallelStream().forEach(c -> {\n        c.shutdownAndAwaitTermination();\n      }));\n\n      if (metricsHistoryHandler != null) {\n        metricsHistoryHandler.close();\n        IOUtils.closeQuietly(metricsHistoryHandler.getSolrClient());\n      }\n\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n      }\n\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (metricManager != null) {\n          metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n        }\n      }\n\n      try {\n        if (coreAdminHandler != null) {\n          customThreadPool.submit(() -> Collections.singleton(coreAdminHandler).parallelStream().forEach(c -> {\n            c.shutdown();\n          }));\n        }\n      } catch (Exception e) {\n        log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          customThreadPool.submit(() -> Collections.singleton(shardHandlerFactory).parallelStream().forEach(c -> {\n            c.close();\n          }));\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            customThreadPool.submit(() -> Collections.singleton(shardHandlerFactory).parallelStream().forEach(c -> {\n              updateShardHandler.close();\n            }));\n          }\n        } finally {\n          try {\n            // we want to close zk stuff last\n            zkSys.close();\n          } finally {\n            ExecutorUtil.shutdownAndAwaitTermination(customThreadPool);\n          }\n        }\n\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if (authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if (authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    ForkJoinPool customThreadPool = new ForkJoinPool(6);\n\n    isShutDown = true;\n    try {\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (isZooKeeperAware()) {\n          cancelCoreRecoveries();\n          try {\n            zkSys.zkController.removeEphemeralLiveNode();\n          } catch (AlreadyClosedException | SessionExpiredException | ConnectionLossException e) {\n\n          } catch (Exception e) {\n            log.warn(\"Error removing live node. Continuing to close CoreContainer\", e);\n          }\n        }\n\n        try {\n          if (zkSys.zkController.getZkClient().getConnectionManager().isConnected()) {\n            log.info(\"Publish this node as DOWN...\");\n            zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n          }\n        } catch (Exception e) {\n          log.warn(\"Error publishing nodes as down. Continuing to close CoreContainer\", e);\n        }\n      }\n\n      ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n      \n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n      \n      customThreadPool.submit(() -> Collections.singleton(replayUpdatesExecutor).parallelStream().forEach(c -> {\n        c.shutdownAndAwaitTermination();\n      }));\n\n      if (metricsHistoryHandler != null) {\n        customThreadPool.submit(() -> Collections.singleton(metricsHistoryHandler).parallelStream().forEach(c -> {\n          IOUtils.closeQuietly(c);\n        }));\n        customThreadPool.submit(() -> Collections.singleton(metricsHistoryHandler.getSolrClient()).parallelStream().forEach(c -> {\n          IOUtils.closeQuietly(c);\n        }));\n      }\n\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n      }\n\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (metricManager != null) {\n          metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n        }\n      }\n\n      try {\n        if (coreAdminHandler != null) {\n          customThreadPool.submit(() -> Collections.singleton(coreAdminHandler).parallelStream().forEach(c -> {\n            c.shutdown();\n          }));\n        }\n      } catch (Exception e) {\n        log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          customThreadPool.submit(() -> Collections.singleton(shardHandlerFactory).parallelStream().forEach(c -> {\n            c.close();\n          }));\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            customThreadPool.submit(() -> Collections.singleton(shardHandlerFactory).parallelStream().forEach(c -> {\n              updateShardHandler.close();\n            }));\n          }\n        } finally {\n          try {\n            // we want to close zk stuff last\n            zkSys.close();\n          } finally {\n            ExecutorUtil.shutdownAndAwaitTermination(customThreadPool);\n          }\n        }\n\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if (authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if (authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e34aff27dfe70db6a9f0d2da0f5d9b640fbac18","date":1543645562,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    ExecutorService customThreadPool = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"closeThreadPool\"));\n\n    isShutDown = true;\n    try {\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (isZooKeeperAware()) {\n          cancelCoreRecoveries();\n          try {\n            zkSys.zkController.removeEphemeralLiveNode();\n          } catch (AlreadyClosedException | SessionExpiredException | ConnectionLossException e) {\n\n          } catch (Exception e) {\n            log.warn(\"Error removing live node. Continuing to close CoreContainer\", e);\n          }\n        }\n\n        try {\n          if (zkSys.zkController.getZkClient().getConnectionManager().isConnected()) {\n            log.info(\"Publish this node as DOWN...\");\n            zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n          }\n        } catch (Exception e) {\n          log.warn(\"Error publishing nodes as down. Continuing to close CoreContainer\", e);\n        }\n      }\n\n      ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n      \n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n      \n      customThreadPool.submit(() -> {\n        replayUpdatesExecutor.shutdownAndAwaitTermination();\n      });\n\n      if (metricsHistoryHandler != null) {\n        metricsHistoryHandler.close();\n        IOUtils.closeQuietly(metricsHistoryHandler.getSolrClient());\n      }\n\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n      }\n\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (metricManager != null) {\n          metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n        }\n      }\n\n      try {\n        if (coreAdminHandler != null) {\n          customThreadPool.submit(() -> {\n            coreAdminHandler.shutdown();\n          });\n        }\n      } catch (Exception e) {\n        log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          customThreadPool.submit(() -> {\n            shardHandlerFactory.close();\n          });\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            customThreadPool.submit(() -> Collections.singleton(shardHandlerFactory).parallelStream().forEach(c -> {\n              updateShardHandler.close();\n            }));\n          }\n        } finally {\n          try {\n            // we want to close zk stuff last\n            zkSys.close();\n          } finally {\n            ExecutorUtil.shutdownAndAwaitTermination(customThreadPool);\n          }\n        }\n\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if (authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if (authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    ForkJoinPool customThreadPool = new ForkJoinPool(6);\n\n    isShutDown = true;\n    try {\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (isZooKeeperAware()) {\n          cancelCoreRecoveries();\n          try {\n            zkSys.zkController.removeEphemeralLiveNode();\n          } catch (AlreadyClosedException | SessionExpiredException | ConnectionLossException e) {\n\n          } catch (Exception e) {\n            log.warn(\"Error removing live node. Continuing to close CoreContainer\", e);\n          }\n        }\n\n        try {\n          if (zkSys.zkController.getZkClient().getConnectionManager().isConnected()) {\n            log.info(\"Publish this node as DOWN...\");\n            zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n          }\n        } catch (Exception e) {\n          log.warn(\"Error publishing nodes as down. Continuing to close CoreContainer\", e);\n        }\n      }\n\n      ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n      \n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n      \n      customThreadPool.submit(() -> Collections.singleton(replayUpdatesExecutor).parallelStream().forEach(c -> {\n        c.shutdownAndAwaitTermination();\n      }));\n\n      if (metricsHistoryHandler != null) {\n        metricsHistoryHandler.close();\n        IOUtils.closeQuietly(metricsHistoryHandler.getSolrClient());\n      }\n\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n      }\n\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (metricManager != null) {\n          metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n        }\n      }\n\n      try {\n        if (coreAdminHandler != null) {\n          customThreadPool.submit(() -> Collections.singleton(coreAdminHandler).parallelStream().forEach(c -> {\n            c.shutdown();\n          }));\n        }\n      } catch (Exception e) {\n        log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          customThreadPool.submit(() -> Collections.singleton(shardHandlerFactory).parallelStream().forEach(c -> {\n            c.close();\n          }));\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            customThreadPool.submit(() -> Collections.singleton(shardHandlerFactory).parallelStream().forEach(c -> {\n              updateShardHandler.close();\n            }));\n          }\n        } finally {\n          try {\n            // we want to close zk stuff last\n            zkSys.close();\n          } finally {\n            ExecutorUtil.shutdownAndAwaitTermination(customThreadPool);\n          }\n        }\n\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if (authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if (authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b627755385655c7cd3fb296f17593658805cf4d5","date":1552455143,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\" + System.identityHashCode(this));\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerAsyncTaskExecutor);\n    ExecutorService customThreadPool = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"closeThreadPool\"));\n\n    isShutDown = true;\n    try {\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (isZooKeeperAware()) {\n          cancelCoreRecoveries();\n          try {\n            zkSys.zkController.removeEphemeralLiveNode();\n          } catch (AlreadyClosedException | SessionExpiredException | ConnectionLossException e) {\n\n          } catch (Exception e) {\n            log.warn(\"Error removing live node. Continuing to close CoreContainer\", e);\n          }\n        }\n\n        try {\n          if (zkSys.zkController.getZkClient().getConnectionManager().isConnected()) {\n            log.info(\"Publish this node as DOWN...\");\n            zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n          }\n        } catch (Exception e) {\n          log.warn(\"Error publishing nodes as down. Continuing to close CoreContainer\", e);\n        }\n      }\n\n      ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n      customThreadPool.submit(() -> {\n        replayUpdatesExecutor.shutdownAndAwaitTermination();\n      });\n\n      if (metricsHistoryHandler != null) {\n        metricsHistoryHandler.close();\n        IOUtils.closeQuietly(metricsHistoryHandler.getSolrClient());\n      }\n\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n      }\n\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (metricManager != null) {\n          metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n        }\n      }\n\n      try {\n        if (coreAdminHandler != null) {\n          customThreadPool.submit(() -> {\n            coreAdminHandler.shutdown();\n          });\n        }\n      } catch (Exception e) {\n        log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          customThreadPool.submit(() -> {\n            shardHandlerFactory.close();\n          });\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            customThreadPool.submit(() -> Collections.singleton(shardHandlerFactory).parallelStream().forEach(c -> {\n              updateShardHandler.close();\n            }));\n          }\n        } finally {\n          try {\n            // we want to close zk stuff last\n            zkSys.close();\n          } finally {\n            ExecutorUtil.shutdownAndAwaitTermination(customThreadPool);\n          }\n        }\n\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if (authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if (authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\"\n        + System.identityHashCode(this));\n\n    ExecutorService customThreadPool = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"closeThreadPool\"));\n\n    isShutDown = true;\n    try {\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (isZooKeeperAware()) {\n          cancelCoreRecoveries();\n          try {\n            zkSys.zkController.removeEphemeralLiveNode();\n          } catch (AlreadyClosedException | SessionExpiredException | ConnectionLossException e) {\n\n          } catch (Exception e) {\n            log.warn(\"Error removing live node. Continuing to close CoreContainer\", e);\n          }\n        }\n\n        try {\n          if (zkSys.zkController.getZkClient().getConnectionManager().isConnected()) {\n            log.info(\"Publish this node as DOWN...\");\n            zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n          }\n        } catch (Exception e) {\n          log.warn(\"Error publishing nodes as down. Continuing to close CoreContainer\", e);\n        }\n      }\n\n      ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n      \n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n      \n      customThreadPool.submit(() -> {\n        replayUpdatesExecutor.shutdownAndAwaitTermination();\n      });\n\n      if (metricsHistoryHandler != null) {\n        metricsHistoryHandler.close();\n        IOUtils.closeQuietly(metricsHistoryHandler.getSolrClient());\n      }\n\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n      }\n\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (metricManager != null) {\n          metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n        }\n      }\n\n      try {\n        if (coreAdminHandler != null) {\n          customThreadPool.submit(() -> {\n            coreAdminHandler.shutdown();\n          });\n        }\n      } catch (Exception e) {\n        log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          customThreadPool.submit(() -> {\n            shardHandlerFactory.close();\n          });\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            customThreadPool.submit(() -> Collections.singleton(shardHandlerFactory).parallelStream().forEach(c -> {\n              updateShardHandler.close();\n            }));\n          }\n        } finally {\n          try {\n            // we want to close zk stuff last\n            zkSys.close();\n          } finally {\n            ExecutorUtil.shutdownAndAwaitTermination(customThreadPool);\n          }\n        }\n\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if (authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if (authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"12ddd922ea96c1d0ea68a68506b6984a246cfb22","date":1554385731,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\" + System.identityHashCode(this));\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerAsyncTaskExecutor);\n    ExecutorService customThreadPool = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"closeThreadPool\"));\n\n    isShutDown = true;\n    try {\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (isZooKeeperAware()) {\n          cancelCoreRecoveries();\n          try {\n            zkSys.zkController.removeEphemeralLiveNode();\n          } catch (AlreadyClosedException | SessionExpiredException | ConnectionLossException e) {\n\n          } catch (Exception e) {\n            log.warn(\"Error removing live node. Continuing to close CoreContainer\", e);\n          }\n        }\n\n        try {\n          if (zkSys.zkController.getZkClient().getConnectionManager().isConnected()) {\n            log.info(\"Publish this node as DOWN...\");\n            zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n          }\n        } catch (Exception e) {\n          log.warn(\"Error publishing nodes as down. Continuing to close CoreContainer\", e);\n        }\n      }\n\n      ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n      customThreadPool.submit(() -> {\n        replayUpdatesExecutor.shutdownAndAwaitTermination();\n      });\n\n      if (metricsHistoryHandler != null) {\n        metricsHistoryHandler.close();\n        IOUtils.closeQuietly(metricsHistoryHandler.getSolrClient());\n      }\n\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n      }\n\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (metricManager != null) {\n          metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n        }\n      }\n\n      try {\n        if (coreAdminHandler != null) {\n          customThreadPool.submit(() -> {\n            coreAdminHandler.shutdown();\n          });\n        }\n      } catch (Exception e) {\n        log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          customThreadPool.submit(() -> {\n            shardHandlerFactory.close();\n          });\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            customThreadPool.submit(() -> Collections.singleton(shardHandlerFactory).parallelStream().forEach(c -> {\n              updateShardHandler.close();\n            }));\n          }\n        } finally {\n          try {\n            // we want to close zk stuff last\n            zkSys.close();\n          } finally {\n            ExecutorUtil.shutdownAndAwaitTermination(customThreadPool);\n          }\n        }\n\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if (authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if (authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    // It should be safe to close the auditlogger plugin at this point.\n    try {\n      if (auditloggerPlugin != null) {\n        auditloggerPlugin.plugin.close();\n        auditloggerPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing auditlogger plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\" + System.identityHashCode(this));\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerAsyncTaskExecutor);\n    ExecutorService customThreadPool = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"closeThreadPool\"));\n\n    isShutDown = true;\n    try {\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (isZooKeeperAware()) {\n          cancelCoreRecoveries();\n          try {\n            zkSys.zkController.removeEphemeralLiveNode();\n          } catch (AlreadyClosedException | SessionExpiredException | ConnectionLossException e) {\n\n          } catch (Exception e) {\n            log.warn(\"Error removing live node. Continuing to close CoreContainer\", e);\n          }\n        }\n\n        try {\n          if (zkSys.zkController.getZkClient().getConnectionManager().isConnected()) {\n            log.info(\"Publish this node as DOWN...\");\n            zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n          }\n        } catch (Exception e) {\n          log.warn(\"Error publishing nodes as down. Continuing to close CoreContainer\", e);\n        }\n      }\n\n      ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n      customThreadPool.submit(() -> {\n        replayUpdatesExecutor.shutdownAndAwaitTermination();\n      });\n\n      if (metricsHistoryHandler != null) {\n        metricsHistoryHandler.close();\n        IOUtils.closeQuietly(metricsHistoryHandler.getSolrClient());\n      }\n\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n      }\n\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (metricManager != null) {\n          metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n        }\n      }\n\n      try {\n        if (coreAdminHandler != null) {\n          customThreadPool.submit(() -> {\n            coreAdminHandler.shutdown();\n          });\n        }\n      } catch (Exception e) {\n        log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          customThreadPool.submit(() -> {\n            shardHandlerFactory.close();\n          });\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            customThreadPool.submit(() -> Collections.singleton(shardHandlerFactory).parallelStream().forEach(c -> {\n              updateShardHandler.close();\n            }));\n          }\n        } finally {\n          try {\n            // we want to close zk stuff last\n            zkSys.close();\n          } finally {\n            ExecutorUtil.shutdownAndAwaitTermination(customThreadPool);\n          }\n        }\n\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if (authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if (authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2dcafe37f7abc7c26e68e7d206bfe7380dd0f2a6","date":1554970874,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\" + System.identityHashCode(this));\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerAsyncTaskExecutor);\n    ExecutorService customThreadPool = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"closeThreadPool\"));\n\n    isShutDown = true;\n    try {\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n        zkSys.zkController.preClose();\n      }\n\n      ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n      customThreadPool.submit(() -> {\n        replayUpdatesExecutor.shutdownAndAwaitTermination();\n      });\n\n      if (metricsHistoryHandler != null) {\n        metricsHistoryHandler.close();\n        IOUtils.closeQuietly(metricsHistoryHandler.getSolrClient());\n      }\n\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n      }\n\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (metricManager != null) {\n          metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n        }\n      }\n\n      try {\n        if (coreAdminHandler != null) {\n          customThreadPool.submit(() -> {\n            coreAdminHandler.shutdown();\n          });\n        }\n      } catch (Exception e) {\n        log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          customThreadPool.submit(() -> {\n            shardHandlerFactory.close();\n          });\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            customThreadPool.submit(() -> Collections.singleton(shardHandlerFactory).parallelStream().forEach(c -> {\n              updateShardHandler.close();\n            }));\n          }\n        } finally {\n          try {\n            // we want to close zk stuff last\n            zkSys.close();\n          } finally {\n            ExecutorUtil.shutdownAndAwaitTermination(customThreadPool);\n          }\n        }\n\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if (authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if (authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    // It should be safe to close the auditlogger plugin at this point.\n    try {\n      if (auditloggerPlugin != null) {\n        auditloggerPlugin.plugin.close();\n        auditloggerPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing auditlogger plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\" + System.identityHashCode(this));\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerAsyncTaskExecutor);\n    ExecutorService customThreadPool = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"closeThreadPool\"));\n\n    isShutDown = true;\n    try {\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (isZooKeeperAware()) {\n          cancelCoreRecoveries();\n          try {\n            zkSys.zkController.removeEphemeralLiveNode();\n          } catch (AlreadyClosedException | SessionExpiredException | ConnectionLossException e) {\n\n          } catch (Exception e) {\n            log.warn(\"Error removing live node. Continuing to close CoreContainer\", e);\n          }\n        }\n\n        try {\n          if (zkSys.zkController.getZkClient().getConnectionManager().isConnected()) {\n            log.info(\"Publish this node as DOWN...\");\n            zkSys.zkController.publishNodeAsDown(zkSys.zkController.getNodeName());\n          }\n        } catch (Exception e) {\n          log.warn(\"Error publishing nodes as down. Continuing to close CoreContainer\", e);\n        }\n      }\n\n      ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n      customThreadPool.submit(() -> {\n        replayUpdatesExecutor.shutdownAndAwaitTermination();\n      });\n\n      if (metricsHistoryHandler != null) {\n        metricsHistoryHandler.close();\n        IOUtils.closeQuietly(metricsHistoryHandler.getSolrClient());\n      }\n\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n      }\n\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (metricManager != null) {\n          metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n        }\n      }\n\n      try {\n        if (coreAdminHandler != null) {\n          customThreadPool.submit(() -> {\n            coreAdminHandler.shutdown();\n          });\n        }\n      } catch (Exception e) {\n        log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          customThreadPool.submit(() -> {\n            shardHandlerFactory.close();\n          });\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            customThreadPool.submit(() -> Collections.singleton(shardHandlerFactory).parallelStream().forEach(c -> {\n              updateShardHandler.close();\n            }));\n          }\n        } finally {\n          try {\n            // we want to close zk stuff last\n            zkSys.close();\n          } finally {\n            ExecutorUtil.shutdownAndAwaitTermination(customThreadPool);\n          }\n        }\n\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if (authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if (authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    // It should be safe to close the auditlogger plugin at this point.\n    try {\n      if (auditloggerPlugin != null) {\n        auditloggerPlugin.plugin.close();\n        auditloggerPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing auditlogger plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1eebf1b080530bdd7572c4927fb2bb52334b7a86","date":1563199033,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  public void shutdown() {\n\n    ZkController zkController = getZkController();\n    if (zkController != null) {\n      OverseerTaskQueue overseerCollectionQueue = zkController.getOverseerCollectionQueue();\n      overseerCollectionQueue.allowOverseerPendingTasksToComplete();\n    }\n    log.info(\"Shutting down CoreContainer instance=\" + System.identityHashCode(this));\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerAsyncTaskExecutor);\n    ExecutorService customThreadPool = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"closeThreadPool\"));\n\n    isShutDown = true;\n    try {\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n        zkSys.zkController.preClose();\n      }\n\n      ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n      customThreadPool.submit(() -> {\n        replayUpdatesExecutor.shutdownAndAwaitTermination();\n      });\n\n      if (metricsHistoryHandler != null) {\n        metricsHistoryHandler.close();\n        IOUtils.closeQuietly(metricsHistoryHandler.getSolrClient());\n      }\n\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n      }\n\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (metricManager != null) {\n          metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n        }\n      }\n\n      try {\n        if (coreAdminHandler != null) {\n          customThreadPool.submit(() -> {\n            coreAdminHandler.shutdown();\n          });\n        }\n      } catch (Exception e) {\n        log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          customThreadPool.submit(() -> {\n            shardHandlerFactory.close();\n          });\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            customThreadPool.submit(() -> Collections.singleton(shardHandlerFactory).parallelStream().forEach(c -> {\n              updateShardHandler.close();\n            }));\n          }\n        } finally {\n          try {\n            // we want to close zk stuff last\n            zkSys.close();\n          } finally {\n            ExecutorUtil.shutdownAndAwaitTermination(customThreadPool);\n          }\n        }\n\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if (authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if (authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    // It should be safe to close the auditlogger plugin at this point.\n    try {\n      if (auditloggerPlugin != null) {\n        auditloggerPlugin.plugin.close();\n        auditloggerPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing auditlogger plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  public void shutdown() {\n    log.info(\"Shutting down CoreContainer instance=\" + System.identityHashCode(this));\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerAsyncTaskExecutor);\n    ExecutorService customThreadPool = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"closeThreadPool\"));\n\n    isShutDown = true;\n    try {\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n        zkSys.zkController.preClose();\n      }\n\n      ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n      customThreadPool.submit(() -> {\n        replayUpdatesExecutor.shutdownAndAwaitTermination();\n      });\n\n      if (metricsHistoryHandler != null) {\n        metricsHistoryHandler.close();\n        IOUtils.closeQuietly(metricsHistoryHandler.getSolrClient());\n      }\n\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n      }\n\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (metricManager != null) {\n          metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n        }\n      }\n\n      try {\n        if (coreAdminHandler != null) {\n          customThreadPool.submit(() -> {\n            coreAdminHandler.shutdown();\n          });\n        }\n      } catch (Exception e) {\n        log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          customThreadPool.submit(() -> {\n            shardHandlerFactory.close();\n          });\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            customThreadPool.submit(() -> Collections.singleton(shardHandlerFactory).parallelStream().forEach(c -> {\n              updateShardHandler.close();\n            }));\n          }\n        } finally {\n          try {\n            // we want to close zk stuff last\n            zkSys.close();\n          } finally {\n            ExecutorUtil.shutdownAndAwaitTermination(customThreadPool);\n          }\n        }\n\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if (authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if (authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    // It should be safe to close the auditlogger plugin at this point.\n    try {\n      if (auditloggerPlugin != null) {\n        auditloggerPlugin.plugin.close();\n        auditloggerPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing auditlogger plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"18e0d88ac18697f82cf4faddd993f4a76ff22722","date":1572586400,"type":3,"author":"noble","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  public void shutdown() {\n\n    ZkController zkController = getZkController();\n    if (zkController != null) {\n      OverseerTaskQueue overseerCollectionQueue = zkController.getOverseerCollectionQueue();\n      overseerCollectionQueue.allowOverseerPendingTasksToComplete();\n    }\n    log.info(\"Shutting down CoreContainer instance=\" + System.identityHashCode(this));\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerAsyncTaskExecutor);\n    ExecutorService customThreadPool = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"closeThreadPool\"));\n\n    isShutDown = true;\n    try {\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n        zkSys.zkController.preClose();\n      }\n\n      ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n      customThreadPool.submit(() -> {\n        replayUpdatesExecutor.shutdownAndAwaitTermination();\n      });\n\n      if (metricsHistoryHandler != null) {\n        metricsHistoryHandler.close();\n        IOUtils.closeQuietly(metricsHistoryHandler.getSolrClient());\n      }\n\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n      }\n\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (metricManager != null) {\n          metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n        }\n      }\n\n      try {\n        if (coreAdminHandler != null) {\n          customThreadPool.submit(() -> {\n            coreAdminHandler.shutdown();\n          });\n        }\n      } catch (Exception e) {\n        log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          customThreadPool.submit(() -> {\n            shardHandlerFactory.close();\n          });\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            customThreadPool.submit(() -> Collections.singleton(shardHandlerFactory).parallelStream().forEach(c -> {\n              updateShardHandler.close();\n            }));\n          }\n        } finally {\n          try {\n            // we want to close zk stuff last\n            zkSys.close();\n          } finally {\n            ExecutorUtil.shutdownAndAwaitTermination(customThreadPool);\n          }\n        }\n\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if (authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if (authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    // It should be safe to close the auditlogger plugin at this point.\n    try {\n      if (auditloggerPlugin != null) {\n        auditloggerPlugin.plugin.close();\n        auditloggerPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing auditlogger plugin.\", e);\n    }\n\n    if(packageLoader != null){\n      org.apache.lucene.util.IOUtils.closeWhileHandlingException(packageLoader);\n    }\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  public void shutdown() {\n\n    ZkController zkController = getZkController();\n    if (zkController != null) {\n      OverseerTaskQueue overseerCollectionQueue = zkController.getOverseerCollectionQueue();\n      overseerCollectionQueue.allowOverseerPendingTasksToComplete();\n    }\n    log.info(\"Shutting down CoreContainer instance=\" + System.identityHashCode(this));\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerAsyncTaskExecutor);\n    ExecutorService customThreadPool = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"closeThreadPool\"));\n\n    isShutDown = true;\n    try {\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n        zkSys.zkController.preClose();\n      }\n\n      ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n      customThreadPool.submit(() -> {\n        replayUpdatesExecutor.shutdownAndAwaitTermination();\n      });\n\n      if (metricsHistoryHandler != null) {\n        metricsHistoryHandler.close();\n        IOUtils.closeQuietly(metricsHistoryHandler.getSolrClient());\n      }\n\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n      }\n\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (metricManager != null) {\n          metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n        }\n      }\n\n      try {\n        if (coreAdminHandler != null) {\n          customThreadPool.submit(() -> {\n            coreAdminHandler.shutdown();\n          });\n        }\n      } catch (Exception e) {\n        log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          customThreadPool.submit(() -> {\n            shardHandlerFactory.close();\n          });\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            customThreadPool.submit(() -> Collections.singleton(shardHandlerFactory).parallelStream().forEach(c -> {\n              updateShardHandler.close();\n            }));\n          }\n        } finally {\n          try {\n            // we want to close zk stuff last\n            zkSys.close();\n          } finally {\n            ExecutorUtil.shutdownAndAwaitTermination(customThreadPool);\n          }\n        }\n\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if (authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if (authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    // It should be safe to close the auditlogger plugin at this point.\n    try {\n      if (auditloggerPlugin != null) {\n        auditloggerPlugin.plugin.close();\n        auditloggerPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing auditlogger plugin.\", e);\n    }\n\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb03700c9690d16b15fb4f56f6ec36b128fd894e","date":1586745995,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  public void shutdown() {\n\n    ZkController zkController = getZkController();\n    if (zkController != null) {\n      OverseerTaskQueue overseerCollectionQueue = zkController.getOverseerCollectionQueue();\n      overseerCollectionQueue.allowOverseerPendingTasksToComplete();\n    }\n    log.info(\"Shutting down CoreContainer instance=\" + System.identityHashCode(this));\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerAsyncTaskExecutor);\n    ExecutorService customThreadPool = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrNamedThreadFactory(\"closeThreadPool\"));\n\n    isShutDown = true;\n    try {\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n        zkSys.zkController.preClose();\n      }\n\n      ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n      customThreadPool.submit(() -> {\n        replayUpdatesExecutor.shutdownAndAwaitTermination();\n      });\n\n      if (metricsHistoryHandler != null) {\n        metricsHistoryHandler.close();\n        IOUtils.closeQuietly(metricsHistoryHandler.getSolrClient());\n      }\n\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n      }\n\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (metricManager != null) {\n          metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n        }\n      }\n\n      try {\n        if (coreAdminHandler != null) {\n          customThreadPool.submit(() -> {\n            coreAdminHandler.shutdown();\n          });\n        }\n      } catch (Exception e) {\n        log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          customThreadPool.submit(() -> {\n            shardHandlerFactory.close();\n          });\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            customThreadPool.submit(() -> Collections.singleton(shardHandlerFactory).parallelStream().forEach(c -> {\n              updateShardHandler.close();\n            }));\n          }\n        } finally {\n          try {\n            // we want to close zk stuff last\n            zkSys.close();\n          } finally {\n            ExecutorUtil.shutdownAndAwaitTermination(customThreadPool);\n          }\n        }\n\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if (authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if (authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    // It should be safe to close the auditlogger plugin at this point.\n    try {\n      if (auditloggerPlugin != null) {\n        auditloggerPlugin.plugin.close();\n        auditloggerPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing auditlogger plugin.\", e);\n    }\n\n    if(packageLoader != null){\n      org.apache.lucene.util.IOUtils.closeWhileHandlingException(packageLoader);\n    }\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  public void shutdown() {\n\n    ZkController zkController = getZkController();\n    if (zkController != null) {\n      OverseerTaskQueue overseerCollectionQueue = zkController.getOverseerCollectionQueue();\n      overseerCollectionQueue.allowOverseerPendingTasksToComplete();\n    }\n    log.info(\"Shutting down CoreContainer instance=\" + System.identityHashCode(this));\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerAsyncTaskExecutor);\n    ExecutorService customThreadPool = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"closeThreadPool\"));\n\n    isShutDown = true;\n    try {\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n        zkSys.zkController.preClose();\n      }\n\n      ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n      customThreadPool.submit(() -> {\n        replayUpdatesExecutor.shutdownAndAwaitTermination();\n      });\n\n      if (metricsHistoryHandler != null) {\n        metricsHistoryHandler.close();\n        IOUtils.closeQuietly(metricsHistoryHandler.getSolrClient());\n      }\n\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n      }\n\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (metricManager != null) {\n          metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n        }\n      }\n\n      try {\n        if (coreAdminHandler != null) {\n          customThreadPool.submit(() -> {\n            coreAdminHandler.shutdown();\n          });\n        }\n      } catch (Exception e) {\n        log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          customThreadPool.submit(() -> {\n            shardHandlerFactory.close();\n          });\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            customThreadPool.submit(() -> Collections.singleton(shardHandlerFactory).parallelStream().forEach(c -> {\n              updateShardHandler.close();\n            }));\n          }\n        } finally {\n          try {\n            // we want to close zk stuff last\n            zkSys.close();\n          } finally {\n            ExecutorUtil.shutdownAndAwaitTermination(customThreadPool);\n          }\n        }\n\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if (authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if (authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    // It should be safe to close the auditlogger plugin at this point.\n    try {\n      if (auditloggerPlugin != null) {\n        auditloggerPlugin.plugin.close();\n        auditloggerPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing auditlogger plugin.\", e);\n    }\n\n    if(packageLoader != null){\n      org.apache.lucene.util.IOUtils.closeWhileHandlingException(packageLoader);\n    }\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"140be51d03394488536f4aacedace29f9b318347","date":1587170432,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  public void shutdown() {\n\n    ZkController zkController = getZkController();\n    if (zkController != null) {\n      OverseerTaskQueue overseerCollectionQueue = zkController.getOverseerCollectionQueue();\n      overseerCollectionQueue.allowOverseerPendingTasksToComplete();\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Shutting down CoreContainer instance={}\", System.identityHashCode(this));\n    }\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerAsyncTaskExecutor);\n    ExecutorService customThreadPool = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrNamedThreadFactory(\"closeThreadPool\"));\n\n    isShutDown = true;\n    try {\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n        zkSys.zkController.preClose();\n      }\n\n      ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n      customThreadPool.submit(() -> {\n        replayUpdatesExecutor.shutdownAndAwaitTermination();\n      });\n\n      if (metricsHistoryHandler != null) {\n        metricsHistoryHandler.close();\n        IOUtils.closeQuietly(metricsHistoryHandler.getSolrClient());\n      }\n\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n      }\n\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (metricManager != null) {\n          metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n        }\n      }\n\n      try {\n        if (coreAdminHandler != null) {\n          customThreadPool.submit(() -> {\n            coreAdminHandler.shutdown();\n          });\n        }\n      } catch (Exception e) {\n        log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          customThreadPool.submit(() -> {\n            shardHandlerFactory.close();\n          });\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            customThreadPool.submit(() -> Collections.singleton(shardHandlerFactory).parallelStream().forEach(c -> {\n              updateShardHandler.close();\n            }));\n          }\n        } finally {\n          try {\n            // we want to close zk stuff last\n            zkSys.close();\n          } finally {\n            ExecutorUtil.shutdownAndAwaitTermination(customThreadPool);\n          }\n        }\n\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if (authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if (authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    // It should be safe to close the auditlogger plugin at this point.\n    try {\n      if (auditloggerPlugin != null) {\n        auditloggerPlugin.plugin.close();\n        auditloggerPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing auditlogger plugin.\", e);\n    }\n\n    if(packageLoader != null){\n      org.apache.lucene.util.IOUtils.closeWhileHandlingException(packageLoader);\n    }\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  public void shutdown() {\n\n    ZkController zkController = getZkController();\n    if (zkController != null) {\n      OverseerTaskQueue overseerCollectionQueue = zkController.getOverseerCollectionQueue();\n      overseerCollectionQueue.allowOverseerPendingTasksToComplete();\n    }\n    log.info(\"Shutting down CoreContainer instance=\" + System.identityHashCode(this));\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerAsyncTaskExecutor);\n    ExecutorService customThreadPool = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrNamedThreadFactory(\"closeThreadPool\"));\n\n    isShutDown = true;\n    try {\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n        zkSys.zkController.preClose();\n      }\n\n      ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n      customThreadPool.submit(() -> {\n        replayUpdatesExecutor.shutdownAndAwaitTermination();\n      });\n\n      if (metricsHistoryHandler != null) {\n        metricsHistoryHandler.close();\n        IOUtils.closeQuietly(metricsHistoryHandler.getSolrClient());\n      }\n\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n      }\n\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (metricManager != null) {\n          metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n        }\n      }\n\n      try {\n        if (coreAdminHandler != null) {\n          customThreadPool.submit(() -> {\n            coreAdminHandler.shutdown();\n          });\n        }\n      } catch (Exception e) {\n        log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          customThreadPool.submit(() -> {\n            shardHandlerFactory.close();\n          });\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            customThreadPool.submit(() -> Collections.singleton(shardHandlerFactory).parallelStream().forEach(c -> {\n              updateShardHandler.close();\n            }));\n          }\n        } finally {\n          try {\n            // we want to close zk stuff last\n            zkSys.close();\n          } finally {\n            ExecutorUtil.shutdownAndAwaitTermination(customThreadPool);\n          }\n        }\n\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if (authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if (authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    // It should be safe to close the auditlogger plugin at this point.\n    try {\n      if (auditloggerPlugin != null) {\n        auditloggerPlugin.plugin.close();\n        auditloggerPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing auditlogger plugin.\", e);\n    }\n\n    if(packageLoader != null){\n      org.apache.lucene.util.IOUtils.closeWhileHandlingException(packageLoader);\n    }\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2022c62013ac31ba0bed28b0f0e6faf9af8dd2aa","date":1589312640,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  public void shutdown() {\n\n    ZkController zkController = getZkController();\n    if (zkController != null) {\n      OverseerTaskQueue overseerCollectionQueue = zkController.getOverseerCollectionQueue();\n      overseerCollectionQueue.allowOverseerPendingTasksToComplete();\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Shutting down CoreContainer instance={}\", System.identityHashCode(this));\n    }\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerAsyncTaskExecutor);\n    ExecutorService customThreadPool = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrNamedThreadFactory(\"closeThreadPool\"));\n\n    isShutDown = true;\n    try {\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n        zkSys.zkController.preClose();\n      }\n\n      ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n      customThreadPool.submit(() -> {\n        replayUpdatesExecutor.shutdownAndAwaitTermination();\n      });\n\n      if (metricsHistoryHandler != null) {\n        metricsHistoryHandler.close();\n        IOUtils.closeQuietly(metricsHistoryHandler.getSolrClient());\n      }\n\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n      }\n\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (metricManager != null) {\n          metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n        }\n      }\n\n      try {\n        if (coreAdminHandler != null) {\n          customThreadPool.submit(() -> {\n            coreAdminHandler.shutdown();\n          });\n        }\n      } catch (Exception e) {\n        log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n      }\n      if (solrClientCache != null) {\n        solrClientCache.close();\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          customThreadPool.submit(() -> {\n            shardHandlerFactory.close();\n          });\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            customThreadPool.submit(() -> Collections.singleton(shardHandlerFactory).parallelStream().forEach(c -> {\n              updateShardHandler.close();\n            }));\n          }\n        } finally {\n          try {\n            // we want to close zk stuff last\n            zkSys.close();\n          } finally {\n            ExecutorUtil.shutdownAndAwaitTermination(customThreadPool);\n          }\n        }\n\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if (authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if (authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    // It should be safe to close the auditlogger plugin at this point.\n    try {\n      if (auditloggerPlugin != null) {\n        auditloggerPlugin.plugin.close();\n        auditloggerPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing auditlogger plugin.\", e);\n    }\n\n    if(packageLoader != null){\n      org.apache.lucene.util.IOUtils.closeWhileHandlingException(packageLoader);\n    }\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  public void shutdown() {\n\n    ZkController zkController = getZkController();\n    if (zkController != null) {\n      OverseerTaskQueue overseerCollectionQueue = zkController.getOverseerCollectionQueue();\n      overseerCollectionQueue.allowOverseerPendingTasksToComplete();\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Shutting down CoreContainer instance={}\", System.identityHashCode(this));\n    }\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerAsyncTaskExecutor);\n    ExecutorService customThreadPool = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrNamedThreadFactory(\"closeThreadPool\"));\n\n    isShutDown = true;\n    try {\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n        zkSys.zkController.preClose();\n      }\n\n      ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n      customThreadPool.submit(() -> {\n        replayUpdatesExecutor.shutdownAndAwaitTermination();\n      });\n\n      if (metricsHistoryHandler != null) {\n        metricsHistoryHandler.close();\n        IOUtils.closeQuietly(metricsHistoryHandler.getSolrClient());\n      }\n\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n      }\n\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (metricManager != null) {\n          metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n        }\n      }\n\n      try {\n        if (coreAdminHandler != null) {\n          customThreadPool.submit(() -> {\n            coreAdminHandler.shutdown();\n          });\n        }\n      } catch (Exception e) {\n        log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          customThreadPool.submit(() -> {\n            shardHandlerFactory.close();\n          });\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            customThreadPool.submit(() -> Collections.singleton(shardHandlerFactory).parallelStream().forEach(c -> {\n              updateShardHandler.close();\n            }));\n          }\n        } finally {\n          try {\n            // we want to close zk stuff last\n            zkSys.close();\n          } finally {\n            ExecutorUtil.shutdownAndAwaitTermination(customThreadPool);\n          }\n        }\n\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if (authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if (authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    // It should be safe to close the auditlogger plugin at this point.\n    try {\n      if (auditloggerPlugin != null) {\n        auditloggerPlugin.plugin.close();\n        auditloggerPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing auditlogger plugin.\", e);\n    }\n\n    if(packageLoader != null){\n      org.apache.lucene.util.IOUtils.closeWhileHandlingException(packageLoader);\n    }\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d7ced979f39d7651addfc7d805e1d9bfac215822","date":1589391432,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#shutdown().mjava","sourceNew":"  public void shutdown() {\n\n    ZkController zkController = getZkController();\n    if (zkController != null) {\n      OverseerTaskQueue overseerCollectionQueue = zkController.getOverseerCollectionQueue();\n      overseerCollectionQueue.allowOverseerPendingTasksToComplete();\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Shutting down CoreContainer instance={}\", System.identityHashCode(this));\n    }\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerAsyncTaskExecutor);\n    ExecutorService customThreadPool = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrNamedThreadFactory(\"closeThreadPool\"));\n\n    isShutDown = true;\n    try {\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n        zkSys.zkController.preClose();\n      }\n\n      ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      objectCache.clear();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n      customThreadPool.submit(() -> {\n        replayUpdatesExecutor.shutdownAndAwaitTermination();\n      });\n\n      if (metricsHistoryHandler != null) {\n        metricsHistoryHandler.close();\n        IOUtils.closeQuietly(metricsHistoryHandler.getSolrClient());\n      }\n\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n      }\n\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (metricManager != null) {\n          metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n        }\n      }\n\n      try {\n        if (coreAdminHandler != null) {\n          customThreadPool.submit(() -> {\n            coreAdminHandler.shutdown();\n          });\n        }\n      } catch (Exception e) {\n        log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n      }\n      if (solrClientCache != null) {\n        solrClientCache.close();\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          customThreadPool.submit(() -> {\n            shardHandlerFactory.close();\n          });\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            customThreadPool.submit(() -> Collections.singleton(shardHandlerFactory).parallelStream().forEach(c -> {\n              updateShardHandler.close();\n            }));\n          }\n        } finally {\n          try {\n            // we want to close zk stuff last\n            zkSys.close();\n          } finally {\n            ExecutorUtil.shutdownAndAwaitTermination(customThreadPool);\n          }\n        }\n\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if (authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if (authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    // It should be safe to close the auditlogger plugin at this point.\n    try {\n      if (auditloggerPlugin != null) {\n        auditloggerPlugin.plugin.close();\n        auditloggerPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing auditlogger plugin.\", e);\n    }\n\n    if(packageLoader != null){\n      org.apache.lucene.util.IOUtils.closeWhileHandlingException(packageLoader);\n    }\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","sourceOld":"  public void shutdown() {\n\n    ZkController zkController = getZkController();\n    if (zkController != null) {\n      OverseerTaskQueue overseerCollectionQueue = zkController.getOverseerCollectionQueue();\n      overseerCollectionQueue.allowOverseerPendingTasksToComplete();\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Shutting down CoreContainer instance={}\", System.identityHashCode(this));\n    }\n\n    ExecutorUtil.shutdownAndAwaitTermination(coreContainerAsyncTaskExecutor);\n    ExecutorService customThreadPool = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrNamedThreadFactory(\"closeThreadPool\"));\n\n    isShutDown = true;\n    try {\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n        zkSys.zkController.preClose();\n      }\n\n      ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n\n      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n      }\n      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n        try {\n          while (true) {\n            backgroundCloser.join(15000);\n            if (backgroundCloser.isAlive()) {\n              synchronized (solrCores.getModifyLock()) {\n                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n              }\n            } else {\n              break;\n            }\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          if (log.isDebugEnabled()) {\n            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n          }\n        }\n      }\n      // Now clear all the cores that are being operated upon.\n      solrCores.close();\n\n      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n      // Since all the pending operations queues have been drained, there should be nothing to do.\n      synchronized (solrCores.getModifyLock()) {\n        solrCores.getModifyLock().notifyAll(); // wake up the thread\n      }\n\n      customThreadPool.submit(() -> {\n        replayUpdatesExecutor.shutdownAndAwaitTermination();\n      });\n\n      if (metricsHistoryHandler != null) {\n        metricsHistoryHandler.close();\n        IOUtils.closeQuietly(metricsHistoryHandler.getSolrClient());\n      }\n\n      if (metricManager != null) {\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n      }\n\n      if (isZooKeeperAware()) {\n        cancelCoreRecoveries();\n\n        if (metricManager != null) {\n          metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n        }\n      }\n\n      try {\n        if (coreAdminHandler != null) {\n          customThreadPool.submit(() -> {\n            coreAdminHandler.shutdown();\n          });\n        }\n      } catch (Exception e) {\n        log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n      }\n      if (solrClientCache != null) {\n        solrClientCache.close();\n      }\n\n    } finally {\n      try {\n        if (shardHandlerFactory != null) {\n          customThreadPool.submit(() -> {\n            shardHandlerFactory.close();\n          });\n        }\n      } finally {\n        try {\n          if (updateShardHandler != null) {\n            customThreadPool.submit(() -> Collections.singleton(shardHandlerFactory).parallelStream().forEach(c -> {\n              updateShardHandler.close();\n            }));\n          }\n        } finally {\n          try {\n            // we want to close zk stuff last\n            zkSys.close();\n          } finally {\n            ExecutorUtil.shutdownAndAwaitTermination(customThreadPool);\n          }\n        }\n\n      }\n    }\n\n    // It should be safe to close the authorization plugin at this point.\n    try {\n      if (authorizationPlugin != null) {\n        authorizationPlugin.plugin.close();\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception while closing authorization plugin.\", e);\n    }\n\n    // It should be safe to close the authentication plugin at this point.\n    try {\n      if (authenticationPlugin != null) {\n        authenticationPlugin.plugin.close();\n        authenticationPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing authentication plugin.\", e);\n    }\n\n    // It should be safe to close the auditlogger plugin at this point.\n    try {\n      if (auditloggerPlugin != null) {\n        auditloggerPlugin.plugin.close();\n        auditloggerPlugin = null;\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception while closing auditlogger plugin.\", e);\n    }\n\n    if(packageLoader != null){\n      org.apache.lucene.util.IOUtils.closeWhileHandlingException(packageLoader);\n    }\n    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"58b7eb80017f1c5b32035176b965fa0cc0287d04":["00e1c8e1340d9e31d2c6bee5f72d9040ce569049"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["da2a6d8e77af99237dccb61ffaadcf0578f91903","af02ebb711553a2cc1969b3ccd4997202c6b50ff"],"058f5a3debcfa0ea477da3eabb4cbe2ec0fac211":["1e1921d1a653059438f4c18a3dad07ff197b0cab"],"d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1":["7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6"],"4820e7931c05e4eb25ac34917774fbacab59c3a3":["fb65cc25534f4e0d77ed573d35995eb0b836b818"],"313ee4f8f743ad1a6a1d143fe720eeaa899a8fb1":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["defa11d88d50ec356d5e7428f1ebc89623e840ac","f8f0f2472d437d44ec2144932e1d13fb494e82a3"],"b29abed5661c7911e4b45d5a3d79a186268e28c4":["9409650933cc688e77e565092a25e58adfc2e18d"],"da2a6d8e77af99237dccb61ffaadcf0578f91903":["512478b5e909ce226fd08d07746564a7d17ea1b6"],"512478b5e909ce226fd08d07746564a7d17ea1b6":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"aba371508186796cc6151d8223a5b4e16d02e26e":["af02ebb711553a2cc1969b3ccd4997202c6b50ff","63fce89dfe8a5dcba79c726470441c175441f122"],"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf":["4820e7931c05e4eb25ac34917774fbacab59c3a3","0265144286422ad99682a00904cc2536b79c8535"],"95303ff3749680c743b9425f9cf99e6e4065e8a8":["75de3186224c3841600321d68416c86a504aae43","474a065e1bf22f3551c2fd2c9e18bde479e5c3c5"],"140be51d03394488536f4aacedace29f9b318347":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"],"073f1aa70444ec64f3e216816af2a3b43fa38fe7":["76634b4b1f858b91192740147c05b56c206d03fb"],"6784d0cc613dc1ee97030eaaa5e0754edc22d164":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"76634b4b1f858b91192740147c05b56c206d03fb":["0265144286422ad99682a00904cc2536b79c8535"],"12ddd922ea96c1d0ea68a68506b6984a246cfb22":["b627755385655c7cd3fb296f17593658805cf4d5"],"474a065e1bf22f3551c2fd2c9e18bde479e5c3c5":["75de3186224c3841600321d68416c86a504aae43"],"2dcafe37f7abc7c26e68e7d206bfe7380dd0f2a6":["12ddd922ea96c1d0ea68a68506b6984a246cfb22"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["6bdcb86c29922edae9a14852e636303bc52df094","fb65cc25534f4e0d77ed573d35995eb0b836b818"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["c26f00b574427b55127e869b935845554afde1fa","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"63fce89dfe8a5dcba79c726470441c175441f122":["af02ebb711553a2cc1969b3ccd4997202c6b50ff"],"05a14b2611ead08655a2b2bdc61632eb31316e57":["aba371508186796cc6151d8223a5b4e16d02e26e","6013b4c7388f1627659c8f96c44abd10a294d3a6"],"0265144286422ad99682a00904cc2536b79c8535":["4820e7931c05e4eb25ac34917774fbacab59c3a3"],"bfc52860e6d13d034226a760813c59d984c6817a":["2bc7a931e936fea6f08e59ae4de1a28e60b4009a"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["af02ebb711553a2cc1969b3ccd4997202c6b50ff","63fce89dfe8a5dcba79c726470441c175441f122"],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["18e0d88ac18697f82cf4faddd993f4a76ff22722"],"75de3186224c3841600321d68416c86a504aae43":["c33399cc2618223f11ba493f9a3a2026fe05b579"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["91e069c492cf4895697ef7b81df0ffb9a8bd4b48","a7035935aa89f6951286e9005cbeb16e89a082a2"],"275019a81d0883a1db4560391b072d1fbe272ec4":["58b7eb80017f1c5b32035176b965fa0cc0287d04"],"6bdcb86c29922edae9a14852e636303bc52df094":["275019a81d0883a1db4560391b072d1fbe272ec4"],"8b6f42dee5a60f46a3fdf3ab93b39aefb356e245":["a837c064b67fa63a9394136e31218b908cdcf783"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["073f1aa70444ec64f3e216816af2a3b43fa38fe7"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["b374d78db8148ec6796fdf37148b33897ab40a8c","c33399cc2618223f11ba493f9a3a2026fe05b579"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["f8f0f2472d437d44ec2144932e1d13fb494e82a3"],"acd1f5a977dc3b97799ed300423294e2c457774f":["6bdcb86c29922edae9a14852e636303bc52df094","fb65cc25534f4e0d77ed573d35995eb0b836b818"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"c33399cc2618223f11ba493f9a3a2026fe05b579":["b374d78db8148ec6796fdf37148b33897ab40a8c"],"91e069c492cf4895697ef7b81df0ffb9a8bd4b48":["0d7032150736f83396eb1fd9fc65e18b918099be"],"af02ebb711553a2cc1969b3ccd4997202c6b50ff":["da2a6d8e77af99237dccb61ffaadcf0578f91903"],"fd92b8bcc88e969302510acf77bd6970da3994c4":["0d22ac6a4146774c1bc8400160fc0b6150294e92","da2a6d8e77af99237dccb61ffaadcf0578f91903"],"6013b4c7388f1627659c8f96c44abd10a294d3a6":["63fce89dfe8a5dcba79c726470441c175441f122"],"f9f72c9b3f95ea71c631268479ce720376c6f248":["816521ebaad5add9cb96bb88c577394e2938c40b"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["c26f00b574427b55127e869b935845554afde1fa","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a":["43564cbb30b064675027cfb569564e8531096e97"],"0e34aff27dfe70db6a9f0d2da0f5d9b640fbac18":["313ee4f8f743ad1a6a1d143fe720eeaa899a8fb1"],"9409650933cc688e77e565092a25e58adfc2e18d":["3278df77f7f499b55fdb79861c0641450444e7d0"],"3278df77f7f499b55fdb79861c0641450444e7d0":["8b6f42dee5a60f46a3fdf3ab93b39aefb356e245"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d7ced979f39d7651addfc7d805e1d9bfac215822":["2022c62013ac31ba0bed28b0f0e6faf9af8dd2aa"],"b374d78db8148ec6796fdf37148b33897ab40a8c":["a6378064655e76cd7b908b1cab4ce425b384b508"],"2bc7a931e936fea6f08e59ae4de1a28e60b4009a":["816521ebaad5add9cb96bb88c577394e2938c40b","f9f72c9b3f95ea71c631268479ce720376c6f248"],"1eebf1b080530bdd7572c4927fb2bb52334b7a86":["2dcafe37f7abc7c26e68e7d206bfe7380dd0f2a6"],"a7035935aa89f6951286e9005cbeb16e89a082a2":["91e069c492cf4895697ef7b81df0ffb9a8bd4b48"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["defa11d88d50ec356d5e7428f1ebc89623e840ac","f8f0f2472d437d44ec2144932e1d13fb494e82a3"],"defa11d88d50ec356d5e7428f1ebc89623e840ac":["4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a"],"2022c62013ac31ba0bed28b0f0e6faf9af8dd2aa":["140be51d03394488536f4aacedace29f9b318347"],"7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6":["6013b4c7388f1627659c8f96c44abd10a294d3a6"],"43564cbb30b064675027cfb569564e8531096e97":["2bc7a931e936fea6f08e59ae4de1a28e60b4009a","bfc52860e6d13d034226a760813c59d984c6817a"],"18e0d88ac18697f82cf4faddd993f4a76ff22722":["1eebf1b080530bdd7572c4927fb2bb52334b7a86"],"fb65cc25534f4e0d77ed573d35995eb0b836b818":["6bdcb86c29922edae9a14852e636303bc52df094"],"816521ebaad5add9cb96bb88c577394e2938c40b":["073f1aa70444ec64f3e216816af2a3b43fa38fe7"],"014f4a9c44ade09ba9dc8a50d2690f1303cbfaf7":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","da2a6d8e77af99237dccb61ffaadcf0578f91903"],"f8f0f2472d437d44ec2144932e1d13fb494e82a3":["defa11d88d50ec356d5e7428f1ebc89623e840ac"],"a6378064655e76cd7b908b1cab4ce425b384b508":["d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1"],"1e1921d1a653059438f4c18a3dad07ff197b0cab":["a7035935aa89f6951286e9005cbeb16e89a082a2"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["058f5a3debcfa0ea477da3eabb4cbe2ec0fac211"],"b627755385655c7cd3fb296f17593658805cf4d5":["0e34aff27dfe70db6a9f0d2da0f5d9b640fbac18"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["c26f00b574427b55127e869b935845554afde1fa"],"0d7032150736f83396eb1fd9fc65e18b918099be":["b29abed5661c7911e4b45d5a3d79a186268e28c4"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a837c064b67fa63a9394136e31218b908cdcf783":["474a065e1bf22f3551c2fd2c9e18bde479e5c3c5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d7ced979f39d7651addfc7d805e1d9bfac215822"],"00e1c8e1340d9e31d2c6bee5f72d9040ce569049":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"]},"commit2Childs":{"58b7eb80017f1c5b32035176b965fa0cc0287d04":["275019a81d0883a1db4560391b072d1fbe272ec4"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"058f5a3debcfa0ea477da3eabb4cbe2ec0fac211":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1":["a6378064655e76cd7b908b1cab4ce425b384b508"],"4820e7931c05e4eb25ac34917774fbacab59c3a3":["5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","0265144286422ad99682a00904cc2536b79c8535"],"313ee4f8f743ad1a6a1d143fe720eeaa899a8fb1":["0e34aff27dfe70db6a9f0d2da0f5d9b640fbac18"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"da2a6d8e77af99237dccb61ffaadcf0578f91903":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","af02ebb711553a2cc1969b3ccd4997202c6b50ff","fd92b8bcc88e969302510acf77bd6970da3994c4","014f4a9c44ade09ba9dc8a50d2690f1303cbfaf7"],"b29abed5661c7911e4b45d5a3d79a186268e28c4":["0d7032150736f83396eb1fd9fc65e18b918099be"],"512478b5e909ce226fd08d07746564a7d17ea1b6":["da2a6d8e77af99237dccb61ffaadcf0578f91903"],"aba371508186796cc6151d8223a5b4e16d02e26e":["05a14b2611ead08655a2b2bdc61632eb31316e57"],"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf":[],"95303ff3749680c743b9425f9cf99e6e4065e8a8":[],"140be51d03394488536f4aacedace29f9b318347":["2022c62013ac31ba0bed28b0f0e6faf9af8dd2aa"],"073f1aa70444ec64f3e216816af2a3b43fa38fe7":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","816521ebaad5add9cb96bb88c577394e2938c40b"],"6784d0cc613dc1ee97030eaaa5e0754edc22d164":["00e1c8e1340d9e31d2c6bee5f72d9040ce569049"],"76634b4b1f858b91192740147c05b56c206d03fb":["073f1aa70444ec64f3e216816af2a3b43fa38fe7"],"12ddd922ea96c1d0ea68a68506b6984a246cfb22":["2dcafe37f7abc7c26e68e7d206bfe7380dd0f2a6"],"474a065e1bf22f3551c2fd2c9e18bde479e5c3c5":["95303ff3749680c743b9425f9cf99e6e4065e8a8","a837c064b67fa63a9394136e31218b908cdcf783"],"2dcafe37f7abc7c26e68e7d206bfe7380dd0f2a6":["1eebf1b080530bdd7572c4927fb2bb52334b7a86"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["014f4a9c44ade09ba9dc8a50d2690f1303cbfaf7"],"63fce89dfe8a5dcba79c726470441c175441f122":["aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424","6013b4c7388f1627659c8f96c44abd10a294d3a6"],"05a14b2611ead08655a2b2bdc61632eb31316e57":[],"0265144286422ad99682a00904cc2536b79c8535":["5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","76634b4b1f858b91192740147c05b56c206d03fb"],"bfc52860e6d13d034226a760813c59d984c6817a":["43564cbb30b064675027cfb569564e8531096e97"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"75de3186224c3841600321d68416c86a504aae43":["95303ff3749680c743b9425f9cf99e6e4065e8a8","474a065e1bf22f3551c2fd2c9e18bde479e5c3c5"],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["140be51d03394488536f4aacedace29f9b318347"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"275019a81d0883a1db4560391b072d1fbe272ec4":["6bdcb86c29922edae9a14852e636303bc52df094"],"6bdcb86c29922edae9a14852e636303bc52df094":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","acd1f5a977dc3b97799ed300423294e2c457774f","fb65cc25534f4e0d77ed573d35995eb0b836b818"],"8b6f42dee5a60f46a3fdf3ab93b39aefb356e245":["3278df77f7f499b55fdb79861c0641450444e7d0"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":[],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["313ee4f8f743ad1a6a1d143fe720eeaa899a8fb1"],"acd1f5a977dc3b97799ed300423294e2c457774f":[],"c26f00b574427b55127e869b935845554afde1fa":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"c33399cc2618223f11ba493f9a3a2026fe05b579":["75de3186224c3841600321d68416c86a504aae43","d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"af02ebb711553a2cc1969b3ccd4997202c6b50ff":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","aba371508186796cc6151d8223a5b4e16d02e26e","63fce89dfe8a5dcba79c726470441c175441f122","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"91e069c492cf4895697ef7b81df0ffb9a8bd4b48":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","a7035935aa89f6951286e9005cbeb16e89a082a2"],"fd92b8bcc88e969302510acf77bd6970da3994c4":[],"6013b4c7388f1627659c8f96c44abd10a294d3a6":["05a14b2611ead08655a2b2bdc61632eb31316e57","7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6"],"f9f72c9b3f95ea71c631268479ce720376c6f248":["2bc7a931e936fea6f08e59ae4de1a28e60b4009a"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["fd92b8bcc88e969302510acf77bd6970da3994c4"],"4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a":["defa11d88d50ec356d5e7428f1ebc89623e840ac"],"9409650933cc688e77e565092a25e58adfc2e18d":["b29abed5661c7911e4b45d5a3d79a186268e28c4"],"0e34aff27dfe70db6a9f0d2da0f5d9b640fbac18":["b627755385655c7cd3fb296f17593658805cf4d5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"3278df77f7f499b55fdb79861c0641450444e7d0":["9409650933cc688e77e565092a25e58adfc2e18d"],"d7ced979f39d7651addfc7d805e1d9bfac215822":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2bc7a931e936fea6f08e59ae4de1a28e60b4009a":["bfc52860e6d13d034226a760813c59d984c6817a","43564cbb30b064675027cfb569564e8531096e97"],"b374d78db8148ec6796fdf37148b33897ab40a8c":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","c33399cc2618223f11ba493f9a3a2026fe05b579"],"1eebf1b080530bdd7572c4927fb2bb52334b7a86":["18e0d88ac18697f82cf4faddd993f4a76ff22722"],"a7035935aa89f6951286e9005cbeb16e89a082a2":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","1e1921d1a653059438f4c18a3dad07ff197b0cab"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[],"defa11d88d50ec356d5e7428f1ebc89623e840ac":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","f8f0f2472d437d44ec2144932e1d13fb494e82a3"],"7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6":["d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1"],"43564cbb30b064675027cfb569564e8531096e97":["4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a"],"2022c62013ac31ba0bed28b0f0e6faf9af8dd2aa":["d7ced979f39d7651addfc7d805e1d9bfac215822"],"fb65cc25534f4e0d77ed573d35995eb0b836b818":["4820e7931c05e4eb25ac34917774fbacab59c3a3","1e6acbaae7af722f17204ceccf0f7db5753eccf3","acd1f5a977dc3b97799ed300423294e2c457774f"],"18e0d88ac18697f82cf4faddd993f4a76ff22722":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"],"816521ebaad5add9cb96bb88c577394e2938c40b":["f9f72c9b3f95ea71c631268479ce720376c6f248","2bc7a931e936fea6f08e59ae4de1a28e60b4009a"],"014f4a9c44ade09ba9dc8a50d2690f1303cbfaf7":[],"f8f0f2472d437d44ec2144932e1d13fb494e82a3":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"a6378064655e76cd7b908b1cab4ce425b384b508":["b374d78db8148ec6796fdf37148b33897ab40a8c"],"1e1921d1a653059438f4c18a3dad07ff197b0cab":["058f5a3debcfa0ea477da3eabb4cbe2ec0fac211"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["512478b5e909ce226fd08d07746564a7d17ea1b6","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92"],"b627755385655c7cd3fb296f17593658805cf4d5":["12ddd922ea96c1d0ea68a68506b6984a246cfb22"],"0d7032150736f83396eb1fd9fc65e18b918099be":["91e069c492cf4895697ef7b81df0ffb9a8bd4b48"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"a837c064b67fa63a9394136e31218b908cdcf783":["8b6f42dee5a60f46a3fdf3ab93b39aefb356e245"],"00e1c8e1340d9e31d2c6bee5f72d9040ce569049":["58b7eb80017f1c5b32035176b965fa0cc0287d04"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","95303ff3749680c743b9425f9cf99e6e4065e8a8","1e6acbaae7af722f17204ceccf0f7db5753eccf3","05a14b2611ead08655a2b2bdc61632eb31316e57","fe33227f6805edab2036cbb80645cc4e2d1fa424","74f45af4339b0daf7a95c820ab88c1aea74fbce0","54ca69905c5d9d1529286f06ab1d12c68f6c13cb","d3fcb70cf561547c7bb1506e0cf32ca7b1287064","acd1f5a977dc3b97799ed300423294e2c457774f","fd92b8bcc88e969302510acf77bd6970da3994c4","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","014f4a9c44ade09ba9dc8a50d2690f1303cbfaf7","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}