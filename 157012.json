{"path":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#floor(BytesRef,BytesRef).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#floor(BytesRef,BytesRef).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#floor(BytesRef,BytesRef).mjava","sourceNew":"  /** Finds largest term accepted by this Automaton, that's\n   *  <= the provided input term.  The result is placed in\n   *  output; it's fine for output and input to point to\n   *  the same BytesRef.  The returned result is either the\n   *  provided output, or null if there is no floor term\n   *  (ie, the provided input term is before the first term\n   *  accepted by this Automaton). */\n  public BytesRef floor(BytesRef input, BytesRef output) {\n\n    output.offset = 0;\n    //if (DEBUG) System.out.println(\"CA.floor input=\" + input.utf8ToString());\n\n    int state = runAutomaton.getInitialState();\n\n    // Special case empty string:\n    if (input.length == 0) {\n      if (runAutomaton.isAccept(state)) {\n        output.length = 0;\n        return output;\n      } else {\n        return null;\n      }\n    }\n\n    final List<Integer> stack = new ArrayList<Integer>();\n\n    int idx = 0;\n    while (true) {\n      int label = input.bytes[input.offset + idx] & 0xff;\n      int nextState = runAutomaton.step(state, label);\n      //if (DEBUG) System.out.println(\"  cycle label=\" + (char) label + \" nextState=\" + nextState);\n\n      if (idx == input.length-1) {\n        if (nextState != -1 && runAutomaton.isAccept(nextState)) {\n          // Input string is accepted\n          if (idx >= output.bytes.length) {\n            output.grow(1+idx);\n          }\n          output.bytes[idx] = (byte) label;\n          output.length = input.length;\n          //if (DEBUG) System.out.println(\"  input is accepted; return term=\" + output.utf8ToString());\n          return output;\n        } else {\n          nextState = -1;\n        }\n      }\n\n      if (nextState == -1) {\n\n        // Pop back to a state that has a transition\n        // <= our label:\n        while (true) {\n          Transition[] transitions = sortedTransitions[state];\n          if (transitions.length == 0) {\n            assert runAutomaton.isAccept(state);\n            output.length = idx;\n            //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n            return output;\n          } else if (label-1 < transitions[0].min) {\n\n            if (runAutomaton.isAccept(state)) {\n              output.length = idx;\n              //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n              return output;\n            }\n            // pop\n            if (stack.size() == 0) {\n              //if (DEBUG) System.out.println(\"  pop ord=\" + idx + \" return null\");\n              return null;\n            } else {\n              state = stack.remove(stack.size()-1);\n              idx--;\n              //if (DEBUG) System.out.println(\"  pop ord=\" + (idx+1) + \" label=\" + (char) label + \" first trans.min=\" + (char) transitions[0].min);\n              label = input.bytes[input.offset + idx] & 0xff;\n            }\n\n          } else {\n            //if (DEBUG) System.out.println(\"  stop pop ord=\" + idx + \" first trans.min=\" + (char) transitions[0].min);\n            break;\n          }\n        }\n\n        //if (DEBUG) System.out.println(\"  label=\" + (char) label + \" idx=\" + idx);\n\n        return addTail(state, output, idx, label);\n        \n      } else {\n        if (idx >= output.bytes.length) {\n          output.grow(1+idx);\n        }\n        output.bytes[idx] = (byte) label;\n        stack.add(state);\n        state = nextState;\n        idx++;\n      }\n    }\n  }\n\n","sourceOld":"  /** Finds largest term accepted by this Automaton, that's\n   *  <= the provided input term.  The result is placed in\n   *  output; it's fine for output and input to point to\n   *  the same BytesRef.  The returned result is either the\n   *  provided output, or null if there is no floor term\n   *  (ie, the provided input term is before the first term\n   *  accepted by this Automaton). */\n  public BytesRef floor(BytesRef input, BytesRef output) {\n\n    output.offset = 0;\n    //if (DEBUG) System.out.println(\"CA.floor input=\" + input.utf8ToString());\n\n    int state = runAutomaton.getInitialState();\n\n    // Special case empty string:\n    if (input.length == 0) {\n      if (runAutomaton.isAccept(state)) {\n        output.length = 0;\n        return output;\n      } else {\n        return null;\n      }\n    }\n\n    final List<Integer> stack = new ArrayList<Integer>();\n\n    int idx = 0;\n    while (true) {\n      int label = input.bytes[input.offset + idx] & 0xff;\n      int nextState = runAutomaton.step(state, label);\n      //if (DEBUG) System.out.println(\"  cycle label=\" + (char) label + \" nextState=\" + nextState);\n\n      if (idx == input.length-1) {\n        if (nextState != -1 && runAutomaton.isAccept(nextState)) {\n          // Input string is accepted\n          if (idx >= output.bytes.length) {\n            output.grow(1+idx);\n          }\n          output.bytes[idx] = (byte) label;\n          output.length = input.length;\n          //if (DEBUG) System.out.println(\"  input is accepted; return term=\" + output.utf8ToString());\n          return output;\n        } else {\n          nextState = -1;\n        }\n      }\n\n      if (nextState == -1) {\n\n        // Pop back to a state that has a transition\n        // <= our label:\n        while (true) {\n          Transition[] transitions = sortedTransitions[state];\n          if (transitions.length == 0) {\n            assert runAutomaton.isAccept(state);\n            output.length = idx;\n            //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n            return output;\n          } else if (label-1 < transitions[0].min) {\n\n            if (runAutomaton.isAccept(state)) {\n              output.length = idx;\n              //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n              return output;\n            }\n            // pop\n            if (stack.size() == 0) {\n              //if (DEBUG) System.out.println(\"  pop ord=\" + idx + \" return null\");\n              return null;\n            } else {\n              state = stack.remove(stack.size()-1);\n              idx--;\n              //if (DEBUG) System.out.println(\"  pop ord=\" + (idx+1) + \" label=\" + (char) label + \" first trans.min=\" + (char) transitions[0].min);\n              label = input.bytes[input.offset + idx] & 0xff;\n            }\n\n          } else {\n            //if (DEBUG) System.out.println(\"  stop pop ord=\" + idx + \" first trans.min=\" + (char) transitions[0].min);\n            break;\n          }\n        }\n\n        //if (DEBUG) System.out.println(\"  label=\" + (char) label + \" idx=\" + idx);\n\n        return addTail(state, output, idx, label);\n        \n      } else {\n        if (idx >= output.bytes.length) {\n          output.grow(1+idx);\n        }\n        output.bytes[idx] = (byte) label;\n        stack.add(state);\n        state = nextState;\n        idx++;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#floor(BytesRef,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#floor(BytesRef,BytesRef).mjava","sourceNew":"  /** Finds largest term accepted by this Automaton, that's\n   *  <= the provided input term.  The result is placed in\n   *  output; it's fine for output and input to point to\n   *  the same BytesRef.  The returned result is either the\n   *  provided output, or null if there is no floor term\n   *  (ie, the provided input term is before the first term\n   *  accepted by this Automaton). */\n  public BytesRef floor(BytesRef input, BytesRef output) {\n\n    output.offset = 0;\n    //if (DEBUG) System.out.println(\"CA.floor input=\" + input.utf8ToString());\n\n    int state = runAutomaton.getInitialState();\n\n    // Special case empty string:\n    if (input.length == 0) {\n      if (runAutomaton.isAccept(state)) {\n        output.length = 0;\n        return output;\n      } else {\n        return null;\n      }\n    }\n\n    final List<Integer> stack = new ArrayList<>();\n\n    int idx = 0;\n    while (true) {\n      int label = input.bytes[input.offset + idx] & 0xff;\n      int nextState = runAutomaton.step(state, label);\n      //if (DEBUG) System.out.println(\"  cycle label=\" + (char) label + \" nextState=\" + nextState);\n\n      if (idx == input.length-1) {\n        if (nextState != -1 && runAutomaton.isAccept(nextState)) {\n          // Input string is accepted\n          if (idx >= output.bytes.length) {\n            output.grow(1+idx);\n          }\n          output.bytes[idx] = (byte) label;\n          output.length = input.length;\n          //if (DEBUG) System.out.println(\"  input is accepted; return term=\" + output.utf8ToString());\n          return output;\n        } else {\n          nextState = -1;\n        }\n      }\n\n      if (nextState == -1) {\n\n        // Pop back to a state that has a transition\n        // <= our label:\n        while (true) {\n          Transition[] transitions = sortedTransitions[state];\n          if (transitions.length == 0) {\n            assert runAutomaton.isAccept(state);\n            output.length = idx;\n            //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n            return output;\n          } else if (label-1 < transitions[0].min) {\n\n            if (runAutomaton.isAccept(state)) {\n              output.length = idx;\n              //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n              return output;\n            }\n            // pop\n            if (stack.size() == 0) {\n              //if (DEBUG) System.out.println(\"  pop ord=\" + idx + \" return null\");\n              return null;\n            } else {\n              state = stack.remove(stack.size()-1);\n              idx--;\n              //if (DEBUG) System.out.println(\"  pop ord=\" + (idx+1) + \" label=\" + (char) label + \" first trans.min=\" + (char) transitions[0].min);\n              label = input.bytes[input.offset + idx] & 0xff;\n            }\n\n          } else {\n            //if (DEBUG) System.out.println(\"  stop pop ord=\" + idx + \" first trans.min=\" + (char) transitions[0].min);\n            break;\n          }\n        }\n\n        //if (DEBUG) System.out.println(\"  label=\" + (char) label + \" idx=\" + idx);\n\n        return addTail(state, output, idx, label);\n        \n      } else {\n        if (idx >= output.bytes.length) {\n          output.grow(1+idx);\n        }\n        output.bytes[idx] = (byte) label;\n        stack.add(state);\n        state = nextState;\n        idx++;\n      }\n    }\n  }\n\n","sourceOld":"  /** Finds largest term accepted by this Automaton, that's\n   *  <= the provided input term.  The result is placed in\n   *  output; it's fine for output and input to point to\n   *  the same BytesRef.  The returned result is either the\n   *  provided output, or null if there is no floor term\n   *  (ie, the provided input term is before the first term\n   *  accepted by this Automaton). */\n  public BytesRef floor(BytesRef input, BytesRef output) {\n\n    output.offset = 0;\n    //if (DEBUG) System.out.println(\"CA.floor input=\" + input.utf8ToString());\n\n    int state = runAutomaton.getInitialState();\n\n    // Special case empty string:\n    if (input.length == 0) {\n      if (runAutomaton.isAccept(state)) {\n        output.length = 0;\n        return output;\n      } else {\n        return null;\n      }\n    }\n\n    final List<Integer> stack = new ArrayList<Integer>();\n\n    int idx = 0;\n    while (true) {\n      int label = input.bytes[input.offset + idx] & 0xff;\n      int nextState = runAutomaton.step(state, label);\n      //if (DEBUG) System.out.println(\"  cycle label=\" + (char) label + \" nextState=\" + nextState);\n\n      if (idx == input.length-1) {\n        if (nextState != -1 && runAutomaton.isAccept(nextState)) {\n          // Input string is accepted\n          if (idx >= output.bytes.length) {\n            output.grow(1+idx);\n          }\n          output.bytes[idx] = (byte) label;\n          output.length = input.length;\n          //if (DEBUG) System.out.println(\"  input is accepted; return term=\" + output.utf8ToString());\n          return output;\n        } else {\n          nextState = -1;\n        }\n      }\n\n      if (nextState == -1) {\n\n        // Pop back to a state that has a transition\n        // <= our label:\n        while (true) {\n          Transition[] transitions = sortedTransitions[state];\n          if (transitions.length == 0) {\n            assert runAutomaton.isAccept(state);\n            output.length = idx;\n            //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n            return output;\n          } else if (label-1 < transitions[0].min) {\n\n            if (runAutomaton.isAccept(state)) {\n              output.length = idx;\n              //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n              return output;\n            }\n            // pop\n            if (stack.size() == 0) {\n              //if (DEBUG) System.out.println(\"  pop ord=\" + idx + \" return null\");\n              return null;\n            } else {\n              state = stack.remove(stack.size()-1);\n              idx--;\n              //if (DEBUG) System.out.println(\"  pop ord=\" + (idx+1) + \" label=\" + (char) label + \" first trans.min=\" + (char) transitions[0].min);\n              label = input.bytes[input.offset + idx] & 0xff;\n            }\n\n          } else {\n            //if (DEBUG) System.out.println(\"  stop pop ord=\" + idx + \" first trans.min=\" + (char) transitions[0].min);\n            break;\n          }\n        }\n\n        //if (DEBUG) System.out.println(\"  label=\" + (char) label + \" idx=\" + idx);\n\n        return addTail(state, output, idx, label);\n        \n      } else {\n        if (idx >= output.bytes.length) {\n          output.grow(1+idx);\n        }\n        output.bytes[idx] = (byte) label;\n        stack.add(state);\n        state = nextState;\n        idx++;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ac34f0c5bb9274821fb0cb18075234e02002e9bf","date":1402508126,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#floor(BytesRef,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#floor(BytesRef,BytesRef).mjava","sourceNew":"  /** Finds largest term accepted by this Automaton, that's\n   *  <= the provided input term.  The result is placed in\n   *  output; it's fine for output and input to point to\n   *  the same BytesRef.  The returned result is either the\n   *  provided output, or null if there is no floor term\n   *  (ie, the provided input term is before the first term\n   *  accepted by this Automaton). */\n  public BytesRef floor(BytesRef input, BytesRef output) {\n\n    output.offset = 0;\n    //if (DEBUG) System.out.println(\"CA.floor input=\" + input.utf8ToString());\n\n    int state = runAutomaton.getInitialState();\n\n    // Special case empty string:\n    if (input.length == 0) {\n      if (runAutomaton.isAccept(state)) {\n        output.length = 0;\n        return output;\n      } else {\n        return null;\n      }\n    }\n\n    final List<Integer> stack = new ArrayList<>();\n\n    int idx = 0;\n    while (true) {\n      int label = input.bytes[input.offset + idx] & 0xff;\n      int nextState = runAutomaton.step(state, label);\n      //if (DEBUG) System.out.println(\"  cycle label=\" + (char) label + \" nextState=\" + nextState);\n\n      if (idx == input.length-1) {\n        if (nextState != -1 && runAutomaton.isAccept(nextState)) {\n          // Input string is accepted\n          if (idx >= output.bytes.length) {\n            output.grow(1+idx);\n          }\n          output.bytes[idx] = (byte) label;\n          output.length = input.length;\n          //if (DEBUG) System.out.println(\"  input is accepted; return term=\" + output.utf8ToString());\n          return output;\n        } else {\n          nextState = -1;\n        }\n      }\n\n      if (nextState == -1) {\n\n        // Pop back to a state that has a transition\n        // <= our label:\n        while (true) {\n          int numTransitions = lightAutomaton.getNumTransitions(state);\n          if (numTransitions == 0) {\n            assert runAutomaton.isAccept(state);\n            output.length = idx;\n            //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n            return output;\n          } else {\n            lightAutomaton.getTransition(state, 0, scratch);\n\n            if (label-1 < scratch.min) {\n\n              if (runAutomaton.isAccept(state)) {\n                output.length = idx;\n                //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n                return output;\n              }\n              // pop\n              if (stack.size() == 0) {\n                //if (DEBUG) System.out.println(\"  pop ord=\" + idx + \" return null\");\n                return null;\n              } else {\n                state = stack.remove(stack.size()-1);\n                idx--;\n                //if (DEBUG) System.out.println(\"  pop ord=\" + (idx+1) + \" label=\" + (char) label + \" first trans.min=\" + (char) transitions[0].min);\n                label = input.bytes[input.offset + idx] & 0xff;\n              }\n            } else {\n              //if (DEBUG) System.out.println(\"  stop pop ord=\" + idx + \" first trans.min=\" + (char) transitions[0].min);\n              break;\n            }\n          }\n        }\n\n        //if (DEBUG) System.out.println(\"  label=\" + (char) label + \" idx=\" + idx);\n\n        return addTail(state, output, idx, label);\n        \n      } else {\n        if (idx >= output.bytes.length) {\n          output.grow(1+idx);\n        }\n        output.bytes[idx] = (byte) label;\n        stack.add(state);\n        state = nextState;\n        idx++;\n      }\n    }\n  }\n\n","sourceOld":"  /** Finds largest term accepted by this Automaton, that's\n   *  <= the provided input term.  The result is placed in\n   *  output; it's fine for output and input to point to\n   *  the same BytesRef.  The returned result is either the\n   *  provided output, or null if there is no floor term\n   *  (ie, the provided input term is before the first term\n   *  accepted by this Automaton). */\n  public BytesRef floor(BytesRef input, BytesRef output) {\n\n    output.offset = 0;\n    //if (DEBUG) System.out.println(\"CA.floor input=\" + input.utf8ToString());\n\n    int state = runAutomaton.getInitialState();\n\n    // Special case empty string:\n    if (input.length == 0) {\n      if (runAutomaton.isAccept(state)) {\n        output.length = 0;\n        return output;\n      } else {\n        return null;\n      }\n    }\n\n    final List<Integer> stack = new ArrayList<>();\n\n    int idx = 0;\n    while (true) {\n      int label = input.bytes[input.offset + idx] & 0xff;\n      int nextState = runAutomaton.step(state, label);\n      //if (DEBUG) System.out.println(\"  cycle label=\" + (char) label + \" nextState=\" + nextState);\n\n      if (idx == input.length-1) {\n        if (nextState != -1 && runAutomaton.isAccept(nextState)) {\n          // Input string is accepted\n          if (idx >= output.bytes.length) {\n            output.grow(1+idx);\n          }\n          output.bytes[idx] = (byte) label;\n          output.length = input.length;\n          //if (DEBUG) System.out.println(\"  input is accepted; return term=\" + output.utf8ToString());\n          return output;\n        } else {\n          nextState = -1;\n        }\n      }\n\n      if (nextState == -1) {\n\n        // Pop back to a state that has a transition\n        // <= our label:\n        while (true) {\n          Transition[] transitions = sortedTransitions[state];\n          if (transitions.length == 0) {\n            assert runAutomaton.isAccept(state);\n            output.length = idx;\n            //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n            return output;\n          } else if (label-1 < transitions[0].min) {\n\n            if (runAutomaton.isAccept(state)) {\n              output.length = idx;\n              //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n              return output;\n            }\n            // pop\n            if (stack.size() == 0) {\n              //if (DEBUG) System.out.println(\"  pop ord=\" + idx + \" return null\");\n              return null;\n            } else {\n              state = stack.remove(stack.size()-1);\n              idx--;\n              //if (DEBUG) System.out.println(\"  pop ord=\" + (idx+1) + \" label=\" + (char) label + \" first trans.min=\" + (char) transitions[0].min);\n              label = input.bytes[input.offset + idx] & 0xff;\n            }\n\n          } else {\n            //if (DEBUG) System.out.println(\"  stop pop ord=\" + idx + \" first trans.min=\" + (char) transitions[0].min);\n            break;\n          }\n        }\n\n        //if (DEBUG) System.out.println(\"  label=\" + (char) label + \" idx=\" + idx);\n\n        return addTail(state, output, idx, label);\n        \n      } else {\n        if (idx >= output.bytes.length) {\n          output.grow(1+idx);\n        }\n        output.bytes[idx] = (byte) label;\n        stack.add(state);\n        state = nextState;\n        idx++;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9","date":1402946522,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#floor(BytesRef,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#floor(BytesRef,BytesRef).mjava","sourceNew":"  /** Finds largest term accepted by this Automaton, that's\n   *  <= the provided input term.  The result is placed in\n   *  output; it's fine for output and input to point to\n   *  the same BytesRef.  The returned result is either the\n   *  provided output, or null if there is no floor term\n   *  (ie, the provided input term is before the first term\n   *  accepted by this Automaton). */\n  public BytesRef floor(BytesRef input, BytesRef output) {\n\n    output.offset = 0;\n    //if (DEBUG) System.out.println(\"CA.floor input=\" + input.utf8ToString());\n\n    int state = runAutomaton.getInitialState();\n\n    // Special case empty string:\n    if (input.length == 0) {\n      if (runAutomaton.isAccept(state)) {\n        output.length = 0;\n        return output;\n      } else {\n        return null;\n      }\n    }\n\n    final List<Integer> stack = new ArrayList<>();\n\n    int idx = 0;\n    while (true) {\n      int label = input.bytes[input.offset + idx] & 0xff;\n      int nextState = runAutomaton.step(state, label);\n      //if (DEBUG) System.out.println(\"  cycle label=\" + (char) label + \" nextState=\" + nextState);\n\n      if (idx == input.length-1) {\n        if (nextState != -1 && runAutomaton.isAccept(nextState)) {\n          // Input string is accepted\n          if (idx >= output.bytes.length) {\n            output.grow(1+idx);\n          }\n          output.bytes[idx] = (byte) label;\n          output.length = input.length;\n          //if (DEBUG) System.out.println(\"  input is accepted; return term=\" + output.utf8ToString());\n          return output;\n        } else {\n          nextState = -1;\n        }\n      }\n\n      if (nextState == -1) {\n\n        // Pop back to a state that has a transition\n        // <= our label:\n        while (true) {\n          int numTransitions = lightAutomaton.getNumTransitions(state);\n          if (numTransitions == 0) {\n            assert runAutomaton.isAccept(state);\n            output.length = idx;\n            //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n            return output;\n          } else {\n            lightAutomaton.getTransition(state, 0, transition);\n\n            if (label-1 < transition.min) {\n\n              if (runAutomaton.isAccept(state)) {\n                output.length = idx;\n                //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n                return output;\n              }\n              // pop\n              if (stack.size() == 0) {\n                //if (DEBUG) System.out.println(\"  pop ord=\" + idx + \" return null\");\n                return null;\n              } else {\n                state = stack.remove(stack.size()-1);\n                idx--;\n                //if (DEBUG) System.out.println(\"  pop ord=\" + (idx+1) + \" label=\" + (char) label + \" first trans.min=\" + (char) transitions[0].min);\n                label = input.bytes[input.offset + idx] & 0xff;\n              }\n            } else {\n              //if (DEBUG) System.out.println(\"  stop pop ord=\" + idx + \" first trans.min=\" + (char) transitions[0].min);\n              break;\n            }\n          }\n        }\n\n        //if (DEBUG) System.out.println(\"  label=\" + (char) label + \" idx=\" + idx);\n\n        return addTail(state, output, idx, label);\n        \n      } else {\n        if (idx >= output.bytes.length) {\n          output.grow(1+idx);\n        }\n        output.bytes[idx] = (byte) label;\n        stack.add(state);\n        state = nextState;\n        idx++;\n      }\n    }\n  }\n\n","sourceOld":"  /** Finds largest term accepted by this Automaton, that's\n   *  <= the provided input term.  The result is placed in\n   *  output; it's fine for output and input to point to\n   *  the same BytesRef.  The returned result is either the\n   *  provided output, or null if there is no floor term\n   *  (ie, the provided input term is before the first term\n   *  accepted by this Automaton). */\n  public BytesRef floor(BytesRef input, BytesRef output) {\n\n    output.offset = 0;\n    //if (DEBUG) System.out.println(\"CA.floor input=\" + input.utf8ToString());\n\n    int state = runAutomaton.getInitialState();\n\n    // Special case empty string:\n    if (input.length == 0) {\n      if (runAutomaton.isAccept(state)) {\n        output.length = 0;\n        return output;\n      } else {\n        return null;\n      }\n    }\n\n    final List<Integer> stack = new ArrayList<>();\n\n    int idx = 0;\n    while (true) {\n      int label = input.bytes[input.offset + idx] & 0xff;\n      int nextState = runAutomaton.step(state, label);\n      //if (DEBUG) System.out.println(\"  cycle label=\" + (char) label + \" nextState=\" + nextState);\n\n      if (idx == input.length-1) {\n        if (nextState != -1 && runAutomaton.isAccept(nextState)) {\n          // Input string is accepted\n          if (idx >= output.bytes.length) {\n            output.grow(1+idx);\n          }\n          output.bytes[idx] = (byte) label;\n          output.length = input.length;\n          //if (DEBUG) System.out.println(\"  input is accepted; return term=\" + output.utf8ToString());\n          return output;\n        } else {\n          nextState = -1;\n        }\n      }\n\n      if (nextState == -1) {\n\n        // Pop back to a state that has a transition\n        // <= our label:\n        while (true) {\n          int numTransitions = lightAutomaton.getNumTransitions(state);\n          if (numTransitions == 0) {\n            assert runAutomaton.isAccept(state);\n            output.length = idx;\n            //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n            return output;\n          } else {\n            lightAutomaton.getTransition(state, 0, scratch);\n\n            if (label-1 < scratch.min) {\n\n              if (runAutomaton.isAccept(state)) {\n                output.length = idx;\n                //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n                return output;\n              }\n              // pop\n              if (stack.size() == 0) {\n                //if (DEBUG) System.out.println(\"  pop ord=\" + idx + \" return null\");\n                return null;\n              } else {\n                state = stack.remove(stack.size()-1);\n                idx--;\n                //if (DEBUG) System.out.println(\"  pop ord=\" + (idx+1) + \" label=\" + (char) label + \" first trans.min=\" + (char) transitions[0].min);\n                label = input.bytes[input.offset + idx] & 0xff;\n              }\n            } else {\n              //if (DEBUG) System.out.println(\"  stop pop ord=\" + idx + \" first trans.min=\" + (char) transitions[0].min);\n              break;\n            }\n          }\n        }\n\n        //if (DEBUG) System.out.println(\"  label=\" + (char) label + \" idx=\" + idx);\n\n        return addTail(state, output, idx, label);\n        \n      } else {\n        if (idx >= output.bytes.length) {\n          output.grow(1+idx);\n        }\n        output.bytes[idx] = (byte) label;\n        stack.add(state);\n        state = nextState;\n        idx++;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ca1c732df8923f5624f6c06b1dcca9e69d98c96","date":1402957391,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#floor(BytesRef,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#floor(BytesRef,BytesRef).mjava","sourceNew":"  /** Finds largest term accepted by this Automaton, that's\n   *  <= the provided input term.  The result is placed in\n   *  output; it's fine for output and input to point to\n   *  the same BytesRef.  The returned result is either the\n   *  provided output, or null if there is no floor term\n   *  (ie, the provided input term is before the first term\n   *  accepted by this Automaton). */\n  public BytesRef floor(BytesRef input, BytesRef output) {\n\n    output.offset = 0;\n    //if (DEBUG) System.out.println(\"CA.floor input=\" + input.utf8ToString());\n\n    int state = runAutomaton.getInitialState();\n\n    // Special case empty string:\n    if (input.length == 0) {\n      if (runAutomaton.isAccept(state)) {\n        output.length = 0;\n        return output;\n      } else {\n        return null;\n      }\n    }\n\n    final List<Integer> stack = new ArrayList<>();\n\n    int idx = 0;\n    while (true) {\n      int label = input.bytes[input.offset + idx] & 0xff;\n      int nextState = runAutomaton.step(state, label);\n      //if (DEBUG) System.out.println(\"  cycle label=\" + (char) label + \" nextState=\" + nextState);\n\n      if (idx == input.length-1) {\n        if (nextState != -1 && runAutomaton.isAccept(nextState)) {\n          // Input string is accepted\n          if (idx >= output.bytes.length) {\n            output.grow(1+idx);\n          }\n          output.bytes[idx] = (byte) label;\n          output.length = input.length;\n          //if (DEBUG) System.out.println(\"  input is accepted; return term=\" + output.utf8ToString());\n          return output;\n        } else {\n          nextState = -1;\n        }\n      }\n\n      if (nextState == -1) {\n\n        // Pop back to a state that has a transition\n        // <= our label:\n        while (true) {\n          int numTransitions = automaton.getNumTransitions(state);\n          if (numTransitions == 0) {\n            assert runAutomaton.isAccept(state);\n            output.length = idx;\n            //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n            return output;\n          } else {\n            automaton.getTransition(state, 0, transition);\n\n            if (label-1 < transition.min) {\n\n              if (runAutomaton.isAccept(state)) {\n                output.length = idx;\n                //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n                return output;\n              }\n              // pop\n              if (stack.size() == 0) {\n                //if (DEBUG) System.out.println(\"  pop ord=\" + idx + \" return null\");\n                return null;\n              } else {\n                state = stack.remove(stack.size()-1);\n                idx--;\n                //if (DEBUG) System.out.println(\"  pop ord=\" + (idx+1) + \" label=\" + (char) label + \" first trans.min=\" + (char) transitions[0].min);\n                label = input.bytes[input.offset + idx] & 0xff;\n              }\n            } else {\n              //if (DEBUG) System.out.println(\"  stop pop ord=\" + idx + \" first trans.min=\" + (char) transitions[0].min);\n              break;\n            }\n          }\n        }\n\n        //if (DEBUG) System.out.println(\"  label=\" + (char) label + \" idx=\" + idx);\n\n        return addTail(state, output, idx, label);\n        \n      } else {\n        if (idx >= output.bytes.length) {\n          output.grow(1+idx);\n        }\n        output.bytes[idx] = (byte) label;\n        stack.add(state);\n        state = nextState;\n        idx++;\n      }\n    }\n  }\n\n","sourceOld":"  /** Finds largest term accepted by this Automaton, that's\n   *  <= the provided input term.  The result is placed in\n   *  output; it's fine for output and input to point to\n   *  the same BytesRef.  The returned result is either the\n   *  provided output, or null if there is no floor term\n   *  (ie, the provided input term is before the first term\n   *  accepted by this Automaton). */\n  public BytesRef floor(BytesRef input, BytesRef output) {\n\n    output.offset = 0;\n    //if (DEBUG) System.out.println(\"CA.floor input=\" + input.utf8ToString());\n\n    int state = runAutomaton.getInitialState();\n\n    // Special case empty string:\n    if (input.length == 0) {\n      if (runAutomaton.isAccept(state)) {\n        output.length = 0;\n        return output;\n      } else {\n        return null;\n      }\n    }\n\n    final List<Integer> stack = new ArrayList<>();\n\n    int idx = 0;\n    while (true) {\n      int label = input.bytes[input.offset + idx] & 0xff;\n      int nextState = runAutomaton.step(state, label);\n      //if (DEBUG) System.out.println(\"  cycle label=\" + (char) label + \" nextState=\" + nextState);\n\n      if (idx == input.length-1) {\n        if (nextState != -1 && runAutomaton.isAccept(nextState)) {\n          // Input string is accepted\n          if (idx >= output.bytes.length) {\n            output.grow(1+idx);\n          }\n          output.bytes[idx] = (byte) label;\n          output.length = input.length;\n          //if (DEBUG) System.out.println(\"  input is accepted; return term=\" + output.utf8ToString());\n          return output;\n        } else {\n          nextState = -1;\n        }\n      }\n\n      if (nextState == -1) {\n\n        // Pop back to a state that has a transition\n        // <= our label:\n        while (true) {\n          int numTransitions = lightAutomaton.getNumTransitions(state);\n          if (numTransitions == 0) {\n            assert runAutomaton.isAccept(state);\n            output.length = idx;\n            //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n            return output;\n          } else {\n            lightAutomaton.getTransition(state, 0, transition);\n\n            if (label-1 < transition.min) {\n\n              if (runAutomaton.isAccept(state)) {\n                output.length = idx;\n                //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n                return output;\n              }\n              // pop\n              if (stack.size() == 0) {\n                //if (DEBUG) System.out.println(\"  pop ord=\" + idx + \" return null\");\n                return null;\n              } else {\n                state = stack.remove(stack.size()-1);\n                idx--;\n                //if (DEBUG) System.out.println(\"  pop ord=\" + (idx+1) + \" label=\" + (char) label + \" first trans.min=\" + (char) transitions[0].min);\n                label = input.bytes[input.offset + idx] & 0xff;\n              }\n            } else {\n              //if (DEBUG) System.out.println(\"  stop pop ord=\" + idx + \" first trans.min=\" + (char) transitions[0].min);\n              break;\n            }\n          }\n        }\n\n        //if (DEBUG) System.out.println(\"  label=\" + (char) label + \" idx=\" + idx);\n\n        return addTail(state, output, idx, label);\n        \n      } else {\n        if (idx >= output.bytes.length) {\n          output.grow(1+idx);\n        }\n        output.bytes[idx] = (byte) label;\n        stack.add(state);\n        state = nextState;\n        idx++;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c84485629d80d203608e8975a1139de9933cc38","date":1403166128,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#floor(BytesRef,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#floor(BytesRef,BytesRef).mjava","sourceNew":"  /** Finds largest term accepted by this Automaton, that's\n   *  <= the provided input term.  The result is placed in\n   *  output; it's fine for output and input to point to\n   *  the same BytesRef.  The returned result is either the\n   *  provided output, or null if there is no floor term\n   *  (ie, the provided input term is before the first term\n   *  accepted by this Automaton). */\n  public BytesRef floor(BytesRef input, BytesRef output) {\n\n    output.offset = 0;\n    //if (DEBUG) System.out.println(\"CA.floor input=\" + input.utf8ToString());\n\n    int state = runAutomaton.getInitialState();\n\n    // Special case empty string:\n    if (input.length == 0) {\n      if (runAutomaton.isAccept(state)) {\n        output.length = 0;\n        return output;\n      } else {\n        return null;\n      }\n    }\n\n    final List<Integer> stack = new ArrayList<>();\n\n    int idx = 0;\n    while (true) {\n      int label = input.bytes[input.offset + idx] & 0xff;\n      int nextState = runAutomaton.step(state, label);\n      //if (DEBUG) System.out.println(\"  cycle label=\" + (char) label + \" nextState=\" + nextState);\n\n      if (idx == input.length-1) {\n        if (nextState != -1 && runAutomaton.isAccept(nextState)) {\n          // Input string is accepted\n          if (idx >= output.bytes.length) {\n            output.grow(1+idx);\n          }\n          output.bytes[idx] = (byte) label;\n          output.length = input.length;\n          //if (DEBUG) System.out.println(\"  input is accepted; return term=\" + output.utf8ToString());\n          return output;\n        } else {\n          nextState = -1;\n        }\n      }\n\n      if (nextState == -1) {\n\n        // Pop back to a state that has a transition\n        // <= our label:\n        while (true) {\n          int numTransitions = automaton.getNumTransitions(state);\n          if (numTransitions == 0) {\n            assert runAutomaton.isAccept(state);\n            output.length = idx;\n            //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n            return output;\n          } else {\n            automaton.getTransition(state, 0, transition);\n\n            if (label-1 < transition.min) {\n\n              if (runAutomaton.isAccept(state)) {\n                output.length = idx;\n                //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n                return output;\n              }\n              // pop\n              if (stack.size() == 0) {\n                //if (DEBUG) System.out.println(\"  pop ord=\" + idx + \" return null\");\n                return null;\n              } else {\n                state = stack.remove(stack.size()-1);\n                idx--;\n                //if (DEBUG) System.out.println(\"  pop ord=\" + (idx+1) + \" label=\" + (char) label + \" first trans.min=\" + (char) transitions[0].min);\n                label = input.bytes[input.offset + idx] & 0xff;\n              }\n            } else {\n              //if (DEBUG) System.out.println(\"  stop pop ord=\" + idx + \" first trans.min=\" + (char) transitions[0].min);\n              break;\n            }\n          }\n        }\n\n        //if (DEBUG) System.out.println(\"  label=\" + (char) label + \" idx=\" + idx);\n\n        return addTail(state, output, idx, label);\n        \n      } else {\n        if (idx >= output.bytes.length) {\n          output.grow(1+idx);\n        }\n        output.bytes[idx] = (byte) label;\n        stack.add(state);\n        state = nextState;\n        idx++;\n      }\n    }\n  }\n\n","sourceOld":"  /** Finds largest term accepted by this Automaton, that's\n   *  <= the provided input term.  The result is placed in\n   *  output; it's fine for output and input to point to\n   *  the same BytesRef.  The returned result is either the\n   *  provided output, or null if there is no floor term\n   *  (ie, the provided input term is before the first term\n   *  accepted by this Automaton). */\n  public BytesRef floor(BytesRef input, BytesRef output) {\n\n    output.offset = 0;\n    //if (DEBUG) System.out.println(\"CA.floor input=\" + input.utf8ToString());\n\n    int state = runAutomaton.getInitialState();\n\n    // Special case empty string:\n    if (input.length == 0) {\n      if (runAutomaton.isAccept(state)) {\n        output.length = 0;\n        return output;\n      } else {\n        return null;\n      }\n    }\n\n    final List<Integer> stack = new ArrayList<>();\n\n    int idx = 0;\n    while (true) {\n      int label = input.bytes[input.offset + idx] & 0xff;\n      int nextState = runAutomaton.step(state, label);\n      //if (DEBUG) System.out.println(\"  cycle label=\" + (char) label + \" nextState=\" + nextState);\n\n      if (idx == input.length-1) {\n        if (nextState != -1 && runAutomaton.isAccept(nextState)) {\n          // Input string is accepted\n          if (idx >= output.bytes.length) {\n            output.grow(1+idx);\n          }\n          output.bytes[idx] = (byte) label;\n          output.length = input.length;\n          //if (DEBUG) System.out.println(\"  input is accepted; return term=\" + output.utf8ToString());\n          return output;\n        } else {\n          nextState = -1;\n        }\n      }\n\n      if (nextState == -1) {\n\n        // Pop back to a state that has a transition\n        // <= our label:\n        while (true) {\n          Transition[] transitions = sortedTransitions[state];\n          if (transitions.length == 0) {\n            assert runAutomaton.isAccept(state);\n            output.length = idx;\n            //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n            return output;\n          } else if (label-1 < transitions[0].min) {\n\n            if (runAutomaton.isAccept(state)) {\n              output.length = idx;\n              //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n              return output;\n            }\n            // pop\n            if (stack.size() == 0) {\n              //if (DEBUG) System.out.println(\"  pop ord=\" + idx + \" return null\");\n              return null;\n            } else {\n              state = stack.remove(stack.size()-1);\n              idx--;\n              //if (DEBUG) System.out.println(\"  pop ord=\" + (idx+1) + \" label=\" + (char) label + \" first trans.min=\" + (char) transitions[0].min);\n              label = input.bytes[input.offset + idx] & 0xff;\n            }\n\n          } else {\n            //if (DEBUG) System.out.println(\"  stop pop ord=\" + idx + \" first trans.min=\" + (char) transitions[0].min);\n            break;\n          }\n        }\n\n        //if (DEBUG) System.out.println(\"  label=\" + (char) label + \" idx=\" + idx);\n\n        return addTail(state, output, idx, label);\n        \n      } else {\n        if (idx >= output.bytes.length) {\n          output.grow(1+idx);\n        }\n        output.bytes[idx] = (byte) label;\n        stack.add(state);\n        state = nextState;\n        idx++;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#floor(BytesRef,BytesRefBuilder).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#floor(BytesRef,BytesRef).mjava","sourceNew":"  /** Finds largest term accepted by this Automaton, that's\n   *  <= the provided input term.  The result is placed in\n   *  output; it's fine for output and input to point to\n   *  the same bytes.  The returned result is either the\n   *  provided output, or null if there is no floor term\n   *  (ie, the provided input term is before the first term\n   *  accepted by this Automaton). */\n  public BytesRef floor(BytesRef input, BytesRefBuilder output) {\n\n    //if (DEBUG) System.out.println(\"CA.floor input=\" + input.utf8ToString());\n\n    int state = runAutomaton.getInitialState();\n\n    // Special case empty string:\n    if (input.length == 0) {\n      if (runAutomaton.isAccept(state)) {\n        output.clear();\n        return output.get();\n      } else {\n        return null;\n      }\n    }\n\n    final List<Integer> stack = new ArrayList<>();\n\n    int idx = 0;\n    while (true) {\n      int label = input.bytes[input.offset + idx] & 0xff;\n      int nextState = runAutomaton.step(state, label);\n      //if (DEBUG) System.out.println(\"  cycle label=\" + (char) label + \" nextState=\" + nextState);\n\n      if (idx == input.length-1) {\n        if (nextState != -1 && runAutomaton.isAccept(nextState)) {\n          // Input string is accepted\n          output.grow(1+idx);\n          output.setByteAt(idx, (byte) label);\n          output.setLength(input.length);\n          //if (DEBUG) System.out.println(\"  input is accepted; return term=\" + output.utf8ToString());\n          return output.get();\n        } else {\n          nextState = -1;\n        }\n      }\n\n      if (nextState == -1) {\n\n        // Pop back to a state that has a transition\n        // <= our label:\n        while (true) {\n          int numTransitions = automaton.getNumTransitions(state);\n          if (numTransitions == 0) {\n            assert runAutomaton.isAccept(state);\n            output.setLength(idx);\n            //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n            return output.get();\n          } else {\n            automaton.getTransition(state, 0, transition);\n\n            if (label-1 < transition.min) {\n\n              if (runAutomaton.isAccept(state)) {\n                output.setLength(idx);\n                //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n                return output.get();\n              }\n              // pop\n              if (stack.size() == 0) {\n                //if (DEBUG) System.out.println(\"  pop ord=\" + idx + \" return null\");\n                return null;\n              } else {\n                state = stack.remove(stack.size()-1);\n                idx--;\n                //if (DEBUG) System.out.println(\"  pop ord=\" + (idx+1) + \" label=\" + (char) label + \" first trans.min=\" + (char) transitions[0].min);\n                label = input.bytes[input.offset + idx] & 0xff;\n              }\n            } else {\n              //if (DEBUG) System.out.println(\"  stop pop ord=\" + idx + \" first trans.min=\" + (char) transitions[0].min);\n              break;\n            }\n          }\n        }\n\n        //if (DEBUG) System.out.println(\"  label=\" + (char) label + \" idx=\" + idx);\n\n        return addTail(state, output, idx, label);\n        \n      } else {\n        output.grow(1+idx);\n        output.setByteAt(idx, (byte) label);\n        stack.add(state);\n        state = nextState;\n        idx++;\n      }\n    }\n  }\n\n","sourceOld":"  /** Finds largest term accepted by this Automaton, that's\n   *  <= the provided input term.  The result is placed in\n   *  output; it's fine for output and input to point to\n   *  the same BytesRef.  The returned result is either the\n   *  provided output, or null if there is no floor term\n   *  (ie, the provided input term is before the first term\n   *  accepted by this Automaton). */\n  public BytesRef floor(BytesRef input, BytesRef output) {\n\n    output.offset = 0;\n    //if (DEBUG) System.out.println(\"CA.floor input=\" + input.utf8ToString());\n\n    int state = runAutomaton.getInitialState();\n\n    // Special case empty string:\n    if (input.length == 0) {\n      if (runAutomaton.isAccept(state)) {\n        output.length = 0;\n        return output;\n      } else {\n        return null;\n      }\n    }\n\n    final List<Integer> stack = new ArrayList<>();\n\n    int idx = 0;\n    while (true) {\n      int label = input.bytes[input.offset + idx] & 0xff;\n      int nextState = runAutomaton.step(state, label);\n      //if (DEBUG) System.out.println(\"  cycle label=\" + (char) label + \" nextState=\" + nextState);\n\n      if (idx == input.length-1) {\n        if (nextState != -1 && runAutomaton.isAccept(nextState)) {\n          // Input string is accepted\n          if (idx >= output.bytes.length) {\n            output.grow(1+idx);\n          }\n          output.bytes[idx] = (byte) label;\n          output.length = input.length;\n          //if (DEBUG) System.out.println(\"  input is accepted; return term=\" + output.utf8ToString());\n          return output;\n        } else {\n          nextState = -1;\n        }\n      }\n\n      if (nextState == -1) {\n\n        // Pop back to a state that has a transition\n        // <= our label:\n        while (true) {\n          int numTransitions = automaton.getNumTransitions(state);\n          if (numTransitions == 0) {\n            assert runAutomaton.isAccept(state);\n            output.length = idx;\n            //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n            return output;\n          } else {\n            automaton.getTransition(state, 0, transition);\n\n            if (label-1 < transition.min) {\n\n              if (runAutomaton.isAccept(state)) {\n                output.length = idx;\n                //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n                return output;\n              }\n              // pop\n              if (stack.size() == 0) {\n                //if (DEBUG) System.out.println(\"  pop ord=\" + idx + \" return null\");\n                return null;\n              } else {\n                state = stack.remove(stack.size()-1);\n                idx--;\n                //if (DEBUG) System.out.println(\"  pop ord=\" + (idx+1) + \" label=\" + (char) label + \" first trans.min=\" + (char) transitions[0].min);\n                label = input.bytes[input.offset + idx] & 0xff;\n              }\n            } else {\n              //if (DEBUG) System.out.println(\"  stop pop ord=\" + idx + \" first trans.min=\" + (char) transitions[0].min);\n              break;\n            }\n          }\n        }\n\n        //if (DEBUG) System.out.println(\"  label=\" + (char) label + \" idx=\" + idx);\n\n        return addTail(state, output, idx, label);\n        \n      } else {\n        if (idx >= output.bytes.length) {\n          output.grow(1+idx);\n        }\n        output.bytes[idx] = (byte) label;\n        stack.add(state);\n        state = nextState;\n        idx++;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9":["ac34f0c5bb9274821fb0cb18075234e02002e9bf"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["5c84485629d80d203608e8975a1139de9933cc38"],"5c84485629d80d203608e8975a1139de9933cc38":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"ac34f0c5bb9274821fb0cb18075234e02002e9bf":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["5c84485629d80d203608e8975a1139de9933cc38","ac34f0c5bb9274821fb0cb18075234e02002e9bf"],"31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["5c84485629d80d203608e8975a1139de9933cc38"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5c84485629d80d203608e8975a1139de9933cc38":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"ac34f0c5bb9274821fb0cb18075234e02002e9bf":["31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}