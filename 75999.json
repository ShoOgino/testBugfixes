{"path":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","commits":[{"id":"d80013b5e260def972025c93a0b08524f9c38f49","date":1170102801,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","pathOld":"/dev/null","sourceNew":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n    try {\n      Context c = new InitialContext();\n\n      /***\n      System.out.println(\"Enumerating JNDI Context=\" + c);\n      NamingEnumeration<NameClassPair> en = c.list(\"java:comp/env\");\n      while (en.hasMore()) {\n        NameClassPair ncp = en.next();\n        System.out.println(\"  ENTRY:\" + ncp);\n      }\n      System.out.println(\"JNDI lookup=\" + c.lookup(\"java:comp/env/solr/home\"));\n      ***/\n\n      String home = (String)c.lookup(\"java:comp/env/solr/home\");\n      if (home!=null) Config.setInstanceDir(home);\n    } catch (NoInitialContextException e) {\n      log.info(\"JNDI not configured for Solr (NoInitialContextEx)\");\n    } catch (NamingException e) {\n      log.info(\"No /solr/home in JNDI\");\n    }\n\n    log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n    core = SolrCore.getSolrCore();\n    parsers = new SolrRequestParsers( core, SolrConfig.config );\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43c800be98a24a96d9d21e62c645822de478f6a2","date":1171769593,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","sourceNew":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n    \n    // Only initalize the directory if it has not been done yet\n    if( !Config.isInstanceDirInitalized() ) {\n      try {\n        Context c = new InitialContext();\n        String home = (String)c.lookup(\"java:comp/env/solr/home\");\n        if (home!=null) Config.setInstanceDir(home);\n      } catch (NoInitialContextException e) {\n        log.info(\"JNDI not configured for Solr (NoInitialContextEx)\");\n      } catch (NamingException e) {\n        log.info(\"No /solr/home in JNDI\");\n      }\n    }\n    \n    // web.xml configuration\n    this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n    this.handleSelect = \"true\".equals( config.getInitParameter( \"handle-select\" ) );\n    \n    log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n    core = SolrCore.getSolrCore();\n    parsers = new SolrRequestParsers( core, SolrConfig.config );\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","sourceOld":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n    try {\n      Context c = new InitialContext();\n\n      /***\n      System.out.println(\"Enumerating JNDI Context=\" + c);\n      NamingEnumeration<NameClassPair> en = c.list(\"java:comp/env\");\n      while (en.hasMore()) {\n        NameClassPair ncp = en.next();\n        System.out.println(\"  ENTRY:\" + ncp);\n      }\n      System.out.println(\"JNDI lookup=\" + c.lookup(\"java:comp/env/solr/home\"));\n      ***/\n\n      String home = (String)c.lookup(\"java:comp/env/solr/home\");\n      if (home!=null) Config.setInstanceDir(home);\n    } catch (NoInitialContextException e) {\n      log.info(\"JNDI not configured for Solr (NoInitialContextEx)\");\n    } catch (NamingException e) {\n      log.info(\"No /solr/home in JNDI\");\n    }\n\n    log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n    core = SolrCore.getSolrCore();\n    parsers = new SolrRequestParsers( core, SolrConfig.config );\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8c31261092dc7e5e9e00b9a640af3d381679e98","date":1171935506,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","sourceNew":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n        \n    // web.xml configuration\n    this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n    this.handleSelect = \"true\".equals( config.getInitParameter( \"handle-select\" ) );\n    \n    log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n    core = SolrCore.getSolrCore();\n    parsers = new SolrRequestParsers( core, SolrConfig.config );\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","sourceOld":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n    \n    // Only initalize the directory if it has not been done yet\n    if( !Config.isInstanceDirInitalized() ) {\n      try {\n        Context c = new InitialContext();\n        String home = (String)c.lookup(\"java:comp/env/solr/home\");\n        if (home!=null) Config.setInstanceDir(home);\n      } catch (NoInitialContextException e) {\n        log.info(\"JNDI not configured for Solr (NoInitialContextEx)\");\n      } catch (NamingException e) {\n        log.info(\"No /solr/home in JNDI\");\n      }\n    }\n    \n    // web.xml configuration\n    this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n    this.handleSelect = \"true\".equals( config.getInitParameter( \"handle-select\" ) );\n    \n    log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n    core = SolrCore.getSolrCore();\n    parsers = new SolrRequestParsers( core, SolrConfig.config );\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"368c8927753a9ca6ee214a251da2746ff35aeef6","date":1177630664,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","sourceNew":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n    \n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      this.handleSelect = \"true\".equals( config.getInitParameter( \"handle-select\" ) );\n      \n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n      core = SolrCore.getSolrCore();\n      parsers = new SolrRequestParsers( core, SolrConfig.config );\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    boolean abortOnConfigurationError = SolrConfig.config.getBool(\"abortOnConfigurationError\",true);\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed infomation on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      out.println( \"in solrconfig.xml\\n\" );\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differntly if you throw an exception durring \n      // initalization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","sourceOld":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n        \n    // web.xml configuration\n    this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n    this.handleSelect = \"true\".equals( config.getInitParameter( \"handle-select\" ) );\n    \n    log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n    core = SolrCore.getSolrCore();\n    parsers = new SolrRequestParsers( core, SolrConfig.config );\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","bugFix":null,"bugIntro":["1a45fbd60083428b1b13884c5c8c2e33e7e71ee7","0aea57ab530d174e645bf6e14d04db1e243e13d7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9c35e0c1cd20847fdfcf51e89270b571ef397c32","date":1177879643,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","sourceNew":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n    \n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      \n      // Let this filter take care of /select?xxx format\n      this.handleSelect = \n        SolrConfig.config.getBool( \"requestDispatcher/@handleSelect\", false ); \n      \n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n      core = SolrCore.getSolrCore();\n      parsers = new SolrRequestParsers( core, SolrConfig.config );\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    boolean abortOnConfigurationError = SolrConfig.config.getBool(\"abortOnConfigurationError\",true);\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed infomation on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      out.println( \"in solrconfig.xml\\n\" );\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differntly if you throw an exception durring \n      // initalization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","sourceOld":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n    \n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      this.handleSelect = \"true\".equals( config.getInitParameter( \"handle-select\" ) );\n      \n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n      core = SolrCore.getSolrCore();\n      parsers = new SolrRequestParsers( core, SolrConfig.config );\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    boolean abortOnConfigurationError = SolrConfig.config.getBool(\"abortOnConfigurationError\",true);\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed infomation on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      out.println( \"in solrconfig.xml\\n\" );\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differntly if you throw an exception durring \n      // initalization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"60c72ea49d42d78d14d5791ec0bed001b5ba4f3d","date":1180843389,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","sourceNew":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n    \n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      \n      // Let this filter take care of /select?xxx format\n      this.handleSelect = \n        SolrConfig.config.getBool( \"requestDispatcher/@handleSelect\", false ); \n      \n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n      core = SolrCore.getSolrCore();\n      parsers = new SolrRequestParsers( core, SolrConfig.config );\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    boolean abortOnConfigurationError = SolrConfig.config.getBool(\"abortOnConfigurationError\",true);\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      out.println( \"in solrconfig.xml\\n\" );\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","sourceOld":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n    \n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      \n      // Let this filter take care of /select?xxx format\n      this.handleSelect = \n        SolrConfig.config.getBool( \"requestDispatcher/@handleSelect\", false ); \n      \n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n      core = SolrCore.getSolrCore();\n      parsers = new SolrRequestParsers( core, SolrConfig.config );\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    boolean abortOnConfigurationError = SolrConfig.config.getBool(\"abortOnConfigurationError\",true);\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed infomation on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      out.println( \"in solrconfig.xml\\n\" );\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differntly if you throw an exception durring \n      // initalization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"08735056ad6ff907f79db8c4cc9ae2ca593bfe22","date":1181588325,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","sourceNew":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n    \n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      \n      // Let this filter take care of /select?xxx format\n      this.handleSelect = \n        SolrConfig.config.getBool( \"requestDispatcher/@handleSelect\", false ); \n      \n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n      core = SolrCore.getSolrCore();\n      parsers = new SolrRequestParsers( core, SolrConfig.config );\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    boolean abortOnConfigurationError = SolrConfig.config.getBool(\"abortOnConfigurationError\",true);\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      out.println( \"in solrconfig.xml\\n\" );\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","sourceOld":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n    \n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      \n      // Let this filter take care of /select?xxx format\n      this.handleSelect = \n        SolrConfig.config.getBool( \"requestDispatcher/@handleSelect\", false ); \n      \n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n      core = SolrCore.getSolrCore();\n      parsers = new SolrRequestParsers( core, SolrConfig.config );\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    boolean abortOnConfigurationError = SolrConfig.config.getBool(\"abortOnConfigurationError\",true);\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      out.println( \"in solrconfig.xml\\n\" );\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6d6338c87060be5f66757a94945975f3bbd377a9","date":1189278234,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","sourceNew":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n    \n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      \n      // Let this filter take care of /select?xxx format\n      this.handleSelect = \n        SolrConfig.config.getBool( \"requestDispatcher/@handleSelect\", false ); \n      \n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n      core = SolrCore.getSolrCore();\n      parsers = new SolrRequestParsers( core );\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    boolean abortOnConfigurationError = SolrConfig.config.getBool(\"abortOnConfigurationError\",true);\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      out.println( \"in solrconfig.xml\\n\" );\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","sourceOld":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n    \n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      \n      // Let this filter take care of /select?xxx format\n      this.handleSelect = \n        SolrConfig.config.getBool( \"requestDispatcher/@handleSelect\", false ); \n      \n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n      core = SolrCore.getSolrCore();\n      parsers = new SolrRequestParsers( core, SolrConfig.config );\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    boolean abortOnConfigurationError = SolrConfig.config.getBool(\"abortOnConfigurationError\",true);\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      out.println( \"in solrconfig.xml\\n\" );\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e7f3c0b24404bb4616728261b4e610481671c921","date":1189312871,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","sourceNew":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n    \n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      \n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n      core = SolrCore.getSolrCore();\n      parsers = new SolrRequestParsers( core );\n\n      // Let this filter take care of /select?xxx format\n      this.handleSelect = \n        SolrConfig.config.getBool( \"requestDispatcher/@handleSelect\", false ); \n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    boolean abortOnConfigurationError = SolrConfig.config.getBool(\"abortOnConfigurationError\",true);\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      out.println( \"in solrconfig.xml\\n\" );\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","sourceOld":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n    \n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      \n      // Let this filter take care of /select?xxx format\n      this.handleSelect = \n        SolrConfig.config.getBool( \"requestDispatcher/@handleSelect\", false ); \n      \n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n      core = SolrCore.getSolrCore();\n      parsers = new SolrRequestParsers( core );\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    boolean abortOnConfigurationError = SolrConfig.config.getBool(\"abortOnConfigurationError\",true);\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      out.println( \"in solrconfig.xml\\n\" );\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8fe3c163c8df3fb3e4248c30f8ae8034cc786589","date":1189317596,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","sourceNew":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n    \n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      \n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n      core = SolrCore.getSolrCore();\n      parsers = new SolrRequestParsers( core );\n\n      // Let this filter take care of /select?xxx format\n      this.handleSelect = \n        core.getSolrConfig().getBool( \"requestDispatcher/@handleSelect\", false ); \n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    boolean abortOnConfigurationError = core.getSolrConfig().getBool(\"abortOnConfigurationError\",true);\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      out.println( \"in solrconfig.xml\\n\" );\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","sourceOld":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n    \n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      \n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n      core = SolrCore.getSolrCore();\n      parsers = new SolrRequestParsers( core );\n\n      // Let this filter take care of /select?xxx format\n      this.handleSelect = \n        SolrConfig.config.getBool( \"requestDispatcher/@handleSelect\", false ); \n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    boolean abortOnConfigurationError = SolrConfig.config.getBool(\"abortOnConfigurationError\",true);\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      out.println( \"in solrconfig.xml\\n\" );\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"abbfb3ad1f90df8ebf4751c8e72b2756ace50699","date":1190497478,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","sourceNew":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      \n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n      core = SolrCore.getSolrCore();\n      \n      // Read the configuration\n      Config solrConfig = core.getSolrConfig();\n\n      long uploadLimitKB = solrConfig.getInt( \n          \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2000 ); // 2MB default\n      \n      boolean enableRemoteStreams = solrConfig.getBool( \n          \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n\n      parsers = new SolrRequestParsers( enableRemoteStreams, uploadLimitKB );\n      \n      // Let this filter take care of /select?xxx format\n      this.handleSelect = solrConfig.getBool( \"requestDispatcher/@handleSelect\", false ); \n      \n      // should it keep going if we hit an error?\n      abortOnConfigurationError = solrConfig.getBool(\"abortOnConfigurationError\",true);\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      out.println( \"in solrconfig.xml\\n\" );\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","sourceOld":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n    \n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      \n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n      core = SolrCore.getSolrCore();\n      parsers = new SolrRequestParsers( core );\n\n      // Let this filter take care of /select?xxx format\n      this.handleSelect = \n        core.getSolrConfig().getBool( \"requestDispatcher/@handleSelect\", false ); \n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    boolean abortOnConfigurationError = core.getSolrConfig().getBool(\"abortOnConfigurationError\",true);\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      out.println( \"in solrconfig.xml\\n\" );\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","bugFix":null,"bugIntro":["1a45fbd60083428b1b13884c5c8c2e33e7e71ee7","cac08ebda61657f2bd130dc94173456fef381a30","cac08ebda61657f2bd130dc94173456fef381a30","cac08ebda61657f2bd130dc94173456fef381a30"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"048361614025800e582bfc7a7b0329dc6fd6a95e","date":1196999392,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","sourceNew":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      \n      // Find a valid solr core\n      SolrCore core = null;\n      multicore = MultiCore.getRegistry();\n      String instanceDir = SolrResourceLoader.locateInstanceDir();\n      File multiconfig = new File( instanceDir, \"multicore.xml\" );\n      log.info( \"looking for multicore.xml: \"+multiconfig.getAbsolutePath() );\n      if( multiconfig.exists() ) {\n        multicore.load( instanceDir, multiconfig );\n      }\n      if( multicore.isEnabled() ) {\n        core = multicore.getDefaultCore();\n        if( core == null ) {\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n              \"Multicore configuration does not include a default\" );\n        }\n        singlecore = null;\n      }\n      else {\n        singlecore = new SolrCore( null, null, new SolrConfig(), null );\n        core = singlecore;\n      }\n      \n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n      \n      // Read global configuration\n      // Only the first registerd core configures the following attributes \n      Config solrConfig = core.getSolrConfig();\n\n      long uploadLimitKB = solrConfig.getInt( \n          \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2000 ); // 2MB default\n      \n      boolean enableRemoteStreams = solrConfig.getBool( \n          \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n\n      parsers = new SolrRequestParsers( enableRemoteStreams, uploadLimitKB );\n      \n      // Let this filter take care of /select?xxx format\n      this.handleSelect = solrConfig.getBool( \"requestDispatcher/@handleSelect\", false ); \n      \n      // should it keep going if we hit an error?\n      abortOnConfigurationError = solrConfig.getBool(\"abortOnConfigurationError\",true);\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      out.println( \"in solrconfig.xml\\n\" );\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","sourceOld":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      \n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n      core = SolrCore.getSolrCore();\n      \n      // Read the configuration\n      Config solrConfig = core.getSolrConfig();\n\n      long uploadLimitKB = solrConfig.getInt( \n          \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2000 ); // 2MB default\n      \n      boolean enableRemoteStreams = solrConfig.getBool( \n          \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n\n      parsers = new SolrRequestParsers( enableRemoteStreams, uploadLimitKB );\n      \n      // Let this filter take care of /select?xxx format\n      this.handleSelect = solrConfig.getBool( \"requestDispatcher/@handleSelect\", false ); \n      \n      // should it keep going if we hit an error?\n      abortOnConfigurationError = solrConfig.getBool(\"abortOnConfigurationError\",true);\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      out.println( \"in solrconfig.xml\\n\" );\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","bugFix":null,"bugIntro":["1a45fbd60083428b1b13884c5c8c2e33e7e71ee7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1a45fbd60083428b1b13884c5c8c2e33e7e71ee7","date":1198275819,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","sourceNew":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      \n      // Find a valid solr core\n      SolrCore core = null;\n      multicore = MultiCore.getRegistry();\n      String instanceDir = SolrResourceLoader.locateInstanceDir();\n      File multiconfig = new File( instanceDir, \"multicore.xml\" );\n      log.info( \"looking for multicore.xml: \"+multiconfig.getAbsolutePath() );\n      if( multiconfig.exists() ) {\n        multicore.load( instanceDir, multiconfig );\n        core = multicore.getDefaultCore();\n      }\n      if( multicore.isEnabled() ) {\n        singlecore = null;\n      }\n      else {\n        singlecore = new SolrCore( null, null, new SolrConfig(), null );\n        core = singlecore;\n      }\n      \n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n      \n      // Read global configuration\n      // Only the first registered core configures the following attributes \n      Config globalConfig = core.getSolrConfig();\n\n      long uploadLimitKB = globalConfig.getInt( \n          \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2000 ); // 2MB default\n      \n      boolean enableRemoteStreams = globalConfig.getBool( \n          \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n\n      parsers = new SolrRequestParsers( enableRemoteStreams, uploadLimitKB );\n      \n      // Let this filter take care of /select?xxx format\n      this.handleSelect = globalConfig.getBool( \"requestDispatcher/@handleSelect\", false ); \n      \n      // should it keep going if we hit an error?\n      abortOnConfigurationError = globalConfig.getBool(\"abortOnConfigurationError\",true);\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      if( multicore.isEnabled() ) {\n        out.println( \"in multicore.xml\\n\" );\n      } \n      else {\n        out.println( \"in solrconfig.xml\\n\" );\n      }\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","sourceOld":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      \n      // Find a valid solr core\n      SolrCore core = null;\n      multicore = MultiCore.getRegistry();\n      String instanceDir = SolrResourceLoader.locateInstanceDir();\n      File multiconfig = new File( instanceDir, \"multicore.xml\" );\n      log.info( \"looking for multicore.xml: \"+multiconfig.getAbsolutePath() );\n      if( multiconfig.exists() ) {\n        multicore.load( instanceDir, multiconfig );\n      }\n      if( multicore.isEnabled() ) {\n        core = multicore.getDefaultCore();\n        if( core == null ) {\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n              \"Multicore configuration does not include a default\" );\n        }\n        singlecore = null;\n      }\n      else {\n        singlecore = new SolrCore( null, null, new SolrConfig(), null );\n        core = singlecore;\n      }\n      \n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n      \n      // Read global configuration\n      // Only the first registerd core configures the following attributes \n      Config solrConfig = core.getSolrConfig();\n\n      long uploadLimitKB = solrConfig.getInt( \n          \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2000 ); // 2MB default\n      \n      boolean enableRemoteStreams = solrConfig.getBool( \n          \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n\n      parsers = new SolrRequestParsers( enableRemoteStreams, uploadLimitKB );\n      \n      // Let this filter take care of /select?xxx format\n      this.handleSelect = solrConfig.getBool( \"requestDispatcher/@handleSelect\", false ); \n      \n      // should it keep going if we hit an error?\n      abortOnConfigurationError = solrConfig.getBool(\"abortOnConfigurationError\",true);\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      out.println( \"in solrconfig.xml\\n\" );\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","bugFix":["048361614025800e582bfc7a7b0329dc6fd6a95e","368c8927753a9ca6ee214a251da2746ff35aeef6","abbfb3ad1f90df8ebf4751c8e72b2756ace50699"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"67011996c84fe164cd5e78316d919154bcfed3f4","date":1198784196,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","sourceNew":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      \n      // Find a valid solr core\n      SolrCore core = null;\n      multicore = MultiCore.getRegistry();\n      String instanceDir = SolrResourceLoader.locateInstanceDir();\n      File multiconfig = new File( instanceDir, \"multicore.xml\" );\n      log.info( \"looking for multicore.xml: \"+multiconfig.getAbsolutePath() );\n      if( multiconfig.exists() ) {\n        multicore.load( instanceDir, multiconfig );\n        core = multicore.getDefaultCore();\n      }\n      if( multicore.isEnabled() ) {\n        singlecore = null;\n      }\n      else {\n        singlecore = new SolrCore( \"core\", null, new SolrConfig(), null );\n        core = singlecore;\n      }\n      \n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n      \n      // Read global configuration\n      // Only the first registered core configures the following attributes \n      Config globalConfig = core.getSolrConfig();\n\n      long uploadLimitKB = globalConfig.getInt( \n          \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2000 ); // 2MB default\n      \n      boolean enableRemoteStreams = globalConfig.getBool( \n          \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n\n      parsers = new SolrRequestParsers( enableRemoteStreams, uploadLimitKB );\n      \n      // Let this filter take care of /select?xxx format\n      this.handleSelect = globalConfig.getBool( \"requestDispatcher/@handleSelect\", false ); \n      \n      // should it keep going if we hit an error?\n      abortOnConfigurationError = globalConfig.getBool(\"abortOnConfigurationError\",true);\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      if( multicore.isEnabled() ) {\n        out.println( \"in multicore.xml\\n\" );\n      } \n      else {\n        out.println( \"in solrconfig.xml\\n\" );\n      }\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","sourceOld":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      \n      // Find a valid solr core\n      SolrCore core = null;\n      multicore = MultiCore.getRegistry();\n      String instanceDir = SolrResourceLoader.locateInstanceDir();\n      File multiconfig = new File( instanceDir, \"multicore.xml\" );\n      log.info( \"looking for multicore.xml: \"+multiconfig.getAbsolutePath() );\n      if( multiconfig.exists() ) {\n        multicore.load( instanceDir, multiconfig );\n        core = multicore.getDefaultCore();\n      }\n      if( multicore.isEnabled() ) {\n        singlecore = null;\n      }\n      else {\n        singlecore = new SolrCore( null, null, new SolrConfig(), null );\n        core = singlecore;\n      }\n      \n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n      \n      // Read global configuration\n      // Only the first registered core configures the following attributes \n      Config globalConfig = core.getSolrConfig();\n\n      long uploadLimitKB = globalConfig.getInt( \n          \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2000 ); // 2MB default\n      \n      boolean enableRemoteStreams = globalConfig.getBool( \n          \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n\n      parsers = new SolrRequestParsers( enableRemoteStreams, uploadLimitKB );\n      \n      // Let this filter take care of /select?xxx format\n      this.handleSelect = globalConfig.getBool( \"requestDispatcher/@handleSelect\", false ); \n      \n      // should it keep going if we hit an error?\n      abortOnConfigurationError = globalConfig.getBool(\"abortOnConfigurationError\",true);\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      if( multicore.isEnabled() ) {\n        out.println( \"in multicore.xml\\n\" );\n      } \n      else {\n        out.println( \"in solrconfig.xml\\n\" );\n      }\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b46f0ccfb6b63c307ea901d48482630e3689042c","date":1198805331,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","sourceNew":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      \n      // Find a valid solr core\n      SolrCore core = null;\n      multicore = MultiCore.getRegistry();\n      String instanceDir = SolrResourceLoader.locateInstanceDir();\n      File multiconfig = new File( instanceDir, \"multicore.xml\" );\n      log.info( \"looking for multicore.xml: \"+multiconfig.getAbsolutePath() );\n      if( multiconfig.exists() ) {\n        multicore.load( instanceDir, multiconfig );\n        core = multicore.getDefaultCore();\n      }\n      if( multicore.isEnabled() ) {\n        singlecore = null;\n      }\n      else {\n        singlecore = new SolrCore( null, null, new SolrConfig(), null );\n        core = singlecore;\n      }\n      \n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n      \n      // Read global configuration\n      // Only the first registered core configures the following attributes \n      Config globalConfig = core.getSolrConfig();\n\n      long uploadLimitKB = globalConfig.getInt( \n          \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2000 ); // 2MB default\n      \n      boolean enableRemoteStreams = globalConfig.getBool( \n          \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n\n      parsers = new SolrRequestParsers( enableRemoteStreams, uploadLimitKB );\n      \n      // Let this filter take care of /select?xxx format\n      this.handleSelect = globalConfig.getBool( \"requestDispatcher/@handleSelect\", false ); \n      \n      // should it keep going if we hit an error?\n      abortOnConfigurationError = globalConfig.getBool(\"abortOnConfigurationError\",true);\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      if( multicore.isEnabled() ) {\n        out.println( \"in multicore.xml\\n\" );\n      } \n      else {\n        out.println( \"in solrconfig.xml\\n\" );\n      }\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","sourceOld":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      \n      // Find a valid solr core\n      SolrCore core = null;\n      multicore = MultiCore.getRegistry();\n      String instanceDir = SolrResourceLoader.locateInstanceDir();\n      File multiconfig = new File( instanceDir, \"multicore.xml\" );\n      log.info( \"looking for multicore.xml: \"+multiconfig.getAbsolutePath() );\n      if( multiconfig.exists() ) {\n        multicore.load( instanceDir, multiconfig );\n        core = multicore.getDefaultCore();\n      }\n      if( multicore.isEnabled() ) {\n        singlecore = null;\n      }\n      else {\n        singlecore = new SolrCore( \"core\", null, new SolrConfig(), null );\n        core = singlecore;\n      }\n      \n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n      \n      // Read global configuration\n      // Only the first registered core configures the following attributes \n      Config globalConfig = core.getSolrConfig();\n\n      long uploadLimitKB = globalConfig.getInt( \n          \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2000 ); // 2MB default\n      \n      boolean enableRemoteStreams = globalConfig.getBool( \n          \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n\n      parsers = new SolrRequestParsers( enableRemoteStreams, uploadLimitKB );\n      \n      // Let this filter take care of /select?xxx format\n      this.handleSelect = globalConfig.getBool( \"requestDispatcher/@handleSelect\", false ); \n      \n      // should it keep going if we hit an error?\n      abortOnConfigurationError = globalConfig.getBool(\"abortOnConfigurationError\",true);\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      if( multicore.isEnabled() ) {\n        out.println( \"in multicore.xml\\n\" );\n      } \n      else {\n        out.println( \"in solrconfig.xml\\n\" );\n      }\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"47be907237431a2c75792932d56b79e4781ee1b1","date":1200322345,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","sourceNew":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      \n      // Find a valid solr core\n      SolrCore core = null;\n      multicore = MultiCore.getRegistry();\n      if( multicore.isEnabled() ) {\n        log.info( \"Using existing multicore configuration\" );\n      }\n      else {\n        String instanceDir = SolrResourceLoader.locateInstanceDir();\n        File multiconfig = new File( instanceDir, \"multicore.xml\" );\n        log.info( \"looking for multicore.xml: \"+multiconfig.getAbsolutePath() );\n        if( multiconfig.exists() ) {\n          multicore.load( instanceDir, multiconfig );\n        }\n      }\n      if( multicore.isEnabled() ) {\n        singlecore = null;\n        core = multicore.getDefaultCore();\n      }\n      else {\n        singlecore = new SolrCore( null, null, new SolrConfig(), null );\n        core = singlecore;\n      }\n      \n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n      \n      // Read global configuration\n      // Only the first registered core configures the following attributes \n      Config globalConfig = core.getSolrConfig();\n\n      long uploadLimitKB = globalConfig.getInt( \n          \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2000 ); // 2MB default\n      \n      boolean enableRemoteStreams = globalConfig.getBool( \n          \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n\n      parsers = new SolrRequestParsers( enableRemoteStreams, uploadLimitKB );\n      \n      // Let this filter take care of /select?xxx format\n      this.handleSelect = globalConfig.getBool( \"requestDispatcher/@handleSelect\", false ); \n      \n      // should it keep going if we hit an error?\n      abortOnConfigurationError = globalConfig.getBool(\"abortOnConfigurationError\",true);\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      if( multicore.isEnabled() ) {\n        out.println( \"in multicore.xml\\n\" );\n      } \n      else {\n        out.println( \"in solrconfig.xml\\n\" );\n      }\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","sourceOld":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      \n      // Find a valid solr core\n      SolrCore core = null;\n      multicore = MultiCore.getRegistry();\n      String instanceDir = SolrResourceLoader.locateInstanceDir();\n      File multiconfig = new File( instanceDir, \"multicore.xml\" );\n      log.info( \"looking for multicore.xml: \"+multiconfig.getAbsolutePath() );\n      if( multiconfig.exists() ) {\n        multicore.load( instanceDir, multiconfig );\n        core = multicore.getDefaultCore();\n      }\n      if( multicore.isEnabled() ) {\n        singlecore = null;\n      }\n      else {\n        singlecore = new SolrCore( null, null, new SolrConfig(), null );\n        core = singlecore;\n      }\n      \n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n      \n      // Read global configuration\n      // Only the first registered core configures the following attributes \n      Config globalConfig = core.getSolrConfig();\n\n      long uploadLimitKB = globalConfig.getInt( \n          \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2000 ); // 2MB default\n      \n      boolean enableRemoteStreams = globalConfig.getBool( \n          \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n\n      parsers = new SolrRequestParsers( enableRemoteStreams, uploadLimitKB );\n      \n      // Let this filter take care of /select?xxx format\n      this.handleSelect = globalConfig.getBool( \"requestDispatcher/@handleSelect\", false ); \n      \n      // should it keep going if we hit an error?\n      abortOnConfigurationError = globalConfig.getBool(\"abortOnConfigurationError\",true);\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      if( multicore.isEnabled() ) {\n        out.println( \"in multicore.xml\\n\" );\n      } \n      else {\n        out.println( \"in solrconfig.xml\\n\" );\n      }\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b920ba0b6285c3aaa7a64d1677f5b4ee58b0779d","date":1203633859,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","sourceNew":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      this.solrConfigFilename = config.getInitParameter(\"solrconfig-filename\");\n      \n      // Find a valid solr core\n      SolrCore core = null;\n      multicore = MultiCore.getRegistry();\n      if( multicore.isEnabled() ) {\n        log.info( \"Using existing multicore configuration\" );\n      }\n      else {\n        String instanceDir = SolrResourceLoader.locateInstanceDir();\n        File multiconfig = new File( instanceDir, \"multicore.xml\" );\n        log.info( \"looking for multicore.xml: \"+multiconfig.getAbsolutePath() );\n        if( multiconfig.exists() ) {\n          multicore.load( instanceDir, multiconfig );\n        }\n      }\n      if( multicore.isEnabled() ) {\n        singlecore = null;\n        core = multicore.getDefaultCore();\n      }\n      else {\n        if (this.solrConfigFilename==null) {\n          singlecore = new SolrCore( null, null, new SolrConfig(), null );\n        } else {\n          singlecore = new SolrCore( null, null, new SolrConfig(this.solrConfigFilename), null);\n        }\n        core = singlecore;\n      }\n      \n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n      \n      // Read global configuration\n      // Only the first registered core configures the following attributes \n      Config globalConfig = core.getSolrConfig();\n\n      long uploadLimitKB = globalConfig.getInt( \n          \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2000 ); // 2MB default\n      \n      boolean enableRemoteStreams = globalConfig.getBool( \n          \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n\n      parsers = new SolrRequestParsers( enableRemoteStreams, uploadLimitKB );\n      \n      // Let this filter take care of /select?xxx format\n      this.handleSelect = globalConfig.getBool( \"requestDispatcher/@handleSelect\", false ); \n      \n      // should it keep going if we hit an error?\n      abortOnConfigurationError = globalConfig.getBool(\"abortOnConfigurationError\",true);\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      if( multicore.isEnabled() ) {\n        out.println( \"in multicore.xml\\n\" );\n      } \n      else {\n        out.println( \"in solrconfig.xml\\n\" );\n      }\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","sourceOld":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      \n      // Find a valid solr core\n      SolrCore core = null;\n      multicore = MultiCore.getRegistry();\n      if( multicore.isEnabled() ) {\n        log.info( \"Using existing multicore configuration\" );\n      }\n      else {\n        String instanceDir = SolrResourceLoader.locateInstanceDir();\n        File multiconfig = new File( instanceDir, \"multicore.xml\" );\n        log.info( \"looking for multicore.xml: \"+multiconfig.getAbsolutePath() );\n        if( multiconfig.exists() ) {\n          multicore.load( instanceDir, multiconfig );\n        }\n      }\n      if( multicore.isEnabled() ) {\n        singlecore = null;\n        core = multicore.getDefaultCore();\n      }\n      else {\n        singlecore = new SolrCore( null, null, new SolrConfig(), null );\n        core = singlecore;\n      }\n      \n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n      \n      // Read global configuration\n      // Only the first registered core configures the following attributes \n      Config globalConfig = core.getSolrConfig();\n\n      long uploadLimitKB = globalConfig.getInt( \n          \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2000 ); // 2MB default\n      \n      boolean enableRemoteStreams = globalConfig.getBool( \n          \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n\n      parsers = new SolrRequestParsers( enableRemoteStreams, uploadLimitKB );\n      \n      // Let this filter take care of /select?xxx format\n      this.handleSelect = globalConfig.getBool( \"requestDispatcher/@handleSelect\", false ); \n      \n      // should it keep going if we hit an error?\n      abortOnConfigurationError = globalConfig.getBool(\"abortOnConfigurationError\",true);\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      if( multicore.isEnabled() ) {\n        out.println( \"in multicore.xml\\n\" );\n      } \n      else {\n        out.println( \"in solrconfig.xml\\n\" );\n      }\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6dc6ab6902f8f70ae43365947ccf44c25986906d","date":1204603577,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","sourceNew":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      this.solrConfigFilename = config.getInitParameter(\"solrconfig-filename\");\n      \n      multicore = MultiCore.getRegistry();\n      if( multicore.isEnabled() ) {\n        log.info( \"Using existing multicore configuration\" );\n      }\n      else {\n        String instanceDir = SolrResourceLoader.locateInstanceDir();\n        File multiconfig = new File( instanceDir, \"multicore.xml\" );\n        log.info( \"looking for multicore.xml: \"+multiconfig.getAbsolutePath() );\n        if( multiconfig.exists() ) {\n          multicore.load( instanceDir, multiconfig );\n        }\n      }\n      \n      abortOnConfigurationError = false;\n      if( multicore.isEnabled() ) {\n        singlecore = null;\n        \n        // if any core aborts on startup, then abort\n        for( SolrCore c : multicore.getCores() ) {\n          if( c.getSolrConfig().getBool( \"abortOnConfigurationError\",false) ) {\n            abortOnConfigurationError = true;\n            break;\n          }\n        }\n      }\n      else {\n        if (this.solrConfigFilename==null) {\n          singlecore = new SolrCore( null, null, new SolrConfig(), null );\n        } else {\n          singlecore = new SolrCore( null, null, new SolrConfig(this.solrConfigFilename), null);\n        }\n      }\n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      if( multicore.isEnabled() ) {\n        out.println( \"in multicore.xml\\n\" );\n      } \n      else {\n        out.println( \"in solrconfig.xml\\n\" );\n      }\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","sourceOld":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      this.solrConfigFilename = config.getInitParameter(\"solrconfig-filename\");\n      \n      // Find a valid solr core\n      SolrCore core = null;\n      multicore = MultiCore.getRegistry();\n      if( multicore.isEnabled() ) {\n        log.info( \"Using existing multicore configuration\" );\n      }\n      else {\n        String instanceDir = SolrResourceLoader.locateInstanceDir();\n        File multiconfig = new File( instanceDir, \"multicore.xml\" );\n        log.info( \"looking for multicore.xml: \"+multiconfig.getAbsolutePath() );\n        if( multiconfig.exists() ) {\n          multicore.load( instanceDir, multiconfig );\n        }\n      }\n      if( multicore.isEnabled() ) {\n        singlecore = null;\n        core = multicore.getDefaultCore();\n      }\n      else {\n        if (this.solrConfigFilename==null) {\n          singlecore = new SolrCore( null, null, new SolrConfig(), null );\n        } else {\n          singlecore = new SolrCore( null, null, new SolrConfig(this.solrConfigFilename), null);\n        }\n        core = singlecore;\n      }\n      \n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n      \n      // Read global configuration\n      // Only the first registered core configures the following attributes \n      Config globalConfig = core.getSolrConfig();\n\n      long uploadLimitKB = globalConfig.getInt( \n          \"requestDispatcher/requestParsers/@multipartUploadLimitInKB\", 2000 ); // 2MB default\n      \n      boolean enableRemoteStreams = globalConfig.getBool( \n          \"requestDispatcher/requestParsers/@enableRemoteStreaming\", false ); \n\n      parsers = new SolrRequestParsers( enableRemoteStreams, uploadLimitKB );\n      \n      // Let this filter take care of /select?xxx format\n      this.handleSelect = globalConfig.getBool( \"requestDispatcher/@handleSelect\", false ); \n      \n      // should it keep going if we hit an error?\n      abortOnConfigurationError = globalConfig.getBool(\"abortOnConfigurationError\",true);\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      if( multicore.isEnabled() ) {\n        out.println( \"in multicore.xml\\n\" );\n      } \n      else {\n        out.println( \"in solrconfig.xml\\n\" );\n      }\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"58b41d4093a9662306bdc051e4b46643deff70de","date":1205090944,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","sourceNew":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      this.solrConfigFilename = config.getInitParameter(\"solrconfig-filename\");\n      \n      // multicore instantiation\n      this.multicore = initMultiCore(config);\n      \n      if(multicore != null && multicore.isEnabled() ) {\n      abortOnConfigurationError = false;\n        singlecore = null;\n        // if any core aborts on startup, then abort\n        for( SolrCore c : multicore.getCores() ) {\n          if( c.getSolrConfig().getBool( \"abortOnConfigurationError\",false) ) {\n            abortOnConfigurationError = true;\n            break;\n          }\n        }\n      }\n      else {\n        SolrConfig cfg = this.solrConfigFilename == null? new SolrConfig() : new SolrConfig(this.solrConfigFilename);\n        singlecore = new SolrCore( null, null, cfg, null );\n        abortOnConfigurationError = cfg.getBool(\n                \"abortOnConfigurationError\", abortOnConfigurationError);\n      }\n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      if (multicore != null && multicore.isEnabled()) {\n        out.println( \"in multicore.xml\\n\" );\n      } else {\n        out.println( \"in solrconfig.xml\\n\" );\n      }\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","sourceOld":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      this.solrConfigFilename = config.getInitParameter(\"solrconfig-filename\");\n      \n      multicore = MultiCore.getRegistry();\n      if( multicore.isEnabled() ) {\n        log.info( \"Using existing multicore configuration\" );\n      }\n      else {\n        String instanceDir = SolrResourceLoader.locateInstanceDir();\n        File multiconfig = new File( instanceDir, \"multicore.xml\" );\n        log.info( \"looking for multicore.xml: \"+multiconfig.getAbsolutePath() );\n        if( multiconfig.exists() ) {\n          multicore.load( instanceDir, multiconfig );\n        }\n      }\n      \n      abortOnConfigurationError = false;\n      if( multicore.isEnabled() ) {\n        singlecore = null;\n        \n        // if any core aborts on startup, then abort\n        for( SolrCore c : multicore.getCores() ) {\n          if( c.getSolrConfig().getBool( \"abortOnConfigurationError\",false) ) {\n            abortOnConfigurationError = true;\n            break;\n          }\n        }\n      }\n      else {\n        if (this.solrConfigFilename==null) {\n          singlecore = new SolrCore( null, null, new SolrConfig(), null );\n        } else {\n          singlecore = new SolrCore( null, null, new SolrConfig(this.solrConfigFilename), null);\n        }\n      }\n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      if( multicore.isEnabled() ) {\n        out.println( \"in multicore.xml\\n\" );\n      } \n      else {\n        out.println( \"in solrconfig.xml\\n\" );\n      }\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4a46cae2a2f75e7ff129d40effceea9918b450a5","date":1206457283,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","sourceNew":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      this.solrConfigFilename = config.getInitParameter(\"solrconfig-filename\");\n      \n      // multicore instantiation\n      this.multicore = initMultiCore(config);\n      \n      if(multicore != null && multicore.isEnabled() ) {\n        abortOnConfigurationError = false;\n        singlecore = null;\n        // if any core aborts on startup, then abort\n        for( SolrCore c : multicore.getCores() ) {\n          if( c.getSolrConfig().getBool( \"abortOnConfigurationError\",false) ) {\n            abortOnConfigurationError = true;\n            break;\n          }\n        }\n      }\n      else {\n        SolrConfig cfg = this.solrConfigFilename == null? new SolrConfig() : new SolrConfig(this.solrConfigFilename);\n        singlecore = new SolrCore( null, null, cfg, null );\n        abortOnConfigurationError = cfg.getBool(\n                \"abortOnConfigurationError\", abortOnConfigurationError);\n      }\n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      if (multicore != null && multicore.isEnabled()) {\n        out.println( \"in multicore.xml\\n\" );\n      } else {\n        out.println( \"in solrconfig.xml\\n\" );\n      }\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","sourceOld":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      this.solrConfigFilename = config.getInitParameter(\"solrconfig-filename\");\n      \n      // multicore instantiation\n      this.multicore = initMultiCore(config);\n      \n      if(multicore != null && multicore.isEnabled() ) {\n      abortOnConfigurationError = false;\n        singlecore = null;\n        // if any core aborts on startup, then abort\n        for( SolrCore c : multicore.getCores() ) {\n          if( c.getSolrConfig().getBool( \"abortOnConfigurationError\",false) ) {\n            abortOnConfigurationError = true;\n            break;\n          }\n        }\n      }\n      else {\n        SolrConfig cfg = this.solrConfigFilename == null? new SolrConfig() : new SolrConfig(this.solrConfigFilename);\n        singlecore = new SolrCore( null, null, cfg, null );\n        abortOnConfigurationError = cfg.getBool(\n                \"abortOnConfigurationError\", abortOnConfigurationError);\n      }\n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      if (multicore != null && multicore.isEnabled()) {\n        out.println( \"in multicore.xml\\n\" );\n      } else {\n        out.println( \"in solrconfig.xml\\n\" );\n      }\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae248910a22eb7d1b6bd9ade7f9a33dfc0506f0c","date":1208435858,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","sourceNew":"  public void init(FilterConfig config) throws ServletException\n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      this.solrConfigFilename = config.getInitParameter(\"solrconfig-filename\");\n\n      // multicore instantiation\n      this.multicore = initMultiCore(config);\n\n      if(multicore != null && multicore.isEnabled() ) {\n        abortOnConfigurationError = false;\n        singlecore = null;\n        // if any core aborts on startup, then abort\n        for( SolrCore c : multicore.getCores() ) {\n          if( c.getSolrConfig().getBool( \"abortOnConfigurationError\",false) ) {\n            abortOnConfigurationError = true;\n            break;\n          }\n        }\n      }\n      else {\n        SolrConfig cfg = this.solrConfigFilename == null? new SolrConfig() : new SolrConfig(this.solrConfigFilename);\n        singlecore = new SolrCore( null, null, cfg, null );\n        abortOnConfigurationError = cfg.getBool(\n                \"abortOnConfigurationError\", abortOnConfigurationError);\n      }\n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n\n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      if (multicore != null && multicore.isEnabled()) {\n        out.println( \"in multicore.xml\\n\" );\n      } else {\n        out.println( \"in solrconfig.xml\\n\" );\n      }\n\n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n\n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n\n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","sourceOld":"  public void init(FilterConfig config) throws ServletException \n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      this.solrConfigFilename = config.getInitParameter(\"solrconfig-filename\");\n      \n      // multicore instantiation\n      this.multicore = initMultiCore(config);\n      \n      if(multicore != null && multicore.isEnabled() ) {\n        abortOnConfigurationError = false;\n        singlecore = null;\n        // if any core aborts on startup, then abort\n        for( SolrCore c : multicore.getCores() ) {\n          if( c.getSolrConfig().getBool( \"abortOnConfigurationError\",false) ) {\n            abortOnConfigurationError = true;\n            break;\n          }\n        }\n      }\n      else {\n        SolrConfig cfg = this.solrConfigFilename == null? new SolrConfig() : new SolrConfig(this.solrConfigFilename);\n        singlecore = new SolrCore( null, null, cfg, null );\n        abortOnConfigurationError = cfg.getBool(\n                \"abortOnConfigurationError\", abortOnConfigurationError);\n      }\n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n    \n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      if (multicore != null && multicore.isEnabled()) {\n        out.println( \"in multicore.xml\\n\" );\n      } else {\n        out.println( \"in solrconfig.xml\\n\" );\n      }\n      \n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n      \n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n    \n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","bugFix":null,"bugIntro":["0aea57ab530d174e645bf6e14d04db1e243e13d7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d5151046764fb8d9662e02d6c5381b2adb69f96d","date":1216394962,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","sourceNew":"  public void init(FilterConfig config) throws ServletException\n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      this.solrConfigFilename = config.getInitParameter(\"solrconfig-filename\");\n\n      // multicore instantiation\n      this.multicore = initMultiCore(config);\n\n      if(multicore != null && multicore.isEnabled() ) {\n        abortOnConfigurationError = false;\n        singleCoreDescriptor = null;\n        // if any core aborts on startup, then abort\n        for( SolrCore c : multicore.getCores() ) {\n          if( c.getSolrConfig().getBool( \"abortOnConfigurationError\",false) ) {\n            abortOnConfigurationError = true;\n            break;\n          }\n        }\n      }\n      else {\n        SolrConfig cfg = this.solrConfigFilename == null? new SolrConfig() : new SolrConfig(this.solrConfigFilename);\n        singleCoreDescriptor = new CoreDescriptor((MultiCore)null);\n        singleCoreDescriptor.init(\"\",cfg.getResourceLoader().getInstanceDir());\n        SolrCore singlecore = new SolrCore( null, null, cfg, null, singleCoreDescriptor);\n        singleCoreDescriptor.setCore(singlecore);\n        abortOnConfigurationError = cfg.getBool(\n                \"abortOnConfigurationError\", abortOnConfigurationError);\n      }\n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n\n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      if (multicore != null && multicore.isEnabled()) {\n        out.println( \"in multicore.xml\\n\" );\n      } else {\n        out.println( \"in solrconfig.xml\\n\" );\n      }\n\n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n\n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n\n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","sourceOld":"  public void init(FilterConfig config) throws ServletException\n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      this.solrConfigFilename = config.getInitParameter(\"solrconfig-filename\");\n\n      // multicore instantiation\n      this.multicore = initMultiCore(config);\n\n      if(multicore != null && multicore.isEnabled() ) {\n        abortOnConfigurationError = false;\n        singlecore = null;\n        // if any core aborts on startup, then abort\n        for( SolrCore c : multicore.getCores() ) {\n          if( c.getSolrConfig().getBool( \"abortOnConfigurationError\",false) ) {\n            abortOnConfigurationError = true;\n            break;\n          }\n        }\n      }\n      else {\n        SolrConfig cfg = this.solrConfigFilename == null? new SolrConfig() : new SolrConfig(this.solrConfigFilename);\n        singlecore = new SolrCore( null, null, cfg, null );\n        abortOnConfigurationError = cfg.getBool(\n                \"abortOnConfigurationError\", abortOnConfigurationError);\n      }\n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n\n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      if (multicore != null && multicore.isEnabled()) {\n        out.println( \"in multicore.xml\\n\" );\n      } else {\n        out.println( \"in solrconfig.xml\\n\" );\n      }\n\n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n\n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n\n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d262ab35a1389f4ad912bfa8b61a202c61cc475a","date":1218563685,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","sourceNew":"  public void init(FilterConfig config) throws ServletException\n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      this.solrConfigFilename = config.getInitParameter(\"solrconfig-filename\");\n\n      // multicore instantiation\n      this.multicore = initMultiCore(config);\n\n      if(multicore != null && multicore.isEnabled() ) {\n        abortOnConfigurationError = false;\n        singleCoreDescriptor = null;\n        // if any core aborts on startup, then abort\n        for( SolrCore c : multicore.getCores() ) {\n          if( c.getSolrConfig().getBool( \"abortOnConfigurationError\",false) ) {\n            abortOnConfigurationError = true;\n            break;\n          }\n        }\n      }\n      else {\n        SolrConfig cfg = this.solrConfigFilename == null? new SolrConfig() : new SolrConfig(this.solrConfigFilename);\n        singleCoreDescriptor = new CoreDescriptor((MultiCore)null);\n        singleCoreDescriptor.init(\"\",cfg.getResourceLoader().getInstanceDir());\n        SolrCore singlecore = new SolrCore( null, null, cfg, null, singleCoreDescriptor);\n        singleCoreDescriptor.setCore(singlecore);\n        abortOnConfigurationError = cfg.getBool(\n                \"abortOnConfigurationError\", abortOnConfigurationError);\n      }\n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n\n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      if (multicore != null && multicore.isEnabled()) {\n        out.println( \"in solr.xml\\n\" );\n      } else {\n        out.println( \"in solrconfig.xml\\n\" );\n      }\n\n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n\n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n\n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","sourceOld":"  public void init(FilterConfig config) throws ServletException\n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      this.solrConfigFilename = config.getInitParameter(\"solrconfig-filename\");\n\n      // multicore instantiation\n      this.multicore = initMultiCore(config);\n\n      if(multicore != null && multicore.isEnabled() ) {\n        abortOnConfigurationError = false;\n        singleCoreDescriptor = null;\n        // if any core aborts on startup, then abort\n        for( SolrCore c : multicore.getCores() ) {\n          if( c.getSolrConfig().getBool( \"abortOnConfigurationError\",false) ) {\n            abortOnConfigurationError = true;\n            break;\n          }\n        }\n      }\n      else {\n        SolrConfig cfg = this.solrConfigFilename == null? new SolrConfig() : new SolrConfig(this.solrConfigFilename);\n        singleCoreDescriptor = new CoreDescriptor((MultiCore)null);\n        singleCoreDescriptor.init(\"\",cfg.getResourceLoader().getInstanceDir());\n        SolrCore singlecore = new SolrCore( null, null, cfg, null, singleCoreDescriptor);\n        singleCoreDescriptor.setCore(singlecore);\n        abortOnConfigurationError = cfg.getBool(\n                \"abortOnConfigurationError\", abortOnConfigurationError);\n      }\n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n\n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      if (multicore != null && multicore.isEnabled()) {\n        out.println( \"in multicore.xml\\n\" );\n      } else {\n        out.println( \"in solrconfig.xml\\n\" );\n      }\n\n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n\n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n\n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9c74b2e17824ac88cefd4b764b4b9f2c56ceeea5","date":1218639440,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","sourceNew":"  public void init(FilterConfig config) throws ServletException\n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      this.solrConfigFilename = config.getInitParameter(\"solrconfig-filename\");\n\n      // cores instantiation\n      this.cores = initMultiCore(config);\n\n      if(cores != null && cores.isEnabled() ) {\n        abortOnConfigurationError = false;\n        singleCoreDescriptor = null;\n        // if any core aborts on startup, then abort\n        for( SolrCore c : cores.getCores() ) {\n          if( c.getSolrConfig().getBool( \"abortOnConfigurationError\",false) ) {\n            abortOnConfigurationError = true;\n            break;\n          }\n        }\n      }\n      else {\n        SolrConfig cfg = this.solrConfigFilename == null? new SolrConfig() : new SolrConfig(this.solrConfigFilename);\n        singleCoreDescriptor = new CoreDescriptor((CoreContainer)null);\n        singleCoreDescriptor.init(\"\",cfg.getResourceLoader().getInstanceDir());\n        SolrCore singlecore = new SolrCore( null, null, cfg, null, singleCoreDescriptor);\n        singleCoreDescriptor.setCore(singlecore);\n        abortOnConfigurationError = cfg.getBool(\n                \"abortOnConfigurationError\", abortOnConfigurationError);\n      }\n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n\n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      if (cores != null && cores.isEnabled()) {\n        out.println( \"in solr.xml\\n\" );\n      } else {\n        out.println( \"in solrconfig.xml\\n\" );\n      }\n\n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n\n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n\n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","sourceOld":"  public void init(FilterConfig config) throws ServletException\n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      this.solrConfigFilename = config.getInitParameter(\"solrconfig-filename\");\n\n      // multicore instantiation\n      this.multicore = initMultiCore(config);\n\n      if(multicore != null && multicore.isEnabled() ) {\n        abortOnConfigurationError = false;\n        singleCoreDescriptor = null;\n        // if any core aborts on startup, then abort\n        for( SolrCore c : multicore.getCores() ) {\n          if( c.getSolrConfig().getBool( \"abortOnConfigurationError\",false) ) {\n            abortOnConfigurationError = true;\n            break;\n          }\n        }\n      }\n      else {\n        SolrConfig cfg = this.solrConfigFilename == null? new SolrConfig() : new SolrConfig(this.solrConfigFilename);\n        singleCoreDescriptor = new CoreDescriptor((MultiCore)null);\n        singleCoreDescriptor.init(\"\",cfg.getResourceLoader().getInstanceDir());\n        SolrCore singlecore = new SolrCore( null, null, cfg, null, singleCoreDescriptor);\n        singleCoreDescriptor.setCore(singlecore);\n        abortOnConfigurationError = cfg.getBool(\n                \"abortOnConfigurationError\", abortOnConfigurationError);\n      }\n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n\n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      if (multicore != null && multicore.isEnabled()) {\n        out.println( \"in solr.xml\\n\" );\n      } else {\n        out.println( \"in solrconfig.xml\\n\" );\n      }\n\n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n\n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n\n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4926b5318ba4167d360445a0c5f3fc8af2cf8c49","date":1218678599,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","sourceNew":"  public void init(FilterConfig config) throws ServletException\n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    CoreContainer.Initializer init = createInitializer();\n    try {\n      // web.xml configuration\n      init.setPathPrefix(config.getInitParameter( \"path-prefix\" ));\n      init.setSolrConfigFilename(config.getInitParameter(\"solrconfig-filename\"));\n\n      this.cores = init.initialize();\n      abortOnConfigurationError = init.isAbortOnConfigurationError();\n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n\n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      out.println( \"in \"+init.getSolrConfigFilename()+\"\\n\" );\n\n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n\n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n\n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","sourceOld":"  public void init(FilterConfig config) throws ServletException\n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      this.solrConfigFilename = config.getInitParameter(\"solrconfig-filename\");\n\n      // cores instantiation\n      this.cores = initMultiCore(config);\n\n      if(cores != null && cores.isEnabled() ) {\n        abortOnConfigurationError = false;\n        singleCoreDescriptor = null;\n        // if any core aborts on startup, then abort\n        for( SolrCore c : cores.getCores() ) {\n          if( c.getSolrConfig().getBool( \"abortOnConfigurationError\",false) ) {\n            abortOnConfigurationError = true;\n            break;\n          }\n        }\n      }\n      else {\n        SolrConfig cfg = this.solrConfigFilename == null? new SolrConfig() : new SolrConfig(this.solrConfigFilename);\n        singleCoreDescriptor = new CoreDescriptor((CoreContainer)null);\n        singleCoreDescriptor.init(\"\",cfg.getResourceLoader().getInstanceDir());\n        SolrCore singlecore = new SolrCore( null, null, cfg, null, singleCoreDescriptor);\n        singleCoreDescriptor.setCore(singlecore);\n        abortOnConfigurationError = cfg.getBool(\n                \"abortOnConfigurationError\", abortOnConfigurationError);\n      }\n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n\n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      if (cores != null && cores.isEnabled()) {\n        out.println( \"in solr.xml\\n\" );\n      } else {\n        out.println( \"in solrconfig.xml\\n\" );\n      }\n\n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n\n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n\n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","bugFix":null,"bugIntro":["0aea57ab530d174e645bf6e14d04db1e243e13d7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"28b4df89ecd7e44172951ebd60d638c2b1d8e146","date":1218762931,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","sourceNew":"  public void init(FilterConfig config) throws ServletException\n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    CoreContainer.Initializer init = createInitializer();\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      init.setSolrConfigFilename(config.getInitParameter(\"solrconfig-filename\"));\n\n      this.cores = init.initialize();\n      abortOnConfigurationError = init.isAbortOnConfigurationError();\n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n\n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      out.println( \"in \"+init.getSolrConfigFilename()+\"\\n\" );\n\n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n\n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n\n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","sourceOld":"  public void init(FilterConfig config) throws ServletException\n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    CoreContainer.Initializer init = createInitializer();\n    try {\n      // web.xml configuration\n      init.setPathPrefix(config.getInitParameter( \"path-prefix\" ));\n      init.setSolrConfigFilename(config.getInitParameter(\"solrconfig-filename\"));\n\n      this.cores = init.initialize();\n      abortOnConfigurationError = init.isAbortOnConfigurationError();\n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n\n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      out.println( \"in \"+init.getSolrConfigFilename()+\"\\n\" );\n\n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n\n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n\n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"00da8b51bdeae168a5b26ec506db372b219ca7a2","date":1221704186,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","sourceNew":"  public void init(FilterConfig config) throws ServletException\n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    CoreContainer.Initializer init = createInitializer();\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      init.setSolrConfigFilename(config.getInitParameter(\"solrconfig-filename\"));\n\n      this.cores = init.initialize();\n      abortOnConfigurationError = init.isAbortOnConfigurationError();\n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.error( \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n\n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      out.println( \"in \"+init.getSolrConfigFilename()+\"\\n\" );\n\n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n\n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n\n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","sourceOld":"  public void init(FilterConfig config) throws ServletException\n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    CoreContainer.Initializer init = createInitializer();\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      init.setSolrConfigFilename(config.getInitParameter(\"solrconfig-filename\"));\n\n      this.cores = init.initialize();\n      abortOnConfigurationError = init.isAbortOnConfigurationError();\n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.log(Level.SEVERE, \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n\n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      out.println( \"in \"+init.getSolrConfigFilename()+\"\\n\" );\n\n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n\n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n\n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"87c63be0728f8f147d7e19ec9c514fd2c8f01907","date":1266867951,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","sourceNew":"  public void init(FilterConfig config) throws ServletException\n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    CoreContainer.Initializer init = createInitializer();\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      init.setSolrConfigFilename(config.getInitParameter(\"solrconfig-filename\"));\n\n      this.cores = init.initialize();\n      abortOnConfigurationError = init.isAbortOnConfigurationError();\n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.error( \"Could not start Solr. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n\n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      out.println( \"in \"+init.getSolrConfigFilename()+\"\\n\" );\n\n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n\n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n\n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","sourceOld":"  public void init(FilterConfig config) throws ServletException\n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    CoreContainer.Initializer init = createInitializer();\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      init.setSolrConfigFilename(config.getInitParameter(\"solrconfig-filename\"));\n\n      this.cores = init.initialize();\n      abortOnConfigurationError = init.isAbortOnConfigurationError();\n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.error( \"Could not start SOLR. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n\n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      out.println( \"in \"+init.getSolrConfigFilename()+\"\\n\" );\n\n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n\n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n\n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#init(FilterConfig).mjava","sourceNew":"  public void init(FilterConfig config) throws ServletException\n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    CoreContainer.Initializer init = createInitializer();\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      init.setSolrConfigFilename(config.getInitParameter(\"solrconfig-filename\"));\n\n      this.cores = init.initialize();\n      abortOnConfigurationError = init.isAbortOnConfigurationError();\n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.error( \"Could not start Solr. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n\n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      out.println( \"in \"+init.getSolrConfigFilename()+\"\\n\" );\n\n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n\n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n\n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","sourceOld":"  public void init(FilterConfig config) throws ServletException\n  {\n    log.info(\"SolrDispatchFilter.init()\");\n\n    boolean abortOnConfigurationError = true;\n    CoreContainer.Initializer init = createInitializer();\n    try {\n      // web.xml configuration\n      this.pathPrefix = config.getInitParameter( \"path-prefix\" );\n      init.setSolrConfigFilename(config.getInitParameter(\"solrconfig-filename\"));\n\n      this.cores = init.initialize();\n      abortOnConfigurationError = init.isAbortOnConfigurationError();\n      log.info(\"user.dir=\" + System.getProperty(\"user.dir\"));\n    }\n    catch( Throwable t ) {\n      // catch this so our filter still works\n      log.error( \"Could not start Solr. Check solr/home property\", t);\n      SolrConfig.severeErrors.add( t );\n      SolrCore.log( t );\n    }\n\n    // Optionally abort if we found a sever error\n    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {\n      StringWriter sw = new StringWriter();\n      PrintWriter out = new PrintWriter( sw );\n      out.println( \"Severe errors in solr configuration.\\n\" );\n      out.println( \"Check your log files for more detailed information on what may be wrong.\\n\" );\n      out.println( \"If you want solr to continue after configuration errors, change: \\n\");\n      out.println( \" <abortOnConfigurationError>false</abortOnConfigurationError>\\n\" );\n      out.println( \"in \"+init.getSolrConfigFilename()+\"\\n\" );\n\n      for( Throwable t : SolrConfig.severeErrors ) {\n        out.println( \"-------------------------------------------------------------\" );\n        t.printStackTrace( out );\n      }\n      out.flush();\n\n      // Servlet containers behave slightly differently if you throw an exception during \n      // initialization.  Resin will display that error for every page, jetty prints it in\n      // the logs, but continues normally.  (We will see a 404 rather then the real error)\n      // rather then leave the behavior undefined, lets cache the error and spit it out \n      // for every request.\n      abortErrorMessage = sw.toString();\n      //throw new ServletException( abortErrorMessage );\n    }\n\n    log.info(\"SolrDispatchFilter.init() done\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"28b4df89ecd7e44172951ebd60d638c2b1d8e146":["4926b5318ba4167d360445a0c5f3fc8af2cf8c49"],"d5151046764fb8d9662e02d6c5381b2adb69f96d":["ae248910a22eb7d1b6bd9ade7f9a33dfc0506f0c"],"d262ab35a1389f4ad912bfa8b61a202c61cc475a":["d5151046764fb8d9662e02d6c5381b2adb69f96d"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"58b41d4093a9662306bdc051e4b46643deff70de":["6dc6ab6902f8f70ae43365947ccf44c25986906d"],"abbfb3ad1f90df8ebf4751c8e72b2756ace50699":["8fe3c163c8df3fb3e4248c30f8ae8034cc786589"],"9c74b2e17824ac88cefd4b764b4b9f2c56ceeea5":["d262ab35a1389f4ad912bfa8b61a202c61cc475a"],"e7f3c0b24404bb4616728261b4e610481671c921":["6d6338c87060be5f66757a94945975f3bbd377a9"],"d80013b5e260def972025c93a0b08524f9c38f49":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"ae248910a22eb7d1b6bd9ade7f9a33dfc0506f0c":["4a46cae2a2f75e7ff129d40effceea9918b450a5"],"60c72ea49d42d78d14d5791ec0bed001b5ba4f3d":["9c35e0c1cd20847fdfcf51e89270b571ef397c32"],"048361614025800e582bfc7a7b0329dc6fd6a95e":["abbfb3ad1f90df8ebf4751c8e72b2756ace50699"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4a46cae2a2f75e7ff129d40effceea9918b450a5":["58b41d4093a9662306bdc051e4b46643deff70de"],"67011996c84fe164cd5e78316d919154bcfed3f4":["1a45fbd60083428b1b13884c5c8c2e33e7e71ee7"],"47be907237431a2c75792932d56b79e4781ee1b1":["b46f0ccfb6b63c307ea901d48482630e3689042c"],"08735056ad6ff907f79db8c4cc9ae2ca593bfe22":["60c72ea49d42d78d14d5791ec0bed001b5ba4f3d"],"ad94625fb8d088209f46650c8097196fec67f00c":["87c63be0728f8f147d7e19ec9c514fd2c8f01907"],"f8c31261092dc7e5e9e00b9a640af3d381679e98":["43c800be98a24a96d9d21e62c645822de478f6a2"],"6d6338c87060be5f66757a94945975f3bbd377a9":["08735056ad6ff907f79db8c4cc9ae2ca593bfe22"],"368c8927753a9ca6ee214a251da2746ff35aeef6":["f8c31261092dc7e5e9e00b9a640af3d381679e98"],"6dc6ab6902f8f70ae43365947ccf44c25986906d":["b920ba0b6285c3aaa7a64d1677f5b4ee58b0779d"],"8fe3c163c8df3fb3e4248c30f8ae8034cc786589":["e7f3c0b24404bb4616728261b4e610481671c921"],"b46f0ccfb6b63c307ea901d48482630e3689042c":["67011996c84fe164cd5e78316d919154bcfed3f4"],"00da8b51bdeae168a5b26ec506db372b219ca7a2":["28b4df89ecd7e44172951ebd60d638c2b1d8e146"],"1a45fbd60083428b1b13884c5c8c2e33e7e71ee7":["048361614025800e582bfc7a7b0329dc6fd6a95e"],"87c63be0728f8f147d7e19ec9c514fd2c8f01907":["00da8b51bdeae168a5b26ec506db372b219ca7a2"],"4926b5318ba4167d360445a0c5f3fc8af2cf8c49":["9c74b2e17824ac88cefd4b764b4b9f2c56ceeea5"],"43c800be98a24a96d9d21e62c645822de478f6a2":["d80013b5e260def972025c93a0b08524f9c38f49"],"b920ba0b6285c3aaa7a64d1677f5b4ee58b0779d":["47be907237431a2c75792932d56b79e4781ee1b1"],"9c35e0c1cd20847fdfcf51e89270b571ef397c32":["368c8927753a9ca6ee214a251da2746ff35aeef6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"28b4df89ecd7e44172951ebd60d638c2b1d8e146":["00da8b51bdeae168a5b26ec506db372b219ca7a2"],"d5151046764fb8d9662e02d6c5381b2adb69f96d":["d262ab35a1389f4ad912bfa8b61a202c61cc475a"],"d262ab35a1389f4ad912bfa8b61a202c61cc475a":["9c74b2e17824ac88cefd4b764b4b9f2c56ceeea5"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["d80013b5e260def972025c93a0b08524f9c38f49"],"58b41d4093a9662306bdc051e4b46643deff70de":["4a46cae2a2f75e7ff129d40effceea9918b450a5"],"abbfb3ad1f90df8ebf4751c8e72b2756ace50699":["048361614025800e582bfc7a7b0329dc6fd6a95e"],"9c74b2e17824ac88cefd4b764b4b9f2c56ceeea5":["4926b5318ba4167d360445a0c5f3fc8af2cf8c49"],"e7f3c0b24404bb4616728261b4e610481671c921":["8fe3c163c8df3fb3e4248c30f8ae8034cc786589"],"d80013b5e260def972025c93a0b08524f9c38f49":["43c800be98a24a96d9d21e62c645822de478f6a2"],"ae248910a22eb7d1b6bd9ade7f9a33dfc0506f0c":["d5151046764fb8d9662e02d6c5381b2adb69f96d"],"60c72ea49d42d78d14d5791ec0bed001b5ba4f3d":["08735056ad6ff907f79db8c4cc9ae2ca593bfe22"],"048361614025800e582bfc7a7b0329dc6fd6a95e":["1a45fbd60083428b1b13884c5c8c2e33e7e71ee7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4a46cae2a2f75e7ff129d40effceea9918b450a5":["ae248910a22eb7d1b6bd9ade7f9a33dfc0506f0c"],"67011996c84fe164cd5e78316d919154bcfed3f4":["b46f0ccfb6b63c307ea901d48482630e3689042c"],"47be907237431a2c75792932d56b79e4781ee1b1":["b920ba0b6285c3aaa7a64d1677f5b4ee58b0779d"],"08735056ad6ff907f79db8c4cc9ae2ca593bfe22":["6d6338c87060be5f66757a94945975f3bbd377a9"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"f8c31261092dc7e5e9e00b9a640af3d381679e98":["368c8927753a9ca6ee214a251da2746ff35aeef6"],"6d6338c87060be5f66757a94945975f3bbd377a9":["e7f3c0b24404bb4616728261b4e610481671c921"],"368c8927753a9ca6ee214a251da2746ff35aeef6":["9c35e0c1cd20847fdfcf51e89270b571ef397c32"],"6dc6ab6902f8f70ae43365947ccf44c25986906d":["58b41d4093a9662306bdc051e4b46643deff70de"],"8fe3c163c8df3fb3e4248c30f8ae8034cc786589":["abbfb3ad1f90df8ebf4751c8e72b2756ace50699"],"b46f0ccfb6b63c307ea901d48482630e3689042c":["47be907237431a2c75792932d56b79e4781ee1b1"],"00da8b51bdeae168a5b26ec506db372b219ca7a2":["87c63be0728f8f147d7e19ec9c514fd2c8f01907"],"1a45fbd60083428b1b13884c5c8c2e33e7e71ee7":["67011996c84fe164cd5e78316d919154bcfed3f4"],"87c63be0728f8f147d7e19ec9c514fd2c8f01907":["ad94625fb8d088209f46650c8097196fec67f00c"],"4926b5318ba4167d360445a0c5f3fc8af2cf8c49":["28b4df89ecd7e44172951ebd60d638c2b1d8e146"],"43c800be98a24a96d9d21e62c645822de478f6a2":["f8c31261092dc7e5e9e00b9a640af3d381679e98"],"9c35e0c1cd20847fdfcf51e89270b571ef397c32":["60c72ea49d42d78d14d5791ec0bed001b5ba4f3d"],"b920ba0b6285c3aaa7a64d1677f5b4ee58b0779d":["6dc6ab6902f8f70ae43365947ccf44c25986906d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}