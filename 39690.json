{"path":"src/java/org/apache/lucene/index/ParallelReader#add(IndexReader,boolean).mjava","commits":[{"id":"3101986002d49f3738148cdfe12337d946b0654c","date":1115921358,"type":0,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/ParallelReader#add(IndexReader,boolean).mjava","pathOld":"/dev/null","sourceNew":" /** Add an IndexReader whose stored fields will not be returned.  This can\n  * accellerate search when stored fields are only needed from a subset of\n  * the IndexReaders. */\n  public void add(IndexReader reader, boolean ignoreStoredFields)\n    throws IOException {\n\n    if (readers.size() == 0) {\n      this.maxDoc = reader.maxDoc();\n      this.numDocs = reader.numDocs();\n      this.hasDeletions = reader.hasDeletions();\n    }\n\n    if (reader.maxDoc() != maxDoc)                // check compatibility\n      throw new IllegalArgumentException\n        (\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n    if (reader.numDocs() != numDocs)\n      throw new IllegalArgumentException\n        (\"All readers must have same numDocs: \"+numDocs+\"!=\"+reader.numDocs());\n    \n    Iterator i = reader.getFieldNames().iterator();\n    while (i.hasNext()) {                         // update fieldToReader map\n      String field = (String)i.next();\n      if (fieldToReader.get(field) == null)\n        fieldToReader.put(field, reader);\n    }\n\n    if (!ignoreStoredFields)\n      storedFieldReaders.add(reader);             // add to storedFieldReaders\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f09499b081084a4c0508a0492de5d0d4fba12e4","date":1123713566,"type":3,"author":"Daniel Naber","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/ParallelReader#add(IndexReader,boolean).mjava","pathOld":"src/java/org/apache/lucene/index/ParallelReader#add(IndexReader,boolean).mjava","sourceNew":" /** Add an IndexReader whose stored fields will not be returned.  This can\n  * accellerate search when stored fields are only needed from a subset of\n  * the IndexReaders.\n  * \n  * @throws IllegalArgumentException if not all indexes contain the same number \n  *     of documents\n  * @throws IllegalArgumentException if not all indexes have the same value \n  *     of {@link IndexReader#maxDoc()}\n  */\n  public void add(IndexReader reader, boolean ignoreStoredFields)\n    throws IOException {\n\n    if (readers.size() == 0) {\n      this.maxDoc = reader.maxDoc();\n      this.numDocs = reader.numDocs();\n      this.hasDeletions = reader.hasDeletions();\n    }\n\n    if (reader.maxDoc() != maxDoc)                // check compatibility\n      throw new IllegalArgumentException\n        (\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n    if (reader.numDocs() != numDocs)\n      throw new IllegalArgumentException\n        (\"All readers must have same numDocs: \"+numDocs+\"!=\"+reader.numDocs());\n    \n    Iterator i = reader.getFieldNames(IndexReader.FieldOption.ALL).iterator();\n    while (i.hasNext()) {                         // update fieldToReader map\n      String field = (String)i.next();\n      if (fieldToReader.get(field) == null)\n        fieldToReader.put(field, reader);\n    }\n\n    if (!ignoreStoredFields)\n      storedFieldReaders.add(reader);             // add to storedFieldReaders\n    readers.add(reader);\n  }\n\n","sourceOld":" /** Add an IndexReader whose stored fields will not be returned.  This can\n  * accellerate search when stored fields are only needed from a subset of\n  * the IndexReaders. */\n  public void add(IndexReader reader, boolean ignoreStoredFields)\n    throws IOException {\n\n    if (readers.size() == 0) {\n      this.maxDoc = reader.maxDoc();\n      this.numDocs = reader.numDocs();\n      this.hasDeletions = reader.hasDeletions();\n    }\n\n    if (reader.maxDoc() != maxDoc)                // check compatibility\n      throw new IllegalArgumentException\n        (\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n    if (reader.numDocs() != numDocs)\n      throw new IllegalArgumentException\n        (\"All readers must have same numDocs: \"+numDocs+\"!=\"+reader.numDocs());\n    \n    Iterator i = reader.getFieldNames().iterator();\n    while (i.hasNext()) {                         // update fieldToReader map\n      String field = (String)i.next();\n      if (fieldToReader.get(field) == null)\n        fieldToReader.put(field, reader);\n    }\n\n    if (!ignoreStoredFields)\n      storedFieldReaders.add(reader);             // add to storedFieldReaders\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"12d40284fd9481f79444bc63bc5d13847caddd3d","date":1149902602,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/ParallelReader#add(IndexReader,boolean).mjava","pathOld":"src/java/org/apache/lucene/index/ParallelReader#add(IndexReader,boolean).mjava","sourceNew":" /** Add an IndexReader whose stored fields will not be returned.  This can\n  * accellerate search when stored fields are only needed from a subset of\n  * the IndexReaders.\n  *\n  * @throws IllegalArgumentException if not all indexes contain the same number\n  *     of documents\n  * @throws IllegalArgumentException if not all indexes have the same value\n  *     of {@link IndexReader#maxDoc()}\n  */\n  public void add(IndexReader reader, boolean ignoreStoredFields)\n    throws IOException {\n\n    if (readers.size() == 0) {\n      this.maxDoc = reader.maxDoc();\n      this.numDocs = reader.numDocs();\n      this.hasDeletions = reader.hasDeletions();\n    }\n\n    if (reader.maxDoc() != maxDoc)                // check compatibility\n      throw new IllegalArgumentException\n        (\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n    if (reader.numDocs() != numDocs)\n      throw new IllegalArgumentException\n        (\"All readers must have same numDocs: \"+numDocs+\"!=\"+reader.numDocs());\n\n    Collection fields = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    readerToFields.put(reader, fields);\n    Iterator i = fields.iterator();\n    while (i.hasNext()) {                         // update fieldToReader map\n      String field = (String)i.next();\n      if (fieldToReader.get(field) == null)\n        fieldToReader.put(field, reader);\n    }\n\n    if (!ignoreStoredFields)\n      storedFieldReaders.add(reader);             // add to storedFieldReaders\n    readers.add(reader);\n  }\n\n","sourceOld":" /** Add an IndexReader whose stored fields will not be returned.  This can\n  * accellerate search when stored fields are only needed from a subset of\n  * the IndexReaders.\n  * \n  * @throws IllegalArgumentException if not all indexes contain the same number \n  *     of documents\n  * @throws IllegalArgumentException if not all indexes have the same value \n  *     of {@link IndexReader#maxDoc()}\n  */\n  public void add(IndexReader reader, boolean ignoreStoredFields)\n    throws IOException {\n\n    if (readers.size() == 0) {\n      this.maxDoc = reader.maxDoc();\n      this.numDocs = reader.numDocs();\n      this.hasDeletions = reader.hasDeletions();\n    }\n\n    if (reader.maxDoc() != maxDoc)                // check compatibility\n      throw new IllegalArgumentException\n        (\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n    if (reader.numDocs() != numDocs)\n      throw new IllegalArgumentException\n        (\"All readers must have same numDocs: \"+numDocs+\"!=\"+reader.numDocs());\n    \n    Iterator i = reader.getFieldNames(IndexReader.FieldOption.ALL).iterator();\n    while (i.hasNext()) {                         // update fieldToReader map\n      String field = (String)i.next();\n      if (fieldToReader.get(field) == null)\n        fieldToReader.put(field, reader);\n    }\n\n    if (!ignoreStoredFields)\n      storedFieldReaders.add(reader);             // add to storedFieldReaders\n    readers.add(reader);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"328c1568e471f0c6eaa49ec00334ca59e573710f","date":1173897963,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/ParallelReader#add(IndexReader,boolean).mjava","pathOld":"src/java/org/apache/lucene/index/ParallelReader#add(IndexReader,boolean).mjava","sourceNew":" /** Add an IndexReader whose stored fields will not be returned.  This can\n  * accellerate search when stored fields are only needed from a subset of\n  * the IndexReaders.\n  *\n  * @throws IllegalArgumentException if not all indexes contain the same number\n  *     of documents\n  * @throws IllegalArgumentException if not all indexes have the same value\n  *     of {@link IndexReader#maxDoc()}\n  * @throws IOException if there is a low-level IO error\n  */\n  public void add(IndexReader reader, boolean ignoreStoredFields)\n    throws IOException {\n\n    ensureOpen();\n    if (readers.size() == 0) {\n      this.maxDoc = reader.maxDoc();\n      this.numDocs = reader.numDocs();\n      this.hasDeletions = reader.hasDeletions();\n    }\n\n    if (reader.maxDoc() != maxDoc)                // check compatibility\n      throw new IllegalArgumentException\n        (\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n    if (reader.numDocs() != numDocs)\n      throw new IllegalArgumentException\n        (\"All readers must have same numDocs: \"+numDocs+\"!=\"+reader.numDocs());\n\n    Collection fields = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    readerToFields.put(reader, fields);\n    Iterator i = fields.iterator();\n    while (i.hasNext()) {                         // update fieldToReader map\n      String field = (String)i.next();\n      if (fieldToReader.get(field) == null)\n        fieldToReader.put(field, reader);\n    }\n\n    if (!ignoreStoredFields)\n      storedFieldReaders.add(reader);             // add to storedFieldReaders\n    readers.add(reader);\n  }\n\n","sourceOld":" /** Add an IndexReader whose stored fields will not be returned.  This can\n  * accellerate search when stored fields are only needed from a subset of\n  * the IndexReaders.\n  *\n  * @throws IllegalArgumentException if not all indexes contain the same number\n  *     of documents\n  * @throws IllegalArgumentException if not all indexes have the same value\n  *     of {@link IndexReader#maxDoc()}\n  */\n  public void add(IndexReader reader, boolean ignoreStoredFields)\n    throws IOException {\n\n    if (readers.size() == 0) {\n      this.maxDoc = reader.maxDoc();\n      this.numDocs = reader.numDocs();\n      this.hasDeletions = reader.hasDeletions();\n    }\n\n    if (reader.maxDoc() != maxDoc)                // check compatibility\n      throw new IllegalArgumentException\n        (\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n    if (reader.numDocs() != numDocs)\n      throw new IllegalArgumentException\n        (\"All readers must have same numDocs: \"+numDocs+\"!=\"+reader.numDocs());\n\n    Collection fields = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    readerToFields.put(reader, fields);\n    Iterator i = fields.iterator();\n    while (i.hasNext()) {                         // update fieldToReader map\n      String field = (String)i.next();\n      if (fieldToReader.get(field) == null)\n        fieldToReader.put(field, reader);\n    }\n\n    if (!ignoreStoredFields)\n      storedFieldReaders.add(reader);             // add to storedFieldReaders\n    readers.add(reader);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b9d7142a399ac70a71ce5b40ee66695eda5b7e8","date":1195335263,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/ParallelReader#add(IndexReader,boolean).mjava","pathOld":"src/java/org/apache/lucene/index/ParallelReader#add(IndexReader,boolean).mjava","sourceNew":" /** Add an IndexReader whose stored fields will not be returned.  This can\n  * accellerate search when stored fields are only needed from a subset of\n  * the IndexReaders.\n  *\n  * @throws IllegalArgumentException if not all indexes contain the same number\n  *     of documents\n  * @throws IllegalArgumentException if not all indexes have the same value\n  *     of {@link IndexReader#maxDoc()}\n  * @throws IOException if there is a low-level IO error\n  */\n  public void add(IndexReader reader, boolean ignoreStoredFields)\n    throws IOException {\n\n    ensureOpen();\n    if (readers.size() == 0) {\n      this.maxDoc = reader.maxDoc();\n      this.numDocs = reader.numDocs();\n      this.hasDeletions = reader.hasDeletions();\n    }\n\n    if (reader.maxDoc() != maxDoc)                // check compatibility\n      throw new IllegalArgumentException\n        (\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n    if (reader.numDocs() != numDocs)\n      throw new IllegalArgumentException\n        (\"All readers must have same numDocs: \"+numDocs+\"!=\"+reader.numDocs());\n\n    Collection fields = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    readerToFields.put(reader, fields);\n    Iterator i = fields.iterator();\n    while (i.hasNext()) {                         // update fieldToReader map\n      String field = (String)i.next();\n      if (fieldToReader.get(field) == null)\n        fieldToReader.put(field, reader);\n    }\n\n    if (!ignoreStoredFields)\n      storedFieldReaders.add(reader);             // add to storedFieldReaders\n    readers.add(reader);\n    \n    if (incRefReaders) {\n      reader.incRef();\n    }\n    decrefOnClose.add(new Boolean(incRefReaders));\n  }\n\n","sourceOld":" /** Add an IndexReader whose stored fields will not be returned.  This can\n  * accellerate search when stored fields are only needed from a subset of\n  * the IndexReaders.\n  *\n  * @throws IllegalArgumentException if not all indexes contain the same number\n  *     of documents\n  * @throws IllegalArgumentException if not all indexes have the same value\n  *     of {@link IndexReader#maxDoc()}\n  * @throws IOException if there is a low-level IO error\n  */\n  public void add(IndexReader reader, boolean ignoreStoredFields)\n    throws IOException {\n\n    ensureOpen();\n    if (readers.size() == 0) {\n      this.maxDoc = reader.maxDoc();\n      this.numDocs = reader.numDocs();\n      this.hasDeletions = reader.hasDeletions();\n    }\n\n    if (reader.maxDoc() != maxDoc)                // check compatibility\n      throw new IllegalArgumentException\n        (\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n    if (reader.numDocs() != numDocs)\n      throw new IllegalArgumentException\n        (\"All readers must have same numDocs: \"+numDocs+\"!=\"+reader.numDocs());\n\n    Collection fields = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    readerToFields.put(reader, fields);\n    Iterator i = fields.iterator();\n    while (i.hasNext()) {                         // update fieldToReader map\n      String field = (String)i.next();\n      if (fieldToReader.get(field) == null)\n        fieldToReader.put(field, reader);\n    }\n\n    if (!ignoreStoredFields)\n      storedFieldReaders.add(reader);             // add to storedFieldReaders\n    readers.add(reader);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b97548d27406e9f33187836e1de98d473a63f5d","date":1196088721,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/ParallelReader#add(IndexReader,boolean).mjava","pathOld":"src/java/org/apache/lucene/index/ParallelReader#add(IndexReader,boolean).mjava","sourceNew":" /** Add an IndexReader whose stored fields will not be returned.  This can\n  * accellerate search when stored fields are only needed from a subset of\n  * the IndexReaders.\n  *\n  * @throws IllegalArgumentException if not all indexes contain the same number\n  *     of documents\n  * @throws IllegalArgumentException if not all indexes have the same value\n  *     of {@link IndexReader#maxDoc()}\n  * @throws IOException if there is a low-level IO error\n  */\n  public void add(IndexReader reader, boolean ignoreStoredFields)\n    throws IOException {\n\n    ensureOpen();\n    if (readers.size() == 0) {\n      this.maxDoc = reader.maxDoc();\n      this.numDocs = reader.numDocs();\n      this.hasDeletions = reader.hasDeletions();\n    }\n\n    if (reader.maxDoc() != maxDoc)                // check compatibility\n      throw new IllegalArgumentException\n        (\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n    if (reader.numDocs() != numDocs)\n      throw new IllegalArgumentException\n        (\"All readers must have same numDocs: \"+numDocs+\"!=\"+reader.numDocs());\n\n    Collection fields = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    readerToFields.put(reader, fields);\n    Iterator i = fields.iterator();\n    while (i.hasNext()) {                         // update fieldToReader map\n      String field = (String)i.next();\n      if (fieldToReader.get(field) == null)\n        fieldToReader.put(field, reader);\n    }\n\n    if (!ignoreStoredFields)\n      storedFieldReaders.add(reader);             // add to storedFieldReaders\n    readers.add(reader);\n    \n    if (incRefReaders) {\n      reader.incRef();\n    }\n    decrefOnClose.add(Boolean.valueOf(incRefReaders));\n  }\n\n","sourceOld":" /** Add an IndexReader whose stored fields will not be returned.  This can\n  * accellerate search when stored fields are only needed from a subset of\n  * the IndexReaders.\n  *\n  * @throws IllegalArgumentException if not all indexes contain the same number\n  *     of documents\n  * @throws IllegalArgumentException if not all indexes have the same value\n  *     of {@link IndexReader#maxDoc()}\n  * @throws IOException if there is a low-level IO error\n  */\n  public void add(IndexReader reader, boolean ignoreStoredFields)\n    throws IOException {\n\n    ensureOpen();\n    if (readers.size() == 0) {\n      this.maxDoc = reader.maxDoc();\n      this.numDocs = reader.numDocs();\n      this.hasDeletions = reader.hasDeletions();\n    }\n\n    if (reader.maxDoc() != maxDoc)                // check compatibility\n      throw new IllegalArgumentException\n        (\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n    if (reader.numDocs() != numDocs)\n      throw new IllegalArgumentException\n        (\"All readers must have same numDocs: \"+numDocs+\"!=\"+reader.numDocs());\n\n    Collection fields = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    readerToFields.put(reader, fields);\n    Iterator i = fields.iterator();\n    while (i.hasNext()) {                         // update fieldToReader map\n      String field = (String)i.next();\n      if (fieldToReader.get(field) == null)\n        fieldToReader.put(field, reader);\n    }\n\n    if (!ignoreStoredFields)\n      storedFieldReaders.add(reader);             // add to storedFieldReaders\n    readers.add(reader);\n    \n    if (incRefReaders) {\n      reader.incRef();\n    }\n    decrefOnClose.add(new Boolean(incRefReaders));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"add7d922e63099fbce8f0a1b31216df7ef5067f1","date":1252002701,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/ParallelReader#add(IndexReader,boolean).mjava","pathOld":"src/java/org/apache/lucene/index/ParallelReader#add(IndexReader,boolean).mjava","sourceNew":" /** Add an IndexReader whose stored fields will not be returned.  This can\n  * accelerate search when stored fields are only needed from a subset of\n  * the IndexReaders.\n  *\n  * @throws IllegalArgumentException if not all indexes contain the same number\n  *     of documents\n  * @throws IllegalArgumentException if not all indexes have the same value\n  *     of {@link IndexReader#maxDoc()}\n  * @throws IOException if there is a low-level IO error\n  */\n  public void add(IndexReader reader, boolean ignoreStoredFields)\n    throws IOException {\n\n    ensureOpen();\n    if (readers.size() == 0) {\n      this.maxDoc = reader.maxDoc();\n      this.numDocs = reader.numDocs();\n      this.hasDeletions = reader.hasDeletions();\n    }\n\n    if (reader.maxDoc() != maxDoc)                // check compatibility\n      throw new IllegalArgumentException\n        (\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n    if (reader.numDocs() != numDocs)\n      throw new IllegalArgumentException\n        (\"All readers must have same numDocs: \"+numDocs+\"!=\"+reader.numDocs());\n\n    Collection fields = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    readerToFields.put(reader, fields);\n    Iterator i = fields.iterator();\n    while (i.hasNext()) {                         // update fieldToReader map\n      String field = (String)i.next();\n      if (fieldToReader.get(field) == null)\n        fieldToReader.put(field, reader);\n    }\n\n    if (!ignoreStoredFields)\n      storedFieldReaders.add(reader);             // add to storedFieldReaders\n    readers.add(reader);\n    \n    if (incRefReaders) {\n      reader.incRef();\n    }\n    decrefOnClose.add(Boolean.valueOf(incRefReaders));\n  }\n\n","sourceOld":" /** Add an IndexReader whose stored fields will not be returned.  This can\n  * accellerate search when stored fields are only needed from a subset of\n  * the IndexReaders.\n  *\n  * @throws IllegalArgumentException if not all indexes contain the same number\n  *     of documents\n  * @throws IllegalArgumentException if not all indexes have the same value\n  *     of {@link IndexReader#maxDoc()}\n  * @throws IOException if there is a low-level IO error\n  */\n  public void add(IndexReader reader, boolean ignoreStoredFields)\n    throws IOException {\n\n    ensureOpen();\n    if (readers.size() == 0) {\n      this.maxDoc = reader.maxDoc();\n      this.numDocs = reader.numDocs();\n      this.hasDeletions = reader.hasDeletions();\n    }\n\n    if (reader.maxDoc() != maxDoc)                // check compatibility\n      throw new IllegalArgumentException\n        (\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n    if (reader.numDocs() != numDocs)\n      throw new IllegalArgumentException\n        (\"All readers must have same numDocs: \"+numDocs+\"!=\"+reader.numDocs());\n\n    Collection fields = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    readerToFields.put(reader, fields);\n    Iterator i = fields.iterator();\n    while (i.hasNext()) {                         // update fieldToReader map\n      String field = (String)i.next();\n      if (fieldToReader.get(field) == null)\n        fieldToReader.put(field, reader);\n    }\n\n    if (!ignoreStoredFields)\n      storedFieldReaders.add(reader);             // add to storedFieldReaders\n    readers.add(reader);\n    \n    if (incRefReaders) {\n      reader.incRef();\n    }\n    decrefOnClose.add(Boolean.valueOf(incRefReaders));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f011f01db72fa6f556a9a0843944ecee2de4aaa8","date":1255806907,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/ParallelReader#add(IndexReader,boolean).mjava","pathOld":"src/java/org/apache/lucene/index/ParallelReader#add(IndexReader,boolean).mjava","sourceNew":" /** Add an IndexReader whose stored fields will not be returned.  This can\n  * accelerate search when stored fields are only needed from a subset of\n  * the IndexReaders.\n  *\n  * @throws IllegalArgumentException if not all indexes contain the same number\n  *     of documents\n  * @throws IllegalArgumentException if not all indexes have the same value\n  *     of {@link IndexReader#maxDoc()}\n  * @throws IOException if there is a low-level IO error\n  */\n  public void add(IndexReader reader, boolean ignoreStoredFields)\n    throws IOException {\n\n    ensureOpen();\n    if (readers.size() == 0) {\n      this.maxDoc = reader.maxDoc();\n      this.numDocs = reader.numDocs();\n      this.hasDeletions = reader.hasDeletions();\n    }\n\n    if (reader.maxDoc() != maxDoc)                // check compatibility\n      throw new IllegalArgumentException\n        (\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n    if (reader.numDocs() != numDocs)\n      throw new IllegalArgumentException\n        (\"All readers must have same numDocs: \"+numDocs+\"!=\"+reader.numDocs());\n\n    Collection<String> fields = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    readerToFields.put(reader, fields);\n    Iterator i = fields.iterator();\n    while (i.hasNext()) {                         // update fieldToReader map\n      String field = (String)i.next();\n      if (fieldToReader.get(field) == null)\n        fieldToReader.put(field, reader);\n    }\n\n    if (!ignoreStoredFields)\n      storedFieldReaders.add(reader);             // add to storedFieldReaders\n    readers.add(reader);\n    \n    if (incRefReaders) {\n      reader.incRef();\n    }\n    decrefOnClose.add(Boolean.valueOf(incRefReaders));\n  }\n\n","sourceOld":" /** Add an IndexReader whose stored fields will not be returned.  This can\n  * accelerate search when stored fields are only needed from a subset of\n  * the IndexReaders.\n  *\n  * @throws IllegalArgumentException if not all indexes contain the same number\n  *     of documents\n  * @throws IllegalArgumentException if not all indexes have the same value\n  *     of {@link IndexReader#maxDoc()}\n  * @throws IOException if there is a low-level IO error\n  */\n  public void add(IndexReader reader, boolean ignoreStoredFields)\n    throws IOException {\n\n    ensureOpen();\n    if (readers.size() == 0) {\n      this.maxDoc = reader.maxDoc();\n      this.numDocs = reader.numDocs();\n      this.hasDeletions = reader.hasDeletions();\n    }\n\n    if (reader.maxDoc() != maxDoc)                // check compatibility\n      throw new IllegalArgumentException\n        (\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n    if (reader.numDocs() != numDocs)\n      throw new IllegalArgumentException\n        (\"All readers must have same numDocs: \"+numDocs+\"!=\"+reader.numDocs());\n\n    Collection fields = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    readerToFields.put(reader, fields);\n    Iterator i = fields.iterator();\n    while (i.hasNext()) {                         // update fieldToReader map\n      String field = (String)i.next();\n      if (fieldToReader.get(field) == null)\n        fieldToReader.put(field, reader);\n    }\n\n    if (!ignoreStoredFields)\n      storedFieldReaders.add(reader);             // add to storedFieldReaders\n    readers.add(reader);\n    \n    if (incRefReaders) {\n      reader.incRef();\n    }\n    decrefOnClose.add(Boolean.valueOf(incRefReaders));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa27b750ee9a51ec4bed93ef328aef9ca1e2153d","date":1255859449,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/ParallelReader#add(IndexReader,boolean).mjava","pathOld":"src/java/org/apache/lucene/index/ParallelReader#add(IndexReader,boolean).mjava","sourceNew":" /** Add an IndexReader whose stored fields will not be returned.  This can\n  * accelerate search when stored fields are only needed from a subset of\n  * the IndexReaders.\n  *\n  * @throws IllegalArgumentException if not all indexes contain the same number\n  *     of documents\n  * @throws IllegalArgumentException if not all indexes have the same value\n  *     of {@link IndexReader#maxDoc()}\n  * @throws IOException if there is a low-level IO error\n  */\n  public void add(IndexReader reader, boolean ignoreStoredFields)\n    throws IOException {\n\n    ensureOpen();\n    if (readers.size() == 0) {\n      this.maxDoc = reader.maxDoc();\n      this.numDocs = reader.numDocs();\n      this.hasDeletions = reader.hasDeletions();\n    }\n\n    if (reader.maxDoc() != maxDoc)                // check compatibility\n      throw new IllegalArgumentException\n        (\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n    if (reader.numDocs() != numDocs)\n      throw new IllegalArgumentException\n        (\"All readers must have same numDocs: \"+numDocs+\"!=\"+reader.numDocs());\n\n    Collection<String> fields = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    readerToFields.put(reader, fields);\n    for (final String field : fields) {                         // update fieldToReader map\n      if (fieldToReader.get(field) == null)\n        fieldToReader.put(field, reader);\n    }\n\n    if (!ignoreStoredFields)\n      storedFieldReaders.add(reader);             // add to storedFieldReaders\n    readers.add(reader);\n    \n    if (incRefReaders) {\n      reader.incRef();\n    }\n    decrefOnClose.add(Boolean.valueOf(incRefReaders));\n  }\n\n","sourceOld":" /** Add an IndexReader whose stored fields will not be returned.  This can\n  * accelerate search when stored fields are only needed from a subset of\n  * the IndexReaders.\n  *\n  * @throws IllegalArgumentException if not all indexes contain the same number\n  *     of documents\n  * @throws IllegalArgumentException if not all indexes have the same value\n  *     of {@link IndexReader#maxDoc()}\n  * @throws IOException if there is a low-level IO error\n  */\n  public void add(IndexReader reader, boolean ignoreStoredFields)\n    throws IOException {\n\n    ensureOpen();\n    if (readers.size() == 0) {\n      this.maxDoc = reader.maxDoc();\n      this.numDocs = reader.numDocs();\n      this.hasDeletions = reader.hasDeletions();\n    }\n\n    if (reader.maxDoc() != maxDoc)                // check compatibility\n      throw new IllegalArgumentException\n        (\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n    if (reader.numDocs() != numDocs)\n      throw new IllegalArgumentException\n        (\"All readers must have same numDocs: \"+numDocs+\"!=\"+reader.numDocs());\n\n    Collection<String> fields = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    readerToFields.put(reader, fields);\n    Iterator i = fields.iterator();\n    while (i.hasNext()) {                         // update fieldToReader map\n      String field = (String)i.next();\n      if (fieldToReader.get(field) == null)\n        fieldToReader.put(field, reader);\n    }\n\n    if (!ignoreStoredFields)\n      storedFieldReaders.add(reader);             // add to storedFieldReaders\n    readers.add(reader);\n    \n    if (incRefReaders) {\n      reader.incRef();\n    }\n    decrefOnClose.add(Boolean.valueOf(incRefReaders));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/ParallelReader#add(IndexReader,boolean).mjava","pathOld":"src/java/org/apache/lucene/index/ParallelReader#add(IndexReader,boolean).mjava","sourceNew":" /** Add an IndexReader whose stored fields will not be returned.  This can\n  * accelerate search when stored fields are only needed from a subset of\n  * the IndexReaders.\n  *\n  * @throws IllegalArgumentException if not all indexes contain the same number\n  *     of documents\n  * @throws IllegalArgumentException if not all indexes have the same value\n  *     of {@link IndexReader#maxDoc()}\n  * @throws IOException if there is a low-level IO error\n  */\n  public void add(IndexReader reader, boolean ignoreStoredFields)\n    throws IOException {\n\n    ensureOpen();\n    if (readers.size() == 0) {\n      this.maxDoc = reader.maxDoc();\n      this.numDocs = reader.numDocs();\n      this.hasDeletions = reader.hasDeletions();\n    }\n\n    if (reader.maxDoc() != maxDoc)                // check compatibility\n      throw new IllegalArgumentException\n        (\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n    if (reader.numDocs() != numDocs)\n      throw new IllegalArgumentException\n        (\"All readers must have same numDocs: \"+numDocs+\"!=\"+reader.numDocs());\n\n    Collection<String> fields = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    readerToFields.put(reader, fields);\n    for (final String field : fields) {                         // update fieldToReader map\n      if (fieldToReader.get(field) == null)\n        fieldToReader.put(field, reader);\n    }\n\n    if (!ignoreStoredFields)\n      storedFieldReaders.add(reader);             // add to storedFieldReaders\n    readers.add(reader);\n    \n    if (incRefReaders) {\n      reader.incRef();\n    }\n    decrefOnClose.add(Boolean.valueOf(incRefReaders));\n  }\n\n","sourceOld":" /** Add an IndexReader whose stored fields will not be returned.  This can\n  * accelerate search when stored fields are only needed from a subset of\n  * the IndexReaders.\n  *\n  * @throws IllegalArgumentException if not all indexes contain the same number\n  *     of documents\n  * @throws IllegalArgumentException if not all indexes have the same value\n  *     of {@link IndexReader#maxDoc()}\n  * @throws IOException if there is a low-level IO error\n  */\n  public void add(IndexReader reader, boolean ignoreStoredFields)\n    throws IOException {\n\n    ensureOpen();\n    if (readers.size() == 0) {\n      this.maxDoc = reader.maxDoc();\n      this.numDocs = reader.numDocs();\n      this.hasDeletions = reader.hasDeletions();\n    }\n\n    if (reader.maxDoc() != maxDoc)                // check compatibility\n      throw new IllegalArgumentException\n        (\"All readers must have same maxDoc: \"+maxDoc+\"!=\"+reader.maxDoc());\n    if (reader.numDocs() != numDocs)\n      throw new IllegalArgumentException\n        (\"All readers must have same numDocs: \"+numDocs+\"!=\"+reader.numDocs());\n\n    Collection<String> fields = reader.getFieldNames(IndexReader.FieldOption.ALL);\n    readerToFields.put(reader, fields);\n    for (final String field : fields) {                         // update fieldToReader map\n      if (fieldToReader.get(field) == null)\n        fieldToReader.put(field, reader);\n    }\n\n    if (!ignoreStoredFields)\n      storedFieldReaders.add(reader);             // add to storedFieldReaders\n    readers.add(reader);\n    \n    if (incRefReaders) {\n      reader.incRef();\n    }\n    decrefOnClose.add(Boolean.valueOf(incRefReaders));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3101986002d49f3738148cdfe12337d946b0654c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"328c1568e471f0c6eaa49ec00334ca59e573710f":["12d40284fd9481f79444bc63bc5d13847caddd3d"],"fa27b750ee9a51ec4bed93ef328aef9ca1e2153d":["f011f01db72fa6f556a9a0843944ecee2de4aaa8"],"0f09499b081084a4c0508a0492de5d0d4fba12e4":["3101986002d49f3738148cdfe12337d946b0654c"],"add7d922e63099fbce8f0a1b31216df7ef5067f1":["8b97548d27406e9f33187836e1de98d473a63f5d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f011f01db72fa6f556a9a0843944ecee2de4aaa8":["add7d922e63099fbce8f0a1b31216df7ef5067f1"],"8b97548d27406e9f33187836e1de98d473a63f5d":["3b9d7142a399ac70a71ce5b40ee66695eda5b7e8"],"12d40284fd9481f79444bc63bc5d13847caddd3d":["0f09499b081084a4c0508a0492de5d0d4fba12e4"],"3b9d7142a399ac70a71ce5b40ee66695eda5b7e8":["328c1568e471f0c6eaa49ec00334ca59e573710f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["fa27b750ee9a51ec4bed93ef328aef9ca1e2153d"]},"commit2Childs":{"3101986002d49f3738148cdfe12337d946b0654c":["0f09499b081084a4c0508a0492de5d0d4fba12e4"],"328c1568e471f0c6eaa49ec00334ca59e573710f":["3b9d7142a399ac70a71ce5b40ee66695eda5b7e8"],"fa27b750ee9a51ec4bed93ef328aef9ca1e2153d":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"0f09499b081084a4c0508a0492de5d0d4fba12e4":["12d40284fd9481f79444bc63bc5d13847caddd3d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3101986002d49f3738148cdfe12337d946b0654c"],"add7d922e63099fbce8f0a1b31216df7ef5067f1":["f011f01db72fa6f556a9a0843944ecee2de4aaa8"],"f011f01db72fa6f556a9a0843944ecee2de4aaa8":["fa27b750ee9a51ec4bed93ef328aef9ca1e2153d"],"12d40284fd9481f79444bc63bc5d13847caddd3d":["328c1568e471f0c6eaa49ec00334ca59e573710f"],"8b97548d27406e9f33187836e1de98d473a63f5d":["add7d922e63099fbce8f0a1b31216df7ef5067f1"],"3b9d7142a399ac70a71ce5b40ee66695eda5b7e8":["8b97548d27406e9f33187836e1de98d473a63f5d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}