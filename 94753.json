{"path":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder[T],Builder.UnCompiledNode[T]).mjava","commits":[{"id":"1abb939fb41b2fe4f89fd518f3da288c0213341d","date":1435657417,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder[T],Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder.UnCompiledNode[T]).mjava","sourceNew":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(Builder<T> builder, Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    final long startAddress = builder.bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(builder, nodeIn);\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (builder.reusedBytesPerArc.length < nodeIn.numArcs) {\n        builder.reusedBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n    }\n\n    builder.arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = builder.bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (builder.lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set((int) target.node, inCounts.get((int) target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      builder.bytes.writeByte((byte) flags);\n      writeLabel(builder.bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, builder.bytes);\n        //System.out.println(\"    write output\");\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, builder.bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        builder.bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        builder.reusedBytesPerArc[arcIdx] = (int) (builder.bytes.getPosition() - lastArcStart);\n        lastArcStart = builder.bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, builder.reusedBytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + builder.reusedBytesPerArc[arcIdx]);\n      }\n    }\n    \n    // TODO: try to avoid wasteful cases: disable doFixedArray in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedArray) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedArray = false;\n      }\n    }\n    */\n\n    if (doFixedArray) {\n      final int MAX_HEADER_SIZE = 11; // header(byte) + numArcs(vint) + numBytes(vint)\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n\n      //System.out.println(\"write int @pos=\" + (fixedArrayStart-4) + \" numArcs=\" + nodeIn.numArcs);\n      // create the header\n      // TODO: clean this up: or just rewind+reuse and deal with it\n      byte header[] = new byte[MAX_HEADER_SIZE]; \n      ByteArrayDataOutput bad = new ByteArrayDataOutput(header);\n      // write a \"false\" first arc:\n      bad.writeByte(ARCS_AS_FIXED_ARRAY);\n      bad.writeVInt(nodeIn.numArcs);\n      bad.writeVInt(maxBytesPerArc);\n      int headerLen = bad.getPosition();\n      \n      final long fixedArrayStart = startAddress + headerLen;\n\n      // expand the arcs in place, backwards\n      long srcPos = builder.bytes.getPosition();\n      long destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      assert destPos >= srcPos;\n      if (destPos > srcPos) {\n        builder.bytes.skipBytes((int) (destPos - srcPos));\n        for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n          destPos -= maxBytesPerArc;\n          srcPos -= builder.reusedBytesPerArc[arcIdx];\n          //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n          if (srcPos != destPos) {\n            //System.out.println(\"  copy len=\" + builder.reusedBytesPerArc[arcIdx]);\n            assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" reusedBytesPerArc[arcIdx]=\" + builder.reusedBytesPerArc[arcIdx] + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n            builder.bytes.copyBytes(srcPos, destPos, builder.reusedBytesPerArc[arcIdx]);\n          }\n        }\n      }\n      \n      // now write the header\n      builder.bytes.writeBytes(startAddress, header, 0, headerLen);\n    }\n\n    final long thisNodeAddress = builder.bytes.getPosition()-1;\n\n    builder.bytes.reverse(startAddress, thisNodeAddress);\n\n    // PackedInts uses int as the index, so we cannot handle\n    // > 2.1B nodes when packing:\n    if (nodeAddress != null && builder.nodeCount == Integer.MAX_VALUE) {\n      throw new IllegalStateException(\"cannot create a packed FST with more than 2.1 billion nodes\");\n    }\n\n    builder.nodeCount++;\n    final long node;\n    if (nodeAddress != null) {\n\n      // Nodes are addressed by 1+ord:\n      if ((int) builder.nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set((int) builder.nodeCount, thisNodeAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = builder.nodeCount;\n    } else {\n      node = thisNodeAddress;\n    }\n\n    //System.out.println(\"  ret node=\" + node + \" address=\" + thisNodeAddress + \" nodeAddress=\" + nodeAddress);\n    return node;\n  }\n\n","sourceOld":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(Builder.UnCompiledNode<T> nodeIn) throws IOException {\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    final long startAddress = bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(nodeIn);\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (reusedBytesPerArc.length < nodeIn.numArcs) {\n        reusedBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n    }\n\n    arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set((int) target.node, inCounts.get((int) target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      bytes.writeByte((byte) flags);\n      writeLabel(bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, bytes);\n        //System.out.println(\"    write output\");\n        arcWithOutputCount++;\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        reusedBytesPerArc[arcIdx] = (int) (bytes.getPosition() - lastArcStart);\n        lastArcStart = bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, reusedBytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + reusedBytesPerArc[arcIdx]);\n      }\n    }\n    \n    // TODO: try to avoid wasteful cases: disable doFixedArray in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedArray) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedArray = false;\n      }\n    }\n    */\n\n    if (doFixedArray) {\n      final int MAX_HEADER_SIZE = 11; // header(byte) + numArcs(vint) + numBytes(vint)\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n\n      //System.out.println(\"write int @pos=\" + (fixedArrayStart-4) + \" numArcs=\" + nodeIn.numArcs);\n      // create the header\n      // TODO: clean this up: or just rewind+reuse and deal with it\n      byte header[] = new byte[MAX_HEADER_SIZE]; \n      ByteArrayDataOutput bad = new ByteArrayDataOutput(header);\n      // write a \"false\" first arc:\n      bad.writeByte(ARCS_AS_FIXED_ARRAY);\n      bad.writeVInt(nodeIn.numArcs);\n      bad.writeVInt(maxBytesPerArc);\n      int headerLen = bad.getPosition();\n      \n      final long fixedArrayStart = startAddress + headerLen;\n\n      // expand the arcs in place, backwards\n      long srcPos = bytes.getPosition();\n      long destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      assert destPos >= srcPos;\n      if (destPos > srcPos) {\n        bytes.skipBytes((int) (destPos - srcPos));\n        for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n          destPos -= maxBytesPerArc;\n          srcPos -= reusedBytesPerArc[arcIdx];\n          //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n          if (srcPos != destPos) {\n            //System.out.println(\"  copy len=\" + reusedBytesPerArc[arcIdx]);\n            assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" reusedBytesPerArc[arcIdx]=\" + reusedBytesPerArc[arcIdx] + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n            bytes.copyBytes(srcPos, destPos, reusedBytesPerArc[arcIdx]);\n          }\n        }\n      }\n      \n      // now write the header\n      bytes.writeBytes(startAddress, header, 0, headerLen);\n    }\n\n    final long thisNodeAddress = bytes.getPosition()-1;\n\n    bytes.reverse(startAddress, thisNodeAddress);\n\n    // PackedInts uses int as the index, so we cannot handle\n    // > 2.1B nodes when packing:\n    if (nodeAddress != null && nodeCount == Integer.MAX_VALUE) {\n      throw new IllegalStateException(\"cannot create a packed FST with more than 2.1 billion nodes\");\n    }\n\n    nodeCount++;\n    final long node;\n    if (nodeAddress != null) {\n\n      // Nodes are addressed by 1+ord:\n      if ((int) nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set((int) nodeCount, thisNodeAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = nodeCount;\n    } else {\n      node = thisNodeAddress;\n    }\n    lastFrozenNode = node;\n\n    //System.out.println(\"  ret node=\" + node + \" address=\" + thisNodeAddress + \" nodeAddress=\" + nodeAddress);\n    return node;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6244579a467d5f2673ac98265d74bddbea1a8114","date":1478786509,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder[T],Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder[T],Builder.UnCompiledNode[T]).mjava","sourceNew":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(Builder<T> builder, Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    final long startAddress = builder.bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(builder, nodeIn);\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (builder.reusedBytesPerArc.length < nodeIn.numArcs) {\n        builder.reusedBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n    }\n\n    builder.arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = builder.bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (builder.lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      builder.bytes.writeByte((byte) flags);\n      writeLabel(builder.bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, builder.bytes);\n        //System.out.println(\"    write output\");\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, builder.bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        builder.bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        builder.reusedBytesPerArc[arcIdx] = (int) (builder.bytes.getPosition() - lastArcStart);\n        lastArcStart = builder.bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, builder.reusedBytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + builder.reusedBytesPerArc[arcIdx]);\n      }\n    }\n    \n    // TODO: try to avoid wasteful cases: disable doFixedArray in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedArray) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedArray = false;\n      }\n    }\n    */\n\n    if (doFixedArray) {\n      final int MAX_HEADER_SIZE = 11; // header(byte) + numArcs(vint) + numBytes(vint)\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n\n      //System.out.println(\"write int @pos=\" + (fixedArrayStart-4) + \" numArcs=\" + nodeIn.numArcs);\n      // create the header\n      // TODO: clean this up: or just rewind+reuse and deal with it\n      byte header[] = new byte[MAX_HEADER_SIZE]; \n      ByteArrayDataOutput bad = new ByteArrayDataOutput(header);\n      // write a \"false\" first arc:\n      bad.writeByte(ARCS_AS_FIXED_ARRAY);\n      bad.writeVInt(nodeIn.numArcs);\n      bad.writeVInt(maxBytesPerArc);\n      int headerLen = bad.getPosition();\n      \n      final long fixedArrayStart = startAddress + headerLen;\n\n      // expand the arcs in place, backwards\n      long srcPos = builder.bytes.getPosition();\n      long destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      assert destPos >= srcPos;\n      if (destPos > srcPos) {\n        builder.bytes.skipBytes((int) (destPos - srcPos));\n        for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n          destPos -= maxBytesPerArc;\n          srcPos -= builder.reusedBytesPerArc[arcIdx];\n          //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n          if (srcPos != destPos) {\n            //System.out.println(\"  copy len=\" + builder.reusedBytesPerArc[arcIdx]);\n            assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" reusedBytesPerArc[arcIdx]=\" + builder.reusedBytesPerArc[arcIdx] + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n            builder.bytes.copyBytes(srcPos, destPos, builder.reusedBytesPerArc[arcIdx]);\n          }\n        }\n      }\n      \n      // now write the header\n      builder.bytes.writeBytes(startAddress, header, 0, headerLen);\n    }\n\n    final long thisNodeAddress = builder.bytes.getPosition()-1;\n\n    builder.bytes.reverse(startAddress, thisNodeAddress);\n\n    builder.nodeCount++;\n    return thisNodeAddress;\n  }\n\n","sourceOld":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(Builder<T> builder, Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    final long startAddress = builder.bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(builder, nodeIn);\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (builder.reusedBytesPerArc.length < nodeIn.numArcs) {\n        builder.reusedBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n    }\n\n    builder.arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = builder.bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (builder.lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set((int) target.node, inCounts.get((int) target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      builder.bytes.writeByte((byte) flags);\n      writeLabel(builder.bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, builder.bytes);\n        //System.out.println(\"    write output\");\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, builder.bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        builder.bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        builder.reusedBytesPerArc[arcIdx] = (int) (builder.bytes.getPosition() - lastArcStart);\n        lastArcStart = builder.bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, builder.reusedBytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + builder.reusedBytesPerArc[arcIdx]);\n      }\n    }\n    \n    // TODO: try to avoid wasteful cases: disable doFixedArray in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedArray) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedArray = false;\n      }\n    }\n    */\n\n    if (doFixedArray) {\n      final int MAX_HEADER_SIZE = 11; // header(byte) + numArcs(vint) + numBytes(vint)\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n\n      //System.out.println(\"write int @pos=\" + (fixedArrayStart-4) + \" numArcs=\" + nodeIn.numArcs);\n      // create the header\n      // TODO: clean this up: or just rewind+reuse and deal with it\n      byte header[] = new byte[MAX_HEADER_SIZE]; \n      ByteArrayDataOutput bad = new ByteArrayDataOutput(header);\n      // write a \"false\" first arc:\n      bad.writeByte(ARCS_AS_FIXED_ARRAY);\n      bad.writeVInt(nodeIn.numArcs);\n      bad.writeVInt(maxBytesPerArc);\n      int headerLen = bad.getPosition();\n      \n      final long fixedArrayStart = startAddress + headerLen;\n\n      // expand the arcs in place, backwards\n      long srcPos = builder.bytes.getPosition();\n      long destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      assert destPos >= srcPos;\n      if (destPos > srcPos) {\n        builder.bytes.skipBytes((int) (destPos - srcPos));\n        for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n          destPos -= maxBytesPerArc;\n          srcPos -= builder.reusedBytesPerArc[arcIdx];\n          //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n          if (srcPos != destPos) {\n            //System.out.println(\"  copy len=\" + builder.reusedBytesPerArc[arcIdx]);\n            assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" reusedBytesPerArc[arcIdx]=\" + builder.reusedBytesPerArc[arcIdx] + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n            builder.bytes.copyBytes(srcPos, destPos, builder.reusedBytesPerArc[arcIdx]);\n          }\n        }\n      }\n      \n      // now write the header\n      builder.bytes.writeBytes(startAddress, header, 0, headerLen);\n    }\n\n    final long thisNodeAddress = builder.bytes.getPosition()-1;\n\n    builder.bytes.reverse(startAddress, thisNodeAddress);\n\n    // PackedInts uses int as the index, so we cannot handle\n    // > 2.1B nodes when packing:\n    if (nodeAddress != null && builder.nodeCount == Integer.MAX_VALUE) {\n      throw new IllegalStateException(\"cannot create a packed FST with more than 2.1 billion nodes\");\n    }\n\n    builder.nodeCount++;\n    final long node;\n    if (nodeAddress != null) {\n\n      // Nodes are addressed by 1+ord:\n      if ((int) builder.nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set((int) builder.nodeCount, thisNodeAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = builder.nodeCount;\n    } else {\n      node = thisNodeAddress;\n    }\n\n    //System.out.println(\"  ret node=\" + node + \" address=\" + thisNodeAddress + \" nodeAddress=\" + nodeAddress);\n    return node;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"199dfa410f1fdbfd3294106b04096cce5ed34b21","date":1478812506,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder[T],Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder[T],Builder.UnCompiledNode[T]).mjava","sourceNew":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(Builder<T> builder, Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    final long startAddress = builder.bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(builder, nodeIn);\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (builder.reusedBytesPerArc.length < nodeIn.numArcs) {\n        builder.reusedBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n    }\n\n    builder.arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = builder.bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (builder.lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      builder.bytes.writeByte((byte) flags);\n      writeLabel(builder.bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, builder.bytes);\n        //System.out.println(\"    write output\");\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, builder.bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        builder.bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        builder.reusedBytesPerArc[arcIdx] = (int) (builder.bytes.getPosition() - lastArcStart);\n        lastArcStart = builder.bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, builder.reusedBytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + builder.reusedBytesPerArc[arcIdx]);\n      }\n    }\n    \n    // TODO: try to avoid wasteful cases: disable doFixedArray in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedArray) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedArray = false;\n      }\n    }\n    */\n\n    if (doFixedArray) {\n      final int MAX_HEADER_SIZE = 11; // header(byte) + numArcs(vint) + numBytes(vint)\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n\n      //System.out.println(\"write int @pos=\" + (fixedArrayStart-4) + \" numArcs=\" + nodeIn.numArcs);\n      // create the header\n      // TODO: clean this up: or just rewind+reuse and deal with it\n      byte header[] = new byte[MAX_HEADER_SIZE]; \n      ByteArrayDataOutput bad = new ByteArrayDataOutput(header);\n      // write a \"false\" first arc:\n      bad.writeByte(ARCS_AS_FIXED_ARRAY);\n      bad.writeVInt(nodeIn.numArcs);\n      bad.writeVInt(maxBytesPerArc);\n      int headerLen = bad.getPosition();\n      \n      final long fixedArrayStart = startAddress + headerLen;\n\n      // expand the arcs in place, backwards\n      long srcPos = builder.bytes.getPosition();\n      long destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      assert destPos >= srcPos;\n      if (destPos > srcPos) {\n        builder.bytes.skipBytes((int) (destPos - srcPos));\n        for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n          destPos -= maxBytesPerArc;\n          srcPos -= builder.reusedBytesPerArc[arcIdx];\n          //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n          if (srcPos != destPos) {\n            //System.out.println(\"  copy len=\" + builder.reusedBytesPerArc[arcIdx]);\n            assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" reusedBytesPerArc[arcIdx]=\" + builder.reusedBytesPerArc[arcIdx] + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n            builder.bytes.copyBytes(srcPos, destPos, builder.reusedBytesPerArc[arcIdx]);\n          }\n        }\n      }\n      \n      // now write the header\n      builder.bytes.writeBytes(startAddress, header, 0, headerLen);\n    }\n\n    final long thisNodeAddress = builder.bytes.getPosition()-1;\n\n    builder.bytes.reverse(startAddress, thisNodeAddress);\n\n    builder.nodeCount++;\n    return thisNodeAddress;\n  }\n\n","sourceOld":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(Builder<T> builder, Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    final long startAddress = builder.bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(builder, nodeIn);\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (builder.reusedBytesPerArc.length < nodeIn.numArcs) {\n        builder.reusedBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n    }\n\n    builder.arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = builder.bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (builder.lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      } else if (inCounts != null) {\n        inCounts.set((int) target.node, inCounts.get((int) target.node) + 1);\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      builder.bytes.writeByte((byte) flags);\n      writeLabel(builder.bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, builder.bytes);\n        //System.out.println(\"    write output\");\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, builder.bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        builder.bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        builder.reusedBytesPerArc[arcIdx] = (int) (builder.bytes.getPosition() - lastArcStart);\n        lastArcStart = builder.bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, builder.reusedBytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + builder.reusedBytesPerArc[arcIdx]);\n      }\n    }\n    \n    // TODO: try to avoid wasteful cases: disable doFixedArray in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedArray) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedArray = false;\n      }\n    }\n    */\n\n    if (doFixedArray) {\n      final int MAX_HEADER_SIZE = 11; // header(byte) + numArcs(vint) + numBytes(vint)\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n\n      //System.out.println(\"write int @pos=\" + (fixedArrayStart-4) + \" numArcs=\" + nodeIn.numArcs);\n      // create the header\n      // TODO: clean this up: or just rewind+reuse and deal with it\n      byte header[] = new byte[MAX_HEADER_SIZE]; \n      ByteArrayDataOutput bad = new ByteArrayDataOutput(header);\n      // write a \"false\" first arc:\n      bad.writeByte(ARCS_AS_FIXED_ARRAY);\n      bad.writeVInt(nodeIn.numArcs);\n      bad.writeVInt(maxBytesPerArc);\n      int headerLen = bad.getPosition();\n      \n      final long fixedArrayStart = startAddress + headerLen;\n\n      // expand the arcs in place, backwards\n      long srcPos = builder.bytes.getPosition();\n      long destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      assert destPos >= srcPos;\n      if (destPos > srcPos) {\n        builder.bytes.skipBytes((int) (destPos - srcPos));\n        for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n          destPos -= maxBytesPerArc;\n          srcPos -= builder.reusedBytesPerArc[arcIdx];\n          //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n          if (srcPos != destPos) {\n            //System.out.println(\"  copy len=\" + builder.reusedBytesPerArc[arcIdx]);\n            assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" reusedBytesPerArc[arcIdx]=\" + builder.reusedBytesPerArc[arcIdx] + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n            builder.bytes.copyBytes(srcPos, destPos, builder.reusedBytesPerArc[arcIdx]);\n          }\n        }\n      }\n      \n      // now write the header\n      builder.bytes.writeBytes(startAddress, header, 0, headerLen);\n    }\n\n    final long thisNodeAddress = builder.bytes.getPosition()-1;\n\n    builder.bytes.reverse(startAddress, thisNodeAddress);\n\n    // PackedInts uses int as the index, so we cannot handle\n    // > 2.1B nodes when packing:\n    if (nodeAddress != null && builder.nodeCount == Integer.MAX_VALUE) {\n      throw new IllegalStateException(\"cannot create a packed FST with more than 2.1 billion nodes\");\n    }\n\n    builder.nodeCount++;\n    final long node;\n    if (nodeAddress != null) {\n\n      // Nodes are addressed by 1+ord:\n      if ((int) builder.nodeCount == nodeAddress.size()) {\n        nodeAddress = nodeAddress.resize(ArrayUtil.oversize(nodeAddress.size() + 1, nodeAddress.getBitsPerValue()));\n        inCounts = inCounts.resize(ArrayUtil.oversize(inCounts.size() + 1, inCounts.getBitsPerValue()));\n      }\n      nodeAddress.set((int) builder.nodeCount, thisNodeAddress);\n      // System.out.println(\"  write nodeAddress[\" + nodeCount + \"] = \" + endAddress);\n      node = builder.nodeCount;\n    } else {\n      node = thisNodeAddress;\n    }\n\n    //System.out.println(\"  ret node=\" + node + \" address=\" + thisNodeAddress + \" nodeAddress=\" + nodeAddress);\n    return node;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae67e1f82a53594208ca929f382ee861dad3d7a8","date":1557134375,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder[T],Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder[T],Builder.UnCompiledNode[T]).mjava","sourceNew":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(Builder<T> builder, Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    final long startAddress = builder.bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(builder, nodeIn);\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (builder.reusedBytesPerArc.length < nodeIn.numArcs) {\n        builder.reusedBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n    }\n\n    builder.arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = builder.bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0; arcIdx < nodeIn.numArcs; arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (builder.lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      builder.bytes.writeByte((byte) flags);\n      writeLabel(builder.bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, builder.bytes);\n        //System.out.println(\"    write output\");\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, builder.bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        builder.bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass, but record how many bytes each one took\n      // and max byte size:\n      if (doFixedArray) {\n        builder.reusedBytesPerArc[arcIdx] = (int) (builder.bytes.getPosition() - lastArcStart);\n        lastArcStart = builder.bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, builder.reusedBytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + builder.reusedBytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: try to avoid wasteful cases: disable doFixedArray in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedArray) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedArray = false;\n      }\n    }\n    */\n\n    if (doFixedArray) {\n      final int MAX_HEADER_SIZE = 11; // header(byte) + numArcs(vint) + numBytes(vint)\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed byte size\n\n      // If more than (1 / DIRECT_ARC_LOAD_FACTOR) of the \"slots\" would be occupied, write an arc\n      // array that may have holes in it so that we can address the arcs directly by label without\n      // binary search\n      int labelRange = nodeIn.arcs[nodeIn.numArcs - 1].label - nodeIn.arcs[0].label + 1;\n      boolean writeDirectly = builder.useDirectArcAddressing && labelRange > 0\n          && labelRange < Builder.DIRECT_ARC_LOAD_FACTOR * nodeIn.numArcs;\n\n      //System.out.println(\"write int @pos=\" + (fixedArrayStart-4) + \" numArcs=\" + nodeIn.numArcs);\n      // create the header\n      // TODO: clean this up: or just rewind+reuse and deal with it\n      byte header[] = new byte[MAX_HEADER_SIZE]; \n      ByteArrayDataOutput bad = new ByteArrayDataOutput(header);\n      // write a \"false\" first arc:\n      if (writeDirectly) {\n        bad.writeByte(ARCS_AS_ARRAY_WITH_GAPS);\n        bad.writeVInt(labelRange);\n      } else {\n        bad.writeByte(ARCS_AS_ARRAY_PACKED);\n        bad.writeVInt(nodeIn.numArcs);\n      }\n      bad.writeVInt(maxBytesPerArc);\n      int headerLen = bad.getPosition();\n      \n      final long fixedArrayStart = startAddress + headerLen;\n\n      if (writeDirectly) {\n        writeArrayWithGaps(builder, nodeIn, fixedArrayStart, maxBytesPerArc, labelRange);\n      } else {\n        writeArrayPacked(builder, nodeIn, fixedArrayStart, maxBytesPerArc);\n      }\n      \n      // now write the header\n      builder.bytes.writeBytes(startAddress, header, 0, headerLen);\n    }\n\n    final long thisNodeAddress = builder.bytes.getPosition()-1;\n\n    builder.bytes.reverse(startAddress, thisNodeAddress);\n\n    builder.nodeCount++;\n    return thisNodeAddress;\n  }\n\n","sourceOld":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(Builder<T> builder, Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    final long startAddress = builder.bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(builder, nodeIn);\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (builder.reusedBytesPerArc.length < nodeIn.numArcs) {\n        builder.reusedBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n    }\n\n    builder.arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = builder.bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0;arcIdx<nodeIn.numArcs;arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (builder.lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      builder.bytes.writeByte((byte) flags);\n      writeLabel(builder.bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, builder.bytes);\n        //System.out.println(\"    write output\");\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, builder.bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        builder.bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass,\n      // but record how many bytes each one took, and max\n      // byte size:\n      if (doFixedArray) {\n        builder.reusedBytesPerArc[arcIdx] = (int) (builder.bytes.getPosition() - lastArcStart);\n        lastArcStart = builder.bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, builder.reusedBytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + builder.reusedBytesPerArc[arcIdx]);\n      }\n    }\n    \n    // TODO: try to avoid wasteful cases: disable doFixedArray in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedArray) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedArray = false;\n      }\n    }\n    */\n\n    if (doFixedArray) {\n      final int MAX_HEADER_SIZE = 11; // header(byte) + numArcs(vint) + numBytes(vint)\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed\n      // byte size\n\n      //System.out.println(\"write int @pos=\" + (fixedArrayStart-4) + \" numArcs=\" + nodeIn.numArcs);\n      // create the header\n      // TODO: clean this up: or just rewind+reuse and deal with it\n      byte header[] = new byte[MAX_HEADER_SIZE]; \n      ByteArrayDataOutput bad = new ByteArrayDataOutput(header);\n      // write a \"false\" first arc:\n      bad.writeByte(ARCS_AS_FIXED_ARRAY);\n      bad.writeVInt(nodeIn.numArcs);\n      bad.writeVInt(maxBytesPerArc);\n      int headerLen = bad.getPosition();\n      \n      final long fixedArrayStart = startAddress + headerLen;\n\n      // expand the arcs in place, backwards\n      long srcPos = builder.bytes.getPosition();\n      long destPos = fixedArrayStart + nodeIn.numArcs*maxBytesPerArc;\n      assert destPos >= srcPos;\n      if (destPos > srcPos) {\n        builder.bytes.skipBytes((int) (destPos - srcPos));\n        for(int arcIdx=nodeIn.numArcs-1;arcIdx>=0;arcIdx--) {\n          destPos -= maxBytesPerArc;\n          srcPos -= builder.reusedBytesPerArc[arcIdx];\n          //System.out.println(\"  repack arcIdx=\" + arcIdx + \" srcPos=\" + srcPos + \" destPos=\" + destPos);\n          if (srcPos != destPos) {\n            //System.out.println(\"  copy len=\" + builder.reusedBytesPerArc[arcIdx]);\n            assert destPos > srcPos: \"destPos=\" + destPos + \" srcPos=\" + srcPos + \" arcIdx=\" + arcIdx + \" maxBytesPerArc=\" + maxBytesPerArc + \" reusedBytesPerArc[arcIdx]=\" + builder.reusedBytesPerArc[arcIdx] + \" nodeIn.numArcs=\" + nodeIn.numArcs;\n            builder.bytes.copyBytes(srcPos, destPos, builder.reusedBytesPerArc[arcIdx]);\n          }\n        }\n      }\n      \n      // now write the header\n      builder.bytes.writeBytes(startAddress, header, 0, headerLen);\n    }\n\n    final long thisNodeAddress = builder.bytes.getPosition()-1;\n\n    builder.bytes.reverse(startAddress, thisNodeAddress);\n\n    builder.nodeCount++;\n    return thisNodeAddress;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59a1204a92958bea883656169000a87a6c55c2d0","date":1562106073,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder[T],Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder[T],Builder.UnCompiledNode[T]).mjava","sourceNew":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(Builder<T> builder, Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    final long startAddress = builder.bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(builder, nodeIn);\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (builder.reusedBytesPerArc.length < nodeIn.numArcs) {\n        builder.reusedBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n    }\n\n    builder.arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = builder.bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0; arcIdx < nodeIn.numArcs; arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (builder.lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      builder.bytes.writeByte((byte) flags);\n      writeLabel(builder.bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, builder.bytes);\n        //System.out.println(\"    write output\");\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, builder.bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        builder.bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass, but record how many bytes each one took\n      // and max byte size:\n      if (doFixedArray) {\n        builder.reusedBytesPerArc[arcIdx] = (int) (builder.bytes.getPosition() - lastArcStart);\n        lastArcStart = builder.bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, builder.reusedBytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + builder.reusedBytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: try to avoid wasteful cases: disable doFixedArray in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedArray) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedArray = false;\n      }\n    }\n    */\n\n    if (doFixedArray) {\n      final int MAX_HEADER_SIZE = 11; // header(byte) + numArcs(vint) + numBytes(vint)\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed byte size\n\n      // If more than (1 / DIRECT_ARC_LOAD_FACTOR) of the \"slots\" would be occupied, write an arc\n      // array that may have holes in it so that we can address the arcs directly by label without\n      // binary search\n      int labelRange = nodeIn.arcs[nodeIn.numArcs - 1].label - nodeIn.arcs[0].label + 1;\n      boolean writeDirectly = labelRange > 0 && labelRange < Builder.DIRECT_ARC_LOAD_FACTOR * nodeIn.numArcs;\n\n      //System.out.println(\"write int @pos=\" + (fixedArrayStart-4) + \" numArcs=\" + nodeIn.numArcs);\n      // create the header\n      // TODO: clean this up: or just rewind+reuse and deal with it\n      byte header[] = new byte[MAX_HEADER_SIZE]; \n      ByteArrayDataOutput bad = new ByteArrayDataOutput(header);\n      // write a \"false\" first arc:\n      if (writeDirectly) {\n        bad.writeByte(ARCS_AS_ARRAY_WITH_GAPS);\n        bad.writeVInt(labelRange);\n      } else {\n        bad.writeByte(ARCS_AS_ARRAY_PACKED);\n        bad.writeVInt(nodeIn.numArcs);\n      }\n      bad.writeVInt(maxBytesPerArc);\n      int headerLen = bad.getPosition();\n      \n      final long fixedArrayStart = startAddress + headerLen;\n\n      if (writeDirectly) {\n        writeArrayWithGaps(builder, nodeIn, fixedArrayStart, maxBytesPerArc, labelRange);\n      } else {\n        writeArrayPacked(builder, nodeIn, fixedArrayStart, maxBytesPerArc);\n      }\n      \n      // now write the header\n      builder.bytes.writeBytes(startAddress, header, 0, headerLen);\n    }\n\n    final long thisNodeAddress = builder.bytes.getPosition()-1;\n\n    builder.bytes.reverse(startAddress, thisNodeAddress);\n\n    builder.nodeCount++;\n    return thisNodeAddress;\n  }\n\n","sourceOld":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(Builder<T> builder, Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    final long startAddress = builder.bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(builder, nodeIn);\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (builder.reusedBytesPerArc.length < nodeIn.numArcs) {\n        builder.reusedBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n    }\n\n    builder.arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = builder.bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0; arcIdx < nodeIn.numArcs; arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (builder.lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      builder.bytes.writeByte((byte) flags);\n      writeLabel(builder.bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, builder.bytes);\n        //System.out.println(\"    write output\");\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, builder.bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        builder.bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass, but record how many bytes each one took\n      // and max byte size:\n      if (doFixedArray) {\n        builder.reusedBytesPerArc[arcIdx] = (int) (builder.bytes.getPosition() - lastArcStart);\n        lastArcStart = builder.bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, builder.reusedBytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + builder.reusedBytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: try to avoid wasteful cases: disable doFixedArray in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedArray) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedArray = false;\n      }\n    }\n    */\n\n    if (doFixedArray) {\n      final int MAX_HEADER_SIZE = 11; // header(byte) + numArcs(vint) + numBytes(vint)\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed byte size\n\n      // If more than (1 / DIRECT_ARC_LOAD_FACTOR) of the \"slots\" would be occupied, write an arc\n      // array that may have holes in it so that we can address the arcs directly by label without\n      // binary search\n      int labelRange = nodeIn.arcs[nodeIn.numArcs - 1].label - nodeIn.arcs[0].label + 1;\n      boolean writeDirectly = builder.useDirectArcAddressing && labelRange > 0\n          && labelRange < Builder.DIRECT_ARC_LOAD_FACTOR * nodeIn.numArcs;\n\n      //System.out.println(\"write int @pos=\" + (fixedArrayStart-4) + \" numArcs=\" + nodeIn.numArcs);\n      // create the header\n      // TODO: clean this up: or just rewind+reuse and deal with it\n      byte header[] = new byte[MAX_HEADER_SIZE]; \n      ByteArrayDataOutput bad = new ByteArrayDataOutput(header);\n      // write a \"false\" first arc:\n      if (writeDirectly) {\n        bad.writeByte(ARCS_AS_ARRAY_WITH_GAPS);\n        bad.writeVInt(labelRange);\n      } else {\n        bad.writeByte(ARCS_AS_ARRAY_PACKED);\n        bad.writeVInt(nodeIn.numArcs);\n      }\n      bad.writeVInt(maxBytesPerArc);\n      int headerLen = bad.getPosition();\n      \n      final long fixedArrayStart = startAddress + headerLen;\n\n      if (writeDirectly) {\n        writeArrayWithGaps(builder, nodeIn, fixedArrayStart, maxBytesPerArc, labelRange);\n      } else {\n        writeArrayPacked(builder, nodeIn, fixedArrayStart, maxBytesPerArc);\n      }\n      \n      // now write the header\n      builder.bytes.writeBytes(startAddress, header, 0, headerLen);\n    }\n\n    final long thisNodeAddress = builder.bytes.getPosition()-1;\n\n    builder.bytes.reverse(startAddress, thisNodeAddress);\n\n    builder.nodeCount++;\n    return thisNodeAddress;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54204c8a3ca26aeafd273139fc29baf70d0f6786","date":1564170395,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder[T],Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder[T],Builder.UnCompiledNode[T]).mjava","sourceNew":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(Builder<T> builder, Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    final long startAddress = builder.bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(builder, nodeIn);\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (builder.reusedBytesPerArc.length < nodeIn.numArcs) {\n        builder.reusedBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n    }\n\n    builder.arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = builder.bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0; arcIdx < nodeIn.numArcs; arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (builder.lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      builder.bytes.writeByte((byte) flags);\n      writeLabel(builder.bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, builder.bytes);\n        //System.out.println(\"    write output\");\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, builder.bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        builder.bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass, but record how many bytes each one took\n      // and max byte size:\n      if (doFixedArray) {\n        builder.reusedBytesPerArc[arcIdx] = (int) (builder.bytes.getPosition() - lastArcStart);\n        lastArcStart = builder.bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, builder.reusedBytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + builder.reusedBytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: try to avoid wasteful cases: disable doFixedArray in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedArray) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedArray = false;\n      }\n    }\n    */\n\n    if (doFixedArray) {\n      final int MAX_HEADER_SIZE = 11; // header(byte) + numArcs(vint) + numBytes(vint)\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed byte size\n\n      // If more than (1 / DIRECT_ARC_LOAD_FACTOR) of the \"slots\" would be occupied, write an arc\n      // array that may have holes in it so that we can address the arcs directly by label without\n      // binary search\n      int labelRange = nodeIn.arcs[nodeIn.numArcs - 1].label - nodeIn.arcs[0].label + 1;\n      boolean writeDirectly = labelRange > 0 && labelRange < Builder.DIRECT_ARC_LOAD_FACTOR * nodeIn.numArcs;\n\n      //System.out.println(\"write int @pos=\" + (fixedArrayStart-4) + \" numArcs=\" + nodeIn.numArcs);\n      // create the header\n      // TODO: clean this up: or just rewind+reuse and deal with it\n      byte[] header = new byte[MAX_HEADER_SIZE];\n      ByteArrayDataOutput bad = new ByteArrayDataOutput(header);\n      // write a \"false\" first arc:\n      if (writeDirectly) {\n        bad.writeByte(ARCS_AS_ARRAY_WITH_GAPS);\n        bad.writeVInt(labelRange);\n      } else {\n        bad.writeByte(ARCS_AS_ARRAY_PACKED);\n        bad.writeVInt(nodeIn.numArcs);\n      }\n      bad.writeVInt(maxBytesPerArc);\n      int headerLen = bad.getPosition();\n      \n      final long fixedArrayStart = startAddress + headerLen;\n\n      if (writeDirectly) {\n        writeArrayWithGaps(builder, nodeIn, fixedArrayStart, maxBytesPerArc, labelRange);\n      } else {\n        writeArrayPacked(builder, nodeIn, fixedArrayStart, maxBytesPerArc);\n      }\n      \n      // now write the header\n      builder.bytes.writeBytes(startAddress, header, 0, headerLen);\n    }\n\n    final long thisNodeAddress = builder.bytes.getPosition()-1;\n\n    builder.bytes.reverse(startAddress, thisNodeAddress);\n\n    builder.nodeCount++;\n    return thisNodeAddress;\n  }\n\n","sourceOld":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(Builder<T> builder, Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    final long startAddress = builder.bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(builder, nodeIn);\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (builder.reusedBytesPerArc.length < nodeIn.numArcs) {\n        builder.reusedBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n    }\n\n    builder.arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = builder.bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0; arcIdx < nodeIn.numArcs; arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (builder.lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      builder.bytes.writeByte((byte) flags);\n      writeLabel(builder.bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, builder.bytes);\n        //System.out.println(\"    write output\");\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, builder.bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        builder.bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass, but record how many bytes each one took\n      // and max byte size:\n      if (doFixedArray) {\n        builder.reusedBytesPerArc[arcIdx] = (int) (builder.bytes.getPosition() - lastArcStart);\n        lastArcStart = builder.bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, builder.reusedBytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + builder.reusedBytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: try to avoid wasteful cases: disable doFixedArray in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedArray) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedArray = false;\n      }\n    }\n    */\n\n    if (doFixedArray) {\n      final int MAX_HEADER_SIZE = 11; // header(byte) + numArcs(vint) + numBytes(vint)\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed byte size\n\n      // If more than (1 / DIRECT_ARC_LOAD_FACTOR) of the \"slots\" would be occupied, write an arc\n      // array that may have holes in it so that we can address the arcs directly by label without\n      // binary search\n      int labelRange = nodeIn.arcs[nodeIn.numArcs - 1].label - nodeIn.arcs[0].label + 1;\n      boolean writeDirectly = labelRange > 0 && labelRange < Builder.DIRECT_ARC_LOAD_FACTOR * nodeIn.numArcs;\n\n      //System.out.println(\"write int @pos=\" + (fixedArrayStart-4) + \" numArcs=\" + nodeIn.numArcs);\n      // create the header\n      // TODO: clean this up: or just rewind+reuse and deal with it\n      byte header[] = new byte[MAX_HEADER_SIZE]; \n      ByteArrayDataOutput bad = new ByteArrayDataOutput(header);\n      // write a \"false\" first arc:\n      if (writeDirectly) {\n        bad.writeByte(ARCS_AS_ARRAY_WITH_GAPS);\n        bad.writeVInt(labelRange);\n      } else {\n        bad.writeByte(ARCS_AS_ARRAY_PACKED);\n        bad.writeVInt(nodeIn.numArcs);\n      }\n      bad.writeVInt(maxBytesPerArc);\n      int headerLen = bad.getPosition();\n      \n      final long fixedArrayStart = startAddress + headerLen;\n\n      if (writeDirectly) {\n        writeArrayWithGaps(builder, nodeIn, fixedArrayStart, maxBytesPerArc, labelRange);\n      } else {\n        writeArrayPacked(builder, nodeIn, fixedArrayStart, maxBytesPerArc);\n      }\n      \n      // now write the header\n      builder.bytes.writeBytes(startAddress, header, 0, headerLen);\n    }\n\n    final long thisNodeAddress = builder.bytes.getPosition()-1;\n\n    builder.bytes.reverse(startAddress, thisNodeAddress);\n\n    builder.nodeCount++;\n    return thisNodeAddress;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9cd2f2532659e458b6f27a7635d90f1977e99c89","date":1564491376,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder[T],Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder[T],Builder.UnCompiledNode[T]).mjava","sourceNew":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(Builder<T> builder, Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n    final long startAddress = builder.bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(builder, nodeIn);\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (builder.reusedBytesPerArc.length < nodeIn.numArcs) {\n        builder.reusedBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n    }\n\n    builder.arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = builder.bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0; arcIdx < nodeIn.numArcs; arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (builder.lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      builder.bytes.writeByte((byte) flags);\n      writeLabel(builder.bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, builder.bytes);\n        //System.out.println(\"    write output\");\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, builder.bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        builder.bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass, but record how many bytes each one took\n      // and max byte size:\n      if (doFixedArray) {\n        builder.reusedBytesPerArc[arcIdx] = (int) (builder.bytes.getPosition() - lastArcStart);\n        lastArcStart = builder.bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, builder.reusedBytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + builder.reusedBytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: try to avoid wasteful cases: disable doFixedArray in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedArray) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedArray = false;\n      }\n    }\n    */\n\n    if (doFixedArray) {\n      final int MAX_HEADER_SIZE = 11; // header(byte) + numArcs(vint) + numBytes(vint)\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed byte size\n\n      // If more than (1 / DIRECT_ARC_LOAD_FACTOR) of the \"slots\" would be occupied, write an arc\n      // array that may have holes in it so that we can address the arcs directly by label without\n      // binary search\n      int labelRange = nodeIn.arcs[nodeIn.numArcs - 1].label - nodeIn.arcs[0].label + 1;\n      boolean writeDirectly = labelRange > 0 && labelRange < Builder.DIRECT_ARC_LOAD_FACTOR * nodeIn.numArcs;\n\n      // create the header\n      // TODO: clean this up: or just rewind+reuse and deal with it\n      byte[] header = new byte[MAX_HEADER_SIZE];\n      ByteArrayDataOutput bad = new ByteArrayDataOutput(header);\n      // write a \"false\" first arc:\n      if (writeDirectly) {\n        bad.writeByte(ARCS_AS_ARRAY_WITH_GAPS);\n        bad.writeVInt(labelRange);\n      } else {\n        bad.writeByte(ARCS_AS_ARRAY_PACKED);\n        bad.writeVInt(nodeIn.numArcs);\n      }\n      bad.writeVInt(maxBytesPerArc);\n      int headerLen = bad.getPosition();\n      \n      final long fixedArrayStart = startAddress + headerLen;\n\n      if (writeDirectly) {\n        writeArrayWithGaps(builder, nodeIn, fixedArrayStart, maxBytesPerArc, labelRange);\n      } else {\n        writeArrayPacked(builder, nodeIn, fixedArrayStart, maxBytesPerArc);\n      }\n      \n      // now write the header\n      builder.bytes.writeBytes(startAddress, header, 0, headerLen);\n    }\n\n    final long thisNodeAddress = builder.bytes.getPosition()-1;\n\n    builder.bytes.reverse(startAddress, thisNodeAddress);\n\n    builder.nodeCount++;\n    return thisNodeAddress;\n  }\n\n","sourceOld":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(Builder<T> builder, Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    final long startAddress = builder.bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(builder, nodeIn);\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (builder.reusedBytesPerArc.length < nodeIn.numArcs) {\n        builder.reusedBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n    }\n\n    builder.arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = builder.bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0; arcIdx < nodeIn.numArcs; arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (builder.lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      builder.bytes.writeByte((byte) flags);\n      writeLabel(builder.bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, builder.bytes);\n        //System.out.println(\"    write output\");\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, builder.bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        builder.bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass, but record how many bytes each one took\n      // and max byte size:\n      if (doFixedArray) {\n        builder.reusedBytesPerArc[arcIdx] = (int) (builder.bytes.getPosition() - lastArcStart);\n        lastArcStart = builder.bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, builder.reusedBytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + builder.reusedBytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: try to avoid wasteful cases: disable doFixedArray in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedArray) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedArray = false;\n      }\n    }\n    */\n\n    if (doFixedArray) {\n      final int MAX_HEADER_SIZE = 11; // header(byte) + numArcs(vint) + numBytes(vint)\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed byte size\n\n      // If more than (1 / DIRECT_ARC_LOAD_FACTOR) of the \"slots\" would be occupied, write an arc\n      // array that may have holes in it so that we can address the arcs directly by label without\n      // binary search\n      int labelRange = nodeIn.arcs[nodeIn.numArcs - 1].label - nodeIn.arcs[0].label + 1;\n      boolean writeDirectly = labelRange > 0 && labelRange < Builder.DIRECT_ARC_LOAD_FACTOR * nodeIn.numArcs;\n\n      //System.out.println(\"write int @pos=\" + (fixedArrayStart-4) + \" numArcs=\" + nodeIn.numArcs);\n      // create the header\n      // TODO: clean this up: or just rewind+reuse and deal with it\n      byte[] header = new byte[MAX_HEADER_SIZE];\n      ByteArrayDataOutput bad = new ByteArrayDataOutput(header);\n      // write a \"false\" first arc:\n      if (writeDirectly) {\n        bad.writeByte(ARCS_AS_ARRAY_WITH_GAPS);\n        bad.writeVInt(labelRange);\n      } else {\n        bad.writeByte(ARCS_AS_ARRAY_PACKED);\n        bad.writeVInt(nodeIn.numArcs);\n      }\n      bad.writeVInt(maxBytesPerArc);\n      int headerLen = bad.getPosition();\n      \n      final long fixedArrayStart = startAddress + headerLen;\n\n      if (writeDirectly) {\n        writeArrayWithGaps(builder, nodeIn, fixedArrayStart, maxBytesPerArc, labelRange);\n      } else {\n        writeArrayPacked(builder, nodeIn, fixedArrayStart, maxBytesPerArc);\n      }\n      \n      // now write the header\n      builder.bytes.writeBytes(startAddress, header, 0, headerLen);\n    }\n\n    final long thisNodeAddress = builder.bytes.getPosition()-1;\n\n    builder.bytes.reverse(startAddress, thisNodeAddress);\n\n    builder.nodeCount++;\n    return thisNodeAddress;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8061ddd97f3352007d927dae445884a6f3d857b","date":1564988276,"type":3,"author":"Atri Sharma","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder[T],Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder[T],Builder.UnCompiledNode[T]).mjava","sourceNew":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(Builder<T> builder, Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n    final long startAddress = builder.bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(builder, nodeIn);\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (builder.reusedBytesPerArc.length < nodeIn.numArcs) {\n        builder.reusedBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n    }\n\n    builder.arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = builder.bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0; arcIdx < nodeIn.numArcs; arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (builder.lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      builder.bytes.writeByte((byte) flags);\n      writeLabel(builder.bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, builder.bytes);\n        //System.out.println(\"    write output\");\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, builder.bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        builder.bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass, but record how many bytes each one took\n      // and max byte size:\n      if (doFixedArray) {\n        builder.reusedBytesPerArc[arcIdx] = (int) (builder.bytes.getPosition() - lastArcStart);\n        lastArcStart = builder.bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, builder.reusedBytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + builder.reusedBytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: try to avoid wasteful cases: disable doFixedArray in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedArray) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedArray = false;\n      }\n    }\n    */\n\n    if (doFixedArray) {\n      final int MAX_HEADER_SIZE = 11; // header(byte) + numArcs(vint) + numBytes(vint)\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed byte size\n\n      // If more than (1 / DIRECT_ARC_LOAD_FACTOR) of the \"slots\" would be occupied, write an arc\n      // array that may have holes in it so that we can address the arcs directly by label without\n      // binary search\n      int labelRange = nodeIn.arcs[nodeIn.numArcs - 1].label - nodeIn.arcs[0].label + 1;\n      boolean writeDirectly = labelRange > 0 && labelRange < Builder.DIRECT_ARC_LOAD_FACTOR * nodeIn.numArcs;\n\n      // create the header\n      // TODO: clean this up: or just rewind+reuse and deal with it\n      byte[] header = new byte[MAX_HEADER_SIZE];\n      ByteArrayDataOutput bad = new ByteArrayDataOutput(header);\n      // write a \"false\" first arc:\n      if (writeDirectly) {\n        bad.writeByte(ARCS_AS_ARRAY_WITH_GAPS);\n        bad.writeVInt(labelRange);\n      } else {\n        bad.writeByte(ARCS_AS_ARRAY_PACKED);\n        bad.writeVInt(nodeIn.numArcs);\n      }\n      bad.writeVInt(maxBytesPerArc);\n      int headerLen = bad.getPosition();\n      \n      final long fixedArrayStart = startAddress + headerLen;\n\n      if (writeDirectly) {\n        writeArrayWithGaps(builder, nodeIn, fixedArrayStart, maxBytesPerArc, labelRange);\n      } else {\n        writeArrayPacked(builder, nodeIn, fixedArrayStart, maxBytesPerArc);\n      }\n      \n      // now write the header\n      builder.bytes.writeBytes(startAddress, header, 0, headerLen);\n    }\n\n    final long thisNodeAddress = builder.bytes.getPosition()-1;\n\n    builder.bytes.reverse(startAddress, thisNodeAddress);\n\n    builder.nodeCount++;\n    return thisNodeAddress;\n  }\n\n","sourceOld":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(Builder<T> builder, Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n\n    final long startAddress = builder.bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(builder, nodeIn);\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (builder.reusedBytesPerArc.length < nodeIn.numArcs) {\n        builder.reusedBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n    }\n\n    builder.arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = builder.bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0; arcIdx < nodeIn.numArcs; arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (builder.lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      builder.bytes.writeByte((byte) flags);\n      writeLabel(builder.bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, builder.bytes);\n        //System.out.println(\"    write output\");\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, builder.bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        builder.bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass, but record how many bytes each one took\n      // and max byte size:\n      if (doFixedArray) {\n        builder.reusedBytesPerArc[arcIdx] = (int) (builder.bytes.getPosition() - lastArcStart);\n        lastArcStart = builder.bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, builder.reusedBytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + builder.reusedBytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: try to avoid wasteful cases: disable doFixedArray in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedArray) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedArray = false;\n      }\n    }\n    */\n\n    if (doFixedArray) {\n      final int MAX_HEADER_SIZE = 11; // header(byte) + numArcs(vint) + numBytes(vint)\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed byte size\n\n      // If more than (1 / DIRECT_ARC_LOAD_FACTOR) of the \"slots\" would be occupied, write an arc\n      // array that may have holes in it so that we can address the arcs directly by label without\n      // binary search\n      int labelRange = nodeIn.arcs[nodeIn.numArcs - 1].label - nodeIn.arcs[0].label + 1;\n      boolean writeDirectly = labelRange > 0 && labelRange < Builder.DIRECT_ARC_LOAD_FACTOR * nodeIn.numArcs;\n\n      //System.out.println(\"write int @pos=\" + (fixedArrayStart-4) + \" numArcs=\" + nodeIn.numArcs);\n      // create the header\n      // TODO: clean this up: or just rewind+reuse and deal with it\n      byte header[] = new byte[MAX_HEADER_SIZE]; \n      ByteArrayDataOutput bad = new ByteArrayDataOutput(header);\n      // write a \"false\" first arc:\n      if (writeDirectly) {\n        bad.writeByte(ARCS_AS_ARRAY_WITH_GAPS);\n        bad.writeVInt(labelRange);\n      } else {\n        bad.writeByte(ARCS_AS_ARRAY_PACKED);\n        bad.writeVInt(nodeIn.numArcs);\n      }\n      bad.writeVInt(maxBytesPerArc);\n      int headerLen = bad.getPosition();\n      \n      final long fixedArrayStart = startAddress + headerLen;\n\n      if (writeDirectly) {\n        writeArrayWithGaps(builder, nodeIn, fixedArrayStart, maxBytesPerArc, labelRange);\n      } else {\n        writeArrayPacked(builder, nodeIn, fixedArrayStart, maxBytesPerArc);\n      }\n      \n      // now write the header\n      builder.bytes.writeBytes(startAddress, header, 0, headerLen);\n    }\n\n    final long thisNodeAddress = builder.bytes.getPosition()-1;\n\n    builder.bytes.reverse(startAddress, thisNodeAddress);\n\n    builder.nodeCount++;\n    return thisNodeAddress;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e19a701ad1d5fd2dd25e0f79bb5d81df864116b","date":1571070636,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder[T],Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder[T],Builder.UnCompiledNode[T]).mjava","sourceNew":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(Builder<T> builder, Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n    final long startAddress = builder.bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(builder, nodeIn);\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (builder.reusedBytesPerArc.length < nodeIn.numArcs) {\n        builder.reusedBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n    }\n\n    builder.arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = builder.bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0; arcIdx < nodeIn.numArcs; arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (builder.lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      builder.bytes.writeByte((byte) flags);\n      writeLabel(builder.bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, builder.bytes);\n        //System.out.println(\"    write output\");\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, builder.bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        builder.bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass, but record how many bytes each one took\n      // and max byte size:\n      if (doFixedArray) {\n        builder.reusedBytesPerArc[arcIdx] = (int) (builder.bytes.getPosition() - lastArcStart);\n        lastArcStart = builder.bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, builder.reusedBytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + builder.reusedBytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: try to avoid wasteful cases: disable doFixedArray in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedArray) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedArray = false;\n      }\n    }\n    */\n\n    if (doFixedArray) {\n      final int MAX_HEADER_SIZE = 11; // header(byte) + numArcs(vint) + numBytes(vint)\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed byte size\n\n      // create the header\n      // TODO: clean this up: or just rewind+reuse and deal with it\n      byte[] header = new byte[MAX_HEADER_SIZE];\n      ByteArrayDataOutput bad = new ByteArrayDataOutput(header);\n      // write a \"false\" first arc:\n      bad.writeByte(ARCS_AS_ARRAY_PACKED);\n      bad.writeVInt(nodeIn.numArcs);\n      bad.writeVInt(maxBytesPerArc);\n      int headerLen = bad.getPosition();\n      \n      final long fixedArrayStart = startAddress + headerLen;\n\n      writeArrayPacked(builder, nodeIn, fixedArrayStart, maxBytesPerArc);\n      \n      // now write the header\n      builder.bytes.writeBytes(startAddress, header, 0, headerLen);\n    }\n\n    final long thisNodeAddress = builder.bytes.getPosition()-1;\n\n    builder.bytes.reverse(startAddress, thisNodeAddress);\n\n    builder.nodeCount++;\n    return thisNodeAddress;\n  }\n\n","sourceOld":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(Builder<T> builder, Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n    final long startAddress = builder.bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(builder, nodeIn);\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (builder.reusedBytesPerArc.length < nodeIn.numArcs) {\n        builder.reusedBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n    }\n\n    builder.arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = builder.bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0; arcIdx < nodeIn.numArcs; arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (builder.lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      builder.bytes.writeByte((byte) flags);\n      writeLabel(builder.bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, builder.bytes);\n        //System.out.println(\"    write output\");\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, builder.bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        builder.bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass, but record how many bytes each one took\n      // and max byte size:\n      if (doFixedArray) {\n        builder.reusedBytesPerArc[arcIdx] = (int) (builder.bytes.getPosition() - lastArcStart);\n        lastArcStart = builder.bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, builder.reusedBytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + builder.reusedBytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: try to avoid wasteful cases: disable doFixedArray in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedArray) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedArray = false;\n      }\n    }\n    */\n\n    if (doFixedArray) {\n      final int MAX_HEADER_SIZE = 11; // header(byte) + numArcs(vint) + numBytes(vint)\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed byte size\n\n      // If more than (1 / DIRECT_ARC_LOAD_FACTOR) of the \"slots\" would be occupied, write an arc\n      // array that may have holes in it so that we can address the arcs directly by label without\n      // binary search\n      int labelRange = nodeIn.arcs[nodeIn.numArcs - 1].label - nodeIn.arcs[0].label + 1;\n      boolean writeDirectly = labelRange > 0 && labelRange < Builder.DIRECT_ARC_LOAD_FACTOR * nodeIn.numArcs;\n\n      // create the header\n      // TODO: clean this up: or just rewind+reuse and deal with it\n      byte[] header = new byte[MAX_HEADER_SIZE];\n      ByteArrayDataOutput bad = new ByteArrayDataOutput(header);\n      // write a \"false\" first arc:\n      if (writeDirectly) {\n        bad.writeByte(ARCS_AS_ARRAY_WITH_GAPS);\n        bad.writeVInt(labelRange);\n      } else {\n        bad.writeByte(ARCS_AS_ARRAY_PACKED);\n        bad.writeVInt(nodeIn.numArcs);\n      }\n      bad.writeVInt(maxBytesPerArc);\n      int headerLen = bad.getPosition();\n      \n      final long fixedArrayStart = startAddress + headerLen;\n\n      if (writeDirectly) {\n        writeArrayWithGaps(builder, nodeIn, fixedArrayStart, maxBytesPerArc, labelRange);\n      } else {\n        writeArrayPacked(builder, nodeIn, fixedArrayStart, maxBytesPerArc);\n      }\n      \n      // now write the header\n      builder.bytes.writeBytes(startAddress, header, 0, headerLen);\n    }\n\n    final long thisNodeAddress = builder.bytes.getPosition()-1;\n\n    builder.bytes.reverse(startAddress, thisNodeAddress);\n\n    builder.nodeCount++;\n    return thisNodeAddress;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder[T],Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder[T],Builder.UnCompiledNode[T]).mjava","sourceNew":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(Builder<T> builder, Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n    final long startAddress = builder.bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(builder, nodeIn);\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (builder.reusedBytesPerArc.length < nodeIn.numArcs) {\n        builder.reusedBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n    }\n\n    builder.arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = builder.bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0; arcIdx < nodeIn.numArcs; arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (builder.lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      builder.bytes.writeByte((byte) flags);\n      writeLabel(builder.bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, builder.bytes);\n        //System.out.println(\"    write output\");\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, builder.bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        builder.bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass, but record how many bytes each one took\n      // and max byte size:\n      if (doFixedArray) {\n        builder.reusedBytesPerArc[arcIdx] = (int) (builder.bytes.getPosition() - lastArcStart);\n        lastArcStart = builder.bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, builder.reusedBytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + builder.reusedBytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: try to avoid wasteful cases: disable doFixedArray in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedArray) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedArray = false;\n      }\n    }\n    */\n\n    if (doFixedArray) {\n      final int MAX_HEADER_SIZE = 11; // header(byte) + numArcs(vint) + numBytes(vint)\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed byte size\n\n      // create the header\n      // TODO: clean this up: or just rewind+reuse and deal with it\n      byte[] header = new byte[MAX_HEADER_SIZE];\n      ByteArrayDataOutput bad = new ByteArrayDataOutput(header);\n      // write a \"false\" first arc:\n      bad.writeByte(ARCS_AS_ARRAY_PACKED);\n      bad.writeVInt(nodeIn.numArcs);\n      bad.writeVInt(maxBytesPerArc);\n      int headerLen = bad.getPosition();\n      \n      final long fixedArrayStart = startAddress + headerLen;\n\n      writeArrayPacked(builder, nodeIn, fixedArrayStart, maxBytesPerArc);\n      \n      // now write the header\n      builder.bytes.writeBytes(startAddress, header, 0, headerLen);\n    }\n\n    final long thisNodeAddress = builder.bytes.getPosition()-1;\n\n    builder.bytes.reverse(startAddress, thisNodeAddress);\n\n    builder.nodeCount++;\n    return thisNodeAddress;\n  }\n\n","sourceOld":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(Builder<T> builder, Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n    final long startAddress = builder.bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(builder, nodeIn);\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (builder.reusedBytesPerArc.length < nodeIn.numArcs) {\n        builder.reusedBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n    }\n\n    builder.arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = builder.bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0; arcIdx < nodeIn.numArcs; arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (builder.lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      builder.bytes.writeByte((byte) flags);\n      writeLabel(builder.bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, builder.bytes);\n        //System.out.println(\"    write output\");\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, builder.bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        builder.bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass, but record how many bytes each one took\n      // and max byte size:\n      if (doFixedArray) {\n        builder.reusedBytesPerArc[arcIdx] = (int) (builder.bytes.getPosition() - lastArcStart);\n        lastArcStart = builder.bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, builder.reusedBytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + builder.reusedBytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: try to avoid wasteful cases: disable doFixedArray in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedArray) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedArray = false;\n      }\n    }\n    */\n\n    if (doFixedArray) {\n      final int MAX_HEADER_SIZE = 11; // header(byte) + numArcs(vint) + numBytes(vint)\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed byte size\n\n      // If more than (1 / DIRECT_ARC_LOAD_FACTOR) of the \"slots\" would be occupied, write an arc\n      // array that may have holes in it so that we can address the arcs directly by label without\n      // binary search\n      int labelRange = nodeIn.arcs[nodeIn.numArcs - 1].label - nodeIn.arcs[0].label + 1;\n      boolean writeDirectly = labelRange > 0 && labelRange < Builder.DIRECT_ARC_LOAD_FACTOR * nodeIn.numArcs;\n\n      // create the header\n      // TODO: clean this up: or just rewind+reuse and deal with it\n      byte[] header = new byte[MAX_HEADER_SIZE];\n      ByteArrayDataOutput bad = new ByteArrayDataOutput(header);\n      // write a \"false\" first arc:\n      if (writeDirectly) {\n        bad.writeByte(ARCS_AS_ARRAY_WITH_GAPS);\n        bad.writeVInt(labelRange);\n      } else {\n        bad.writeByte(ARCS_AS_ARRAY_PACKED);\n        bad.writeVInt(nodeIn.numArcs);\n      }\n      bad.writeVInt(maxBytesPerArc);\n      int headerLen = bad.getPosition();\n      \n      final long fixedArrayStart = startAddress + headerLen;\n\n      if (writeDirectly) {\n        writeArrayWithGaps(builder, nodeIn, fixedArrayStart, maxBytesPerArc, labelRange);\n      } else {\n        writeArrayPacked(builder, nodeIn, fixedArrayStart, maxBytesPerArc);\n      }\n      \n      // now write the header\n      builder.bytes.writeBytes(startAddress, header, 0, headerLen);\n    }\n\n    final long thisNodeAddress = builder.bytes.getPosition()-1;\n\n    builder.bytes.reverse(startAddress, thisNodeAddress);\n\n    builder.nodeCount++;\n    return thisNodeAddress;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"71d31a7d5773508492505519bb5230b87c8937ad","date":1573681693,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder[T],Builder.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder[T],Builder.UnCompiledNode[T]).mjava","sourceNew":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(Builder<T> builder, Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n    final long startAddress = builder.bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedLengthArcs = shouldExpandNodeWithFixedLengthArcs(builder, nodeIn);\n    if (doFixedLengthArcs) {\n      //System.out.println(\"  fixed length arcs\");\n      if (builder.numBytesPerArc.length < nodeIn.numArcs) {\n        builder.numBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, Integer.BYTES)];\n        builder.numLabelBytesPerArc = new int[builder.numBytesPerArc.length];\n      }\n    }\n\n    builder.arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = builder.bytes.getPosition();\n    int maxBytesPerArc = 0;\n    int maxBytesPerArcWithoutLabel = 0;\n    for(int arcIdx=0; arcIdx < nodeIn.numArcs; arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (builder.lastFrozenNode == target.node && !doFixedLengthArcs) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      builder.bytes.writeByte((byte) flags);\n      long labelStart = builder.bytes.getPosition();\n      writeLabel(builder.bytes, arc.label);\n      int numLabelBytes = (int) (builder.bytes.getPosition() - labelStart);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, builder.bytes);\n        //System.out.println(\"    write output\");\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, builder.bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        builder.bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass, but record how many bytes each one took\n      // and max byte size:\n      if (doFixedLengthArcs) {\n        int numArcBytes = (int) (builder.bytes.getPosition() - lastArcStart);\n        builder.numBytesPerArc[arcIdx] = numArcBytes;\n        builder.numLabelBytesPerArc[arcIdx] = numLabelBytes;\n        lastArcStart = builder.bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, numArcBytes);\n        maxBytesPerArcWithoutLabel = Math.max(maxBytesPerArcWithoutLabel, numArcBytes - numLabelBytes);\n        //System.out.println(\"    arcBytes=\" + numArcBytes + \" labelBytes=\" + numLabelBytes);\n      }\n    }\n\n    // TODO: try to avoid wasteful cases: disable doFixedLengthArcs in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedLengthArcs) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedLengthArcs = false;\n      }\n    }\n    */\n\n    if (doFixedLengthArcs) {\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed byte size\n\n      int labelRange = nodeIn.arcs[nodeIn.numArcs - 1].label - nodeIn.arcs[0].label + 1;\n      assert labelRange > 0;\n      if (shouldExpandNodeWithDirectAddressing(builder, nodeIn, maxBytesPerArc, maxBytesPerArcWithoutLabel, labelRange)) {\n        writeNodeForDirectAddressing(builder, nodeIn, startAddress, maxBytesPerArcWithoutLabel, labelRange);\n        builder.directAddressingNodeCount++;\n      } else {\n        writeNodeForBinarySearch(builder, nodeIn, startAddress, maxBytesPerArc);\n        builder.binarySearchNodeCount++;\n      }\n    }\n\n    final long thisNodeAddress = builder.bytes.getPosition()-1;\n    builder.bytes.reverse(startAddress, thisNodeAddress);\n    builder.nodeCount++;\n    return thisNodeAddress;\n  }\n\n","sourceOld":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(Builder<T> builder, Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n    final long startAddress = builder.bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedArray = shouldExpand(builder, nodeIn);\n    if (doFixedArray) {\n      //System.out.println(\"  fixedArray\");\n      if (builder.reusedBytesPerArc.length < nodeIn.numArcs) {\n        builder.reusedBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, 1)];\n      }\n    }\n\n    builder.arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = builder.bytes.getPosition();\n    int maxBytesPerArc = 0;\n    for(int arcIdx=0; arcIdx < nodeIn.numArcs; arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (builder.lastFrozenNode == target.node && !doFixedArray) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      builder.bytes.writeByte((byte) flags);\n      writeLabel(builder.bytes, arc.label);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, builder.bytes);\n        //System.out.println(\"    write output\");\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, builder.bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        builder.bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass, but record how many bytes each one took\n      // and max byte size:\n      if (doFixedArray) {\n        builder.reusedBytesPerArc[arcIdx] = (int) (builder.bytes.getPosition() - lastArcStart);\n        lastArcStart = builder.bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, builder.reusedBytesPerArc[arcIdx]);\n        //System.out.println(\"    bytes=\" + builder.reusedBytesPerArc[arcIdx]);\n      }\n    }\n\n    // TODO: try to avoid wasteful cases: disable doFixedArray in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedArray) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedArray = false;\n      }\n    }\n    */\n\n    if (doFixedArray) {\n      final int MAX_HEADER_SIZE = 11; // header(byte) + numArcs(vint) + numBytes(vint)\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed byte size\n\n      // create the header\n      // TODO: clean this up: or just rewind+reuse and deal with it\n      byte[] header = new byte[MAX_HEADER_SIZE];\n      ByteArrayDataOutput bad = new ByteArrayDataOutput(header);\n      // write a \"false\" first arc:\n      bad.writeByte(ARCS_AS_ARRAY_PACKED);\n      bad.writeVInt(nodeIn.numArcs);\n      bad.writeVInt(maxBytesPerArc);\n      int headerLen = bad.getPosition();\n      \n      final long fixedArrayStart = startAddress + headerLen;\n\n      writeArrayPacked(builder, nodeIn, fixedArrayStart, maxBytesPerArc);\n      \n      // now write the header\n      builder.bytes.writeBytes(startAddress, header, 0, headerLen);\n    }\n\n    final long thisNodeAddress = builder.bytes.getPosition()-1;\n\n    builder.bytes.reverse(startAddress, thisNodeAddress);\n\n    builder.nodeCount++;\n    return thisNodeAddress;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f5661e6a04d3172e262ad741b717924f2f1b6a5","date":1576244274,"type":5,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(FSTCompiler[T],FSTCompiler.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder[T],Builder.UnCompiledNode[T]).mjava","sourceNew":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(FSTCompiler<T> fstCompiler, FSTCompiler.UnCompiledNode<T> nodeIn) throws IOException {\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n    final long startAddress = fstCompiler.bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedLengthArcs = shouldExpandNodeWithFixedLengthArcs(fstCompiler, nodeIn);\n    if (doFixedLengthArcs) {\n      //System.out.println(\"  fixed length arcs\");\n      if (fstCompiler.numBytesPerArc.length < nodeIn.numArcs) {\n        fstCompiler.numBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, Integer.BYTES)];\n        fstCompiler.numLabelBytesPerArc = new int[fstCompiler.numBytesPerArc.length];\n      }\n    }\n\n    fstCompiler.arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = fstCompiler.bytes.getPosition();\n    int maxBytesPerArc = 0;\n    int maxBytesPerArcWithoutLabel = 0;\n    for(int arcIdx=0; arcIdx < nodeIn.numArcs; arcIdx++) {\n      final FSTCompiler.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final FSTCompiler.CompiledNode target = (FSTCompiler.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (fstCompiler.lastFrozenNode == target.node && !doFixedLengthArcs) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      fstCompiler.bytes.writeByte((byte) flags);\n      long labelStart = fstCompiler.bytes.getPosition();\n      writeLabel(fstCompiler.bytes, arc.label);\n      int numLabelBytes = (int) (fstCompiler.bytes.getPosition() - labelStart);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, fstCompiler.bytes);\n        //System.out.println(\"    write output\");\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, fstCompiler.bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        fstCompiler.bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass, but record how many bytes each one took\n      // and max byte size:\n      if (doFixedLengthArcs) {\n        int numArcBytes = (int) (fstCompiler.bytes.getPosition() - lastArcStart);\n        fstCompiler.numBytesPerArc[arcIdx] = numArcBytes;\n        fstCompiler.numLabelBytesPerArc[arcIdx] = numLabelBytes;\n        lastArcStart = fstCompiler.bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, numArcBytes);\n        maxBytesPerArcWithoutLabel = Math.max(maxBytesPerArcWithoutLabel, numArcBytes - numLabelBytes);\n        //System.out.println(\"    arcBytes=\" + numArcBytes + \" labelBytes=\" + numLabelBytes);\n      }\n    }\n\n    // TODO: try to avoid wasteful cases: disable doFixedLengthArcs in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedLengthArcs) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedLengthArcs = false;\n      }\n    }\n    */\n\n    if (doFixedLengthArcs) {\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed byte size\n\n      int labelRange = nodeIn.arcs[nodeIn.numArcs - 1].label - nodeIn.arcs[0].label + 1;\n      assert labelRange > 0;\n      if (shouldExpandNodeWithDirectAddressing(fstCompiler, nodeIn, maxBytesPerArc, maxBytesPerArcWithoutLabel, labelRange)) {\n        writeNodeForDirectAddressing(fstCompiler, nodeIn, startAddress, maxBytesPerArcWithoutLabel, labelRange);\n        fstCompiler.directAddressingNodeCount++;\n      } else {\n        writeNodeForBinarySearch(fstCompiler, nodeIn, startAddress, maxBytesPerArc);\n        fstCompiler.binarySearchNodeCount++;\n      }\n    }\n\n    final long thisNodeAddress = fstCompiler.bytes.getPosition()-1;\n    fstCompiler.bytes.reverse(startAddress, thisNodeAddress);\n    fstCompiler.nodeCount++;\n    return thisNodeAddress;\n  }\n\n","sourceOld":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(Builder<T> builder, Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n    final long startAddress = builder.bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedLengthArcs = shouldExpandNodeWithFixedLengthArcs(builder, nodeIn);\n    if (doFixedLengthArcs) {\n      //System.out.println(\"  fixed length arcs\");\n      if (builder.numBytesPerArc.length < nodeIn.numArcs) {\n        builder.numBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, Integer.BYTES)];\n        builder.numLabelBytesPerArc = new int[builder.numBytesPerArc.length];\n      }\n    }\n\n    builder.arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = builder.bytes.getPosition();\n    int maxBytesPerArc = 0;\n    int maxBytesPerArcWithoutLabel = 0;\n    for(int arcIdx=0; arcIdx < nodeIn.numArcs; arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (builder.lastFrozenNode == target.node && !doFixedLengthArcs) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      builder.bytes.writeByte((byte) flags);\n      long labelStart = builder.bytes.getPosition();\n      writeLabel(builder.bytes, arc.label);\n      int numLabelBytes = (int) (builder.bytes.getPosition() - labelStart);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, builder.bytes);\n        //System.out.println(\"    write output\");\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, builder.bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        builder.bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass, but record how many bytes each one took\n      // and max byte size:\n      if (doFixedLengthArcs) {\n        int numArcBytes = (int) (builder.bytes.getPosition() - lastArcStart);\n        builder.numBytesPerArc[arcIdx] = numArcBytes;\n        builder.numLabelBytesPerArc[arcIdx] = numLabelBytes;\n        lastArcStart = builder.bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, numArcBytes);\n        maxBytesPerArcWithoutLabel = Math.max(maxBytesPerArcWithoutLabel, numArcBytes - numLabelBytes);\n        //System.out.println(\"    arcBytes=\" + numArcBytes + \" labelBytes=\" + numLabelBytes);\n      }\n    }\n\n    // TODO: try to avoid wasteful cases: disable doFixedLengthArcs in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedLengthArcs) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedLengthArcs = false;\n      }\n    }\n    */\n\n    if (doFixedLengthArcs) {\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed byte size\n\n      int labelRange = nodeIn.arcs[nodeIn.numArcs - 1].label - nodeIn.arcs[0].label + 1;\n      assert labelRange > 0;\n      if (shouldExpandNodeWithDirectAddressing(builder, nodeIn, maxBytesPerArc, maxBytesPerArcWithoutLabel, labelRange)) {\n        writeNodeForDirectAddressing(builder, nodeIn, startAddress, maxBytesPerArcWithoutLabel, labelRange);\n        builder.directAddressingNodeCount++;\n      } else {\n        writeNodeForBinarySearch(builder, nodeIn, startAddress, maxBytesPerArc);\n        builder.binarySearchNodeCount++;\n      }\n    }\n\n    final long thisNodeAddress = builder.bytes.getPosition()-1;\n    builder.bytes.reverse(startAddress, thisNodeAddress);\n    builder.nodeCount++;\n    return thisNodeAddress;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","date":1576247714,"type":5,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(FSTCompiler[T],FSTCompiler.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder[T],Builder.UnCompiledNode[T]).mjava","sourceNew":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(FSTCompiler<T> fstCompiler, FSTCompiler.UnCompiledNode<T> nodeIn) throws IOException {\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n    final long startAddress = fstCompiler.bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedLengthArcs = shouldExpandNodeWithFixedLengthArcs(fstCompiler, nodeIn);\n    if (doFixedLengthArcs) {\n      //System.out.println(\"  fixed length arcs\");\n      if (fstCompiler.numBytesPerArc.length < nodeIn.numArcs) {\n        fstCompiler.numBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, Integer.BYTES)];\n        fstCompiler.numLabelBytesPerArc = new int[fstCompiler.numBytesPerArc.length];\n      }\n    }\n\n    fstCompiler.arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = fstCompiler.bytes.getPosition();\n    int maxBytesPerArc = 0;\n    int maxBytesPerArcWithoutLabel = 0;\n    for(int arcIdx=0; arcIdx < nodeIn.numArcs; arcIdx++) {\n      final FSTCompiler.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final FSTCompiler.CompiledNode target = (FSTCompiler.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (fstCompiler.lastFrozenNode == target.node && !doFixedLengthArcs) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      fstCompiler.bytes.writeByte((byte) flags);\n      long labelStart = fstCompiler.bytes.getPosition();\n      writeLabel(fstCompiler.bytes, arc.label);\n      int numLabelBytes = (int) (fstCompiler.bytes.getPosition() - labelStart);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, fstCompiler.bytes);\n        //System.out.println(\"    write output\");\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, fstCompiler.bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        fstCompiler.bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass, but record how many bytes each one took\n      // and max byte size:\n      if (doFixedLengthArcs) {\n        int numArcBytes = (int) (fstCompiler.bytes.getPosition() - lastArcStart);\n        fstCompiler.numBytesPerArc[arcIdx] = numArcBytes;\n        fstCompiler.numLabelBytesPerArc[arcIdx] = numLabelBytes;\n        lastArcStart = fstCompiler.bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, numArcBytes);\n        maxBytesPerArcWithoutLabel = Math.max(maxBytesPerArcWithoutLabel, numArcBytes - numLabelBytes);\n        //System.out.println(\"    arcBytes=\" + numArcBytes + \" labelBytes=\" + numLabelBytes);\n      }\n    }\n\n    // TODO: try to avoid wasteful cases: disable doFixedLengthArcs in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedLengthArcs) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedLengthArcs = false;\n      }\n    }\n    */\n\n    if (doFixedLengthArcs) {\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed byte size\n\n      int labelRange = nodeIn.arcs[nodeIn.numArcs - 1].label - nodeIn.arcs[0].label + 1;\n      assert labelRange > 0;\n      if (shouldExpandNodeWithDirectAddressing(fstCompiler, nodeIn, maxBytesPerArc, maxBytesPerArcWithoutLabel, labelRange)) {\n        writeNodeForDirectAddressing(fstCompiler, nodeIn, startAddress, maxBytesPerArcWithoutLabel, labelRange);\n        fstCompiler.directAddressingNodeCount++;\n      } else {\n        writeNodeForBinarySearch(fstCompiler, nodeIn, startAddress, maxBytesPerArc);\n        fstCompiler.binarySearchNodeCount++;\n      }\n    }\n\n    final long thisNodeAddress = fstCompiler.bytes.getPosition()-1;\n    fstCompiler.bytes.reverse(startAddress, thisNodeAddress);\n    fstCompiler.nodeCount++;\n    return thisNodeAddress;\n  }\n\n","sourceOld":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(Builder<T> builder, Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n    final long startAddress = builder.bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedLengthArcs = shouldExpandNodeWithFixedLengthArcs(builder, nodeIn);\n    if (doFixedLengthArcs) {\n      //System.out.println(\"  fixed length arcs\");\n      if (builder.numBytesPerArc.length < nodeIn.numArcs) {\n        builder.numBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, Integer.BYTES)];\n        builder.numLabelBytesPerArc = new int[builder.numBytesPerArc.length];\n      }\n    }\n\n    builder.arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = builder.bytes.getPosition();\n    int maxBytesPerArc = 0;\n    int maxBytesPerArcWithoutLabel = 0;\n    for(int arcIdx=0; arcIdx < nodeIn.numArcs; arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (builder.lastFrozenNode == target.node && !doFixedLengthArcs) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      builder.bytes.writeByte((byte) flags);\n      long labelStart = builder.bytes.getPosition();\n      writeLabel(builder.bytes, arc.label);\n      int numLabelBytes = (int) (builder.bytes.getPosition() - labelStart);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, builder.bytes);\n        //System.out.println(\"    write output\");\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, builder.bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        builder.bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass, but record how many bytes each one took\n      // and max byte size:\n      if (doFixedLengthArcs) {\n        int numArcBytes = (int) (builder.bytes.getPosition() - lastArcStart);\n        builder.numBytesPerArc[arcIdx] = numArcBytes;\n        builder.numLabelBytesPerArc[arcIdx] = numLabelBytes;\n        lastArcStart = builder.bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, numArcBytes);\n        maxBytesPerArcWithoutLabel = Math.max(maxBytesPerArcWithoutLabel, numArcBytes - numLabelBytes);\n        //System.out.println(\"    arcBytes=\" + numArcBytes + \" labelBytes=\" + numLabelBytes);\n      }\n    }\n\n    // TODO: try to avoid wasteful cases: disable doFixedLengthArcs in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedLengthArcs) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedLengthArcs = false;\n      }\n    }\n    */\n\n    if (doFixedLengthArcs) {\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed byte size\n\n      int labelRange = nodeIn.arcs[nodeIn.numArcs - 1].label - nodeIn.arcs[0].label + 1;\n      assert labelRange > 0;\n      if (shouldExpandNodeWithDirectAddressing(builder, nodeIn, maxBytesPerArc, maxBytesPerArcWithoutLabel, labelRange)) {\n        writeNodeForDirectAddressing(builder, nodeIn, startAddress, maxBytesPerArcWithoutLabel, labelRange);\n        builder.directAddressingNodeCount++;\n      } else {\n        writeNodeForBinarySearch(builder, nodeIn, startAddress, maxBytesPerArc);\n        builder.binarySearchNodeCount++;\n      }\n    }\n\n    final long thisNodeAddress = builder.bytes.getPosition()-1;\n    builder.bytes.reverse(startAddress, thisNodeAddress);\n    builder.nodeCount++;\n    return thisNodeAddress;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1abb939fb41b2fe4f89fd518f3da288c0213341d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6244579a467d5f2673ac98265d74bddbea1a8114":["1abb939fb41b2fe4f89fd518f3da288c0213341d"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":["1abb939fb41b2fe4f89fd518f3da288c0213341d","6244579a467d5f2673ac98265d74bddbea1a8114"],"71d31a7d5773508492505519bb5230b87c8937ad":["3e19a701ad1d5fd2dd25e0f79bb5d81df864116b"],"ae67e1f82a53594208ca929f382ee861dad3d7a8":["6244579a467d5f2673ac98265d74bddbea1a8114"],"f8061ddd97f3352007d927dae445884a6f3d857b":["59a1204a92958bea883656169000a87a6c55c2d0","9cd2f2532659e458b6f27a7635d90f1977e99c89"],"54204c8a3ca26aeafd273139fc29baf70d0f6786":["59a1204a92958bea883656169000a87a6c55c2d0"],"59a1204a92958bea883656169000a87a6c55c2d0":["ae67e1f82a53594208ca929f382ee861dad3d7a8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3e19a701ad1d5fd2dd25e0f79bb5d81df864116b":["9cd2f2532659e458b6f27a7635d90f1977e99c89"],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":["71d31a7d5773508492505519bb5230b87c8937ad","0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["71d31a7d5773508492505519bb5230b87c8937ad"],"9cd2f2532659e458b6f27a7635d90f1977e99c89":["54204c8a3ca26aeafd273139fc29baf70d0f6786"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"b0b597c65628ca9e73913a07e81691f8229bae35":["9cd2f2532659e458b6f27a7635d90f1977e99c89","3e19a701ad1d5fd2dd25e0f79bb5d81df864116b"]},"commit2Childs":{"1abb939fb41b2fe4f89fd518f3da288c0213341d":["6244579a467d5f2673ac98265d74bddbea1a8114","199dfa410f1fdbfd3294106b04096cce5ed34b21"],"6244579a467d5f2673ac98265d74bddbea1a8114":["199dfa410f1fdbfd3294106b04096cce5ed34b21","ae67e1f82a53594208ca929f382ee861dad3d7a8"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":[],"71d31a7d5773508492505519bb5230b87c8937ad":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"ae67e1f82a53594208ca929f382ee861dad3d7a8":["59a1204a92958bea883656169000a87a6c55c2d0"],"f8061ddd97f3352007d927dae445884a6f3d857b":[],"59a1204a92958bea883656169000a87a6c55c2d0":["f8061ddd97f3352007d927dae445884a6f3d857b","54204c8a3ca26aeafd273139fc29baf70d0f6786"],"54204c8a3ca26aeafd273139fc29baf70d0f6786":["9cd2f2532659e458b6f27a7635d90f1977e99c89"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1abb939fb41b2fe4f89fd518f3da288c0213341d"],"3e19a701ad1d5fd2dd25e0f79bb5d81df864116b":["71d31a7d5773508492505519bb5230b87c8937ad","b0b597c65628ca9e73913a07e81691f8229bae35"],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":[],"9cd2f2532659e458b6f27a7635d90f1977e99c89":["f8061ddd97f3352007d927dae445884a6f3d857b","3e19a701ad1d5fd2dd25e0f79bb5d81df864116b","b0b597c65628ca9e73913a07e81691f8229bae35"],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["199dfa410f1fdbfd3294106b04096cce5ed34b21","f8061ddd97f3352007d927dae445884a6f3d857b","c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}