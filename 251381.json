{"path":"solr/core/src/test/org/apache/solr/cloud/AssignTest#testIdIsUnique().mjava","commits":[{"id":"9f100e4a037a938ee4b027674f1ca80fc208badf","date":1500526196,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AssignTest#testIdIsUnique().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testIdIsUnique() throws Exception {\n    String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    ZkTestServer server = new ZkTestServer(zkDir);\n    Object fixedValue = new Object();\n    String[] collections = new String[]{\"c1\",\"c2\",\"c3\",\"c4\",\"c5\",\"c6\",\"c7\",\"c8\",\"c9\"};\n    Map<String, ConcurrentHashMap<Integer, Object>> collectionUniqueIds = new HashMap<>();\n    for (String c : collections) {\n      collectionUniqueIds.put(c, new ConcurrentHashMap<>());\n    }\n\n    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n    try {\n      server.run();\n\n      try (SolrZkClient zkClient = new SolrZkClient(server.getZkAddress(), 10000)) {\n        assertTrue(zkClient.isConnected());\n        zkClient.makePath(\"/\", true);\n        for (String c : collections) {\n          zkClient.makePath(\"/collections/\"+c, true);\n        }\n        List<Future<?>> futures = new ArrayList<>();\n        for (int i = 0; i < 1000; i++) {\n          futures.add(executor.submit(() -> {\n            String collection = collections[random().nextInt(collections.length)];\n            int id = Assign.incAndGetId(zkClient, collection);\n            Object val = collectionUniqueIds.get(collection).put(id, fixedValue);\n            if (val != null) {\n              fail(\"ZkController do not generate unique id for \" + collection);\n            }\n          }));\n        }\n        for (Future<?> future : futures) {\n          future.get();\n        }\n      }\n      assertEquals(1000, (long) collectionUniqueIds.values().stream()\n          .map(ConcurrentHashMap::size)\n          .reduce((m1, m2) -> m1 + m2).get());\n    } finally {\n      server.shutdown();\n      ExecutorUtil.shutdownAndAwaitTermination(executor);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"651c3ddf5bc1266d9de0a972ec05e59d77099a4c","date":1500969855,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AssignTest#testIdIsUnique().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AssignTest#testIdIsUnique().mjava","sourceNew":"  @Test\n  public void testIdIsUnique() throws Exception {\n    String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    ZkTestServer server = new ZkTestServer(zkDir);\n    Object fixedValue = new Object();\n    String[] collections = new String[]{\"c1\",\"c2\",\"c3\",\"c4\",\"c5\",\"c6\",\"c7\",\"c8\",\"c9\"};\n    Map<String, ConcurrentHashMap<Integer, Object>> collectionUniqueIds = new HashMap<>();\n    for (String c : collections) {\n      collectionUniqueIds.put(c, new ConcurrentHashMap<>());\n    }\n\n    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n    try {\n      server.run();\n\n      try (SolrZkClient zkClient = new SolrZkClient(server.getZkAddress(), 10000)) {\n        assertTrue(zkClient.isConnected());\n        zkClient.makePath(\"/\", true);\n        for (String c : collections) {\n          zkClient.makePath(\"/collections/\"+c, true);\n        }\n        List<Future<?>> futures = new ArrayList<>();\n        for (int i = 0; i < 1000; i++) {\n          futures.add(executor.submit(() -> {\n            String collection = collections[random().nextInt(collections.length)];\n            int id = Assign.incAndGetId(zkClient, collection, 0);\n            Object val = collectionUniqueIds.get(collection).put(id, fixedValue);\n            if (val != null) {\n              fail(\"ZkController do not generate unique id for \" + collection);\n            }\n          }));\n        }\n        for (Future<?> future : futures) {\n          future.get();\n        }\n      }\n      assertEquals(1000, (long) collectionUniqueIds.values().stream()\n          .map(ConcurrentHashMap::size)\n          .reduce((m1, m2) -> m1 + m2).get());\n    } finally {\n      server.shutdown();\n      ExecutorUtil.shutdownAndAwaitTermination(executor);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testIdIsUnique() throws Exception {\n    String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    ZkTestServer server = new ZkTestServer(zkDir);\n    Object fixedValue = new Object();\n    String[] collections = new String[]{\"c1\",\"c2\",\"c3\",\"c4\",\"c5\",\"c6\",\"c7\",\"c8\",\"c9\"};\n    Map<String, ConcurrentHashMap<Integer, Object>> collectionUniqueIds = new HashMap<>();\n    for (String c : collections) {\n      collectionUniqueIds.put(c, new ConcurrentHashMap<>());\n    }\n\n    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n    try {\n      server.run();\n\n      try (SolrZkClient zkClient = new SolrZkClient(server.getZkAddress(), 10000)) {\n        assertTrue(zkClient.isConnected());\n        zkClient.makePath(\"/\", true);\n        for (String c : collections) {\n          zkClient.makePath(\"/collections/\"+c, true);\n        }\n        List<Future<?>> futures = new ArrayList<>();\n        for (int i = 0; i < 1000; i++) {\n          futures.add(executor.submit(() -> {\n            String collection = collections[random().nextInt(collections.length)];\n            int id = Assign.incAndGetId(zkClient, collection);\n            Object val = collectionUniqueIds.get(collection).put(id, fixedValue);\n            if (val != null) {\n              fail(\"ZkController do not generate unique id for \" + collection);\n            }\n          }));\n        }\n        for (Future<?> future : futures) {\n          future.get();\n        }\n      }\n      assertEquals(1000, (long) collectionUniqueIds.values().stream()\n          .map(ConcurrentHashMap::size)\n          .reduce((m1, m2) -> m1 + m2).get());\n    } finally {\n      server.shutdown();\n      ExecutorUtil.shutdownAndAwaitTermination(executor);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"936cdd5882761db3b844afd6f84ab81cbb011a75","date":1500973524,"type":0,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AssignTest#testIdIsUnique().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testIdIsUnique() throws Exception {\n    String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    ZkTestServer server = new ZkTestServer(zkDir);\n    Object fixedValue = new Object();\n    String[] collections = new String[]{\"c1\",\"c2\",\"c3\",\"c4\",\"c5\",\"c6\",\"c7\",\"c8\",\"c9\"};\n    Map<String, ConcurrentHashMap<Integer, Object>> collectionUniqueIds = new HashMap<>();\n    for (String c : collections) {\n      collectionUniqueIds.put(c, new ConcurrentHashMap<>());\n    }\n\n    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n    try {\n      server.run();\n\n      try (SolrZkClient zkClient = new SolrZkClient(server.getZkAddress(), 10000)) {\n        assertTrue(zkClient.isConnected());\n        zkClient.makePath(\"/\", true);\n        for (String c : collections) {\n          zkClient.makePath(\"/collections/\"+c, true);\n        }\n        List<Future<?>> futures = new ArrayList<>();\n        for (int i = 0; i < 1000; i++) {\n          futures.add(executor.submit(() -> {\n            String collection = collections[random().nextInt(collections.length)];\n            int id = Assign.incAndGetId(zkClient, collection, 0);\n            Object val = collectionUniqueIds.get(collection).put(id, fixedValue);\n            if (val != null) {\n              fail(\"ZkController do not generate unique id for \" + collection);\n            }\n          }));\n        }\n        for (Future<?> future : futures) {\n          future.get();\n        }\n      }\n      assertEquals(1000, (long) collectionUniqueIds.values().stream()\n          .map(ConcurrentHashMap::size)\n          .reduce((m1, m2) -> m1 + m2).get());\n    } finally {\n      server.shutdown();\n      ExecutorUtil.shutdownAndAwaitTermination(executor);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a52341299179de5479672f7cf518bf4b173f34b3","date":1501079746,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AssignTest#testIdIsUnique().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AssignTest#testIdIsUnique().mjava","sourceNew":"  @Test\n  public void testIdIsUnique() throws Exception {\n    String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    ZkTestServer server = new ZkTestServer(zkDir);\n    Object fixedValue = new Object();\n    String[] collections = new String[]{\"c1\",\"c2\",\"c3\",\"c4\",\"c5\",\"c6\",\"c7\",\"c8\",\"c9\"};\n    Map<String, ConcurrentHashMap<Integer, Object>> collectionUniqueIds = new HashMap<>();\n    for (String c : collections) {\n      collectionUniqueIds.put(c, new ConcurrentHashMap<>());\n    }\n\n    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n    try {\n      server.run();\n\n      try (SolrZkClient zkClient = new SolrZkClient(server.getZkAddress(), 10000)) {\n        assertTrue(zkClient.isConnected());\n        zkClient.makePath(\"/\", true);\n        for (String c : collections) {\n          zkClient.makePath(\"/collections/\"+c, true);\n        }\n        List<Future<?>> futures = new ArrayList<>();\n        for (int i = 0; i < 1000; i++) {\n          futures.add(executor.submit(() -> {\n            String collection = collections[random().nextInt(collections.length)];\n            int id = Assign.incAndGetId(zkClient, collection, 0);\n            Object val = collectionUniqueIds.get(collection).put(id, fixedValue);\n            if (val != null) {\n              fail(\"ZkController do not generate unique id for \" + collection);\n            }\n          }));\n        }\n        for (Future<?> future : futures) {\n          future.get();\n        }\n      }\n      assertEquals(1000, (long) collectionUniqueIds.values().stream()\n          .map(ConcurrentHashMap::size)\n          .reduce((m1, m2) -> m1 + m2).get());\n    } finally {\n      server.shutdown();\n      ExecutorUtil.shutdownAndAwaitTermination(executor);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testIdIsUnique() throws Exception {\n    String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    ZkTestServer server = new ZkTestServer(zkDir);\n    Object fixedValue = new Object();\n    String[] collections = new String[]{\"c1\",\"c2\",\"c3\",\"c4\",\"c5\",\"c6\",\"c7\",\"c8\",\"c9\"};\n    Map<String, ConcurrentHashMap<Integer, Object>> collectionUniqueIds = new HashMap<>();\n    for (String c : collections) {\n      collectionUniqueIds.put(c, new ConcurrentHashMap<>());\n    }\n\n    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n    try {\n      server.run();\n\n      try (SolrZkClient zkClient = new SolrZkClient(server.getZkAddress(), 10000)) {\n        assertTrue(zkClient.isConnected());\n        zkClient.makePath(\"/\", true);\n        for (String c : collections) {\n          zkClient.makePath(\"/collections/\"+c, true);\n        }\n        List<Future<?>> futures = new ArrayList<>();\n        for (int i = 0; i < 1000; i++) {\n          futures.add(executor.submit(() -> {\n            String collection = collections[random().nextInt(collections.length)];\n            int id = Assign.incAndGetId(zkClient, collection);\n            Object val = collectionUniqueIds.get(collection).put(id, fixedValue);\n            if (val != null) {\n              fail(\"ZkController do not generate unique id for \" + collection);\n            }\n          }));\n        }\n        for (Future<?> future : futures) {\n          future.get();\n        }\n      }\n      assertEquals(1000, (long) collectionUniqueIds.values().stream()\n          .map(ConcurrentHashMap::size)\n          .reduce((m1, m2) -> m1 + m2).get());\n    } finally {\n      server.shutdown();\n      ExecutorUtil.shutdownAndAwaitTermination(executor);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"85212dad4ed576c7f7e6c165ee19e597b7b4efc8","date":1507997740,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AssignTest#testIdIsUnique().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AssignTest#testIdIsUnique().mjava","sourceNew":"  @Test\n  public void testIdIsUnique() throws Exception {\n    String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    ZkTestServer server = new ZkTestServer(zkDir);\n    Object fixedValue = new Object();\n    String[] collections = new String[]{\"c1\",\"c2\",\"c3\",\"c4\",\"c5\",\"c6\",\"c7\",\"c8\",\"c9\"};\n    Map<String, ConcurrentHashMap<Integer, Object>> collectionUniqueIds = new HashMap<>();\n    for (String c : collections) {\n      collectionUniqueIds.put(c, new ConcurrentHashMap<>());\n    }\n\n    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n    try {\n      server.run();\n\n      try (SolrZkClient zkClient = new SolrZkClient(server.getZkAddress(), 10000)) {\n        assertTrue(zkClient.isConnected());\n        zkClient.makePath(\"/\", true);\n        for (String c : collections) {\n          zkClient.makePath(\"/collections/\"+c, true);\n        }\n        // TODO: fix this to be independent of ZK\n        ZkDistribStateManager stateManager = new ZkDistribStateManager(zkClient);\n        List<Future<?>> futures = new ArrayList<>();\n        for (int i = 0; i < 1000; i++) {\n          futures.add(executor.submit(() -> {\n            String collection = collections[random().nextInt(collections.length)];\n            int id = Assign.incAndGetId(stateManager, collection, 0);\n            Object val = collectionUniqueIds.get(collection).put(id, fixedValue);\n            if (val != null) {\n              fail(\"ZkController do not generate unique id for \" + collection);\n            }\n          }));\n        }\n        for (Future<?> future : futures) {\n          future.get();\n        }\n      }\n      assertEquals(1000, (long) collectionUniqueIds.values().stream()\n          .map(ConcurrentHashMap::size)\n          .reduce((m1, m2) -> m1 + m2).get());\n    } finally {\n      server.shutdown();\n      ExecutorUtil.shutdownAndAwaitTermination(executor);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testIdIsUnique() throws Exception {\n    String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    ZkTestServer server = new ZkTestServer(zkDir);\n    Object fixedValue = new Object();\n    String[] collections = new String[]{\"c1\",\"c2\",\"c3\",\"c4\",\"c5\",\"c6\",\"c7\",\"c8\",\"c9\"};\n    Map<String, ConcurrentHashMap<Integer, Object>> collectionUniqueIds = new HashMap<>();\n    for (String c : collections) {\n      collectionUniqueIds.put(c, new ConcurrentHashMap<>());\n    }\n\n    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n    try {\n      server.run();\n\n      try (SolrZkClient zkClient = new SolrZkClient(server.getZkAddress(), 10000)) {\n        assertTrue(zkClient.isConnected());\n        zkClient.makePath(\"/\", true);\n        for (String c : collections) {\n          zkClient.makePath(\"/collections/\"+c, true);\n        }\n        List<Future<?>> futures = new ArrayList<>();\n        for (int i = 0; i < 1000; i++) {\n          futures.add(executor.submit(() -> {\n            String collection = collections[random().nextInt(collections.length)];\n            int id = Assign.incAndGetId(zkClient, collection, 0);\n            Object val = collectionUniqueIds.get(collection).put(id, fixedValue);\n            if (val != null) {\n              fail(\"ZkController do not generate unique id for \" + collection);\n            }\n          }));\n        }\n        for (Future<?> future : futures) {\n          future.get();\n        }\n      }\n      assertEquals(1000, (long) collectionUniqueIds.values().stream()\n          .map(ConcurrentHashMap::size)\n          .reduce((m1, m2) -> m1 + m2).get());\n    } finally {\n      server.shutdown();\n      ExecutorUtil.shutdownAndAwaitTermination(executor);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":5,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/AssignTest#testIdIsUnique().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AssignTest#testIdIsUnique().mjava","sourceNew":"  @Test\n  public void testIdIsUnique() throws Exception {\n    String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    ZkTestServer server = new ZkTestServer(zkDir);\n    Object fixedValue = new Object();\n    String[] collections = new String[]{\"c1\",\"c2\",\"c3\",\"c4\",\"c5\",\"c6\",\"c7\",\"c8\",\"c9\"};\n    Map<String, ConcurrentHashMap<Integer, Object>> collectionUniqueIds = new HashMap<>();\n    for (String c : collections) {\n      collectionUniqueIds.put(c, new ConcurrentHashMap<>());\n    }\n\n    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n    try {\n      server.run();\n\n      try (SolrZkClient zkClient = new SolrZkClient(server.getZkAddress(), 10000)) {\n        assertTrue(zkClient.isConnected());\n        zkClient.makePath(\"/\", true);\n        for (String c : collections) {\n          zkClient.makePath(\"/collections/\"+c, true);\n        }\n        // TODO: fix this to be independent of ZK\n        ZkDistribStateManager stateManager = new ZkDistribStateManager(zkClient);\n        List<Future<?>> futures = new ArrayList<>();\n        for (int i = 0; i < 1000; i++) {\n          futures.add(executor.submit(() -> {\n            String collection = collections[random().nextInt(collections.length)];\n            int id = Assign.incAndGetId(stateManager, collection, 0);\n            Object val = collectionUniqueIds.get(collection).put(id, fixedValue);\n            if (val != null) {\n              fail(\"ZkController do not generate unique id for \" + collection);\n            }\n          }));\n        }\n        for (Future<?> future : futures) {\n          future.get();\n        }\n      }\n      assertEquals(1000, (long) collectionUniqueIds.values().stream()\n          .map(ConcurrentHashMap::size)\n          .reduce((m1, m2) -> m1 + m2).get());\n    } finally {\n      server.shutdown();\n      ExecutorUtil.shutdownAndAwaitTermination(executor);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testIdIsUnique() throws Exception {\n    String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    ZkTestServer server = new ZkTestServer(zkDir);\n    Object fixedValue = new Object();\n    String[] collections = new String[]{\"c1\",\"c2\",\"c3\",\"c4\",\"c5\",\"c6\",\"c7\",\"c8\",\"c9\"};\n    Map<String, ConcurrentHashMap<Integer, Object>> collectionUniqueIds = new HashMap<>();\n    for (String c : collections) {\n      collectionUniqueIds.put(c, new ConcurrentHashMap<>());\n    }\n\n    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n    try {\n      server.run();\n\n      try (SolrZkClient zkClient = new SolrZkClient(server.getZkAddress(), 10000)) {\n        assertTrue(zkClient.isConnected());\n        zkClient.makePath(\"/\", true);\n        for (String c : collections) {\n          zkClient.makePath(\"/collections/\"+c, true);\n        }\n        // TODO: fix this to be independent of ZK\n        ZkDistribStateManager stateManager = new ZkDistribStateManager(zkClient);\n        List<Future<?>> futures = new ArrayList<>();\n        for (int i = 0; i < 1000; i++) {\n          futures.add(executor.submit(() -> {\n            String collection = collections[random().nextInt(collections.length)];\n            int id = Assign.incAndGetId(stateManager, collection, 0);\n            Object val = collectionUniqueIds.get(collection).put(id, fixedValue);\n            if (val != null) {\n              fail(\"ZkController do not generate unique id for \" + collection);\n            }\n          }));\n        }\n        for (Future<?> future : futures) {\n          future.get();\n        }\n      }\n      assertEquals(1000, (long) collectionUniqueIds.values().stream()\n          .map(ConcurrentHashMap::size)\n          .reduce((m1, m2) -> m1 + m2).get());\n    } finally {\n      server.shutdown();\n      ExecutorUtil.shutdownAndAwaitTermination(executor);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":5,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/AssignTest#testIdIsUnique().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AssignTest#testIdIsUnique().mjava","sourceNew":"  @Test\n  public void testIdIsUnique() throws Exception {\n    String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    ZkTestServer server = new ZkTestServer(zkDir);\n    Object fixedValue = new Object();\n    String[] collections = new String[]{\"c1\",\"c2\",\"c3\",\"c4\",\"c5\",\"c6\",\"c7\",\"c8\",\"c9\"};\n    Map<String, ConcurrentHashMap<Integer, Object>> collectionUniqueIds = new HashMap<>();\n    for (String c : collections) {\n      collectionUniqueIds.put(c, new ConcurrentHashMap<>());\n    }\n\n    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n    try {\n      server.run();\n\n      try (SolrZkClient zkClient = new SolrZkClient(server.getZkAddress(), 10000)) {\n        assertTrue(zkClient.isConnected());\n        zkClient.makePath(\"/\", true);\n        for (String c : collections) {\n          zkClient.makePath(\"/collections/\"+c, true);\n        }\n        // TODO: fix this to be independent of ZK\n        ZkDistribStateManager stateManager = new ZkDistribStateManager(zkClient);\n        List<Future<?>> futures = new ArrayList<>();\n        for (int i = 0; i < 1000; i++) {\n          futures.add(executor.submit(() -> {\n            String collection = collections[random().nextInt(collections.length)];\n            int id = Assign.incAndGetId(stateManager, collection, 0);\n            Object val = collectionUniqueIds.get(collection).put(id, fixedValue);\n            if (val != null) {\n              fail(\"ZkController do not generate unique id for \" + collection);\n            }\n          }));\n        }\n        for (Future<?> future : futures) {\n          future.get();\n        }\n      }\n      assertEquals(1000, (long) collectionUniqueIds.values().stream()\n          .map(ConcurrentHashMap::size)\n          .reduce((m1, m2) -> m1 + m2).get());\n    } finally {\n      server.shutdown();\n      ExecutorUtil.shutdownAndAwaitTermination(executor);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testIdIsUnique() throws Exception {\n    String zkDir = createTempDir(\"zkData\").toFile().getAbsolutePath();\n    ZkTestServer server = new ZkTestServer(zkDir);\n    Object fixedValue = new Object();\n    String[] collections = new String[]{\"c1\",\"c2\",\"c3\",\"c4\",\"c5\",\"c6\",\"c7\",\"c8\",\"c9\"};\n    Map<String, ConcurrentHashMap<Integer, Object>> collectionUniqueIds = new HashMap<>();\n    for (String c : collections) {\n      collectionUniqueIds.put(c, new ConcurrentHashMap<>());\n    }\n\n    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n    try {\n      server.run();\n\n      try (SolrZkClient zkClient = new SolrZkClient(server.getZkAddress(), 10000)) {\n        assertTrue(zkClient.isConnected());\n        zkClient.makePath(\"/\", true);\n        for (String c : collections) {\n          zkClient.makePath(\"/collections/\"+c, true);\n        }\n        // TODO: fix this to be independent of ZK\n        ZkDistribStateManager stateManager = new ZkDistribStateManager(zkClient);\n        List<Future<?>> futures = new ArrayList<>();\n        for (int i = 0; i < 1000; i++) {\n          futures.add(executor.submit(() -> {\n            String collection = collections[random().nextInt(collections.length)];\n            int id = Assign.incAndGetId(stateManager, collection, 0);\n            Object val = collectionUniqueIds.get(collection).put(id, fixedValue);\n            if (val != null) {\n              fail(\"ZkController do not generate unique id for \" + collection);\n            }\n          }));\n        }\n        for (Future<?> future : futures) {\n          future.get();\n        }\n      }\n      assertEquals(1000, (long) collectionUniqueIds.values().stream()\n          .map(ConcurrentHashMap::size)\n          .reduce((m1, m2) -> m1 + m2).get());\n    } finally {\n      server.shutdown();\n      ExecutorUtil.shutdownAndAwaitTermination(executor);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"651c3ddf5bc1266d9de0a972ec05e59d77099a4c":["9f100e4a037a938ee4b027674f1ca80fc208badf"],"b94236357aaa22b76c10629851fe4e376e0cea82":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"a52341299179de5479672f7cf518bf4b173f34b3":["9f100e4a037a938ee4b027674f1ca80fc208badf","651c3ddf5bc1266d9de0a972ec05e59d77099a4c"],"9f100e4a037a938ee4b027674f1ca80fc208badf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["a52341299179de5479672f7cf518bf4b173f34b3"],"936cdd5882761db3b844afd6f84ab81cbb011a75":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","651c3ddf5bc1266d9de0a972ec05e59d77099a4c"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b94236357aaa22b76c10629851fe4e376e0cea82"]},"commit2Childs":{"651c3ddf5bc1266d9de0a972ec05e59d77099a4c":["a52341299179de5479672f7cf518bf4b173f34b3","936cdd5882761db3b844afd6f84ab81cbb011a75"],"b94236357aaa22b76c10629851fe4e376e0cea82":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a52341299179de5479672f7cf518bf4b173f34b3":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8"],"9f100e4a037a938ee4b027674f1ca80fc208badf":["651c3ddf5bc1266d9de0a972ec05e59d77099a4c","a52341299179de5479672f7cf518bf4b173f34b3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9f100e4a037a938ee4b027674f1ca80fc208badf","936cdd5882761db3b844afd6f84ab81cbb011a75"],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["b94236357aaa22b76c10629851fe4e376e0cea82","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"936cdd5882761db3b844afd6f84ab81cbb011a75":[],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["936cdd5882761db3b844afd6f84ab81cbb011a75","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}