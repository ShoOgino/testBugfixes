{"path":"lucene/classification/src/java/org/apache/lucene/classification/BM25NBClassifier#assignClassNormalizedList(String).mjava","commits":[{"id":"37dc4585237301aef478cc54a24c7188a28ab2e6","date":1494512792,"type":0,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/BM25NBClassifier#assignClassNormalizedList(String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Calculate probabilities for all classes for a given input text\n   *\n   * @param inputDocument the input text as a {@code String}\n   * @return a {@code List} of {@code ClassificationResult}, one for each existing class\n   * @throws IOException if assigning probabilities fails\n   */\n  private List<ClassificationResult<BytesRef>> assignClassNormalizedList(String inputDocument) throws IOException {\n    List<ClassificationResult<BytesRef>> assignedClasses = new ArrayList<>();\n\n    Terms classes = MultiFields.getTerms(indexReader, classFieldName);\n    TermsEnum classesEnum = classes.iterator();\n    BytesRef next;\n    String[] tokenizedText = tokenize(inputDocument);\n    while ((next = classesEnum.next()) != null) {\n      if (next.length > 0) {\n        Term term = new Term(this.classFieldName, next);\n        assignedClasses.add(new ClassificationResult<>(term.bytes(), calculateLogPrior(term) + calculateLogLikelihood(tokenizedText, term)));\n      }\n    }\n\n    return normClassificationResults(assignedClasses);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"360b3962efc30aa8b2c39c3087aa36069674bbe7","date":1494557674,"type":0,"author":"Cao Manh Dat","isMerge":true,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/BM25NBClassifier#assignClassNormalizedList(String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Calculate probabilities for all classes for a given input text\n   *\n   * @param inputDocument the input text as a {@code String}\n   * @return a {@code List} of {@code ClassificationResult}, one for each existing class\n   * @throws IOException if assigning probabilities fails\n   */\n  private List<ClassificationResult<BytesRef>> assignClassNormalizedList(String inputDocument) throws IOException {\n    List<ClassificationResult<BytesRef>> assignedClasses = new ArrayList<>();\n\n    Terms classes = MultiFields.getTerms(indexReader, classFieldName);\n    TermsEnum classesEnum = classes.iterator();\n    BytesRef next;\n    String[] tokenizedText = tokenize(inputDocument);\n    while ((next = classesEnum.next()) != null) {\n      if (next.length > 0) {\n        Term term = new Term(this.classFieldName, next);\n        assignedClasses.add(new ClassificationResult<>(term.bytes(), calculateLogPrior(term) + calculateLogLikelihood(tokenizedText, term)));\n      }\n    }\n\n    return normClassificationResults(assignedClasses);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/BM25NBClassifier#assignClassNormalizedList(String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Calculate probabilities for all classes for a given input text\n   *\n   * @param inputDocument the input text as a {@code String}\n   * @return a {@code List} of {@code ClassificationResult}, one for each existing class\n   * @throws IOException if assigning probabilities fails\n   */\n  private List<ClassificationResult<BytesRef>> assignClassNormalizedList(String inputDocument) throws IOException {\n    List<ClassificationResult<BytesRef>> assignedClasses = new ArrayList<>();\n\n    Terms classes = MultiFields.getTerms(indexReader, classFieldName);\n    TermsEnum classesEnum = classes.iterator();\n    BytesRef next;\n    String[] tokenizedText = tokenize(inputDocument);\n    while ((next = classesEnum.next()) != null) {\n      if (next.length > 0) {\n        Term term = new Term(this.classFieldName, next);\n        assignedClasses.add(new ClassificationResult<>(term.bytes(), calculateLogPrior(term) + calculateLogLikelihood(tokenizedText, term)));\n      }\n    }\n\n    return normClassificationResults(assignedClasses);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04e775de416dd2d8067b10db1c8af975a1d5017e","date":1539906554,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/BM25NBClassifier#assignClassNormalizedList(String).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/BM25NBClassifier#assignClassNormalizedList(String).mjava","sourceNew":"  /**\n   * Calculate probabilities for all classes for a given input text\n   *\n   * @param inputDocument the input text as a {@code String}\n   * @return a {@code List} of {@code ClassificationResult}, one for each existing class\n   * @throws IOException if assigning probabilities fails\n   */\n  private List<ClassificationResult<BytesRef>> assignClassNormalizedList(String inputDocument) throws IOException {\n    List<ClassificationResult<BytesRef>> assignedClasses = new ArrayList<>();\n\n    Terms classes = MultiTerms.getTerms(indexReader, classFieldName);\n    TermsEnum classesEnum = classes.iterator();\n    BytesRef next;\n    String[] tokenizedText = tokenize(inputDocument);\n    while ((next = classesEnum.next()) != null) {\n      if (next.length > 0) {\n        Term term = new Term(this.classFieldName, next);\n        assignedClasses.add(new ClassificationResult<>(term.bytes(), calculateLogPrior(term) + calculateLogLikelihood(tokenizedText, term)));\n      }\n    }\n\n    return normClassificationResults(assignedClasses);\n  }\n\n","sourceOld":"  /**\n   * Calculate probabilities for all classes for a given input text\n   *\n   * @param inputDocument the input text as a {@code String}\n   * @return a {@code List} of {@code ClassificationResult}, one for each existing class\n   * @throws IOException if assigning probabilities fails\n   */\n  private List<ClassificationResult<BytesRef>> assignClassNormalizedList(String inputDocument) throws IOException {\n    List<ClassificationResult<BytesRef>> assignedClasses = new ArrayList<>();\n\n    Terms classes = MultiFields.getTerms(indexReader, classFieldName);\n    TermsEnum classesEnum = classes.iterator();\n    BytesRef next;\n    String[] tokenizedText = tokenize(inputDocument);\n    while ((next = classesEnum.next()) != null) {\n      if (next.length > 0) {\n        Term term = new Term(this.classFieldName, next);\n        assignedClasses.add(new ClassificationResult<>(term.bytes(), calculateLogPrior(term) + calculateLogLikelihood(tokenizedText, term)));\n      }\n    }\n\n    return normClassificationResults(assignedClasses);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e9017cf144952056066919f1ebc7897ff9bd71b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","360b3962efc30aa8b2c39c3087aa36069674bbe7"],"360b3962efc30aa8b2c39c3087aa36069674bbe7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","37dc4585237301aef478cc54a24c7188a28ab2e6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"04e775de416dd2d8067b10db1c8af975a1d5017e":["360b3962efc30aa8b2c39c3087aa36069674bbe7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["04e775de416dd2d8067b10db1c8af975a1d5017e"],"37dc4585237301aef478cc54a24c7188a28ab2e6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"360b3962efc30aa8b2c39c3087aa36069674bbe7":["e9017cf144952056066919f1ebc7897ff9bd71b1","04e775de416dd2d8067b10db1c8af975a1d5017e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e9017cf144952056066919f1ebc7897ff9bd71b1","360b3962efc30aa8b2c39c3087aa36069674bbe7","37dc4585237301aef478cc54a24c7188a28ab2e6"],"04e775de416dd2d8067b10db1c8af975a1d5017e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"37dc4585237301aef478cc54a24c7188a28ab2e6":["360b3962efc30aa8b2c39c3087aa36069674bbe7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}