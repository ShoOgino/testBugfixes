{"path":"lucene/core/src/java/org/apache/lucene/index/TieredMergePolicy#findForcedMerges(SegmentInfos,int,Map[SegmentCommitInfo,Boolean],IndexWriter).mjava","commits":[{"id":"027bee21e09164c9ee230395405076d1e0034b30","date":1401521821,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TieredMergePolicy#findForcedMerges(SegmentInfos,int,Map[SegmentCommitInfo,Boolean],IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TieredMergePolicy#findForcedMerges(SegmentInfos,int,Map[SegmentCommitInfo,Boolean]).mjava","sourceNew":"  @Override\n  public MergeSpecification findForcedMerges(SegmentInfos infos, int maxSegmentCount, Map<SegmentCommitInfo,Boolean> segmentsToMerge, IndexWriter writer) throws IOException {\n    if (verbose(writer)) {\n      message(\"findForcedMerges maxSegmentCount=\" + maxSegmentCount + \" infos=\" + writer.segString(infos) + \" segmentsToMerge=\" + segmentsToMerge, writer);\n    }\n\n    List<SegmentCommitInfo> eligible = new ArrayList<>();\n    boolean forceMergeRunning = false;\n    final Collection<SegmentCommitInfo> merging = writer.getMergingSegments();\n    boolean segmentIsOriginal = false;\n    for(SegmentCommitInfo info : infos) {\n      final Boolean isOriginal = segmentsToMerge.get(info);\n      if (isOriginal != null) {\n        segmentIsOriginal = isOriginal;\n        if (!merging.contains(info)) {\n          eligible.add(info);\n        } else {\n          forceMergeRunning = true;\n        }\n      }\n    }\n\n    if (eligible.size() == 0) {\n      return null;\n    }\n\n    if ((maxSegmentCount > 1 && eligible.size() <= maxSegmentCount) ||\n        (maxSegmentCount == 1 && eligible.size() == 1 && (!segmentIsOriginal || isMerged(infos, eligible.get(0), writer)))) {\n      if (verbose(writer)) {\n        message(\"already merged\", writer);\n      }\n      return null;\n    }\n\n    Collections.sort(eligible, new SegmentByteSizeDescending(writer));\n\n    if (verbose(writer)) {\n      message(\"eligible=\" + eligible, writer);\n      message(\"forceMergeRunning=\" + forceMergeRunning, writer);\n    }\n\n    int end = eligible.size();\n    \n    MergeSpecification spec = null;\n\n    // Do full merges, first, backwards:\n    while(end >= maxMergeAtOnceExplicit + maxSegmentCount - 1) {\n      if (spec == null) {\n        spec = new MergeSpecification();\n      }\n      final OneMerge merge = new OneMerge(eligible.subList(end-maxMergeAtOnceExplicit, end));\n      if (verbose(writer)) {\n        message(\"add merge=\" + writer.segString(merge.segments), writer);\n      }\n      spec.add(merge);\n      end -= maxMergeAtOnceExplicit;\n    }\n\n    if (spec == null && !forceMergeRunning) {\n      // Do final merge\n      final int numToMerge = end - maxSegmentCount + 1;\n      final OneMerge merge = new OneMerge(eligible.subList(end-numToMerge, end));\n      if (verbose(writer)) {\n        message(\"add final merge=\" + merge.segString(writer.getDirectory()), writer);\n      }\n      spec = new MergeSpecification();\n      spec.add(merge);\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  @Override\n  public MergeSpecification findForcedMerges(SegmentInfos infos, int maxSegmentCount, Map<SegmentCommitInfo,Boolean> segmentsToMerge) throws IOException {\n    if (verbose()) {\n      message(\"findForcedMerges maxSegmentCount=\" + maxSegmentCount + \" infos=\" + writer.get().segString(infos) + \" segmentsToMerge=\" + segmentsToMerge);\n    }\n\n    List<SegmentCommitInfo> eligible = new ArrayList<>();\n    boolean forceMergeRunning = false;\n    final Collection<SegmentCommitInfo> merging = writer.get().getMergingSegments();\n    boolean segmentIsOriginal = false;\n    for(SegmentCommitInfo info : infos) {\n      final Boolean isOriginal = segmentsToMerge.get(info);\n      if (isOriginal != null) {\n        segmentIsOriginal = isOriginal;\n        if (!merging.contains(info)) {\n          eligible.add(info);\n        } else {\n          forceMergeRunning = true;\n        }\n      }\n    }\n\n    if (eligible.size() == 0) {\n      return null;\n    }\n\n    if ((maxSegmentCount > 1 && eligible.size() <= maxSegmentCount) ||\n        (maxSegmentCount == 1 && eligible.size() == 1 && (!segmentIsOriginal || isMerged(infos, eligible.get(0))))) {\n      if (verbose()) {\n        message(\"already merged\");\n      }\n      return null;\n    }\n\n    Collections.sort(eligible, new SegmentByteSizeDescending());\n\n    if (verbose()) {\n      message(\"eligible=\" + eligible);\n      message(\"forceMergeRunning=\" + forceMergeRunning);\n    }\n\n    int end = eligible.size();\n    \n    MergeSpecification spec = null;\n\n    // Do full merges, first, backwards:\n    while(end >= maxMergeAtOnceExplicit + maxSegmentCount - 1) {\n      if (spec == null) {\n        spec = new MergeSpecification();\n      }\n      final OneMerge merge = new OneMerge(eligible.subList(end-maxMergeAtOnceExplicit, end));\n      if (verbose()) {\n        message(\"add merge=\" + writer.get().segString(merge.segments));\n      }\n      spec.add(merge);\n      end -= maxMergeAtOnceExplicit;\n    }\n\n    if (spec == null && !forceMergeRunning) {\n      // Do final merge\n      final int numToMerge = end - maxSegmentCount + 1;\n      final OneMerge merge = new OneMerge(eligible.subList(end-numToMerge, end));\n      if (verbose()) {\n        message(\"add final merge=\" + merge.segString(writer.get().getDirectory()));\n      }\n      spec = new MergeSpecification();\n      spec.add(merge);\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5faf65b6692f15cca0f87bf8666c87899afc619f","date":1420468108,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TieredMergePolicy#findForcedMerges(SegmentInfos,int,Map[SegmentCommitInfo,Boolean],IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TieredMergePolicy#findForcedMerges(SegmentInfos,int,Map[SegmentCommitInfo,Boolean],IndexWriter).mjava","sourceNew":"  @Override\n  public MergeSpecification findForcedMerges(SegmentInfos infos, int maxSegmentCount, Map<SegmentCommitInfo,Boolean> segmentsToMerge, IndexWriter writer) throws IOException {\n    if (verbose(writer)) {\n      message(\"findForcedMerges maxSegmentCount=\" + maxSegmentCount + \" infos=\" + writer.segString(infos) + \" segmentsToMerge=\" + segmentsToMerge, writer);\n    }\n\n    List<SegmentCommitInfo> eligible = new ArrayList<>();\n    boolean forceMergeRunning = false;\n    final Collection<SegmentCommitInfo> merging = writer.getMergingSegments();\n    boolean segmentIsOriginal = false;\n    for(SegmentCommitInfo info : infos) {\n      final Boolean isOriginal = segmentsToMerge.get(info);\n      if (isOriginal != null) {\n        segmentIsOriginal = isOriginal;\n        if (!merging.contains(info)) {\n          eligible.add(info);\n        } else {\n          forceMergeRunning = true;\n        }\n      }\n    }\n\n    if (eligible.size() == 0) {\n      return null;\n    }\n\n    if ((maxSegmentCount > 1 && eligible.size() <= maxSegmentCount) ||\n        (maxSegmentCount == 1 && eligible.size() == 1 && (!segmentIsOriginal || isMerged(infos, eligible.get(0), writer)))) {\n      if (verbose(writer)) {\n        message(\"already merged\", writer);\n      }\n      return null;\n    }\n\n    Collections.sort(eligible, new SegmentByteSizeDescending(writer));\n\n    if (verbose(writer)) {\n      message(\"eligible=\" + eligible, writer);\n      message(\"forceMergeRunning=\" + forceMergeRunning, writer);\n    }\n\n    int end = eligible.size();\n    \n    MergeSpecification spec = null;\n\n    // Do full merges, first, backwards:\n    while(end >= maxMergeAtOnceExplicit + maxSegmentCount - 1) {\n      if (spec == null) {\n        spec = new MergeSpecification();\n      }\n      final OneMerge merge = new OneMerge(eligible.subList(end-maxMergeAtOnceExplicit, end));\n      if (verbose(writer)) {\n        message(\"add merge=\" + writer.segString(merge.segments), writer);\n      }\n      spec.add(merge);\n      end -= maxMergeAtOnceExplicit;\n    }\n\n    if (spec == null && !forceMergeRunning) {\n      // Do final merge\n      final int numToMerge = end - maxSegmentCount + 1;\n      final OneMerge merge = new OneMerge(eligible.subList(end-numToMerge, end));\n      if (verbose(writer)) {\n        message(\"add final merge=\" + merge.segString(), writer);\n      }\n      spec = new MergeSpecification();\n      spec.add(merge);\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  @Override\n  public MergeSpecification findForcedMerges(SegmentInfos infos, int maxSegmentCount, Map<SegmentCommitInfo,Boolean> segmentsToMerge, IndexWriter writer) throws IOException {\n    if (verbose(writer)) {\n      message(\"findForcedMerges maxSegmentCount=\" + maxSegmentCount + \" infos=\" + writer.segString(infos) + \" segmentsToMerge=\" + segmentsToMerge, writer);\n    }\n\n    List<SegmentCommitInfo> eligible = new ArrayList<>();\n    boolean forceMergeRunning = false;\n    final Collection<SegmentCommitInfo> merging = writer.getMergingSegments();\n    boolean segmentIsOriginal = false;\n    for(SegmentCommitInfo info : infos) {\n      final Boolean isOriginal = segmentsToMerge.get(info);\n      if (isOriginal != null) {\n        segmentIsOriginal = isOriginal;\n        if (!merging.contains(info)) {\n          eligible.add(info);\n        } else {\n          forceMergeRunning = true;\n        }\n      }\n    }\n\n    if (eligible.size() == 0) {\n      return null;\n    }\n\n    if ((maxSegmentCount > 1 && eligible.size() <= maxSegmentCount) ||\n        (maxSegmentCount == 1 && eligible.size() == 1 && (!segmentIsOriginal || isMerged(infos, eligible.get(0), writer)))) {\n      if (verbose(writer)) {\n        message(\"already merged\", writer);\n      }\n      return null;\n    }\n\n    Collections.sort(eligible, new SegmentByteSizeDescending(writer));\n\n    if (verbose(writer)) {\n      message(\"eligible=\" + eligible, writer);\n      message(\"forceMergeRunning=\" + forceMergeRunning, writer);\n    }\n\n    int end = eligible.size();\n    \n    MergeSpecification spec = null;\n\n    // Do full merges, first, backwards:\n    while(end >= maxMergeAtOnceExplicit + maxSegmentCount - 1) {\n      if (spec == null) {\n        spec = new MergeSpecification();\n      }\n      final OneMerge merge = new OneMerge(eligible.subList(end-maxMergeAtOnceExplicit, end));\n      if (verbose(writer)) {\n        message(\"add merge=\" + writer.segString(merge.segments), writer);\n      }\n      spec.add(merge);\n      end -= maxMergeAtOnceExplicit;\n    }\n\n    if (spec == null && !forceMergeRunning) {\n      // Do final merge\n      final int numToMerge = end - maxSegmentCount + 1;\n      final OneMerge merge = new OneMerge(eligible.subList(end-numToMerge, end));\n      if (verbose(writer)) {\n        message(\"add final merge=\" + merge.segString(writer.getDirectory()), writer);\n      }\n      spec = new MergeSpecification();\n      spec.add(merge);\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f4363cd33f6eff7fb4753574a441e2d18c1022a4","date":1498067235,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TieredMergePolicy#findForcedMerges(SegmentInfos,int,Map[SegmentCommitInfo,Boolean],IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TieredMergePolicy#findForcedMerges(SegmentInfos,int,Map[SegmentCommitInfo,Boolean],IndexWriter).mjava","sourceNew":"  @Override\n  public MergeSpecification findForcedMerges(SegmentInfos infos, int maxSegmentCount, Map<SegmentCommitInfo,Boolean> segmentsToMerge, IndexWriter writer) throws IOException {\n    if (verbose(writer)) {\n      message(\"findForcedMerges maxSegmentCount=\" + maxSegmentCount + \" infos=\" + writer.segString(infos) + \" segmentsToMerge=\" + segmentsToMerge, writer);\n    }\n\n    List<SegmentCommitInfo> eligible = new ArrayList<>();\n    boolean forceMergeRunning = false;\n    final Collection<SegmentCommitInfo> merging = writer.getMergingSegments();\n    boolean segmentIsOriginal = false;\n    for(SegmentCommitInfo info : infos) {\n      final Boolean isOriginal = segmentsToMerge.get(info);\n      if (isOriginal != null) {\n        segmentIsOriginal = isOriginal;\n        if (merging.contains(info) == false) {\n          eligible.add(info);\n        } else {\n          forceMergeRunning = true;\n        }\n      }\n    }\n\n    if (eligible.size() == 0) {\n      return null;\n    }\n\n    // The size can change concurrently while we are running here, because deletes\n    // are now applied concurrently, and this can piss off TimSort!  So we\n    // call size() once per segment and sort by that:\n    Map<SegmentCommitInfo,Long> sizeInBytes = getSegmentSizes(writer, eligible);\n\n    if ((maxSegmentCount > 1 && eligible.size() <= maxSegmentCount) ||\n        (maxSegmentCount == 1 && eligible.size() == 1 && (!segmentIsOriginal || isMerged(infos, eligible.get(0), writer)))) {\n      if (verbose(writer)) {\n        message(\"already merged\", writer);\n      }\n      return null;\n    }\n\n    Collections.sort(eligible, new SegmentByteSizeDescending(sizeInBytes));\n\n    if (verbose(writer)) {\n      message(\"eligible=\" + eligible, writer);\n      message(\"forceMergeRunning=\" + forceMergeRunning, writer);\n    }\n\n    int end = eligible.size();\n    \n    MergeSpecification spec = null;\n\n    // Do full merges, first, backwards:\n    while(end >= maxMergeAtOnceExplicit + maxSegmentCount - 1) {\n      if (spec == null) {\n        spec = new MergeSpecification();\n      }\n      final OneMerge merge = new OneMerge(eligible.subList(end-maxMergeAtOnceExplicit, end));\n      if (verbose(writer)) {\n        message(\"add merge=\" + writer.segString(merge.segments), writer);\n      }\n      spec.add(merge);\n      end -= maxMergeAtOnceExplicit;\n    }\n\n    if (spec == null && !forceMergeRunning) {\n      // Do final merge\n      final int numToMerge = end - maxSegmentCount + 1;\n      final OneMerge merge = new OneMerge(eligible.subList(end-numToMerge, end));\n      if (verbose(writer)) {\n        message(\"add final merge=\" + merge.segString(), writer);\n      }\n      spec = new MergeSpecification();\n      spec.add(merge);\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  @Override\n  public MergeSpecification findForcedMerges(SegmentInfos infos, int maxSegmentCount, Map<SegmentCommitInfo,Boolean> segmentsToMerge, IndexWriter writer) throws IOException {\n    if (verbose(writer)) {\n      message(\"findForcedMerges maxSegmentCount=\" + maxSegmentCount + \" infos=\" + writer.segString(infos) + \" segmentsToMerge=\" + segmentsToMerge, writer);\n    }\n\n    List<SegmentCommitInfo> eligible = new ArrayList<>();\n    boolean forceMergeRunning = false;\n    final Collection<SegmentCommitInfo> merging = writer.getMergingSegments();\n    boolean segmentIsOriginal = false;\n    for(SegmentCommitInfo info : infos) {\n      final Boolean isOriginal = segmentsToMerge.get(info);\n      if (isOriginal != null) {\n        segmentIsOriginal = isOriginal;\n        if (!merging.contains(info)) {\n          eligible.add(info);\n        } else {\n          forceMergeRunning = true;\n        }\n      }\n    }\n\n    if (eligible.size() == 0) {\n      return null;\n    }\n\n    if ((maxSegmentCount > 1 && eligible.size() <= maxSegmentCount) ||\n        (maxSegmentCount == 1 && eligible.size() == 1 && (!segmentIsOriginal || isMerged(infos, eligible.get(0), writer)))) {\n      if (verbose(writer)) {\n        message(\"already merged\", writer);\n      }\n      return null;\n    }\n\n    Collections.sort(eligible, new SegmentByteSizeDescending(writer));\n\n    if (verbose(writer)) {\n      message(\"eligible=\" + eligible, writer);\n      message(\"forceMergeRunning=\" + forceMergeRunning, writer);\n    }\n\n    int end = eligible.size();\n    \n    MergeSpecification spec = null;\n\n    // Do full merges, first, backwards:\n    while(end >= maxMergeAtOnceExplicit + maxSegmentCount - 1) {\n      if (spec == null) {\n        spec = new MergeSpecification();\n      }\n      final OneMerge merge = new OneMerge(eligible.subList(end-maxMergeAtOnceExplicit, end));\n      if (verbose(writer)) {\n        message(\"add merge=\" + writer.segString(merge.segments), writer);\n      }\n      spec.add(merge);\n      end -= maxMergeAtOnceExplicit;\n    }\n\n    if (spec == null && !forceMergeRunning) {\n      // Do final merge\n      final int numToMerge = end - maxSegmentCount + 1;\n      final OneMerge merge = new OneMerge(eligible.subList(end-numToMerge, end));\n      if (verbose(writer)) {\n        message(\"add final merge=\" + merge.segString(), writer);\n      }\n      spec = new MergeSpecification();\n      spec.add(merge);\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TieredMergePolicy#findForcedMerges(SegmentInfos,int,Map[SegmentCommitInfo,Boolean],IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TieredMergePolicy#findForcedMerges(SegmentInfos,int,Map[SegmentCommitInfo,Boolean],IndexWriter).mjava","sourceNew":"  @Override\n  public MergeSpecification findForcedMerges(SegmentInfos infos, int maxSegmentCount, Map<SegmentCommitInfo,Boolean> segmentsToMerge, IndexWriter writer) throws IOException {\n    if (verbose(writer)) {\n      message(\"findForcedMerges maxSegmentCount=\" + maxSegmentCount + \" infos=\" + writer.segString(infos) + \" segmentsToMerge=\" + segmentsToMerge, writer);\n    }\n\n    List<SegmentCommitInfo> eligible = new ArrayList<>();\n    boolean forceMergeRunning = false;\n    final Collection<SegmentCommitInfo> merging = writer.getMergingSegments();\n    boolean segmentIsOriginal = false;\n    for(SegmentCommitInfo info : infos) {\n      final Boolean isOriginal = segmentsToMerge.get(info);\n      if (isOriginal != null) {\n        segmentIsOriginal = isOriginal;\n        if (merging.contains(info) == false) {\n          eligible.add(info);\n        } else {\n          forceMergeRunning = true;\n        }\n      }\n    }\n\n    if (eligible.size() == 0) {\n      return null;\n    }\n\n    // The size can change concurrently while we are running here, because deletes\n    // are now applied concurrently, and this can piss off TimSort!  So we\n    // call size() once per segment and sort by that:\n    Map<SegmentCommitInfo,Long> sizeInBytes = getSegmentSizes(writer, eligible);\n\n    if ((maxSegmentCount > 1 && eligible.size() <= maxSegmentCount) ||\n        (maxSegmentCount == 1 && eligible.size() == 1 && (!segmentIsOriginal || isMerged(infos, eligible.get(0), writer)))) {\n      if (verbose(writer)) {\n        message(\"already merged\", writer);\n      }\n      return null;\n    }\n\n    Collections.sort(eligible, new SegmentByteSizeDescending(sizeInBytes));\n\n    if (verbose(writer)) {\n      message(\"eligible=\" + eligible, writer);\n      message(\"forceMergeRunning=\" + forceMergeRunning, writer);\n    }\n\n    int end = eligible.size();\n    \n    MergeSpecification spec = null;\n\n    // Do full merges, first, backwards:\n    while(end >= maxMergeAtOnceExplicit + maxSegmentCount - 1) {\n      if (spec == null) {\n        spec = new MergeSpecification();\n      }\n      final OneMerge merge = new OneMerge(eligible.subList(end-maxMergeAtOnceExplicit, end));\n      if (verbose(writer)) {\n        message(\"add merge=\" + writer.segString(merge.segments), writer);\n      }\n      spec.add(merge);\n      end -= maxMergeAtOnceExplicit;\n    }\n\n    if (spec == null && !forceMergeRunning) {\n      // Do final merge\n      final int numToMerge = end - maxSegmentCount + 1;\n      final OneMerge merge = new OneMerge(eligible.subList(end-numToMerge, end));\n      if (verbose(writer)) {\n        message(\"add final merge=\" + merge.segString(), writer);\n      }\n      spec = new MergeSpecification();\n      spec.add(merge);\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  @Override\n  public MergeSpecification findForcedMerges(SegmentInfos infos, int maxSegmentCount, Map<SegmentCommitInfo,Boolean> segmentsToMerge, IndexWriter writer) throws IOException {\n    if (verbose(writer)) {\n      message(\"findForcedMerges maxSegmentCount=\" + maxSegmentCount + \" infos=\" + writer.segString(infos) + \" segmentsToMerge=\" + segmentsToMerge, writer);\n    }\n\n    List<SegmentCommitInfo> eligible = new ArrayList<>();\n    boolean forceMergeRunning = false;\n    final Collection<SegmentCommitInfo> merging = writer.getMergingSegments();\n    boolean segmentIsOriginal = false;\n    for(SegmentCommitInfo info : infos) {\n      final Boolean isOriginal = segmentsToMerge.get(info);\n      if (isOriginal != null) {\n        segmentIsOriginal = isOriginal;\n        if (!merging.contains(info)) {\n          eligible.add(info);\n        } else {\n          forceMergeRunning = true;\n        }\n      }\n    }\n\n    if (eligible.size() == 0) {\n      return null;\n    }\n\n    if ((maxSegmentCount > 1 && eligible.size() <= maxSegmentCount) ||\n        (maxSegmentCount == 1 && eligible.size() == 1 && (!segmentIsOriginal || isMerged(infos, eligible.get(0), writer)))) {\n      if (verbose(writer)) {\n        message(\"already merged\", writer);\n      }\n      return null;\n    }\n\n    Collections.sort(eligible, new SegmentByteSizeDescending(writer));\n\n    if (verbose(writer)) {\n      message(\"eligible=\" + eligible, writer);\n      message(\"forceMergeRunning=\" + forceMergeRunning, writer);\n    }\n\n    int end = eligible.size();\n    \n    MergeSpecification spec = null;\n\n    // Do full merges, first, backwards:\n    while(end >= maxMergeAtOnceExplicit + maxSegmentCount - 1) {\n      if (spec == null) {\n        spec = new MergeSpecification();\n      }\n      final OneMerge merge = new OneMerge(eligible.subList(end-maxMergeAtOnceExplicit, end));\n      if (verbose(writer)) {\n        message(\"add merge=\" + writer.segString(merge.segments), writer);\n      }\n      spec.add(merge);\n      end -= maxMergeAtOnceExplicit;\n    }\n\n    if (spec == null && !forceMergeRunning) {\n      // Do final merge\n      final int numToMerge = end - maxSegmentCount + 1;\n      final OneMerge merge = new OneMerge(eligible.subList(end-numToMerge, end));\n      if (verbose(writer)) {\n        message(\"add final merge=\" + merge.segString(), writer);\n      }\n      spec = new MergeSpecification();\n      spec.add(merge);\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TieredMergePolicy#findForcedMerges(SegmentInfos,int,Map[SegmentCommitInfo,Boolean],IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TieredMergePolicy#findForcedMerges(SegmentInfos,int,Map[SegmentCommitInfo,Boolean],IndexWriter).mjava","sourceNew":"  @Override\n  public MergeSpecification findForcedMerges(SegmentInfos infos, int maxSegmentCount, Map<SegmentCommitInfo,Boolean> segmentsToMerge, IndexWriter writer) throws IOException {\n    if (verbose(writer)) {\n      message(\"findForcedMerges maxSegmentCount=\" + maxSegmentCount + \" infos=\" + writer.segString(infos) + \" segmentsToMerge=\" + segmentsToMerge, writer);\n    }\n\n    List<SegmentCommitInfo> eligible = new ArrayList<>();\n    boolean forceMergeRunning = false;\n    final Collection<SegmentCommitInfo> merging = writer.getMergingSegments();\n    boolean segmentIsOriginal = false;\n    for(SegmentCommitInfo info : infos) {\n      final Boolean isOriginal = segmentsToMerge.get(info);\n      if (isOriginal != null) {\n        segmentIsOriginal = isOriginal;\n        if (merging.contains(info) == false) {\n          eligible.add(info);\n        } else {\n          forceMergeRunning = true;\n        }\n      }\n    }\n\n    if (eligible.size() == 0) {\n      return null;\n    }\n\n    // The size can change concurrently while we are running here, because deletes\n    // are now applied concurrently, and this can piss off TimSort!  So we\n    // call size() once per segment and sort by that:\n    Map<SegmentCommitInfo,Long> sizeInBytes = getSegmentSizes(writer, eligible);\n\n    if ((maxSegmentCount > 1 && eligible.size() <= maxSegmentCount) ||\n        (maxSegmentCount == 1 && eligible.size() == 1 && (!segmentIsOriginal || isMerged(infos, eligible.get(0), writer)))) {\n      if (verbose(writer)) {\n        message(\"already merged\", writer);\n      }\n      return null;\n    }\n\n    Collections.sort(eligible, new SegmentByteSizeDescending(sizeInBytes));\n\n    if (verbose(writer)) {\n      message(\"eligible=\" + eligible, writer);\n      message(\"forceMergeRunning=\" + forceMergeRunning, writer);\n    }\n\n    int end = eligible.size();\n    \n    MergeSpecification spec = null;\n\n    // Do full merges, first, backwards:\n    while(end >= maxMergeAtOnceExplicit + maxSegmentCount - 1) {\n      if (spec == null) {\n        spec = new MergeSpecification();\n      }\n      final OneMerge merge = new OneMerge(eligible.subList(end-maxMergeAtOnceExplicit, end));\n      if (verbose(writer)) {\n        message(\"add merge=\" + writer.segString(merge.segments), writer);\n      }\n      spec.add(merge);\n      end -= maxMergeAtOnceExplicit;\n    }\n\n    if (spec == null && !forceMergeRunning) {\n      // Do final merge\n      final int numToMerge = end - maxSegmentCount + 1;\n      final OneMerge merge = new OneMerge(eligible.subList(end-numToMerge, end));\n      if (verbose(writer)) {\n        message(\"add final merge=\" + merge.segString(), writer);\n      }\n      spec = new MergeSpecification();\n      spec.add(merge);\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  @Override\n  public MergeSpecification findForcedMerges(SegmentInfos infos, int maxSegmentCount, Map<SegmentCommitInfo,Boolean> segmentsToMerge, IndexWriter writer) throws IOException {\n    if (verbose(writer)) {\n      message(\"findForcedMerges maxSegmentCount=\" + maxSegmentCount + \" infos=\" + writer.segString(infos) + \" segmentsToMerge=\" + segmentsToMerge, writer);\n    }\n\n    List<SegmentCommitInfo> eligible = new ArrayList<>();\n    boolean forceMergeRunning = false;\n    final Collection<SegmentCommitInfo> merging = writer.getMergingSegments();\n    boolean segmentIsOriginal = false;\n    for(SegmentCommitInfo info : infos) {\n      final Boolean isOriginal = segmentsToMerge.get(info);\n      if (isOriginal != null) {\n        segmentIsOriginal = isOriginal;\n        if (!merging.contains(info)) {\n          eligible.add(info);\n        } else {\n          forceMergeRunning = true;\n        }\n      }\n    }\n\n    if (eligible.size() == 0) {\n      return null;\n    }\n\n    if ((maxSegmentCount > 1 && eligible.size() <= maxSegmentCount) ||\n        (maxSegmentCount == 1 && eligible.size() == 1 && (!segmentIsOriginal || isMerged(infos, eligible.get(0), writer)))) {\n      if (verbose(writer)) {\n        message(\"already merged\", writer);\n      }\n      return null;\n    }\n\n    Collections.sort(eligible, new SegmentByteSizeDescending(writer));\n\n    if (verbose(writer)) {\n      message(\"eligible=\" + eligible, writer);\n      message(\"forceMergeRunning=\" + forceMergeRunning, writer);\n    }\n\n    int end = eligible.size();\n    \n    MergeSpecification spec = null;\n\n    // Do full merges, first, backwards:\n    while(end >= maxMergeAtOnceExplicit + maxSegmentCount - 1) {\n      if (spec == null) {\n        spec = new MergeSpecification();\n      }\n      final OneMerge merge = new OneMerge(eligible.subList(end-maxMergeAtOnceExplicit, end));\n      if (verbose(writer)) {\n        message(\"add merge=\" + writer.segString(merge.segments), writer);\n      }\n      spec.add(merge);\n      end -= maxMergeAtOnceExplicit;\n    }\n\n    if (spec == null && !forceMergeRunning) {\n      // Do final merge\n      final int numToMerge = end - maxSegmentCount + 1;\n      final OneMerge merge = new OneMerge(eligible.subList(end-numToMerge, end));\n      if (verbose(writer)) {\n        message(\"add final merge=\" + merge.segString(), writer);\n      }\n      spec = new MergeSpecification();\n      spec.add(merge);\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c0f10353be871363159f724b6419748c9b89c5c0","date":1501592481,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TieredMergePolicy#findForcedMerges(SegmentInfos,int,Map[SegmentCommitInfo,Boolean],IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TieredMergePolicy#findForcedMerges(SegmentInfos,int,Map[SegmentCommitInfo,Boolean],IndexWriter).mjava","sourceNew":"  @Override\n  public MergeSpecification findForcedMerges(SegmentInfos infos, int maxSegmentCount, Map<SegmentCommitInfo,Boolean> segmentsToMerge, IndexWriter writer) throws IOException {\n    if (verbose(writer)) {\n      message(\"findForcedMerges maxSegmentCount=\" + maxSegmentCount + \" infos=\" + writer.segString(infos) + \" segmentsToMerge=\" + segmentsToMerge, writer);\n    }\n\n    List<SegmentCommitInfo> eligible = new ArrayList<>();\n    boolean forceMergeRunning = false;\n    final Collection<SegmentCommitInfo> merging = writer.getMergingSegments();\n    boolean segmentIsOriginal = false;\n    for(SegmentCommitInfo info : infos) {\n      final Boolean isOriginal = segmentsToMerge.get(info);\n      if (isOriginal != null) {\n        segmentIsOriginal = isOriginal;\n        if (merging.contains(info) == false) {\n          eligible.add(info);\n        } else {\n          forceMergeRunning = true;\n        }\n      }\n    }\n\n    if (eligible.size() == 0) {\n      return null;\n    }\n\n    // The size can change concurrently while we are running here, because deletes\n    // are now applied concurrently, and this can piss off TimSort!  So we\n    // call size() once per segment and sort by that:\n    Map<SegmentCommitInfo,Long> sizeInBytes = getSegmentSizes(writer, eligible);\n\n    if ((maxSegmentCount > 1 && eligible.size() <= maxSegmentCount) ||\n        (maxSegmentCount == 1 && eligible.size() == 1 && (!segmentIsOriginal || isMerged(infos, eligible.get(0), writer)))) {\n      if (verbose(writer)) {\n        message(\"already merged\", writer);\n      }\n      return null;\n    }\n\n    eligible.sort(new SegmentByteSizeDescending(sizeInBytes));\n\n    if (verbose(writer)) {\n      message(\"eligible=\" + eligible, writer);\n      message(\"forceMergeRunning=\" + forceMergeRunning, writer);\n    }\n\n    int end = eligible.size();\n    \n    MergeSpecification spec = null;\n\n    // Do full merges, first, backwards:\n    while(end >= maxMergeAtOnceExplicit + maxSegmentCount - 1) {\n      if (spec == null) {\n        spec = new MergeSpecification();\n      }\n      final OneMerge merge = new OneMerge(eligible.subList(end-maxMergeAtOnceExplicit, end));\n      if (verbose(writer)) {\n        message(\"add merge=\" + writer.segString(merge.segments), writer);\n      }\n      spec.add(merge);\n      end -= maxMergeAtOnceExplicit;\n    }\n\n    if (spec == null && !forceMergeRunning) {\n      // Do final merge\n      final int numToMerge = end - maxSegmentCount + 1;\n      final OneMerge merge = new OneMerge(eligible.subList(end-numToMerge, end));\n      if (verbose(writer)) {\n        message(\"add final merge=\" + merge.segString(), writer);\n      }\n      spec = new MergeSpecification();\n      spec.add(merge);\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  @Override\n  public MergeSpecification findForcedMerges(SegmentInfos infos, int maxSegmentCount, Map<SegmentCommitInfo,Boolean> segmentsToMerge, IndexWriter writer) throws IOException {\n    if (verbose(writer)) {\n      message(\"findForcedMerges maxSegmentCount=\" + maxSegmentCount + \" infos=\" + writer.segString(infos) + \" segmentsToMerge=\" + segmentsToMerge, writer);\n    }\n\n    List<SegmentCommitInfo> eligible = new ArrayList<>();\n    boolean forceMergeRunning = false;\n    final Collection<SegmentCommitInfo> merging = writer.getMergingSegments();\n    boolean segmentIsOriginal = false;\n    for(SegmentCommitInfo info : infos) {\n      final Boolean isOriginal = segmentsToMerge.get(info);\n      if (isOriginal != null) {\n        segmentIsOriginal = isOriginal;\n        if (merging.contains(info) == false) {\n          eligible.add(info);\n        } else {\n          forceMergeRunning = true;\n        }\n      }\n    }\n\n    if (eligible.size() == 0) {\n      return null;\n    }\n\n    // The size can change concurrently while we are running here, because deletes\n    // are now applied concurrently, and this can piss off TimSort!  So we\n    // call size() once per segment and sort by that:\n    Map<SegmentCommitInfo,Long> sizeInBytes = getSegmentSizes(writer, eligible);\n\n    if ((maxSegmentCount > 1 && eligible.size() <= maxSegmentCount) ||\n        (maxSegmentCount == 1 && eligible.size() == 1 && (!segmentIsOriginal || isMerged(infos, eligible.get(0), writer)))) {\n      if (verbose(writer)) {\n        message(\"already merged\", writer);\n      }\n      return null;\n    }\n\n    Collections.sort(eligible, new SegmentByteSizeDescending(sizeInBytes));\n\n    if (verbose(writer)) {\n      message(\"eligible=\" + eligible, writer);\n      message(\"forceMergeRunning=\" + forceMergeRunning, writer);\n    }\n\n    int end = eligible.size();\n    \n    MergeSpecification spec = null;\n\n    // Do full merges, first, backwards:\n    while(end >= maxMergeAtOnceExplicit + maxSegmentCount - 1) {\n      if (spec == null) {\n        spec = new MergeSpecification();\n      }\n      final OneMerge merge = new OneMerge(eligible.subList(end-maxMergeAtOnceExplicit, end));\n      if (verbose(writer)) {\n        message(\"add merge=\" + writer.segString(merge.segments), writer);\n      }\n      spec.add(merge);\n      end -= maxMergeAtOnceExplicit;\n    }\n\n    if (spec == null && !forceMergeRunning) {\n      // Do final merge\n      final int numToMerge = end - maxSegmentCount + 1;\n      final OneMerge merge = new OneMerge(eligible.subList(end-numToMerge, end));\n      if (verbose(writer)) {\n        message(\"add final merge=\" + merge.segString(), writer);\n      }\n      spec = new MergeSpecification();\n      spec.add(merge);\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TieredMergePolicy#findForcedMerges(SegmentInfos,int,Map[SegmentCommitInfo,Boolean],IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TieredMergePolicy#findForcedMerges(SegmentInfos,int,Map[SegmentCommitInfo,Boolean],IndexWriter).mjava","sourceNew":"  @Override\n  public MergeSpecification findForcedMerges(SegmentInfos infos, int maxSegmentCount, Map<SegmentCommitInfo,Boolean> segmentsToMerge, IndexWriter writer) throws IOException {\n    if (verbose(writer)) {\n      message(\"findForcedMerges maxSegmentCount=\" + maxSegmentCount + \" infos=\" + writer.segString(infos) + \" segmentsToMerge=\" + segmentsToMerge, writer);\n    }\n\n    List<SegmentCommitInfo> eligible = new ArrayList<>();\n    boolean forceMergeRunning = false;\n    final Collection<SegmentCommitInfo> merging = writer.getMergingSegments();\n    boolean segmentIsOriginal = false;\n    for(SegmentCommitInfo info : infos) {\n      final Boolean isOriginal = segmentsToMerge.get(info);\n      if (isOriginal != null) {\n        segmentIsOriginal = isOriginal;\n        if (merging.contains(info) == false) {\n          eligible.add(info);\n        } else {\n          forceMergeRunning = true;\n        }\n      }\n    }\n\n    if (eligible.size() == 0) {\n      return null;\n    }\n\n    // The size can change concurrently while we are running here, because deletes\n    // are now applied concurrently, and this can piss off TimSort!  So we\n    // call size() once per segment and sort by that:\n    Map<SegmentCommitInfo,Long> sizeInBytes = getSegmentSizes(writer, eligible);\n\n    if ((maxSegmentCount > 1 && eligible.size() <= maxSegmentCount) ||\n        (maxSegmentCount == 1 && eligible.size() == 1 && (!segmentIsOriginal || isMerged(infos, eligible.get(0), writer)))) {\n      if (verbose(writer)) {\n        message(\"already merged\", writer);\n      }\n      return null;\n    }\n\n    eligible.sort(new SegmentByteSizeDescending(sizeInBytes));\n\n    if (verbose(writer)) {\n      message(\"eligible=\" + eligible, writer);\n      message(\"forceMergeRunning=\" + forceMergeRunning, writer);\n    }\n\n    int end = eligible.size();\n    \n    MergeSpecification spec = null;\n\n    // Do full merges, first, backwards:\n    while(end >= maxMergeAtOnceExplicit + maxSegmentCount - 1) {\n      if (spec == null) {\n        spec = new MergeSpecification();\n      }\n      final OneMerge merge = new OneMerge(eligible.subList(end-maxMergeAtOnceExplicit, end));\n      if (verbose(writer)) {\n        message(\"add merge=\" + writer.segString(merge.segments), writer);\n      }\n      spec.add(merge);\n      end -= maxMergeAtOnceExplicit;\n    }\n\n    if (spec == null && !forceMergeRunning) {\n      // Do final merge\n      final int numToMerge = end - maxSegmentCount + 1;\n      final OneMerge merge = new OneMerge(eligible.subList(end-numToMerge, end));\n      if (verbose(writer)) {\n        message(\"add final merge=\" + merge.segString(), writer);\n      }\n      spec = new MergeSpecification();\n      spec.add(merge);\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  @Override\n  public MergeSpecification findForcedMerges(SegmentInfos infos, int maxSegmentCount, Map<SegmentCommitInfo,Boolean> segmentsToMerge, IndexWriter writer) throws IOException {\n    if (verbose(writer)) {\n      message(\"findForcedMerges maxSegmentCount=\" + maxSegmentCount + \" infos=\" + writer.segString(infos) + \" segmentsToMerge=\" + segmentsToMerge, writer);\n    }\n\n    List<SegmentCommitInfo> eligible = new ArrayList<>();\n    boolean forceMergeRunning = false;\n    final Collection<SegmentCommitInfo> merging = writer.getMergingSegments();\n    boolean segmentIsOriginal = false;\n    for(SegmentCommitInfo info : infos) {\n      final Boolean isOriginal = segmentsToMerge.get(info);\n      if (isOriginal != null) {\n        segmentIsOriginal = isOriginal;\n        if (merging.contains(info) == false) {\n          eligible.add(info);\n        } else {\n          forceMergeRunning = true;\n        }\n      }\n    }\n\n    if (eligible.size() == 0) {\n      return null;\n    }\n\n    // The size can change concurrently while we are running here, because deletes\n    // are now applied concurrently, and this can piss off TimSort!  So we\n    // call size() once per segment and sort by that:\n    Map<SegmentCommitInfo,Long> sizeInBytes = getSegmentSizes(writer, eligible);\n\n    if ((maxSegmentCount > 1 && eligible.size() <= maxSegmentCount) ||\n        (maxSegmentCount == 1 && eligible.size() == 1 && (!segmentIsOriginal || isMerged(infos, eligible.get(0), writer)))) {\n      if (verbose(writer)) {\n        message(\"already merged\", writer);\n      }\n      return null;\n    }\n\n    Collections.sort(eligible, new SegmentByteSizeDescending(sizeInBytes));\n\n    if (verbose(writer)) {\n      message(\"eligible=\" + eligible, writer);\n      message(\"forceMergeRunning=\" + forceMergeRunning, writer);\n    }\n\n    int end = eligible.size();\n    \n    MergeSpecification spec = null;\n\n    // Do full merges, first, backwards:\n    while(end >= maxMergeAtOnceExplicit + maxSegmentCount - 1) {\n      if (spec == null) {\n        spec = new MergeSpecification();\n      }\n      final OneMerge merge = new OneMerge(eligible.subList(end-maxMergeAtOnceExplicit, end));\n      if (verbose(writer)) {\n        message(\"add merge=\" + writer.segString(merge.segments), writer);\n      }\n      spec.add(merge);\n      end -= maxMergeAtOnceExplicit;\n    }\n\n    if (spec == null && !forceMergeRunning) {\n      // Do final merge\n      final int numToMerge = end - maxSegmentCount + 1;\n      final OneMerge merge = new OneMerge(eligible.subList(end-numToMerge, end));\n      if (verbose(writer)) {\n        message(\"add final merge=\" + merge.segString(), writer);\n      }\n      spec = new MergeSpecification();\n      spec.add(merge);\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5399733c0eeb73827ff5b8aee51c110ec540e6f0","date":1511756706,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TieredMergePolicy#findForcedMerges(SegmentInfos,int,Map[SegmentCommitInfo,Boolean],IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TieredMergePolicy#findForcedMerges(SegmentInfos,int,Map[SegmentCommitInfo,Boolean],IndexWriter).mjava","sourceNew":"  @Override\n  public MergeSpecification findForcedMerges(SegmentInfos infos, int maxSegmentCount, Map<SegmentCommitInfo,Boolean> segmentsToMerge, IndexWriter writer) throws IOException {\n    if (verbose(writer)) {\n      message(\"findForcedMerges maxSegmentCount=\" + maxSegmentCount + \" infos=\" + writer.segString(infos) + \" segmentsToMerge=\" + segmentsToMerge, writer);\n    }\n\n    List<SegmentCommitInfo> eligible = new ArrayList<>();\n    boolean forceMergeRunning = false;\n    final Set<SegmentCommitInfo> merging = writer.getMergingSegments();\n    boolean segmentIsOriginal = false;\n    for(SegmentCommitInfo info : infos) {\n      final Boolean isOriginal = segmentsToMerge.get(info);\n      if (isOriginal != null) {\n        segmentIsOriginal = isOriginal;\n        if (merging.contains(info) == false) {\n          eligible.add(info);\n        } else {\n          forceMergeRunning = true;\n        }\n      }\n    }\n\n    if (eligible.size() == 0) {\n      return null;\n    }\n\n    // The size can change concurrently while we are running here, because deletes\n    // are now applied concurrently, and this can piss off TimSort!  So we\n    // call size() once per segment and sort by that:\n    Map<SegmentCommitInfo,Long> sizeInBytes = getSegmentSizes(writer, eligible);\n\n    if ((maxSegmentCount > 1 && eligible.size() <= maxSegmentCount) ||\n        (maxSegmentCount == 1 && eligible.size() == 1 && (!segmentIsOriginal || isMerged(infos, eligible.get(0), writer)))) {\n      if (verbose(writer)) {\n        message(\"already merged\", writer);\n      }\n      return null;\n    }\n\n    eligible.sort(new SegmentByteSizeDescending(sizeInBytes));\n\n    if (verbose(writer)) {\n      message(\"eligible=\" + eligible, writer);\n      message(\"forceMergeRunning=\" + forceMergeRunning, writer);\n    }\n\n    int end = eligible.size();\n    \n    MergeSpecification spec = null;\n\n    // Do full merges, first, backwards:\n    while(end >= maxMergeAtOnceExplicit + maxSegmentCount - 1) {\n      if (spec == null) {\n        spec = new MergeSpecification();\n      }\n      final OneMerge merge = new OneMerge(eligible.subList(end-maxMergeAtOnceExplicit, end));\n      if (verbose(writer)) {\n        message(\"add merge=\" + writer.segString(merge.segments), writer);\n      }\n      spec.add(merge);\n      end -= maxMergeAtOnceExplicit;\n    }\n\n    if (spec == null && !forceMergeRunning) {\n      // Do final merge\n      final int numToMerge = end - maxSegmentCount + 1;\n      final OneMerge merge = new OneMerge(eligible.subList(end-numToMerge, end));\n      if (verbose(writer)) {\n        message(\"add final merge=\" + merge.segString(), writer);\n      }\n      spec = new MergeSpecification();\n      spec.add(merge);\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  @Override\n  public MergeSpecification findForcedMerges(SegmentInfos infos, int maxSegmentCount, Map<SegmentCommitInfo,Boolean> segmentsToMerge, IndexWriter writer) throws IOException {\n    if (verbose(writer)) {\n      message(\"findForcedMerges maxSegmentCount=\" + maxSegmentCount + \" infos=\" + writer.segString(infos) + \" segmentsToMerge=\" + segmentsToMerge, writer);\n    }\n\n    List<SegmentCommitInfo> eligible = new ArrayList<>();\n    boolean forceMergeRunning = false;\n    final Collection<SegmentCommitInfo> merging = writer.getMergingSegments();\n    boolean segmentIsOriginal = false;\n    for(SegmentCommitInfo info : infos) {\n      final Boolean isOriginal = segmentsToMerge.get(info);\n      if (isOriginal != null) {\n        segmentIsOriginal = isOriginal;\n        if (merging.contains(info) == false) {\n          eligible.add(info);\n        } else {\n          forceMergeRunning = true;\n        }\n      }\n    }\n\n    if (eligible.size() == 0) {\n      return null;\n    }\n\n    // The size can change concurrently while we are running here, because deletes\n    // are now applied concurrently, and this can piss off TimSort!  So we\n    // call size() once per segment and sort by that:\n    Map<SegmentCommitInfo,Long> sizeInBytes = getSegmentSizes(writer, eligible);\n\n    if ((maxSegmentCount > 1 && eligible.size() <= maxSegmentCount) ||\n        (maxSegmentCount == 1 && eligible.size() == 1 && (!segmentIsOriginal || isMerged(infos, eligible.get(0), writer)))) {\n      if (verbose(writer)) {\n        message(\"already merged\", writer);\n      }\n      return null;\n    }\n\n    eligible.sort(new SegmentByteSizeDescending(sizeInBytes));\n\n    if (verbose(writer)) {\n      message(\"eligible=\" + eligible, writer);\n      message(\"forceMergeRunning=\" + forceMergeRunning, writer);\n    }\n\n    int end = eligible.size();\n    \n    MergeSpecification spec = null;\n\n    // Do full merges, first, backwards:\n    while(end >= maxMergeAtOnceExplicit + maxSegmentCount - 1) {\n      if (spec == null) {\n        spec = new MergeSpecification();\n      }\n      final OneMerge merge = new OneMerge(eligible.subList(end-maxMergeAtOnceExplicit, end));\n      if (verbose(writer)) {\n        message(\"add merge=\" + writer.segString(merge.segments), writer);\n      }\n      spec.add(merge);\n      end -= maxMergeAtOnceExplicit;\n    }\n\n    if (spec == null && !forceMergeRunning) {\n      // Do final merge\n      final int numToMerge = end - maxSegmentCount + 1;\n      final OneMerge merge = new OneMerge(eligible.subList(end-numToMerge, end));\n      if (verbose(writer)) {\n        message(\"add final merge=\" + merge.segString(), writer);\n      }\n      spec = new MergeSpecification();\n      spec.add(merge);\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f0e53d133180083c87dcb8114b087cfe6bfc7bce","date":1511856078,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TieredMergePolicy#findForcedMerges(SegmentInfos,int,Map[SegmentCommitInfo,Boolean],IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TieredMergePolicy#findForcedMerges(SegmentInfos,int,Map[SegmentCommitInfo,Boolean],IndexWriter).mjava","sourceNew":"  @Override\n  public MergeSpecification findForcedMerges(SegmentInfos infos, int maxSegmentCount, Map<SegmentCommitInfo,Boolean> segmentsToMerge, IndexWriter writer) throws IOException {\n    if (verbose(writer)) {\n      message(\"findForcedMerges maxSegmentCount=\" + maxSegmentCount + \" infos=\" + writer.segString(infos) + \" segmentsToMerge=\" + segmentsToMerge, writer);\n    }\n\n    List<SegmentCommitInfo> eligible = new ArrayList<>();\n    boolean forceMergeRunning = false;\n    final Set<SegmentCommitInfo> merging = writer.getMergingSegments();\n    boolean segmentIsOriginal = false;\n    for(SegmentCommitInfo info : infos) {\n      final Boolean isOriginal = segmentsToMerge.get(info);\n      if (isOriginal != null) {\n        segmentIsOriginal = isOriginal;\n        if (merging.contains(info) == false) {\n          eligible.add(info);\n        } else {\n          forceMergeRunning = true;\n        }\n      }\n    }\n\n    if (eligible.size() == 0) {\n      return null;\n    }\n\n    // The size can change concurrently while we are running here, because deletes\n    // are now applied concurrently, and this can piss off TimSort!  So we\n    // call size() once per segment and sort by that:\n    Map<SegmentCommitInfo,Long> sizeInBytes = getSegmentSizes(writer, eligible);\n\n    if ((maxSegmentCount > 1 && eligible.size() <= maxSegmentCount) ||\n        (maxSegmentCount == 1 && eligible.size() == 1 && (!segmentIsOriginal || isMerged(infos, eligible.get(0), writer)))) {\n      if (verbose(writer)) {\n        message(\"already merged\", writer);\n      }\n      return null;\n    }\n\n    eligible.sort(new SegmentByteSizeDescending(sizeInBytes));\n\n    if (verbose(writer)) {\n      message(\"eligible=\" + eligible, writer);\n      message(\"forceMergeRunning=\" + forceMergeRunning, writer);\n    }\n\n    int end = eligible.size();\n    \n    MergeSpecification spec = null;\n\n    // Do full merges, first, backwards:\n    while(end >= maxMergeAtOnceExplicit + maxSegmentCount - 1) {\n      if (spec == null) {\n        spec = new MergeSpecification();\n      }\n      final OneMerge merge = new OneMerge(eligible.subList(end-maxMergeAtOnceExplicit, end));\n      if (verbose(writer)) {\n        message(\"add merge=\" + writer.segString(merge.segments), writer);\n      }\n      spec.add(merge);\n      end -= maxMergeAtOnceExplicit;\n    }\n\n    if (spec == null && !forceMergeRunning) {\n      // Do final merge\n      final int numToMerge = end - maxSegmentCount + 1;\n      final OneMerge merge = new OneMerge(eligible.subList(end-numToMerge, end));\n      if (verbose(writer)) {\n        message(\"add final merge=\" + merge.segString(), writer);\n      }\n      spec = new MergeSpecification();\n      spec.add(merge);\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  @Override\n  public MergeSpecification findForcedMerges(SegmentInfos infos, int maxSegmentCount, Map<SegmentCommitInfo,Boolean> segmentsToMerge, IndexWriter writer) throws IOException {\n    if (verbose(writer)) {\n      message(\"findForcedMerges maxSegmentCount=\" + maxSegmentCount + \" infos=\" + writer.segString(infos) + \" segmentsToMerge=\" + segmentsToMerge, writer);\n    }\n\n    List<SegmentCommitInfo> eligible = new ArrayList<>();\n    boolean forceMergeRunning = false;\n    final Collection<SegmentCommitInfo> merging = writer.getMergingSegments();\n    boolean segmentIsOriginal = false;\n    for(SegmentCommitInfo info : infos) {\n      final Boolean isOriginal = segmentsToMerge.get(info);\n      if (isOriginal != null) {\n        segmentIsOriginal = isOriginal;\n        if (merging.contains(info) == false) {\n          eligible.add(info);\n        } else {\n          forceMergeRunning = true;\n        }\n      }\n    }\n\n    if (eligible.size() == 0) {\n      return null;\n    }\n\n    // The size can change concurrently while we are running here, because deletes\n    // are now applied concurrently, and this can piss off TimSort!  So we\n    // call size() once per segment and sort by that:\n    Map<SegmentCommitInfo,Long> sizeInBytes = getSegmentSizes(writer, eligible);\n\n    if ((maxSegmentCount > 1 && eligible.size() <= maxSegmentCount) ||\n        (maxSegmentCount == 1 && eligible.size() == 1 && (!segmentIsOriginal || isMerged(infos, eligible.get(0), writer)))) {\n      if (verbose(writer)) {\n        message(\"already merged\", writer);\n      }\n      return null;\n    }\n\n    eligible.sort(new SegmentByteSizeDescending(sizeInBytes));\n\n    if (verbose(writer)) {\n      message(\"eligible=\" + eligible, writer);\n      message(\"forceMergeRunning=\" + forceMergeRunning, writer);\n    }\n\n    int end = eligible.size();\n    \n    MergeSpecification spec = null;\n\n    // Do full merges, first, backwards:\n    while(end >= maxMergeAtOnceExplicit + maxSegmentCount - 1) {\n      if (spec == null) {\n        spec = new MergeSpecification();\n      }\n      final OneMerge merge = new OneMerge(eligible.subList(end-maxMergeAtOnceExplicit, end));\n      if (verbose(writer)) {\n        message(\"add merge=\" + writer.segString(merge.segments), writer);\n      }\n      spec.add(merge);\n      end -= maxMergeAtOnceExplicit;\n    }\n\n    if (spec == null && !forceMergeRunning) {\n      // Do final merge\n      final int numToMerge = end - maxSegmentCount + 1;\n      final OneMerge merge = new OneMerge(eligible.subList(end-numToMerge, end));\n      if (verbose(writer)) {\n        message(\"add final merge=\" + merge.segString(), writer);\n      }\n      spec = new MergeSpecification();\n      spec.add(merge);\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1d28f215464f76024caf026606f8ea51a5319c53","date":1527226629,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/TieredMergePolicy#findForcedMerges(SegmentInfos,int,Map[SegmentCommitInfo,Boolean],MergeContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/TieredMergePolicy#findForcedMerges(SegmentInfos,int,Map[SegmentCommitInfo,Boolean],IndexWriter).mjava","sourceNew":"  @Override\n  public MergeSpecification findForcedMerges(SegmentInfos infos, int maxSegmentCount, Map<SegmentCommitInfo,Boolean> segmentsToMerge, MergeContext mergeContext) throws IOException {\n    if (verbose(mergeContext)) {\n      message(\"findForcedMerges maxSegmentCount=\" + maxSegmentCount + \" infos=\" + segString(mergeContext, infos) + \" segmentsToMerge=\" + segmentsToMerge, mergeContext);\n    }\n\n    List<SegmentCommitInfo> eligible = new ArrayList<>();\n    boolean forceMergeRunning = false;\n    final Set<SegmentCommitInfo> merging = mergeContext.getMergingSegments();\n    boolean segmentIsOriginal = false;\n    for(SegmentCommitInfo info : infos) {\n      final Boolean isOriginal = segmentsToMerge.get(info);\n      if (isOriginal != null) {\n        segmentIsOriginal = isOriginal;\n        if (merging.contains(info) == false) {\n          eligible.add(info);\n        } else {\n          forceMergeRunning = true;\n        }\n      }\n    }\n\n    if (eligible.size() == 0) {\n      return null;\n    }\n\n    // The size can change concurrently while we are running here, because deletes\n    // are now applied concurrently, and this can piss off TimSort!  So we\n    // call size() once per segment and sort by that:\n    Map<SegmentCommitInfo,Long> sizeInBytes = getSegmentSizes(mergeContext, eligible);\n\n    if ((maxSegmentCount > 1 && eligible.size() <= maxSegmentCount) ||\n        (maxSegmentCount == 1 && eligible.size() == 1 && (!segmentIsOriginal || isMerged(infos, eligible.get(0), mergeContext)))) {\n      if (verbose(mergeContext)) {\n        message(\"already merged\", mergeContext);\n      }\n      return null;\n    }\n\n    eligible.sort(new SegmentByteSizeDescending(sizeInBytes));\n\n    if (verbose(mergeContext)) {\n      message(\"eligible=\" + eligible, mergeContext);\n      message(\"forceMergeRunning=\" + forceMergeRunning, mergeContext);\n    }\n\n    int end = eligible.size();\n    \n    MergeSpecification spec = null;\n\n    // Do full merges, first, backwards:\n    while(end >= maxMergeAtOnceExplicit + maxSegmentCount - 1) {\n      if (spec == null) {\n        spec = new MergeSpecification();\n      }\n      final OneMerge merge = new OneMerge(eligible.subList(end-maxMergeAtOnceExplicit, end));\n      if (verbose(mergeContext)) {\n        message(\"add merge=\" + segString(mergeContext, merge.segments), mergeContext);\n      }\n      spec.add(merge);\n      end -= maxMergeAtOnceExplicit;\n    }\n\n    if (spec == null && !forceMergeRunning) {\n      // Do final merge\n      final int numToMerge = end - maxSegmentCount + 1;\n      final OneMerge merge = new OneMerge(eligible.subList(end-numToMerge, end));\n      if (verbose(mergeContext)) {\n        message(\"add final merge=\" + merge.segString(), mergeContext);\n      }\n      spec = new MergeSpecification();\n      spec.add(merge);\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  @Override\n  public MergeSpecification findForcedMerges(SegmentInfos infos, int maxSegmentCount, Map<SegmentCommitInfo,Boolean> segmentsToMerge, IndexWriter writer) throws IOException {\n    if (verbose(writer)) {\n      message(\"findForcedMerges maxSegmentCount=\" + maxSegmentCount + \" infos=\" + writer.segString(infos) + \" segmentsToMerge=\" + segmentsToMerge, writer);\n    }\n\n    List<SegmentCommitInfo> eligible = new ArrayList<>();\n    boolean forceMergeRunning = false;\n    final Set<SegmentCommitInfo> merging = writer.getMergingSegments();\n    boolean segmentIsOriginal = false;\n    for(SegmentCommitInfo info : infos) {\n      final Boolean isOriginal = segmentsToMerge.get(info);\n      if (isOriginal != null) {\n        segmentIsOriginal = isOriginal;\n        if (merging.contains(info) == false) {\n          eligible.add(info);\n        } else {\n          forceMergeRunning = true;\n        }\n      }\n    }\n\n    if (eligible.size() == 0) {\n      return null;\n    }\n\n    // The size can change concurrently while we are running here, because deletes\n    // are now applied concurrently, and this can piss off TimSort!  So we\n    // call size() once per segment and sort by that:\n    Map<SegmentCommitInfo,Long> sizeInBytes = getSegmentSizes(writer, eligible);\n\n    if ((maxSegmentCount > 1 && eligible.size() <= maxSegmentCount) ||\n        (maxSegmentCount == 1 && eligible.size() == 1 && (!segmentIsOriginal || isMerged(infos, eligible.get(0), writer)))) {\n      if (verbose(writer)) {\n        message(\"already merged\", writer);\n      }\n      return null;\n    }\n\n    eligible.sort(new SegmentByteSizeDescending(sizeInBytes));\n\n    if (verbose(writer)) {\n      message(\"eligible=\" + eligible, writer);\n      message(\"forceMergeRunning=\" + forceMergeRunning, writer);\n    }\n\n    int end = eligible.size();\n    \n    MergeSpecification spec = null;\n\n    // Do full merges, first, backwards:\n    while(end >= maxMergeAtOnceExplicit + maxSegmentCount - 1) {\n      if (spec == null) {\n        spec = new MergeSpecification();\n      }\n      final OneMerge merge = new OneMerge(eligible.subList(end-maxMergeAtOnceExplicit, end));\n      if (verbose(writer)) {\n        message(\"add merge=\" + writer.segString(merge.segments), writer);\n      }\n      spec.add(merge);\n      end -= maxMergeAtOnceExplicit;\n    }\n\n    if (spec == null && !forceMergeRunning) {\n      // Do final merge\n      final int numToMerge = end - maxSegmentCount + 1;\n      final OneMerge merge = new OneMerge(eligible.subList(end-numToMerge, end));\n      if (verbose(writer)) {\n        message(\"add final merge=\" + merge.segString(), writer);\n      }\n      spec = new MergeSpecification();\n      spec.add(merge);\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":["79ba4baff197d5691f403962548d82fe855e4101"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","c0f10353be871363159f724b6419748c9b89c5c0"],"5399733c0eeb73827ff5b8aee51c110ec540e6f0":["c0f10353be871363159f724b6419748c9b89c5c0"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1d28f215464f76024caf026606f8ea51a5319c53":["f0e53d133180083c87dcb8114b087cfe6bfc7bce"],"c0f10353be871363159f724b6419748c9b89c5c0":["28288370235ed02234a64753cdbf0c6ec096304a"],"f0e53d133180083c87dcb8114b087cfe6bfc7bce":["c0f10353be871363159f724b6419748c9b89c5c0","5399733c0eeb73827ff5b8aee51c110ec540e6f0"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["027bee21e09164c9ee230395405076d1e0034b30"],"027bee21e09164c9ee230395405076d1e0034b30":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["5faf65b6692f15cca0f87bf8666c87899afc619f","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"28288370235ed02234a64753cdbf0c6ec096304a":["5faf65b6692f15cca0f87bf8666c87899afc619f","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1d28f215464f76024caf026606f8ea51a5319c53"]},"commit2Childs":{"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":[],"5399733c0eeb73827ff5b8aee51c110ec540e6f0":["f0e53d133180083c87dcb8114b087cfe6bfc7bce"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["027bee21e09164c9ee230395405076d1e0034b30"],"c0f10353be871363159f724b6419748c9b89c5c0":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","5399733c0eeb73827ff5b8aee51c110ec540e6f0","f0e53d133180083c87dcb8114b087cfe6bfc7bce"],"1d28f215464f76024caf026606f8ea51a5319c53":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f0e53d133180083c87dcb8114b087cfe6bfc7bce":["1d28f215464f76024caf026606f8ea51a5319c53"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["f4363cd33f6eff7fb4753574a441e2d18c1022a4","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"027bee21e09164c9ee230395405076d1e0034b30":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"28288370235ed02234a64753cdbf0c6ec096304a":["c0f10353be871363159f724b6419748c9b89c5c0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}