{"path":"lucene/src/test-framework/org/apache/lucene/index/RandomCodecProvider#RandomCodecProvider(Random).mjava","commits":[{"id":"e0eb7463fbe86f15add19bc7b9206f9e98a73144","date":1314325319,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/index/RandomCodecProvider#RandomCodecProvider(Random).mjava","pathOld":"/dev/null","sourceNew":"  public RandomCodecProvider(Random random) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    register(_TestUtil.randomizeCodec(random, new StandardCodec(minItemsPerBlock, maxItemsPerBlock)));\n    register(_TestUtil.randomizeCodec(random, new PreFlexCodec()));\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    maxItemsPerBlock = 2*(Math.max(1, minItemsPerBlock-1)) + random.nextInt(100);\n    register(_TestUtil.randomizeCodec(random, new PulsingCodec( 1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock)));\n    register(_TestUtil.randomizeCodec(random, new SimpleTextCodec()));\n    register(_TestUtil.randomizeCodec(random, new MemoryCodec()));\n    Collections.shuffle(knownCodecs, random);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["5f8d592a5e572553f95dd01f3e6875293829b375"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5f8d592a5e572553f95dd01f3e6875293829b375","date":1314526287,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/index/RandomCodecProvider#RandomCodecProvider(Random).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/index/RandomCodecProvider#RandomCodecProvider(Random).mjava","sourceNew":"  public RandomCodecProvider(Random random) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    register(new StandardCodec(minItemsPerBlock, maxItemsPerBlock));\n    register(new PreFlexCodec());\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    maxItemsPerBlock = 2*(Math.max(1, minItemsPerBlock-1)) + random.nextInt(100);\n    register(new PulsingCodec( 1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock));\n    register(new SimpleTextCodec());\n    register(new MemoryCodec());\n    Collections.shuffle(knownCodecs, random);\n  }\n\n","sourceOld":"  public RandomCodecProvider(Random random) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    register(_TestUtil.randomizeCodec(random, new StandardCodec(minItemsPerBlock, maxItemsPerBlock)));\n    register(_TestUtil.randomizeCodec(random, new PreFlexCodec()));\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    maxItemsPerBlock = 2*(Math.max(1, minItemsPerBlock-1)) + random.nextInt(100);\n    register(_TestUtil.randomizeCodec(random, new PulsingCodec( 1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock)));\n    register(_TestUtil.randomizeCodec(random, new SimpleTextCodec()));\n    register(_TestUtil.randomizeCodec(random, new MemoryCodec()));\n    Collections.shuffle(knownCodecs, random);\n  }\n\n","bugFix":["e0eb7463fbe86f15add19bc7b9206f9e98a73144"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fdbabcdfbf0ec1640188c28570cd54fd30440942","date":1317820582,"type":5,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/index/RandomCodecProvider#RandomCodecProvider(Random,boolean).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/index/RandomCodecProvider#RandomCodecProvider(Random).mjava","sourceNew":"  public RandomCodecProvider(Random random, boolean useNoMemoryExpensiveCodec) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    register(new StandardCodec(minItemsPerBlock, maxItemsPerBlock));\n    register(new PreFlexCodec());\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    maxItemsPerBlock = 2*(Math.max(1, minItemsPerBlock-1)) + random.nextInt(100);\n    register(new PulsingCodec( 1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock));\n    if (!useNoMemoryExpensiveCodec) {\n      register(new SimpleTextCodec());\n      register(new MemoryCodec());\n    }\n    Collections.shuffle(knownCodecs, random);\n  }\n\n","sourceOld":"  public RandomCodecProvider(Random random) {\n    this.perFieldSeed = random.nextInt();\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);\n    register(new StandardCodec(minItemsPerBlock, maxItemsPerBlock));\n    register(new PreFlexCodec());\n    // TODO: make it possible to specify min/max iterms per\n    // block via CL:\n    minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);\n    maxItemsPerBlock = 2*(Math.max(1, minItemsPerBlock-1)) + random.nextInt(100);\n    register(new PulsingCodec( 1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock));\n    register(new SimpleTextCodec());\n    register(new MemoryCodec());\n    Collections.shuffle(knownCodecs, random);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5f8d592a5e572553f95dd01f3e6875293829b375":["e0eb7463fbe86f15add19bc7b9206f9e98a73144"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fdbabcdfbf0ec1640188c28570cd54fd30440942":["5f8d592a5e572553f95dd01f3e6875293829b375"],"e0eb7463fbe86f15add19bc7b9206f9e98a73144":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fdbabcdfbf0ec1640188c28570cd54fd30440942"]},"commit2Childs":{"5f8d592a5e572553f95dd01f3e6875293829b375":["fdbabcdfbf0ec1640188c28570cd54fd30440942"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e0eb7463fbe86f15add19bc7b9206f9e98a73144"],"fdbabcdfbf0ec1640188c28570cd54fd30440942":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e0eb7463fbe86f15add19bc7b9206f9e98a73144":["5f8d592a5e572553f95dd01f3e6875293829b375"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}