{"path":"solr/core/src/java/org/apache/solr/util/SolrCLI.AutoscalingTool#simulate(SolrCloudManager,AutoScalingConfig,Map[String,Object],String,boolean,boolean,boolean,boolean,boolean,int,boolean).mjava","commits":[{"id":"d3d2a34ea3732f91149b31bcad82026ad85fda69","date":1567850949,"type":1,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI.AutoscalingTool#simulate(SolrCloudManager,AutoScalingConfig,Map[String,Object],String,boolean,boolean,boolean,boolean,boolean,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI.AutoscalingTool#simulate(SolrCloudManager,AutoScalingConfig,Map[String,Object],String,boolean,boolean,boolean,boolean,boolean,int).mjava","sourceNew":"    private void simulate(SolrCloudManager cloudManager,\n                          AutoScalingConfig config,\n                          Map<String, Object> results,\n                          String saveSimulated,\n                          boolean withClusterState,\n                          boolean withStats,\n                          boolean withSuggestions,\n                          boolean withSortedNodes,\n                          boolean withDiagnostics, int iterations, boolean redact) throws Exception {\n      File saveDir = null;\n      if (saveSimulated != null) {\n        saveDir = new File(saveSimulated);\n        if (!saveDir.exists()) {\n          if (!saveDir.mkdirs()) {\n            throw new Exception(\"Unable to create 'saveSimulated' directory: \" + saveDir.getAbsolutePath());\n          }\n        } else if (!saveDir.isDirectory()) {\n          throw new Exception(\"'saveSimulated' path exists and is not a directory! \" + saveDir.getAbsolutePath());\n        }\n      }\n      int SPEED = 50;\n      SimCloudManager simCloudManager = SimCloudManager.createCluster(cloudManager, config, TimeSource.get(\"simTime:\" + SPEED));\n      int loop = 0;\n      List<Suggester.SuggestionInfo> suggestions = Collections.emptyList();\n      Map<String, Object> intermediate = new LinkedHashMap<>();\n      results.put(\"intermediate\", intermediate);\n      while (loop < iterations) {\n        LinkedHashMap<String, Object> perStep = new LinkedHashMap<>();\n        long start = TimeSource.NANO_TIME.getTimeNs();\n        suggestions = PolicyHelper.getSuggestions(config, simCloudManager);\n        CLIO.err(\"-- step \" + loop + \", \" + suggestions.size() + \" suggestions.\");\n        long end = TimeSource.NANO_TIME.getTimeNs();\n        CLIO.err(\"   - calculated in \" + TimeUnit.NANOSECONDS.toMillis(end - start) + \" ms (real time ≈ simulated time)\");\n        if (suggestions.isEmpty()) {\n          break;\n        }\n        SnapshotCloudManager snapshotCloudManager = new SnapshotCloudManager(simCloudManager, config);\n        if (saveDir != null) {\n          File target = new File(saveDir, \"step\" + loop + \"_start\");\n          snapshotCloudManager.saveSnapshot(target, true, redact);\n        }\n        if (verbose) {\n          Map<String, Object> snapshot = snapshotCloudManager.getSnapshot(false, redact);\n          snapshot.remove(SnapshotCloudManager.DISTRIB_STATE_KEY);\n          snapshot.remove(SnapshotCloudManager.MANAGER_STATE_KEY);\n          perStep.put(\"snapshotStart\", snapshot);\n        }\n        intermediate.put(\"step\" + loop, perStep);\n        int unresolvedCount = 0;\n        start = TimeSource.NANO_TIME.getTimeNs();\n        List<Map<String, Object>> perStepOps = new ArrayList<>(suggestions.size());\n        if (withSuggestions) {\n          perStep.put(\"suggestions\", suggestions);\n          perStep.put(\"opDetails\", perStepOps);\n        }\n        for (Suggester.SuggestionInfo suggestion : suggestions) {\n          SolrRequest operation = suggestion.getOperation();\n          if (operation == null) {\n            unresolvedCount++;\n            if (suggestion.getViolation() == null) {\n              CLIO.err(\"   - ignoring suggestion without violation and without operation: \" + suggestion);\n            }\n            continue;\n          }\n          SolrParams params = operation.getParams();\n          if (operation instanceof V2Request) {\n            params = SimUtils.v2AdminRequestToV1Params((V2Request)operation);\n          }\n          Map<String, Object> paramsMap = new LinkedHashMap<>();\n          params.toMap(paramsMap);\n          ReplicaInfo info = simCloudManager.getSimClusterStateProvider().simGetReplicaInfo(\n              params.get(CollectionAdminParams.COLLECTION), params.get(\"replica\"));\n          if (info == null) {\n            CLIO.err(\"Could not find ReplicaInfo for params: \" + params);\n          } else if (verbose) {\n            paramsMap.put(\"replicaInfo\", info);\n          } else if (info.getVariable(Variable.Type.CORE_IDX.tagName) != null) {\n            paramsMap.put(Variable.Type.CORE_IDX.tagName, info.getVariable(Variable.Type.CORE_IDX.tagName));\n          }\n          if (withSuggestions) {\n            perStepOps.add(paramsMap);\n          }\n          try {\n            simCloudManager.request(operation);\n          } catch (Exception e) {\n            CLIO.err(\"Aborting - error executing suggestion \" + suggestion + \": \" + e);\n            Map<String, Object> error = new HashMap<>();\n            error.put(\"suggestion\", suggestion);\n            error.put(\"replicaInfo\", info);\n            error.put(\"exception\", e);\n            perStep.put(\"error\", error);\n            break;\n          }\n        }\n        end = TimeSource.NANO_TIME.getTimeNs();\n        long realTime = TimeUnit.NANOSECONDS.toMillis(end - start);\n        long simTime = realTime * SPEED;\n        CLIO.err(\"   - executed in \" + realTime + \" ms (real time), \" + simTime + \" ms (simulated time)\");\n        if (unresolvedCount == suggestions.size()) {\n          CLIO.err(\"--- aborting simulation, only unresolved violations remain\");\n          break;\n        }\n        if (withStats) {\n          perStep.put(\"statsExecutionStop\", SimUtils.calculateStats(simCloudManager, config, verbose));\n        }\n        snapshotCloudManager = new SnapshotCloudManager(simCloudManager, config);\n        if (saveDir != null) {\n          File target = new File(saveDir, \"step\" + loop + \"_stop\");\n          snapshotCloudManager.saveSnapshot(target, true, redact);\n        }\n        if (verbose) {\n          Map<String, Object> snapshot = snapshotCloudManager.getSnapshot(false, redact);\n          snapshot.remove(SnapshotCloudManager.DISTRIB_STATE_KEY);\n          snapshot.remove(SnapshotCloudManager.MANAGER_STATE_KEY);\n          perStep.put(\"snapshotStop\", snapshot);\n        }\n        loop++;\n      }\n      if (loop == iterations && !suggestions.isEmpty()) {\n        CLIO.err(\"### Failed to apply all suggestions in \" + iterations + \" steps. Remaining suggestions: \" + suggestions + \"\\n\");\n      }\n      results.put(\"finalState\", prepareResults(simCloudManager, config, withClusterState, withStats,\n          withSuggestions, withSortedNodes, withDiagnostics));\n    }\n\n","sourceOld":"    private void simulate(SolrCloudManager cloudManager,\n                          AutoScalingConfig config,\n                          Map<String, Object> results,\n                          String saveSimulated,\n                          boolean withClusterState,\n                          boolean withStats,\n                          boolean withSuggestions,\n                          boolean withSortedNodes,\n                          boolean withDiagnostics, int iterations) throws Exception {\n      File saveDir = null;\n      if (saveSimulated != null) {\n        saveDir = new File(saveSimulated);\n        if (!saveDir.exists()) {\n          if (!saveDir.mkdirs()) {\n            throw new Exception(\"Unable to create 'saveSimulated' directory: \" + saveDir.getAbsolutePath());\n          }\n        } else if (!saveDir.isDirectory()) {\n          throw new Exception(\"'saveSimulated' path exists and is not a directory! \" + saveDir.getAbsolutePath());\n        }\n      }\n      int SPEED = 50;\n      SimCloudManager simCloudManager = SimCloudManager.createCluster(cloudManager, config, TimeSource.get(\"simTime:\" + SPEED));\n      int loop = 0;\n      List<Suggester.SuggestionInfo> suggestions = Collections.emptyList();\n      Map<String, Object> intermediate = new LinkedHashMap<>();\n      results.put(\"intermediate\", intermediate);\n      while (loop < iterations) {\n        LinkedHashMap<String, Object> perStep = new LinkedHashMap<>();\n        long start = TimeSource.NANO_TIME.getTimeNs();\n        suggestions = PolicyHelper.getSuggestions(config, simCloudManager);\n        CLIO.err(\"-- step \" + loop + \", \" + suggestions.size() + \" suggestions.\");\n        long end = TimeSource.NANO_TIME.getTimeNs();\n        CLIO.err(\"   - calculated in \" + TimeUnit.NANOSECONDS.toMillis(end - start) + \" ms (real time ≈ simulated time)\");\n        if (suggestions.isEmpty()) {\n          break;\n        }\n        SnapshotCloudManager snapshotCloudManager = new SnapshotCloudManager(simCloudManager, config);\n        if (saveDir != null) {\n          File target = new File(saveDir, \"step\" + loop + \"_start\");\n          snapshotCloudManager.saveSnapshot(target, true);\n        }\n        if (verbose) {\n          Map<String, Object> snapshot = snapshotCloudManager.getSnapshot(false);\n          snapshot.remove(SnapshotCloudManager.DISTRIB_STATE_KEY);\n          snapshot.remove(SnapshotCloudManager.MANAGER_STATE_KEY);\n          perStep.put(\"snapshotStart\", snapshot);\n        }\n        intermediate.put(\"step\" + loop, perStep);\n        int unresolvedCount = 0;\n        start = TimeSource.NANO_TIME.getTimeNs();\n        List<Map<String, Object>> perStepOps = new ArrayList<>(suggestions.size());\n        if (withSuggestions) {\n          perStep.put(\"suggestions\", suggestions);\n          perStep.put(\"opDetails\", perStepOps);\n        }\n        for (Suggester.SuggestionInfo suggestion : suggestions) {\n          SolrRequest operation = suggestion.getOperation();\n          if (operation == null) {\n            unresolvedCount++;\n            if (suggestion.getViolation() == null) {\n              CLIO.err(\"   - ignoring suggestion without violation and without operation: \" + suggestion);\n            }\n            continue;\n          }\n          SolrParams params = operation.getParams();\n          if (operation instanceof V2Request) {\n            params = SimUtils.v2AdminRequestToV1Params((V2Request)operation);\n          }\n          Map<String, Object> paramsMap = new LinkedHashMap<>();\n          params.toMap(paramsMap);\n          ReplicaInfo info = simCloudManager.getSimClusterStateProvider().simGetReplicaInfo(\n              params.get(CollectionAdminParams.COLLECTION), params.get(\"replica\"));\n          if (info == null) {\n            CLIO.err(\"Could not find ReplicaInfo for params: \" + params);\n          } else if (verbose) {\n            paramsMap.put(\"replicaInfo\", info);\n          } else if (info.getVariable(Variable.Type.CORE_IDX.tagName) != null) {\n            paramsMap.put(Variable.Type.CORE_IDX.tagName, info.getVariable(Variable.Type.CORE_IDX.tagName));\n          }\n          if (withSuggestions) {\n            perStepOps.add(paramsMap);\n          }\n          try {\n            simCloudManager.request(operation);\n          } catch (Exception e) {\n            CLIO.err(\"Aborting - error executing suggestion \" + suggestion + \": \" + e);\n            Map<String, Object> error = new HashMap<>();\n            error.put(\"suggestion\", suggestion);\n            error.put(\"replicaInfo\", info);\n            error.put(\"exception\", e);\n            perStep.put(\"error\", error);\n            break;\n          }\n        }\n        end = TimeSource.NANO_TIME.getTimeNs();\n        long realTime = TimeUnit.NANOSECONDS.toMillis(end - start);\n        long simTime = realTime * SPEED;\n        CLIO.err(\"   - executed in \" + realTime + \" ms (real time), \" + simTime + \" ms (simulated time)\");\n        if (unresolvedCount == suggestions.size()) {\n          CLIO.err(\"--- aborting simulation, only unresolved violations remain\");\n          break;\n        }\n        if (withStats) {\n          perStep.put(\"statsExecutionStop\", SimUtils.calculateStats(simCloudManager, config, verbose));\n        }\n        snapshotCloudManager = new SnapshotCloudManager(simCloudManager, config);\n        if (saveDir != null) {\n          File target = new File(saveDir, \"step\" + loop + \"_stop\");\n          snapshotCloudManager.saveSnapshot(target, true);\n        }\n        if (verbose) {\n          Map<String, Object> snapshot = snapshotCloudManager.getSnapshot(false);\n          snapshot.remove(SnapshotCloudManager.DISTRIB_STATE_KEY);\n          snapshot.remove(SnapshotCloudManager.MANAGER_STATE_KEY);\n          perStep.put(\"snapshotStop\", snapshot);\n        }\n        loop++;\n      }\n      if (loop == iterations && !suggestions.isEmpty()) {\n        CLIO.err(\"### Failed to apply all suggestions in \" + iterations + \" steps. Remaining suggestions: \" + suggestions + \"\\n\");\n      }\n      results.put(\"finalState\", prepareResults(simCloudManager, config, withClusterState, withStats,\n          withSuggestions, withSortedNodes, withDiagnostics));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ee8fbffa595c312bc0437f2c9bb6376a29c1b427","date":1589412657,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI.AutoscalingTool#simulate(SolrCloudManager,AutoScalingConfig,Map[String,Object],String,boolean,boolean,boolean,boolean,boolean,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI.AutoscalingTool#simulate(SolrCloudManager,AutoScalingConfig,Map[String,Object],String,boolean,boolean,boolean,boolean,boolean,int,boolean).mjava","sourceNew":"    private void simulate(SolrCloudManager cloudManager,\n                          AutoScalingConfig config,\n                          Map<String, Object> results,\n                          String saveSimulated,\n                          boolean withClusterState,\n                          boolean withStats,\n                          boolean withSuggestions,\n                          boolean withSortedNodes,\n                          boolean withDiagnostics, int iterations, boolean redact) throws Exception {\n      File saveDir = null;\n      if (saveSimulated != null) {\n        saveDir = new File(saveSimulated);\n        if (!saveDir.exists()) {\n          if (!saveDir.mkdirs()) {\n            throw new Exception(\"Unable to create 'saveSimulated' directory: \" + saveDir.getAbsolutePath());\n          }\n        } else if (!saveDir.isDirectory()) {\n          throw new Exception(\"'saveSimulated' path exists and is not a directory! \" + saveDir.getAbsolutePath());\n        }\n      }\n      int SPEED = 50;\n      SimCloudManager simCloudManager = SimCloudManager.createCluster(cloudManager, config, TimeSource.get(\"simTime:\" + SPEED));\n      int loop = 0;\n      List<Suggester.SuggestionInfo> suggestions = Collections.emptyList();\n      Map<String, Object> intermediate = new LinkedHashMap<>();\n      results.put(\"intermediate\", intermediate);\n      while (loop < iterations) {\n        LinkedHashMap<String, Object> perStep = new LinkedHashMap<>();\n        long start = TimeSource.NANO_TIME.getTimeNs();\n        suggestions = PolicyHelper.getSuggestions(config, simCloudManager);\n        CLIO.err(\"-- step \" + loop + \", \" + suggestions.size() + \" suggestions.\");\n        long end = TimeSource.NANO_TIME.getTimeNs();\n        CLIO.err(\"   - calculated in \" + TimeUnit.NANOSECONDS.toMillis(end - start) + \" ms (real time ≈ simulated time)\");\n        if (suggestions.isEmpty()) {\n          break;\n        }\n        SnapshotCloudManager snapshotCloudManager = new SnapshotCloudManager(simCloudManager, config);\n        if (saveDir != null) {\n          File target = new File(saveDir, \"step\" + loop + \"_start\");\n          snapshotCloudManager.saveSnapshot(target, true, redact);\n        }\n        if (verbose) {\n          Map<String, Object> snapshot = snapshotCloudManager.getSnapshot(false, redact);\n          snapshot.remove(SnapshotCloudManager.DISTRIB_STATE_KEY);\n          snapshot.remove(SnapshotCloudManager.MANAGER_STATE_KEY);\n          perStep.put(\"snapshotStart\", snapshot);\n        }\n        intermediate.put(\"step\" + loop, perStep);\n        int unresolvedCount = 0;\n        start = TimeSource.NANO_TIME.getTimeNs();\n        List<Map<String, Object>> perStepOps = new ArrayList<>(suggestions.size());\n        if (withSuggestions) {\n          perStep.put(\"suggestions\", suggestions);\n          perStep.put(\"opDetails\", perStepOps);\n        }\n        for (Suggester.SuggestionInfo suggestion : suggestions) {\n          SolrRequest<?> operation = suggestion.getOperation();\n          if (operation == null) {\n            unresolvedCount++;\n            if (suggestion.getViolation() == null) {\n              CLIO.err(\"   - ignoring suggestion without violation and without operation: \" + suggestion);\n            }\n            continue;\n          }\n          SolrParams params = operation.getParams();\n          if (operation instanceof V2Request) {\n            params = SimUtils.v2AdminRequestToV1Params((V2Request)operation);\n          }\n          Map<String, Object> paramsMap = new LinkedHashMap<>();\n          params.toMap(paramsMap);\n          ReplicaInfo info = simCloudManager.getSimClusterStateProvider().simGetReplicaInfo(\n              params.get(CollectionAdminParams.COLLECTION), params.get(\"replica\"));\n          if (info == null) {\n            CLIO.err(\"Could not find ReplicaInfo for params: \" + params);\n          } else if (verbose) {\n            paramsMap.put(\"replicaInfo\", info);\n          } else if (info.getVariable(Variable.Type.CORE_IDX.tagName) != null) {\n            paramsMap.put(Variable.Type.CORE_IDX.tagName, info.getVariable(Variable.Type.CORE_IDX.tagName));\n          }\n          if (withSuggestions) {\n            perStepOps.add(paramsMap);\n          }\n          try {\n            simCloudManager.request(operation);\n          } catch (Exception e) {\n            CLIO.err(\"Aborting - error executing suggestion \" + suggestion + \": \" + e);\n            Map<String, Object> error = new HashMap<>();\n            error.put(\"suggestion\", suggestion);\n            error.put(\"replicaInfo\", info);\n            error.put(\"exception\", e);\n            perStep.put(\"error\", error);\n            break;\n          }\n        }\n        end = TimeSource.NANO_TIME.getTimeNs();\n        long realTime = TimeUnit.NANOSECONDS.toMillis(end - start);\n        long simTime = realTime * SPEED;\n        CLIO.err(\"   - executed in \" + realTime + \" ms (real time), \" + simTime + \" ms (simulated time)\");\n        if (unresolvedCount == suggestions.size()) {\n          CLIO.err(\"--- aborting simulation, only unresolved violations remain\");\n          break;\n        }\n        if (withStats) {\n          perStep.put(\"statsExecutionStop\", SimUtils.calculateStats(simCloudManager, config, verbose));\n        }\n        snapshotCloudManager = new SnapshotCloudManager(simCloudManager, config);\n        if (saveDir != null) {\n          File target = new File(saveDir, \"step\" + loop + \"_stop\");\n          snapshotCloudManager.saveSnapshot(target, true, redact);\n        }\n        if (verbose) {\n          Map<String, Object> snapshot = snapshotCloudManager.getSnapshot(false, redact);\n          snapshot.remove(SnapshotCloudManager.DISTRIB_STATE_KEY);\n          snapshot.remove(SnapshotCloudManager.MANAGER_STATE_KEY);\n          perStep.put(\"snapshotStop\", snapshot);\n        }\n        loop++;\n      }\n      if (loop == iterations && !suggestions.isEmpty()) {\n        CLIO.err(\"### Failed to apply all suggestions in \" + iterations + \" steps. Remaining suggestions: \" + suggestions + \"\\n\");\n      }\n      results.put(\"finalState\", prepareResults(simCloudManager, config, withClusterState, withStats,\n          withSuggestions, withSortedNodes, withDiagnostics));\n    }\n\n","sourceOld":"    private void simulate(SolrCloudManager cloudManager,\n                          AutoScalingConfig config,\n                          Map<String, Object> results,\n                          String saveSimulated,\n                          boolean withClusterState,\n                          boolean withStats,\n                          boolean withSuggestions,\n                          boolean withSortedNodes,\n                          boolean withDiagnostics, int iterations, boolean redact) throws Exception {\n      File saveDir = null;\n      if (saveSimulated != null) {\n        saveDir = new File(saveSimulated);\n        if (!saveDir.exists()) {\n          if (!saveDir.mkdirs()) {\n            throw new Exception(\"Unable to create 'saveSimulated' directory: \" + saveDir.getAbsolutePath());\n          }\n        } else if (!saveDir.isDirectory()) {\n          throw new Exception(\"'saveSimulated' path exists and is not a directory! \" + saveDir.getAbsolutePath());\n        }\n      }\n      int SPEED = 50;\n      SimCloudManager simCloudManager = SimCloudManager.createCluster(cloudManager, config, TimeSource.get(\"simTime:\" + SPEED));\n      int loop = 0;\n      List<Suggester.SuggestionInfo> suggestions = Collections.emptyList();\n      Map<String, Object> intermediate = new LinkedHashMap<>();\n      results.put(\"intermediate\", intermediate);\n      while (loop < iterations) {\n        LinkedHashMap<String, Object> perStep = new LinkedHashMap<>();\n        long start = TimeSource.NANO_TIME.getTimeNs();\n        suggestions = PolicyHelper.getSuggestions(config, simCloudManager);\n        CLIO.err(\"-- step \" + loop + \", \" + suggestions.size() + \" suggestions.\");\n        long end = TimeSource.NANO_TIME.getTimeNs();\n        CLIO.err(\"   - calculated in \" + TimeUnit.NANOSECONDS.toMillis(end - start) + \" ms (real time ≈ simulated time)\");\n        if (suggestions.isEmpty()) {\n          break;\n        }\n        SnapshotCloudManager snapshotCloudManager = new SnapshotCloudManager(simCloudManager, config);\n        if (saveDir != null) {\n          File target = new File(saveDir, \"step\" + loop + \"_start\");\n          snapshotCloudManager.saveSnapshot(target, true, redact);\n        }\n        if (verbose) {\n          Map<String, Object> snapshot = snapshotCloudManager.getSnapshot(false, redact);\n          snapshot.remove(SnapshotCloudManager.DISTRIB_STATE_KEY);\n          snapshot.remove(SnapshotCloudManager.MANAGER_STATE_KEY);\n          perStep.put(\"snapshotStart\", snapshot);\n        }\n        intermediate.put(\"step\" + loop, perStep);\n        int unresolvedCount = 0;\n        start = TimeSource.NANO_TIME.getTimeNs();\n        List<Map<String, Object>> perStepOps = new ArrayList<>(suggestions.size());\n        if (withSuggestions) {\n          perStep.put(\"suggestions\", suggestions);\n          perStep.put(\"opDetails\", perStepOps);\n        }\n        for (Suggester.SuggestionInfo suggestion : suggestions) {\n          SolrRequest operation = suggestion.getOperation();\n          if (operation == null) {\n            unresolvedCount++;\n            if (suggestion.getViolation() == null) {\n              CLIO.err(\"   - ignoring suggestion without violation and without operation: \" + suggestion);\n            }\n            continue;\n          }\n          SolrParams params = operation.getParams();\n          if (operation instanceof V2Request) {\n            params = SimUtils.v2AdminRequestToV1Params((V2Request)operation);\n          }\n          Map<String, Object> paramsMap = new LinkedHashMap<>();\n          params.toMap(paramsMap);\n          ReplicaInfo info = simCloudManager.getSimClusterStateProvider().simGetReplicaInfo(\n              params.get(CollectionAdminParams.COLLECTION), params.get(\"replica\"));\n          if (info == null) {\n            CLIO.err(\"Could not find ReplicaInfo for params: \" + params);\n          } else if (verbose) {\n            paramsMap.put(\"replicaInfo\", info);\n          } else if (info.getVariable(Variable.Type.CORE_IDX.tagName) != null) {\n            paramsMap.put(Variable.Type.CORE_IDX.tagName, info.getVariable(Variable.Type.CORE_IDX.tagName));\n          }\n          if (withSuggestions) {\n            perStepOps.add(paramsMap);\n          }\n          try {\n            simCloudManager.request(operation);\n          } catch (Exception e) {\n            CLIO.err(\"Aborting - error executing suggestion \" + suggestion + \": \" + e);\n            Map<String, Object> error = new HashMap<>();\n            error.put(\"suggestion\", suggestion);\n            error.put(\"replicaInfo\", info);\n            error.put(\"exception\", e);\n            perStep.put(\"error\", error);\n            break;\n          }\n        }\n        end = TimeSource.NANO_TIME.getTimeNs();\n        long realTime = TimeUnit.NANOSECONDS.toMillis(end - start);\n        long simTime = realTime * SPEED;\n        CLIO.err(\"   - executed in \" + realTime + \" ms (real time), \" + simTime + \" ms (simulated time)\");\n        if (unresolvedCount == suggestions.size()) {\n          CLIO.err(\"--- aborting simulation, only unresolved violations remain\");\n          break;\n        }\n        if (withStats) {\n          perStep.put(\"statsExecutionStop\", SimUtils.calculateStats(simCloudManager, config, verbose));\n        }\n        snapshotCloudManager = new SnapshotCloudManager(simCloudManager, config);\n        if (saveDir != null) {\n          File target = new File(saveDir, \"step\" + loop + \"_stop\");\n          snapshotCloudManager.saveSnapshot(target, true, redact);\n        }\n        if (verbose) {\n          Map<String, Object> snapshot = snapshotCloudManager.getSnapshot(false, redact);\n          snapshot.remove(SnapshotCloudManager.DISTRIB_STATE_KEY);\n          snapshot.remove(SnapshotCloudManager.MANAGER_STATE_KEY);\n          perStep.put(\"snapshotStop\", snapshot);\n        }\n        loop++;\n      }\n      if (loop == iterations && !suggestions.isEmpty()) {\n        CLIO.err(\"### Failed to apply all suggestions in \" + iterations + \" steps. Remaining suggestions: \" + suggestions + \"\\n\");\n      }\n      results.put(\"finalState\", prepareResults(simCloudManager, config, withClusterState, withStats,\n          withSuggestions, withSortedNodes, withDiagnostics));\n    }\n\n","bugFix":["edf5b262a72d10530eb2f01dc8f19060355b213e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd","date":1594731683,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI.AutoscalingTool#simulate(SolrCloudManager,AutoScalingConfig,Map[String,Object],String,boolean,boolean,boolean,boolean,boolean,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI.AutoscalingTool#simulate(SolrCloudManager,AutoScalingConfig,Map[String,Object],String,boolean,boolean,boolean,boolean,boolean,int,boolean).mjava","sourceNew":"    private void simulate(SolrCloudManager cloudManager,\n                          AutoScalingConfig config,\n                          Map<String, Object> results,\n                          String saveSimulated,\n                          boolean withClusterState,\n                          boolean withStats,\n                          boolean withSuggestions,\n                          boolean withSortedNodes,\n                          boolean withDiagnostics, int iterations, boolean redact) throws Exception {\n      File saveDir = null;\n      if (saveSimulated != null) {\n        saveDir = new File(saveSimulated);\n        if (!saveDir.exists()) {\n          if (!saveDir.mkdirs()) {\n            throw new Exception(\"Unable to create 'saveSimulated' directory: \" + saveDir.getAbsolutePath());\n          }\n        } else if (!saveDir.isDirectory()) {\n          throw new Exception(\"'saveSimulated' path exists and is not a directory! \" + saveDir.getAbsolutePath());\n        }\n      }\n      int SPEED = 50;\n      SimCloudManager simCloudManager = SimCloudManager.createCluster(cloudManager, config, TimeSource.get(\"simTime:\" + SPEED));\n      int loop = 0;\n      List<Suggester.SuggestionInfo> suggestions = Collections.emptyList();\n      Map<String, Object> intermediate = new LinkedHashMap<>();\n      results.put(\"intermediate\", intermediate);\n      while (loop < iterations) {\n        LinkedHashMap<String, Object> perStep = new LinkedHashMap<>();\n        long start = TimeSource.NANO_TIME.getTimeNs();\n        suggestions = PolicyHelper.getSuggestions(config, simCloudManager);\n        CLIO.err(\"-- step \" + loop + \", \" + suggestions.size() + \" suggestions.\");\n        long end = TimeSource.NANO_TIME.getTimeNs();\n        CLIO.err(\"   - calculated in \" + TimeUnit.NANOSECONDS.toMillis(end - start) + \" ms (real time ≈ simulated time)\");\n        if (suggestions.isEmpty()) {\n          break;\n        }\n        SnapshotCloudManager snapshotCloudManager = new SnapshotCloudManager(simCloudManager, config);\n        if (saveDir != null) {\n          File target = new File(saveDir, \"step\" + loop + \"_start\");\n          snapshotCloudManager.saveSnapshot(target, true, redact);\n        }\n        if (verbose) {\n          Map<String, Object> snapshot = snapshotCloudManager.getSnapshot(false, redact);\n          snapshot.remove(SnapshotCloudManager.DISTRIB_STATE_KEY);\n          snapshot.remove(SnapshotCloudManager.MANAGER_STATE_KEY);\n          perStep.put(\"snapshotStart\", snapshot);\n        }\n        intermediate.put(\"step\" + loop, perStep);\n        int unresolvedCount = 0;\n        start = TimeSource.NANO_TIME.getTimeNs();\n        List<Map<String, Object>> perStepOps = new ArrayList<>(suggestions.size());\n        if (withSuggestions) {\n          perStep.put(\"suggestions\", suggestions);\n          perStep.put(\"opDetails\", perStepOps);\n        }\n        for (Suggester.SuggestionInfo suggestion : suggestions) {\n          SolrRequest<?> operation = suggestion.getOperation();\n          if (operation == null) {\n            unresolvedCount++;\n            if (suggestion.getViolation() == null) {\n              CLIO.err(\"   - ignoring suggestion without violation and without operation: \" + suggestion);\n            }\n            continue;\n          }\n          SolrParams params = operation.getParams();\n          if (operation instanceof V2Request) {\n            params = SimUtils.v2AdminRequestToV1Params((V2Request)operation);\n          }\n          Map<String, Object> paramsMap = new LinkedHashMap<>();\n          params.toMap(paramsMap);\n          Replica info = simCloudManager.getSimClusterStateProvider().simGetReplicaInfo(\n              params.get(CollectionAdminParams.COLLECTION), params.get(\"replica\"));\n          if (info == null) {\n            CLIO.err(\"Could not find ReplicaInfo for params: \" + params);\n          } else if (verbose) {\n            paramsMap.put(\"replicaInfo\", info);\n          } else if (info.get(Variable.Type.CORE_IDX.tagName) != null) {\n            paramsMap.put(Variable.Type.CORE_IDX.tagName, info.get(Variable.Type.CORE_IDX.tagName));\n          }\n          if (withSuggestions) {\n            perStepOps.add(paramsMap);\n          }\n          try {\n            simCloudManager.request(operation);\n          } catch (Exception e) {\n            CLIO.err(\"Aborting - error executing suggestion \" + suggestion + \": \" + e);\n            Map<String, Object> error = new HashMap<>();\n            error.put(\"suggestion\", suggestion);\n            error.put(\"replicaInfo\", info);\n            error.put(\"exception\", e);\n            perStep.put(\"error\", error);\n            break;\n          }\n        }\n        end = TimeSource.NANO_TIME.getTimeNs();\n        long realTime = TimeUnit.NANOSECONDS.toMillis(end - start);\n        long simTime = realTime * SPEED;\n        CLIO.err(\"   - executed in \" + realTime + \" ms (real time), \" + simTime + \" ms (simulated time)\");\n        if (unresolvedCount == suggestions.size()) {\n          CLIO.err(\"--- aborting simulation, only unresolved violations remain\");\n          break;\n        }\n        if (withStats) {\n          perStep.put(\"statsExecutionStop\", SimUtils.calculateStats(simCloudManager, config, verbose));\n        }\n        snapshotCloudManager = new SnapshotCloudManager(simCloudManager, config);\n        if (saveDir != null) {\n          File target = new File(saveDir, \"step\" + loop + \"_stop\");\n          snapshotCloudManager.saveSnapshot(target, true, redact);\n        }\n        if (verbose) {\n          Map<String, Object> snapshot = snapshotCloudManager.getSnapshot(false, redact);\n          snapshot.remove(SnapshotCloudManager.DISTRIB_STATE_KEY);\n          snapshot.remove(SnapshotCloudManager.MANAGER_STATE_KEY);\n          perStep.put(\"snapshotStop\", snapshot);\n        }\n        loop++;\n      }\n      if (loop == iterations && !suggestions.isEmpty()) {\n        CLIO.err(\"### Failed to apply all suggestions in \" + iterations + \" steps. Remaining suggestions: \" + suggestions + \"\\n\");\n      }\n      results.put(\"finalState\", prepareResults(simCloudManager, config, withClusterState, withStats,\n          withSuggestions, withSortedNodes, withDiagnostics));\n    }\n\n","sourceOld":"    private void simulate(SolrCloudManager cloudManager,\n                          AutoScalingConfig config,\n                          Map<String, Object> results,\n                          String saveSimulated,\n                          boolean withClusterState,\n                          boolean withStats,\n                          boolean withSuggestions,\n                          boolean withSortedNodes,\n                          boolean withDiagnostics, int iterations, boolean redact) throws Exception {\n      File saveDir = null;\n      if (saveSimulated != null) {\n        saveDir = new File(saveSimulated);\n        if (!saveDir.exists()) {\n          if (!saveDir.mkdirs()) {\n            throw new Exception(\"Unable to create 'saveSimulated' directory: \" + saveDir.getAbsolutePath());\n          }\n        } else if (!saveDir.isDirectory()) {\n          throw new Exception(\"'saveSimulated' path exists and is not a directory! \" + saveDir.getAbsolutePath());\n        }\n      }\n      int SPEED = 50;\n      SimCloudManager simCloudManager = SimCloudManager.createCluster(cloudManager, config, TimeSource.get(\"simTime:\" + SPEED));\n      int loop = 0;\n      List<Suggester.SuggestionInfo> suggestions = Collections.emptyList();\n      Map<String, Object> intermediate = new LinkedHashMap<>();\n      results.put(\"intermediate\", intermediate);\n      while (loop < iterations) {\n        LinkedHashMap<String, Object> perStep = new LinkedHashMap<>();\n        long start = TimeSource.NANO_TIME.getTimeNs();\n        suggestions = PolicyHelper.getSuggestions(config, simCloudManager);\n        CLIO.err(\"-- step \" + loop + \", \" + suggestions.size() + \" suggestions.\");\n        long end = TimeSource.NANO_TIME.getTimeNs();\n        CLIO.err(\"   - calculated in \" + TimeUnit.NANOSECONDS.toMillis(end - start) + \" ms (real time ≈ simulated time)\");\n        if (suggestions.isEmpty()) {\n          break;\n        }\n        SnapshotCloudManager snapshotCloudManager = new SnapshotCloudManager(simCloudManager, config);\n        if (saveDir != null) {\n          File target = new File(saveDir, \"step\" + loop + \"_start\");\n          snapshotCloudManager.saveSnapshot(target, true, redact);\n        }\n        if (verbose) {\n          Map<String, Object> snapshot = snapshotCloudManager.getSnapshot(false, redact);\n          snapshot.remove(SnapshotCloudManager.DISTRIB_STATE_KEY);\n          snapshot.remove(SnapshotCloudManager.MANAGER_STATE_KEY);\n          perStep.put(\"snapshotStart\", snapshot);\n        }\n        intermediate.put(\"step\" + loop, perStep);\n        int unresolvedCount = 0;\n        start = TimeSource.NANO_TIME.getTimeNs();\n        List<Map<String, Object>> perStepOps = new ArrayList<>(suggestions.size());\n        if (withSuggestions) {\n          perStep.put(\"suggestions\", suggestions);\n          perStep.put(\"opDetails\", perStepOps);\n        }\n        for (Suggester.SuggestionInfo suggestion : suggestions) {\n          SolrRequest<?> operation = suggestion.getOperation();\n          if (operation == null) {\n            unresolvedCount++;\n            if (suggestion.getViolation() == null) {\n              CLIO.err(\"   - ignoring suggestion without violation and without operation: \" + suggestion);\n            }\n            continue;\n          }\n          SolrParams params = operation.getParams();\n          if (operation instanceof V2Request) {\n            params = SimUtils.v2AdminRequestToV1Params((V2Request)operation);\n          }\n          Map<String, Object> paramsMap = new LinkedHashMap<>();\n          params.toMap(paramsMap);\n          ReplicaInfo info = simCloudManager.getSimClusterStateProvider().simGetReplicaInfo(\n              params.get(CollectionAdminParams.COLLECTION), params.get(\"replica\"));\n          if (info == null) {\n            CLIO.err(\"Could not find ReplicaInfo for params: \" + params);\n          } else if (verbose) {\n            paramsMap.put(\"replicaInfo\", info);\n          } else if (info.getVariable(Variable.Type.CORE_IDX.tagName) != null) {\n            paramsMap.put(Variable.Type.CORE_IDX.tagName, info.getVariable(Variable.Type.CORE_IDX.tagName));\n          }\n          if (withSuggestions) {\n            perStepOps.add(paramsMap);\n          }\n          try {\n            simCloudManager.request(operation);\n          } catch (Exception e) {\n            CLIO.err(\"Aborting - error executing suggestion \" + suggestion + \": \" + e);\n            Map<String, Object> error = new HashMap<>();\n            error.put(\"suggestion\", suggestion);\n            error.put(\"replicaInfo\", info);\n            error.put(\"exception\", e);\n            perStep.put(\"error\", error);\n            break;\n          }\n        }\n        end = TimeSource.NANO_TIME.getTimeNs();\n        long realTime = TimeUnit.NANOSECONDS.toMillis(end - start);\n        long simTime = realTime * SPEED;\n        CLIO.err(\"   - executed in \" + realTime + \" ms (real time), \" + simTime + \" ms (simulated time)\");\n        if (unresolvedCount == suggestions.size()) {\n          CLIO.err(\"--- aborting simulation, only unresolved violations remain\");\n          break;\n        }\n        if (withStats) {\n          perStep.put(\"statsExecutionStop\", SimUtils.calculateStats(simCloudManager, config, verbose));\n        }\n        snapshotCloudManager = new SnapshotCloudManager(simCloudManager, config);\n        if (saveDir != null) {\n          File target = new File(saveDir, \"step\" + loop + \"_stop\");\n          snapshotCloudManager.saveSnapshot(target, true, redact);\n        }\n        if (verbose) {\n          Map<String, Object> snapshot = snapshotCloudManager.getSnapshot(false, redact);\n          snapshot.remove(SnapshotCloudManager.DISTRIB_STATE_KEY);\n          snapshot.remove(SnapshotCloudManager.MANAGER_STATE_KEY);\n          perStep.put(\"snapshotStop\", snapshot);\n        }\n        loop++;\n      }\n      if (loop == iterations && !suggestions.isEmpty()) {\n        CLIO.err(\"### Failed to apply all suggestions in \" + iterations + \" steps. Remaining suggestions: \" + suggestions + \"\\n\");\n      }\n      results.put(\"finalState\", prepareResults(simCloudManager, config, withClusterState, withStats,\n          withSuggestions, withSortedNodes, withDiagnostics));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI.AutoscalingTool#simulate(SolrCloudManager,AutoScalingConfig,Map[String,Object],String,boolean,boolean,boolean,boolean,boolean,int,boolean).mjava","sourceNew":null,"sourceOld":"    private void simulate(SolrCloudManager cloudManager,\n                          AutoScalingConfig config,\n                          Map<String, Object> results,\n                          String saveSimulated,\n                          boolean withClusterState,\n                          boolean withStats,\n                          boolean withSuggestions,\n                          boolean withSortedNodes,\n                          boolean withDiagnostics, int iterations, boolean redact) throws Exception {\n      File saveDir = null;\n      if (saveSimulated != null) {\n        saveDir = new File(saveSimulated);\n        if (!saveDir.exists()) {\n          if (!saveDir.mkdirs()) {\n            throw new Exception(\"Unable to create 'saveSimulated' directory: \" + saveDir.getAbsolutePath());\n          }\n        } else if (!saveDir.isDirectory()) {\n          throw new Exception(\"'saveSimulated' path exists and is not a directory! \" + saveDir.getAbsolutePath());\n        }\n      }\n      int SPEED = 50;\n      SimCloudManager simCloudManager = SimCloudManager.createCluster(cloudManager, config, TimeSource.get(\"simTime:\" + SPEED));\n      int loop = 0;\n      List<Suggester.SuggestionInfo> suggestions = Collections.emptyList();\n      Map<String, Object> intermediate = new LinkedHashMap<>();\n      results.put(\"intermediate\", intermediate);\n      while (loop < iterations) {\n        LinkedHashMap<String, Object> perStep = new LinkedHashMap<>();\n        long start = TimeSource.NANO_TIME.getTimeNs();\n        suggestions = PolicyHelper.getSuggestions(config, simCloudManager);\n        CLIO.err(\"-- step \" + loop + \", \" + suggestions.size() + \" suggestions.\");\n        long end = TimeSource.NANO_TIME.getTimeNs();\n        CLIO.err(\"   - calculated in \" + TimeUnit.NANOSECONDS.toMillis(end - start) + \" ms (real time ≈ simulated time)\");\n        if (suggestions.isEmpty()) {\n          break;\n        }\n        SnapshotCloudManager snapshotCloudManager = new SnapshotCloudManager(simCloudManager, config);\n        if (saveDir != null) {\n          File target = new File(saveDir, \"step\" + loop + \"_start\");\n          snapshotCloudManager.saveSnapshot(target, true, redact);\n        }\n        if (verbose) {\n          Map<String, Object> snapshot = snapshotCloudManager.getSnapshot(false, redact);\n          snapshot.remove(SnapshotCloudManager.DISTRIB_STATE_KEY);\n          snapshot.remove(SnapshotCloudManager.MANAGER_STATE_KEY);\n          perStep.put(\"snapshotStart\", snapshot);\n        }\n        intermediate.put(\"step\" + loop, perStep);\n        int unresolvedCount = 0;\n        start = TimeSource.NANO_TIME.getTimeNs();\n        List<Map<String, Object>> perStepOps = new ArrayList<>(suggestions.size());\n        if (withSuggestions) {\n          perStep.put(\"suggestions\", suggestions);\n          perStep.put(\"opDetails\", perStepOps);\n        }\n        for (Suggester.SuggestionInfo suggestion : suggestions) {\n          SolrRequest<?> operation = suggestion.getOperation();\n          if (operation == null) {\n            unresolvedCount++;\n            if (suggestion.getViolation() == null) {\n              CLIO.err(\"   - ignoring suggestion without violation and without operation: \" + suggestion);\n            }\n            continue;\n          }\n          SolrParams params = operation.getParams();\n          if (operation instanceof V2Request) {\n            params = SimUtils.v2AdminRequestToV1Params((V2Request)operation);\n          }\n          Map<String, Object> paramsMap = new LinkedHashMap<>();\n          params.toMap(paramsMap);\n          Replica info = simCloudManager.getSimClusterStateProvider().simGetReplicaInfo(\n              params.get(CollectionAdminParams.COLLECTION), params.get(\"replica\"));\n          if (info == null) {\n            CLIO.err(\"Could not find ReplicaInfo for params: \" + params);\n          } else if (verbose) {\n            paramsMap.put(\"replicaInfo\", info);\n          } else if (info.get(Variable.Type.CORE_IDX.tagName) != null) {\n            paramsMap.put(Variable.Type.CORE_IDX.tagName, info.get(Variable.Type.CORE_IDX.tagName));\n          }\n          if (withSuggestions) {\n            perStepOps.add(paramsMap);\n          }\n          try {\n            simCloudManager.request(operation);\n          } catch (Exception e) {\n            CLIO.err(\"Aborting - error executing suggestion \" + suggestion + \": \" + e);\n            Map<String, Object> error = new HashMap<>();\n            error.put(\"suggestion\", suggestion);\n            error.put(\"replicaInfo\", info);\n            error.put(\"exception\", e);\n            perStep.put(\"error\", error);\n            break;\n          }\n        }\n        end = TimeSource.NANO_TIME.getTimeNs();\n        long realTime = TimeUnit.NANOSECONDS.toMillis(end - start);\n        long simTime = realTime * SPEED;\n        CLIO.err(\"   - executed in \" + realTime + \" ms (real time), \" + simTime + \" ms (simulated time)\");\n        if (unresolvedCount == suggestions.size()) {\n          CLIO.err(\"--- aborting simulation, only unresolved violations remain\");\n          break;\n        }\n        if (withStats) {\n          perStep.put(\"statsExecutionStop\", SimUtils.calculateStats(simCloudManager, config, verbose));\n        }\n        snapshotCloudManager = new SnapshotCloudManager(simCloudManager, config);\n        if (saveDir != null) {\n          File target = new File(saveDir, \"step\" + loop + \"_stop\");\n          snapshotCloudManager.saveSnapshot(target, true, redact);\n        }\n        if (verbose) {\n          Map<String, Object> snapshot = snapshotCloudManager.getSnapshot(false, redact);\n          snapshot.remove(SnapshotCloudManager.DISTRIB_STATE_KEY);\n          snapshot.remove(SnapshotCloudManager.MANAGER_STATE_KEY);\n          perStep.put(\"snapshotStop\", snapshot);\n        }\n        loop++;\n      }\n      if (loop == iterations && !suggestions.isEmpty()) {\n        CLIO.err(\"### Failed to apply all suggestions in \" + iterations + \" steps. Remaining suggestions: \" + suggestions + \"\\n\");\n      }\n      results.put(\"finalState\", prepareResults(simCloudManager, config, withClusterState, withStats,\n          withSuggestions, withSortedNodes, withDiagnostics));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3d2a34ea3732f91149b31bcad82026ad85fda69":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd":["ee8fbffa595c312bc0437f2c9bb6376a29c1b427"],"3f504512a03d978990cbff30db0522b354e846db":["7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ee8fbffa595c312bc0437f2c9bb6376a29c1b427":["d3d2a34ea3732f91149b31bcad82026ad85fda69"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"]},"commit2Childs":{"d3d2a34ea3732f91149b31bcad82026ad85fda69":["ee8fbffa595c312bc0437f2c9bb6376a29c1b427"],"7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd":["3f504512a03d978990cbff30db0522b354e846db"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d3d2a34ea3732f91149b31bcad82026ad85fda69"],"ee8fbffa595c312bc0437f2c9bb6376a29c1b427":["7e8ce2f9d2ddfcf5cfa7e73b8b2af287a2a276fd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}