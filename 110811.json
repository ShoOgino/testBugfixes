{"path":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#[T]_keywordTokenStream(Collection[T]).mjava","commits":[{"id":"f11899016a0460a7ea2e4b008d002e1e75c7d867","date":1256772085,"type":1,"author":"Uwe Schindler","isMerge":false,"pathNew":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#[T]_keywordTokenStream(Collection[T]).mjava","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#keywordTokenStream(Collection).mjava","sourceNew":"  /**\n   * Convenience method; Creates and returns a token stream that generates a\n   * token for each keyword in the given collection, \"as is\", without any\n   * transforming text analysis. The resulting token stream can be fed into\n   * {@link #addField(String, TokenStream)}, perhaps wrapped into another\n   * {@link org.apache.lucene.analysis.TokenFilter}, as desired.\n   * \n   * @param keywords\n   *            the keywords to generate tokens for\n   * @return the corresponding token stream\n   */\n  public <T> TokenStream keywordTokenStream(final Collection<T> keywords) {\n    // TODO: deprecate & move this method into AnalyzerUtil?\n    if (keywords == null)\n      throw new IllegalArgumentException(\"keywords must not be null\");\n    \n    return new TokenStream() {\n      private Iterator<T> iter = keywords.iterator();\n      private int start = 0;\n      private TermAttribute termAtt = addAttribute(TermAttribute.class);\n      private OffsetAttribute offsetAtt = addAttribute(OffsetAttribute.class);\n      \n      public boolean incrementToken() {\n        if (!iter.hasNext()) return false;\n        \n        T obj = iter.next();\n        if (obj == null) \n          throw new IllegalArgumentException(\"keyword must not be null\");\n        \n        String term = obj.toString();\n        termAtt.setTermBuffer(term);\n        offsetAtt.setOffset(start, start+termAtt.termLength());\n        start += term.length() + 1; // separate words by 1 (blank) character\n        return true;\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Convenience method; Creates and returns a token stream that generates a\n   * token for each keyword in the given collection, \"as is\", without any\n   * transforming text analysis. The resulting token stream can be fed into\n   * {@link #addField(String, TokenStream)}, perhaps wrapped into another\n   * {@link org.apache.lucene.analysis.TokenFilter}, as desired.\n   * \n   * @param keywords\n   *            the keywords to generate tokens for\n   * @return the corresponding token stream\n   */\n  public TokenStream keywordTokenStream(final Collection keywords) {\n    // TODO: deprecate & move this method into AnalyzerUtil?\n    if (keywords == null)\n      throw new IllegalArgumentException(\"keywords must not be null\");\n    \n    return new TokenStream() {\n      private Iterator iter = keywords.iterator();\n      private int start = 0;\n      private TermAttribute termAtt = addAttribute(TermAttribute.class);\n      private OffsetAttribute offsetAtt = addAttribute(OffsetAttribute.class);\n      \n      public boolean incrementToken() {\n        if (!iter.hasNext()) return false;\n        \n        Object obj = iter.next();\n        if (obj == null) \n          throw new IllegalArgumentException(\"keyword must not be null\");\n        \n        String term = obj.toString();\n        termAtt.setTermBuffer(term);\n        offsetAtt.setOffset(start, start+termAtt.termLength());\n        start += term.length() + 1; // separate words by 1 (blank) character\n        return true;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d57eb7c98c08c03af6e4cd83509df31c81ac16af","date":1257684312,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#[T]_keywordTokenStream(Collection[T]).mjava","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#[T]_keywordTokenStream(Collection[T]).mjava","sourceNew":"  /**\n   * Convenience method; Creates and returns a token stream that generates a\n   * token for each keyword in the given collection, \"as is\", without any\n   * transforming text analysis. The resulting token stream can be fed into\n   * {@link #addField(String, TokenStream)}, perhaps wrapped into another\n   * {@link org.apache.lucene.analysis.TokenFilter}, as desired.\n   * \n   * @param keywords\n   *            the keywords to generate tokens for\n   * @return the corresponding token stream\n   */\n  public <T> TokenStream keywordTokenStream(final Collection<T> keywords) {\n    // TODO: deprecate & move this method into AnalyzerUtil?\n    if (keywords == null)\n      throw new IllegalArgumentException(\"keywords must not be null\");\n    \n    return new TokenStream() {\n      private Iterator<T> iter = keywords.iterator();\n      private int start = 0;\n      private TermAttribute termAtt = addAttribute(TermAttribute.class);\n      private OffsetAttribute offsetAtt = addAttribute(OffsetAttribute.class);\n      \n      @Override\n      public boolean incrementToken() {\n        if (!iter.hasNext()) return false;\n        \n        T obj = iter.next();\n        if (obj == null) \n          throw new IllegalArgumentException(\"keyword must not be null\");\n        \n        String term = obj.toString();\n        termAtt.setTermBuffer(term);\n        offsetAtt.setOffset(start, start+termAtt.termLength());\n        start += term.length() + 1; // separate words by 1 (blank) character\n        return true;\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Convenience method; Creates and returns a token stream that generates a\n   * token for each keyword in the given collection, \"as is\", without any\n   * transforming text analysis. The resulting token stream can be fed into\n   * {@link #addField(String, TokenStream)}, perhaps wrapped into another\n   * {@link org.apache.lucene.analysis.TokenFilter}, as desired.\n   * \n   * @param keywords\n   *            the keywords to generate tokens for\n   * @return the corresponding token stream\n   */\n  public <T> TokenStream keywordTokenStream(final Collection<T> keywords) {\n    // TODO: deprecate & move this method into AnalyzerUtil?\n    if (keywords == null)\n      throw new IllegalArgumentException(\"keywords must not be null\");\n    \n    return new TokenStream() {\n      private Iterator<T> iter = keywords.iterator();\n      private int start = 0;\n      private TermAttribute termAtt = addAttribute(TermAttribute.class);\n      private OffsetAttribute offsetAtt = addAttribute(OffsetAttribute.class);\n      \n      public boolean incrementToken() {\n        if (!iter.hasNext()) return false;\n        \n        T obj = iter.next();\n        if (obj == null) \n          throw new IllegalArgumentException(\"keyword must not be null\");\n        \n        String term = obj.toString();\n        termAtt.setTermBuffer(term);\n        offsetAtt.setOffset(start, start+termAtt.termLength());\n        start += term.length() + 1; // separate words by 1 (blank) character\n        return true;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"360d15dc189fb48153cb62234f7d20819e4e292e","date":1263562938,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#[T]_keywordTokenStream(Collection[T]).mjava","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#[T]_keywordTokenStream(Collection[T]).mjava","sourceNew":"  /**\n   * Convenience method; Creates and returns a token stream that generates a\n   * token for each keyword in the given collection, \"as is\", without any\n   * transforming text analysis. The resulting token stream can be fed into\n   * {@link #addField(String, TokenStream)}, perhaps wrapped into another\n   * {@link org.apache.lucene.analysis.TokenFilter}, as desired.\n   * \n   * @param keywords\n   *            the keywords to generate tokens for\n   * @return the corresponding token stream\n   */\n  public <T> TokenStream keywordTokenStream(final Collection<T> keywords) {\n    // TODO: deprecate & move this method into AnalyzerUtil?\n    if (keywords == null)\n      throw new IllegalArgumentException(\"keywords must not be null\");\n    \n    return new TokenStream() {\n      private Iterator<T> iter = keywords.iterator();\n      private int start = 0;\n      private TermAttribute termAtt = addAttribute(TermAttribute.class);\n      private OffsetAttribute offsetAtt = addAttribute(OffsetAttribute.class);\n      \n      @Override\n      public boolean incrementToken() {\n        if (!iter.hasNext()) return false;\n        \n        T obj = iter.next();\n        if (obj == null) \n          throw new IllegalArgumentException(\"keyword must not be null\");\n        \n        String term = obj.toString();\n        clearAttributes();\n        termAtt.setTermBuffer(term);\n        offsetAtt.setOffset(start, start+termAtt.termLength());\n        start += term.length() + 1; // separate words by 1 (blank) character\n        return true;\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Convenience method; Creates and returns a token stream that generates a\n   * token for each keyword in the given collection, \"as is\", without any\n   * transforming text analysis. The resulting token stream can be fed into\n   * {@link #addField(String, TokenStream)}, perhaps wrapped into another\n   * {@link org.apache.lucene.analysis.TokenFilter}, as desired.\n   * \n   * @param keywords\n   *            the keywords to generate tokens for\n   * @return the corresponding token stream\n   */\n  public <T> TokenStream keywordTokenStream(final Collection<T> keywords) {\n    // TODO: deprecate & move this method into AnalyzerUtil?\n    if (keywords == null)\n      throw new IllegalArgumentException(\"keywords must not be null\");\n    \n    return new TokenStream() {\n      private Iterator<T> iter = keywords.iterator();\n      private int start = 0;\n      private TermAttribute termAtt = addAttribute(TermAttribute.class);\n      private OffsetAttribute offsetAtt = addAttribute(OffsetAttribute.class);\n      \n      @Override\n      public boolean incrementToken() {\n        if (!iter.hasNext()) return false;\n        \n        T obj = iter.next();\n        if (obj == null) \n          throw new IllegalArgumentException(\"keyword must not be null\");\n        \n        String term = obj.toString();\n        termAtt.setTermBuffer(term);\n        offsetAtt.setOffset(start, start+termAtt.termLength());\n        start += term.length() + 1; // separate words by 1 (blank) character\n        return true;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#[T]_keywordTokenStream(Collection[T]).mjava","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#[T]_keywordTokenStream(Collection[T]).mjava","sourceNew":"  /**\n   * Convenience method; Creates and returns a token stream that generates a\n   * token for each keyword in the given collection, \"as is\", without any\n   * transforming text analysis. The resulting token stream can be fed into\n   * {@link #addField(String, TokenStream)}, perhaps wrapped into another\n   * {@link org.apache.lucene.analysis.TokenFilter}, as desired.\n   * \n   * @param keywords\n   *            the keywords to generate tokens for\n   * @return the corresponding token stream\n   */\n  public <T> TokenStream keywordTokenStream(final Collection<T> keywords) {\n    // TODO: deprecate & move this method into AnalyzerUtil?\n    if (keywords == null)\n      throw new IllegalArgumentException(\"keywords must not be null\");\n    \n    return new TokenStream() {\n      private Iterator<T> iter = keywords.iterator();\n      private int start = 0;\n      private TermAttribute termAtt = addAttribute(TermAttribute.class);\n      private OffsetAttribute offsetAtt = addAttribute(OffsetAttribute.class);\n      \n      @Override\n      public boolean incrementToken() {\n        if (!iter.hasNext()) return false;\n        \n        T obj = iter.next();\n        if (obj == null) \n          throw new IllegalArgumentException(\"keyword must not be null\");\n        \n        String term = obj.toString();\n        clearAttributes();\n        termAtt.setTermBuffer(term);\n        offsetAtt.setOffset(start, start+termAtt.termLength());\n        start += term.length() + 1; // separate words by 1 (blank) character\n        return true;\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Convenience method; Creates and returns a token stream that generates a\n   * token for each keyword in the given collection, \"as is\", without any\n   * transforming text analysis. The resulting token stream can be fed into\n   * {@link #addField(String, TokenStream)}, perhaps wrapped into another\n   * {@link org.apache.lucene.analysis.TokenFilter}, as desired.\n   * \n   * @param keywords\n   *            the keywords to generate tokens for\n   * @return the corresponding token stream\n   */\n  public <T> TokenStream keywordTokenStream(final Collection<T> keywords) {\n    // TODO: deprecate & move this method into AnalyzerUtil?\n    if (keywords == null)\n      throw new IllegalArgumentException(\"keywords must not be null\");\n    \n    return new TokenStream() {\n      private Iterator<T> iter = keywords.iterator();\n      private int start = 0;\n      private TermAttribute termAtt = addAttribute(TermAttribute.class);\n      private OffsetAttribute offsetAtt = addAttribute(OffsetAttribute.class);\n      \n      @Override\n      public boolean incrementToken() {\n        if (!iter.hasNext()) return false;\n        \n        T obj = iter.next();\n        if (obj == null) \n          throw new IllegalArgumentException(\"keyword must not be null\");\n        \n        String term = obj.toString();\n        clearAttributes();\n        termAtt.setTermBuffer(term);\n        offsetAtt.setOffset(start, start+termAtt.termLength());\n        start += term.length() + 1; // separate words by 1 (blank) character\n        return true;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d57eb7c98c08c03af6e4cd83509df31c81ac16af":["f11899016a0460a7ea2e4b008d002e1e75c7d867"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["360d15dc189fb48153cb62234f7d20819e4e292e"],"360d15dc189fb48153cb62234f7d20819e4e292e":["d57eb7c98c08c03af6e4cd83509df31c81ac16af"],"f11899016a0460a7ea2e4b008d002e1e75c7d867":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f11899016a0460a7ea2e4b008d002e1e75c7d867"],"d57eb7c98c08c03af6e4cd83509df31c81ac16af":["360d15dc189fb48153cb62234f7d20819e4e292e"],"f11899016a0460a7ea2e4b008d002e1e75c7d867":["d57eb7c98c08c03af6e4cd83509df31c81ac16af"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"360d15dc189fb48153cb62234f7d20819e4e292e":["9454a6510e2db155fb01faa5c049b06ece95fab9"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}