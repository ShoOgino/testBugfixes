{"path":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","commits":[{"id":"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","date":1513252583,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    // make sure coreNodeName is unique across cluster\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lock();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in tests\n      replicaInfo.getVariables().put(Suggestion.coreidxsize, 123450000);\n\n      replicas.add(replicaInfo);\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = 1000;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 10);\n      if (runLeaderElection) {\n        cloudManager.submit(new LeaderElection(Collections.singleton(replicaInfo.getCollection()), true));\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["042b92cf48996255bedb0c3c4bf772d7e06e4dea","7cf5ebf4183939c15e55353b64c57a5182671639"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a4422b331d00607258b0ed3e43934306e67764aa","date":1513943901,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","sourceNew":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    // make sure coreNodeName is unique across cluster\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lock();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in tests\n      replicaInfo.getVariables().put(Suggestion.coreidxsize, 123450000);\n\n      replicas.add(replicaInfo);\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = 1000;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 10);\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    // make sure coreNodeName is unique across cluster\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lock();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in tests\n      replicaInfo.getVariables().put(Suggestion.coreidxsize, 123450000);\n\n      replicas.add(replicaInfo);\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = 1000;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 10);\n      if (runLeaderElection) {\n        cloudManager.submit(new LeaderElection(Collections.singleton(replicaInfo.getCollection()), true));\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7cf5ebf4183939c15e55353b64c57a5182671639","date":1516815713,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","sourceNew":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    // make sure coreNodeName is unique across cluster\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lock();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in tests\n      replicaInfo.getVariables().put(Suggestion.coreidxsize, SimCloudManager.DEFAULT_IDX_SIZE_BYTES);\n\n      replicas.add(replicaInfo);\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    // make sure coreNodeName is unique across cluster\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lock();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in tests\n      replicaInfo.getVariables().put(Suggestion.coreidxsize, 123450000);\n\n      replicas.add(replicaInfo);\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = 1000;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 10);\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"43a787a75ad72a9bf26e8ff714d8b6d01f9eb441","date":1516881857,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","sourceNew":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    // make sure coreNodeName is unique across cluster\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lock();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in tests\n      replicaInfo.getVariables().put(Suggestion.coreidxsize, SimCloudManager.DEFAULT_IDX_SIZE_BYTES);\n\n      replicas.add(replicaInfo);\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    // make sure coreNodeName is unique across cluster\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lock();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in tests\n      replicaInfo.getVariables().put(Suggestion.coreidxsize, 123450000);\n\n      replicas.add(replicaInfo);\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = 1000;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 10);\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e597d523624fcbdb80b49ea69e4a952b676383b9","date":1519820307,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","sourceNew":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    // make sure coreNodeName is unique across cluster\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lock();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations and in tests\n      // NOTE: this confusingly reuses INDEX.sizeInBytes name but\n      // the actual value is expressed in GB units!!!\n      replicaInfo.getVariables().put(Suggestion.coreidxsize, 1);\n\n      replicas.add(replicaInfo);\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    // make sure coreNodeName is unique across cluster\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lock();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in tests\n      replicaInfo.getVariables().put(Suggestion.coreidxsize, SimCloudManager.DEFAULT_IDX_SIZE_BYTES);\n\n      replicas.add(replicaInfo);\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9c6c0dad4932399aec99b4818086cb1772773916","date":1520515900,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","sourceNew":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    // make sure SolrCore name is unique across cluster and coreNodeName within collection\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName()) && ri.getCollection().equals(replicaInfo.getCollection())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lock();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations and in tests\n      // NOTE: this confusingly reuses INDEX.sizeInBytes name but\n      // the actual value is expressed in GB units!!!\n      replicaInfo.getVariables().put(Suggestion.coreidxsize, 1);\n\n      replicas.add(replicaInfo);\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    // make sure coreNodeName is unique across cluster\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lock();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations and in tests\n      // NOTE: this confusingly reuses INDEX.sizeInBytes name but\n      // the actual value is expressed in GB units!!!\n      replicaInfo.getVariables().put(Suggestion.coreidxsize, 1);\n\n      replicas.add(replicaInfo);\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1","date":1523453934,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","sourceNew":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    // make sure SolrCore name is unique across cluster and coreNodeName within collection\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName()) && ri.getCollection().equals(replicaInfo.getCollection())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lockInterruptibly();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations and in tests\n      // NOTE: this confusingly reuses INDEX.sizeInBytes name but\n      // the actual value is expressed in GB units!!!\n      replicaInfo.getVariables().put(Suggestion.coreidxsize, 1);\n\n      replicas.add(replicaInfo);\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    // make sure SolrCore name is unique across cluster and coreNodeName within collection\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName()) && ri.getCollection().equals(replicaInfo.getCollection())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lock();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations and in tests\n      // NOTE: this confusingly reuses INDEX.sizeInBytes name but\n      // the actual value is expressed in GB units!!!\n      replicaInfo.getVariables().put(Suggestion.coreidxsize, 1);\n\n      replicas.add(replicaInfo);\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"43345f1452f9510f8aaadae6156fe0c834e7d957","date":1523483670,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","sourceNew":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    // make sure SolrCore name is unique across cluster and coreNodeName within collection\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName()) && ri.getCollection().equals(replicaInfo.getCollection())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lockInterruptibly();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations and in tests\n      // NOTE: this confusingly reuses INDEX.sizeInBytes name but\n      // the actual value is expressed in GB units!!!\n      replicaInfo.getVariables().put(Suggestion.coreidxsize, 1);\n\n      replicas.add(replicaInfo);\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    // make sure SolrCore name is unique across cluster and coreNodeName within collection\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName()) && ri.getCollection().equals(replicaInfo.getCollection())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lock();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations and in tests\n      // NOTE: this confusingly reuses INDEX.sizeInBytes name but\n      // the actual value is expressed in GB units!!!\n      replicaInfo.getVariables().put(Suggestion.coreidxsize, 1);\n\n      replicas.add(replicaInfo);\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a","date":1527582939,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","sourceNew":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    // make sure SolrCore name is unique across cluster and coreNodeName within collection\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName()) && ri.getCollection().equals(replicaInfo.getCollection())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lockInterruptibly();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations and in tests\n      // NOTE: this confusingly reuses INDEX.sizeInBytes name but\n      // the actual value is expressed in GB units!!!\n      replicaInfo.getVariables().put(Suggestion.coreidxsize, 1);\n\n      replicas.add(replicaInfo);\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      // fake metrics\n      String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.core, replicaInfo.getCollection(),\n          replicaInfo.getShard(),\n          Utils.parseMetricsReplicaName(replicaInfo.getCollection(), replicaInfo.getCore()));\n      cloudManager.getMetricManager().registry(registry).counter(\"UPDATE./update.requests\");\n      cloudManager.getMetricManager().registry(registry).counter(\"QUERY./select.requests\");\n      cloudManager.getMetricManager().registerGauge(null, registry, () -> 1000, \"\", true, \"INDEX.sizeInBytes\");\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    // make sure SolrCore name is unique across cluster and coreNodeName within collection\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName()) && ri.getCollection().equals(replicaInfo.getCollection())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lockInterruptibly();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations and in tests\n      // NOTE: this confusingly reuses INDEX.sizeInBytes name but\n      // the actual value is expressed in GB units!!!\n      replicaInfo.getVariables().put(Suggestion.coreidxsize, 1);\n\n      replicas.add(replicaInfo);\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad60b6945c360ff89899d716d9cdec8dd674e2a0","date":1528114819,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","sourceNew":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    // make sure SolrCore name is unique across cluster and coreNodeName within collection\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName()) && ri.getCollection().equals(replicaInfo.getCollection())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lockInterruptibly();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations and in tests\n      // NOTE: this confusingly reuses INDEX.sizeInBytes name but\n      // the actual value is expressed in GB units!!!\n      replicaInfo.getVariables().put(Suggestion.coreidxsize, 1);\n\n      replicas.add(replicaInfo);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      // fake metrics\n      String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.core, replicaInfo.getCollection(),\n          replicaInfo.getShard(),\n          Utils.parseMetricsReplicaName(replicaInfo.getCollection(), replicaInfo.getCore()));\n      cloudManager.getMetricManager().registry(registry).counter(\"UPDATE./update.requests\");\n      cloudManager.getMetricManager().registry(registry).counter(\"QUERY./select.requests\");\n      cloudManager.getMetricManager().registerGauge(null, registry, () -> 1000, \"\", true, \"INDEX.sizeInBytes\");\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    // make sure SolrCore name is unique across cluster and coreNodeName within collection\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName()) && ri.getCollection().equals(replicaInfo.getCollection())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lockInterruptibly();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations and in tests\n      // NOTE: this confusingly reuses INDEX.sizeInBytes name but\n      // the actual value is expressed in GB units!!!\n      replicaInfo.getVariables().put(Suggestion.coreidxsize, 1);\n\n      replicas.add(replicaInfo);\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      // fake metrics\n      String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.core, replicaInfo.getCollection(),\n          replicaInfo.getShard(),\n          Utils.parseMetricsReplicaName(replicaInfo.getCollection(), replicaInfo.getCore()));\n      cloudManager.getMetricManager().registry(registry).counter(\"UPDATE./update.requests\");\n      cloudManager.getMetricManager().registry(registry).counter(\"QUERY./select.requests\");\n      cloudManager.getMetricManager().registerGauge(null, registry, () -> 1000, \"\", true, \"INDEX.sizeInBytes\");\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","sourceNew":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    // make sure SolrCore name is unique across cluster and coreNodeName within collection\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName()) && ri.getCollection().equals(replicaInfo.getCollection())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lockInterruptibly();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations and in tests\n      // NOTE: this confusingly reuses INDEX.sizeInBytes name but\n      // the actual value is expressed in GB units!!!\n      replicaInfo.getVariables().put(Suggestion.coreidxsize, 1);\n\n      replicas.add(replicaInfo);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      // fake metrics\n      String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.core, replicaInfo.getCollection(),\n          replicaInfo.getShard(),\n          Utils.parseMetricsReplicaName(replicaInfo.getCollection(), replicaInfo.getCore()));\n      cloudManager.getMetricManager().registry(registry).counter(\"UPDATE./update.requests\");\n      cloudManager.getMetricManager().registry(registry).counter(\"QUERY./select.requests\");\n      cloudManager.getMetricManager().registerGauge(null, registry, () -> 1000, \"\", true, \"INDEX.sizeInBytes\");\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    // make sure SolrCore name is unique across cluster and coreNodeName within collection\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName()) && ri.getCollection().equals(replicaInfo.getCollection())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lockInterruptibly();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations and in tests\n      // NOTE: this confusingly reuses INDEX.sizeInBytes name but\n      // the actual value is expressed in GB units!!!\n      replicaInfo.getVariables().put(Suggestion.coreidxsize, 1);\n\n      replicas.add(replicaInfo);\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      // fake metrics\n      String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.core, replicaInfo.getCollection(),\n          replicaInfo.getShard(),\n          Utils.parseMetricsReplicaName(replicaInfo.getCollection(), replicaInfo.getCore()));\n      cloudManager.getMetricManager().registry(registry).counter(\"UPDATE./update.requests\");\n      cloudManager.getMetricManager().registry(registry).counter(\"QUERY./select.requests\");\n      cloudManager.getMetricManager().registerGauge(null, registry, () -> 1000, \"\", true, \"INDEX.sizeInBytes\");\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","sourceNew":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    // make sure SolrCore name is unique across cluster and coreNodeName within collection\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName()) && ri.getCollection().equals(replicaInfo.getCollection())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lockInterruptibly();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations and in tests\n      // NOTE: this confusingly reuses INDEX.sizeInBytes name but\n      // the actual value is expressed in GB units!!!\n      replicaInfo.getVariables().put(Suggestion.coreidxsize, 1);\n\n      replicas.add(replicaInfo);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      // fake metrics\n      String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.core, replicaInfo.getCollection(),\n          replicaInfo.getShard(),\n          Utils.parseMetricsReplicaName(replicaInfo.getCollection(), replicaInfo.getCore()));\n      cloudManager.getMetricManager().registry(registry).counter(\"UPDATE./update.requests\");\n      cloudManager.getMetricManager().registry(registry).counter(\"QUERY./select.requests\");\n      cloudManager.getMetricManager().registerGauge(null, registry, () -> 1000, \"\", true, \"INDEX.sizeInBytes\");\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    // make sure SolrCore name is unique across cluster and coreNodeName within collection\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName()) && ri.getCollection().equals(replicaInfo.getCollection())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lockInterruptibly();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations and in tests\n      // NOTE: this confusingly reuses INDEX.sizeInBytes name but\n      // the actual value is expressed in GB units!!!\n      replicaInfo.getVariables().put(Suggestion.coreidxsize, 1);\n\n      replicas.add(replicaInfo);\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      // fake metrics\n      String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.core, replicaInfo.getCollection(),\n          replicaInfo.getShard(),\n          Utils.parseMetricsReplicaName(replicaInfo.getCollection(), replicaInfo.getCore()));\n      cloudManager.getMetricManager().registry(registry).counter(\"UPDATE./update.requests\");\n      cloudManager.getMetricManager().registry(registry).counter(\"QUERY./select.requests\");\n      cloudManager.getMetricManager().registerGauge(null, registry, () -> 1000, \"\", true, \"INDEX.sizeInBytes\");\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b55cd711a129fb7fc4c3c4672d652149c9a4faa","date":1528813320,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","sourceNew":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    // make sure SolrCore name is unique across cluster and coreNodeName within collection\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName()) && ri.getCollection().equals(replicaInfo.getCollection())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lockInterruptibly();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations, if missing\n      if (replicaInfo.getVariable(Suggestion.ConditionType.CORE_IDX.metricsAttribute) == null) {\n        replicaInfo.getVariables().put(Suggestion.ConditionType.CORE_IDX.metricsAttribute, SimCloudManager.DEFAULT_IDX_SIZE_BYTES);\n        replicaInfo.getVariables().put(Suggestion.coreidxsize,\n            Suggestion.ConditionType.CORE_IDX.convertVal(SimCloudManager.DEFAULT_IDX_SIZE_BYTES));\n      }\n\n      replicas.add(replicaInfo);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      // fake metrics\n      String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.core, replicaInfo.getCollection(),\n          replicaInfo.getShard(),\n          Utils.parseMetricsReplicaName(replicaInfo.getCollection(), replicaInfo.getCore()));\n      cloudManager.getMetricManager().registry(registry).counter(\"UPDATE./update.requests\");\n      cloudManager.getMetricManager().registry(registry).counter(\"QUERY./select.requests\");\n      cloudManager.getMetricManager().registerGauge(null, registry,\n          () -> replicaInfo.getVariable(Suggestion.ConditionType.CORE_IDX.metricsAttribute),\n          \"\", true, \"INDEX.sizeInBytes\");\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    // make sure SolrCore name is unique across cluster and coreNodeName within collection\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName()) && ri.getCollection().equals(replicaInfo.getCollection())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lockInterruptibly();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations and in tests\n      // NOTE: this confusingly reuses INDEX.sizeInBytes name but\n      // the actual value is expressed in GB units!!!\n      replicaInfo.getVariables().put(Suggestion.coreidxsize, 1);\n\n      replicas.add(replicaInfo);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      // fake metrics\n      String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.core, replicaInfo.getCollection(),\n          replicaInfo.getShard(),\n          Utils.parseMetricsReplicaName(replicaInfo.getCollection(), replicaInfo.getCore()));\n      cloudManager.getMetricManager().registry(registry).counter(\"UPDATE./update.requests\");\n      cloudManager.getMetricManager().registry(registry).counter(\"QUERY./select.requests\");\n      cloudManager.getMetricManager().registerGauge(null, registry, () -> 1000, \"\", true, \"INDEX.sizeInBytes\");\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","sourceNew":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    // make sure SolrCore name is unique across cluster and coreNodeName within collection\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName()) && ri.getCollection().equals(replicaInfo.getCollection())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lockInterruptibly();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations, if missing\n      if (replicaInfo.getVariable(Suggestion.ConditionType.CORE_IDX.metricsAttribute) == null) {\n        replicaInfo.getVariables().put(Suggestion.ConditionType.CORE_IDX.metricsAttribute, SimCloudManager.DEFAULT_IDX_SIZE_BYTES);\n        replicaInfo.getVariables().put(Suggestion.coreidxsize,\n            Suggestion.ConditionType.CORE_IDX.convertVal(SimCloudManager.DEFAULT_IDX_SIZE_BYTES));\n      }\n\n      replicas.add(replicaInfo);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      // fake metrics\n      String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.core, replicaInfo.getCollection(),\n          replicaInfo.getShard(),\n          Utils.parseMetricsReplicaName(replicaInfo.getCollection(), replicaInfo.getCore()));\n      cloudManager.getMetricManager().registry(registry).counter(\"UPDATE./update.requests\");\n      cloudManager.getMetricManager().registry(registry).counter(\"QUERY./select.requests\");\n      cloudManager.getMetricManager().registerGauge(null, registry,\n          () -> replicaInfo.getVariable(Suggestion.ConditionType.CORE_IDX.metricsAttribute),\n          \"\", true, \"INDEX.sizeInBytes\");\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    // make sure SolrCore name is unique across cluster and coreNodeName within collection\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName()) && ri.getCollection().equals(replicaInfo.getCollection())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lockInterruptibly();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations and in tests\n      // NOTE: this confusingly reuses INDEX.sizeInBytes name but\n      // the actual value is expressed in GB units!!!\n      replicaInfo.getVariables().put(Suggestion.coreidxsize, 1);\n\n      replicas.add(replicaInfo);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      // fake metrics\n      String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.core, replicaInfo.getCollection(),\n          replicaInfo.getShard(),\n          Utils.parseMetricsReplicaName(replicaInfo.getCollection(), replicaInfo.getCore()));\n      cloudManager.getMetricManager().registry(registry).counter(\"UPDATE./update.requests\");\n      cloudManager.getMetricManager().registry(registry).counter(\"QUERY./select.requests\");\n      cloudManager.getMetricManager().registerGauge(null, registry, () -> 1000, \"\", true, \"INDEX.sizeInBytes\");\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","sourceNew":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    // make sure SolrCore name is unique across cluster and coreNodeName within collection\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName()) && ri.getCollection().equals(replicaInfo.getCollection())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lockInterruptibly();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations, if missing\n      if (replicaInfo.getVariable(Suggestion.ConditionType.CORE_IDX.metricsAttribute) == null) {\n        replicaInfo.getVariables().put(Suggestion.ConditionType.CORE_IDX.metricsAttribute, SimCloudManager.DEFAULT_IDX_SIZE_BYTES);\n        replicaInfo.getVariables().put(Suggestion.coreidxsize,\n            Suggestion.ConditionType.CORE_IDX.convertVal(SimCloudManager.DEFAULT_IDX_SIZE_BYTES));\n      }\n\n      replicas.add(replicaInfo);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      // fake metrics\n      String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.core, replicaInfo.getCollection(),\n          replicaInfo.getShard(),\n          Utils.parseMetricsReplicaName(replicaInfo.getCollection(), replicaInfo.getCore()));\n      cloudManager.getMetricManager().registry(registry).counter(\"UPDATE./update.requests\");\n      cloudManager.getMetricManager().registry(registry).counter(\"QUERY./select.requests\");\n      cloudManager.getMetricManager().registerGauge(null, registry,\n          () -> replicaInfo.getVariable(Suggestion.ConditionType.CORE_IDX.metricsAttribute),\n          \"\", true, \"INDEX.sizeInBytes\");\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    // make sure SolrCore name is unique across cluster and coreNodeName within collection\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName()) && ri.getCollection().equals(replicaInfo.getCollection())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lockInterruptibly();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations and in tests\n      // NOTE: this confusingly reuses INDEX.sizeInBytes name but\n      // the actual value is expressed in GB units!!!\n      replicaInfo.getVariables().put(Suggestion.coreidxsize, 1);\n\n      replicas.add(replicaInfo);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      // fake metrics\n      String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.core, replicaInfo.getCollection(),\n          replicaInfo.getShard(),\n          Utils.parseMetricsReplicaName(replicaInfo.getCollection(), replicaInfo.getCore()));\n      cloudManager.getMetricManager().registry(registry).counter(\"UPDATE./update.requests\");\n      cloudManager.getMetricManager().registry(registry).counter(\"QUERY./select.requests\");\n      cloudManager.getMetricManager().registerGauge(null, registry, () -> 1000, \"\", true, \"INDEX.sizeInBytes\");\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"427edb17549d4bb82462a16eec4ee0533d12d5b7","date":1533006754,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","sourceNew":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    // make sure SolrCore name is unique across cluster and coreNodeName within collection\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName()) && ri.getCollection().equals(replicaInfo.getCollection())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lockInterruptibly();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations, if missing\n      if (replicaInfo.getVariable(Type.CORE_IDX.metricsAttribute) == null) {\n        replicaInfo.getVariables().put(Type.CORE_IDX.metricsAttribute, SimCloudManager.DEFAULT_IDX_SIZE_BYTES);\n        replicaInfo.getVariables().put(Variable.coreidxsize,\n            Type.CORE_IDX.convertVal(SimCloudManager.DEFAULT_IDX_SIZE_BYTES));\n      }\n\n      replicas.add(replicaInfo);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      // fake metrics\n      String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.core, replicaInfo.getCollection(),\n          replicaInfo.getShard(),\n          Utils.parseMetricsReplicaName(replicaInfo.getCollection(), replicaInfo.getCore()));\n      cloudManager.getMetricManager().registry(registry).counter(\"UPDATE./update.requests\");\n      cloudManager.getMetricManager().registry(registry).counter(\"QUERY./select.requests\");\n      cloudManager.getMetricManager().registerGauge(null, registry,\n          () -> replicaInfo.getVariable(Type.CORE_IDX.metricsAttribute),\n          \"\", true, \"INDEX.sizeInBytes\");\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    // make sure SolrCore name is unique across cluster and coreNodeName within collection\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName()) && ri.getCollection().equals(replicaInfo.getCollection())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lockInterruptibly();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations, if missing\n      if (replicaInfo.getVariable(Suggestion.ConditionType.CORE_IDX.metricsAttribute) == null) {\n        replicaInfo.getVariables().put(Suggestion.ConditionType.CORE_IDX.metricsAttribute, SimCloudManager.DEFAULT_IDX_SIZE_BYTES);\n        replicaInfo.getVariables().put(Suggestion.coreidxsize,\n            Suggestion.ConditionType.CORE_IDX.convertVal(SimCloudManager.DEFAULT_IDX_SIZE_BYTES));\n      }\n\n      replicas.add(replicaInfo);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      // fake metrics\n      String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.core, replicaInfo.getCollection(),\n          replicaInfo.getShard(),\n          Utils.parseMetricsReplicaName(replicaInfo.getCollection(), replicaInfo.getCore()));\n      cloudManager.getMetricManager().registry(registry).counter(\"UPDATE./update.requests\");\n      cloudManager.getMetricManager().registry(registry).counter(\"QUERY./select.requests\");\n      cloudManager.getMetricManager().registerGauge(null, registry,\n          () -> replicaInfo.getVariable(Suggestion.ConditionType.CORE_IDX.metricsAttribute),\n          \"\", true, \"INDEX.sizeInBytes\");\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"042b92cf48996255bedb0c3c4bf772d7e06e4dea","date":1534272102,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","sourceNew":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    ensureNotClosed();\n    // make sure SolrCore name is unique across cluster and coreNodeName within collection\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName()) && ri.getCollection().equals(replicaInfo.getCollection())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lockInterruptibly();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations, if missing\n      if (replicaInfo.getVariable(Type.CORE_IDX.metricsAttribute) == null) {\n        replicaInfo.getVariables().put(Type.CORE_IDX.metricsAttribute, SimCloudManager.DEFAULT_IDX_SIZE_BYTES);\n        replicaInfo.getVariables().put(Variable.coreidxsize,\n            Type.CORE_IDX.convertVal(SimCloudManager.DEFAULT_IDX_SIZE_BYTES));\n      }\n\n      replicas.add(replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      // fake metrics\n      String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.core, replicaInfo.getCollection(),\n          replicaInfo.getShard(),\n          Utils.parseMetricsReplicaName(replicaInfo.getCollection(), replicaInfo.getCore()));\n      cloudManager.getMetricManager().registry(registry).counter(\"UPDATE./update.requests\");\n      cloudManager.getMetricManager().registry(registry).counter(\"QUERY./select.requests\");\n      cloudManager.getMetricManager().registerGauge(null, registry,\n          () -> replicaInfo.getVariable(Type.CORE_IDX.metricsAttribute),\n          \"\", true, \"INDEX.sizeInBytes\");\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    // make sure SolrCore name is unique across cluster and coreNodeName within collection\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName()) && ri.getCollection().equals(replicaInfo.getCollection())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lockInterruptibly();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations, if missing\n      if (replicaInfo.getVariable(Type.CORE_IDX.metricsAttribute) == null) {\n        replicaInfo.getVariables().put(Type.CORE_IDX.metricsAttribute, SimCloudManager.DEFAULT_IDX_SIZE_BYTES);\n        replicaInfo.getVariables().put(Variable.coreidxsize,\n            Type.CORE_IDX.convertVal(SimCloudManager.DEFAULT_IDX_SIZE_BYTES));\n      }\n\n      replicas.add(replicaInfo);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      // fake metrics\n      String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.core, replicaInfo.getCollection(),\n          replicaInfo.getShard(),\n          Utils.parseMetricsReplicaName(replicaInfo.getCollection(), replicaInfo.getCore()));\n      cloudManager.getMetricManager().registry(registry).counter(\"UPDATE./update.requests\");\n      cloudManager.getMetricManager().registry(registry).counter(\"QUERY./select.requests\");\n      cloudManager.getMetricManager().registerGauge(null, registry,\n          () -> replicaInfo.getVariable(Type.CORE_IDX.metricsAttribute),\n          \"\", true, \"INDEX.sizeInBytes\");\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":["ad60b6945c360ff89899d716d9cdec8dd674e2a0","1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","sourceNew":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    ensureNotClosed();\n    // make sure SolrCore name is unique across cluster and coreNodeName within collection\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName()) && ri.getCollection().equals(replicaInfo.getCollection())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lockInterruptibly();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations, if missing\n      if (replicaInfo.getVariable(Type.CORE_IDX.metricsAttribute) == null) {\n        replicaInfo.getVariables().put(Type.CORE_IDX.metricsAttribute, SimCloudManager.DEFAULT_IDX_SIZE_BYTES);\n        replicaInfo.getVariables().put(Variable.coreidxsize,\n            Type.CORE_IDX.convertVal(SimCloudManager.DEFAULT_IDX_SIZE_BYTES));\n      }\n\n      replicas.add(replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      // fake metrics\n      String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.core, replicaInfo.getCollection(),\n          replicaInfo.getShard(),\n          Utils.parseMetricsReplicaName(replicaInfo.getCollection(), replicaInfo.getCore()));\n      cloudManager.getMetricManager().registry(registry).counter(\"UPDATE./update.requests\");\n      cloudManager.getMetricManager().registry(registry).counter(\"QUERY./select.requests\");\n      cloudManager.getMetricManager().registerGauge(null, registry,\n          () -> replicaInfo.getVariable(Type.CORE_IDX.metricsAttribute),\n          \"\", true, \"INDEX.sizeInBytes\");\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      log.trace(\"-- simAddReplica {}\", replicaInfo);\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    ensureNotClosed();\n    // make sure SolrCore name is unique across cluster and coreNodeName within collection\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName()) && ri.getCollection().equals(replicaInfo.getCollection())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lockInterruptibly();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations, if missing\n      if (replicaInfo.getVariable(Type.CORE_IDX.metricsAttribute) == null) {\n        replicaInfo.getVariables().put(Type.CORE_IDX.metricsAttribute, SimCloudManager.DEFAULT_IDX_SIZE_BYTES);\n        replicaInfo.getVariables().put(Variable.coreidxsize,\n            Type.CORE_IDX.convertVal(SimCloudManager.DEFAULT_IDX_SIZE_BYTES));\n      }\n\n      replicas.add(replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      // fake metrics\n      String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.core, replicaInfo.getCollection(),\n          replicaInfo.getShard(),\n          Utils.parseMetricsReplicaName(replicaInfo.getCollection(), replicaInfo.getCore()));\n      cloudManager.getMetricManager().registry(registry).counter(\"UPDATE./update.requests\");\n      cloudManager.getMetricManager().registry(registry).counter(\"QUERY./select.requests\");\n      cloudManager.getMetricManager().registerGauge(null, registry,\n          () -> replicaInfo.getVariable(Type.CORE_IDX.metricsAttribute),\n          \"\", true, \"INDEX.sizeInBytes\");\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      LOG.trace(\"-- simAddReplica {}\", replicaInfo);\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc18bc8ea2e2c1e308757ff50671c774438e9f3e","date":1538052583,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","sourceNew":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    ensureNotClosed();\n    // make sure SolrCore name is unique across cluster and coreNodeName within collection\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName()) && ri.getCollection().equals(replicaInfo.getCollection())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lockInterruptibly();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations, if missing\n      if (replicaInfo.getVariable(Type.CORE_IDX.metricsAttribute) == null) {\n        replicaInfo.getVariables().put(Type.CORE_IDX.metricsAttribute, new AtomicLong(SimCloudManager.DEFAULT_IDX_SIZE_BYTES));\n        replicaInfo.getVariables().put(Variable.coreidxsize,\n            new AtomicDouble((Double)Type.CORE_IDX.convertVal(SimCloudManager.DEFAULT_IDX_SIZE_BYTES)));\n      }\n\n      replicas.add(replicaInfo);\n      colShardReplicaMap.computeIfAbsent(replicaInfo.getCollection(), c -> new ConcurrentHashMap<>())\n          .computeIfAbsent(replicaInfo.getShard(), s -> new ArrayList<>())\n          .add(replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_FREE_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      // fake metrics\n      String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.core, replicaInfo.getCollection(),\n          replicaInfo.getShard(),\n          Utils.parseMetricsReplicaName(replicaInfo.getCollection(), replicaInfo.getCore()));\n      cloudManager.getMetricManager().registry(registry).counter(\"UPDATE./update.requests\");\n      cloudManager.getMetricManager().registry(registry).counter(\"QUERY./select.requests\");\n      cloudManager.getMetricManager().registerGauge(null, registry,\n          () -> ((Number)replicaInfo.getVariable(Type.CORE_IDX.metricsAttribute)).longValue(),\n          \"\", true, \"INDEX.sizeInBytes\");\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      log.trace(\"-- simAddReplica {}\", replicaInfo);\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    ensureNotClosed();\n    // make sure SolrCore name is unique across cluster and coreNodeName within collection\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName()) && ri.getCollection().equals(replicaInfo.getCollection())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lockInterruptibly();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations, if missing\n      if (replicaInfo.getVariable(Type.CORE_IDX.metricsAttribute) == null) {\n        replicaInfo.getVariables().put(Type.CORE_IDX.metricsAttribute, SimCloudManager.DEFAULT_IDX_SIZE_BYTES);\n        replicaInfo.getVariables().put(Variable.coreidxsize,\n            Type.CORE_IDX.convertVal(SimCloudManager.DEFAULT_IDX_SIZE_BYTES));\n      }\n\n      replicas.add(replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      // fake metrics\n      String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.core, replicaInfo.getCollection(),\n          replicaInfo.getShard(),\n          Utils.parseMetricsReplicaName(replicaInfo.getCollection(), replicaInfo.getCore()));\n      cloudManager.getMetricManager().registry(registry).counter(\"UPDATE./update.requests\");\n      cloudManager.getMetricManager().registry(registry).counter(\"QUERY./select.requests\");\n      cloudManager.getMetricManager().registerGauge(null, registry,\n          () -> replicaInfo.getVariable(Type.CORE_IDX.metricsAttribute),\n          \"\", true, \"INDEX.sizeInBytes\");\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      log.trace(\"-- simAddReplica {}\", replicaInfo);\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"66b87d86427dfa19b2ef36b66de83aa9655cea33","date":1552627668,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","sourceNew":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    ensureNotClosed();\n    lock.lockInterruptibly();\n    try {\n\n      // make sure SolrCore name is unique across cluster and coreNodeName within collection\n      for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n        final List<ReplicaInfo> replicas = e.getValue();\n        synchronized (replicas) {\n          for (ReplicaInfo ri : replicas) {\n            if (ri.getCore().equals(replicaInfo.getCore())) {\n              throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n            }\n            if (ri.getName().equals(replicaInfo.getName()) && ri.getCollection().equals(replicaInfo.getCollection())) {\n              throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n            }\n          }\n        }\n      }\n      if (!liveNodes.contains(nodeId)) {\n        throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n      }\n      // verify info\n      if (replicaInfo.getCore() == null) {\n        throw new Exception(\"Missing core: \" + replicaInfo);\n      }\n      // XXX replica info is not supposed to have this as a variable\n      replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n      if (replicaInfo.getName() == null) {\n        throw new Exception(\"Missing name: \" + replicaInfo);\n      }\n      if (replicaInfo.getNode() == null) {\n        throw new Exception(\"Missing node: \" + replicaInfo);\n      }\n      if (!replicaInfo.getNode().equals(nodeId)) {\n        throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n      }\n      \n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations, if missing\n      if (replicaInfo.getVariable(Type.CORE_IDX.metricsAttribute) == null) {\n        replicaInfo.getVariables().put(Type.CORE_IDX.metricsAttribute, new AtomicLong(SimCloudManager.DEFAULT_IDX_SIZE_BYTES));\n        replicaInfo.getVariables().put(Variable.coreidxsize,\n            new AtomicDouble((Double)Type.CORE_IDX.convertVal(SimCloudManager.DEFAULT_IDX_SIZE_BYTES)));\n      }\n      nodeReplicaMap.computeIfAbsent(nodeId, Utils.NEW_SYNCHRONIZED_ARRAYLIST_FUN).add(replicaInfo);\n      colShardReplicaMap.computeIfAbsent(replicaInfo.getCollection(), c -> new ConcurrentHashMap<>())\n          .computeIfAbsent(replicaInfo.getShard(), s -> new ArrayList<>())\n          .add(replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_FREE_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      // fake metrics\n      String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.core, replicaInfo.getCollection(),\n          replicaInfo.getShard(),\n          Utils.parseMetricsReplicaName(replicaInfo.getCollection(), replicaInfo.getCore()));\n      cloudManager.getMetricManager().registry(registry).counter(\"UPDATE./update.requests\");\n      cloudManager.getMetricManager().registry(registry).counter(\"QUERY./select.requests\");\n      cloudManager.getMetricManager().registerGauge(null, registry,\n          () -> ((Number)replicaInfo.getVariable(Type.CORE_IDX.metricsAttribute)).longValue(),\n          \"\", true, \"INDEX.sizeInBytes\");\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      log.trace(\"-- simAddReplica {}\", replicaInfo);\n      if (runLeaderElection) {\n        simRunLeaderElection(replicaInfo.getCollection(), replicaInfo.getShard(), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    ensureNotClosed();\n    // make sure SolrCore name is unique across cluster and coreNodeName within collection\n    for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n      for (ReplicaInfo ri : e.getValue()) {\n        if (ri.getCore().equals(replicaInfo.getCore())) {\n          throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n        if (ri.getName().equals(replicaInfo.getName()) && ri.getCollection().equals(replicaInfo.getCollection())) {\n          throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n        }\n      }\n    }\n    if (!liveNodes.contains(nodeId)) {\n      throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n    }\n    // verify info\n    if (replicaInfo.getCore() == null) {\n      throw new Exception(\"Missing core: \" + replicaInfo);\n    }\n    // XXX replica info is not supposed to have this as a variable\n    replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n    if (replicaInfo.getName() == null) {\n      throw new Exception(\"Missing name: \" + replicaInfo);\n    }\n    if (replicaInfo.getNode() == null) {\n      throw new Exception(\"Missing node: \" + replicaInfo);\n    }\n    if (!replicaInfo.getNode().equals(nodeId)) {\n      throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n    }\n\n    lock.lockInterruptibly();\n    try {\n\n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      List<ReplicaInfo> replicas = nodeReplicaMap.computeIfAbsent(nodeId, n -> new ArrayList<>());\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations, if missing\n      if (replicaInfo.getVariable(Type.CORE_IDX.metricsAttribute) == null) {\n        replicaInfo.getVariables().put(Type.CORE_IDX.metricsAttribute, new AtomicLong(SimCloudManager.DEFAULT_IDX_SIZE_BYTES));\n        replicaInfo.getVariables().put(Variable.coreidxsize,\n            new AtomicDouble((Double)Type.CORE_IDX.convertVal(SimCloudManager.DEFAULT_IDX_SIZE_BYTES)));\n      }\n\n      replicas.add(replicaInfo);\n      colShardReplicaMap.computeIfAbsent(replicaInfo.getCollection(), c -> new ConcurrentHashMap<>())\n          .computeIfAbsent(replicaInfo.getShard(), s -> new ArrayList<>())\n          .add(replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_FREE_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      // fake metrics\n      String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.core, replicaInfo.getCollection(),\n          replicaInfo.getShard(),\n          Utils.parseMetricsReplicaName(replicaInfo.getCollection(), replicaInfo.getCore()));\n      cloudManager.getMetricManager().registry(registry).counter(\"UPDATE./update.requests\");\n      cloudManager.getMetricManager().registry(registry).counter(\"QUERY./select.requests\");\n      cloudManager.getMetricManager().registerGauge(null, registry,\n          () -> ((Number)replicaInfo.getVariable(Type.CORE_IDX.metricsAttribute)).longValue(),\n          \"\", true, \"INDEX.sizeInBytes\");\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      log.trace(\"-- simAddReplica {}\", replicaInfo);\n      if (runLeaderElection) {\n        simRunLeaderElection(Collections.singleton(replicaInfo.getCollection()), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5","date":1556572478,"type":5,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simAddReplica(String,ReplicaInfo,boolean).mjava","sourceNew":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    ensureNotClosed();\n    lock.lockInterruptibly();\n    try {\n\n      // make sure SolrCore name is unique across cluster and coreNodeName within collection\n      for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n        final List<ReplicaInfo> replicas = e.getValue();\n        synchronized (replicas) {\n          for (ReplicaInfo ri : replicas) {\n            if (ri.getCore().equals(replicaInfo.getCore())) {\n              throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n            }\n            if (ri.getName().equals(replicaInfo.getName()) && ri.getCollection().equals(replicaInfo.getCollection())) {\n              throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n            }\n          }\n        }\n      }\n      if (!liveNodes.contains(nodeId)) {\n        throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n      }\n      // verify info\n      if (replicaInfo.getCore() == null) {\n        throw new Exception(\"Missing core: \" + replicaInfo);\n      }\n      // XXX replica info is not supposed to have this as a variable\n      replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n      if (replicaInfo.getName() == null) {\n        throw new Exception(\"Missing name: \" + replicaInfo);\n      }\n      if (replicaInfo.getNode() == null) {\n        throw new Exception(\"Missing node: \" + replicaInfo);\n      }\n      if (!replicaInfo.getNode().equals(nodeId)) {\n        throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n      }\n      \n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations, if missing\n      if (replicaInfo.getVariable(Type.CORE_IDX.metricsAttribute) == null) {\n        replicaInfo.getVariables().put(Type.CORE_IDX.metricsAttribute, new AtomicLong(SimCloudManager.DEFAULT_IDX_SIZE_BYTES));\n        replicaInfo.getVariables().put(Variable.coreidxsize,\n            new AtomicDouble((Double)Type.CORE_IDX.convertVal(SimCloudManager.DEFAULT_IDX_SIZE_BYTES)));\n      }\n      nodeReplicaMap.computeIfAbsent(nodeId, Utils.NEW_SYNCHRONIZED_ARRAYLIST_FUN).add(replicaInfo);\n      colShardReplicaMap.computeIfAbsent(replicaInfo.getCollection(), c -> new ConcurrentHashMap<>())\n          .computeIfAbsent(replicaInfo.getShard(), s -> new ArrayList<>())\n          .add(replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Number disk = (Number)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_FREE_DISK;\n      }\n      long replicaSize = ((Number)replicaInfo.getVariable(Type.CORE_IDX.metricsAttribute)).longValue();\n      Number replicaSizeGB = (Number)Type.CORE_IDX.convertVal(replicaSize);\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk.doubleValue() - replicaSizeGB.doubleValue());\n      // fake metrics\n      String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.core, replicaInfo.getCollection(),\n          replicaInfo.getShard(),\n          Utils.parseMetricsReplicaName(replicaInfo.getCollection(), replicaInfo.getCore()));\n      cloudManager.getMetricManager().registry(registry).counter(\"UPDATE./update.requests\");\n      cloudManager.getMetricManager().registry(registry).counter(\"QUERY./select.requests\");\n      cloudManager.getMetricManager().registerGauge(null, registry,\n          () -> replicaSize, \"\", true, Type.CORE_IDX.metricsAttribute);\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      log.trace(\"-- simAddReplica {}\", replicaInfo);\n      if (runLeaderElection) {\n        simRunLeaderElection(replicaInfo.getCollection(), replicaInfo.getShard(), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  /**\n   * Add a replica. Note that all details of the replica must be present here, including\n   * node, coreNodeName and SolrCore name.\n   * @param nodeId node id where the replica will be added\n   * @param replicaInfo replica info\n   * @param runLeaderElection if true then run a leader election after adding the replica.\n   */\n  public void simAddReplica(String nodeId, ReplicaInfo replicaInfo, boolean runLeaderElection) throws Exception {\n    ensureNotClosed();\n    lock.lockInterruptibly();\n    try {\n\n      // make sure SolrCore name is unique across cluster and coreNodeName within collection\n      for (Map.Entry<String, List<ReplicaInfo>> e : nodeReplicaMap.entrySet()) {\n        final List<ReplicaInfo> replicas = e.getValue();\n        synchronized (replicas) {\n          for (ReplicaInfo ri : replicas) {\n            if (ri.getCore().equals(replicaInfo.getCore())) {\n              throw new Exception(\"Duplicate SolrCore name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n            }\n            if (ri.getName().equals(replicaInfo.getName()) && ri.getCollection().equals(replicaInfo.getCollection())) {\n              throw new Exception(\"Duplicate coreNode name for existing=\" + ri + \" on node \" + e.getKey() + \" and new=\" + replicaInfo);\n            }\n          }\n        }\n      }\n      if (!liveNodes.contains(nodeId)) {\n        throw new Exception(\"Target node \" + nodeId + \" is not live: \" + liveNodes);\n      }\n      // verify info\n      if (replicaInfo.getCore() == null) {\n        throw new Exception(\"Missing core: \" + replicaInfo);\n      }\n      // XXX replica info is not supposed to have this as a variable\n      replicaInfo.getVariables().remove(ZkStateReader.SHARD_ID_PROP);\n      if (replicaInfo.getName() == null) {\n        throw new Exception(\"Missing name: \" + replicaInfo);\n      }\n      if (replicaInfo.getNode() == null) {\n        throw new Exception(\"Missing node: \" + replicaInfo);\n      }\n      if (!replicaInfo.getNode().equals(nodeId)) {\n        throw new Exception(\"Wrong node (not \" + nodeId + \"): \" + replicaInfo);\n      }\n      \n      opDelay(replicaInfo.getCollection(), CollectionParams.CollectionAction.ADDREPLICA.name());\n\n      // mark replica as active\n      replicaInfo.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n      // add a property expected in Policy calculations, if missing\n      if (replicaInfo.getVariable(Type.CORE_IDX.metricsAttribute) == null) {\n        replicaInfo.getVariables().put(Type.CORE_IDX.metricsAttribute, new AtomicLong(SimCloudManager.DEFAULT_IDX_SIZE_BYTES));\n        replicaInfo.getVariables().put(Variable.coreidxsize,\n            new AtomicDouble((Double)Type.CORE_IDX.convertVal(SimCloudManager.DEFAULT_IDX_SIZE_BYTES)));\n      }\n      nodeReplicaMap.computeIfAbsent(nodeId, Utils.NEW_SYNCHRONIZED_ARRAYLIST_FUN).add(replicaInfo);\n      colShardReplicaMap.computeIfAbsent(replicaInfo.getCollection(), c -> new ConcurrentHashMap<>())\n          .computeIfAbsent(replicaInfo.getShard(), s -> new ArrayList<>())\n          .add(replicaInfo);\n\n      Map<String, Object> values = cloudManager.getSimNodeStateProvider().simGetAllNodeValues()\n          .computeIfAbsent(nodeId, id -> new ConcurrentHashMap<>(SimCloudManager.createNodeValues(id)));\n      // update the number of cores and freedisk in node values\n      Integer cores = (Integer)values.get(ImplicitSnitch.CORES);\n      if (cores == null) {\n        cores = 0;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.CORES, cores + 1);\n      Integer disk = (Integer)values.get(ImplicitSnitch.DISK);\n      if (disk == null) {\n        disk = SimCloudManager.DEFAULT_FREE_DISK;\n      }\n      cloudManager.getSimNodeStateProvider().simSetNodeValue(nodeId, ImplicitSnitch.DISK, disk - 1);\n      // fake metrics\n      String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.core, replicaInfo.getCollection(),\n          replicaInfo.getShard(),\n          Utils.parseMetricsReplicaName(replicaInfo.getCollection(), replicaInfo.getCore()));\n      cloudManager.getMetricManager().registry(registry).counter(\"UPDATE./update.requests\");\n      cloudManager.getMetricManager().registry(registry).counter(\"QUERY./select.requests\");\n      cloudManager.getMetricManager().registerGauge(null, registry,\n          () -> ((Number)replicaInfo.getVariable(Type.CORE_IDX.metricsAttribute)).longValue(),\n          \"\", true, \"INDEX.sizeInBytes\");\n      // at this point nuke our cached DocCollection state\n      collectionsStatesRef.set(null);\n      log.trace(\"-- simAddReplica {}\", replicaInfo);\n      if (runLeaderElection) {\n        simRunLeaderElection(replicaInfo.getCollection(), replicaInfo.getShard(), true);\n      }\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fc18bc8ea2e2c1e308757ff50671c774438e9f3e":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"7cf5ebf4183939c15e55353b64c57a5182671639":["a4422b331d00607258b0ed3e43934306e67764aa"],"43345f1452f9510f8aaadae6156fe0c834e7d957":["9c6c0dad4932399aec99b4818086cb1772773916","ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1"],"43a787a75ad72a9bf26e8ff714d8b6d01f9eb441":["a4422b331d00607258b0ed3e43934306e67764aa","7cf5ebf4183939c15e55353b64c57a5182671639"],"042b92cf48996255bedb0c3c4bf772d7e06e4dea":["427edb17549d4bb82462a16eec4ee0533d12d5b7"],"e597d523624fcbdb80b49ea69e4a952b676383b9":["43a787a75ad72a9bf26e8ff714d8b6d01f9eb441"],"9c6c0dad4932399aec99b4818086cb1772773916":["e597d523624fcbdb80b49ea69e4a952b676383b9"],"6b55cd711a129fb7fc4c3c4672d652149c9a4faa":["ad60b6945c360ff89899d716d9cdec8dd674e2a0"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["b70042a8a492f7054d480ccdd2be9796510d4327","6b55cd711a129fb7fc4c3c4672d652149c9a4faa"],"4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a":["43345f1452f9510f8aaadae6156fe0c834e7d957"],"ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1":["9c6c0dad4932399aec99b4818086cb1772773916"],"66b87d86427dfa19b2ef36b66de83aa9655cea33":["fc18bc8ea2e2c1e308757ff50671c774438e9f3e"],"427edb17549d4bb82462a16eec4ee0533d12d5b7":["6b55cd711a129fb7fc4c3c4672d652149c9a4faa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a","ad60b6945c360ff89899d716d9cdec8dd674e2a0"],"a4422b331d00607258b0ed3e43934306e67764aa":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["66b87d86427dfa19b2ef36b66de83aa9655cea33"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ad60b6945c360ff89899d716d9cdec8dd674e2a0":["4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a"],"f592209545c71895260367152601e9200399776d":["4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a","ad60b6945c360ff89899d716d9cdec8dd674e2a0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["f592209545c71895260367152601e9200399776d","6b55cd711a129fb7fc4c3c4672d652149c9a4faa"]},"commit2Childs":{"fc18bc8ea2e2c1e308757ff50671c774438e9f3e":["66b87d86427dfa19b2ef36b66de83aa9655cea33"],"7cf5ebf4183939c15e55353b64c57a5182671639":["43a787a75ad72a9bf26e8ff714d8b6d01f9eb441"],"43345f1452f9510f8aaadae6156fe0c834e7d957":["4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a"],"43a787a75ad72a9bf26e8ff714d8b6d01f9eb441":["e597d523624fcbdb80b49ea69e4a952b676383b9"],"042b92cf48996255bedb0c3c4bf772d7e06e4dea":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"e597d523624fcbdb80b49ea69e4a952b676383b9":["9c6c0dad4932399aec99b4818086cb1772773916"],"9c6c0dad4932399aec99b4818086cb1772773916":["43345f1452f9510f8aaadae6156fe0c834e7d957","ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1"],"6b55cd711a129fb7fc4c3c4672d652149c9a4faa":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","427edb17549d4bb82462a16eec4ee0533d12d5b7","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"4181b4cf0450ea3c6d1aff8dc3ad4ed9cd3eeb6a":["b70042a8a492f7054d480ccdd2be9796510d4327","ad60b6945c360ff89899d716d9cdec8dd674e2a0","f592209545c71895260367152601e9200399776d"],"ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1":["43345f1452f9510f8aaadae6156fe0c834e7d957"],"66b87d86427dfa19b2ef36b66de83aa9655cea33":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"427edb17549d4bb82462a16eec4ee0533d12d5b7":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"b70042a8a492f7054d480ccdd2be9796510d4327":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"a4422b331d00607258b0ed3e43934306e67764aa":["7cf5ebf4183939c15e55353b64c57a5182671639","43a787a75ad72a9bf26e8ff714d8b6d01f9eb441"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["a4422b331d00607258b0ed3e43934306e67764aa"],"ad60b6945c360ff89899d716d9cdec8dd674e2a0":["6b55cd711a129fb7fc4c3c4672d652149c9a4faa","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d"],"f592209545c71895260367152601e9200399776d":["7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["fc18bc8ea2e2c1e308757ff50671c774438e9f3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}