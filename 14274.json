{"path":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#waitForReplicationFromReplicas(String,ZkStateReader,TimeOut).mjava","commits":[{"id":"61c45e99cf6676da48f19d7511c73712ad39402b","date":1495508331,"type":0,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#waitForReplicationFromReplicas(String,ZkStateReader,TimeOut).mjava","pathOld":"/dev/null","sourceNew":"  protected void waitForReplicationFromReplicas(String collectionName, ZkStateReader zkStateReader, TimeOut timeout) throws KeeperException, InterruptedException, IOException {\n    zkStateReader.forceUpdateCollection(collectionName);\n    DocCollection collection = zkStateReader.getClusterState().getCollection(collectionName);\n    Map<String, CoreContainer> containers = new HashMap<>();\n    for (JettySolrRunner runner:jettys) {\n      if (!runner.isRunning()) {\n        continue;\n      }\n      containers.put(runner.getNodeName(), runner.getCoreContainer());\n    }\n    for(Slice s:collection.getSlices()) {\n      Replica leader = s.getLeader();\n      long leaderIndexVersion = -1;\n      while (!timeout.hasTimedOut()) {\n        leaderIndexVersion = getIndexVersion(leader);\n        if (leaderIndexVersion >= 0) {\n          break;\n        }\n        Thread.sleep(1000);\n      }\n      if (timeout.hasTimedOut()) {\n        fail(\"Unable to get leader indexVersion\");\n      }\n      for (Replica pullReplica:s.getReplicas(EnumSet.of(Replica.Type.PULL,Replica.Type.TLOG))) {\n        if (!zkStateReader.getClusterState().liveNodesContain(pullReplica.getNodeName())) {\n          continue;\n        }\n        while (true) {\n          long replicaIndexVersion = getIndexVersion(pullReplica); \n          if (leaderIndexVersion == replicaIndexVersion) {\n            log.debug(\"Leader replica's version ({}) in sync with replica({}): {} == {}\", leader.getName(), pullReplica.getName(), leaderIndexVersion, replicaIndexVersion);\n            \n            // Make sure the host is serving the correct version\n            try (SolrCore core = containers.get(pullReplica.getNodeName()).getCore(pullReplica.getCoreName())) {\n              RefCounted<SolrIndexSearcher> ref = core.getRegisteredSearcher();\n              try {\n                SolrIndexSearcher searcher = ref.get();\n                String servingVersion = searcher.getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n                if (Long.parseLong(servingVersion) == replicaIndexVersion) {\n                  break;\n                } else {\n                  log.debug(\"Replica {} has the correct version replicated, but the searcher is not ready yet. Replicated version: {}, Serving version: {}\", pullReplica.getName(), replicaIndexVersion, servingVersion);\n                }\n              } finally {\n                if (ref != null) ref.decref();\n              }\n            }\n          } else {\n            if (timeout.hasTimedOut()) {\n              logReplicaTypesReplicationInfo(collectionName, zkStateReader);\n              fail(String.format(Locale.ROOT, \"Timed out waiting for replica %s (%d) to replicate from leader %s (%d)\", pullReplica.getName(), replicaIndexVersion, leader.getName(), leaderIndexVersion));\n            }\n            if (leaderIndexVersion > replicaIndexVersion) {\n              log.debug(\"{} version is {} and leader's is {}, will wait for replication\", pullReplica.getName(), replicaIndexVersion, leaderIndexVersion);\n            } else {\n              log.debug(\"Leader replica's version ({}) is lower than pull replica({}): {} < {}\", leader.getName(), pullReplica.getName(), leaderIndexVersion, replicaIndexVersion);\n            }\n          }\n          Thread.sleep(1000);\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["a0b5e3ee6bb824e478df845ec9f04a5198d3bf77"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#waitForReplicationFromReplicas(String,ZkStateReader,TimeOut).mjava","pathOld":"/dev/null","sourceNew":"  protected void waitForReplicationFromReplicas(String collectionName, ZkStateReader zkStateReader, TimeOut timeout) throws KeeperException, InterruptedException, IOException {\n    zkStateReader.forceUpdateCollection(collectionName);\n    DocCollection collection = zkStateReader.getClusterState().getCollection(collectionName);\n    Map<String, CoreContainer> containers = new HashMap<>();\n    for (JettySolrRunner runner:jettys) {\n      if (!runner.isRunning()) {\n        continue;\n      }\n      containers.put(runner.getNodeName(), runner.getCoreContainer());\n    }\n    for(Slice s:collection.getSlices()) {\n      Replica leader = s.getLeader();\n      long leaderIndexVersion = -1;\n      while (!timeout.hasTimedOut()) {\n        leaderIndexVersion = getIndexVersion(leader);\n        if (leaderIndexVersion >= 0) {\n          break;\n        }\n        Thread.sleep(1000);\n      }\n      if (timeout.hasTimedOut()) {\n        fail(\"Unable to get leader indexVersion\");\n      }\n      for (Replica pullReplica:s.getReplicas(EnumSet.of(Replica.Type.PULL,Replica.Type.TLOG))) {\n        if (!zkStateReader.getClusterState().liveNodesContain(pullReplica.getNodeName())) {\n          continue;\n        }\n        while (true) {\n          long replicaIndexVersion = getIndexVersion(pullReplica); \n          if (leaderIndexVersion == replicaIndexVersion) {\n            log.debug(\"Leader replica's version ({}) in sync with replica({}): {} == {}\", leader.getName(), pullReplica.getName(), leaderIndexVersion, replicaIndexVersion);\n            \n            // Make sure the host is serving the correct version\n            try (SolrCore core = containers.get(pullReplica.getNodeName()).getCore(pullReplica.getCoreName())) {\n              RefCounted<SolrIndexSearcher> ref = core.getRegisteredSearcher();\n              try {\n                SolrIndexSearcher searcher = ref.get();\n                String servingVersion = searcher.getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n                if (Long.parseLong(servingVersion) == replicaIndexVersion) {\n                  break;\n                } else {\n                  log.debug(\"Replica {} has the correct version replicated, but the searcher is not ready yet. Replicated version: {}, Serving version: {}\", pullReplica.getName(), replicaIndexVersion, servingVersion);\n                }\n              } finally {\n                if (ref != null) ref.decref();\n              }\n            }\n          } else {\n            if (timeout.hasTimedOut()) {\n              logReplicaTypesReplicationInfo(collectionName, zkStateReader);\n              fail(String.format(Locale.ROOT, \"Timed out waiting for replica %s (%d) to replicate from leader %s (%d)\", pullReplica.getName(), replicaIndexVersion, leader.getName(), leaderIndexVersion));\n            }\n            if (leaderIndexVersion > replicaIndexVersion) {\n              log.debug(\"{} version is {} and leader's is {}, will wait for replication\", pullReplica.getName(), replicaIndexVersion, leaderIndexVersion);\n            } else {\n              log.debug(\"Leader replica's version ({}) is lower than pull replica({}): {} < {}\", leader.getName(), pullReplica.getName(), leaderIndexVersion, replicaIndexVersion);\n            }\n          }\n          Thread.sleep(1000);\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73a4df49bbf08e66754aaad0861f9627c0276cc2","date":1496792409,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#waitForReplicationFromReplicas(String,ZkStateReader,TimeOut).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#waitForReplicationFromReplicas(String,ZkStateReader,TimeOut).mjava","sourceNew":"  protected void waitForReplicationFromReplicas(String collectionName, ZkStateReader zkStateReader, TimeOut timeout) throws KeeperException, InterruptedException, IOException {\n    zkStateReader.forceUpdateCollection(collectionName);\n    DocCollection collection = zkStateReader.getClusterState().getCollection(collectionName);\n    Map<String, CoreContainer> containers = new HashMap<>();\n    for (JettySolrRunner runner:jettys) {\n      if (!runner.isRunning()) {\n        continue;\n      }\n      containers.put(runner.getNodeName(), runner.getCoreContainer());\n    }\n    for(Slice s:collection.getSlices()) {\n      Replica leader = s.getLeader();\n      long leaderIndexVersion = -1;\n      while (!timeout.hasTimedOut()) {\n        leaderIndexVersion = getIndexVersion(leader);\n        if (leaderIndexVersion >= 0) {\n          break;\n        }\n        Thread.sleep(1000);\n      }\n      if (timeout.hasTimedOut()) {\n        fail(\"Unable to get leader indexVersion\");\n      }\n      for (Replica pullReplica:s.getReplicas(EnumSet.of(Replica.Type.PULL,Replica.Type.TLOG))) {\n        if (!zkStateReader.getClusterState().liveNodesContain(pullReplica.getNodeName())) {\n          continue;\n        }\n        while (true) {\n          long replicaIndexVersion = getIndexVersion(pullReplica); \n          if (leaderIndexVersion == replicaIndexVersion) {\n            log.info(\"Leader replica's version ({}) in sync with replica({}): {} == {}\", leader.getName(), pullReplica.getName(), leaderIndexVersion, replicaIndexVersion);\n            \n            // Make sure the host is serving the correct version\n            try (SolrCore core = containers.get(pullReplica.getNodeName()).getCore(pullReplica.getCoreName())) {\n              RefCounted<SolrIndexSearcher> ref = core.getRegisteredSearcher();\n              try {\n                SolrIndexSearcher searcher = ref.get();\n                String servingVersion = searcher.getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n                if (Long.parseLong(servingVersion) == replicaIndexVersion) {\n                  break;\n                } else {\n                  log.info(\"Replica {} has the correct version replicated, but the searcher is not ready yet. Replicated version: {}, Serving version: {}\", pullReplica.getName(), replicaIndexVersion, servingVersion);\n                }\n              } finally {\n                if (ref != null) ref.decref();\n              }\n            }\n          } else {\n            if (timeout.hasTimedOut()) {\n              logReplicaTypesReplicationInfo(collectionName, zkStateReader);\n              fail(String.format(Locale.ROOT, \"Timed out waiting for replica %s (%d) to replicate from leader %s (%d)\", pullReplica.getName(), replicaIndexVersion, leader.getName(), leaderIndexVersion));\n            }\n            if (leaderIndexVersion > replicaIndexVersion) {\n              log.info(\"{} version is {} and leader's is {}, will wait for replication\", pullReplica.getName(), replicaIndexVersion, leaderIndexVersion);\n            } else {\n              log.info(\"Leader replica's version ({}) is lower than pull replica({}): {} < {}\", leader.getName(), pullReplica.getName(), leaderIndexVersion, replicaIndexVersion);\n            }\n          }\n          Thread.sleep(1000);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  protected void waitForReplicationFromReplicas(String collectionName, ZkStateReader zkStateReader, TimeOut timeout) throws KeeperException, InterruptedException, IOException {\n    zkStateReader.forceUpdateCollection(collectionName);\n    DocCollection collection = zkStateReader.getClusterState().getCollection(collectionName);\n    Map<String, CoreContainer> containers = new HashMap<>();\n    for (JettySolrRunner runner:jettys) {\n      if (!runner.isRunning()) {\n        continue;\n      }\n      containers.put(runner.getNodeName(), runner.getCoreContainer());\n    }\n    for(Slice s:collection.getSlices()) {\n      Replica leader = s.getLeader();\n      long leaderIndexVersion = -1;\n      while (!timeout.hasTimedOut()) {\n        leaderIndexVersion = getIndexVersion(leader);\n        if (leaderIndexVersion >= 0) {\n          break;\n        }\n        Thread.sleep(1000);\n      }\n      if (timeout.hasTimedOut()) {\n        fail(\"Unable to get leader indexVersion\");\n      }\n      for (Replica pullReplica:s.getReplicas(EnumSet.of(Replica.Type.PULL,Replica.Type.TLOG))) {\n        if (!zkStateReader.getClusterState().liveNodesContain(pullReplica.getNodeName())) {\n          continue;\n        }\n        while (true) {\n          long replicaIndexVersion = getIndexVersion(pullReplica); \n          if (leaderIndexVersion == replicaIndexVersion) {\n            log.debug(\"Leader replica's version ({}) in sync with replica({}): {} == {}\", leader.getName(), pullReplica.getName(), leaderIndexVersion, replicaIndexVersion);\n            \n            // Make sure the host is serving the correct version\n            try (SolrCore core = containers.get(pullReplica.getNodeName()).getCore(pullReplica.getCoreName())) {\n              RefCounted<SolrIndexSearcher> ref = core.getRegisteredSearcher();\n              try {\n                SolrIndexSearcher searcher = ref.get();\n                String servingVersion = searcher.getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n                if (Long.parseLong(servingVersion) == replicaIndexVersion) {\n                  break;\n                } else {\n                  log.debug(\"Replica {} has the correct version replicated, but the searcher is not ready yet. Replicated version: {}, Serving version: {}\", pullReplica.getName(), replicaIndexVersion, servingVersion);\n                }\n              } finally {\n                if (ref != null) ref.decref();\n              }\n            }\n          } else {\n            if (timeout.hasTimedOut()) {\n              logReplicaTypesReplicationInfo(collectionName, zkStateReader);\n              fail(String.format(Locale.ROOT, \"Timed out waiting for replica %s (%d) to replicate from leader %s (%d)\", pullReplica.getName(), replicaIndexVersion, leader.getName(), leaderIndexVersion));\n            }\n            if (leaderIndexVersion > replicaIndexVersion) {\n              log.debug(\"{} version is {} and leader's is {}, will wait for replication\", pullReplica.getName(), replicaIndexVersion, leaderIndexVersion);\n            } else {\n              log.debug(\"Leader replica's version ({}) is lower than pull replica({}): {} < {}\", leader.getName(), pullReplica.getName(), leaderIndexVersion, replicaIndexVersion);\n            }\n          }\n          Thread.sleep(1000);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f344bb33ca91f48e99c061980115b46fa84fc8f5","date":1496903283,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#waitForReplicationFromReplicas(String,ZkStateReader,TimeOut).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#waitForReplicationFromReplicas(String,ZkStateReader,TimeOut).mjava","sourceNew":"  protected void waitForReplicationFromReplicas(String collectionName, ZkStateReader zkStateReader, TimeOut timeout) throws KeeperException, InterruptedException, IOException {\n    zkStateReader.forceUpdateCollection(collectionName);\n    DocCollection collection = zkStateReader.getClusterState().getCollection(collectionName);\n    Map<String, CoreContainer> containers = new HashMap<>();\n    for (JettySolrRunner runner:jettys) {\n      if (!runner.isRunning()) {\n        continue;\n      }\n      containers.put(runner.getNodeName(), runner.getCoreContainer());\n    }\n    for(Slice s:collection.getSlices()) {\n      Replica leader = s.getLeader();\n      long leaderIndexVersion = -1;\n      while (!timeout.hasTimedOut()) {\n        leaderIndexVersion = getIndexVersion(leader);\n        if (leaderIndexVersion >= 0) {\n          break;\n        }\n        Thread.sleep(1000);\n      }\n      if (timeout.hasTimedOut()) {\n        fail(\"Unable to get leader indexVersion\");\n      }\n      for (Replica pullReplica:s.getReplicas(EnumSet.of(Replica.Type.PULL,Replica.Type.TLOG))) {\n        if (!zkStateReader.getClusterState().liveNodesContain(pullReplica.getNodeName())) {\n          continue;\n        }\n        while (true) {\n          long replicaIndexVersion = getIndexVersion(pullReplica); \n          if (leaderIndexVersion == replicaIndexVersion) {\n            log.info(\"Leader replica's version ({}) in sync with replica({}): {} == {}\", leader.getName(), pullReplica.getName(), leaderIndexVersion, replicaIndexVersion);\n            \n            // Make sure the host is serving the correct version\n            try (SolrCore core = containers.get(pullReplica.getNodeName()).getCore(pullReplica.getCoreName())) {\n              RefCounted<SolrIndexSearcher> ref = core.getRegisteredSearcher();\n              try {\n                SolrIndexSearcher searcher = ref.get();\n                String servingVersion = searcher.getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n                if (Long.parseLong(servingVersion) == replicaIndexVersion) {\n                  break;\n                } else {\n                  log.info(\"Replica {} has the correct version replicated, but the searcher is not ready yet. Replicated version: {}, Serving version: {}\", pullReplica.getName(), replicaIndexVersion, servingVersion);\n                }\n              } finally {\n                if (ref != null) ref.decref();\n              }\n            }\n          } else {\n            if (timeout.hasTimedOut()) {\n              logReplicaTypesReplicationInfo(collectionName, zkStateReader);\n              fail(String.format(Locale.ROOT, \"Timed out waiting for replica %s (%d) to replicate from leader %s (%d)\", pullReplica.getName(), replicaIndexVersion, leader.getName(), leaderIndexVersion));\n            }\n            if (leaderIndexVersion > replicaIndexVersion) {\n              log.info(\"{} version is {} and leader's is {}, will wait for replication\", pullReplica.getName(), replicaIndexVersion, leaderIndexVersion);\n            } else {\n              log.info(\"Leader replica's version ({}) is lower than pull replica({}): {} < {}\", leader.getName(), pullReplica.getName(), leaderIndexVersion, replicaIndexVersion);\n            }\n          }\n          Thread.sleep(1000);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  protected void waitForReplicationFromReplicas(String collectionName, ZkStateReader zkStateReader, TimeOut timeout) throws KeeperException, InterruptedException, IOException {\n    zkStateReader.forceUpdateCollection(collectionName);\n    DocCollection collection = zkStateReader.getClusterState().getCollection(collectionName);\n    Map<String, CoreContainer> containers = new HashMap<>();\n    for (JettySolrRunner runner:jettys) {\n      if (!runner.isRunning()) {\n        continue;\n      }\n      containers.put(runner.getNodeName(), runner.getCoreContainer());\n    }\n    for(Slice s:collection.getSlices()) {\n      Replica leader = s.getLeader();\n      long leaderIndexVersion = -1;\n      while (!timeout.hasTimedOut()) {\n        leaderIndexVersion = getIndexVersion(leader);\n        if (leaderIndexVersion >= 0) {\n          break;\n        }\n        Thread.sleep(1000);\n      }\n      if (timeout.hasTimedOut()) {\n        fail(\"Unable to get leader indexVersion\");\n      }\n      for (Replica pullReplica:s.getReplicas(EnumSet.of(Replica.Type.PULL,Replica.Type.TLOG))) {\n        if (!zkStateReader.getClusterState().liveNodesContain(pullReplica.getNodeName())) {\n          continue;\n        }\n        while (true) {\n          long replicaIndexVersion = getIndexVersion(pullReplica); \n          if (leaderIndexVersion == replicaIndexVersion) {\n            log.debug(\"Leader replica's version ({}) in sync with replica({}): {} == {}\", leader.getName(), pullReplica.getName(), leaderIndexVersion, replicaIndexVersion);\n            \n            // Make sure the host is serving the correct version\n            try (SolrCore core = containers.get(pullReplica.getNodeName()).getCore(pullReplica.getCoreName())) {\n              RefCounted<SolrIndexSearcher> ref = core.getRegisteredSearcher();\n              try {\n                SolrIndexSearcher searcher = ref.get();\n                String servingVersion = searcher.getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n                if (Long.parseLong(servingVersion) == replicaIndexVersion) {\n                  break;\n                } else {\n                  log.debug(\"Replica {} has the correct version replicated, but the searcher is not ready yet. Replicated version: {}, Serving version: {}\", pullReplica.getName(), replicaIndexVersion, servingVersion);\n                }\n              } finally {\n                if (ref != null) ref.decref();\n              }\n            }\n          } else {\n            if (timeout.hasTimedOut()) {\n              logReplicaTypesReplicationInfo(collectionName, zkStateReader);\n              fail(String.format(Locale.ROOT, \"Timed out waiting for replica %s (%d) to replicate from leader %s (%d)\", pullReplica.getName(), replicaIndexVersion, leader.getName(), leaderIndexVersion));\n            }\n            if (leaderIndexVersion > replicaIndexVersion) {\n              log.debug(\"{} version is {} and leader's is {}, will wait for replication\", pullReplica.getName(), replicaIndexVersion, leaderIndexVersion);\n            } else {\n              log.debug(\"Leader replica's version ({}) is lower than pull replica({}): {} < {}\", leader.getName(), pullReplica.getName(), leaderIndexVersion, replicaIndexVersion);\n            }\n          }\n          Thread.sleep(1000);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#waitForReplicationFromReplicas(String,ZkStateReader,TimeOut).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#waitForReplicationFromReplicas(String,ZkStateReader,TimeOut).mjava","sourceNew":"  protected void waitForReplicationFromReplicas(String collectionName, ZkStateReader zkStateReader, TimeOut timeout) throws KeeperException, InterruptedException, IOException {\n    zkStateReader.forceUpdateCollection(collectionName);\n    DocCollection collection = zkStateReader.getClusterState().getCollection(collectionName);\n    Map<String, CoreContainer> containers = new HashMap<>();\n    for (JettySolrRunner runner:jettys) {\n      if (!runner.isRunning()) {\n        continue;\n      }\n      containers.put(runner.getNodeName(), runner.getCoreContainer());\n    }\n    for(Slice s:collection.getSlices()) {\n      Replica leader = s.getLeader();\n      long leaderIndexVersion = -1;\n      while (!timeout.hasTimedOut()) {\n        leaderIndexVersion = getIndexVersion(leader);\n        if (leaderIndexVersion >= 0) {\n          break;\n        }\n        Thread.sleep(1000);\n      }\n      if (timeout.hasTimedOut()) {\n        fail(\"Unable to get leader indexVersion\");\n      }\n      for (Replica pullReplica:s.getReplicas(EnumSet.of(Replica.Type.PULL,Replica.Type.TLOG))) {\n        if (!zkStateReader.getClusterState().liveNodesContain(pullReplica.getNodeName())) {\n          continue;\n        }\n        while (true) {\n          long replicaIndexVersion = getIndexVersion(pullReplica); \n          if (leaderIndexVersion == replicaIndexVersion) {\n            log.info(\"Leader replica's version ({}) in sync with replica({}): {} == {}\", leader.getName(), pullReplica.getName(), leaderIndexVersion, replicaIndexVersion);\n            \n            // Make sure the host is serving the correct version\n            try (SolrCore core = containers.get(pullReplica.getNodeName()).getCore(pullReplica.getCoreName())) {\n              RefCounted<SolrIndexSearcher> ref = core.getRegisteredSearcher();\n              try {\n                SolrIndexSearcher searcher = ref.get();\n                String servingVersion = searcher.getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n                if (Long.parseLong(servingVersion) == replicaIndexVersion) {\n                  break;\n                } else {\n                  log.info(\"Replica {} has the correct version replicated, but the searcher is not ready yet. Replicated version: {}, Serving version: {}\", pullReplica.getName(), replicaIndexVersion, servingVersion);\n                }\n              } finally {\n                if (ref != null) ref.decref();\n              }\n            }\n          } else {\n            if (timeout.hasTimedOut()) {\n              logReplicaTypesReplicationInfo(collectionName, zkStateReader);\n              fail(String.format(Locale.ROOT, \"Timed out waiting for replica %s (%d) to replicate from leader %s (%d)\", pullReplica.getName(), replicaIndexVersion, leader.getName(), leaderIndexVersion));\n            }\n            if (leaderIndexVersion > replicaIndexVersion) {\n              log.info(\"{} version is {} and leader's is {}, will wait for replication\", pullReplica.getName(), replicaIndexVersion, leaderIndexVersion);\n            } else {\n              log.info(\"Leader replica's version ({}) is lower than pull replica({}): {} < {}\", leader.getName(), pullReplica.getName(), leaderIndexVersion, replicaIndexVersion);\n            }\n          }\n          Thread.sleep(1000);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  protected void waitForReplicationFromReplicas(String collectionName, ZkStateReader zkStateReader, TimeOut timeout) throws KeeperException, InterruptedException, IOException {\n    zkStateReader.forceUpdateCollection(collectionName);\n    DocCollection collection = zkStateReader.getClusterState().getCollection(collectionName);\n    Map<String, CoreContainer> containers = new HashMap<>();\n    for (JettySolrRunner runner:jettys) {\n      if (!runner.isRunning()) {\n        continue;\n      }\n      containers.put(runner.getNodeName(), runner.getCoreContainer());\n    }\n    for(Slice s:collection.getSlices()) {\n      Replica leader = s.getLeader();\n      long leaderIndexVersion = -1;\n      while (!timeout.hasTimedOut()) {\n        leaderIndexVersion = getIndexVersion(leader);\n        if (leaderIndexVersion >= 0) {\n          break;\n        }\n        Thread.sleep(1000);\n      }\n      if (timeout.hasTimedOut()) {\n        fail(\"Unable to get leader indexVersion\");\n      }\n      for (Replica pullReplica:s.getReplicas(EnumSet.of(Replica.Type.PULL,Replica.Type.TLOG))) {\n        if (!zkStateReader.getClusterState().liveNodesContain(pullReplica.getNodeName())) {\n          continue;\n        }\n        while (true) {\n          long replicaIndexVersion = getIndexVersion(pullReplica); \n          if (leaderIndexVersion == replicaIndexVersion) {\n            log.debug(\"Leader replica's version ({}) in sync with replica({}): {} == {}\", leader.getName(), pullReplica.getName(), leaderIndexVersion, replicaIndexVersion);\n            \n            // Make sure the host is serving the correct version\n            try (SolrCore core = containers.get(pullReplica.getNodeName()).getCore(pullReplica.getCoreName())) {\n              RefCounted<SolrIndexSearcher> ref = core.getRegisteredSearcher();\n              try {\n                SolrIndexSearcher searcher = ref.get();\n                String servingVersion = searcher.getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n                if (Long.parseLong(servingVersion) == replicaIndexVersion) {\n                  break;\n                } else {\n                  log.debug(\"Replica {} has the correct version replicated, but the searcher is not ready yet. Replicated version: {}, Serving version: {}\", pullReplica.getName(), replicaIndexVersion, servingVersion);\n                }\n              } finally {\n                if (ref != null) ref.decref();\n              }\n            }\n          } else {\n            if (timeout.hasTimedOut()) {\n              logReplicaTypesReplicationInfo(collectionName, zkStateReader);\n              fail(String.format(Locale.ROOT, \"Timed out waiting for replica %s (%d) to replicate from leader %s (%d)\", pullReplica.getName(), replicaIndexVersion, leader.getName(), leaderIndexVersion));\n            }\n            if (leaderIndexVersion > replicaIndexVersion) {\n              log.debug(\"{} version is {} and leader's is {}, will wait for replication\", pullReplica.getName(), replicaIndexVersion, leaderIndexVersion);\n            } else {\n              log.debug(\"Leader replica's version ({}) is lower than pull replica({}): {} < {}\", leader.getName(), pullReplica.getName(), leaderIndexVersion, replicaIndexVersion);\n            }\n          }\n          Thread.sleep(1000);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#waitForReplicationFromReplicas(String,ZkStateReader,TimeOut).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#waitForReplicationFromReplicas(String,ZkStateReader,TimeOut).mjava","sourceNew":"  protected void waitForReplicationFromReplicas(String collectionName, ZkStateReader zkStateReader, TimeOut timeout) throws KeeperException, InterruptedException, IOException {\n    zkStateReader.forceUpdateCollection(collectionName);\n    DocCollection collection = zkStateReader.getClusterState().getCollection(collectionName);\n    Map<String, CoreContainer> containers = new HashMap<>();\n    for (JettySolrRunner runner:jettys) {\n      if (!runner.isRunning()) {\n        continue;\n      }\n      containers.put(runner.getNodeName(), runner.getCoreContainer());\n    }\n    for(Slice s:collection.getSlices()) {\n      Replica leader = s.getLeader();\n      long leaderIndexVersion = -1;\n      while (!timeout.hasTimedOut()) {\n        leaderIndexVersion = getIndexVersion(leader);\n        if (leaderIndexVersion >= 0) {\n          break;\n        }\n        Thread.sleep(1000);\n      }\n      if (timeout.hasTimedOut()) {\n        fail(\"Unable to get leader indexVersion\");\n      }\n      for (Replica pullReplica:s.getReplicas(EnumSet.of(Replica.Type.PULL,Replica.Type.TLOG))) {\n        if (!zkStateReader.getClusterState().liveNodesContain(pullReplica.getNodeName())) {\n          continue;\n        }\n        while (true) {\n          long replicaIndexVersion = getIndexVersion(pullReplica); \n          if (leaderIndexVersion == replicaIndexVersion) {\n            log.info(\"Leader replica's version ({}) in sync with replica({}): {} == {}\", leader.getName(), pullReplica.getName(), leaderIndexVersion, replicaIndexVersion);\n            \n            // Make sure the host is serving the correct version\n            try (SolrCore core = containers.get(pullReplica.getNodeName()).getCore(pullReplica.getCoreName())) {\n              RefCounted<SolrIndexSearcher> ref = core.getRegisteredSearcher();\n              try {\n                SolrIndexSearcher searcher = ref.get();\n                String servingVersion = searcher.getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n                if (Long.parseLong(servingVersion) == replicaIndexVersion) {\n                  break;\n                } else {\n                  log.info(\"Replica {} has the correct version replicated, but the searcher is not ready yet. Replicated version: {}, Serving version: {}\", pullReplica.getName(), replicaIndexVersion, servingVersion);\n                }\n              } finally {\n                if (ref != null) ref.decref();\n              }\n            }\n          } else {\n            if (timeout.hasTimedOut()) {\n              logReplicaTypesReplicationInfo(collectionName, zkStateReader);\n              fail(String.format(Locale.ROOT, \"Timed out waiting for replica %s (%d) to replicate from leader %s (%d)\", pullReplica.getName(), replicaIndexVersion, leader.getName(), leaderIndexVersion));\n            }\n            if (leaderIndexVersion > replicaIndexVersion) {\n              log.info(\"{} version is {} and leader's is {}, will wait for replication\", pullReplica.getName(), replicaIndexVersion, leaderIndexVersion);\n            } else {\n              log.info(\"Leader replica's version ({}) is lower than pull replica({}): {} < {}\", leader.getName(), pullReplica.getName(), leaderIndexVersion, replicaIndexVersion);\n            }\n          }\n          Thread.sleep(1000);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  protected void waitForReplicationFromReplicas(String collectionName, ZkStateReader zkStateReader, TimeOut timeout) throws KeeperException, InterruptedException, IOException {\n    zkStateReader.forceUpdateCollection(collectionName);\n    DocCollection collection = zkStateReader.getClusterState().getCollection(collectionName);\n    Map<String, CoreContainer> containers = new HashMap<>();\n    for (JettySolrRunner runner:jettys) {\n      if (!runner.isRunning()) {\n        continue;\n      }\n      containers.put(runner.getNodeName(), runner.getCoreContainer());\n    }\n    for(Slice s:collection.getSlices()) {\n      Replica leader = s.getLeader();\n      long leaderIndexVersion = -1;\n      while (!timeout.hasTimedOut()) {\n        leaderIndexVersion = getIndexVersion(leader);\n        if (leaderIndexVersion >= 0) {\n          break;\n        }\n        Thread.sleep(1000);\n      }\n      if (timeout.hasTimedOut()) {\n        fail(\"Unable to get leader indexVersion\");\n      }\n      for (Replica pullReplica:s.getReplicas(EnumSet.of(Replica.Type.PULL,Replica.Type.TLOG))) {\n        if (!zkStateReader.getClusterState().liveNodesContain(pullReplica.getNodeName())) {\n          continue;\n        }\n        while (true) {\n          long replicaIndexVersion = getIndexVersion(pullReplica); \n          if (leaderIndexVersion == replicaIndexVersion) {\n            log.debug(\"Leader replica's version ({}) in sync with replica({}): {} == {}\", leader.getName(), pullReplica.getName(), leaderIndexVersion, replicaIndexVersion);\n            \n            // Make sure the host is serving the correct version\n            try (SolrCore core = containers.get(pullReplica.getNodeName()).getCore(pullReplica.getCoreName())) {\n              RefCounted<SolrIndexSearcher> ref = core.getRegisteredSearcher();\n              try {\n                SolrIndexSearcher searcher = ref.get();\n                String servingVersion = searcher.getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n                if (Long.parseLong(servingVersion) == replicaIndexVersion) {\n                  break;\n                } else {\n                  log.debug(\"Replica {} has the correct version replicated, but the searcher is not ready yet. Replicated version: {}, Serving version: {}\", pullReplica.getName(), replicaIndexVersion, servingVersion);\n                }\n              } finally {\n                if (ref != null) ref.decref();\n              }\n            }\n          } else {\n            if (timeout.hasTimedOut()) {\n              logReplicaTypesReplicationInfo(collectionName, zkStateReader);\n              fail(String.format(Locale.ROOT, \"Timed out waiting for replica %s (%d) to replicate from leader %s (%d)\", pullReplica.getName(), replicaIndexVersion, leader.getName(), leaderIndexVersion));\n            }\n            if (leaderIndexVersion > replicaIndexVersion) {\n              log.debug(\"{} version is {} and leader's is {}, will wait for replication\", pullReplica.getName(), replicaIndexVersion, leaderIndexVersion);\n            } else {\n              log.debug(\"Leader replica's version ({}) is lower than pull replica({}): {} < {}\", leader.getName(), pullReplica.getName(), leaderIndexVersion, replicaIndexVersion);\n            }\n          }\n          Thread.sleep(1000);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0b5e3ee6bb824e478df845ec9f04a5198d3bf77","date":1519772788,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#waitForReplicationFromReplicas(String,ZkStateReader,TimeOut).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#waitForReplicationFromReplicas(String,ZkStateReader,TimeOut).mjava","sourceNew":"  protected void waitForReplicationFromReplicas(String collectionName, ZkStateReader zkStateReader, TimeOut timeout) throws KeeperException, InterruptedException, IOException {\n    zkStateReader.forceUpdateCollection(collectionName);\n    DocCollection collection = zkStateReader.getClusterState().getCollection(collectionName);\n    Map<String, CoreContainer> containers = new HashMap<>();\n    for (JettySolrRunner runner:jettys) {\n      if (!runner.isRunning()) {\n        continue;\n      }\n      containers.put(runner.getNodeName(), runner.getCoreContainer());\n    }\n    for(Slice s:collection.getSlices()) {\n      Replica leader = zkStateReader.getLeaderRetry(collectionName, s.getName(), (int)timeout.timeLeft(TimeUnit.MILLISECONDS));\n      long leaderIndexVersion = -1;\n      while (!timeout.hasTimedOut()) {\n        leaderIndexVersion = getIndexVersion(leader);\n        if (leaderIndexVersion >= 0) {\n          break;\n        }\n        Thread.sleep(1000);\n      }\n      if (timeout.hasTimedOut()) {\n        fail(\"Unable to get leader indexVersion\");\n      }\n      for (Replica pullReplica:s.getReplicas(EnumSet.of(Replica.Type.PULL,Replica.Type.TLOG))) {\n        if (!zkStateReader.getClusterState().liveNodesContain(pullReplica.getNodeName())) {\n          continue;\n        }\n        while (true) {\n          long replicaIndexVersion = getIndexVersion(pullReplica); \n          if (leaderIndexVersion == replicaIndexVersion) {\n            log.info(\"Leader replica's version ({}) in sync with replica({}): {} == {}\", leader.getName(), pullReplica.getName(), leaderIndexVersion, replicaIndexVersion);\n            \n            // Make sure the host is serving the correct version\n            try (SolrCore core = containers.get(pullReplica.getNodeName()).getCore(pullReplica.getCoreName())) {\n              RefCounted<SolrIndexSearcher> ref = core.getRegisteredSearcher();\n              try {\n                SolrIndexSearcher searcher = ref.get();\n                String servingVersion = searcher.getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n                if (Long.parseLong(servingVersion) == replicaIndexVersion) {\n                  break;\n                } else {\n                  log.info(\"Replica {} has the correct version replicated, but the searcher is not ready yet. Replicated version: {}, Serving version: {}\", pullReplica.getName(), replicaIndexVersion, servingVersion);\n                }\n              } finally {\n                if (ref != null) ref.decref();\n              }\n            }\n          } else {\n            if (timeout.hasTimedOut()) {\n              logReplicaTypesReplicationInfo(collectionName, zkStateReader);\n              fail(String.format(Locale.ROOT, \"Timed out waiting for replica %s (%d) to replicate from leader %s (%d)\", pullReplica.getName(), replicaIndexVersion, leader.getName(), leaderIndexVersion));\n            }\n            if (leaderIndexVersion > replicaIndexVersion) {\n              log.info(\"{} version is {} and leader's is {}, will wait for replication\", pullReplica.getName(), replicaIndexVersion, leaderIndexVersion);\n            } else {\n              log.info(\"Leader replica's version ({}) is lower than pull replica({}): {} < {}\", leader.getName(), pullReplica.getName(), leaderIndexVersion, replicaIndexVersion);\n            }\n          }\n          Thread.sleep(1000);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  protected void waitForReplicationFromReplicas(String collectionName, ZkStateReader zkStateReader, TimeOut timeout) throws KeeperException, InterruptedException, IOException {\n    zkStateReader.forceUpdateCollection(collectionName);\n    DocCollection collection = zkStateReader.getClusterState().getCollection(collectionName);\n    Map<String, CoreContainer> containers = new HashMap<>();\n    for (JettySolrRunner runner:jettys) {\n      if (!runner.isRunning()) {\n        continue;\n      }\n      containers.put(runner.getNodeName(), runner.getCoreContainer());\n    }\n    for(Slice s:collection.getSlices()) {\n      Replica leader = s.getLeader();\n      long leaderIndexVersion = -1;\n      while (!timeout.hasTimedOut()) {\n        leaderIndexVersion = getIndexVersion(leader);\n        if (leaderIndexVersion >= 0) {\n          break;\n        }\n        Thread.sleep(1000);\n      }\n      if (timeout.hasTimedOut()) {\n        fail(\"Unable to get leader indexVersion\");\n      }\n      for (Replica pullReplica:s.getReplicas(EnumSet.of(Replica.Type.PULL,Replica.Type.TLOG))) {\n        if (!zkStateReader.getClusterState().liveNodesContain(pullReplica.getNodeName())) {\n          continue;\n        }\n        while (true) {\n          long replicaIndexVersion = getIndexVersion(pullReplica); \n          if (leaderIndexVersion == replicaIndexVersion) {\n            log.info(\"Leader replica's version ({}) in sync with replica({}): {} == {}\", leader.getName(), pullReplica.getName(), leaderIndexVersion, replicaIndexVersion);\n            \n            // Make sure the host is serving the correct version\n            try (SolrCore core = containers.get(pullReplica.getNodeName()).getCore(pullReplica.getCoreName())) {\n              RefCounted<SolrIndexSearcher> ref = core.getRegisteredSearcher();\n              try {\n                SolrIndexSearcher searcher = ref.get();\n                String servingVersion = searcher.getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n                if (Long.parseLong(servingVersion) == replicaIndexVersion) {\n                  break;\n                } else {\n                  log.info(\"Replica {} has the correct version replicated, but the searcher is not ready yet. Replicated version: {}, Serving version: {}\", pullReplica.getName(), replicaIndexVersion, servingVersion);\n                }\n              } finally {\n                if (ref != null) ref.decref();\n              }\n            }\n          } else {\n            if (timeout.hasTimedOut()) {\n              logReplicaTypesReplicationInfo(collectionName, zkStateReader);\n              fail(String.format(Locale.ROOT, \"Timed out waiting for replica %s (%d) to replicate from leader %s (%d)\", pullReplica.getName(), replicaIndexVersion, leader.getName(), leaderIndexVersion));\n            }\n            if (leaderIndexVersion > replicaIndexVersion) {\n              log.info(\"{} version is {} and leader's is {}, will wait for replication\", pullReplica.getName(), replicaIndexVersion, leaderIndexVersion);\n            } else {\n              log.info(\"Leader replica's version ({}) is lower than pull replica({}): {} < {}\", leader.getName(), pullReplica.getName(), leaderIndexVersion, replicaIndexVersion);\n            }\n          }\n          Thread.sleep(1000);\n        }\n      }\n    }\n  }\n\n","bugFix":["61c45e99cf6676da48f19d7511c73712ad39402b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b06f42faae0ab79dde1a569756990bb96283580d","date":1566418420,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#waitForReplicationFromReplicas(String,ZkStateReader,TimeOut).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#waitForReplicationFromReplicas(String,ZkStateReader,TimeOut).mjava","sourceNew":"  protected void waitForReplicationFromReplicas(String collectionName, ZkStateReader zkStateReader, TimeOut timeout) throws KeeperException, InterruptedException, IOException {\n    log.info(\"waitForReplicationFromReplicas: {}\", collectionName);\n    zkStateReader.forceUpdateCollection(collectionName);\n    DocCollection collection = zkStateReader.getClusterState().getCollection(collectionName);\n    Map<String, CoreContainer> containers = new HashMap<>();\n    for (JettySolrRunner runner:jettys) {\n      if (!runner.isRunning()) {\n        continue;\n      }\n      containers.put(runner.getNodeName(), runner.getCoreContainer());\n    }\n    for(Slice s:collection.getSlices()) {\n      Replica leader = zkStateReader.getLeaderRetry(collectionName, s.getName(), (int)timeout.timeLeft(TimeUnit.MILLISECONDS));\n      long leaderIndexVersion = -1;\n      while (!timeout.hasTimedOut()) {\n        leaderIndexVersion = getIndexVersion(leader);\n        if (leaderIndexVersion >= 0) {\n          break;\n        }\n        Thread.sleep(1000);\n      }\n      if (timeout.hasTimedOut()) {\n        fail(\"Unable to get leader indexVersion\");\n      }\n      for (Replica pullReplica:s.getReplicas(EnumSet.of(Replica.Type.PULL,Replica.Type.TLOG))) {\n        if (!zkStateReader.getClusterState().liveNodesContain(pullReplica.getNodeName())) {\n          continue;\n        }\n        while (true) {\n          long replicaIndexVersion = getIndexVersion(pullReplica); \n          if (leaderIndexVersion == replicaIndexVersion) {\n            log.info(\"Leader replica's version ({}) in sync with replica({}): {} == {}\", leader.getName(), pullReplica.getName(), leaderIndexVersion, replicaIndexVersion);\n            \n            // Make sure the host is serving the correct version\n            try (SolrCore core = containers.get(pullReplica.getNodeName()).getCore(pullReplica.getCoreName())) {\n              RefCounted<SolrIndexSearcher> ref = core.getRegisteredSearcher();\n              try {\n                SolrIndexSearcher searcher = ref.get();\n                String servingVersion = searcher.getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n                if (Long.parseLong(servingVersion) == replicaIndexVersion) {\n                  break;\n                } else {\n                  log.info(\"Replica {} has the correct version replicated, but the searcher is not ready yet. Replicated version: {}, Serving version: {}\", pullReplica.getName(), replicaIndexVersion, servingVersion);\n                }\n              } finally {\n                if (ref != null) ref.decref();\n              }\n            }\n          } else {\n            if (timeout.hasTimedOut()) {\n              logReplicaTypesReplicationInfo(collectionName, zkStateReader);\n              fail(String.format(Locale.ROOT, \"Timed out waiting for replica %s (%d) to replicate from leader %s (%d)\", pullReplica.getName(), replicaIndexVersion, leader.getName(), leaderIndexVersion));\n            }\n            if (leaderIndexVersion > replicaIndexVersion) {\n              log.info(\"{} version is {} and leader's is {}, will wait for replication\", pullReplica.getName(), replicaIndexVersion, leaderIndexVersion);\n            } else {\n              log.info(\"Leader replica's version ({}) is lower than pull replica({}): {} < {}\", leader.getName(), pullReplica.getName(), leaderIndexVersion, replicaIndexVersion);\n            }\n          }\n          Thread.sleep(1000);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  protected void waitForReplicationFromReplicas(String collectionName, ZkStateReader zkStateReader, TimeOut timeout) throws KeeperException, InterruptedException, IOException {\n    zkStateReader.forceUpdateCollection(collectionName);\n    DocCollection collection = zkStateReader.getClusterState().getCollection(collectionName);\n    Map<String, CoreContainer> containers = new HashMap<>();\n    for (JettySolrRunner runner:jettys) {\n      if (!runner.isRunning()) {\n        continue;\n      }\n      containers.put(runner.getNodeName(), runner.getCoreContainer());\n    }\n    for(Slice s:collection.getSlices()) {\n      Replica leader = zkStateReader.getLeaderRetry(collectionName, s.getName(), (int)timeout.timeLeft(TimeUnit.MILLISECONDS));\n      long leaderIndexVersion = -1;\n      while (!timeout.hasTimedOut()) {\n        leaderIndexVersion = getIndexVersion(leader);\n        if (leaderIndexVersion >= 0) {\n          break;\n        }\n        Thread.sleep(1000);\n      }\n      if (timeout.hasTimedOut()) {\n        fail(\"Unable to get leader indexVersion\");\n      }\n      for (Replica pullReplica:s.getReplicas(EnumSet.of(Replica.Type.PULL,Replica.Type.TLOG))) {\n        if (!zkStateReader.getClusterState().liveNodesContain(pullReplica.getNodeName())) {\n          continue;\n        }\n        while (true) {\n          long replicaIndexVersion = getIndexVersion(pullReplica); \n          if (leaderIndexVersion == replicaIndexVersion) {\n            log.info(\"Leader replica's version ({}) in sync with replica({}): {} == {}\", leader.getName(), pullReplica.getName(), leaderIndexVersion, replicaIndexVersion);\n            \n            // Make sure the host is serving the correct version\n            try (SolrCore core = containers.get(pullReplica.getNodeName()).getCore(pullReplica.getCoreName())) {\n              RefCounted<SolrIndexSearcher> ref = core.getRegisteredSearcher();\n              try {\n                SolrIndexSearcher searcher = ref.get();\n                String servingVersion = searcher.getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n                if (Long.parseLong(servingVersion) == replicaIndexVersion) {\n                  break;\n                } else {\n                  log.info(\"Replica {} has the correct version replicated, but the searcher is not ready yet. Replicated version: {}, Serving version: {}\", pullReplica.getName(), replicaIndexVersion, servingVersion);\n                }\n              } finally {\n                if (ref != null) ref.decref();\n              }\n            }\n          } else {\n            if (timeout.hasTimedOut()) {\n              logReplicaTypesReplicationInfo(collectionName, zkStateReader);\n              fail(String.format(Locale.ROOT, \"Timed out waiting for replica %s (%d) to replicate from leader %s (%d)\", pullReplica.getName(), replicaIndexVersion, leader.getName(), leaderIndexVersion));\n            }\n            if (leaderIndexVersion > replicaIndexVersion) {\n              log.info(\"{} version is {} and leader's is {}, will wait for replication\", pullReplica.getName(), replicaIndexVersion, leaderIndexVersion);\n            } else {\n              log.info(\"Leader replica's version ({}) is lower than pull replica({}): {} < {}\", leader.getName(), pullReplica.getName(), leaderIndexVersion, replicaIndexVersion);\n            }\n          }\n          Thread.sleep(1000);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#waitForReplicationFromReplicas(String,ZkStateReader,TimeOut).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase#waitForReplicationFromReplicas(String,ZkStateReader,TimeOut).mjava","sourceNew":"  protected void waitForReplicationFromReplicas(String collectionName, ZkStateReader zkStateReader, TimeOut timeout) throws KeeperException, InterruptedException, IOException {\n    log.info(\"waitForReplicationFromReplicas: {}\", collectionName);\n    zkStateReader.forceUpdateCollection(collectionName);\n    DocCollection collection = zkStateReader.getClusterState().getCollection(collectionName);\n    Map<String, CoreContainer> containers = new HashMap<>();\n    for (JettySolrRunner runner:jettys) {\n      if (!runner.isRunning()) {\n        continue;\n      }\n      containers.put(runner.getNodeName(), runner.getCoreContainer());\n    }\n    for(Slice s:collection.getSlices()) {\n      Replica leader = zkStateReader.getLeaderRetry(collectionName, s.getName(), (int)timeout.timeLeft(TimeUnit.MILLISECONDS));\n      long leaderIndexVersion = -1;\n      while (!timeout.hasTimedOut()) {\n        leaderIndexVersion = getIndexVersion(leader);\n        if (leaderIndexVersion >= 0) {\n          break;\n        }\n        Thread.sleep(1000);\n      }\n      if (timeout.hasTimedOut()) {\n        fail(\"Unable to get leader indexVersion\");\n      }\n      for (Replica pullReplica:s.getReplicas(EnumSet.of(Replica.Type.PULL,Replica.Type.TLOG))) {\n        if (!zkStateReader.getClusterState().liveNodesContain(pullReplica.getNodeName())) {\n          continue;\n        }\n        while (true) {\n          long replicaIndexVersion = getIndexVersion(pullReplica); \n          if (leaderIndexVersion == replicaIndexVersion) {\n            if (log.isInfoEnabled()) {\n              log.info(\"Leader replica's version ({}) in sync with replica({}): {} == {}\"\n                  , leader.getName(), pullReplica.getName(), leaderIndexVersion, replicaIndexVersion);\n            }\n            \n            // Make sure the host is serving the correct version\n            try (SolrCore core = containers.get(pullReplica.getNodeName()).getCore(pullReplica.getCoreName())) {\n              RefCounted<SolrIndexSearcher> ref = core.getRegisteredSearcher();\n              try {\n                SolrIndexSearcher searcher = ref.get();\n                String servingVersion = searcher.getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n                if (Long.parseLong(servingVersion) == replicaIndexVersion) {\n                  break;\n                } else {\n                  if (log.isInfoEnabled()) {\n                    log.info(\"Replica {} has the correct version replicated, but the searcher is not ready yet. Replicated version: {}, Serving version: {}\"\n                        , pullReplica.getName(), replicaIndexVersion, servingVersion);\n                  }\n                }\n              } finally {\n                if (ref != null) ref.decref();\n              }\n            }\n          } else {\n            if (timeout.hasTimedOut()) {\n              logReplicaTypesReplicationInfo(collectionName, zkStateReader);\n              fail(String.format(Locale.ROOT, \"Timed out waiting for replica %s (%d) to replicate from leader %s (%d)\", pullReplica.getName(), replicaIndexVersion, leader.getName(), leaderIndexVersion));\n            }\n            if (leaderIndexVersion > replicaIndexVersion) {\n              if (log.isInfoEnabled()) {\n                log.info(\"{} version is {} and leader's is {}, will wait for replication\"\n                    , pullReplica.getName(), replicaIndexVersion, leaderIndexVersion);\n              }\n            } else {\n              if (log.isInfoEnabled()) {\n                log.info(\"Leader replica's version ({}) is lower than pull replica({}): {} < {}\"\n                    , leader.getName(), pullReplica.getName(), leaderIndexVersion, replicaIndexVersion);\n              }\n            }\n          }\n          Thread.sleep(1000);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  protected void waitForReplicationFromReplicas(String collectionName, ZkStateReader zkStateReader, TimeOut timeout) throws KeeperException, InterruptedException, IOException {\n    log.info(\"waitForReplicationFromReplicas: {}\", collectionName);\n    zkStateReader.forceUpdateCollection(collectionName);\n    DocCollection collection = zkStateReader.getClusterState().getCollection(collectionName);\n    Map<String, CoreContainer> containers = new HashMap<>();\n    for (JettySolrRunner runner:jettys) {\n      if (!runner.isRunning()) {\n        continue;\n      }\n      containers.put(runner.getNodeName(), runner.getCoreContainer());\n    }\n    for(Slice s:collection.getSlices()) {\n      Replica leader = zkStateReader.getLeaderRetry(collectionName, s.getName(), (int)timeout.timeLeft(TimeUnit.MILLISECONDS));\n      long leaderIndexVersion = -1;\n      while (!timeout.hasTimedOut()) {\n        leaderIndexVersion = getIndexVersion(leader);\n        if (leaderIndexVersion >= 0) {\n          break;\n        }\n        Thread.sleep(1000);\n      }\n      if (timeout.hasTimedOut()) {\n        fail(\"Unable to get leader indexVersion\");\n      }\n      for (Replica pullReplica:s.getReplicas(EnumSet.of(Replica.Type.PULL,Replica.Type.TLOG))) {\n        if (!zkStateReader.getClusterState().liveNodesContain(pullReplica.getNodeName())) {\n          continue;\n        }\n        while (true) {\n          long replicaIndexVersion = getIndexVersion(pullReplica); \n          if (leaderIndexVersion == replicaIndexVersion) {\n            log.info(\"Leader replica's version ({}) in sync with replica({}): {} == {}\", leader.getName(), pullReplica.getName(), leaderIndexVersion, replicaIndexVersion);\n            \n            // Make sure the host is serving the correct version\n            try (SolrCore core = containers.get(pullReplica.getNodeName()).getCore(pullReplica.getCoreName())) {\n              RefCounted<SolrIndexSearcher> ref = core.getRegisteredSearcher();\n              try {\n                SolrIndexSearcher searcher = ref.get();\n                String servingVersion = searcher.getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n                if (Long.parseLong(servingVersion) == replicaIndexVersion) {\n                  break;\n                } else {\n                  log.info(\"Replica {} has the correct version replicated, but the searcher is not ready yet. Replicated version: {}, Serving version: {}\", pullReplica.getName(), replicaIndexVersion, servingVersion);\n                }\n              } finally {\n                if (ref != null) ref.decref();\n              }\n            }\n          } else {\n            if (timeout.hasTimedOut()) {\n              logReplicaTypesReplicationInfo(collectionName, zkStateReader);\n              fail(String.format(Locale.ROOT, \"Timed out waiting for replica %s (%d) to replicate from leader %s (%d)\", pullReplica.getName(), replicaIndexVersion, leader.getName(), leaderIndexVersion));\n            }\n            if (leaderIndexVersion > replicaIndexVersion) {\n              log.info(\"{} version is {} and leader's is {}, will wait for replication\", pullReplica.getName(), replicaIndexVersion, leaderIndexVersion);\n            } else {\n              log.info(\"Leader replica's version ({}) is lower than pull replica({}): {} < {}\", leader.getName(), pullReplica.getName(), leaderIndexVersion, replicaIndexVersion);\n            }\n          }\n          Thread.sleep(1000);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e9017cf144952056066919f1ebc7897ff9bd71b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","61c45e99cf6676da48f19d7511c73712ad39402b"],"61c45e99cf6676da48f19d7511c73712ad39402b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0b5e3ee6bb824e478df845ec9f04a5198d3bf77":["28288370235ed02234a64753cdbf0c6ec096304a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b06f42faae0ab79dde1a569756990bb96283580d":["a0b5e3ee6bb824e478df845ec9f04a5198d3bf77"],"f344bb33ca91f48e99c061980115b46fa84fc8f5":["61c45e99cf6676da48f19d7511c73712ad39402b","73a4df49bbf08e66754aaad0861f9627c0276cc2"],"73a4df49bbf08e66754aaad0861f9627c0276cc2":["61c45e99cf6676da48f19d7511c73712ad39402b"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["b06f42faae0ab79dde1a569756990bb96283580d"],"28288370235ed02234a64753cdbf0c6ec096304a":["61c45e99cf6676da48f19d7511c73712ad39402b","f344bb33ca91f48e99c061980115b46fa84fc8f5"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["e9017cf144952056066919f1ebc7897ff9bd71b1","f344bb33ca91f48e99c061980115b46fa84fc8f5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a966532d92cf9ba2856f15a8140151bb6b518e4b"]},"commit2Childs":{"e9017cf144952056066919f1ebc7897ff9bd71b1":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"61c45e99cf6676da48f19d7511c73712ad39402b":["e9017cf144952056066919f1ebc7897ff9bd71b1","f344bb33ca91f48e99c061980115b46fa84fc8f5","73a4df49bbf08e66754aaad0861f9627c0276cc2","28288370235ed02234a64753cdbf0c6ec096304a"],"a0b5e3ee6bb824e478df845ec9f04a5198d3bf77":["b06f42faae0ab79dde1a569756990bb96283580d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e9017cf144952056066919f1ebc7897ff9bd71b1","61c45e99cf6676da48f19d7511c73712ad39402b"],"b06f42faae0ab79dde1a569756990bb96283580d":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"f344bb33ca91f48e99c061980115b46fa84fc8f5":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"73a4df49bbf08e66754aaad0861f9627c0276cc2":["f344bb33ca91f48e99c061980115b46fa84fc8f5"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"28288370235ed02234a64753cdbf0c6ec096304a":["a0b5e3ee6bb824e478df845ec9f04a5198d3bf77"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}