{"path":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","sourceNew":"  public void save(DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    if (nodeAddress != null) {\n      throw new IllegalStateException(\"cannot save an FST pre-packed FST; it must first be packed\");\n    }\n    CodecUtil.writeHeader(out, FILE_FORMAT_NAME, VERSION_CURRENT);\n    if (packed) {\n      out.writeByte((byte) 1);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      out.writeByte((byte) 1);\n      out.writeVInt(emptyOutputBytes.length);\n      out.writeBytes(emptyOutputBytes, 0, emptyOutputBytes.length);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    out.writeByte(t);\n    if (packed) {\n      assert nodeRefToAddress != null;\n      out.writeVInt(nodeRefToAddress.length);\n      for(int idx=0;idx<nodeRefToAddress.length;idx++) {\n        out.writeVInt(nodeRefToAddress[idx]);\n      }\n    }\n    out.writeVInt(startNode);\n    out.writeVInt(nodeCount);\n    out.writeVInt(arcCount);\n    out.writeVInt(arcWithOutputCount);\n    out.writeVInt(bytes.length);\n    out.writeBytes(bytes, 0, bytes.length);\n  }\n\n","sourceOld":"  public void save(DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    if (nodeAddress != null) {\n      throw new IllegalStateException(\"cannot save an FST pre-packed FST; it must first be packed\");\n    }\n    CodecUtil.writeHeader(out, FILE_FORMAT_NAME, VERSION_CURRENT);\n    if (packed) {\n      out.writeByte((byte) 1);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      out.writeByte((byte) 1);\n      out.writeVInt(emptyOutputBytes.length);\n      out.writeBytes(emptyOutputBytes, 0, emptyOutputBytes.length);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    out.writeByte(t);\n    if (packed) {\n      assert nodeRefToAddress != null;\n      out.writeVInt(nodeRefToAddress.length);\n      for(int idx=0;idx<nodeRefToAddress.length;idx++) {\n        out.writeVInt(nodeRefToAddress[idx]);\n      }\n    }\n    out.writeVInt(startNode);\n    out.writeVInt(nodeCount);\n    out.writeVInt(arcCount);\n    out.writeVInt(arcWithOutputCount);\n    out.writeVInt(bytes.length);\n    out.writeBytes(bytes, 0, bytes.length);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"edb74c83fff94196b864e08ca033d92823252cb7","date":1339593164,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","sourceNew":"  public void save(DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    if (nodeAddress != null) {\n      throw new IllegalStateException(\"cannot save an FST pre-packed FST; it must first be packed\");\n    }\n    if (packed && !(nodeRefToAddress instanceof PackedInts.Mutable)) {\n      throw new IllegalStateException(\"cannot save a FST which has been loaded from disk \");\n    }\n    CodecUtil.writeHeader(out, FILE_FORMAT_NAME, VERSION_CURRENT);\n    if (packed) {\n      out.writeByte((byte) 1);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      out.writeByte((byte) 1);\n      out.writeVInt(emptyOutputBytes.length);\n      out.writeBytes(emptyOutputBytes, 0, emptyOutputBytes.length);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    out.writeByte(t);\n    if (packed) {\n      ((PackedInts.Mutable) nodeRefToAddress).save(out);\n    }\n    out.writeVInt(startNode);\n    out.writeVInt(nodeCount);\n    out.writeVInt(arcCount);\n    out.writeVInt(arcWithOutputCount);\n    out.writeVInt(bytes.length);\n    out.writeBytes(bytes, 0, bytes.length);\n  }\n\n","sourceOld":"  public void save(DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    if (nodeAddress != null) {\n      throw new IllegalStateException(\"cannot save an FST pre-packed FST; it must first be packed\");\n    }\n    CodecUtil.writeHeader(out, FILE_FORMAT_NAME, VERSION_CURRENT);\n    if (packed) {\n      out.writeByte((byte) 1);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      out.writeByte((byte) 1);\n      out.writeVInt(emptyOutputBytes.length);\n      out.writeBytes(emptyOutputBytes, 0, emptyOutputBytes.length);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    out.writeByte(t);\n    if (packed) {\n      assert nodeRefToAddress != null;\n      out.writeVInt(nodeRefToAddress.length);\n      for(int idx=0;idx<nodeRefToAddress.length;idx++) {\n        out.writeVInt(nodeRefToAddress[idx]);\n      }\n    }\n    out.writeVInt(startNode);\n    out.writeVInt(nodeCount);\n    out.writeVInt(arcCount);\n    out.writeVInt(arcWithOutputCount);\n    out.writeVInt(bytes.length);\n    out.writeBytes(bytes, 0, bytes.length);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09827d0d9c0291b55c1258295b29a4fe7f0a1f40","date":1357659901,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","sourceNew":"  public void save(DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    if (nodeAddress != null) {\n      throw new IllegalStateException(\"cannot save an FST pre-packed FST; it must first be packed\");\n    }\n    if (packed && !(nodeRefToAddress instanceof PackedInts.Mutable)) {\n      throw new IllegalStateException(\"cannot save a FST which has been loaded from disk \");\n    }\n    CodecUtil.writeHeader(out, FILE_FORMAT_NAME, VERSION_CURRENT);\n    if (packed) {\n      out.writeByte((byte) 1);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      // Accepts empty string\n      out.writeByte((byte) 1);\n\n      // Serialize empty-string output:\n      RAMOutputStream ros = new RAMOutputStream();\n      outputs.writeFinalOutput(emptyOutput, ros);\n      \n      byte[] emptyOutputBytes = new byte[(int) ros.getFilePointer()];\n      ros.writeTo(emptyOutputBytes, 0);\n\n      if (true || !packed) {\n        // reverse\n        final int stopAt = emptyOutputBytes.length/2;\n        int upto = 0;\n        while(upto < stopAt) {\n          final byte b = emptyOutputBytes[upto];\n          emptyOutputBytes[upto] = emptyOutputBytes[emptyOutputBytes.length-upto-1];\n          emptyOutputBytes[emptyOutputBytes.length-upto-1] = b;\n          upto++;\n        }\n      }\n      out.writeVInt(emptyOutputBytes.length);\n      out.writeBytes(emptyOutputBytes, 0, emptyOutputBytes.length);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    out.writeByte(t);\n    if (packed) {\n      ((PackedInts.Mutable) nodeRefToAddress).save(out);\n    }\n    out.writeVInt(startNode);\n    out.writeVInt(nodeCount);\n    out.writeVInt(arcCount);\n    out.writeVInt(arcWithOutputCount);\n    out.writeVInt(bytes.length);\n    out.writeBytes(bytes, 0, bytes.length);\n  }\n\n","sourceOld":"  public void save(DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    if (nodeAddress != null) {\n      throw new IllegalStateException(\"cannot save an FST pre-packed FST; it must first be packed\");\n    }\n    if (packed && !(nodeRefToAddress instanceof PackedInts.Mutable)) {\n      throw new IllegalStateException(\"cannot save a FST which has been loaded from disk \");\n    }\n    CodecUtil.writeHeader(out, FILE_FORMAT_NAME, VERSION_CURRENT);\n    if (packed) {\n      out.writeByte((byte) 1);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      out.writeByte((byte) 1);\n      out.writeVInt(emptyOutputBytes.length);\n      out.writeBytes(emptyOutputBytes, 0, emptyOutputBytes.length);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    out.writeByte(t);\n    if (packed) {\n      ((PackedInts.Mutable) nodeRefToAddress).save(out);\n    }\n    out.writeVInt(startNode);\n    out.writeVInt(nodeCount);\n    out.writeVInt(arcCount);\n    out.writeVInt(arcWithOutputCount);\n    out.writeVInt(bytes.length);\n    out.writeBytes(bytes, 0, bytes.length);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ef0933b174e58bde65fb3876acbf28647656b925","date":1357660555,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","sourceNew":"  public void save(DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    if (nodeAddress != null) {\n      throw new IllegalStateException(\"cannot save an FST pre-packed FST; it must first be packed\");\n    }\n    if (packed && !(nodeRefToAddress instanceof PackedInts.Mutable)) {\n      throw new IllegalStateException(\"cannot save a FST which has been loaded from disk \");\n    }\n    CodecUtil.writeHeader(out, FILE_FORMAT_NAME, VERSION_CURRENT);\n    if (packed) {\n      out.writeByte((byte) 1);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      // Accepts empty string\n      out.writeByte((byte) 1);\n\n      // Serialize empty-string output:\n      RAMOutputStream ros = new RAMOutputStream();\n      outputs.writeFinalOutput(emptyOutput, ros);\n      \n      byte[] emptyOutputBytes = new byte[(int) ros.getFilePointer()];\n      ros.writeTo(emptyOutputBytes, 0);\n\n      if (!packed) {\n        // reverse\n        final int stopAt = emptyOutputBytes.length/2;\n        int upto = 0;\n        while(upto < stopAt) {\n          final byte b = emptyOutputBytes[upto];\n          emptyOutputBytes[upto] = emptyOutputBytes[emptyOutputBytes.length-upto-1];\n          emptyOutputBytes[emptyOutputBytes.length-upto-1] = b;\n          upto++;\n        }\n      }\n      out.writeVInt(emptyOutputBytes.length);\n      out.writeBytes(emptyOutputBytes, 0, emptyOutputBytes.length);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    out.writeByte(t);\n    if (packed) {\n      ((PackedInts.Mutable) nodeRefToAddress).save(out);\n    }\n    out.writeVInt(startNode);\n    out.writeVInt(nodeCount);\n    out.writeVInt(arcCount);\n    out.writeVInt(arcWithOutputCount);\n    out.writeVInt(bytes.length);\n    out.writeBytes(bytes, 0, bytes.length);\n  }\n\n","sourceOld":"  public void save(DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    if (nodeAddress != null) {\n      throw new IllegalStateException(\"cannot save an FST pre-packed FST; it must first be packed\");\n    }\n    if (packed && !(nodeRefToAddress instanceof PackedInts.Mutable)) {\n      throw new IllegalStateException(\"cannot save a FST which has been loaded from disk \");\n    }\n    CodecUtil.writeHeader(out, FILE_FORMAT_NAME, VERSION_CURRENT);\n    if (packed) {\n      out.writeByte((byte) 1);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      // Accepts empty string\n      out.writeByte((byte) 1);\n\n      // Serialize empty-string output:\n      RAMOutputStream ros = new RAMOutputStream();\n      outputs.writeFinalOutput(emptyOutput, ros);\n      \n      byte[] emptyOutputBytes = new byte[(int) ros.getFilePointer()];\n      ros.writeTo(emptyOutputBytes, 0);\n\n      if (true || !packed) {\n        // reverse\n        final int stopAt = emptyOutputBytes.length/2;\n        int upto = 0;\n        while(upto < stopAt) {\n          final byte b = emptyOutputBytes[upto];\n          emptyOutputBytes[upto] = emptyOutputBytes[emptyOutputBytes.length-upto-1];\n          emptyOutputBytes[emptyOutputBytes.length-upto-1] = b;\n          upto++;\n        }\n      }\n      out.writeVInt(emptyOutputBytes.length);\n      out.writeBytes(emptyOutputBytes, 0, emptyOutputBytes.length);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    out.writeByte(t);\n    if (packed) {\n      ((PackedInts.Mutable) nodeRefToAddress).save(out);\n    }\n    out.writeVInt(startNode);\n    out.writeVInt(nodeCount);\n    out.writeVInt(arcCount);\n    out.writeVInt(arcWithOutputCount);\n    out.writeVInt(bytes.length);\n    out.writeBytes(bytes, 0, bytes.length);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4e6354dd7c71fe122926fc53d7d29f715b1283db","date":1357915185,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","sourceNew":"  public void save(DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    if (nodeAddress != null) {\n      throw new IllegalStateException(\"cannot save an FST pre-packed FST; it must first be packed\");\n    }\n    if (packed && !(nodeRefToAddress instanceof PackedInts.Mutable)) {\n      throw new IllegalStateException(\"cannot save a FST which has been loaded from disk \");\n    }\n    CodecUtil.writeHeader(out, FILE_FORMAT_NAME, VERSION_CURRENT);\n    if (packed) {\n      out.writeByte((byte) 1);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      // Accepts empty string\n      out.writeByte((byte) 1);\n\n      // Serialize empty-string output:\n      RAMOutputStream ros = new RAMOutputStream();\n      outputs.writeFinalOutput(emptyOutput, ros);\n      \n      byte[] emptyOutputBytes = new byte[(int) ros.getFilePointer()];\n      ros.writeTo(emptyOutputBytes, 0);\n\n      if (!packed) {\n        // reverse\n        final int stopAt = emptyOutputBytes.length/2;\n        int upto = 0;\n        while(upto < stopAt) {\n          final byte b = emptyOutputBytes[upto];\n          emptyOutputBytes[upto] = emptyOutputBytes[emptyOutputBytes.length-upto-1];\n          emptyOutputBytes[emptyOutputBytes.length-upto-1] = b;\n          upto++;\n        }\n      }\n      out.writeVInt(emptyOutputBytes.length);\n      out.writeBytes(emptyOutputBytes, 0, emptyOutputBytes.length);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    out.writeByte(t);\n    if (packed) {\n      ((PackedInts.Mutable) nodeRefToAddress).save(out);\n    }\n    out.writeVInt(startNode);\n    out.writeVInt(nodeCount);\n    out.writeVInt(arcCount);\n    out.writeVInt(arcWithOutputCount);\n    out.writeVInt(bytes.length);\n    out.writeBytes(bytes, 0, bytes.length);\n  }\n\n","sourceOld":"  public void save(DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    if (nodeAddress != null) {\n      throw new IllegalStateException(\"cannot save an FST pre-packed FST; it must first be packed\");\n    }\n    if (packed && !(nodeRefToAddress instanceof PackedInts.Mutable)) {\n      throw new IllegalStateException(\"cannot save a FST which has been loaded from disk \");\n    }\n    CodecUtil.writeHeader(out, FILE_FORMAT_NAME, VERSION_CURRENT);\n    if (packed) {\n      out.writeByte((byte) 1);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      out.writeByte((byte) 1);\n      out.writeVInt(emptyOutputBytes.length);\n      out.writeBytes(emptyOutputBytes, 0, emptyOutputBytes.length);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    out.writeByte(t);\n    if (packed) {\n      ((PackedInts.Mutable) nodeRefToAddress).save(out);\n    }\n    out.writeVInt(startNode);\n    out.writeVInt(nodeCount);\n    out.writeVInt(arcCount);\n    out.writeVInt(arcWithOutputCount);\n    out.writeVInt(bytes.length);\n    out.writeBytes(bytes, 0, bytes.length);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"87e78f3c129251e74ecc2ff73a32de0f27cf09d5","date":1358006150,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","sourceNew":"  public void save(DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    if (nodeAddress != null) {\n      throw new IllegalStateException(\"cannot save an FST pre-packed FST; it must first be packed\");\n    }\n    if (packed && !(nodeRefToAddress instanceof PackedInts.Mutable)) {\n      throw new IllegalStateException(\"cannot save a FST which has been loaded from disk \");\n    }\n    CodecUtil.writeHeader(out, FILE_FORMAT_NAME, VERSION_CURRENT);\n    if (packed) {\n      out.writeByte((byte) 1);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      // Accepts empty string\n      out.writeByte((byte) 1);\n\n      // Serialize empty-string output:\n      RAMOutputStream ros = new RAMOutputStream();\n      outputs.writeFinalOutput(emptyOutput, ros);\n      \n      byte[] emptyOutputBytes = new byte[(int) ros.getFilePointer()];\n      ros.writeTo(emptyOutputBytes, 0);\n\n      if (!packed) {\n        // reverse\n        final int stopAt = emptyOutputBytes.length/2;\n        int upto = 0;\n        while(upto < stopAt) {\n          final byte b = emptyOutputBytes[upto];\n          emptyOutputBytes[upto] = emptyOutputBytes[emptyOutputBytes.length-upto-1];\n          emptyOutputBytes[emptyOutputBytes.length-upto-1] = b;\n          upto++;\n        }\n      }\n      out.writeVInt(emptyOutputBytes.length);\n      out.writeBytes(emptyOutputBytes, 0, emptyOutputBytes.length);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    out.writeByte(t);\n    if (packed) {\n      ((PackedInts.Mutable) nodeRefToAddress).save(out);\n    }\n    out.writeVInt(startNode);\n    out.writeVInt(nodeCount);\n    out.writeVInt(arcCount);\n    out.writeVInt(arcWithOutputCount);\n    int numBytes = bytes.getPosition();\n    out.writeVInt(numBytes);\n    bytes.writeTo(out);\n  }\n\n","sourceOld":"  public void save(DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    if (nodeAddress != null) {\n      throw new IllegalStateException(\"cannot save an FST pre-packed FST; it must first be packed\");\n    }\n    if (packed && !(nodeRefToAddress instanceof PackedInts.Mutable)) {\n      throw new IllegalStateException(\"cannot save a FST which has been loaded from disk \");\n    }\n    CodecUtil.writeHeader(out, FILE_FORMAT_NAME, VERSION_CURRENT);\n    if (packed) {\n      out.writeByte((byte) 1);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      // Accepts empty string\n      out.writeByte((byte) 1);\n\n      // Serialize empty-string output:\n      RAMOutputStream ros = new RAMOutputStream();\n      outputs.writeFinalOutput(emptyOutput, ros);\n      \n      byte[] emptyOutputBytes = new byte[(int) ros.getFilePointer()];\n      ros.writeTo(emptyOutputBytes, 0);\n\n      if (!packed) {\n        // reverse\n        final int stopAt = emptyOutputBytes.length/2;\n        int upto = 0;\n        while(upto < stopAt) {\n          final byte b = emptyOutputBytes[upto];\n          emptyOutputBytes[upto] = emptyOutputBytes[emptyOutputBytes.length-upto-1];\n          emptyOutputBytes[emptyOutputBytes.length-upto-1] = b;\n          upto++;\n        }\n      }\n      out.writeVInt(emptyOutputBytes.length);\n      out.writeBytes(emptyOutputBytes, 0, emptyOutputBytes.length);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    out.writeByte(t);\n    if (packed) {\n      ((PackedInts.Mutable) nodeRefToAddress).save(out);\n    }\n    out.writeVInt(startNode);\n    out.writeVInt(nodeCount);\n    out.writeVInt(arcCount);\n    out.writeVInt(arcWithOutputCount);\n    out.writeVInt(bytes.length);\n    out.writeBytes(bytes, 0, bytes.length);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0","date":1358188277,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","sourceNew":"  public void save(DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    if (nodeAddress != null) {\n      throw new IllegalStateException(\"cannot save an FST pre-packed FST; it must first be packed\");\n    }\n    if (packed && !(nodeRefToAddress instanceof PackedInts.Mutable)) {\n      throw new IllegalStateException(\"cannot save a FST which has been loaded from disk \");\n    }\n    CodecUtil.writeHeader(out, FILE_FORMAT_NAME, VERSION_CURRENT);\n    if (packed) {\n      out.writeByte((byte) 1);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      // Accepts empty string\n      out.writeByte((byte) 1);\n\n      // Serialize empty-string output:\n      RAMOutputStream ros = new RAMOutputStream();\n      outputs.writeFinalOutput(emptyOutput, ros);\n      \n      byte[] emptyOutputBytes = new byte[(int) ros.getFilePointer()];\n      ros.writeTo(emptyOutputBytes, 0);\n\n      if (!packed) {\n        // reverse\n        final int stopAt = emptyOutputBytes.length/2;\n        int upto = 0;\n        while(upto < stopAt) {\n          final byte b = emptyOutputBytes[upto];\n          emptyOutputBytes[upto] = emptyOutputBytes[emptyOutputBytes.length-upto-1];\n          emptyOutputBytes[emptyOutputBytes.length-upto-1] = b;\n          upto++;\n        }\n      }\n      out.writeVInt(emptyOutputBytes.length);\n      out.writeBytes(emptyOutputBytes, 0, emptyOutputBytes.length);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    out.writeByte(t);\n    if (packed) {\n      ((PackedInts.Mutable) nodeRefToAddress).save(out);\n    }\n    out.writeVLong(startNode);\n    out.writeVLong(nodeCount);\n    out.writeVLong(arcCount);\n    out.writeVLong(arcWithOutputCount);\n    long numBytes = bytes.getPosition();\n    out.writeVLong(numBytes);\n    bytes.writeTo(out);\n  }\n\n","sourceOld":"  public void save(DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    if (nodeAddress != null) {\n      throw new IllegalStateException(\"cannot save an FST pre-packed FST; it must first be packed\");\n    }\n    if (packed && !(nodeRefToAddress instanceof PackedInts.Mutable)) {\n      throw new IllegalStateException(\"cannot save a FST which has been loaded from disk \");\n    }\n    CodecUtil.writeHeader(out, FILE_FORMAT_NAME, VERSION_CURRENT);\n    if (packed) {\n      out.writeByte((byte) 1);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      // Accepts empty string\n      out.writeByte((byte) 1);\n\n      // Serialize empty-string output:\n      RAMOutputStream ros = new RAMOutputStream();\n      outputs.writeFinalOutput(emptyOutput, ros);\n      \n      byte[] emptyOutputBytes = new byte[(int) ros.getFilePointer()];\n      ros.writeTo(emptyOutputBytes, 0);\n\n      if (!packed) {\n        // reverse\n        final int stopAt = emptyOutputBytes.length/2;\n        int upto = 0;\n        while(upto < stopAt) {\n          final byte b = emptyOutputBytes[upto];\n          emptyOutputBytes[upto] = emptyOutputBytes[emptyOutputBytes.length-upto-1];\n          emptyOutputBytes[emptyOutputBytes.length-upto-1] = b;\n          upto++;\n        }\n      }\n      out.writeVInt(emptyOutputBytes.length);\n      out.writeBytes(emptyOutputBytes, 0, emptyOutputBytes.length);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    out.writeByte(t);\n    if (packed) {\n      ((PackedInts.Mutable) nodeRefToAddress).save(out);\n    }\n    out.writeVInt(startNode);\n    out.writeVInt(nodeCount);\n    out.writeVInt(arcCount);\n    out.writeVInt(arcWithOutputCount);\n    int numBytes = bytes.getPosition();\n    out.writeVInt(numBytes);\n    bytes.writeTo(out);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8917bfede3b4ca30f4305c1e391e9218959cd723","date":1358189662,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","sourceNew":"  public void save(DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    if (nodeAddress != null) {\n      throw new IllegalStateException(\"cannot save an FST pre-packed FST; it must first be packed\");\n    }\n    if (packed && !(nodeRefToAddress instanceof PackedInts.Mutable)) {\n      throw new IllegalStateException(\"cannot save a FST which has been loaded from disk \");\n    }\n    CodecUtil.writeHeader(out, FILE_FORMAT_NAME, VERSION_CURRENT);\n    if (packed) {\n      out.writeByte((byte) 1);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      // Accepts empty string\n      out.writeByte((byte) 1);\n\n      // Serialize empty-string output:\n      RAMOutputStream ros = new RAMOutputStream();\n      outputs.writeFinalOutput(emptyOutput, ros);\n      \n      byte[] emptyOutputBytes = new byte[(int) ros.getFilePointer()];\n      ros.writeTo(emptyOutputBytes, 0);\n\n      if (!packed) {\n        // reverse\n        final int stopAt = emptyOutputBytes.length/2;\n        int upto = 0;\n        while(upto < stopAt) {\n          final byte b = emptyOutputBytes[upto];\n          emptyOutputBytes[upto] = emptyOutputBytes[emptyOutputBytes.length-upto-1];\n          emptyOutputBytes[emptyOutputBytes.length-upto-1] = b;\n          upto++;\n        }\n      }\n      out.writeVInt(emptyOutputBytes.length);\n      out.writeBytes(emptyOutputBytes, 0, emptyOutputBytes.length);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    out.writeByte(t);\n    if (packed) {\n      ((PackedInts.Mutable) nodeRefToAddress).save(out);\n    }\n    out.writeVLong(startNode);\n    out.writeVLong(nodeCount);\n    out.writeVLong(arcCount);\n    out.writeVLong(arcWithOutputCount);\n    long numBytes = bytes.getPosition();\n    out.writeVLong(numBytes);\n    bytes.writeTo(out);\n  }\n\n","sourceOld":"  public void save(DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    if (nodeAddress != null) {\n      throw new IllegalStateException(\"cannot save an FST pre-packed FST; it must first be packed\");\n    }\n    if (packed && !(nodeRefToAddress instanceof PackedInts.Mutable)) {\n      throw new IllegalStateException(\"cannot save a FST which has been loaded from disk \");\n    }\n    CodecUtil.writeHeader(out, FILE_FORMAT_NAME, VERSION_CURRENT);\n    if (packed) {\n      out.writeByte((byte) 1);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      // Accepts empty string\n      out.writeByte((byte) 1);\n\n      // Serialize empty-string output:\n      RAMOutputStream ros = new RAMOutputStream();\n      outputs.writeFinalOutput(emptyOutput, ros);\n      \n      byte[] emptyOutputBytes = new byte[(int) ros.getFilePointer()];\n      ros.writeTo(emptyOutputBytes, 0);\n\n      if (!packed) {\n        // reverse\n        final int stopAt = emptyOutputBytes.length/2;\n        int upto = 0;\n        while(upto < stopAt) {\n          final byte b = emptyOutputBytes[upto];\n          emptyOutputBytes[upto] = emptyOutputBytes[emptyOutputBytes.length-upto-1];\n          emptyOutputBytes[emptyOutputBytes.length-upto-1] = b;\n          upto++;\n        }\n      }\n      out.writeVInt(emptyOutputBytes.length);\n      out.writeBytes(emptyOutputBytes, 0, emptyOutputBytes.length);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    out.writeByte(t);\n    if (packed) {\n      ((PackedInts.Mutable) nodeRefToAddress).save(out);\n    }\n    out.writeVInt(startNode);\n    out.writeVInt(nodeCount);\n    out.writeVInt(arcCount);\n    out.writeVInt(arcWithOutputCount);\n    out.writeVInt(bytes.length);\n    out.writeBytes(bytes, 0, bytes.length);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1abb939fb41b2fe4f89fd518f3da288c0213341d","date":1435657417,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","sourceNew":"  public void save(DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    if (nodeAddress != null) {\n      throw new IllegalStateException(\"cannot save an FST pre-packed FST; it must first be packed\");\n    }\n    if (packed && !(nodeRefToAddress instanceof PackedInts.Mutable)) {\n      throw new IllegalStateException(\"cannot save a FST which has been loaded from disk \");\n    }\n    CodecUtil.writeHeader(out, FILE_FORMAT_NAME, VERSION_CURRENT);\n    if (packed) {\n      out.writeByte((byte) 1);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      // Accepts empty string\n      out.writeByte((byte) 1);\n\n      // Serialize empty-string output:\n      RAMOutputStream ros = new RAMOutputStream();\n      outputs.writeFinalOutput(emptyOutput, ros);\n      \n      byte[] emptyOutputBytes = new byte[(int) ros.getFilePointer()];\n      ros.writeTo(emptyOutputBytes, 0);\n\n      if (!packed) {\n        // reverse\n        final int stopAt = emptyOutputBytes.length/2;\n        int upto = 0;\n        while(upto < stopAt) {\n          final byte b = emptyOutputBytes[upto];\n          emptyOutputBytes[upto] = emptyOutputBytes[emptyOutputBytes.length-upto-1];\n          emptyOutputBytes[emptyOutputBytes.length-upto-1] = b;\n          upto++;\n        }\n      }\n      out.writeVInt(emptyOutputBytes.length);\n      out.writeBytes(emptyOutputBytes, 0, emptyOutputBytes.length);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    out.writeByte(t);\n    if (packed) {\n      ((PackedInts.Mutable) nodeRefToAddress).save(out);\n    }\n    out.writeVLong(startNode);\n    if (bytes != null) {\n      long numBytes = bytes.getPosition();\n      out.writeVLong(numBytes);\n      bytes.writeTo(out);\n    } else {\n      assert bytesArray != null;\n      out.writeVLong(bytesArray.length);\n      out.writeBytes(bytesArray, 0, bytesArray.length);\n    }\n  }\n\n","sourceOld":"  public void save(DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    if (nodeAddress != null) {\n      throw new IllegalStateException(\"cannot save an FST pre-packed FST; it must first be packed\");\n    }\n    if (packed && !(nodeRefToAddress instanceof PackedInts.Mutable)) {\n      throw new IllegalStateException(\"cannot save a FST which has been loaded from disk \");\n    }\n    CodecUtil.writeHeader(out, FILE_FORMAT_NAME, VERSION_CURRENT);\n    if (packed) {\n      out.writeByte((byte) 1);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      // Accepts empty string\n      out.writeByte((byte) 1);\n\n      // Serialize empty-string output:\n      RAMOutputStream ros = new RAMOutputStream();\n      outputs.writeFinalOutput(emptyOutput, ros);\n      \n      byte[] emptyOutputBytes = new byte[(int) ros.getFilePointer()];\n      ros.writeTo(emptyOutputBytes, 0);\n\n      if (!packed) {\n        // reverse\n        final int stopAt = emptyOutputBytes.length/2;\n        int upto = 0;\n        while(upto < stopAt) {\n          final byte b = emptyOutputBytes[upto];\n          emptyOutputBytes[upto] = emptyOutputBytes[emptyOutputBytes.length-upto-1];\n          emptyOutputBytes[emptyOutputBytes.length-upto-1] = b;\n          upto++;\n        }\n      }\n      out.writeVInt(emptyOutputBytes.length);\n      out.writeBytes(emptyOutputBytes, 0, emptyOutputBytes.length);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    out.writeByte(t);\n    if (packed) {\n      ((PackedInts.Mutable) nodeRefToAddress).save(out);\n    }\n    out.writeVLong(startNode);\n    out.writeVLong(nodeCount);\n    out.writeVLong(arcCount);\n    out.writeVLong(arcWithOutputCount);\n    long numBytes = bytes.getPosition();\n    out.writeVLong(numBytes);\n    bytes.writeTo(out);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6244579a467d5f2673ac98265d74bddbea1a8114","date":1478786509,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","sourceNew":"  public void save(DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    CodecUtil.writeHeader(out, FILE_FORMAT_NAME, VERSION_CURRENT);\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      // Accepts empty string\n      out.writeByte((byte) 1);\n\n      // Serialize empty-string output:\n      RAMOutputStream ros = new RAMOutputStream();\n      outputs.writeFinalOutput(emptyOutput, ros);\n      \n      byte[] emptyOutputBytes = new byte[(int) ros.getFilePointer()];\n      ros.writeTo(emptyOutputBytes, 0);\n\n      // reverse\n      final int stopAt = emptyOutputBytes.length/2;\n      int upto = 0;\n      while(upto < stopAt) {\n        final byte b = emptyOutputBytes[upto];\n        emptyOutputBytes[upto] = emptyOutputBytes[emptyOutputBytes.length-upto-1];\n        emptyOutputBytes[emptyOutputBytes.length-upto-1] = b;\n        upto++;\n      }\n      out.writeVInt(emptyOutputBytes.length);\n      out.writeBytes(emptyOutputBytes, 0, emptyOutputBytes.length);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    out.writeByte(t);\n    out.writeVLong(startNode);\n    if (bytes != null) {\n      long numBytes = bytes.getPosition();\n      out.writeVLong(numBytes);\n      bytes.writeTo(out);\n    } else {\n      assert bytesArray != null;\n      out.writeVLong(bytesArray.length);\n      out.writeBytes(bytesArray, 0, bytesArray.length);\n    }\n  }\n\n","sourceOld":"  public void save(DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    if (nodeAddress != null) {\n      throw new IllegalStateException(\"cannot save an FST pre-packed FST; it must first be packed\");\n    }\n    if (packed && !(nodeRefToAddress instanceof PackedInts.Mutable)) {\n      throw new IllegalStateException(\"cannot save a FST which has been loaded from disk \");\n    }\n    CodecUtil.writeHeader(out, FILE_FORMAT_NAME, VERSION_CURRENT);\n    if (packed) {\n      out.writeByte((byte) 1);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      // Accepts empty string\n      out.writeByte((byte) 1);\n\n      // Serialize empty-string output:\n      RAMOutputStream ros = new RAMOutputStream();\n      outputs.writeFinalOutput(emptyOutput, ros);\n      \n      byte[] emptyOutputBytes = new byte[(int) ros.getFilePointer()];\n      ros.writeTo(emptyOutputBytes, 0);\n\n      if (!packed) {\n        // reverse\n        final int stopAt = emptyOutputBytes.length/2;\n        int upto = 0;\n        while(upto < stopAt) {\n          final byte b = emptyOutputBytes[upto];\n          emptyOutputBytes[upto] = emptyOutputBytes[emptyOutputBytes.length-upto-1];\n          emptyOutputBytes[emptyOutputBytes.length-upto-1] = b;\n          upto++;\n        }\n      }\n      out.writeVInt(emptyOutputBytes.length);\n      out.writeBytes(emptyOutputBytes, 0, emptyOutputBytes.length);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    out.writeByte(t);\n    if (packed) {\n      ((PackedInts.Mutable) nodeRefToAddress).save(out);\n    }\n    out.writeVLong(startNode);\n    if (bytes != null) {\n      long numBytes = bytes.getPosition();\n      out.writeVLong(numBytes);\n      bytes.writeTo(out);\n    } else {\n      assert bytesArray != null;\n      out.writeVLong(bytesArray.length);\n      out.writeBytes(bytesArray, 0, bytesArray.length);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"199dfa410f1fdbfd3294106b04096cce5ed34b21","date":1478812506,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","sourceNew":"  public void save(DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    CodecUtil.writeHeader(out, FILE_FORMAT_NAME, VERSION_CURRENT);\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      // Accepts empty string\n      out.writeByte((byte) 1);\n\n      // Serialize empty-string output:\n      RAMOutputStream ros = new RAMOutputStream();\n      outputs.writeFinalOutput(emptyOutput, ros);\n      \n      byte[] emptyOutputBytes = new byte[(int) ros.getFilePointer()];\n      ros.writeTo(emptyOutputBytes, 0);\n\n      // reverse\n      final int stopAt = emptyOutputBytes.length/2;\n      int upto = 0;\n      while(upto < stopAt) {\n        final byte b = emptyOutputBytes[upto];\n        emptyOutputBytes[upto] = emptyOutputBytes[emptyOutputBytes.length-upto-1];\n        emptyOutputBytes[emptyOutputBytes.length-upto-1] = b;\n        upto++;\n      }\n      out.writeVInt(emptyOutputBytes.length);\n      out.writeBytes(emptyOutputBytes, 0, emptyOutputBytes.length);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    out.writeByte(t);\n    out.writeVLong(startNode);\n    if (bytes != null) {\n      long numBytes = bytes.getPosition();\n      out.writeVLong(numBytes);\n      bytes.writeTo(out);\n    } else {\n      assert bytesArray != null;\n      out.writeVLong(bytesArray.length);\n      out.writeBytes(bytesArray, 0, bytesArray.length);\n    }\n  }\n\n","sourceOld":"  public void save(DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    if (nodeAddress != null) {\n      throw new IllegalStateException(\"cannot save an FST pre-packed FST; it must first be packed\");\n    }\n    if (packed && !(nodeRefToAddress instanceof PackedInts.Mutable)) {\n      throw new IllegalStateException(\"cannot save a FST which has been loaded from disk \");\n    }\n    CodecUtil.writeHeader(out, FILE_FORMAT_NAME, VERSION_CURRENT);\n    if (packed) {\n      out.writeByte((byte) 1);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      // Accepts empty string\n      out.writeByte((byte) 1);\n\n      // Serialize empty-string output:\n      RAMOutputStream ros = new RAMOutputStream();\n      outputs.writeFinalOutput(emptyOutput, ros);\n      \n      byte[] emptyOutputBytes = new byte[(int) ros.getFilePointer()];\n      ros.writeTo(emptyOutputBytes, 0);\n\n      if (!packed) {\n        // reverse\n        final int stopAt = emptyOutputBytes.length/2;\n        int upto = 0;\n        while(upto < stopAt) {\n          final byte b = emptyOutputBytes[upto];\n          emptyOutputBytes[upto] = emptyOutputBytes[emptyOutputBytes.length-upto-1];\n          emptyOutputBytes[emptyOutputBytes.length-upto-1] = b;\n          upto++;\n        }\n      }\n      out.writeVInt(emptyOutputBytes.length);\n      out.writeBytes(emptyOutputBytes, 0, emptyOutputBytes.length);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    out.writeByte(t);\n    if (packed) {\n      ((PackedInts.Mutable) nodeRefToAddress).save(out);\n    }\n    out.writeVLong(startNode);\n    if (bytes != null) {\n      long numBytes = bytes.getPosition();\n      out.writeVLong(numBytes);\n      bytes.writeTo(out);\n    } else {\n      assert bytesArray != null;\n      out.writeVLong(bytesArray.length);\n      out.writeBytes(bytesArray, 0, bytesArray.length);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"409da428f28953cf35fddd5c9ff5c7e4f5439863","date":1547556145,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","sourceNew":"  public void save(DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    CodecUtil.writeHeader(out, FILE_FORMAT_NAME, VERSION_CURRENT);\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      // Accepts empty string\n      out.writeByte((byte) 1);\n\n      // Serialize empty-string output:\n      ByteBuffersDataOutput ros = new ByteBuffersDataOutput();\n      outputs.writeFinalOutput(emptyOutput, ros);\n      byte[] emptyOutputBytes = ros.toArrayCopy();\n\n      // reverse\n      final int stopAt = emptyOutputBytes.length/2;\n      int upto = 0;\n      while (upto < stopAt) {\n        final byte b = emptyOutputBytes[upto];\n        emptyOutputBytes[upto] = emptyOutputBytes[emptyOutputBytes.length-upto-1];\n        emptyOutputBytes[emptyOutputBytes.length-upto-1] = b;\n        upto++;\n      }\n      out.writeVInt(emptyOutputBytes.length);\n      out.writeBytes(emptyOutputBytes, 0, emptyOutputBytes.length);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    out.writeByte(t);\n    out.writeVLong(startNode);\n    if (bytes != null) {\n      long numBytes = bytes.getPosition();\n      out.writeVLong(numBytes);\n      bytes.writeTo(out);\n    } else {\n      assert bytesArray != null;\n      out.writeVLong(bytesArray.length);\n      out.writeBytes(bytesArray, 0, bytesArray.length);\n    }\n  }\n\n","sourceOld":"  public void save(DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    CodecUtil.writeHeader(out, FILE_FORMAT_NAME, VERSION_CURRENT);\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      // Accepts empty string\n      out.writeByte((byte) 1);\n\n      // Serialize empty-string output:\n      RAMOutputStream ros = new RAMOutputStream();\n      outputs.writeFinalOutput(emptyOutput, ros);\n      \n      byte[] emptyOutputBytes = new byte[(int) ros.getFilePointer()];\n      ros.writeTo(emptyOutputBytes, 0);\n\n      // reverse\n      final int stopAt = emptyOutputBytes.length/2;\n      int upto = 0;\n      while(upto < stopAt) {\n        final byte b = emptyOutputBytes[upto];\n        emptyOutputBytes[upto] = emptyOutputBytes[emptyOutputBytes.length-upto-1];\n        emptyOutputBytes[emptyOutputBytes.length-upto-1] = b;\n        upto++;\n      }\n      out.writeVInt(emptyOutputBytes.length);\n      out.writeBytes(emptyOutputBytes, 0, emptyOutputBytes.length);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    out.writeByte(t);\n    out.writeVLong(startNode);\n    if (bytes != null) {\n      long numBytes = bytes.getPosition();\n      out.writeVLong(numBytes);\n      bytes.writeTo(out);\n    } else {\n      assert bytesArray != null;\n      out.writeVLong(bytesArray.length);\n      out.writeBytes(bytesArray, 0, bytesArray.length);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dcc12263939c1d6c4b4a2015f67d1b6d97f375a4","date":1550598742,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","sourceNew":"  public void save(DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    CodecUtil.writeHeader(out, FILE_FORMAT_NAME, VERSION_CURRENT);\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      // Accepts empty string\n      out.writeByte((byte) 1);\n\n      // Serialize empty-string output:\n      ByteBuffersDataOutput ros = new ByteBuffersDataOutput();\n      outputs.writeFinalOutput(emptyOutput, ros);\n      byte[] emptyOutputBytes = ros.toArrayCopy();\n\n      // reverse\n      final int stopAt = emptyOutputBytes.length/2;\n      int upto = 0;\n      while (upto < stopAt) {\n        final byte b = emptyOutputBytes[upto];\n        emptyOutputBytes[upto] = emptyOutputBytes[emptyOutputBytes.length-upto-1];\n        emptyOutputBytes[emptyOutputBytes.length-upto-1] = b;\n        upto++;\n      }\n      out.writeVInt(emptyOutputBytes.length);\n      out.writeBytes(emptyOutputBytes, 0, emptyOutputBytes.length);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    out.writeByte(t);\n    out.writeVLong(startNode);\n    if (bytes != null) {\n      long numBytes = bytes.getPosition();\n      out.writeVLong(numBytes);\n      bytes.writeTo(out);\n    } else {\n      assert fstStore != null;\n      fstStore.writeTo(out);\n    }\n  }\n\n","sourceOld":"  public void save(DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    CodecUtil.writeHeader(out, FILE_FORMAT_NAME, VERSION_CURRENT);\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      // Accepts empty string\n      out.writeByte((byte) 1);\n\n      // Serialize empty-string output:\n      ByteBuffersDataOutput ros = new ByteBuffersDataOutput();\n      outputs.writeFinalOutput(emptyOutput, ros);\n      byte[] emptyOutputBytes = ros.toArrayCopy();\n\n      // reverse\n      final int stopAt = emptyOutputBytes.length/2;\n      int upto = 0;\n      while (upto < stopAt) {\n        final byte b = emptyOutputBytes[upto];\n        emptyOutputBytes[upto] = emptyOutputBytes[emptyOutputBytes.length-upto-1];\n        emptyOutputBytes[emptyOutputBytes.length-upto-1] = b;\n        upto++;\n      }\n      out.writeVInt(emptyOutputBytes.length);\n      out.writeBytes(emptyOutputBytes, 0, emptyOutputBytes.length);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    out.writeByte(t);\n    out.writeVLong(startNode);\n    if (bytes != null) {\n      long numBytes = bytes.getPosition();\n      out.writeVLong(numBytes);\n      bytes.writeTo(out);\n    } else {\n      assert bytesArray != null;\n      out.writeVLong(bytesArray.length);\n      out.writeBytes(bytesArray, 0, bytesArray.length);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54204c8a3ca26aeafd273139fc29baf70d0f6786","date":1564170395,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","sourceNew":"  public void save(DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    CodecUtil.writeHeader(out, FILE_FORMAT_NAME, VERSION_CURRENT);\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      // Accepts empty string\n      out.writeByte((byte) 1);\n\n      // Serialize empty-string output:\n      ByteBuffersDataOutput ros = new ByteBuffersDataOutput();\n      outputs.writeFinalOutput(emptyOutput, ros);\n      byte[] emptyOutputBytes = ros.toArrayCopy();\n      int emptyLen = emptyOutputBytes.length;\n\n      // reverse\n      final int stopAt = emptyLen / 2;\n      int upto = 0;\n      while (upto < stopAt) {\n        final byte b = emptyOutputBytes[upto];\n        emptyOutputBytes[upto] = emptyOutputBytes[emptyLen - upto - 1];\n        emptyOutputBytes[emptyLen - upto - 1] = b;\n        upto++;\n      }\n      out.writeVInt(emptyLen);\n      out.writeBytes(emptyOutputBytes, 0, emptyLen);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    out.writeByte(t);\n    out.writeVLong(startNode);\n    if (bytes != null) {\n      long numBytes = bytes.getPosition();\n      out.writeVLong(numBytes);\n      bytes.writeTo(out);\n    } else {\n      assert fstStore != null;\n      fstStore.writeTo(out);\n    }\n  }\n\n","sourceOld":"  public void save(DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    CodecUtil.writeHeader(out, FILE_FORMAT_NAME, VERSION_CURRENT);\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      // Accepts empty string\n      out.writeByte((byte) 1);\n\n      // Serialize empty-string output:\n      ByteBuffersDataOutput ros = new ByteBuffersDataOutput();\n      outputs.writeFinalOutput(emptyOutput, ros);\n      byte[] emptyOutputBytes = ros.toArrayCopy();\n\n      // reverse\n      final int stopAt = emptyOutputBytes.length/2;\n      int upto = 0;\n      while (upto < stopAt) {\n        final byte b = emptyOutputBytes[upto];\n        emptyOutputBytes[upto] = emptyOutputBytes[emptyOutputBytes.length-upto-1];\n        emptyOutputBytes[emptyOutputBytes.length-upto-1] = b;\n        upto++;\n      }\n      out.writeVInt(emptyOutputBytes.length);\n      out.writeBytes(emptyOutputBytes, 0, emptyOutputBytes.length);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    out.writeByte(t);\n    out.writeVLong(startNode);\n    if (bytes != null) {\n      long numBytes = bytes.getPosition();\n      out.writeVLong(numBytes);\n      bytes.writeTo(out);\n    } else {\n      assert fstStore != null;\n      fstStore.writeTo(out);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8061ddd97f3352007d927dae445884a6f3d857b","date":1564988276,"type":3,"author":"Atri Sharma","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","sourceNew":"  public void save(DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    CodecUtil.writeHeader(out, FILE_FORMAT_NAME, VERSION_CURRENT);\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      // Accepts empty string\n      out.writeByte((byte) 1);\n\n      // Serialize empty-string output:\n      ByteBuffersDataOutput ros = new ByteBuffersDataOutput();\n      outputs.writeFinalOutput(emptyOutput, ros);\n      byte[] emptyOutputBytes = ros.toArrayCopy();\n      int emptyLen = emptyOutputBytes.length;\n\n      // reverse\n      final int stopAt = emptyLen / 2;\n      int upto = 0;\n      while (upto < stopAt) {\n        final byte b = emptyOutputBytes[upto];\n        emptyOutputBytes[upto] = emptyOutputBytes[emptyLen - upto - 1];\n        emptyOutputBytes[emptyLen - upto - 1] = b;\n        upto++;\n      }\n      out.writeVInt(emptyLen);\n      out.writeBytes(emptyOutputBytes, 0, emptyLen);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    out.writeByte(t);\n    out.writeVLong(startNode);\n    if (bytes != null) {\n      long numBytes = bytes.getPosition();\n      out.writeVLong(numBytes);\n      bytes.writeTo(out);\n    } else {\n      assert fstStore != null;\n      fstStore.writeTo(out);\n    }\n  }\n\n","sourceOld":"  public void save(DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    CodecUtil.writeHeader(out, FILE_FORMAT_NAME, VERSION_CURRENT);\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      // Accepts empty string\n      out.writeByte((byte) 1);\n\n      // Serialize empty-string output:\n      ByteBuffersDataOutput ros = new ByteBuffersDataOutput();\n      outputs.writeFinalOutput(emptyOutput, ros);\n      byte[] emptyOutputBytes = ros.toArrayCopy();\n\n      // reverse\n      final int stopAt = emptyOutputBytes.length/2;\n      int upto = 0;\n      while (upto < stopAt) {\n        final byte b = emptyOutputBytes[upto];\n        emptyOutputBytes[upto] = emptyOutputBytes[emptyOutputBytes.length-upto-1];\n        emptyOutputBytes[emptyOutputBytes.length-upto-1] = b;\n        upto++;\n      }\n      out.writeVInt(emptyOutputBytes.length);\n      out.writeBytes(emptyOutputBytes, 0, emptyOutputBytes.length);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    out.writeByte(t);\n    out.writeVLong(startNode);\n    if (bytes != null) {\n      long numBytes = bytes.getPosition();\n      out.writeVLong(numBytes);\n      bytes.writeTo(out);\n    } else {\n      assert fstStore != null;\n      fstStore.writeTo(out);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"99f06f5dd087b1829e7b4139e4d014c786b92572","date":1592312728,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput,DataOutput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#save(DataOutput).mjava","sourceNew":"  public void save(DataOutput metaOut, DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    CodecUtil.writeHeader(metaOut, FILE_FORMAT_NAME, VERSION_CURRENT);\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      // Accepts empty string\n      metaOut.writeByte((byte) 1);\n\n      // Serialize empty-string output:\n      ByteBuffersDataOutput ros = new ByteBuffersDataOutput();\n      outputs.writeFinalOutput(emptyOutput, ros);\n      byte[] emptyOutputBytes = ros.toArrayCopy();\n      int emptyLen = emptyOutputBytes.length;\n\n      // reverse\n      final int stopAt = emptyLen / 2;\n      int upto = 0;\n      while (upto < stopAt) {\n        final byte b = emptyOutputBytes[upto];\n        emptyOutputBytes[upto] = emptyOutputBytes[emptyLen - upto - 1];\n        emptyOutputBytes[emptyLen - upto - 1] = b;\n        upto++;\n      }\n      metaOut.writeVInt(emptyLen);\n      metaOut.writeBytes(emptyOutputBytes, 0, emptyLen);\n    } else {\n      metaOut.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    metaOut.writeByte(t);\n    metaOut.writeVLong(startNode);\n    if (bytes != null) {\n      long numBytes = bytes.getPosition();\n      metaOut.writeVLong(numBytes);\n      bytes.writeTo(out);\n    } else {\n      assert fstStore != null;\n      fstStore.writeTo(out);\n    }\n  }\n\n","sourceOld":"  public void save(DataOutput out) throws IOException {\n    if (startNode == -1) {\n      throw new IllegalStateException(\"call finish first\");\n    }\n    CodecUtil.writeHeader(out, FILE_FORMAT_NAME, VERSION_CURRENT);\n    // TODO: really we should encode this as an arc, arriving\n    // to the root node, instead of special casing here:\n    if (emptyOutput != null) {\n      // Accepts empty string\n      out.writeByte((byte) 1);\n\n      // Serialize empty-string output:\n      ByteBuffersDataOutput ros = new ByteBuffersDataOutput();\n      outputs.writeFinalOutput(emptyOutput, ros);\n      byte[] emptyOutputBytes = ros.toArrayCopy();\n      int emptyLen = emptyOutputBytes.length;\n\n      // reverse\n      final int stopAt = emptyLen / 2;\n      int upto = 0;\n      while (upto < stopAt) {\n        final byte b = emptyOutputBytes[upto];\n        emptyOutputBytes[upto] = emptyOutputBytes[emptyLen - upto - 1];\n        emptyOutputBytes[emptyLen - upto - 1] = b;\n        upto++;\n      }\n      out.writeVInt(emptyLen);\n      out.writeBytes(emptyOutputBytes, 0, emptyLen);\n    } else {\n      out.writeByte((byte) 0);\n    }\n    final byte t;\n    if (inputType == INPUT_TYPE.BYTE1) {\n      t = 0;\n    } else if (inputType == INPUT_TYPE.BYTE2) {\n      t = 1;\n    } else {\n      t = 2;\n    }\n    out.writeByte(t);\n    out.writeVLong(startNode);\n    if (bytes != null) {\n      long numBytes = bytes.getPosition();\n      out.writeVLong(numBytes);\n      bytes.writeTo(out);\n    } else {\n      assert fstStore != null;\n      fstStore.writeTo(out);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1abb939fb41b2fe4f89fd518f3da288c0213341d":["d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0":["87e78f3c129251e74ecc2ff73a32de0f27cf09d5"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8917bfede3b4ca30f4305c1e391e9218959cd723":["4e6354dd7c71fe122926fc53d7d29f715b1283db","d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"99f06f5dd087b1829e7b4139e4d014c786b92572":["54204c8a3ca26aeafd273139fc29baf70d0f6786"],"6244579a467d5f2673ac98265d74bddbea1a8114":["1abb939fb41b2fe4f89fd518f3da288c0213341d"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":["1abb939fb41b2fe4f89fd518f3da288c0213341d","6244579a467d5f2673ac98265d74bddbea1a8114"],"09827d0d9c0291b55c1258295b29a4fe7f0a1f40":["edb74c83fff94196b864e08ca033d92823252cb7"],"87e78f3c129251e74ecc2ff73a32de0f27cf09d5":["ef0933b174e58bde65fb3876acbf28647656b925"],"f8061ddd97f3352007d927dae445884a6f3d857b":["dcc12263939c1d6c4b4a2015f67d1b6d97f375a4","54204c8a3ca26aeafd273139fc29baf70d0f6786"],"dcc12263939c1d6c4b4a2015f67d1b6d97f375a4":["409da428f28953cf35fddd5c9ff5c7e4f5439863"],"54204c8a3ca26aeafd273139fc29baf70d0f6786":["dcc12263939c1d6c4b4a2015f67d1b6d97f375a4"],"409da428f28953cf35fddd5c9ff5c7e4f5439863":["6244579a467d5f2673ac98265d74bddbea1a8114"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ef0933b174e58bde65fb3876acbf28647656b925":["09827d0d9c0291b55c1258295b29a4fe7f0a1f40"],"edb74c83fff94196b864e08ca033d92823252cb7":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"4e6354dd7c71fe122926fc53d7d29f715b1283db":["edb74c83fff94196b864e08ca033d92823252cb7","ef0933b174e58bde65fb3876acbf28647656b925"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["99f06f5dd087b1829e7b4139e4d014c786b92572"]},"commit2Childs":{"1abb939fb41b2fe4f89fd518f3da288c0213341d":["6244579a467d5f2673ac98265d74bddbea1a8114","199dfa410f1fdbfd3294106b04096cce5ed34b21"],"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0":["1abb939fb41b2fe4f89fd518f3da288c0213341d","8917bfede3b4ca30f4305c1e391e9218959cd723"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["edb74c83fff94196b864e08ca033d92823252cb7"],"8917bfede3b4ca30f4305c1e391e9218959cd723":[],"99f06f5dd087b1829e7b4139e4d014c786b92572":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6244579a467d5f2673ac98265d74bddbea1a8114":["199dfa410f1fdbfd3294106b04096cce5ed34b21","409da428f28953cf35fddd5c9ff5c7e4f5439863"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":[],"09827d0d9c0291b55c1258295b29a4fe7f0a1f40":["ef0933b174e58bde65fb3876acbf28647656b925"],"87e78f3c129251e74ecc2ff73a32de0f27cf09d5":["d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"f8061ddd97f3352007d927dae445884a6f3d857b":[],"dcc12263939c1d6c4b4a2015f67d1b6d97f375a4":["f8061ddd97f3352007d927dae445884a6f3d857b","54204c8a3ca26aeafd273139fc29baf70d0f6786"],"54204c8a3ca26aeafd273139fc29baf70d0f6786":["99f06f5dd087b1829e7b4139e4d014c786b92572","f8061ddd97f3352007d927dae445884a6f3d857b"],"409da428f28953cf35fddd5c9ff5c7e4f5439863":["dcc12263939c1d6c4b4a2015f67d1b6d97f375a4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"ef0933b174e58bde65fb3876acbf28647656b925":["87e78f3c129251e74ecc2ff73a32de0f27cf09d5","4e6354dd7c71fe122926fc53d7d29f715b1283db"],"edb74c83fff94196b864e08ca033d92823252cb7":["09827d0d9c0291b55c1258295b29a4fe7f0a1f40","4e6354dd7c71fe122926fc53d7d29f715b1283db"],"4e6354dd7c71fe122926fc53d7d29f715b1283db":["8917bfede3b4ca30f4305c1e391e9218959cd723"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8917bfede3b4ca30f4305c1e391e9218959cd723","199dfa410f1fdbfd3294106b04096cce5ed34b21","f8061ddd97f3352007d927dae445884a6f3d857b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}