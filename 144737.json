{"path":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#PrimaryNode(IndexWriter,int,long,long,SearcherFactory,PrintStream).mjava","commits":[{"id":"2b844e2ae5435a8d4d925003c10027c25e26e02d","date":1455044345,"type":1,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#PrimaryNode(IndexWriter,int,long,long,SearcherFactory,PrintStream).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#PrimaryNode(IndexWriter,int,long,long,SearcherFactory).mjava","sourceNew":"  public PrimaryNode(IndexWriter writer, int id, long primaryGen, long forcePrimaryVersion,\n                     SearcherFactory searcherFactory, PrintStream printStream) throws IOException {\n    super(id, writer.getDirectory(), searcherFactory, printStream);\n    message(\"top: now init primary\");\n    this.writer = writer;\n    this.primaryGen = primaryGen;\n\n    try {\n      // So that when primary node's IndexWriter finishes a merge, but before it cuts over to the merged segment,\n      // it copies it out to the replicas.  This ensures the whole system's NRT latency remains low even when a\n      // large merge completes:\n      writer.getConfig().setMergedSegmentWarmer(new PreCopyMergedSegmentWarmer(this));\n\n      message(\"IWC:\\n\" + writer.getConfig());\n      message(\"dir:\\n\" + writer.getDirectory());\n      message(\"commitData: \" + writer.getCommitData());\n\n      // Record our primaryGen in the userData, and set initial version to 0:\n      Map<String,String> commitData = new HashMap<>(writer.getCommitData());\n      commitData.put(PRIMARY_GEN_KEY, Long.toString(primaryGen));\n      if (commitData.get(VERSION_KEY) == null) {\n        commitData.put(VERSION_KEY, \"0\");\n        message(\"add initial commitData version=0\");\n      } else {\n        message(\"keep current commitData version=\" + commitData.get(VERSION_KEY));\n      }\n      writer.setCommitData(commitData, false);\n\n      // We forcefully advance the SIS version to an unused future version.  This is necessary if the previous primary crashed and we are\n      // starting up on an \"older\" index, else versions can be illegally reused but show different results:\n      if (forcePrimaryVersion != -1) {\n        message(\"now forcePrimaryVersion to version=\" + forcePrimaryVersion);\n        writer.advanceSegmentInfosVersion(forcePrimaryVersion);\n      }\n\n      mgr = new SearcherManager(writer, true, true, searcherFactory);\n      setCurrentInfos(Collections.<String>emptySet());\n      message(\"init: infos version=\" + curInfos.getVersion());\n\n      IndexSearcher s = mgr.acquire();\n      try {\n        // TODO: this is test code specific!!\n        message(\"init: marker count: \" + s.count(new TermQuery(new Term(\"marker\", \"marker\"))));\n      } finally {\n        mgr.release(s);\n      }\n\n    } catch (Throwable t) {\n      message(\"init: exception\");\n      t.printStackTrace(printStream);\n      throw new RuntimeException(t);\n    }\n  }\n\n","sourceOld":"  public PrimaryNode(IndexWriter writer, int id, long primaryGen, long forcePrimaryVersion, SearcherFactory searcherFactory) throws IOException {\n    super(id, writer.getDirectory(), searcherFactory);\n    message(\"top: now init primary\");\n    this.writer = writer;\n    this.primaryGen = primaryGen;\n\n    try {\n      // So that when primary node's IndexWriter finishes a merge, but before it cuts over to the merged segment,\n      // it copies it out to the replicas.  This ensures the whole system's NRT latency remains low even when a\n      // large merge completes:\n      writer.getConfig().setMergedSegmentWarmer(new PreCopyMergedSegmentWarmer(this));\n\n      message(\"IWC:\\n\" + writer.getConfig());\n      message(\"dir:\\n\" + writer.getDirectory());\n      message(\"commitData: \" + writer.getCommitData());\n\n      // Record our primaryGen in the userData, and set initial version to 0:\n      Map<String,String> commitData = new HashMap<>(writer.getCommitData());\n      commitData.put(PRIMARY_GEN_KEY, Long.toString(primaryGen));\n      if (commitData.get(VERSION_KEY) == null) {\n        commitData.put(VERSION_KEY, \"0\");\n        message(\"add initial commitData version=0\");\n      } else {\n        message(\"keep current commitData version=\" + commitData.get(VERSION_KEY));\n      }\n      writer.setCommitData(commitData, false);\n\n      // We forcefully advance the SIS version to an unused future version.  This is necessary if the previous primary crashed and we are\n      // starting up on an \"older\" index, else versions can be illegally reused but show different results:\n      if (forcePrimaryVersion != -1) {\n        message(\"now forcePrimaryVersion to version=\" + forcePrimaryVersion);\n        writer.advanceSegmentInfosVersion(forcePrimaryVersion);\n      }\n\n      mgr = new SearcherManager(writer, true, true, searcherFactory);\n      setCurrentInfos(Collections.<String>emptySet());\n      message(\"init: infos version=\" + curInfos.getVersion());\n\n      IndexSearcher s = mgr.acquire();\n      try {\n        // TODO: this is test code specific!!\n        message(\"init: marker count: \" + s.count(new TermQuery(new Term(\"marker\", \"marker\"))));\n      } finally {\n        mgr.release(s);\n      }\n\n    } catch (Throwable t) {\n      message(\"init: exception\");\n      t.printStackTrace(System.out);\n      throw new RuntimeException(t);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#PrimaryNode(IndexWriter,int,long,long,SearcherFactory,PrintStream).mjava","pathOld":"/dev/null","sourceNew":"  public PrimaryNode(IndexWriter writer, int id, long primaryGen, long forcePrimaryVersion,\n                     SearcherFactory searcherFactory, PrintStream printStream) throws IOException {\n    super(id, writer.getDirectory(), searcherFactory, printStream);\n    message(\"top: now init primary\");\n    this.writer = writer;\n    this.primaryGen = primaryGen;\n\n    try {\n      // So that when primary node's IndexWriter finishes a merge, but before it cuts over to the merged segment,\n      // it copies it out to the replicas.  This ensures the whole system's NRT latency remains low even when a\n      // large merge completes:\n      writer.getConfig().setMergedSegmentWarmer(new PreCopyMergedSegmentWarmer(this));\n\n      message(\"IWC:\\n\" + writer.getConfig());\n      message(\"dir:\\n\" + writer.getDirectory());\n      message(\"commitData: \" + writer.getCommitData());\n\n      // Record our primaryGen in the userData, and set initial version to 0:\n      Map<String,String> commitData = new HashMap<>(writer.getCommitData());\n      commitData.put(PRIMARY_GEN_KEY, Long.toString(primaryGen));\n      if (commitData.get(VERSION_KEY) == null) {\n        commitData.put(VERSION_KEY, \"0\");\n        message(\"add initial commitData version=0\");\n      } else {\n        message(\"keep current commitData version=\" + commitData.get(VERSION_KEY));\n      }\n      writer.setCommitData(commitData, false);\n\n      // We forcefully advance the SIS version to an unused future version.  This is necessary if the previous primary crashed and we are\n      // starting up on an \"older\" index, else versions can be illegally reused but show different results:\n      if (forcePrimaryVersion != -1) {\n        message(\"now forcePrimaryVersion to version=\" + forcePrimaryVersion);\n        writer.advanceSegmentInfosVersion(forcePrimaryVersion);\n      }\n\n      mgr = new SearcherManager(writer, true, true, searcherFactory);\n      setCurrentInfos(Collections.<String>emptySet());\n      message(\"init: infos version=\" + curInfos.getVersion());\n\n      IndexSearcher s = mgr.acquire();\n      try {\n        // TODO: this is test code specific!!\n        message(\"init: marker count: \" + s.count(new TermQuery(new Term(\"marker\", \"marker\"))));\n      } finally {\n        mgr.release(s);\n      }\n\n    } catch (Throwable t) {\n      message(\"init: exception\");\n      t.printStackTrace(printStream);\n      throw new RuntimeException(t);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"71e1a70f18d64b93db3ef618e606d6df5062f747","date":1466156390,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#PrimaryNode(IndexWriter,int,long,long,SearcherFactory,PrintStream).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#PrimaryNode(IndexWriter,int,long,long,SearcherFactory,PrintStream).mjava","sourceNew":"  public PrimaryNode(IndexWriter writer, int id, long primaryGen, long forcePrimaryVersion,\n                     SearcherFactory searcherFactory, PrintStream printStream) throws IOException {\n    super(id, writer.getDirectory(), searcherFactory, printStream);\n    message(\"top: now init primary\");\n    this.writer = writer;\n    this.primaryGen = primaryGen;\n\n    try {\n      // So that when primary node's IndexWriter finishes a merge, but before it cuts over to the merged segment,\n      // it copies it out to the replicas.  This ensures the whole system's NRT latency remains low even when a\n      // large merge completes:\n      writer.getConfig().setMergedSegmentWarmer(new PreCopyMergedSegmentWarmer(this));\n\n      message(\"IWC:\\n\" + writer.getConfig());\n      message(\"dir:\\n\" + writer.getDirectory());\n      message(\"commitData: \" + writer.getLiveCommitData());\n\n      // Record our primaryGen in the userData, and set initial version to 0:\n      Map<String,String> commitData = new HashMap<>();\n      Iterable<Map.Entry<String,String>> iter = writer.getLiveCommitData();\n      if (iter != null) {\n        for(Map.Entry<String,String> ent : iter) {\n          commitData.put(ent.getKey(), ent.getValue());\n        }\n      }\n      commitData.put(PRIMARY_GEN_KEY, Long.toString(primaryGen));\n      if (commitData.get(VERSION_KEY) == null) {\n        commitData.put(VERSION_KEY, \"0\");\n        message(\"add initial commitData version=0\");\n      } else {\n        message(\"keep current commitData version=\" + commitData.get(VERSION_KEY));\n      }\n      writer.setLiveCommitData(commitData.entrySet(), false);\n\n      // We forcefully advance the SIS version to an unused future version.  This is necessary if the previous primary crashed and we are\n      // starting up on an \"older\" index, else versions can be illegally reused but show different results:\n      if (forcePrimaryVersion != -1) {\n        message(\"now forcePrimaryVersion to version=\" + forcePrimaryVersion);\n        writer.advanceSegmentInfosVersion(forcePrimaryVersion);\n      }\n\n      mgr = new SearcherManager(writer, true, true, searcherFactory);\n      setCurrentInfos(Collections.<String>emptySet());\n      message(\"init: infos version=\" + curInfos.getVersion());\n\n      IndexSearcher s = mgr.acquire();\n      try {\n        // TODO: this is test code specific!!\n        message(\"init: marker count: \" + s.count(new TermQuery(new Term(\"marker\", \"marker\"))));\n      } finally {\n        mgr.release(s);\n      }\n\n    } catch (Throwable t) {\n      message(\"init: exception\");\n      t.printStackTrace(printStream);\n      throw new RuntimeException(t);\n    }\n  }\n\n","sourceOld":"  public PrimaryNode(IndexWriter writer, int id, long primaryGen, long forcePrimaryVersion,\n                     SearcherFactory searcherFactory, PrintStream printStream) throws IOException {\n    super(id, writer.getDirectory(), searcherFactory, printStream);\n    message(\"top: now init primary\");\n    this.writer = writer;\n    this.primaryGen = primaryGen;\n\n    try {\n      // So that when primary node's IndexWriter finishes a merge, but before it cuts over to the merged segment,\n      // it copies it out to the replicas.  This ensures the whole system's NRT latency remains low even when a\n      // large merge completes:\n      writer.getConfig().setMergedSegmentWarmer(new PreCopyMergedSegmentWarmer(this));\n\n      message(\"IWC:\\n\" + writer.getConfig());\n      message(\"dir:\\n\" + writer.getDirectory());\n      message(\"commitData: \" + writer.getCommitData());\n\n      // Record our primaryGen in the userData, and set initial version to 0:\n      Map<String,String> commitData = new HashMap<>(writer.getCommitData());\n      commitData.put(PRIMARY_GEN_KEY, Long.toString(primaryGen));\n      if (commitData.get(VERSION_KEY) == null) {\n        commitData.put(VERSION_KEY, \"0\");\n        message(\"add initial commitData version=0\");\n      } else {\n        message(\"keep current commitData version=\" + commitData.get(VERSION_KEY));\n      }\n      writer.setCommitData(commitData, false);\n\n      // We forcefully advance the SIS version to an unused future version.  This is necessary if the previous primary crashed and we are\n      // starting up on an \"older\" index, else versions can be illegally reused but show different results:\n      if (forcePrimaryVersion != -1) {\n        message(\"now forcePrimaryVersion to version=\" + forcePrimaryVersion);\n        writer.advanceSegmentInfosVersion(forcePrimaryVersion);\n      }\n\n      mgr = new SearcherManager(writer, true, true, searcherFactory);\n      setCurrentInfos(Collections.<String>emptySet());\n      message(\"init: infos version=\" + curInfos.getVersion());\n\n      IndexSearcher s = mgr.acquire();\n      try {\n        // TODO: this is test code specific!!\n        message(\"init: marker count: \" + s.count(new TermQuery(new Term(\"marker\", \"marker\"))));\n      } finally {\n        mgr.release(s);\n      }\n\n    } catch (Throwable t) {\n      message(\"init: exception\");\n      t.printStackTrace(printStream);\n      throw new RuntimeException(t);\n    }\n  }\n\n","bugFix":["0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#PrimaryNode(IndexWriter,int,long,long,SearcherFactory,PrintStream).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#PrimaryNode(IndexWriter,int,long,long,SearcherFactory,PrintStream).mjava","sourceNew":"  public PrimaryNode(IndexWriter writer, int id, long primaryGen, long forcePrimaryVersion,\n                     SearcherFactory searcherFactory, PrintStream printStream) throws IOException {\n    super(id, writer.getDirectory(), searcherFactory, printStream);\n    message(\"top: now init primary\");\n    this.writer = writer;\n    this.primaryGen = primaryGen;\n\n    try {\n      // So that when primary node's IndexWriter finishes a merge, but before it cuts over to the merged segment,\n      // it copies it out to the replicas.  This ensures the whole system's NRT latency remains low even when a\n      // large merge completes:\n      writer.getConfig().setMergedSegmentWarmer(new PreCopyMergedSegmentWarmer(this));\n\n      message(\"IWC:\\n\" + writer.getConfig());\n      message(\"dir:\\n\" + writer.getDirectory());\n      message(\"commitData: \" + writer.getLiveCommitData());\n\n      // Record our primaryGen in the userData, and set initial version to 0:\n      Map<String,String> commitData = new HashMap<>();\n      Iterable<Map.Entry<String,String>> iter = writer.getLiveCommitData();\n      if (iter != null) {\n        for(Map.Entry<String,String> ent : iter) {\n          commitData.put(ent.getKey(), ent.getValue());\n        }\n      }\n      commitData.put(PRIMARY_GEN_KEY, Long.toString(primaryGen));\n      if (commitData.get(VERSION_KEY) == null) {\n        commitData.put(VERSION_KEY, \"0\");\n        message(\"add initial commitData version=0\");\n      } else {\n        message(\"keep current commitData version=\" + commitData.get(VERSION_KEY));\n      }\n      writer.setLiveCommitData(commitData.entrySet(), false);\n\n      // We forcefully advance the SIS version to an unused future version.  This is necessary if the previous primary crashed and we are\n      // starting up on an \"older\" index, else versions can be illegally reused but show different results:\n      if (forcePrimaryVersion != -1) {\n        message(\"now forcePrimaryVersion to version=\" + forcePrimaryVersion);\n        writer.advanceSegmentInfosVersion(forcePrimaryVersion);\n      }\n\n      mgr = new SearcherManager(writer, true, true, searcherFactory);\n      setCurrentInfos(Collections.<String>emptySet());\n      message(\"init: infos version=\" + curInfos.getVersion());\n\n      IndexSearcher s = mgr.acquire();\n      try {\n        // TODO: this is test code specific!!\n        message(\"init: marker count: \" + s.count(new TermQuery(new Term(\"marker\", \"marker\"))));\n      } finally {\n        mgr.release(s);\n      }\n\n    } catch (Throwable t) {\n      message(\"init: exception\");\n      t.printStackTrace(printStream);\n      throw new RuntimeException(t);\n    }\n  }\n\n","sourceOld":"  public PrimaryNode(IndexWriter writer, int id, long primaryGen, long forcePrimaryVersion,\n                     SearcherFactory searcherFactory, PrintStream printStream) throws IOException {\n    super(id, writer.getDirectory(), searcherFactory, printStream);\n    message(\"top: now init primary\");\n    this.writer = writer;\n    this.primaryGen = primaryGen;\n\n    try {\n      // So that when primary node's IndexWriter finishes a merge, but before it cuts over to the merged segment,\n      // it copies it out to the replicas.  This ensures the whole system's NRT latency remains low even when a\n      // large merge completes:\n      writer.getConfig().setMergedSegmentWarmer(new PreCopyMergedSegmentWarmer(this));\n\n      message(\"IWC:\\n\" + writer.getConfig());\n      message(\"dir:\\n\" + writer.getDirectory());\n      message(\"commitData: \" + writer.getCommitData());\n\n      // Record our primaryGen in the userData, and set initial version to 0:\n      Map<String,String> commitData = new HashMap<>(writer.getCommitData());\n      commitData.put(PRIMARY_GEN_KEY, Long.toString(primaryGen));\n      if (commitData.get(VERSION_KEY) == null) {\n        commitData.put(VERSION_KEY, \"0\");\n        message(\"add initial commitData version=0\");\n      } else {\n        message(\"keep current commitData version=\" + commitData.get(VERSION_KEY));\n      }\n      writer.setCommitData(commitData, false);\n\n      // We forcefully advance the SIS version to an unused future version.  This is necessary if the previous primary crashed and we are\n      // starting up on an \"older\" index, else versions can be illegally reused but show different results:\n      if (forcePrimaryVersion != -1) {\n        message(\"now forcePrimaryVersion to version=\" + forcePrimaryVersion);\n        writer.advanceSegmentInfosVersion(forcePrimaryVersion);\n      }\n\n      mgr = new SearcherManager(writer, true, true, searcherFactory);\n      setCurrentInfos(Collections.<String>emptySet());\n      message(\"init: infos version=\" + curInfos.getVersion());\n\n      IndexSearcher s = mgr.acquire();\n      try {\n        // TODO: this is test code specific!!\n        message(\"init: marker count: \" + s.count(new TermQuery(new Term(\"marker\", \"marker\"))));\n      } finally {\n        mgr.release(s);\n      }\n\n    } catch (Throwable t) {\n      message(\"init: exception\");\n      t.printStackTrace(printStream);\n      throw new RuntimeException(t);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c99ce0aa95120025213296d8d1ebf6164566dd49","date":1504272254,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#PrimaryNode(IndexWriter,int,long,long,SearcherFactory,PrintStream).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#PrimaryNode(IndexWriter,int,long,long,SearcherFactory,PrintStream).mjava","sourceNew":"  public PrimaryNode(IndexWriter writer, int id, long primaryGen, long forcePrimaryVersion,\n                     SearcherFactory searcherFactory, PrintStream printStream) throws IOException {\n    super(id, writer.getDirectory(), searcherFactory, printStream);\n    message(\"top: now init primary\");\n    this.writer = writer;\n    this.primaryGen = primaryGen;\n\n    try {\n      // So that when primary node's IndexWriter finishes a merge, but before it cuts over to the merged segment,\n      // it copies it out to the replicas.  This ensures the whole system's NRT latency remains low even when a\n      // large merge completes:\n      writer.getConfig().setMergedSegmentWarmer(new PreCopyMergedSegmentWarmer(this));\n\n      message(\"IWC:\\n\" + writer.getConfig());\n      message(\"dir:\\n\" + writer.getDirectory());\n      message(\"commitData: \" + writer.getLiveCommitData());\n\n      // Record our primaryGen in the userData, and set initial version to 0:\n      Map<String,String> commitData = new HashMap<>();\n      Iterable<Map.Entry<String,String>> iter = writer.getLiveCommitData();\n      if (iter != null) {\n        for(Map.Entry<String,String> ent : iter) {\n          commitData.put(ent.getKey(), ent.getValue());\n        }\n      }\n      commitData.put(PRIMARY_GEN_KEY, Long.toString(primaryGen));\n      if (commitData.get(VERSION_KEY) == null) {\n        commitData.put(VERSION_KEY, \"0\");\n        message(\"add initial commitData version=0\");\n      } else {\n        message(\"keep current commitData version=\" + commitData.get(VERSION_KEY));\n      }\n      writer.setLiveCommitData(commitData.entrySet(), false);\n\n      // We forcefully advance the SIS version to an unused future version.  This is necessary if the previous primary crashed and we are\n      // starting up on an \"older\" index, else versions can be illegally reused but show different results:\n      if (forcePrimaryVersion != -1) {\n        message(\"now forcePrimaryVersion to version=\" + forcePrimaryVersion);\n        writer.advanceSegmentInfosVersion(forcePrimaryVersion);\n      }\n\n      mgr = new SearcherManager(writer, true, true, searcherFactory);\n      setCurrentInfos(Collections.<String>emptySet());\n      message(\"init: infos version=\" + curInfos.getVersion());\n\n    } catch (Throwable t) {\n      message(\"init: exception\");\n      t.printStackTrace(printStream);\n      throw new RuntimeException(t);\n    }\n  }\n\n","sourceOld":"  public PrimaryNode(IndexWriter writer, int id, long primaryGen, long forcePrimaryVersion,\n                     SearcherFactory searcherFactory, PrintStream printStream) throws IOException {\n    super(id, writer.getDirectory(), searcherFactory, printStream);\n    message(\"top: now init primary\");\n    this.writer = writer;\n    this.primaryGen = primaryGen;\n\n    try {\n      // So that when primary node's IndexWriter finishes a merge, but before it cuts over to the merged segment,\n      // it copies it out to the replicas.  This ensures the whole system's NRT latency remains low even when a\n      // large merge completes:\n      writer.getConfig().setMergedSegmentWarmer(new PreCopyMergedSegmentWarmer(this));\n\n      message(\"IWC:\\n\" + writer.getConfig());\n      message(\"dir:\\n\" + writer.getDirectory());\n      message(\"commitData: \" + writer.getLiveCommitData());\n\n      // Record our primaryGen in the userData, and set initial version to 0:\n      Map<String,String> commitData = new HashMap<>();\n      Iterable<Map.Entry<String,String>> iter = writer.getLiveCommitData();\n      if (iter != null) {\n        for(Map.Entry<String,String> ent : iter) {\n          commitData.put(ent.getKey(), ent.getValue());\n        }\n      }\n      commitData.put(PRIMARY_GEN_KEY, Long.toString(primaryGen));\n      if (commitData.get(VERSION_KEY) == null) {\n        commitData.put(VERSION_KEY, \"0\");\n        message(\"add initial commitData version=0\");\n      } else {\n        message(\"keep current commitData version=\" + commitData.get(VERSION_KEY));\n      }\n      writer.setLiveCommitData(commitData.entrySet(), false);\n\n      // We forcefully advance the SIS version to an unused future version.  This is necessary if the previous primary crashed and we are\n      // starting up on an \"older\" index, else versions can be illegally reused but show different results:\n      if (forcePrimaryVersion != -1) {\n        message(\"now forcePrimaryVersion to version=\" + forcePrimaryVersion);\n        writer.advanceSegmentInfosVersion(forcePrimaryVersion);\n      }\n\n      mgr = new SearcherManager(writer, true, true, searcherFactory);\n      setCurrentInfos(Collections.<String>emptySet());\n      message(\"init: infos version=\" + curInfos.getVersion());\n\n      IndexSearcher s = mgr.acquire();\n      try {\n        // TODO: this is test code specific!!\n        message(\"init: marker count: \" + s.count(new TermQuery(new Term(\"marker\", \"marker\"))));\n      } finally {\n        mgr.release(s);\n      }\n\n    } catch (Throwable t) {\n      message(\"init: exception\");\n      t.printStackTrace(printStream);\n      throw new RuntimeException(t);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a7809d1d753b67f48b1a706e17034bf8b624ea3","date":1504366927,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#PrimaryNode(IndexWriter,int,long,long,SearcherFactory,PrintStream).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#PrimaryNode(IndexWriter,int,long,long,SearcherFactory,PrintStream).mjava","sourceNew":"  public PrimaryNode(IndexWriter writer, int id, long primaryGen, long forcePrimaryVersion,\n                     SearcherFactory searcherFactory, PrintStream printStream) throws IOException {\n    super(id, writer.getDirectory(), searcherFactory, printStream);\n    message(\"top: now init primary\");\n    this.writer = writer;\n    this.primaryGen = primaryGen;\n\n    try {\n      // So that when primary node's IndexWriter finishes a merge, but before it cuts over to the merged segment,\n      // it copies it out to the replicas.  This ensures the whole system's NRT latency remains low even when a\n      // large merge completes:\n      writer.getConfig().setMergedSegmentWarmer(new PreCopyMergedSegmentWarmer(this));\n\n      message(\"IWC:\\n\" + writer.getConfig());\n      message(\"dir:\\n\" + writer.getDirectory());\n      message(\"commitData: \" + writer.getLiveCommitData());\n\n      // Record our primaryGen in the userData, and set initial version to 0:\n      Map<String,String> commitData = new HashMap<>();\n      Iterable<Map.Entry<String,String>> iter = writer.getLiveCommitData();\n      if (iter != null) {\n        for(Map.Entry<String,String> ent : iter) {\n          commitData.put(ent.getKey(), ent.getValue());\n        }\n      }\n      commitData.put(PRIMARY_GEN_KEY, Long.toString(primaryGen));\n      if (commitData.get(VERSION_KEY) == null) {\n        commitData.put(VERSION_KEY, \"0\");\n        message(\"add initial commitData version=0\");\n      } else {\n        message(\"keep current commitData version=\" + commitData.get(VERSION_KEY));\n      }\n      writer.setLiveCommitData(commitData.entrySet(), false);\n\n      // We forcefully advance the SIS version to an unused future version.  This is necessary if the previous primary crashed and we are\n      // starting up on an \"older\" index, else versions can be illegally reused but show different results:\n      if (forcePrimaryVersion != -1) {\n        message(\"now forcePrimaryVersion to version=\" + forcePrimaryVersion);\n        writer.advanceSegmentInfosVersion(forcePrimaryVersion);\n      }\n\n      mgr = new SearcherManager(writer, true, true, searcherFactory);\n      setCurrentInfos(Collections.<String>emptySet());\n      message(\"init: infos version=\" + curInfos.getVersion());\n\n    } catch (Throwable t) {\n      message(\"init: exception\");\n      t.printStackTrace(printStream);\n      throw new RuntimeException(t);\n    }\n  }\n\n","sourceOld":"  public PrimaryNode(IndexWriter writer, int id, long primaryGen, long forcePrimaryVersion,\n                     SearcherFactory searcherFactory, PrintStream printStream) throws IOException {\n    super(id, writer.getDirectory(), searcherFactory, printStream);\n    message(\"top: now init primary\");\n    this.writer = writer;\n    this.primaryGen = primaryGen;\n\n    try {\n      // So that when primary node's IndexWriter finishes a merge, but before it cuts over to the merged segment,\n      // it copies it out to the replicas.  This ensures the whole system's NRT latency remains low even when a\n      // large merge completes:\n      writer.getConfig().setMergedSegmentWarmer(new PreCopyMergedSegmentWarmer(this));\n\n      message(\"IWC:\\n\" + writer.getConfig());\n      message(\"dir:\\n\" + writer.getDirectory());\n      message(\"commitData: \" + writer.getLiveCommitData());\n\n      // Record our primaryGen in the userData, and set initial version to 0:\n      Map<String,String> commitData = new HashMap<>();\n      Iterable<Map.Entry<String,String>> iter = writer.getLiveCommitData();\n      if (iter != null) {\n        for(Map.Entry<String,String> ent : iter) {\n          commitData.put(ent.getKey(), ent.getValue());\n        }\n      }\n      commitData.put(PRIMARY_GEN_KEY, Long.toString(primaryGen));\n      if (commitData.get(VERSION_KEY) == null) {\n        commitData.put(VERSION_KEY, \"0\");\n        message(\"add initial commitData version=0\");\n      } else {\n        message(\"keep current commitData version=\" + commitData.get(VERSION_KEY));\n      }\n      writer.setLiveCommitData(commitData.entrySet(), false);\n\n      // We forcefully advance the SIS version to an unused future version.  This is necessary if the previous primary crashed and we are\n      // starting up on an \"older\" index, else versions can be illegally reused but show different results:\n      if (forcePrimaryVersion != -1) {\n        message(\"now forcePrimaryVersion to version=\" + forcePrimaryVersion);\n        writer.advanceSegmentInfosVersion(forcePrimaryVersion);\n      }\n\n      mgr = new SearcherManager(writer, true, true, searcherFactory);\n      setCurrentInfos(Collections.<String>emptySet());\n      message(\"init: infos version=\" + curInfos.getVersion());\n\n      IndexSearcher s = mgr.acquire();\n      try {\n        // TODO: this is test code specific!!\n        message(\"init: marker count: \" + s.count(new TermQuery(new Term(\"marker\", \"marker\"))));\n      } finally {\n        mgr.release(s);\n      }\n\n    } catch (Throwable t) {\n      message(\"init: exception\");\n      t.printStackTrace(printStream);\n      throw new RuntimeException(t);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b21283ed01203901a7257aa4b7f0a0899c86e56e","date":1504689720,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#PrimaryNode(IndexWriter,int,long,long,SearcherFactory,PrintStream).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#PrimaryNode(IndexWriter,int,long,long,SearcherFactory,PrintStream).mjava","sourceNew":"  public PrimaryNode(IndexWriter writer, int id, long primaryGen, long forcePrimaryVersion,\n                     SearcherFactory searcherFactory, PrintStream printStream) throws IOException {\n    super(id, writer.getDirectory(), searcherFactory, printStream);\n    message(\"top: now init primary\");\n    this.writer = writer;\n    this.primaryGen = primaryGen;\n\n    try {\n      // So that when primary node's IndexWriter finishes a merge, but before it cuts over to the merged segment,\n      // it copies it out to the replicas.  This ensures the whole system's NRT latency remains low even when a\n      // large merge completes:\n      writer.getConfig().setMergedSegmentWarmer(new PreCopyMergedSegmentWarmer(this));\n\n      message(\"IWC:\\n\" + writer.getConfig());\n      message(\"dir:\\n\" + writer.getDirectory());\n      message(\"commitData: \" + writer.getLiveCommitData());\n\n      // Record our primaryGen in the userData, and set initial version to 0:\n      Map<String,String> commitData = new HashMap<>();\n      Iterable<Map.Entry<String,String>> iter = writer.getLiveCommitData();\n      if (iter != null) {\n        for(Map.Entry<String,String> ent : iter) {\n          commitData.put(ent.getKey(), ent.getValue());\n        }\n      }\n      commitData.put(PRIMARY_GEN_KEY, Long.toString(primaryGen));\n      if (commitData.get(VERSION_KEY) == null) {\n        commitData.put(VERSION_KEY, \"0\");\n        message(\"add initial commitData version=0\");\n      } else {\n        message(\"keep current commitData version=\" + commitData.get(VERSION_KEY));\n      }\n      writer.setLiveCommitData(commitData.entrySet(), false);\n\n      // We forcefully advance the SIS version to an unused future version.  This is necessary if the previous primary crashed and we are\n      // starting up on an \"older\" index, else versions can be illegally reused but show different results:\n      if (forcePrimaryVersion != -1) {\n        message(\"now forcePrimaryVersion to version=\" + forcePrimaryVersion);\n        writer.advanceSegmentInfosVersion(forcePrimaryVersion);\n      }\n\n      mgr = new SearcherManager(writer, true, true, searcherFactory);\n      setCurrentInfos(Collections.<String>emptySet());\n      message(\"init: infos version=\" + curInfos.getVersion());\n\n    } catch (Throwable t) {\n      message(\"init: exception\");\n      t.printStackTrace(printStream);\n      throw new RuntimeException(t);\n    }\n  }\n\n","sourceOld":"  public PrimaryNode(IndexWriter writer, int id, long primaryGen, long forcePrimaryVersion,\n                     SearcherFactory searcherFactory, PrintStream printStream) throws IOException {\n    super(id, writer.getDirectory(), searcherFactory, printStream);\n    message(\"top: now init primary\");\n    this.writer = writer;\n    this.primaryGen = primaryGen;\n\n    try {\n      // So that when primary node's IndexWriter finishes a merge, but before it cuts over to the merged segment,\n      // it copies it out to the replicas.  This ensures the whole system's NRT latency remains low even when a\n      // large merge completes:\n      writer.getConfig().setMergedSegmentWarmer(new PreCopyMergedSegmentWarmer(this));\n\n      message(\"IWC:\\n\" + writer.getConfig());\n      message(\"dir:\\n\" + writer.getDirectory());\n      message(\"commitData: \" + writer.getLiveCommitData());\n\n      // Record our primaryGen in the userData, and set initial version to 0:\n      Map<String,String> commitData = new HashMap<>();\n      Iterable<Map.Entry<String,String>> iter = writer.getLiveCommitData();\n      if (iter != null) {\n        for(Map.Entry<String,String> ent : iter) {\n          commitData.put(ent.getKey(), ent.getValue());\n        }\n      }\n      commitData.put(PRIMARY_GEN_KEY, Long.toString(primaryGen));\n      if (commitData.get(VERSION_KEY) == null) {\n        commitData.put(VERSION_KEY, \"0\");\n        message(\"add initial commitData version=0\");\n      } else {\n        message(\"keep current commitData version=\" + commitData.get(VERSION_KEY));\n      }\n      writer.setLiveCommitData(commitData.entrySet(), false);\n\n      // We forcefully advance the SIS version to an unused future version.  This is necessary if the previous primary crashed and we are\n      // starting up on an \"older\" index, else versions can be illegally reused but show different results:\n      if (forcePrimaryVersion != -1) {\n        message(\"now forcePrimaryVersion to version=\" + forcePrimaryVersion);\n        writer.advanceSegmentInfosVersion(forcePrimaryVersion);\n      }\n\n      mgr = new SearcherManager(writer, true, true, searcherFactory);\n      setCurrentInfos(Collections.<String>emptySet());\n      message(\"init: infos version=\" + curInfos.getVersion());\n\n      IndexSearcher s = mgr.acquire();\n      try {\n        // TODO: this is test code specific!!\n        message(\"init: marker count: \" + s.count(new TermQuery(new Term(\"marker\", \"marker\"))));\n      } finally {\n        mgr.release(s);\n      }\n\n    } catch (Throwable t) {\n      message(\"init: exception\");\n      t.printStackTrace(printStream);\n      throw new RuntimeException(t);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7","date":1504848000,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#PrimaryNode(IndexWriter,int,long,long,SearcherFactory,PrintStream).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/PrimaryNode#PrimaryNode(IndexWriter,int,long,long,SearcherFactory,PrintStream).mjava","sourceNew":"  public PrimaryNode(IndexWriter writer, int id, long primaryGen, long forcePrimaryVersion,\n                     SearcherFactory searcherFactory, PrintStream printStream) throws IOException {\n    super(id, writer.getDirectory(), searcherFactory, printStream);\n    message(\"top: now init primary\");\n    this.writer = writer;\n    this.primaryGen = primaryGen;\n\n    try {\n      // So that when primary node's IndexWriter finishes a merge, but before it cuts over to the merged segment,\n      // it copies it out to the replicas.  This ensures the whole system's NRT latency remains low even when a\n      // large merge completes:\n      writer.getConfig().setMergedSegmentWarmer(new PreCopyMergedSegmentWarmer(this));\n\n      message(\"IWC:\\n\" + writer.getConfig());\n      message(\"dir:\\n\" + writer.getDirectory());\n      message(\"commitData: \" + writer.getLiveCommitData());\n\n      // Record our primaryGen in the userData, and set initial version to 0:\n      Map<String,String> commitData = new HashMap<>();\n      Iterable<Map.Entry<String,String>> iter = writer.getLiveCommitData();\n      if (iter != null) {\n        for(Map.Entry<String,String> ent : iter) {\n          commitData.put(ent.getKey(), ent.getValue());\n        }\n      }\n      commitData.put(PRIMARY_GEN_KEY, Long.toString(primaryGen));\n      if (commitData.get(VERSION_KEY) == null) {\n        commitData.put(VERSION_KEY, \"0\");\n        message(\"add initial commitData version=0\");\n      } else {\n        message(\"keep current commitData version=\" + commitData.get(VERSION_KEY));\n      }\n      writer.setLiveCommitData(commitData.entrySet(), false);\n\n      // We forcefully advance the SIS version to an unused future version.  This is necessary if the previous primary crashed and we are\n      // starting up on an \"older\" index, else versions can be illegally reused but show different results:\n      if (forcePrimaryVersion != -1) {\n        message(\"now forcePrimaryVersion to version=\" + forcePrimaryVersion);\n        writer.advanceSegmentInfosVersion(forcePrimaryVersion);\n      }\n\n      mgr = new SearcherManager(writer, true, true, searcherFactory);\n      setCurrentInfos(Collections.<String>emptySet());\n      message(\"init: infos version=\" + curInfos.getVersion());\n\n    } catch (Throwable t) {\n      message(\"init: exception\");\n      t.printStackTrace(printStream);\n      throw new RuntimeException(t);\n    }\n  }\n\n","sourceOld":"  public PrimaryNode(IndexWriter writer, int id, long primaryGen, long forcePrimaryVersion,\n                     SearcherFactory searcherFactory, PrintStream printStream) throws IOException {\n    super(id, writer.getDirectory(), searcherFactory, printStream);\n    message(\"top: now init primary\");\n    this.writer = writer;\n    this.primaryGen = primaryGen;\n\n    try {\n      // So that when primary node's IndexWriter finishes a merge, but before it cuts over to the merged segment,\n      // it copies it out to the replicas.  This ensures the whole system's NRT latency remains low even when a\n      // large merge completes:\n      writer.getConfig().setMergedSegmentWarmer(new PreCopyMergedSegmentWarmer(this));\n\n      message(\"IWC:\\n\" + writer.getConfig());\n      message(\"dir:\\n\" + writer.getDirectory());\n      message(\"commitData: \" + writer.getLiveCommitData());\n\n      // Record our primaryGen in the userData, and set initial version to 0:\n      Map<String,String> commitData = new HashMap<>();\n      Iterable<Map.Entry<String,String>> iter = writer.getLiveCommitData();\n      if (iter != null) {\n        for(Map.Entry<String,String> ent : iter) {\n          commitData.put(ent.getKey(), ent.getValue());\n        }\n      }\n      commitData.put(PRIMARY_GEN_KEY, Long.toString(primaryGen));\n      if (commitData.get(VERSION_KEY) == null) {\n        commitData.put(VERSION_KEY, \"0\");\n        message(\"add initial commitData version=0\");\n      } else {\n        message(\"keep current commitData version=\" + commitData.get(VERSION_KEY));\n      }\n      writer.setLiveCommitData(commitData.entrySet(), false);\n\n      // We forcefully advance the SIS version to an unused future version.  This is necessary if the previous primary crashed and we are\n      // starting up on an \"older\" index, else versions can be illegally reused but show different results:\n      if (forcePrimaryVersion != -1) {\n        message(\"now forcePrimaryVersion to version=\" + forcePrimaryVersion);\n        writer.advanceSegmentInfosVersion(forcePrimaryVersion);\n      }\n\n      mgr = new SearcherManager(writer, true, true, searcherFactory);\n      setCurrentInfos(Collections.<String>emptySet());\n      message(\"init: infos version=\" + curInfos.getVersion());\n\n      IndexSearcher s = mgr.acquire();\n      try {\n        // TODO: this is test code specific!!\n        message(\"init: marker count: \" + s.count(new TermQuery(new Term(\"marker\", \"marker\"))));\n      } finally {\n        mgr.release(s);\n      }\n\n    } catch (Throwable t) {\n      message(\"init: exception\");\n      t.printStackTrace(printStream);\n      throw new RuntimeException(t);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b21283ed01203901a7257aa4b7f0a0899c86e56e":["71e1a70f18d64b93db3ef618e606d6df5062f747","c99ce0aa95120025213296d8d1ebf6164566dd49"],"2b844e2ae5435a8d4d925003c10027c25e26e02d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"71e1a70f18d64b93db3ef618e606d6df5062f747":["68496c2200e559fb7802f7575427b7a482659afb"],"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7":["71e1a70f18d64b93db3ef618e606d6df5062f747","b21283ed01203901a7257aa4b7f0a0899c86e56e"],"c99ce0aa95120025213296d8d1ebf6164566dd49":["71e1a70f18d64b93db3ef618e606d6df5062f747"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":["71e1a70f18d64b93db3ef618e606d6df5062f747","c99ce0aa95120025213296d8d1ebf6164566dd49"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"68496c2200e559fb7802f7575427b7a482659afb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2b844e2ae5435a8d4d925003c10027c25e26e02d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["68496c2200e559fb7802f7575427b7a482659afb","71e1a70f18d64b93db3ef618e606d6df5062f747"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"]},"commit2Childs":{"b21283ed01203901a7257aa4b7f0a0899c86e56e":["104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"],"2b844e2ae5435a8d4d925003c10027c25e26e02d":["68496c2200e559fb7802f7575427b7a482659afb"],"71e1a70f18d64b93db3ef618e606d6df5062f747":["b21283ed01203901a7257aa4b7f0a0899c86e56e","104a3f62ee393d48b5596de76ed4d9a4e0ea6de7","c99ce0aa95120025213296d8d1ebf6164566dd49","3a7809d1d753b67f48b1a706e17034bf8b624ea3","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"c99ce0aa95120025213296d8d1ebf6164566dd49":["b21283ed01203901a7257aa4b7f0a0899c86e56e","3a7809d1d753b67f48b1a706e17034bf8b624ea3"],"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2b844e2ae5435a8d4d925003c10027c25e26e02d","68496c2200e559fb7802f7575427b7a482659afb"],"68496c2200e559fb7802f7575427b7a482659afb":["71e1a70f18d64b93db3ef618e606d6df5062f747","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3a7809d1d753b67f48b1a706e17034bf8b624ea3","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}