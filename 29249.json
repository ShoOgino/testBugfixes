{"path":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean,boolean).mjava","commits":[{"id":"d9405f486872f1e416304dfe389741f4ee2f8a4d","date":1351276739,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","sourceNew":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback, boolean forceNewDir) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait();\n        } catch (InterruptedException e) {}\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\", forceNewDir);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait();\n        } catch (InterruptedException e) {}\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\", true);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f2126b84bd093fa3d921582a109a0ee578c28126","date":1351522501,"type":1,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","sourceNew":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback, boolean forceNewDir) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait();\n        } catch (InterruptedException e) {}\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\", forceNewDir);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait();\n        } catch (InterruptedException e) {}\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\", true);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3a59df963d88be504b80055918c76d3cc066054","date":1352556665,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean,boolean).mjava","sourceNew":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback, boolean forceNewDir) throws IOException {\n    if (closed) {\n      throw new AlreadyClosedException(\"SolrCoreState already closed\");\n    }\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait();\n        } catch (InterruptedException e) {}\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\", forceNewDir);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback, boolean forceNewDir) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait();\n        } catch (InterruptedException e) {}\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\", forceNewDir);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["058801f8673d53a5abac8088204860ec29a40f0d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean,boolean).mjava","sourceNew":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback, boolean forceNewDir) throws IOException {\n    if (closed) {\n      throw new AlreadyClosedException(\"SolrCoreState already closed\");\n    }\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait();\n        } catch (InterruptedException e) {}\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\", forceNewDir);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback, boolean forceNewDir) throws IOException {\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait();\n        } catch (InterruptedException e) {}\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\", forceNewDir);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eb4a175e8863893e146a53576c406f9fecb9a9cf","date":1355165706,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean,boolean).mjava","sourceNew":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback, boolean forceNewDir) throws IOException {\n    if (closed) {\n      throw new AlreadyClosedException(\"SolrCoreState already closed\");\n    }\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new RuntimeException(\"Already closed\");\n        }\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\", forceNewDir);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback, boolean forceNewDir) throws IOException {\n    if (closed) {\n      throw new AlreadyClosedException(\"SolrCoreState already closed\");\n    }\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait();\n        } catch (InterruptedException e) {}\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\", forceNewDir);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["0cf25ac9828f9d484e626a18635422d10f8c9549"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0237c8eedfd2dc43722634e4e8d7432b7b8faf3f","date":1355272694,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean,boolean).mjava","sourceNew":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback, boolean forceNewDir) throws IOException {\n    if (closed) {\n      throw new AlreadyClosedException(\"SolrCoreState already closed\");\n    }\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new RuntimeException(\"SolrCoreState already closed\");\n        }\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\", forceNewDir);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback, boolean forceNewDir) throws IOException {\n    if (closed) {\n      throw new AlreadyClosedException(\"SolrCoreState already closed\");\n    }\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new RuntimeException(\"Already closed\");\n        }\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\", forceNewDir);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["0cf25ac9828f9d484e626a18635422d10f8c9549"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean,boolean).mjava","sourceNew":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback, boolean forceNewDir) throws IOException {\n    if (closed) {\n      throw new AlreadyClosedException(\"SolrCoreState already closed\");\n    }\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new RuntimeException(\"SolrCoreState already closed\");\n        }\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\", forceNewDir);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback, boolean forceNewDir) throws IOException {\n    if (closed) {\n      throw new AlreadyClosedException(\"SolrCoreState already closed\");\n    }\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait();\n        } catch (InterruptedException e) {}\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\", forceNewDir);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0cf25ac9828f9d484e626a18635422d10f8c9549","date":1360344005,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean,boolean).mjava","sourceNew":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback, boolean forceNewDir) throws IOException {\n    if (closed) {\n      throw new AlreadyClosedException(\"SolrCoreState already closed\");\n    }\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      boolean yieldedCommitLock = false;\n      try {\n        if (commitLock.isHeldByCurrentThread()) {\n          yieldedCommitLock = true;\n          commitLock.unlock();\n        }\n        \n        while (!writerFree) {\n          try {\n            writerPauseLock.wait(100);\n          } catch (InterruptedException e) {}\n          \n          if (closed) {\n            throw new RuntimeException(\"SolrCoreState already closed\");\n          }\n        }\n      } finally {\n        if (yieldedCommitLock) {\n          commitLock.lock();\n        }\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\", forceNewDir);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback, boolean forceNewDir) throws IOException {\n    if (closed) {\n      throw new AlreadyClosedException(\"SolrCoreState already closed\");\n    }\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new RuntimeException(\"SolrCoreState already closed\");\n        }\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\", forceNewDir);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":["0237c8eedfd2dc43722634e4e8d7432b7b8faf3f","1381b91b03f7409d8d548c7070dbc615931a0f50","eb4a175e8863893e146a53576c406f9fecb9a9cf"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6985908e87af0a99c5571a36bb1813179076fe95","date":1362158687,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean,boolean).mjava","sourceNew":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback, boolean forceNewDir) throws IOException {\n    if (closed) {\n      throw new AlreadyClosedException(\"SolrCoreState already closed\");\n    }\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new RuntimeException(\"SolrCoreState already closed\");\n        }\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\", forceNewDir);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback, boolean forceNewDir) throws IOException {\n    if (closed) {\n      throw new AlreadyClosedException(\"SolrCoreState already closed\");\n    }\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      boolean yieldedCommitLock = false;\n      try {\n        if (commitLock.isHeldByCurrentThread()) {\n          yieldedCommitLock = true;\n          commitLock.unlock();\n        }\n        \n        while (!writerFree) {\n          try {\n            writerPauseLock.wait(100);\n          } catch (InterruptedException e) {}\n          \n          if (closed) {\n            throw new RuntimeException(\"SolrCoreState already closed\");\n          }\n        }\n      } finally {\n        if (yieldedCommitLock) {\n          commitLock.lock();\n        }\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\", forceNewDir);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8d2f62023fd5e0673362628a444c858f0ca4ea33","date":1363177719,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean,boolean).mjava","sourceNew":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback, boolean forceNewDir) throws IOException {\n    if (closed) {\n      throw new AlreadyClosedException(\"SolrCoreState already closed\");\n    }\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCoreState already closed\");\n        }\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\", forceNewDir);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback, boolean forceNewDir) throws IOException {\n    if (closed) {\n      throw new AlreadyClosedException(\"SolrCoreState already closed\");\n    }\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new RuntimeException(\"SolrCoreState already closed\");\n        }\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\", forceNewDir);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54f9a16329716fa08b653c53f1c3dfc6b284d2cc","date":1363905854,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean,boolean).mjava","sourceNew":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback, boolean forceNewDir) throws IOException {\n    if (closed) {\n      throw new AlreadyClosedException(\"SolrCoreState already closed\");\n    }\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCoreState already closed\");\n        }\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\");\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback, boolean forceNewDir) throws IOException {\n    if (closed) {\n      throw new AlreadyClosedException(\"SolrCoreState already closed\");\n    }\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCoreState already closed\");\n        }\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\", forceNewDir);\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["1adea4accc297f58fd9d8de3c820fd576eb0d396"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"11fa6b3c54740236744aa64f1a29954b1cf172a5","date":1363907001,"type":5,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DefaultSolrCoreState#newIndexWriter(SolrCore,boolean,boolean).mjava","sourceNew":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback) throws IOException {\n    if (closed) {\n      throw new AlreadyClosedException(\"SolrCoreState already closed\");\n    }\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCoreState already closed\");\n        }\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\");\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void newIndexWriter(SolrCore core, boolean rollback, boolean forceNewDir) throws IOException {\n    if (closed) {\n      throw new AlreadyClosedException(\"SolrCoreState already closed\");\n    }\n    log.info(\"Creating new IndexWriter...\");\n    String coreName = core.getName();\n    synchronized (writerPauseLock) {\n      // we need to wait for the Writer to fall out of use\n      // first lets stop it from being lent out\n      pauseWriter = true;\n      // then lets wait until its out of use\n      log.info(\"Waiting until IndexWriter is unused... core=\" + coreName);\n      \n      while (!writerFree) {\n        try {\n          writerPauseLock.wait(100);\n        } catch (InterruptedException e) {}\n        \n        if (closed) {\n          throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"SolrCoreState already closed\");\n        }\n      }\n\n      try {\n        if (indexWriter != null) {\n          if (!rollback) {\n            try {\n              log.info(\"Closing old IndexWriter... core=\" + coreName);\n              indexWriter.close();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error closing old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          } else {\n            try {\n              log.info(\"Rollback old IndexWriter... core=\" + coreName);\n              indexWriter.rollback();\n            } catch (Throwable t) {\n              SolrException.log(log, \"Error rolling back old IndexWriter. core=\"\n                  + coreName, t);\n            }\n          }\n        }\n        indexWriter = createMainIndexWriter(core, \"DirectUpdateHandler2\");\n        log.info(\"New IndexWriter is ready to be used.\");\n        // we need to null this so it picks up the new writer next get call\n        refCntWriter = null;\n      } finally {\n        \n        pauseWriter = false;\n        writerPauseLock.notifyAll();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["1adea4accc297f58fd9d8de3c820fd576eb0d396"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","0237c8eedfd2dc43722634e4e8d7432b7b8faf3f"],"8d2f62023fd5e0673362628a444c858f0ca4ea33":["6985908e87af0a99c5571a36bb1813179076fe95"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d9405f486872f1e416304dfe389741f4ee2f8a4d","a3a59df963d88be504b80055918c76d3cc066054"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0237c8eedfd2dc43722634e4e8d7432b7b8faf3f":["eb4a175e8863893e146a53576c406f9fecb9a9cf"],"a3a59df963d88be504b80055918c76d3cc066054":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"6985908e87af0a99c5571a36bb1813179076fe95":["0cf25ac9828f9d484e626a18635422d10f8c9549"],"eb4a175e8863893e146a53576c406f9fecb9a9cf":["a3a59df963d88be504b80055918c76d3cc066054"],"11fa6b3c54740236744aa64f1a29954b1cf172a5":["54f9a16329716fa08b653c53f1c3dfc6b284d2cc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"54f9a16329716fa08b653c53f1c3dfc6b284d2cc":["8d2f62023fd5e0673362628a444c858f0ca4ea33"],"0cf25ac9828f9d484e626a18635422d10f8c9549":["0237c8eedfd2dc43722634e4e8d7432b7b8faf3f"],"f2126b84bd093fa3d921582a109a0ee578c28126":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d9405f486872f1e416304dfe389741f4ee2f8a4d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["11fa6b3c54740236744aa64f1a29954b1cf172a5"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"8d2f62023fd5e0673362628a444c858f0ca4ea33":["54f9a16329716fa08b653c53f1c3dfc6b284d2cc"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["407687e67faf6e1f02a211ca078d8e3eed631027","a3a59df963d88be504b80055918c76d3cc066054","f2126b84bd093fa3d921582a109a0ee578c28126"],"0237c8eedfd2dc43722634e4e8d7432b7b8faf3f":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","0cf25ac9828f9d484e626a18635422d10f8c9549"],"a3a59df963d88be504b80055918c76d3cc066054":["407687e67faf6e1f02a211ca078d8e3eed631027","eb4a175e8863893e146a53576c406f9fecb9a9cf"],"6985908e87af0a99c5571a36bb1813179076fe95":["8d2f62023fd5e0673362628a444c858f0ca4ea33"],"eb4a175e8863893e146a53576c406f9fecb9a9cf":["0237c8eedfd2dc43722634e4e8d7432b7b8faf3f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d9405f486872f1e416304dfe389741f4ee2f8a4d","f2126b84bd093fa3d921582a109a0ee578c28126"],"11fa6b3c54740236744aa64f1a29954b1cf172a5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0cf25ac9828f9d484e626a18635422d10f8c9549":["6985908e87af0a99c5571a36bb1813179076fe95"],"54f9a16329716fa08b653c53f1c3dfc6b284d2cc":["11fa6b3c54740236744aa64f1a29954b1cf172a5"],"f2126b84bd093fa3d921582a109a0ee578c28126":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","f2126b84bd093fa3d921582a109a0ee578c28126","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}