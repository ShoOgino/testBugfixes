{"path":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int).mjava","commits":[{"id":"04c370507e5521b2eb998530736f1c19b851ed5a","date":1531911305,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is &lt;= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  DocValues, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, needsScores, true); // TODO: disable exact counts?\n      }\n\n      float groupMaxScore = needsScores ? Float.NEGATIVE_INFINITY : Float.NaN;\n      LeafCollector leafCollector = collector.getLeafCollector(og.readerContext);\n      leafCollector.setScorer(fakeScorer);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n          groupMaxScore = Math.max(groupMaxScore, fakeScorer.score);\n        }\n        leafCollector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      groupSortValues = new Comparable<?>[comparators.length];\n      for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n        groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             groupMaxScore,\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, groupMaxScore);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","sourceOld":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is &lt;= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  DocValues, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, true); // TODO: disable exact counts?\n      }\n\n      float groupMaxScore = needsScores ? Float.NEGATIVE_INFINITY : Float.NaN;\n      LeafCollector leafCollector = collector.getLeafCollector(og.readerContext);\n      leafCollector.setScorer(fakeScorer);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n          groupMaxScore = Math.max(groupMaxScore, fakeScorer.score);\n        }\n        leafCollector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             groupMaxScore,\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, groupMaxScore);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d3f7ab1a502671bbdb03bcced21e764d2483221","date":1532329609,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int).mjava","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is &lt;= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  DocValues, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, true); // TODO: disable exact counts?\n      }\n\n      float groupMaxScore = needsScores ? Float.NEGATIVE_INFINITY : Float.NaN;\n      LeafCollector leafCollector = collector.getLeafCollector(og.readerContext);\n      leafCollector.setScorer(fakeScorer);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n          groupMaxScore = Math.max(groupMaxScore, fakeScorer.score);\n        }\n        leafCollector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      groupSortValues = new Comparable<?>[comparators.length];\n      for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n        groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             groupMaxScore,\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, groupMaxScore);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","sourceOld":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is &lt;= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  DocValues, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, needsScores, true); // TODO: disable exact counts?\n      }\n\n      float groupMaxScore = needsScores ? Float.NEGATIVE_INFINITY : Float.NaN;\n      LeafCollector leafCollector = collector.getLeafCollector(og.readerContext);\n      leafCollector.setScorer(fakeScorer);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n          groupMaxScore = Math.max(groupMaxScore, fakeScorer.score);\n        }\n        leafCollector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      groupSortValues = new Comparable<?>[comparators.length];\n      for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n        groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             groupMaxScore,\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, groupMaxScore);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int).mjava","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is &lt;= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  DocValues, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, true); // TODO: disable exact counts?\n      }\n\n      float groupMaxScore = needsScores ? Float.NEGATIVE_INFINITY : Float.NaN;\n      LeafCollector leafCollector = collector.getLeafCollector(og.readerContext);\n      leafCollector.setScorer(fakeScorer);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n          groupMaxScore = Math.max(groupMaxScore, fakeScorer.score);\n        }\n        leafCollector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      groupSortValues = new Comparable<?>[comparators.length];\n      for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n        groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             groupMaxScore,\n                                             new TotalHits(og.count, TotalHits.Relation.EQUAL_TO),\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, groupMaxScore);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","sourceOld":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is &lt;= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  DocValues, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, true); // TODO: disable exact counts?\n      }\n\n      float groupMaxScore = needsScores ? Float.NEGATIVE_INFINITY : Float.NaN;\n      LeafCollector leafCollector = collector.getLeafCollector(og.readerContext);\n      leafCollector.setScorer(fakeScorer);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n          groupMaxScore = Math.max(groupMaxScore, fakeScorer.score);\n        }\n        leafCollector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      groupSortValues = new Comparable<?>[comparators.length];\n      for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n        groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             groupMaxScore,\n                                             og.count,\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, groupMaxScore);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe3c6364bed04a73ad0884b05401d80ce96027a9","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int).mjava","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is &lt;= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  DocValues, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, Integer.MAX_VALUE);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, Integer.MAX_VALUE); // TODO: disable exact counts?\n      }\n\n      float groupMaxScore = needsScores ? Float.NEGATIVE_INFINITY : Float.NaN;\n      LeafCollector leafCollector = collector.getLeafCollector(og.readerContext);\n      leafCollector.setScorer(fakeScorer);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n          groupMaxScore = Math.max(groupMaxScore, fakeScorer.score);\n        }\n        leafCollector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      groupSortValues = new Comparable<?>[comparators.length];\n      for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n        groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             groupMaxScore,\n                                             new TotalHits(og.count, TotalHits.Relation.EQUAL_TO),\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, groupMaxScore);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","sourceOld":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is &lt;= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  DocValues, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, true); // TODO: disable exact counts?\n      }\n\n      float groupMaxScore = needsScores ? Float.NEGATIVE_INFINITY : Float.NaN;\n      LeafCollector leafCollector = collector.getLeafCollector(og.readerContext);\n      leafCollector.setScorer(fakeScorer);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n          groupMaxScore = Math.max(groupMaxScore, fakeScorer.score);\n        }\n        leafCollector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      groupSortValues = new Comparable<?>[comparators.length];\n      for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n        groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             groupMaxScore,\n                                             new TotalHits(og.count, TotalHits.Relation.EQUAL_TO),\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, groupMaxScore);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6dbd758f2776b0129f6b3641b6490ddc68d7b0f3","date":1536316907,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int).mjava","pathOld":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int).mjava","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is &lt;= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  DocValues, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final ScoreAndDoc fakeScorer = new ScoreAndDoc();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, Integer.MAX_VALUE);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, Integer.MAX_VALUE); // TODO: disable exact counts?\n      }\n\n      float groupMaxScore = needsScores ? Float.NEGATIVE_INFINITY : Float.NaN;\n      LeafCollector leafCollector = collector.getLeafCollector(og.readerContext);\n      leafCollector.setScorer(fakeScorer);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n          groupMaxScore = Math.max(groupMaxScore, fakeScorer.score);\n        }\n        leafCollector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      groupSortValues = new Comparable<?>[comparators.length];\n      for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n        groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             groupMaxScore,\n                                             new TotalHits(og.count, TotalHits.Relation.EQUAL_TO),\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, groupMaxScore);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","sourceOld":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is &lt;= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  DocValues, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    float maxScore = Float.MIN_VALUE;\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, Integer.MAX_VALUE);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, Integer.MAX_VALUE); // TODO: disable exact counts?\n      }\n\n      float groupMaxScore = needsScores ? Float.NEGATIVE_INFINITY : Float.NaN;\n      LeafCollector leafCollector = collector.getLeafCollector(og.readerContext);\n      leafCollector.setScorer(fakeScorer);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n          groupMaxScore = Math.max(groupMaxScore, fakeScorer.score);\n        }\n        leafCollector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      groupSortValues = new Comparable<?>[comparators.length];\n      for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n        groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      // TODO: we could aggregate scores across children\n      // by Sum/Avg instead of passing NaN:\n      groups[downTo] = new GroupDocs<>(Float.NaN,\n                                             groupMaxScore,\n                                             new TotalHits(og.count, TotalHits.Relation.EQUAL_TO),\n                                             topDocs.scoreDocs,\n                                             null,\n                                             groupSortValues);\n      maxScore = Math.max(maxScore, groupMaxScore);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<>(new TopGroups<>(groupSort.getSort(),\n                                       withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups, maxScore),\n                         totalGroupCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"04c370507e5521b2eb998530736f1c19b851ed5a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6dbd758f2776b0129f6b3641b6490ddc68d7b0f3":["fe3c6364bed04a73ad0884b05401d80ce96027a9"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["1d3f7ab1a502671bbdb03bcced21e764d2483221"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6dbd758f2776b0129f6b3641b6490ddc68d7b0f3"],"fe3c6364bed04a73ad0884b05401d80ce96027a9":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"1d3f7ab1a502671bbdb03bcced21e764d2483221":["04c370507e5521b2eb998530736f1c19b851ed5a"]},"commit2Childs":{"04c370507e5521b2eb998530736f1c19b851ed5a":["1d3f7ab1a502671bbdb03bcced21e764d2483221"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["04c370507e5521b2eb998530736f1c19b851ed5a"],"6dbd758f2776b0129f6b3641b6490ddc68d7b0f3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["fe3c6364bed04a73ad0884b05401d80ce96027a9"],"fe3c6364bed04a73ad0884b05401d80ce96027a9":["6dbd758f2776b0129f6b3641b6490ddc68d7b0f3"],"1d3f7ab1a502671bbdb03bcced21e764d2483221":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}