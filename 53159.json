{"path":"solr/core/src/java/org/apache/solr/cloud/ZkController#preClose().mjava","commits":[{"id":"2dcafe37f7abc7c26e68e7d206bfe7380dd0f2a6","date":1554970874,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#preClose().mjava","pathOld":"/dev/null","sourceNew":"  public void preClose() {\n    this.isClosed = true;\n\n    try {\n      this.removeEphemeralLiveNode();\n    } catch (AlreadyClosedException | SessionExpiredException | KeeperException.ConnectionLossException e) {\n\n    } catch (Exception e) {\n      log.warn(\"Error removing live node. Continuing to close CoreContainer\", e);\n    }\n\n    try {\n      if (getZkClient().getConnectionManager().isConnected()) {\n        log.info(\"Publish this node as DOWN...\");\n        publishNodeAsDown(getNodeName());\n      }\n    } catch (Exception e) {\n      log.warn(\"Error publishing nodes as down. Continuing to close CoreContainer\", e);\n    }\n\n    ExecutorService customThreadPool = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"preCloseThreadPool\"));\n\n    try {\n      synchronized (collectionToTerms) {\n        customThreadPool.submit(() -> collectionToTerms.values().parallelStream().forEach(ZkCollectionTerms::close));\n      }\n\n      customThreadPool.submit(() -> replicateFromLeaders.values().parallelStream().forEach(ReplicateFromLeader::stopReplication));\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(customThreadPool);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb03700c9690d16b15fb4f56f6ec36b128fd894e","date":1586745995,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#preClose().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#preClose().mjava","sourceNew":"  public void preClose() {\n    this.isClosed = true;\n\n    try {\n      this.removeEphemeralLiveNode();\n    } catch (AlreadyClosedException | SessionExpiredException | KeeperException.ConnectionLossException e) {\n\n    } catch (Exception e) {\n      log.warn(\"Error removing live node. Continuing to close CoreContainer\", e);\n    }\n\n    try {\n      if (getZkClient().getConnectionManager().isConnected()) {\n        log.info(\"Publish this node as DOWN...\");\n        publishNodeAsDown(getNodeName());\n      }\n    } catch (Exception e) {\n      log.warn(\"Error publishing nodes as down. Continuing to close CoreContainer\", e);\n    }\n\n    ExecutorService customThreadPool = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrNamedThreadFactory(\"preCloseThreadPool\"));\n\n    try {\n      synchronized (collectionToTerms) {\n        customThreadPool.submit(() -> collectionToTerms.values().parallelStream().forEach(ZkCollectionTerms::close));\n      }\n\n      customThreadPool.submit(() -> replicateFromLeaders.values().parallelStream().forEach(ReplicateFromLeader::stopReplication));\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(customThreadPool);\n    }\n  }\n\n","sourceOld":"  public void preClose() {\n    this.isClosed = true;\n\n    try {\n      this.removeEphemeralLiveNode();\n    } catch (AlreadyClosedException | SessionExpiredException | KeeperException.ConnectionLossException e) {\n\n    } catch (Exception e) {\n      log.warn(\"Error removing live node. Continuing to close CoreContainer\", e);\n    }\n\n    try {\n      if (getZkClient().getConnectionManager().isConnected()) {\n        log.info(\"Publish this node as DOWN...\");\n        publishNodeAsDown(getNodeName());\n      }\n    } catch (Exception e) {\n      log.warn(\"Error publishing nodes as down. Continuing to close CoreContainer\", e);\n    }\n\n    ExecutorService customThreadPool = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"preCloseThreadPool\"));\n\n    try {\n      synchronized (collectionToTerms) {\n        customThreadPool.submit(() -> collectionToTerms.values().parallelStream().forEach(ZkCollectionTerms::close));\n      }\n\n      customThreadPool.submit(() -> replicateFromLeaders.values().parallelStream().forEach(ReplicateFromLeader::stopReplication));\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(customThreadPool);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2dcafe37f7abc7c26e68e7d206bfe7380dd0f2a6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["2dcafe37f7abc7c26e68e7d206bfe7380dd0f2a6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"]},"commit2Childs":{"2dcafe37f7abc7c26e68e7d206bfe7380dd0f2a6":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2dcafe37f7abc7c26e68e7d206bfe7380dd0f2a6"],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}