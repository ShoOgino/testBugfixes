{"path":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final IndexWriter.ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          final int fullDelCount = rld.info.getDelCount() + rld.pendingDeleteCount;\n          assert fullDelCount <= rld.info.docCount;\n          segAllDeletes = fullDelCount == rld.info.docCount;\n        } finally {\n          readerPool.release(reader, false);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final IndexWriter.ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.pendingDeleteCount;\n            assert fullDelCount <= rld.info.docCount;\n            segAllDeletes = fullDelCount == rld.info.docCount;\n          } finally {\n            readerPool.release(reader, false);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final IndexWriter.ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          final int fullDelCount = rld.info.getDelCount() + rld.pendingDeleteCount;\n          assert fullDelCount <= rld.info.docCount;\n          segAllDeletes = fullDelCount == rld.info.docCount;\n        } finally {\n          readerPool.release(reader, false);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final IndexWriter.ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.pendingDeleteCount;\n            assert fullDelCount <= rld.info.docCount;\n            segAllDeletes = fullDelCount == rld.info.docCount;\n          } finally {\n            readerPool.release(reader, false);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae695f21c50b03702b5d0fa2543d5af844bb7cd3","date":1331554994,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n          assert fullDelCount <= rld.info.docCount;\n          segAllDeletes = fullDelCount == rld.info.docCount;\n        } finally {\n          rld.release(reader);\n          readerPool.release(rld);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            assert fullDelCount <= rld.info.docCount;\n            segAllDeletes = fullDelCount == rld.info.docCount;\n          } finally {   \n            rld.release(reader);\n            readerPool.release(rld);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final IndexWriter.ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          final int fullDelCount = rld.info.getDelCount() + rld.pendingDeleteCount;\n          assert fullDelCount <= rld.info.docCount;\n          segAllDeletes = fullDelCount == rld.info.docCount;\n        } finally {\n          readerPool.release(reader, false);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final IndexWriter.ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.pendingDeleteCount;\n            assert fullDelCount <= rld.info.docCount;\n            segAllDeletes = fullDelCount == rld.info.docCount;\n          } finally {\n            readerPool.release(reader, false);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":["9ce667c6d3400b22523701c549c0d35e26da8b46","c19f985e36a65cc969e8e564fe337a0d41512075"],"bugIntro":["7e4c214a1f904dde76f5611b56d4081533055b3b","7e4c214a1f904dde76f5611b56d4081533055b3b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n          assert fullDelCount <= rld.info.docCount;\n          segAllDeletes = fullDelCount == rld.info.docCount;\n        } finally {\n          rld.release(reader);\n          readerPool.release(rld);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            assert fullDelCount <= rld.info.docCount;\n            segAllDeletes = fullDelCount == rld.info.docCount;\n          } finally {   \n            rld.release(reader);\n            readerPool.release(rld);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final IndexWriter.ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          final int fullDelCount = rld.info.getDelCount() + rld.pendingDeleteCount;\n          assert fullDelCount <= rld.info.docCount;\n          segAllDeletes = fullDelCount == rld.info.docCount;\n        } finally {\n          readerPool.release(reader, false);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final IndexWriter.ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.pendingDeleteCount;\n            assert fullDelCount <= rld.info.docCount;\n            segAllDeletes = fullDelCount == rld.info.docCount;\n          } finally {\n            readerPool.release(reader, false);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9d153abcf92dc5329d98571a8c3035df9bd80648","date":1337702630,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfoPerCommit]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfoPerCommit> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfoPerCommit> infos2 = new ArrayList<SegmentInfoPerCommit>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfoPerCommit> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfoPerCommit info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n          assert fullDelCount <= rld.info.info.docCount;\n          segAllDeletes = fullDelCount == rld.info.info.docCount;\n        } finally {\n          rld.release(reader);\n          readerPool.release(rld);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfoPerCommit>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            assert fullDelCount <= rld.info.info.docCount;\n            segAllDeletes = fullDelCount == rld.info.info.docCount;\n          } finally {   \n            rld.release(reader);\n            readerPool.release(rld);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfoPerCommit>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n          assert fullDelCount <= rld.info.docCount;\n          segAllDeletes = fullDelCount == rld.info.docCount;\n        } finally {\n          rld.release(reader);\n          readerPool.release(rld);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            assert fullDelCount <= rld.info.docCount;\n            segAllDeletes = fullDelCount == rld.info.docCount;\n          } finally {   \n            rld.release(reader);\n            readerPool.release(rld);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":5,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfoPerCommit]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyDeletes(IndexWriter.ReaderPool,List[SegmentInfo]).mjava","sourceNew":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfoPerCommit> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfoPerCommit> infos2 = new ArrayList<SegmentInfoPerCommit>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfoPerCommit> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfoPerCommit info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n          assert fullDelCount <= rld.info.info.getDocCount();\n          segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n        } finally {\n          rld.release(reader);\n          readerPool.release(rld);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfoPerCommit>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            assert fullDelCount <= rld.info.info.getDocCount();\n            segAllDeletes = fullDelCount == rld.info.info.getDocCount();\n          } finally {   \n            rld.release(reader);\n            readerPool.release(rld);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfoPerCommit>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","sourceOld":"  /** Resolves the buffered deleted Term/Query/docIDs, into\n   *  actual deleted docIDs in the liveDocs MutableBits for\n   *  each SegmentReader. */\n  public synchronized ApplyDeletesResult applyDeletes(IndexWriter.ReaderPool readerPool, List<SegmentInfo> infos) throws IOException {\n    final long t0 = System.currentTimeMillis();\n\n    if (infos.size() == 0) {\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    assert checkDeleteStats();\n\n    if (!any()) {\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", \"applyDeletes: no deletes; skipping\");\n      }\n      return new ApplyDeletesResult(false, nextGen++, null);\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: infos=\" + infos + \" packetCount=\" + deletes.size());\n    }\n\n    List<SegmentInfo> infos2 = new ArrayList<SegmentInfo>();\n    infos2.addAll(infos);\n    Collections.sort(infos2, sortSegInfoByDelGen);\n\n    CoalescedDeletes coalescedDeletes = null;\n    boolean anyNewDeletes = false;\n\n    int infosIDX = infos2.size()-1;\n    int delIDX = deletes.size()-1;\n\n    List<SegmentInfo> allDeleted = null;\n\n    while (infosIDX >= 0) {\n      //System.out.println(\"BD: cycle delIDX=\" + delIDX + \" infoIDX=\" + infosIDX);\n\n      final FrozenBufferedDeletes packet = delIDX >= 0 ? deletes.get(delIDX) : null;\n      final SegmentInfo info = infos2.get(infosIDX);\n      final long segGen = info.getBufferedDeletesGen();\n\n      if (packet != null && segGen < packet.delGen()) {\n        //System.out.println(\"  coalesce\");\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        if (!packet.isSegmentPrivate) {\n          /*\n           * Only coalesce if we are NOT on a segment private del packet: the segment private del packet\n           * must only applied to segments with the same delGen.  Yet, if a segment is already deleted\n           * from the SI since it had no more documents remaining after some del packets younger than\n           * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been\n           * removed.\n           */\n          coalescedDeletes.update(packet);\n        }\n\n        delIDX--;\n      } else if (packet != null && segGen == packet.delGen()) {\n        assert packet.isSegmentPrivate : \"Packet and Segments deletegen can only match on a segment private del packet gen=\" + segGen;\n        //System.out.println(\"  eq\");\n\n        // Lock order: IW -> BD -> RP\n        assert readerPool.infoIsLive(info);\n        final ReadersAndLiveDocs rld = readerPool.get(info, true);\n        final SegmentReader reader = rld.getReader(IOContext.READ);\n        int delCount = 0;\n        final boolean segAllDeletes;\n        try {\n          if (coalescedDeletes != null) {\n            //System.out.println(\"    del coalesced\");\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n          }\n          //System.out.println(\"    del exact\");\n          // Don't delete by Term here; DocumentsWriterPerThread\n          // already did that on flush:\n          delCount += applyQueryDeletes(packet.queriesIterable(), rld, reader);\n          final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n          assert fullDelCount <= rld.info.docCount;\n          segAllDeletes = fullDelCount == rld.info.docCount;\n        } finally {\n          rld.release(reader);\n          readerPool.release(rld);\n        }\n        anyNewDeletes |= delCount > 0;\n\n        if (segAllDeletes) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<SegmentInfo>();\n          }\n          allDeleted.add(info);\n        }\n\n        if (infoStream.isEnabled(\"BD\")) {\n          infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" segDeletes=[\" + packet + \"]; coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n        }\n\n        if (coalescedDeletes == null) {\n          coalescedDeletes = new CoalescedDeletes();\n        }\n        \n        /*\n         * Since we are on a segment private del packet we must not\n         * update the coalescedDeletes here! We can simply advance to the \n         * next packet and seginfo.\n         */\n        delIDX--;\n        infosIDX--;\n        info.setBufferedDeletesGen(nextGen);\n\n      } else {\n        //System.out.println(\"  gt\");\n\n        if (coalescedDeletes != null) {\n          // Lock order: IW -> BD -> RP\n          assert readerPool.infoIsLive(info);\n          final ReadersAndLiveDocs rld = readerPool.get(info, true);\n          final SegmentReader reader = rld.getReader(IOContext.READ);\n          int delCount = 0;\n          final boolean segAllDeletes;\n          try {\n            delCount += applyTermDeletes(coalescedDeletes.termsIterable(), rld, reader);\n            delCount += applyQueryDeletes(coalescedDeletes.queriesIterable(), rld, reader);\n            final int fullDelCount = rld.info.getDelCount() + rld.getPendingDeleteCount();\n            assert fullDelCount <= rld.info.docCount;\n            segAllDeletes = fullDelCount == rld.info.docCount;\n          } finally {   \n            rld.release(reader);\n            readerPool.release(rld);\n          }\n          anyNewDeletes |= delCount > 0;\n\n          if (segAllDeletes) {\n            if (allDeleted == null) {\n              allDeleted = new ArrayList<SegmentInfo>();\n            }\n            allDeleted.add(info);\n          }\n\n          if (infoStream.isEnabled(\"BD\")) {\n            infoStream.message(\"BD\", \"seg=\" + info + \" segGen=\" + segGen + \" coalesced deletes=[\" + (coalescedDeletes == null ? \"null\" : coalescedDeletes) + \"] newDelCount=\" + delCount + (segAllDeletes ? \" 100% deleted\" : \"\"));\n          }\n        }\n        info.setBufferedDeletesGen(nextGen);\n\n        infosIDX--;\n      }\n    }\n\n    assert checkDeleteStats();\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes took \" + (System.currentTimeMillis()-t0) + \" msec\");\n    }\n    // assert infos != segmentInfos || !any() : \"infos=\" + infos + \" segmentInfos=\" + segmentInfos + \" any=\" + any;\n\n    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"38e3b736c7ca086d61b7dbb841c905ee115490da":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","ae695f21c50b03702b5d0fa2543d5af844bb7cd3"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["ae695f21c50b03702b5d0fa2543d5af844bb7cd3","9d153abcf92dc5329d98571a8c3035df9bd80648"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9d153abcf92dc5329d98571a8c3035df9bd80648":["ae695f21c50b03702b5d0fa2543d5af844bb7cd3"],"ae695f21c50b03702b5d0fa2543d5af844bb7cd3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"]},"commit2Childs":{"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["38e3b736c7ca086d61b7dbb841c905ee115490da","ae695f21c50b03702b5d0fa2543d5af844bb7cd3"],"9d153abcf92dc5329d98571a8c3035df9bd80648":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"ae695f21c50b03702b5d0fa2543d5af844bb7cd3":["38e3b736c7ca086d61b7dbb841c905ee115490da","615ddbd81799980d0fdd95e0238e1c498b6f47b0","9d153abcf92dc5329d98571a8c3035df9bd80648"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["38e3b736c7ca086d61b7dbb841c905ee115490da","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}