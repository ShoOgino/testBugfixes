{"path":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#add(BytesRef).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#add(BytesRef).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/BytesRefHash#add(BytesRef).mjava","sourceNew":"  /**\n   * Adds a new {@link BytesRef}\n   * \n   * @param bytes\n   *          the bytes to hash\n   * @return the ord the given bytes are hashed if there was no mapping for the\n   *         given bytes, otherwise <code>(-(ord)-1)</code>. This guarantees\n   *         that the return value will always be &gt;= 0 if the given bytes\n   *         haven't been hashed before.\n   * \n   * @throws MaxBytesLengthExceededException\n   *           if the given bytes are > 2 +\n   *           {@link ByteBlockPool#BYTE_BLOCK_SIZE}\n   */\n  public int add(BytesRef bytes) {\n    return add(bytes, bytes.hashCode());\n  }\n\n","sourceOld":"  /**\n   * Adds a new {@link BytesRef}\n   * \n   * @param bytes\n   *          the bytes to hash\n   * @return the ord the given bytes are hashed if there was no mapping for the\n   *         given bytes, otherwise <code>(-(ord)-1)</code>. This guarantees\n   *         that the return value will always be &gt;= 0 if the given bytes\n   *         haven't been hashed before.\n   * \n   * @throws MaxBytesLengthExceededException\n   *           if the given bytes are > 2 +\n   *           {@link ByteBlockPool#BYTE_BLOCK_SIZE}\n   */\n  public int add(BytesRef bytes) {\n    return add(bytes, bytes.hashCode());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bbccaf0f052c2a25526a56531803c5ebac7c8f41","date":1363510731,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#add(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#add(BytesRef).mjava","sourceNew":"  /**\n   * Adds a new {@link BytesRef}\n   * \n   * @param bytes\n   *          the bytes to hash\n   * @return the id the given bytes are hashed if there was no mapping for the\n   *         given bytes, otherwise <code>(-(id)-1)</code>. This guarantees\n   *         that the return value will always be &gt;= 0 if the given bytes\n   *         haven't been hashed before.\n   * \n   * @throws MaxBytesLengthExceededException\n   *           if the given bytes are > 2 +\n   *           {@link ByteBlockPool#BYTE_BLOCK_SIZE}\n   */\n  public int add(BytesRef bytes) {\n    return add(bytes, bytes.hashCode());\n  }\n\n","sourceOld":"  /**\n   * Adds a new {@link BytesRef}\n   * \n   * @param bytes\n   *          the bytes to hash\n   * @return the ord the given bytes are hashed if there was no mapping for the\n   *         given bytes, otherwise <code>(-(ord)-1)</code>. This guarantees\n   *         that the return value will always be &gt;= 0 if the given bytes\n   *         haven't been hashed before.\n   * \n   * @throws MaxBytesLengthExceededException\n   *           if the given bytes are > 2 +\n   *           {@link ByteBlockPool#BYTE_BLOCK_SIZE}\n   */\n  public int add(BytesRef bytes) {\n    return add(bytes, bytes.hashCode());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30fe9fa09df804ce770f1b667401a7a7647301ed","date":1397554534,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#add(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#add(BytesRef).mjava","sourceNew":"  /**\n   * Adds a new {@link BytesRef}\n   * \n   * @param bytes\n   *          the bytes to hash\n   * @return the id the given bytes are hashed if there was no mapping for the\n   *         given bytes, otherwise <code>(-(id)-1)</code>. This guarantees\n   *         that the return value will always be &gt;= 0 if the given bytes\n   *         haven't been hashed before.\n   * \n   * @throws MaxBytesLengthExceededException\n   *           if the given bytes are > 2 +\n   *           {@link ByteBlockPool#BYTE_BLOCK_SIZE}\n   */\n  public int add(BytesRef bytes) {\n    assert bytesStart != null : \"Bytesstart is null - not initialized\";\n    final int length = bytes.length;\n    // final position\n    final int hashPos = findHash(bytes);\n    int e = ids[hashPos];\n    \n    if (e == -1) {\n      // new entry\n      final int len2 = 2 + bytes.length;\n      if (len2 + pool.byteUpto > BYTE_BLOCK_SIZE) {\n        if (len2 > BYTE_BLOCK_SIZE) {\n          throw new MaxBytesLengthExceededException(\"bytes can be at most \"\n              + (BYTE_BLOCK_SIZE - 2) + \" in length; got \" + bytes.length);\n        }\n        pool.nextBuffer();\n      }\n      final byte[] buffer = pool.buffer;\n      final int bufferUpto = pool.byteUpto;\n      if (count >= bytesStart.length) {\n        bytesStart = bytesStartArray.grow();\n        assert count < bytesStart.length + 1 : \"count: \" + count + \" len: \"\n            + bytesStart.length;\n      }\n      e = count++;\n\n      bytesStart[e] = bufferUpto + pool.byteOffset;\n\n      // We first encode the length, followed by the\n      // bytes. Length is encoded as vInt, but will consume\n      // 1 or 2 bytes at most (we reject too-long terms,\n      // above).\n      if (length < 128) {\n        // 1 byte to store length\n        buffer[bufferUpto] = (byte) length;\n        pool.byteUpto += length + 1;\n        assert length >= 0: \"Length must be positive: \" + length;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 1,\n            length);\n      } else {\n        // 2 byte to store length\n        buffer[bufferUpto] = (byte) (0x80 | (length & 0x7f));\n        buffer[bufferUpto + 1] = (byte) ((length >> 7) & 0xff);\n        pool.byteUpto += length + 2;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 2,\n            length);\n      }\n      assert ids[hashPos] == -1;\n      ids[hashPos] = e;\n\n      if (count == hashHalfSize) {\n        rehash(2 * hashSize, true);\n      }\n      return e;\n    }\n    return -(e + 1);\n  }\n\n","sourceOld":"  /**\n   * Adds a new {@link BytesRef}\n   * \n   * @param bytes\n   *          the bytes to hash\n   * @return the id the given bytes are hashed if there was no mapping for the\n   *         given bytes, otherwise <code>(-(id)-1)</code>. This guarantees\n   *         that the return value will always be &gt;= 0 if the given bytes\n   *         haven't been hashed before.\n   * \n   * @throws MaxBytesLengthExceededException\n   *           if the given bytes are > 2 +\n   *           {@link ByteBlockPool#BYTE_BLOCK_SIZE}\n   */\n  public int add(BytesRef bytes) {\n    return add(bytes, bytes.hashCode());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b1eb427f2c6beed80d1724555fc1db003ccf3030","date":1417137397,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#add(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/BytesRefHash#add(BytesRef).mjava","sourceNew":"  /**\n   * Adds a new {@link BytesRef}\n   * \n   * @param bytes\n   *          the bytes to hash\n   * @return the id the given bytes are hashed if there was no mapping for the\n   *         given bytes, otherwise <code>(-(id)-1)</code>. This guarantees\n   *         that the return value will always be &gt;= 0 if the given bytes\n   *         haven't been hashed before.\n   * \n   * @throws MaxBytesLengthExceededException\n   *           if the given bytes are {@code > 2 +}\n   *           {@link ByteBlockPool#BYTE_BLOCK_SIZE}\n   */\n  public int add(BytesRef bytes) {\n    assert bytesStart != null : \"Bytesstart is null - not initialized\";\n    final int length = bytes.length;\n    // final position\n    final int hashPos = findHash(bytes);\n    int e = ids[hashPos];\n    \n    if (e == -1) {\n      // new entry\n      final int len2 = 2 + bytes.length;\n      if (len2 + pool.byteUpto > BYTE_BLOCK_SIZE) {\n        if (len2 > BYTE_BLOCK_SIZE) {\n          throw new MaxBytesLengthExceededException(\"bytes can be at most \"\n              + (BYTE_BLOCK_SIZE - 2) + \" in length; got \" + bytes.length);\n        }\n        pool.nextBuffer();\n      }\n      final byte[] buffer = pool.buffer;\n      final int bufferUpto = pool.byteUpto;\n      if (count >= bytesStart.length) {\n        bytesStart = bytesStartArray.grow();\n        assert count < bytesStart.length + 1 : \"count: \" + count + \" len: \"\n            + bytesStart.length;\n      }\n      e = count++;\n\n      bytesStart[e] = bufferUpto + pool.byteOffset;\n\n      // We first encode the length, followed by the\n      // bytes. Length is encoded as vInt, but will consume\n      // 1 or 2 bytes at most (we reject too-long terms,\n      // above).\n      if (length < 128) {\n        // 1 byte to store length\n        buffer[bufferUpto] = (byte) length;\n        pool.byteUpto += length + 1;\n        assert length >= 0: \"Length must be positive: \" + length;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 1,\n            length);\n      } else {\n        // 2 byte to store length\n        buffer[bufferUpto] = (byte) (0x80 | (length & 0x7f));\n        buffer[bufferUpto + 1] = (byte) ((length >> 7) & 0xff);\n        pool.byteUpto += length + 2;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 2,\n            length);\n      }\n      assert ids[hashPos] == -1;\n      ids[hashPos] = e;\n\n      if (count == hashHalfSize) {\n        rehash(2 * hashSize, true);\n      }\n      return e;\n    }\n    return -(e + 1);\n  }\n\n","sourceOld":"  /**\n   * Adds a new {@link BytesRef}\n   * \n   * @param bytes\n   *          the bytes to hash\n   * @return the id the given bytes are hashed if there was no mapping for the\n   *         given bytes, otherwise <code>(-(id)-1)</code>. This guarantees\n   *         that the return value will always be &gt;= 0 if the given bytes\n   *         haven't been hashed before.\n   * \n   * @throws MaxBytesLengthExceededException\n   *           if the given bytes are > 2 +\n   *           {@link ByteBlockPool#BYTE_BLOCK_SIZE}\n   */\n  public int add(BytesRef bytes) {\n    assert bytesStart != null : \"Bytesstart is null - not initialized\";\n    final int length = bytes.length;\n    // final position\n    final int hashPos = findHash(bytes);\n    int e = ids[hashPos];\n    \n    if (e == -1) {\n      // new entry\n      final int len2 = 2 + bytes.length;\n      if (len2 + pool.byteUpto > BYTE_BLOCK_SIZE) {\n        if (len2 > BYTE_BLOCK_SIZE) {\n          throw new MaxBytesLengthExceededException(\"bytes can be at most \"\n              + (BYTE_BLOCK_SIZE - 2) + \" in length; got \" + bytes.length);\n        }\n        pool.nextBuffer();\n      }\n      final byte[] buffer = pool.buffer;\n      final int bufferUpto = pool.byteUpto;\n      if (count >= bytesStart.length) {\n        bytesStart = bytesStartArray.grow();\n        assert count < bytesStart.length + 1 : \"count: \" + count + \" len: \"\n            + bytesStart.length;\n      }\n      e = count++;\n\n      bytesStart[e] = bufferUpto + pool.byteOffset;\n\n      // We first encode the length, followed by the\n      // bytes. Length is encoded as vInt, but will consume\n      // 1 or 2 bytes at most (we reject too-long terms,\n      // above).\n      if (length < 128) {\n        // 1 byte to store length\n        buffer[bufferUpto] = (byte) length;\n        pool.byteUpto += length + 1;\n        assert length >= 0: \"Length must be positive: \" + length;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 1,\n            length);\n      } else {\n        // 2 byte to store length\n        buffer[bufferUpto] = (byte) (0x80 | (length & 0x7f));\n        buffer[bufferUpto + 1] = (byte) ((length >> 7) & 0xff);\n        pool.byteUpto += length + 2;\n        System.arraycopy(bytes.bytes, bytes.offset, buffer, bufferUpto + 2,\n            length);\n      }\n      assert ids[hashPos] == -1;\n      ids[hashPos] = e;\n\n      if (count == hashHalfSize) {\n        rehash(2 * hashSize, true);\n      }\n      return e;\n    }\n    return -(e + 1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b1eb427f2c6beed80d1724555fc1db003ccf3030":["30fe9fa09df804ce770f1b667401a7a7647301ed"],"30fe9fa09df804ce770f1b667401a7a7647301ed":["bbccaf0f052c2a25526a56531803c5ebac7c8f41"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bbccaf0f052c2a25526a56531803c5ebac7c8f41":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b1eb427f2c6beed80d1724555fc1db003ccf3030"]},"commit2Childs":{"b1eb427f2c6beed80d1724555fc1db003ccf3030":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"30fe9fa09df804ce770f1b667401a7a7647301ed":["b1eb427f2c6beed80d1724555fc1db003ccf3030"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["bbccaf0f052c2a25526a56531803c5ebac7c8f41"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"bbccaf0f052c2a25526a56531803c5ebac7c8f41":["30fe9fa09df804ce770f1b667401a7a7647301ed"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}