{"path":"lucene/core/src/java/org/apache/lucene/search/SortRescorer#explain(IndexSearcher,Explanation,int).mjava","commits":[{"id":"222ff577a0e1b2399d3151966bf561ecd7a0b7d0","date":1395575041,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SortRescorer#explain(IndexSearcher,Explanation,int).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Explanation explain(IndexSearcher searcher, Explanation firstPassExplanation, int docID) throws IOException {\n    TopDocs oneHit = new TopDocs(1, new ScoreDoc[] {new ScoreDoc(docID, firstPassExplanation.getValue())});\n    TopDocs hits = rescore(searcher, oneHit, 1);\n    assert hits.totalHits == 1;\n\n    // TODO: if we could ask the Sort to explain itself then\n    // we wouldn't need the separate ExpressionRescorer...\n    Explanation result = new Explanation(0.0f, \"sort field values for sort=\" + sort.toString());\n\n    // Add first pass:\n    Explanation first = new Explanation(firstPassExplanation.getValue(), \"first pass score\");\n    first.addDetail(firstPassExplanation);\n    result.addDetail(first);\n\n    FieldDoc fieldDoc = (FieldDoc) hits.scoreDocs[0];\n\n    // Add sort values:\n    SortField[] sortFields = sort.getSort();\n    for(int i=0;i<sortFields.length;i++) {\n      result.addDetail(new Explanation(0.0f, \"sort field \" + sortFields[i].toString() + \" value=\" + fieldDoc.fields[i]));\n    }\n\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ff3285c7b2387faedef0ffb24db20c4cbbd9fd91","date":1429620941,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SortRescorer#explain(IndexSearcher,Explanation,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SortRescorer#explain(IndexSearcher,Explanation,int).mjava","sourceNew":"  @Override\n  public Explanation explain(IndexSearcher searcher, Explanation firstPassExplanation, int docID) throws IOException {\n    TopDocs oneHit = new TopDocs(1, new ScoreDoc[] {new ScoreDoc(docID, firstPassExplanation.getValue())});\n    TopDocs hits = rescore(searcher, oneHit, 1);\n    assert hits.totalHits == 1;\n\n    List<Explanation> subs = new ArrayList<>();\n\n    // Add first pass:\n    Explanation first = Explanation.match(firstPassExplanation.getValue(), \"first pass score\", firstPassExplanation);\n    subs.add(first);\n\n    FieldDoc fieldDoc = (FieldDoc) hits.scoreDocs[0];\n\n    // Add sort values:\n    SortField[] sortFields = sort.getSort();\n    for(int i=0;i<sortFields.length;i++) {\n      subs.add(Explanation.match(0.0f, \"sort field \" + sortFields[i].toString() + \" value=\" + fieldDoc.fields[i]));\n    }\n\n    // TODO: if we could ask the Sort to explain itself then\n    // we wouldn't need the separate ExpressionRescorer...\n    return Explanation.match(0.0f, \"sort field values for sort=\" + sort.toString(), subs);\n  }\n\n","sourceOld":"  @Override\n  public Explanation explain(IndexSearcher searcher, Explanation firstPassExplanation, int docID) throws IOException {\n    TopDocs oneHit = new TopDocs(1, new ScoreDoc[] {new ScoreDoc(docID, firstPassExplanation.getValue())});\n    TopDocs hits = rescore(searcher, oneHit, 1);\n    assert hits.totalHits == 1;\n\n    // TODO: if we could ask the Sort to explain itself then\n    // we wouldn't need the separate ExpressionRescorer...\n    Explanation result = new Explanation(0.0f, \"sort field values for sort=\" + sort.toString());\n\n    // Add first pass:\n    Explanation first = new Explanation(firstPassExplanation.getValue(), \"first pass score\");\n    first.addDetail(firstPassExplanation);\n    result.addDetail(first);\n\n    FieldDoc fieldDoc = (FieldDoc) hits.scoreDocs[0];\n\n    // Add sort values:\n    SortField[] sortFields = sort.getSort();\n    for(int i=0;i<sortFields.length;i++) {\n      result.addDetail(new Explanation(0.0f, \"sort field \" + sortFields[i].toString() + \" value=\" + fieldDoc.fields[i]));\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b8e3fe8a32614e52f7d9fd491b9faab852fbb4bf","date":1514891219,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SortRescorer#explain(IndexSearcher,Explanation,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SortRescorer#explain(IndexSearcher,Explanation,int).mjava","sourceNew":"  @Override\n  public Explanation explain(IndexSearcher searcher, Explanation firstPassExplanation, int docID) throws IOException {\n    TopDocs oneHit = new TopDocs(1, new ScoreDoc[] {new ScoreDoc(docID, firstPassExplanation.getValue().floatValue())});\n    TopDocs hits = rescore(searcher, oneHit, 1);\n    assert hits.totalHits == 1;\n\n    List<Explanation> subs = new ArrayList<>();\n\n    // Add first pass:\n    Explanation first = Explanation.match(firstPassExplanation.getValue(), \"first pass score\", firstPassExplanation);\n    subs.add(first);\n\n    FieldDoc fieldDoc = (FieldDoc) hits.scoreDocs[0];\n\n    // Add sort values:\n    SortField[] sortFields = sort.getSort();\n    for(int i=0;i<sortFields.length;i++) {\n      subs.add(Explanation.match(0.0f, \"sort field \" + sortFields[i].toString() + \" value=\" + fieldDoc.fields[i]));\n    }\n\n    // TODO: if we could ask the Sort to explain itself then\n    // we wouldn't need the separate ExpressionRescorer...\n    return Explanation.match(0.0f, \"sort field values for sort=\" + sort.toString(), subs);\n  }\n\n","sourceOld":"  @Override\n  public Explanation explain(IndexSearcher searcher, Explanation firstPassExplanation, int docID) throws IOException {\n    TopDocs oneHit = new TopDocs(1, new ScoreDoc[] {new ScoreDoc(docID, firstPassExplanation.getValue())});\n    TopDocs hits = rescore(searcher, oneHit, 1);\n    assert hits.totalHits == 1;\n\n    List<Explanation> subs = new ArrayList<>();\n\n    // Add first pass:\n    Explanation first = Explanation.match(firstPassExplanation.getValue(), \"first pass score\", firstPassExplanation);\n    subs.add(first);\n\n    FieldDoc fieldDoc = (FieldDoc) hits.scoreDocs[0];\n\n    // Add sort values:\n    SortField[] sortFields = sort.getSort();\n    for(int i=0;i<sortFields.length;i++) {\n      subs.add(Explanation.match(0.0f, \"sort field \" + sortFields[i].toString() + \" value=\" + fieldDoc.fields[i]));\n    }\n\n    // TODO: if we could ask the Sort to explain itself then\n    // we wouldn't need the separate ExpressionRescorer...\n    return Explanation.match(0.0f, \"sort field values for sort=\" + sort.toString(), subs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SortRescorer#explain(IndexSearcher,Explanation,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SortRescorer#explain(IndexSearcher,Explanation,int).mjava","sourceNew":"  @Override\n  public Explanation explain(IndexSearcher searcher, Explanation firstPassExplanation, int docID) throws IOException {\n    TopDocs oneHit = new TopDocs(new TotalHits(1, Relation.EQUAL_TO), new ScoreDoc[] {new ScoreDoc(docID, firstPassExplanation.getValue().floatValue())});\n    TopDocs hits = rescore(searcher, oneHit, 1);\n    assert hits.totalHits.value == 1;\n\n    List<Explanation> subs = new ArrayList<>();\n\n    // Add first pass:\n    Explanation first = Explanation.match(firstPassExplanation.getValue(), \"first pass score\", firstPassExplanation);\n    subs.add(first);\n\n    FieldDoc fieldDoc = (FieldDoc) hits.scoreDocs[0];\n\n    // Add sort values:\n    SortField[] sortFields = sort.getSort();\n    for(int i=0;i<sortFields.length;i++) {\n      subs.add(Explanation.match(0.0f, \"sort field \" + sortFields[i].toString() + \" value=\" + fieldDoc.fields[i]));\n    }\n\n    // TODO: if we could ask the Sort to explain itself then\n    // we wouldn't need the separate ExpressionRescorer...\n    return Explanation.match(0.0f, \"sort field values for sort=\" + sort.toString(), subs);\n  }\n\n","sourceOld":"  @Override\n  public Explanation explain(IndexSearcher searcher, Explanation firstPassExplanation, int docID) throws IOException {\n    TopDocs oneHit = new TopDocs(1, new ScoreDoc[] {new ScoreDoc(docID, firstPassExplanation.getValue().floatValue())});\n    TopDocs hits = rescore(searcher, oneHit, 1);\n    assert hits.totalHits == 1;\n\n    List<Explanation> subs = new ArrayList<>();\n\n    // Add first pass:\n    Explanation first = Explanation.match(firstPassExplanation.getValue(), \"first pass score\", firstPassExplanation);\n    subs.add(first);\n\n    FieldDoc fieldDoc = (FieldDoc) hits.scoreDocs[0];\n\n    // Add sort values:\n    SortField[] sortFields = sort.getSort();\n    for(int i=0;i<sortFields.length;i++) {\n      subs.add(Explanation.match(0.0f, \"sort field \" + sortFields[i].toString() + \" value=\" + fieldDoc.fields[i]));\n    }\n\n    // TODO: if we could ask the Sort to explain itself then\n    // we wouldn't need the separate ExpressionRescorer...\n    return Explanation.match(0.0f, \"sort field values for sort=\" + sort.toString(), subs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"222ff577a0e1b2399d3151966bf561ecd7a0b7d0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b8e3fe8a32614e52f7d9fd491b9faab852fbb4bf":["ff3285c7b2387faedef0ffb24db20c4cbbd9fd91"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"83788ad129a5154d5c6562c4e8ce3db48793aada":["b8e3fe8a32614e52f7d9fd491b9faab852fbb4bf"],"ff3285c7b2387faedef0ffb24db20c4cbbd9fd91":["222ff577a0e1b2399d3151966bf561ecd7a0b7d0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["83788ad129a5154d5c6562c4e8ce3db48793aada"]},"commit2Childs":{"222ff577a0e1b2399d3151966bf561ecd7a0b7d0":["ff3285c7b2387faedef0ffb24db20c4cbbd9fd91"],"b8e3fe8a32614e52f7d9fd491b9faab852fbb4bf":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["222ff577a0e1b2399d3151966bf561ecd7a0b7d0"],"ff3285c7b2387faedef0ffb24db20c4cbbd9fd91":["b8e3fe8a32614e52f7d9fd491b9faab852fbb4bf"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}