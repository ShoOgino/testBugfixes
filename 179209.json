{"path":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","commits":[{"id":"c7e79e31f55cbb444e3023d430a340658755aa31","date":1357666399,"type":1,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin].ExtendedSolrQueryParser#getQuery().mjava","sourceNew":"    private Query getQuery() {\n      try {\n        \n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query = super.getFieldQuery(field, val, type == QType.PHRASE);\n            // A BooleanQuery is only possible from getFieldQuery if it came from\n            // a single whitespace separated term. In this case, check the coordination\n            // factor on the query: if its enabled, that means we aren't a set of synonyms\n            // but instead multiple terms from one whitespace-separated term, we must\n            // apply minShouldMatch here so that it works correctly with other things\n            // like aliasing.\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              if (!bq.isCoordDisabled()) {\n                SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch);\n              }\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              ((PhraseQuery)query).setSlop(slop);\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery pq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTermArrays().size() < minClauseSize) return null;\n              ((MultiPhraseQuery)query).setSlop(slop);\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n        \n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","sourceOld":"    private Query getQuery() {\n      try {\n\n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query = super.getFieldQuery(field, val, type == QType.PHRASE);\n            // A BooleanQuery is only possible from getFieldQuery if it came from\n            // a single whitespace separated term. In this case, check the coordination\n            // factor on the query: if its enabled, that means we aren't a set of synonyms\n            // but instead multiple terms from one whitespace-separated term, we must\n            // apply minShouldMatch here so that it works correctly with other things\n            // like aliasing.\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              if (!bq.isCoordDisabled()) {\n                SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch);\n              }\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              ((PhraseQuery)query).setSlop(slop);\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery pq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTermArrays().size() < minClauseSize) return null;\n              ((MultiPhraseQuery)query).setSlop(slop);\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n\n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4e6354dd7c71fe122926fc53d7d29f715b1283db","date":1357915185,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin].ExtendedSolrQueryParser#getQuery().mjava","sourceNew":"    private Query getQuery() {\n      try {\n        \n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query = super.getFieldQuery(field, val, type == QType.PHRASE);\n            // A BooleanQuery is only possible from getFieldQuery if it came from\n            // a single whitespace separated term. In this case, check the coordination\n            // factor on the query: if its enabled, that means we aren't a set of synonyms\n            // but instead multiple terms from one whitespace-separated term, we must\n            // apply minShouldMatch here so that it works correctly with other things\n            // like aliasing.\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              if (!bq.isCoordDisabled()) {\n                SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch);\n              }\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              ((PhraseQuery)query).setSlop(slop);\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery pq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTermArrays().size() < minClauseSize) return null;\n              ((MultiPhraseQuery)query).setSlop(slop);\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n        \n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","sourceOld":"    private Query getQuery() {\n      try {\n\n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query = super.getFieldQuery(field, val, type == QType.PHRASE);\n            // A BooleanQuery is only possible from getFieldQuery if it came from\n            // a single whitespace separated term. In this case, check the coordination\n            // factor on the query: if its enabled, that means we aren't a set of synonyms\n            // but instead multiple terms from one whitespace-separated term, we must\n            // apply minShouldMatch here so that it works correctly with other things\n            // like aliasing.\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              if (!bq.isCoordDisabled()) {\n                SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch);\n              }\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              ((PhraseQuery)query).setSlop(slop);\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery pq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTermArrays().size() < minClauseSize) return null;\n              ((MultiPhraseQuery)query).setSlop(slop);\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n\n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1","date":1419400138,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","sourceNew":"    private Query getQuery() {\n      try {\n        \n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query = super.getFieldQuery(field, val, type == QType.PHRASE);\n            // A BooleanQuery is only possible from getFieldQuery if it came from\n            // a single whitespace separated term. In this case, check the coordination\n            // factor on the query: if it's enabled, that means we aren't a set of synonyms\n            // but instead multiple terms from one whitespace-separated term, we must\n            // apply minShouldMatch here so that it works correctly with other things\n            // like aliasing.\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              if (!bq.isCoordDisabled()) {\n                SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch);\n              }\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              ((PhraseQuery)query).setSlop(slop);\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery pq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTermArrays().size() < minClauseSize) return null;\n              ((MultiPhraseQuery)query).setSlop(slop);\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n        \n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","sourceOld":"    private Query getQuery() {\n      try {\n        \n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query = super.getFieldQuery(field, val, type == QType.PHRASE);\n            // A BooleanQuery is only possible from getFieldQuery if it came from\n            // a single whitespace separated term. In this case, check the coordination\n            // factor on the query: if its enabled, that means we aren't a set of synonyms\n            // but instead multiple terms from one whitespace-separated term, we must\n            // apply minShouldMatch here so that it works correctly with other things\n            // like aliasing.\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              if (!bq.isCoordDisabled()) {\n                SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch);\n              }\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              ((PhraseQuery)query).setSlop(slop);\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery pq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTermArrays().size() < minClauseSize) return null;\n              ((MultiPhraseQuery)query).setSlop(slop);\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n        \n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9e1499c5d26c936238506df90a3c02c76707722","date":1434449920,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","sourceNew":"    private Query getQuery() {\n      try {\n        \n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query = super.getFieldQuery(field, val, type == QType.PHRASE);\n            // A BooleanQuery is only possible from getFieldQuery if it came from\n            // a single whitespace separated term. In this case, check the coordination\n            // factor on the query: if it's enabled, that means we aren't a set of synonyms\n            // but instead multiple terms from one whitespace-separated term, we must\n            // apply minShouldMatch here so that it works correctly with other things\n            // like aliasing.\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              if (!bq.isCoordDisabled()) {\n                SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch);\n              }\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              PhraseQuery.Builder builder = new PhraseQuery.Builder();\n              Term[] terms = pq.getTerms();\n              int[] positions = pq.getPositions();\n              for (int i = 0; i < terms.length; ++i) {\n                builder.add(terms[i], positions[i]);\n              }\n              builder.setSlop(slop);\n              query = builder.build();\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery pq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTermArrays().size() < minClauseSize) return null;\n              ((MultiPhraseQuery)query).setSlop(slop);\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n        \n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","sourceOld":"    private Query getQuery() {\n      try {\n        \n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query = super.getFieldQuery(field, val, type == QType.PHRASE);\n            // A BooleanQuery is only possible from getFieldQuery if it came from\n            // a single whitespace separated term. In this case, check the coordination\n            // factor on the query: if it's enabled, that means we aren't a set of synonyms\n            // but instead multiple terms from one whitespace-separated term, we must\n            // apply minShouldMatch here so that it works correctly with other things\n            // like aliasing.\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              if (!bq.isCoordDisabled()) {\n                SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch);\n              }\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              ((PhraseQuery)query).setSlop(slop);\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery pq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTermArrays().size() < minClauseSize) return null;\n              ((MultiPhraseQuery)query).setSlop(slop);\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n        \n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3f68d01cf19df971dcdcb05e30247f4ad7ec9747","date":1434611645,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","sourceNew":"    private Query getQuery() {\n      try {\n        \n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query = super.getFieldQuery(field, val, type == QType.PHRASE);\n            // A BooleanQuery is only possible from getFieldQuery if it came from\n            // a single whitespace separated term. In this case, check the coordination\n            // factor on the query: if it's enabled, that means we aren't a set of synonyms\n            // but instead multiple terms from one whitespace-separated term, we must\n            // apply minShouldMatch here so that it works correctly with other things\n            // like aliasing.\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              if (!bq.isCoordDisabled()) {\n                query = SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch);\n              }\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              PhraseQuery.Builder builder = new PhraseQuery.Builder();\n              Term[] terms = pq.getTerms();\n              int[] positions = pq.getPositions();\n              for (int i = 0; i < terms.length; ++i) {\n                builder.add(terms[i], positions[i]);\n              }\n              builder.setSlop(slop);\n              query = builder.build();\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery pq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTermArrays().size() < minClauseSize) return null;\n              ((MultiPhraseQuery)query).setSlop(slop);\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n        \n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","sourceOld":"    private Query getQuery() {\n      try {\n        \n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query = super.getFieldQuery(field, val, type == QType.PHRASE);\n            // A BooleanQuery is only possible from getFieldQuery if it came from\n            // a single whitespace separated term. In this case, check the coordination\n            // factor on the query: if it's enabled, that means we aren't a set of synonyms\n            // but instead multiple terms from one whitespace-separated term, we must\n            // apply minShouldMatch here so that it works correctly with other things\n            // like aliasing.\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              if (!bq.isCoordDisabled()) {\n                SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch);\n              }\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              PhraseQuery.Builder builder = new PhraseQuery.Builder();\n              Term[] terms = pq.getTerms();\n              int[] positions = pq.getPositions();\n              for (int i = 0; i < terms.length; ++i) {\n                builder.add(terms[i], positions[i]);\n              }\n              builder.setSlop(slop);\n              query = builder.build();\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery pq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTermArrays().size() < minClauseSize) return null;\n              ((MultiPhraseQuery)query).setSlop(slop);\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n        \n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","bugFix":null,"bugIntro":["3ca415055c1401a2359adfb8f5d3fbf3887f95d7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3ca415055c1401a2359adfb8f5d3fbf3887f95d7","date":1438554679,"type":3,"author":"Jan HÃ¸ydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","sourceNew":"    private Query getQuery() {\n      try {\n        \n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query = super.getFieldQuery(field, val, type == QType.PHRASE);\n            // A BooleanQuery is only possible from getFieldQuery if it came from\n            // a single whitespace separated term. In this case, check the coordination\n            // factor on the query: if it's enabled, that means we aren't a set of synonyms\n            // but instead multiple terms from one whitespace-separated term, we must\n            // apply minShouldMatch here so that it works correctly with other things\n            // like aliasing.\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              if (!bq.isCoordDisabled()) {\n                query = SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch, false);\n              }\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              PhraseQuery.Builder builder = new PhraseQuery.Builder();\n              Term[] terms = pq.getTerms();\n              int[] positions = pq.getPositions();\n              for (int i = 0; i < terms.length; ++i) {\n                builder.add(terms[i], positions[i]);\n              }\n              builder.setSlop(slop);\n              query = builder.build();\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery pq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTermArrays().size() < minClauseSize) return null;\n              ((MultiPhraseQuery)query).setSlop(slop);\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n        \n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","sourceOld":"    private Query getQuery() {\n      try {\n        \n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query = super.getFieldQuery(field, val, type == QType.PHRASE);\n            // A BooleanQuery is only possible from getFieldQuery if it came from\n            // a single whitespace separated term. In this case, check the coordination\n            // factor on the query: if it's enabled, that means we aren't a set of synonyms\n            // but instead multiple terms from one whitespace-separated term, we must\n            // apply minShouldMatch here so that it works correctly with other things\n            // like aliasing.\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              if (!bq.isCoordDisabled()) {\n                query = SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch);\n              }\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              PhraseQuery.Builder builder = new PhraseQuery.Builder();\n              Term[] terms = pq.getTerms();\n              int[] positions = pq.getPositions();\n              for (int i = 0; i < terms.length; ++i) {\n                builder.add(terms[i], positions[i]);\n              }\n              builder.setSlop(slop);\n              query = builder.build();\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery pq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTermArrays().size() < minClauseSize) return null;\n              ((MultiPhraseQuery)query).setSlop(slop);\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n        \n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","bugFix":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"92b4a131f1796dd57cc6698aae3d589d32a29deb","date":1457087316,"type":3,"author":"Luc Vanlerberghe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","sourceNew":"    private Query getQuery() {\n      try {\n        \n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query = super.getFieldQuery(field, val, type == QType.PHRASE);\n            // A BooleanQuery is only possible from getFieldQuery if it came from\n            // a single whitespace separated term. In this case, check the coordination\n            // factor on the query: if it's enabled, that means we aren't a set of synonyms\n            // but instead multiple terms from one whitespace-separated term, we must\n            // apply minShouldMatch here so that it works correctly with other things\n            // like aliasing.\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              if (!bq.isCoordDisabled()) {\n                query = SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch, false);\n              }\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              PhraseQuery.Builder builder = new PhraseQuery.Builder();\n              Term[] terms = pq.getTerms();\n              int[] positions = pq.getPositions();\n              for (int i = 0; i < terms.length; ++i) {\n                builder.add(terms[i], positions[i]);\n              }\n              builder.setSlop(slop);\n              query = builder.build();\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery mpq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && mpq.getTermArrays().length < minClauseSize) return null;\n              if (slop != mpq.getSlop()) {\n                query = new MultiPhraseQuery.Builder(mpq).setSlop(slop).build();\n              }\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n        \n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","sourceOld":"    private Query getQuery() {\n      try {\n        \n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query = super.getFieldQuery(field, val, type == QType.PHRASE);\n            // A BooleanQuery is only possible from getFieldQuery if it came from\n            // a single whitespace separated term. In this case, check the coordination\n            // factor on the query: if it's enabled, that means we aren't a set of synonyms\n            // but instead multiple terms from one whitespace-separated term, we must\n            // apply minShouldMatch here so that it works correctly with other things\n            // like aliasing.\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              if (!bq.isCoordDisabled()) {\n                query = SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch, false);\n              }\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              PhraseQuery.Builder builder = new PhraseQuery.Builder();\n              Term[] terms = pq.getTerms();\n              int[] positions = pq.getPositions();\n              for (int i = 0; i < terms.length; ++i) {\n                builder.add(terms[i], positions[i]);\n              }\n              builder.setSlop(slop);\n              query = builder.build();\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery pq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTermArrays().size() < minClauseSize) return null;\n              ((MultiPhraseQuery)query).setSlop(slop);\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n        \n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","sourceNew":"    private Query getQuery() {\n      try {\n        \n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query = super.getFieldQuery(field, val, type == QType.PHRASE);\n            // A BooleanQuery is only possible from getFieldQuery if it came from\n            // a single whitespace separated term. In this case, check the coordination\n            // factor on the query: if it's enabled, that means we aren't a set of synonyms\n            // but instead multiple terms from one whitespace-separated term, we must\n            // apply minShouldMatch here so that it works correctly with other things\n            // like aliasing.\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              if (!bq.isCoordDisabled()) {\n                query = SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch, false);\n              }\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              PhraseQuery.Builder builder = new PhraseQuery.Builder();\n              Term[] terms = pq.getTerms();\n              int[] positions = pq.getPositions();\n              for (int i = 0; i < terms.length; ++i) {\n                builder.add(terms[i], positions[i]);\n              }\n              builder.setSlop(slop);\n              query = builder.build();\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery mpq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && mpq.getTermArrays().length < minClauseSize) return null;\n              if (slop != mpq.getSlop()) {\n                query = new MultiPhraseQuery.Builder(mpq).setSlop(slop).build();\n              }\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n        \n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","sourceOld":"    private Query getQuery() {\n      try {\n        \n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query = super.getFieldQuery(field, val, type == QType.PHRASE);\n            // A BooleanQuery is only possible from getFieldQuery if it came from\n            // a single whitespace separated term. In this case, check the coordination\n            // factor on the query: if it's enabled, that means we aren't a set of synonyms\n            // but instead multiple terms from one whitespace-separated term, we must\n            // apply minShouldMatch here so that it works correctly with other things\n            // like aliasing.\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              if (!bq.isCoordDisabled()) {\n                query = SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch, false);\n              }\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              PhraseQuery.Builder builder = new PhraseQuery.Builder();\n              Term[] terms = pq.getTerms();\n              int[] positions = pq.getPositions();\n              for (int i = 0; i < terms.length; ++i) {\n                builder.add(terms[i], positions[i]);\n              }\n              builder.setSlop(slop);\n              query = builder.build();\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery pq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTermArrays().size() < minClauseSize) return null;\n              ((MultiPhraseQuery)query).setSlop(slop);\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n        \n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c8a0e442f7b61f811680273b25da95994a724466","date":1467878549,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","sourceNew":"    private Query getQuery() {\n      try {\n        \n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query = super.getFieldQuery(field, val, type == QType.PHRASE);\n            // Boolean query on a whitespace-separated string\n            // If these were synonyms we would have a SynonymQuery\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              query = SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch, false);\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              PhraseQuery.Builder builder = new PhraseQuery.Builder();\n              Term[] terms = pq.getTerms();\n              int[] positions = pq.getPositions();\n              for (int i = 0; i < terms.length; ++i) {\n                builder.add(terms[i], positions[i]);\n              }\n              builder.setSlop(slop);\n              query = builder.build();\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery mpq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && mpq.getTermArrays().length < minClauseSize) return null;\n              if (slop != mpq.getSlop()) {\n                query = new MultiPhraseQuery.Builder(mpq).setSlop(slop).build();\n              }\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n        \n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","sourceOld":"    private Query getQuery() {\n      try {\n        \n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query = super.getFieldQuery(field, val, type == QType.PHRASE);\n            // A BooleanQuery is only possible from getFieldQuery if it came from\n            // a single whitespace separated term. In this case, check the coordination\n            // factor on the query: if it's enabled, that means we aren't a set of synonyms\n            // but instead multiple terms from one whitespace-separated term, we must\n            // apply minShouldMatch here so that it works correctly with other things\n            // like aliasing.\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              if (!bq.isCoordDisabled()) {\n                query = SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch, false);\n              }\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              PhraseQuery.Builder builder = new PhraseQuery.Builder();\n              Term[] terms = pq.getTerms();\n              int[] positions = pq.getPositions();\n              for (int i = 0; i < terms.length; ++i) {\n                builder.add(terms[i], positions[i]);\n              }\n              builder.setSlop(slop);\n              query = builder.build();\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery mpq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && mpq.getTermArrays().length < minClauseSize) return null;\n              if (slop != mpq.getSlop()) {\n                query = new MultiPhraseQuery.Builder(mpq).setSlop(slop).build();\n              }\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n        \n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","bugFix":null,"bugIntro":["c7a49f8dc38a90fbd6c7edac0845981e0b0a7f21"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","sourceNew":"    private Query getQuery() {\n      try {\n        \n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query = super.getFieldQuery(field, val, type == QType.PHRASE);\n            // Boolean query on a whitespace-separated string\n            // If these were synonyms we would have a SynonymQuery\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              query = SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch, false);\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              PhraseQuery.Builder builder = new PhraseQuery.Builder();\n              Term[] terms = pq.getTerms();\n              int[] positions = pq.getPositions();\n              for (int i = 0; i < terms.length; ++i) {\n                builder.add(terms[i], positions[i]);\n              }\n              builder.setSlop(slop);\n              query = builder.build();\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery mpq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && mpq.getTermArrays().length < minClauseSize) return null;\n              if (slop != mpq.getSlop()) {\n                query = new MultiPhraseQuery.Builder(mpq).setSlop(slop).build();\n              }\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n        \n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","sourceOld":"    private Query getQuery() {\n      try {\n        \n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query = super.getFieldQuery(field, val, type == QType.PHRASE);\n            // A BooleanQuery is only possible from getFieldQuery if it came from\n            // a single whitespace separated term. In this case, check the coordination\n            // factor on the query: if it's enabled, that means we aren't a set of synonyms\n            // but instead multiple terms from one whitespace-separated term, we must\n            // apply minShouldMatch here so that it works correctly with other things\n            // like aliasing.\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              if (!bq.isCoordDisabled()) {\n                query = SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch, false);\n              }\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              PhraseQuery.Builder builder = new PhraseQuery.Builder();\n              Term[] terms = pq.getTerms();\n              int[] positions = pq.getPositions();\n              for (int i = 0; i < terms.length; ++i) {\n                builder.add(terms[i], positions[i]);\n              }\n              builder.setSlop(slop);\n              query = builder.build();\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery mpq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && mpq.getTermArrays().length < minClauseSize) return null;\n              if (slop != mpq.getSlop()) {\n                query = new MultiPhraseQuery.Builder(mpq).setSlop(slop).build();\n              }\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n        \n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68c354ba50abc8ed5c5fe98901e61d68f93952bb","date":1479836000,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","sourceNew":"    private Query getQuery() {\n      try {\n        \n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query = super.getFieldQuery(field, val, type == QType.PHRASE, false);\n            // Boolean query on a whitespace-separated string\n            // If these were synonyms we would have a SynonymQuery\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              query = SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch, false);\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              PhraseQuery.Builder builder = new PhraseQuery.Builder();\n              Term[] terms = pq.getTerms();\n              int[] positions = pq.getPositions();\n              for (int i = 0; i < terms.length; ++i) {\n                builder.add(terms[i], positions[i]);\n              }\n              builder.setSlop(slop);\n              query = builder.build();\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery mpq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && mpq.getTermArrays().length < minClauseSize) return null;\n              if (slop != mpq.getSlop()) {\n                query = new MultiPhraseQuery.Builder(mpq).setSlop(slop).build();\n              }\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n        \n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","sourceOld":"    private Query getQuery() {\n      try {\n        \n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query = super.getFieldQuery(field, val, type == QType.PHRASE);\n            // Boolean query on a whitespace-separated string\n            // If these were synonyms we would have a SynonymQuery\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              query = SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch, false);\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              PhraseQuery.Builder builder = new PhraseQuery.Builder();\n              Term[] terms = pq.getTerms();\n              int[] positions = pq.getPositions();\n              for (int i = 0; i < terms.length; ++i) {\n                builder.add(terms[i], positions[i]);\n              }\n              builder.setSlop(slop);\n              query = builder.build();\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery mpq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && mpq.getTermArrays().length < minClauseSize) return null;\n              if (slop != mpq.getSlop()) {\n                query = new MultiPhraseQuery.Builder(mpq).setSlop(slop).build();\n              }\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n        \n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"727bb765ff2542275f6d31f67be18d7104bae148","date":1480353976,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","sourceNew":"    private Query getQuery() {\n      try {\n        \n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query = super.getFieldQuery(field, val, type == QType.PHRASE, false);\n            // Boolean query on a whitespace-separated string\n            // If these were synonyms we would have a SynonymQuery\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              query = SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch, false);\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              PhraseQuery.Builder builder = new PhraseQuery.Builder();\n              Term[] terms = pq.getTerms();\n              int[] positions = pq.getPositions();\n              for (int i = 0; i < terms.length; ++i) {\n                builder.add(terms[i], positions[i]);\n              }\n              builder.setSlop(slop);\n              query = builder.build();\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery mpq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && mpq.getTermArrays().length < minClauseSize) return null;\n              if (slop != mpq.getSlop()) {\n                query = new MultiPhraseQuery.Builder(mpq).setSlop(slop).build();\n              }\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n        \n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","sourceOld":"    private Query getQuery() {\n      try {\n        \n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query = super.getFieldQuery(field, val, type == QType.PHRASE);\n            // Boolean query on a whitespace-separated string\n            // If these were synonyms we would have a SynonymQuery\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              query = SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch, false);\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              PhraseQuery.Builder builder = new PhraseQuery.Builder();\n              Term[] terms = pq.getTerms();\n              int[] positions = pq.getPositions();\n              for (int i = 0; i < terms.length; ++i) {\n                builder.add(terms[i], positions[i]);\n              }\n              builder.setSlop(slop);\n              query = builder.build();\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery mpq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && mpq.getTermArrays().length < minClauseSize) return null;\n              if (slop != mpq.getSlop()) {\n                query = new MultiPhraseQuery.Builder(mpq).setSlop(slop).build();\n              }\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n        \n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e55782fb51a6e9789542818eb2161a3247f39ace","date":1489707707,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","sourceNew":"    private Query getQuery() {\n      try {\n        \n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query;\n            if (val == null) {\n              query = super.getFieldQuery(field, vals, false);\n            } else {\n              query = super.getFieldQuery(field, val, type == QType.PHRASE, false);\n            }\n            // Boolean query on a whitespace-separated string\n            // If these were synonyms we would have a SynonymQuery\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              query = SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch, false);\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              PhraseQuery.Builder builder = new PhraseQuery.Builder();\n              Term[] terms = pq.getTerms();\n              int[] positions = pq.getPositions();\n              for (int i = 0; i < terms.length; ++i) {\n                builder.add(terms[i], positions[i]);\n              }\n              builder.setSlop(slop);\n              query = builder.build();\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery mpq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && mpq.getTermArrays().length < minClauseSize) return null;\n              if (slop != mpq.getSlop()) {\n                query = new MultiPhraseQuery.Builder(mpq).setSlop(slop).build();\n              }\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n        \n      } catch (QueryParserConfigurationException e) {\n        throw e;  // Don't ignore configuration exceptions\n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","sourceOld":"    private Query getQuery() {\n      try {\n        \n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query = super.getFieldQuery(field, val, type == QType.PHRASE, false);\n            // Boolean query on a whitespace-separated string\n            // If these were synonyms we would have a SynonymQuery\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              query = SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch, false);\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              PhraseQuery.Builder builder = new PhraseQuery.Builder();\n              Term[] terms = pq.getTerms();\n              int[] positions = pq.getPositions();\n              for (int i = 0; i < terms.length; ++i) {\n                builder.add(terms[i], positions[i]);\n              }\n              builder.setSlop(slop);\n              query = builder.build();\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery mpq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && mpq.getTermArrays().length < minClauseSize) return null;\n              if (slop != mpq.getSlop()) {\n                query = new MultiPhraseQuery.Builder(mpq).setSlop(slop).build();\n              }\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n        \n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c03778630c4604270d88c148afb8c7de35b51d3c","date":1490280010,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","sourceNew":"    private Query getQuery() {\n      try {\n        \n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query;\n            if (val == null) {\n              query = super.getFieldQuery(field, vals, false);\n            } else {\n              query = super.getFieldQuery(field, val, type == QType.PHRASE, false);\n            }\n            // Boolean query on a whitespace-separated string\n            // If these were synonyms we would have a SynonymQuery\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              query = SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch, false);\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              PhraseQuery.Builder builder = new PhraseQuery.Builder();\n              Term[] terms = pq.getTerms();\n              int[] positions = pq.getPositions();\n              for (int i = 0; i < terms.length; ++i) {\n                builder.add(terms[i], positions[i]);\n              }\n              builder.setSlop(slop);\n              query = builder.build();\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery mpq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && mpq.getTermArrays().length < minClauseSize) return null;\n              if (slop != mpq.getSlop()) {\n                query = new MultiPhraseQuery.Builder(mpq).setSlop(slop).build();\n              }\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n        \n      } catch (QueryParserConfigurationException e) {\n        throw e;  // Don't ignore configuration exceptions\n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","sourceOld":"    private Query getQuery() {\n      try {\n        \n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query = super.getFieldQuery(field, val, type == QType.PHRASE, false);\n            // Boolean query on a whitespace-separated string\n            // If these were synonyms we would have a SynonymQuery\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              query = SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch, false);\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              PhraseQuery.Builder builder = new PhraseQuery.Builder();\n              Term[] terms = pq.getTerms();\n              int[] positions = pq.getPositions();\n              for (int i = 0; i < terms.length; ++i) {\n                builder.add(terms[i], positions[i]);\n              }\n              builder.setSlop(slop);\n              query = builder.build();\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery mpq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && mpq.getTermArrays().length < minClauseSize) return null;\n              if (slop != mpq.getSlop()) {\n                query = new MultiPhraseQuery.Builder(mpq).setSlop(slop).build();\n              }\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n        \n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b360a3d5b9d443b4e880d2c92724cffd7def8db","date":1490740768,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","sourceNew":"    private Query getQuery() {\n      try {\n        \n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query;\n            if (val == null) {\n              query = super.getFieldQuery(field, vals, false);\n            } else {\n              query = super.getFieldQuery(field, val, type == QType.PHRASE, false);\n            }\n            // Boolean query on a whitespace-separated string\n            // If these were synonyms we would have a SynonymQuery\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              query = SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch, false);\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              PhraseQuery.Builder builder = new PhraseQuery.Builder();\n              Term[] terms = pq.getTerms();\n              int[] positions = pq.getPositions();\n              for (int i = 0; i < terms.length; ++i) {\n                builder.add(terms[i], positions[i]);\n              }\n              builder.setSlop(slop);\n              query = builder.build();\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery mpq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && mpq.getTermArrays().length < minClauseSize) return null;\n              if (slop != mpq.getSlop()) {\n                query = new MultiPhraseQuery.Builder(mpq).setSlop(slop).build();\n              }\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n        \n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","sourceOld":"    private Query getQuery() {\n      try {\n        \n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query;\n            if (val == null) {\n              query = super.getFieldQuery(field, vals, false);\n            } else {\n              query = super.getFieldQuery(field, val, type == QType.PHRASE, false);\n            }\n            // Boolean query on a whitespace-separated string\n            // If these were synonyms we would have a SynonymQuery\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              query = SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch, false);\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              PhraseQuery.Builder builder = new PhraseQuery.Builder();\n              Term[] terms = pq.getTerms();\n              int[] positions = pq.getPositions();\n              for (int i = 0; i < terms.length; ++i) {\n                builder.add(terms[i], positions[i]);\n              }\n              builder.setSlop(slop);\n              query = builder.build();\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery mpq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && mpq.getTermArrays().length < minClauseSize) return null;\n              if (slop != mpq.getSlop()) {\n                query = new MultiPhraseQuery.Builder(mpq).setSlop(slop).build();\n              }\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n        \n      } catch (QueryParserConfigurationException e) {\n        throw e;  // Don't ignore configuration exceptions\n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"36d81030ef9ff5ae6820e560c0833127181c7a2c","date":1490873946,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","sourceNew":"    private Query getQuery() {\n      try {\n        \n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query;\n            if (val == null) {\n              query = super.getFieldQuery(field, vals, false);\n            } else {\n              query = super.getFieldQuery(field, val, type == QType.PHRASE, false);\n            }\n            // Boolean query on a whitespace-separated string\n            // If these were synonyms we would have a SynonymQuery\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              query = SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch, false);\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              PhraseQuery.Builder builder = new PhraseQuery.Builder();\n              Term[] terms = pq.getTerms();\n              int[] positions = pq.getPositions();\n              for (int i = 0; i < terms.length; ++i) {\n                builder.add(terms[i], positions[i]);\n              }\n              builder.setSlop(slop);\n              query = builder.build();\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery mpq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && mpq.getTermArrays().length < minClauseSize) return null;\n              if (slop != mpq.getSlop()) {\n                query = new MultiPhraseQuery.Builder(mpq).setSlop(slop).build();\n              }\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n        \n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","sourceOld":"    private Query getQuery() {\n      try {\n        \n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query;\n            if (val == null) {\n              query = super.getFieldQuery(field, vals, false);\n            } else {\n              query = super.getFieldQuery(field, val, type == QType.PHRASE, false);\n            }\n            // Boolean query on a whitespace-separated string\n            // If these were synonyms we would have a SynonymQuery\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              query = SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch, false);\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              PhraseQuery.Builder builder = new PhraseQuery.Builder();\n              Term[] terms = pq.getTerms();\n              int[] positions = pq.getPositions();\n              for (int i = 0; i < terms.length; ++i) {\n                builder.add(terms[i], positions[i]);\n              }\n              builder.setSlop(slop);\n              query = builder.build();\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery mpq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && mpq.getTermArrays().length < minClauseSize) return null;\n              if (slop != mpq.getSlop()) {\n                query = new MultiPhraseQuery.Builder(mpq).setSlop(slop).build();\n              }\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n        \n      } catch (QueryParserConfigurationException e) {\n        throw e;  // Don't ignore configuration exceptions\n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7a49f8dc38a90fbd6c7edac0845981e0b0a7f21","date":1541431969,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser.ExtendedSolrQueryParser#getQuery().mjava","sourceNew":"    private Query getQuery() {\n      try {\n        \n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query;\n            if (val == null) {\n              query = super.getFieldQuery(field, vals, false);\n            } else {\n              query = super.getFieldQuery(field, val, type == QType.PHRASE, false);\n            }\n            // Boolean query on a whitespace-separated string\n            // If these were synonyms we would have a SynonymQuery\n            if (query instanceof BooleanQuery) {\n              if (type == QType.FIELD) { // Don't set mm for boolean query containing phrase queries\n                BooleanQuery bq = (BooleanQuery) query;\n                query = SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch, false);\n              }\n            } else if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              PhraseQuery.Builder builder = new PhraseQuery.Builder();\n              Term[] terms = pq.getTerms();\n              int[] positions = pq.getPositions();\n              for (int i = 0; i < terms.length; ++i) {\n                builder.add(terms[i], positions[i]);\n              }\n              builder.setSlop(slop);\n              query = builder.build();\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery mpq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && mpq.getTermArrays().length < minClauseSize) return null;\n              if (slop != mpq.getSlop()) {\n                query = new MultiPhraseQuery.Builder(mpq).setSlop(slop).build();\n              }\n            } else if (query instanceof SpanQuery) {\n              return query;\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n        \n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","sourceOld":"    private Query getQuery() {\n      try {\n        \n        switch (type) {\n          case FIELD:  // fallthrough\n          case PHRASE:\n            Query query;\n            if (val == null) {\n              query = super.getFieldQuery(field, vals, false);\n            } else {\n              query = super.getFieldQuery(field, val, type == QType.PHRASE, false);\n            }\n            // Boolean query on a whitespace-separated string\n            // If these were synonyms we would have a SynonymQuery\n            if (query instanceof BooleanQuery) {\n              BooleanQuery bq = (BooleanQuery) query;\n              query = SolrPluginUtils.setMinShouldMatch(bq, minShouldMatch, false);\n            }\n            if (query instanceof PhraseQuery) {\n              PhraseQuery pq = (PhraseQuery)query;\n              if (minClauseSize > 1 && pq.getTerms().length < minClauseSize) return null;\n              PhraseQuery.Builder builder = new PhraseQuery.Builder();\n              Term[] terms = pq.getTerms();\n              int[] positions = pq.getPositions();\n              for (int i = 0; i < terms.length; ++i) {\n                builder.add(terms[i], positions[i]);\n              }\n              builder.setSlop(slop);\n              query = builder.build();\n            } else if (query instanceof MultiPhraseQuery) {\n              MultiPhraseQuery mpq = (MultiPhraseQuery)query;\n              if (minClauseSize > 1 && mpq.getTermArrays().length < minClauseSize) return null;\n              if (slop != mpq.getSlop()) {\n                query = new MultiPhraseQuery.Builder(mpq).setSlop(slop).build();\n              }\n            } else if (minClauseSize > 1) {\n              // if it's not a type of phrase query, it doesn't meet the minClauseSize requirements\n              return null;\n            }\n            return query;\n          case PREFIX: return super.getPrefixQuery(field, val);\n          case WILDCARD: return super.getWildcardQuery(field, val);\n          case FUZZY: return super.getFuzzyQuery(field, val, flt);\n          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);\n        }\n        return null;\n        \n      } catch (Exception e) {\n        // an exception here is due to the field query not being compatible with the input text\n        // for example, passing a string to a numeric field.\n        return null;\n      }\n    }\n\n","bugFix":["19ec10ef17ba08cbd0c263d0d31a6ae9e9461a33","c8a0e442f7b61f811680273b25da95994a724466","20349324eb18d1565d301e59be543989f38743d3"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8b360a3d5b9d443b4e880d2c92724cffd7def8db":["e55782fb51a6e9789542818eb2161a3247f39ace"],"36d81030ef9ff5ae6820e560c0833127181c7a2c":["c03778630c4604270d88c148afb8c7de35b51d3c"],"c03778630c4604270d88c148afb8c7de35b51d3c":["68c354ba50abc8ed5c5fe98901e61d68f93952bb"],"e55782fb51a6e9789542818eb2161a3247f39ace":["68c354ba50abc8ed5c5fe98901e61d68f93952bb"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273","c8a0e442f7b61f811680273b25da95994a724466"],"3ca415055c1401a2359adfb8f5d3fbf3887f95d7":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["e9e1499c5d26c936238506df90a3c02c76707722"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["c7e79e31f55cbb444e3023d430a340658755aa31"],"92b4a131f1796dd57cc6698aae3d589d32a29deb":["3ca415055c1401a2359adfb8f5d3fbf3887f95d7"],"727bb765ff2542275f6d31f67be18d7104bae148":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","68c354ba50abc8ed5c5fe98901e61d68f93952bb"],"e9e1499c5d26c936238506df90a3c02c76707722":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c8a0e442f7b61f811680273b25da95994a724466":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["3ca415055c1401a2359adfb8f5d3fbf3887f95d7","92b4a131f1796dd57cc6698aae3d589d32a29deb"],"c7e79e31f55cbb444e3023d430a340658755aa31":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"68c354ba50abc8ed5c5fe98901e61d68f93952bb":["c8a0e442f7b61f811680273b25da95994a724466"],"4e6354dd7c71fe122926fc53d7d29f715b1283db":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c7e79e31f55cbb444e3023d430a340658755aa31"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c7a49f8dc38a90fbd6c7edac0845981e0b0a7f21"],"c7a49f8dc38a90fbd6c7edac0845981e0b0a7f21":["8b360a3d5b9d443b4e880d2c92724cffd7def8db"]},"commit2Childs":{"8b360a3d5b9d443b4e880d2c92724cffd7def8db":["c7a49f8dc38a90fbd6c7edac0845981e0b0a7f21"],"36d81030ef9ff5ae6820e560c0833127181c7a2c":[],"c03778630c4604270d88c148afb8c7de35b51d3c":["36d81030ef9ff5ae6820e560c0833127181c7a2c"],"e55782fb51a6e9789542818eb2161a3247f39ace":["8b360a3d5b9d443b4e880d2c92724cffd7def8db"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["727bb765ff2542275f6d31f67be18d7104bae148"],"3ca415055c1401a2359adfb8f5d3fbf3887f95d7":["92b4a131f1796dd57cc6698aae3d589d32a29deb","cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["3ca415055c1401a2359adfb8f5d3fbf3887f95d7"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["e9e1499c5d26c936238506df90a3c02c76707722"],"92b4a131f1796dd57cc6698aae3d589d32a29deb":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"727bb765ff2542275f6d31f67be18d7104bae148":[],"e9e1499c5d26c936238506df90a3c02c76707722":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c7e79e31f55cbb444e3023d430a340658755aa31","4e6354dd7c71fe122926fc53d7d29f715b1283db"],"c8a0e442f7b61f811680273b25da95994a724466":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","68c354ba50abc8ed5c5fe98901e61d68f93952bb"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","c8a0e442f7b61f811680273b25da95994a724466"],"c7e79e31f55cbb444e3023d430a340658755aa31":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1","4e6354dd7c71fe122926fc53d7d29f715b1283db"],"68c354ba50abc8ed5c5fe98901e61d68f93952bb":["c03778630c4604270d88c148afb8c7de35b51d3c","e55782fb51a6e9789542818eb2161a3247f39ace","727bb765ff2542275f6d31f67be18d7104bae148"],"4e6354dd7c71fe122926fc53d7d29f715b1283db":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"c7a49f8dc38a90fbd6c7edac0845981e0b0a7f21":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["36d81030ef9ff5ae6820e560c0833127181c7a2c","727bb765ff2542275f6d31f67be18d7104bae148","4e6354dd7c71fe122926fc53d7d29f715b1283db","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}