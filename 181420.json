{"path":"src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","commits":[{"id":"98bc22650ab0fe51f9c00513397bfa42a64fc663","date":1161986633,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","pathOld":"/dev/null","sourceNew":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by advancing\n   * all subSpans except the last one in reverse order.\n   */\n  private boolean shrinkToAfterShortestMatch() throws IOException {\n    matchStart = subSpans[subSpans.length - 1].start();\n    matchEnd = subSpans[subSpans.length - 1].end();\n    int matchSlop = 0;\n    int lastStart = matchStart;\n    int lastEnd = matchEnd;\n    for (int i = subSpans.length - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans[i];\n      int prevStart = prevSpans.start();\n      int prevEnd = prevSpans.end();\n      while (true) { // Advance prevSpans until after (lastStart, lastEnd)\n        if (! prevSpans.next()) {\n          inSameDoc = false;\n          more = false;\n          break; // Check remaining subSpans for final match.\n        } else if (matchDoc != prevSpans.doc()) {\n          inSameDoc = false; // The last subSpans is not advanced here.\n          break; // Check remaining subSpans for last match in this document.\n        } else {\n          int ppStart = prevSpans.start();\n          int ppEnd = prevSpans.end(); // Cannot avoid invoking .end()\n          if (! docSpansOrdered(ppStart, ppEnd, lastStart, lastEnd)) {\n            break; // Check remaining subSpans.\n          } else { // prevSpans still before (lastStart, lastEnd)\n            prevStart = ppStart;\n            prevEnd = ppEnd;\n          }\n        }\n      }\n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that subSpans[0] is advanced after the match, if any.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n      lastEnd = prevEnd;\n    }\n    return matchSlop <= allowedSlop; // ordered and allowed slop\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["441e4370677ea6e64691231510de2a90b67dd2fb","77301f098b899884dd472e6b27fb5f8136189fe3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fd5947db4de866f035b932f219674c03562d904e","date":1219248396,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","pathOld":"src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","sourceNew":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by advancing\n   * all subSpans except the last one in reverse order.\n   */\n  private boolean shrinkToAfterShortestMatch() throws IOException {\n    matchStart = subSpans[subSpans.length - 1].start();\n    matchEnd = subSpans[subSpans.length - 1].end();\n    if (subSpans[subSpans.length - 1].isPayloadAvailable()) {\n      matchPayload.addAll(subSpans[subSpans.length - 1].getPayload());\n    }\n    int matchSlop = 0;\n    int lastStart = matchStart;\n    int lastEnd = matchEnd;\n    for (int i = subSpans.length - 2; i >= 0; i--) {\n      PayloadSpans prevSpans = subSpans[i];\n      \n      if (subSpans[i].isPayloadAvailable()) {\n        matchPayload.addAll(0, subSpans[i].getPayload());\n      }\n      \n      int prevStart = prevSpans.start();\n      int prevEnd = prevSpans.end();\n      while (true) { // Advance prevSpans until after (lastStart, lastEnd)\n        if (! prevSpans.next()) {\n          inSameDoc = false;\n          more = false;\n          break; // Check remaining subSpans for final match.\n        } else if (matchDoc != prevSpans.doc()) {\n          inSameDoc = false; // The last subSpans is not advanced here.\n          break; // Check remaining subSpans for last match in this document.\n        } else {\n          int ppStart = prevSpans.start();\n          int ppEnd = prevSpans.end(); // Cannot avoid invoking .end()\n          if (! docSpansOrdered(ppStart, ppEnd, lastStart, lastEnd)) {\n            break; // Check remaining subSpans.\n          } else { // prevSpans still before (lastStart, lastEnd)\n            prevStart = ppStart;\n            prevEnd = ppEnd;\n          }\n        }\n      }\n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that subSpans[0] is advanced after the match, if any.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n      lastEnd = prevEnd;\n    }\n    return matchSlop <= allowedSlop; // ordered and allowed slop\n  }\n\n","sourceOld":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by advancing\n   * all subSpans except the last one in reverse order.\n   */\n  private boolean shrinkToAfterShortestMatch() throws IOException {\n    matchStart = subSpans[subSpans.length - 1].start();\n    matchEnd = subSpans[subSpans.length - 1].end();\n    int matchSlop = 0;\n    int lastStart = matchStart;\n    int lastEnd = matchEnd;\n    for (int i = subSpans.length - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans[i];\n      int prevStart = prevSpans.start();\n      int prevEnd = prevSpans.end();\n      while (true) { // Advance prevSpans until after (lastStart, lastEnd)\n        if (! prevSpans.next()) {\n          inSameDoc = false;\n          more = false;\n          break; // Check remaining subSpans for final match.\n        } else if (matchDoc != prevSpans.doc()) {\n          inSameDoc = false; // The last subSpans is not advanced here.\n          break; // Check remaining subSpans for last match in this document.\n        } else {\n          int ppStart = prevSpans.start();\n          int ppEnd = prevSpans.end(); // Cannot avoid invoking .end()\n          if (! docSpansOrdered(ppStart, ppEnd, lastStart, lastEnd)) {\n            break; // Check remaining subSpans.\n          } else { // prevSpans still before (lastStart, lastEnd)\n            prevStart = ppStart;\n            prevEnd = ppEnd;\n          }\n        }\n      }\n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that subSpans[0] is advanced after the match, if any.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n      lastEnd = prevEnd;\n    }\n    return matchSlop <= allowedSlop; // ordered and allowed slop\n  }\n\n","bugFix":null,"bugIntro":["441e4370677ea6e64691231510de2a90b67dd2fb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"441e4370677ea6e64691231510de2a90b67dd2fb","date":1227656336,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","pathOld":"src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","sourceNew":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by advancing\n   * all subSpans except the last one in reverse order.\n   */\n  private boolean shrinkToAfterShortestMatch() throws IOException {\n    matchStart = subSpans[subSpans.length - 1].start();\n    matchEnd = subSpans[subSpans.length - 1].end();\n    Set possibleMatchPayloads = new HashSet();\n    if (subSpans[subSpans.length - 1].isPayloadAvailable()) {\n      possibleMatchPayloads.addAll(subSpans[subSpans.length - 1].getPayload());\n    }\n\n    Collection possiblePayload = null;\n    \n    int matchSlop = 0;\n    int lastStart = matchStart;\n    int lastEnd = matchEnd;\n    for (int i = subSpans.length - 2; i >= 0; i--) {\n      PayloadSpans prevSpans = subSpans[i];\n      if (prevSpans.isPayloadAvailable()) {\n        Collection payload = prevSpans.getPayload();\n        possiblePayload = new ArrayList(payload.size());\n        possiblePayload.addAll(payload);\n      }\n      \n      int prevStart = prevSpans.start();\n      int prevEnd = prevSpans.end();\n      while (true) { // Advance prevSpans until after (lastStart, lastEnd)\n        if (! prevSpans.next()) {\n          inSameDoc = false;\n          more = false;\n          break; // Check remaining subSpans for final match.\n        } else if (matchDoc != prevSpans.doc()) {\n          inSameDoc = false; // The last subSpans is not advanced here.\n          break; // Check remaining subSpans for last match in this document.\n        } else {\n          int ppStart = prevSpans.start();\n          int ppEnd = prevSpans.end(); // Cannot avoid invoking .end()\n          if (! docSpansOrdered(ppStart, ppEnd, lastStart, lastEnd)) {\n            break; // Check remaining subSpans.\n          } else { // prevSpans still before (lastStart, lastEnd)\n            prevStart = ppStart;\n            prevEnd = ppEnd;\n            if (prevSpans.isPayloadAvailable()) {\n              Collection payload = prevSpans.getPayload();\n              possiblePayload = new ArrayList(payload.size());\n              possiblePayload.addAll(payload);\n            }\n          }\n        }\n      }\n\n      if (possiblePayload != null) {\n        possibleMatchPayloads.addAll(possiblePayload);\n      }\n      \n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that subSpans[0] is advanced after the match, if any.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n      lastEnd = prevEnd;\n    }\n    \n    boolean match = matchSlop <= allowedSlop;\n    \n    if(match && possibleMatchPayloads.size() > 0) {\n      matchPayload.addAll(possibleMatchPayloads);\n    }\n\n    return match; // ordered and allowed slop\n  }\n\n","sourceOld":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by advancing\n   * all subSpans except the last one in reverse order.\n   */\n  private boolean shrinkToAfterShortestMatch() throws IOException {\n    matchStart = subSpans[subSpans.length - 1].start();\n    matchEnd = subSpans[subSpans.length - 1].end();\n    if (subSpans[subSpans.length - 1].isPayloadAvailable()) {\n      matchPayload.addAll(subSpans[subSpans.length - 1].getPayload());\n    }\n    int matchSlop = 0;\n    int lastStart = matchStart;\n    int lastEnd = matchEnd;\n    for (int i = subSpans.length - 2; i >= 0; i--) {\n      PayloadSpans prevSpans = subSpans[i];\n      \n      if (subSpans[i].isPayloadAvailable()) {\n        matchPayload.addAll(0, subSpans[i].getPayload());\n      }\n      \n      int prevStart = prevSpans.start();\n      int prevEnd = prevSpans.end();\n      while (true) { // Advance prevSpans until after (lastStart, lastEnd)\n        if (! prevSpans.next()) {\n          inSameDoc = false;\n          more = false;\n          break; // Check remaining subSpans for final match.\n        } else if (matchDoc != prevSpans.doc()) {\n          inSameDoc = false; // The last subSpans is not advanced here.\n          break; // Check remaining subSpans for last match in this document.\n        } else {\n          int ppStart = prevSpans.start();\n          int ppEnd = prevSpans.end(); // Cannot avoid invoking .end()\n          if (! docSpansOrdered(ppStart, ppEnd, lastStart, lastEnd)) {\n            break; // Check remaining subSpans.\n          } else { // prevSpans still before (lastStart, lastEnd)\n            prevStart = ppStart;\n            prevEnd = ppEnd;\n          }\n        }\n      }\n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that subSpans[0] is advanced after the match, if any.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n      lastEnd = prevEnd;\n    }\n    return matchSlop <= allowedSlop; // ordered and allowed slop\n  }\n\n","bugFix":["98bc22650ab0fe51f9c00513397bfa42a64fc663","fd5947db4de866f035b932f219674c03562d904e"],"bugIntro":["b00d44ccb616bf40482a9ba5302cb256c26c6e4c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b00d44ccb616bf40482a9ba5302cb256c26c6e4c","date":1249308735,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","pathOld":"src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","sourceNew":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by advancing\n   * all subSpans except the last one in reverse order.\n   */\n  private boolean shrinkToAfterShortestMatch() throws IOException {\n    matchStart = subSpans[subSpans.length - 1].start();\n    matchEnd = subSpans[subSpans.length - 1].end();\n    Set possibleMatchPayloads = new HashSet();\n    if (subSpans[subSpans.length - 1].isPayloadAvailable()) {\n      possibleMatchPayloads.addAll(subSpans[subSpans.length - 1].getPayload());\n    }\n\n    Collection possiblePayload = null;\n    \n    int matchSlop = 0;\n    int lastStart = matchStart;\n    int lastEnd = matchEnd;\n    for (int i = subSpans.length - 2; i >= 0; i--) {\n      PayloadSpans prevSpans = subSpans[i];\n      if (collectPayloads && prevSpans.isPayloadAvailable()) {\n        Collection payload = prevSpans.getPayload();\n        possiblePayload = new ArrayList(payload.size());\n        possiblePayload.addAll(payload);\n      }\n      \n      int prevStart = prevSpans.start();\n      int prevEnd = prevSpans.end();\n      while (true) { // Advance prevSpans until after (lastStart, lastEnd)\n        if (! prevSpans.next()) {\n          inSameDoc = false;\n          more = false;\n          break; // Check remaining subSpans for final match.\n        } else if (matchDoc != prevSpans.doc()) {\n          inSameDoc = false; // The last subSpans is not advanced here.\n          break; // Check remaining subSpans for last match in this document.\n        } else {\n          int ppStart = prevSpans.start();\n          int ppEnd = prevSpans.end(); // Cannot avoid invoking .end()\n          if (! docSpansOrdered(ppStart, ppEnd, lastStart, lastEnd)) {\n            break; // Check remaining subSpans.\n          } else { // prevSpans still before (lastStart, lastEnd)\n            prevStart = ppStart;\n            prevEnd = ppEnd;\n            if (collectPayloads && prevSpans.isPayloadAvailable()) {\n              Collection payload = prevSpans.getPayload();\n              possiblePayload = new ArrayList(payload.size());\n              possiblePayload.addAll(payload);\n            }\n          }\n        }\n      }\n\n      if (collectPayloads && possiblePayload != null) {\n        possibleMatchPayloads.addAll(possiblePayload);\n      }\n      \n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that subSpans[0] is advanced after the match, if any.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n      lastEnd = prevEnd;\n    }\n    \n    boolean match = matchSlop <= allowedSlop;\n    \n    if(collectPayloads && match && possibleMatchPayloads.size() > 0) {\n      matchPayload.addAll(possibleMatchPayloads);\n    }\n\n    return match; // ordered and allowed slop\n  }\n\n","sourceOld":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by advancing\n   * all subSpans except the last one in reverse order.\n   */\n  private boolean shrinkToAfterShortestMatch() throws IOException {\n    matchStart = subSpans[subSpans.length - 1].start();\n    matchEnd = subSpans[subSpans.length - 1].end();\n    Set possibleMatchPayloads = new HashSet();\n    if (subSpans[subSpans.length - 1].isPayloadAvailable()) {\n      possibleMatchPayloads.addAll(subSpans[subSpans.length - 1].getPayload());\n    }\n\n    Collection possiblePayload = null;\n    \n    int matchSlop = 0;\n    int lastStart = matchStart;\n    int lastEnd = matchEnd;\n    for (int i = subSpans.length - 2; i >= 0; i--) {\n      PayloadSpans prevSpans = subSpans[i];\n      if (prevSpans.isPayloadAvailable()) {\n        Collection payload = prevSpans.getPayload();\n        possiblePayload = new ArrayList(payload.size());\n        possiblePayload.addAll(payload);\n      }\n      \n      int prevStart = prevSpans.start();\n      int prevEnd = prevSpans.end();\n      while (true) { // Advance prevSpans until after (lastStart, lastEnd)\n        if (! prevSpans.next()) {\n          inSameDoc = false;\n          more = false;\n          break; // Check remaining subSpans for final match.\n        } else if (matchDoc != prevSpans.doc()) {\n          inSameDoc = false; // The last subSpans is not advanced here.\n          break; // Check remaining subSpans for last match in this document.\n        } else {\n          int ppStart = prevSpans.start();\n          int ppEnd = prevSpans.end(); // Cannot avoid invoking .end()\n          if (! docSpansOrdered(ppStart, ppEnd, lastStart, lastEnd)) {\n            break; // Check remaining subSpans.\n          } else { // prevSpans still before (lastStart, lastEnd)\n            prevStart = ppStart;\n            prevEnd = ppEnd;\n            if (prevSpans.isPayloadAvailable()) {\n              Collection payload = prevSpans.getPayload();\n              possiblePayload = new ArrayList(payload.size());\n              possiblePayload.addAll(payload);\n            }\n          }\n        }\n      }\n\n      if (possiblePayload != null) {\n        possibleMatchPayloads.addAll(possiblePayload);\n      }\n      \n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that subSpans[0] is advanced after the match, if any.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n      lastEnd = prevEnd;\n    }\n    \n    boolean match = matchSlop <= allowedSlop;\n    \n    if(match && possibleMatchPayloads.size() > 0) {\n      matchPayload.addAll(possibleMatchPayloads);\n    }\n\n    return match; // ordered and allowed slop\n  }\n\n","bugFix":["441e4370677ea6e64691231510de2a90b67dd2fb"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ff93c6759a7da468c20c64fb459f85bccd0af370","date":1249413002,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","pathOld":"src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","sourceNew":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by advancing\n   * all subSpans except the last one in reverse order.\n   */\n  private boolean shrinkToAfterShortestMatch() throws IOException {\n    matchStart = subSpans[subSpans.length - 1].start();\n    matchEnd = subSpans[subSpans.length - 1].end();\n    Set possibleMatchPayloads = new HashSet();\n    if (subSpans[subSpans.length - 1].isPayloadAvailable()) {\n      possibleMatchPayloads.addAll(subSpans[subSpans.length - 1].getPayload());\n    }\n\n    Collection possiblePayload = null;\n    \n    int matchSlop = 0;\n    int lastStart = matchStart;\n    int lastEnd = matchEnd;\n    for (int i = subSpans.length - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans[i];\n      if (collectPayloads && prevSpans.isPayloadAvailable()) {\n        Collection payload = prevSpans.getPayload();\n        possiblePayload = new ArrayList(payload.size());\n        possiblePayload.addAll(payload);\n      }\n      \n      int prevStart = prevSpans.start();\n      int prevEnd = prevSpans.end();\n      while (true) { // Advance prevSpans until after (lastStart, lastEnd)\n        if (! prevSpans.next()) {\n          inSameDoc = false;\n          more = false;\n          break; // Check remaining subSpans for final match.\n        } else if (matchDoc != prevSpans.doc()) {\n          inSameDoc = false; // The last subSpans is not advanced here.\n          break; // Check remaining subSpans for last match in this document.\n        } else {\n          int ppStart = prevSpans.start();\n          int ppEnd = prevSpans.end(); // Cannot avoid invoking .end()\n          if (! docSpansOrdered(ppStart, ppEnd, lastStart, lastEnd)) {\n            break; // Check remaining subSpans.\n          } else { // prevSpans still before (lastStart, lastEnd)\n            prevStart = ppStart;\n            prevEnd = ppEnd;\n            if (collectPayloads && prevSpans.isPayloadAvailable()) {\n              Collection payload = prevSpans.getPayload();\n              possiblePayload = new ArrayList(payload.size());\n              possiblePayload.addAll(payload);\n            }\n          }\n        }\n      }\n\n      if (collectPayloads && possiblePayload != null) {\n        possibleMatchPayloads.addAll(possiblePayload);\n      }\n      \n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that subSpans[0] is advanced after the match, if any.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n      lastEnd = prevEnd;\n    }\n    \n    boolean match = matchSlop <= allowedSlop;\n    \n    if(collectPayloads && match && possibleMatchPayloads.size() > 0) {\n      matchPayload.addAll(possibleMatchPayloads);\n    }\n\n    return match; // ordered and allowed slop\n  }\n\n","sourceOld":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by advancing\n   * all subSpans except the last one in reverse order.\n   */\n  private boolean shrinkToAfterShortestMatch() throws IOException {\n    matchStart = subSpans[subSpans.length - 1].start();\n    matchEnd = subSpans[subSpans.length - 1].end();\n    Set possibleMatchPayloads = new HashSet();\n    if (subSpans[subSpans.length - 1].isPayloadAvailable()) {\n      possibleMatchPayloads.addAll(subSpans[subSpans.length - 1].getPayload());\n    }\n\n    Collection possiblePayload = null;\n    \n    int matchSlop = 0;\n    int lastStart = matchStart;\n    int lastEnd = matchEnd;\n    for (int i = subSpans.length - 2; i >= 0; i--) {\n      PayloadSpans prevSpans = subSpans[i];\n      if (collectPayloads && prevSpans.isPayloadAvailable()) {\n        Collection payload = prevSpans.getPayload();\n        possiblePayload = new ArrayList(payload.size());\n        possiblePayload.addAll(payload);\n      }\n      \n      int prevStart = prevSpans.start();\n      int prevEnd = prevSpans.end();\n      while (true) { // Advance prevSpans until after (lastStart, lastEnd)\n        if (! prevSpans.next()) {\n          inSameDoc = false;\n          more = false;\n          break; // Check remaining subSpans for final match.\n        } else if (matchDoc != prevSpans.doc()) {\n          inSameDoc = false; // The last subSpans is not advanced here.\n          break; // Check remaining subSpans for last match in this document.\n        } else {\n          int ppStart = prevSpans.start();\n          int ppEnd = prevSpans.end(); // Cannot avoid invoking .end()\n          if (! docSpansOrdered(ppStart, ppEnd, lastStart, lastEnd)) {\n            break; // Check remaining subSpans.\n          } else { // prevSpans still before (lastStart, lastEnd)\n            prevStart = ppStart;\n            prevEnd = ppEnd;\n            if (collectPayloads && prevSpans.isPayloadAvailable()) {\n              Collection payload = prevSpans.getPayload();\n              possiblePayload = new ArrayList(payload.size());\n              possiblePayload.addAll(payload);\n            }\n          }\n        }\n      }\n\n      if (collectPayloads && possiblePayload != null) {\n        possibleMatchPayloads.addAll(possiblePayload);\n      }\n      \n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that subSpans[0] is advanced after the match, if any.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n      lastEnd = prevEnd;\n    }\n    \n    boolean match = matchSlop <= allowedSlop;\n    \n    if(collectPayloads && match && possibleMatchPayloads.size() > 0) {\n      matchPayload.addAll(possibleMatchPayloads);\n    }\n\n    return match; // ordered and allowed slop\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ef82ff03e4016c705811b2658e81471a645c0e49","date":1255900293,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","pathOld":"src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","sourceNew":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by advancing\n   * all subSpans except the last one in reverse order.\n   */\n  private boolean shrinkToAfterShortestMatch() throws IOException {\n    matchStart = subSpans[subSpans.length - 1].start();\n    matchEnd = subSpans[subSpans.length - 1].end();\n    Set<byte[]> possibleMatchPayloads = new HashSet<byte[]>();\n    if (subSpans[subSpans.length - 1].isPayloadAvailable()) {\n      possibleMatchPayloads.addAll(subSpans[subSpans.length - 1].getPayload());\n    }\n\n    Collection<byte[]> possiblePayload = null;\n    \n    int matchSlop = 0;\n    int lastStart = matchStart;\n    int lastEnd = matchEnd;\n    for (int i = subSpans.length - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans[i];\n      if (collectPayloads && prevSpans.isPayloadAvailable()) {\n        Collection<byte[]> payload = prevSpans.getPayload();\n        possiblePayload = new ArrayList<byte[]>(payload.size());\n        possiblePayload.addAll(payload);\n      }\n      \n      int prevStart = prevSpans.start();\n      int prevEnd = prevSpans.end();\n      while (true) { // Advance prevSpans until after (lastStart, lastEnd)\n        if (! prevSpans.next()) {\n          inSameDoc = false;\n          more = false;\n          break; // Check remaining subSpans for final match.\n        } else if (matchDoc != prevSpans.doc()) {\n          inSameDoc = false; // The last subSpans is not advanced here.\n          break; // Check remaining subSpans for last match in this document.\n        } else {\n          int ppStart = prevSpans.start();\n          int ppEnd = prevSpans.end(); // Cannot avoid invoking .end()\n          if (! docSpansOrdered(ppStart, ppEnd, lastStart, lastEnd)) {\n            break; // Check remaining subSpans.\n          } else { // prevSpans still before (lastStart, lastEnd)\n            prevStart = ppStart;\n            prevEnd = ppEnd;\n            if (collectPayloads && prevSpans.isPayloadAvailable()) {\n              Collection<byte[]> payload = prevSpans.getPayload();\n              possiblePayload = new ArrayList<byte[]>(payload.size());\n              possiblePayload.addAll(payload);\n            }\n          }\n        }\n      }\n\n      if (collectPayloads && possiblePayload != null) {\n        possibleMatchPayloads.addAll(possiblePayload);\n      }\n      \n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that subSpans[0] is advanced after the match, if any.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n      lastEnd = prevEnd;\n    }\n    \n    boolean match = matchSlop <= allowedSlop;\n    \n    if(collectPayloads && match && possibleMatchPayloads.size() > 0) {\n      matchPayload.addAll(possibleMatchPayloads);\n    }\n\n    return match; // ordered and allowed slop\n  }\n\n","sourceOld":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by advancing\n   * all subSpans except the last one in reverse order.\n   */\n  private boolean shrinkToAfterShortestMatch() throws IOException {\n    matchStart = subSpans[subSpans.length - 1].start();\n    matchEnd = subSpans[subSpans.length - 1].end();\n    Set possibleMatchPayloads = new HashSet();\n    if (subSpans[subSpans.length - 1].isPayloadAvailable()) {\n      possibleMatchPayloads.addAll(subSpans[subSpans.length - 1].getPayload());\n    }\n\n    Collection possiblePayload = null;\n    \n    int matchSlop = 0;\n    int lastStart = matchStart;\n    int lastEnd = matchEnd;\n    for (int i = subSpans.length - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans[i];\n      if (collectPayloads && prevSpans.isPayloadAvailable()) {\n        Collection payload = prevSpans.getPayload();\n        possiblePayload = new ArrayList(payload.size());\n        possiblePayload.addAll(payload);\n      }\n      \n      int prevStart = prevSpans.start();\n      int prevEnd = prevSpans.end();\n      while (true) { // Advance prevSpans until after (lastStart, lastEnd)\n        if (! prevSpans.next()) {\n          inSameDoc = false;\n          more = false;\n          break; // Check remaining subSpans for final match.\n        } else if (matchDoc != prevSpans.doc()) {\n          inSameDoc = false; // The last subSpans is not advanced here.\n          break; // Check remaining subSpans for last match in this document.\n        } else {\n          int ppStart = prevSpans.start();\n          int ppEnd = prevSpans.end(); // Cannot avoid invoking .end()\n          if (! docSpansOrdered(ppStart, ppEnd, lastStart, lastEnd)) {\n            break; // Check remaining subSpans.\n          } else { // prevSpans still before (lastStart, lastEnd)\n            prevStart = ppStart;\n            prevEnd = ppEnd;\n            if (collectPayloads && prevSpans.isPayloadAvailable()) {\n              Collection payload = prevSpans.getPayload();\n              possiblePayload = new ArrayList(payload.size());\n              possiblePayload.addAll(payload);\n            }\n          }\n        }\n      }\n\n      if (collectPayloads && possiblePayload != null) {\n        possibleMatchPayloads.addAll(possiblePayload);\n      }\n      \n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that subSpans[0] is advanced after the match, if any.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n      lastEnd = prevEnd;\n    }\n    \n    boolean match = matchSlop <= allowedSlop;\n    \n    if(collectPayloads && match && possibleMatchPayloads.size() > 0) {\n      matchPayload.addAll(possibleMatchPayloads);\n    }\n\n    return match; // ordered and allowed slop\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","pathOld":"src/java/org/apache/lucene/search/spans/NearSpansOrdered#shrinkToAfterShortestMatch().mjava","sourceNew":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by advancing\n   * all subSpans except the last one in reverse order.\n   */\n  private boolean shrinkToAfterShortestMatch() throws IOException {\n    matchStart = subSpans[subSpans.length - 1].start();\n    matchEnd = subSpans[subSpans.length - 1].end();\n    Set<byte[]> possibleMatchPayloads = new HashSet<byte[]>();\n    if (subSpans[subSpans.length - 1].isPayloadAvailable()) {\n      possibleMatchPayloads.addAll(subSpans[subSpans.length - 1].getPayload());\n    }\n\n    Collection<byte[]> possiblePayload = null;\n    \n    int matchSlop = 0;\n    int lastStart = matchStart;\n    int lastEnd = matchEnd;\n    for (int i = subSpans.length - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans[i];\n      if (collectPayloads && prevSpans.isPayloadAvailable()) {\n        Collection<byte[]> payload = prevSpans.getPayload();\n        possiblePayload = new ArrayList<byte[]>(payload.size());\n        possiblePayload.addAll(payload);\n      }\n      \n      int prevStart = prevSpans.start();\n      int prevEnd = prevSpans.end();\n      while (true) { // Advance prevSpans until after (lastStart, lastEnd)\n        if (! prevSpans.next()) {\n          inSameDoc = false;\n          more = false;\n          break; // Check remaining subSpans for final match.\n        } else if (matchDoc != prevSpans.doc()) {\n          inSameDoc = false; // The last subSpans is not advanced here.\n          break; // Check remaining subSpans for last match in this document.\n        } else {\n          int ppStart = prevSpans.start();\n          int ppEnd = prevSpans.end(); // Cannot avoid invoking .end()\n          if (! docSpansOrdered(ppStart, ppEnd, lastStart, lastEnd)) {\n            break; // Check remaining subSpans.\n          } else { // prevSpans still before (lastStart, lastEnd)\n            prevStart = ppStart;\n            prevEnd = ppEnd;\n            if (collectPayloads && prevSpans.isPayloadAvailable()) {\n              Collection<byte[]> payload = prevSpans.getPayload();\n              possiblePayload = new ArrayList<byte[]>(payload.size());\n              possiblePayload.addAll(payload);\n            }\n          }\n        }\n      }\n\n      if (collectPayloads && possiblePayload != null) {\n        possibleMatchPayloads.addAll(possiblePayload);\n      }\n      \n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that subSpans[0] is advanced after the match, if any.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n      lastEnd = prevEnd;\n    }\n    \n    boolean match = matchSlop <= allowedSlop;\n    \n    if(collectPayloads && match && possibleMatchPayloads.size() > 0) {\n      matchPayload.addAll(possibleMatchPayloads);\n    }\n\n    return match; // ordered and allowed slop\n  }\n\n","sourceOld":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by advancing\n   * all subSpans except the last one in reverse order.\n   */\n  private boolean shrinkToAfterShortestMatch() throws IOException {\n    matchStart = subSpans[subSpans.length - 1].start();\n    matchEnd = subSpans[subSpans.length - 1].end();\n    Set<byte[]> possibleMatchPayloads = new HashSet<byte[]>();\n    if (subSpans[subSpans.length - 1].isPayloadAvailable()) {\n      possibleMatchPayloads.addAll(subSpans[subSpans.length - 1].getPayload());\n    }\n\n    Collection<byte[]> possiblePayload = null;\n    \n    int matchSlop = 0;\n    int lastStart = matchStart;\n    int lastEnd = matchEnd;\n    for (int i = subSpans.length - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans[i];\n      if (collectPayloads && prevSpans.isPayloadAvailable()) {\n        Collection<byte[]> payload = prevSpans.getPayload();\n        possiblePayload = new ArrayList<byte[]>(payload.size());\n        possiblePayload.addAll(payload);\n      }\n      \n      int prevStart = prevSpans.start();\n      int prevEnd = prevSpans.end();\n      while (true) { // Advance prevSpans until after (lastStart, lastEnd)\n        if (! prevSpans.next()) {\n          inSameDoc = false;\n          more = false;\n          break; // Check remaining subSpans for final match.\n        } else if (matchDoc != prevSpans.doc()) {\n          inSameDoc = false; // The last subSpans is not advanced here.\n          break; // Check remaining subSpans for last match in this document.\n        } else {\n          int ppStart = prevSpans.start();\n          int ppEnd = prevSpans.end(); // Cannot avoid invoking .end()\n          if (! docSpansOrdered(ppStart, ppEnd, lastStart, lastEnd)) {\n            break; // Check remaining subSpans.\n          } else { // prevSpans still before (lastStart, lastEnd)\n            prevStart = ppStart;\n            prevEnd = ppEnd;\n            if (collectPayloads && prevSpans.isPayloadAvailable()) {\n              Collection<byte[]> payload = prevSpans.getPayload();\n              possiblePayload = new ArrayList<byte[]>(payload.size());\n              possiblePayload.addAll(payload);\n            }\n          }\n        }\n      }\n\n      if (collectPayloads && possiblePayload != null) {\n        possibleMatchPayloads.addAll(possiblePayload);\n      }\n      \n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that subSpans[0] is advanced after the match, if any.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n      lastEnd = prevEnd;\n    }\n    \n    boolean match = matchSlop <= allowedSlop;\n    \n    if(collectPayloads && match && possibleMatchPayloads.size() > 0) {\n      matchPayload.addAll(possibleMatchPayloads);\n    }\n\n    return match; // ordered and allowed slop\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"b00d44ccb616bf40482a9ba5302cb256c26c6e4c":["441e4370677ea6e64691231510de2a90b67dd2fb"],"98bc22650ab0fe51f9c00513397bfa42a64fc663":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"441e4370677ea6e64691231510de2a90b67dd2fb":["fd5947db4de866f035b932f219674c03562d904e"],"ef82ff03e4016c705811b2658e81471a645c0e49":["ff93c6759a7da468c20c64fb459f85bccd0af370"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fd5947db4de866f035b932f219674c03562d904e":["98bc22650ab0fe51f9c00513397bfa42a64fc663"],"ff93c6759a7da468c20c64fb459f85bccd0af370":["b00d44ccb616bf40482a9ba5302cb256c26c6e4c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["ef82ff03e4016c705811b2658e81471a645c0e49"]},"commit2Childs":{"b00d44ccb616bf40482a9ba5302cb256c26c6e4c":["ff93c6759a7da468c20c64fb459f85bccd0af370"],"98bc22650ab0fe51f9c00513397bfa42a64fc663":["fd5947db4de866f035b932f219674c03562d904e"],"441e4370677ea6e64691231510de2a90b67dd2fb":["b00d44ccb616bf40482a9ba5302cb256c26c6e4c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["98bc22650ab0fe51f9c00513397bfa42a64fc663"],"ef82ff03e4016c705811b2658e81471a645c0e49":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"fd5947db4de866f035b932f219674c03562d904e":["441e4370677ea6e64691231510de2a90b67dd2fb"],"ff93c6759a7da468c20c64fb459f85bccd0af370":["ef82ff03e4016c705811b2658e81471a645c0e49"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}