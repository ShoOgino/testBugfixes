{"path":"lucene/facet/src/java/org/apache/lucene/facet/search/FacetResult#mergeHierarchies(List[FacetResult],TaxonomyReader,Map[String,FacetArrays]).mjava","commits":[{"id":"ff6a0dc6ca67172f353dbc6b826e324f84d378ef","date":1369831625,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/FacetResult#mergeHierarchies(List[FacetResult],TaxonomyReader,Map[String,FacetArrays]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * A utility for merging multiple {@link FacetResult} of the same\n   * (hierarchical) dimension into a single {@link FacetResult}, to reconstruct\n   * the hierarchy. The results are merged according to the following rules:\n   * <ul>\n   * <li>If two results share the same dimension (first component in their\n   * {@link CategoryPath}), they are merged.\n   * <li>If a result is missing ancestors in the other results, e.g. A/B/C but\n   * no corresponding A or A/B, these nodes are 'filled' with their label,\n   * ordinal and value (obtained from the respective {@link FacetArrays}).\n   * <li>If a result does not share a dimension with other results, it is\n   * returned as is.\n   * </ul>\n   * <p>\n   * <b>NOTE:</b> the returned results are not guaranteed to be in the same\n   * order of the input ones.\n   * \n   * @param results\n   *          the results to merge\n   * @param taxoReader\n   *          the {@link TaxonomyReader} to use when creating missing ancestor\n   *          nodes\n   * @param dimArrays\n   *          a mapping from a dimension to the respective {@link FacetArrays}\n   *          from which to pull the nodes values\n   */\n  public static List<FacetResult> mergeHierarchies(List<FacetResult> results, TaxonomyReader taxoReader,\n      Map<String, FacetArrays> dimArrays) throws IOException {\n    final Map<String, List<FacetResult>> dims = new HashMap<>();\n    for (FacetResult fr : results) {\n      String dim = fr.getFacetRequest().categoryPath.components[0];\n      List<FacetResult> frs = dims.get(dim);\n      if (frs == null) {\n        frs = new ArrayList<>();\n        dims.put(dim, frs);\n      }\n      frs.add(fr);\n    }\n\n    final List<FacetResult> res = new ArrayList<>();\n    for (List<FacetResult> frs : dims.values()) {\n      FacetResult mergedResult = frs.get(0);\n      if (frs.size() > 1) {\n        CollectionUtil.introSort(frs, new Comparator<FacetResult>() {\n          @Override\n          public int compare(FacetResult fr1, FacetResult fr2) {\n            return fr1.getFacetRequest().categoryPath.compareTo(fr2.getFacetRequest().categoryPath);\n          }\n        });\n        Map<CategoryPath, FacetResultNode> mergedNodes = new HashMap<>();\n        FacetArrays arrays = dimArrays != null ? dimArrays.get(frs.get(0).getFacetRequest().categoryPath.components[0]) : null;\n        for (FacetResult fr : frs) {\n          FacetResultNode frn = fr.getFacetResultNode();\n          FacetResultNode merged = mergedNodes.get(frn.label);\n          if (merged == null) {\n            CategoryPath parent = frn.label.subpath(frn.label.length - 1);\n            FacetResultNode childNode = frn;\n            FacetResultNode parentNode = null;\n            while (parent.length > 0 && (parentNode = mergedNodes.get(parent)) == null) {\n              int parentOrd = taxoReader.getOrdinal(parent);\n              double parentValue = arrays != null ? fr.getFacetRequest().getValueOf(arrays, parentOrd) : -1;\n              parentNode = new FacetResultNode(parentOrd, parentValue);\n              parentNode.label = parent;\n              parentNode.subResults = new ArrayList<>();\n              parentNode.subResults.add(childNode);\n              mergedNodes.put(parent, parentNode);\n              childNode = parentNode;\n              parent = parent.subpath(parent.length - 1);\n            }\n\n            // at least one parent was added, so link the final (existing)\n            // parent with the child\n            if (parent.length > 0) {\n              if (!(parentNode.subResults instanceof ArrayList)) {\n                parentNode.subResults = new ArrayList<>(parentNode.subResults);\n              }\n              parentNode.subResults.add(childNode);\n            }\n\n            // for missing FRNs, add new ones with label and value=-1\n            // first time encountered this label, add it and all its children to\n            // the map.\n            mergedNodes.put(frn.label, frn);\n            for (FacetResultNode child : frn.subResults) {\n              addIfNotExist(mergedNodes, child);\n            }\n          } else {\n            if (!(merged.subResults instanceof ArrayList)) {\n              merged.subResults = new ArrayList<>(merged.subResults);\n            }\n            for (FacetResultNode sub : frn.subResults) {\n              // make sure sub wasn't already added\n              sub = addIfNotExist(mergedNodes, sub);\n              if (!merged.subResults.contains(sub)) {\n                merged.subResults.add(sub);\n              }\n            }\n          }\n        }\n        \n        // find the 'first' node to put on the FacetResult root\n        CategoryPath min = null;\n        for (CategoryPath cp : mergedNodes.keySet()) {\n          if (min == null || cp.compareTo(min) < 0) {\n            min = cp;\n          }\n        }\n        FacetRequest dummy = new FacetRequest(min, frs.get(0).getFacetRequest().numResults) {\n          @Override\n          public double getValueOf(FacetArrays arrays, int idx) {\n            throw new UnsupportedOperationException(\"not supported by this request\");\n          }\n          \n          @Override\n          public FacetArraysSource getFacetArraysSource() {\n            throw new UnsupportedOperationException(\"not supported by this request\");\n          }\n        };\n        mergedResult = new FacetResult(dummy, mergedNodes.get(min), -1);\n      }\n      res.add(mergedResult);\n    }\n    return res;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"35d59eaf6a197e412d53262def39f05f06d71a06","date":1369832066,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/FacetResult#mergeHierarchies(List[FacetResult],TaxonomyReader,Map[String,FacetArrays]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/FacetResult#mergeHierarchies(List[FacetResult],TaxonomyReader,Map[String,FacetArrays]).mjava","sourceNew":"  /**\n   * A utility for merging multiple {@link FacetResult} of the same\n   * (hierarchical) dimension into a single {@link FacetResult}, to reconstruct\n   * the hierarchy. The results are merged according to the following rules:\n   * <ul>\n   * <li>If two results share the same dimension (first component in their\n   * {@link CategoryPath}), they are merged.\n   * <li>If a result is missing ancestors in the other results, e.g. A/B/C but\n   * no corresponding A or A/B, these nodes are 'filled' with their label,\n   * ordinal and value (obtained from the respective {@link FacetArrays}).\n   * <li>If a result does not share a dimension with other results, it is\n   * returned as is.\n   * </ul>\n   * <p>\n   * <b>NOTE:</b> the returned results are not guaranteed to be in the same\n   * order of the input ones.\n   * \n   * @param results\n   *          the results to merge\n   * @param taxoReader\n   *          the {@link TaxonomyReader} to use when creating missing ancestor\n   *          nodes\n   * @param dimArrays\n   *          a mapping from a dimension to the respective {@link FacetArrays}\n   *          from which to pull the nodes values\n   */\n  public static List<FacetResult> mergeHierarchies(List<FacetResult> results, TaxonomyReader taxoReader,\n      Map<String, FacetArrays> dimArrays) throws IOException {\n    final Map<String, List<FacetResult>> dims = new HashMap<String,List<FacetResult>>();\n    for (FacetResult fr : results) {\n      String dim = fr.getFacetRequest().categoryPath.components[0];\n      List<FacetResult> frs = dims.get(dim);\n      if (frs == null) {\n        frs = new ArrayList<FacetResult>();\n        dims.put(dim, frs);\n      }\n      frs.add(fr);\n    }\n\n    final List<FacetResult> res = new ArrayList<FacetResult>();\n    for (List<FacetResult> frs : dims.values()) {\n      FacetResult mergedResult = frs.get(0);\n      if (frs.size() > 1) {\n        CollectionUtil.introSort(frs, new Comparator<FacetResult>() {\n          @Override\n          public int compare(FacetResult fr1, FacetResult fr2) {\n            return fr1.getFacetRequest().categoryPath.compareTo(fr2.getFacetRequest().categoryPath);\n          }\n        });\n        Map<CategoryPath, FacetResultNode> mergedNodes = new HashMap<CategoryPath,FacetResultNode>();\n        FacetArrays arrays = dimArrays != null ? dimArrays.get(frs.get(0).getFacetRequest().categoryPath.components[0]) : null;\n        for (FacetResult fr : frs) {\n          FacetResultNode frn = fr.getFacetResultNode();\n          FacetResultNode merged = mergedNodes.get(frn.label);\n          if (merged == null) {\n            CategoryPath parent = frn.label.subpath(frn.label.length - 1);\n            FacetResultNode childNode = frn;\n            FacetResultNode parentNode = null;\n            while (parent.length > 0 && (parentNode = mergedNodes.get(parent)) == null) {\n              int parentOrd = taxoReader.getOrdinal(parent);\n              double parentValue = arrays != null ? fr.getFacetRequest().getValueOf(arrays, parentOrd) : -1;\n              parentNode = new FacetResultNode(parentOrd, parentValue);\n              parentNode.label = parent;\n              parentNode.subResults = new ArrayList<FacetResultNode>();\n              parentNode.subResults.add(childNode);\n              mergedNodes.put(parent, parentNode);\n              childNode = parentNode;\n              parent = parent.subpath(parent.length - 1);\n            }\n\n            // at least one parent was added, so link the final (existing)\n            // parent with the child\n            if (parent.length > 0) {\n              if (!(parentNode.subResults instanceof ArrayList)) {\n                parentNode.subResults = new ArrayList<FacetResultNode>(parentNode.subResults);\n              }\n              parentNode.subResults.add(childNode);\n            }\n\n            // for missing FRNs, add new ones with label and value=-1\n            // first time encountered this label, add it and all its children to\n            // the map.\n            mergedNodes.put(frn.label, frn);\n            for (FacetResultNode child : frn.subResults) {\n              addIfNotExist(mergedNodes, child);\n            }\n          } else {\n            if (!(merged.subResults instanceof ArrayList)) {\n              merged.subResults = new ArrayList<FacetResultNode>(merged.subResults);\n            }\n            for (FacetResultNode sub : frn.subResults) {\n              // make sure sub wasn't already added\n              sub = addIfNotExist(mergedNodes, sub);\n              if (!merged.subResults.contains(sub)) {\n                merged.subResults.add(sub);\n              }\n            }\n          }\n        }\n        \n        // find the 'first' node to put on the FacetResult root\n        CategoryPath min = null;\n        for (CategoryPath cp : mergedNodes.keySet()) {\n          if (min == null || cp.compareTo(min) < 0) {\n            min = cp;\n          }\n        }\n        FacetRequest dummy = new FacetRequest(min, frs.get(0).getFacetRequest().numResults) {\n          @Override\n          public double getValueOf(FacetArrays arrays, int idx) {\n            throw new UnsupportedOperationException(\"not supported by this request\");\n          }\n          \n          @Override\n          public FacetArraysSource getFacetArraysSource() {\n            throw new UnsupportedOperationException(\"not supported by this request\");\n          }\n        };\n        mergedResult = new FacetResult(dummy, mergedNodes.get(min), -1);\n      }\n      res.add(mergedResult);\n    }\n    return res;\n  }\n\n","sourceOld":"  /**\n   * A utility for merging multiple {@link FacetResult} of the same\n   * (hierarchical) dimension into a single {@link FacetResult}, to reconstruct\n   * the hierarchy. The results are merged according to the following rules:\n   * <ul>\n   * <li>If two results share the same dimension (first component in their\n   * {@link CategoryPath}), they are merged.\n   * <li>If a result is missing ancestors in the other results, e.g. A/B/C but\n   * no corresponding A or A/B, these nodes are 'filled' with their label,\n   * ordinal and value (obtained from the respective {@link FacetArrays}).\n   * <li>If a result does not share a dimension with other results, it is\n   * returned as is.\n   * </ul>\n   * <p>\n   * <b>NOTE:</b> the returned results are not guaranteed to be in the same\n   * order of the input ones.\n   * \n   * @param results\n   *          the results to merge\n   * @param taxoReader\n   *          the {@link TaxonomyReader} to use when creating missing ancestor\n   *          nodes\n   * @param dimArrays\n   *          a mapping from a dimension to the respective {@link FacetArrays}\n   *          from which to pull the nodes values\n   */\n  public static List<FacetResult> mergeHierarchies(List<FacetResult> results, TaxonomyReader taxoReader,\n      Map<String, FacetArrays> dimArrays) throws IOException {\n    final Map<String, List<FacetResult>> dims = new HashMap<>();\n    for (FacetResult fr : results) {\n      String dim = fr.getFacetRequest().categoryPath.components[0];\n      List<FacetResult> frs = dims.get(dim);\n      if (frs == null) {\n        frs = new ArrayList<>();\n        dims.put(dim, frs);\n      }\n      frs.add(fr);\n    }\n\n    final List<FacetResult> res = new ArrayList<>();\n    for (List<FacetResult> frs : dims.values()) {\n      FacetResult mergedResult = frs.get(0);\n      if (frs.size() > 1) {\n        CollectionUtil.introSort(frs, new Comparator<FacetResult>() {\n          @Override\n          public int compare(FacetResult fr1, FacetResult fr2) {\n            return fr1.getFacetRequest().categoryPath.compareTo(fr2.getFacetRequest().categoryPath);\n          }\n        });\n        Map<CategoryPath, FacetResultNode> mergedNodes = new HashMap<>();\n        FacetArrays arrays = dimArrays != null ? dimArrays.get(frs.get(0).getFacetRequest().categoryPath.components[0]) : null;\n        for (FacetResult fr : frs) {\n          FacetResultNode frn = fr.getFacetResultNode();\n          FacetResultNode merged = mergedNodes.get(frn.label);\n          if (merged == null) {\n            CategoryPath parent = frn.label.subpath(frn.label.length - 1);\n            FacetResultNode childNode = frn;\n            FacetResultNode parentNode = null;\n            while (parent.length > 0 && (parentNode = mergedNodes.get(parent)) == null) {\n              int parentOrd = taxoReader.getOrdinal(parent);\n              double parentValue = arrays != null ? fr.getFacetRequest().getValueOf(arrays, parentOrd) : -1;\n              parentNode = new FacetResultNode(parentOrd, parentValue);\n              parentNode.label = parent;\n              parentNode.subResults = new ArrayList<>();\n              parentNode.subResults.add(childNode);\n              mergedNodes.put(parent, parentNode);\n              childNode = parentNode;\n              parent = parent.subpath(parent.length - 1);\n            }\n\n            // at least one parent was added, so link the final (existing)\n            // parent with the child\n            if (parent.length > 0) {\n              if (!(parentNode.subResults instanceof ArrayList)) {\n                parentNode.subResults = new ArrayList<>(parentNode.subResults);\n              }\n              parentNode.subResults.add(childNode);\n            }\n\n            // for missing FRNs, add new ones with label and value=-1\n            // first time encountered this label, add it and all its children to\n            // the map.\n            mergedNodes.put(frn.label, frn);\n            for (FacetResultNode child : frn.subResults) {\n              addIfNotExist(mergedNodes, child);\n            }\n          } else {\n            if (!(merged.subResults instanceof ArrayList)) {\n              merged.subResults = new ArrayList<>(merged.subResults);\n            }\n            for (FacetResultNode sub : frn.subResults) {\n              // make sure sub wasn't already added\n              sub = addIfNotExist(mergedNodes, sub);\n              if (!merged.subResults.contains(sub)) {\n                merged.subResults.add(sub);\n              }\n            }\n          }\n        }\n        \n        // find the 'first' node to put on the FacetResult root\n        CategoryPath min = null;\n        for (CategoryPath cp : mergedNodes.keySet()) {\n          if (min == null || cp.compareTo(min) < 0) {\n            min = cp;\n          }\n        }\n        FacetRequest dummy = new FacetRequest(min, frs.get(0).getFacetRequest().numResults) {\n          @Override\n          public double getValueOf(FacetArrays arrays, int idx) {\n            throw new UnsupportedOperationException(\"not supported by this request\");\n          }\n          \n          @Override\n          public FacetArraysSource getFacetArraysSource() {\n            throw new UnsupportedOperationException(\"not supported by this request\");\n          }\n        };\n        mergedResult = new FacetResult(dummy, mergedNodes.get(min), -1);\n      }\n      res.add(mergedResult);\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49","date":1375103250,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/FacetResult#mergeHierarchies(List[FacetResult],TaxonomyReader,Map[String,FacetArrays]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/FacetResult#mergeHierarchies(List[FacetResult],TaxonomyReader,Map[String,FacetArrays]).mjava","sourceNew":"  /**\n   * A utility for merging multiple {@link FacetResult} of the same\n   * (hierarchical) dimension into a single {@link FacetResult}, to reconstruct\n   * the hierarchy. The results are merged according to the following rules:\n   * <ul>\n   * <li>If two results share the same dimension (first component in their\n   * {@link CategoryPath}), they are merged.\n   * <li>If a result is missing ancestors in the other results, e.g. A/B/C but\n   * no corresponding A or A/B, these nodes are 'filled' with their label,\n   * ordinal and value (obtained from the respective {@link FacetArrays}).\n   * <li>If a result does not share a dimension with other results, it is\n   * returned as is.\n   * </ul>\n   * <p>\n   * <b>NOTE:</b> the returned results are not guaranteed to be in the same\n   * order of the input ones.\n   * \n   * @param results\n   *          the results to merge\n   * @param taxoReader\n   *          the {@link TaxonomyReader} to use when creating missing ancestor\n   *          nodes\n   * @param dimArrays\n   *          a mapping from a dimension to the respective {@link FacetArrays}\n   *          from which to pull the nodes values\n   */\n  public static List<FacetResult> mergeHierarchies(List<FacetResult> results, TaxonomyReader taxoReader,\n      Map<String, FacetArrays> dimArrays) throws IOException {\n    final Map<String, List<FacetResult>> dims = new HashMap<String,List<FacetResult>>();\n    for (FacetResult fr : results) {\n      String dim = fr.getFacetRequest().categoryPath.components[0];\n      List<FacetResult> frs = dims.get(dim);\n      if (frs == null) {\n        frs = new ArrayList<FacetResult>();\n        dims.put(dim, frs);\n      }\n      frs.add(fr);\n    }\n\n    final List<FacetResult> res = new ArrayList<FacetResult>();\n    for (List<FacetResult> frs : dims.values()) {\n      FacetResult mergedResult = frs.get(0);\n      if (frs.size() > 1) {\n        CollectionUtil.introSort(frs, new Comparator<FacetResult>() {\n          @Override\n          public int compare(FacetResult fr1, FacetResult fr2) {\n            return fr1.getFacetRequest().categoryPath.compareTo(fr2.getFacetRequest().categoryPath);\n          }\n        });\n        Map<CategoryPath, FacetResultNode> mergedNodes = new HashMap<CategoryPath,FacetResultNode>();\n        FacetArrays arrays = dimArrays != null ? dimArrays.get(frs.get(0).getFacetRequest().categoryPath.components[0]) : null;\n        for (FacetResult fr : frs) {\n          FacetResultNode frn = fr.getFacetResultNode();\n          FacetResultNode merged = mergedNodes.get(frn.label);\n          if (merged == null) {\n            CategoryPath parent = frn.label.subpath(frn.label.length - 1);\n            FacetResultNode childNode = frn;\n            FacetResultNode parentNode = null;\n            while (parent.length > 0 && (parentNode = mergedNodes.get(parent)) == null) {\n              int parentOrd = taxoReader.getOrdinal(parent);\n              double parentValue = arrays != null ? fr.getFacetRequest().getValueOf(arrays, parentOrd) : -1;\n              parentNode = new FacetResultNode(parentOrd, parentValue);\n              parentNode.label = parent;\n              parentNode.subResults = new ArrayList<FacetResultNode>();\n              parentNode.subResults.add(childNode);\n              mergedNodes.put(parent, parentNode);\n              childNode = parentNode;\n              parent = parent.subpath(parent.length - 1);\n            }\n\n            // at least one parent was added, so link the final (existing)\n            // parent with the child\n            if (parent.length > 0) {\n              if (!(parentNode.subResults instanceof ArrayList)) {\n                parentNode.subResults = new ArrayList<FacetResultNode>(parentNode.subResults);\n              }\n              parentNode.subResults.add(childNode);\n            }\n\n            // for missing FRNs, add new ones with label and value=-1\n            // first time encountered this label, add it and all its children to\n            // the map.\n            mergedNodes.put(frn.label, frn);\n            for (FacetResultNode child : frn.subResults) {\n              addIfNotExist(mergedNodes, child);\n            }\n          } else {\n            if (!(merged.subResults instanceof ArrayList)) {\n              merged.subResults = new ArrayList<FacetResultNode>(merged.subResults);\n            }\n            for (FacetResultNode sub : frn.subResults) {\n              // make sure sub wasn't already added\n              sub = addIfNotExist(mergedNodes, sub);\n              if (!merged.subResults.contains(sub)) {\n                merged.subResults.add(sub);\n              }\n            }\n          }\n        }\n        \n        // find the 'first' node to put on the FacetResult root\n        CategoryPath min = null;\n        for (CategoryPath cp : mergedNodes.keySet()) {\n          if (min == null || cp.compareTo(min) < 0) {\n            min = cp;\n          }\n        }\n        FacetRequest dummy = new FacetRequest(min, frs.get(0).getFacetRequest().numResults) {\n          @Override\n          public FacetsAggregator createFacetsAggregator(FacetIndexingParams fip) {\n            throw new UnsupportedOperationException(\"not supported by this request\");\n          }\n          \n          @Override\n          public double getValueOf(FacetArrays arrays, int idx) {\n            throw new UnsupportedOperationException(\"not supported by this request\");\n          }\n          \n          @Override\n          public FacetArraysSource getFacetArraysSource() {\n            throw new UnsupportedOperationException(\"not supported by this request\");\n          }\n        };\n        mergedResult = new FacetResult(dummy, mergedNodes.get(min), -1);\n      }\n      res.add(mergedResult);\n    }\n    return res;\n  }\n\n","sourceOld":"  /**\n   * A utility for merging multiple {@link FacetResult} of the same\n   * (hierarchical) dimension into a single {@link FacetResult}, to reconstruct\n   * the hierarchy. The results are merged according to the following rules:\n   * <ul>\n   * <li>If two results share the same dimension (first component in their\n   * {@link CategoryPath}), they are merged.\n   * <li>If a result is missing ancestors in the other results, e.g. A/B/C but\n   * no corresponding A or A/B, these nodes are 'filled' with their label,\n   * ordinal and value (obtained from the respective {@link FacetArrays}).\n   * <li>If a result does not share a dimension with other results, it is\n   * returned as is.\n   * </ul>\n   * <p>\n   * <b>NOTE:</b> the returned results are not guaranteed to be in the same\n   * order of the input ones.\n   * \n   * @param results\n   *          the results to merge\n   * @param taxoReader\n   *          the {@link TaxonomyReader} to use when creating missing ancestor\n   *          nodes\n   * @param dimArrays\n   *          a mapping from a dimension to the respective {@link FacetArrays}\n   *          from which to pull the nodes values\n   */\n  public static List<FacetResult> mergeHierarchies(List<FacetResult> results, TaxonomyReader taxoReader,\n      Map<String, FacetArrays> dimArrays) throws IOException {\n    final Map<String, List<FacetResult>> dims = new HashMap<String,List<FacetResult>>();\n    for (FacetResult fr : results) {\n      String dim = fr.getFacetRequest().categoryPath.components[0];\n      List<FacetResult> frs = dims.get(dim);\n      if (frs == null) {\n        frs = new ArrayList<FacetResult>();\n        dims.put(dim, frs);\n      }\n      frs.add(fr);\n    }\n\n    final List<FacetResult> res = new ArrayList<FacetResult>();\n    for (List<FacetResult> frs : dims.values()) {\n      FacetResult mergedResult = frs.get(0);\n      if (frs.size() > 1) {\n        CollectionUtil.introSort(frs, new Comparator<FacetResult>() {\n          @Override\n          public int compare(FacetResult fr1, FacetResult fr2) {\n            return fr1.getFacetRequest().categoryPath.compareTo(fr2.getFacetRequest().categoryPath);\n          }\n        });\n        Map<CategoryPath, FacetResultNode> mergedNodes = new HashMap<CategoryPath,FacetResultNode>();\n        FacetArrays arrays = dimArrays != null ? dimArrays.get(frs.get(0).getFacetRequest().categoryPath.components[0]) : null;\n        for (FacetResult fr : frs) {\n          FacetResultNode frn = fr.getFacetResultNode();\n          FacetResultNode merged = mergedNodes.get(frn.label);\n          if (merged == null) {\n            CategoryPath parent = frn.label.subpath(frn.label.length - 1);\n            FacetResultNode childNode = frn;\n            FacetResultNode parentNode = null;\n            while (parent.length > 0 && (parentNode = mergedNodes.get(parent)) == null) {\n              int parentOrd = taxoReader.getOrdinal(parent);\n              double parentValue = arrays != null ? fr.getFacetRequest().getValueOf(arrays, parentOrd) : -1;\n              parentNode = new FacetResultNode(parentOrd, parentValue);\n              parentNode.label = parent;\n              parentNode.subResults = new ArrayList<FacetResultNode>();\n              parentNode.subResults.add(childNode);\n              mergedNodes.put(parent, parentNode);\n              childNode = parentNode;\n              parent = parent.subpath(parent.length - 1);\n            }\n\n            // at least one parent was added, so link the final (existing)\n            // parent with the child\n            if (parent.length > 0) {\n              if (!(parentNode.subResults instanceof ArrayList)) {\n                parentNode.subResults = new ArrayList<FacetResultNode>(parentNode.subResults);\n              }\n              parentNode.subResults.add(childNode);\n            }\n\n            // for missing FRNs, add new ones with label and value=-1\n            // first time encountered this label, add it and all its children to\n            // the map.\n            mergedNodes.put(frn.label, frn);\n            for (FacetResultNode child : frn.subResults) {\n              addIfNotExist(mergedNodes, child);\n            }\n          } else {\n            if (!(merged.subResults instanceof ArrayList)) {\n              merged.subResults = new ArrayList<FacetResultNode>(merged.subResults);\n            }\n            for (FacetResultNode sub : frn.subResults) {\n              // make sure sub wasn't already added\n              sub = addIfNotExist(mergedNodes, sub);\n              if (!merged.subResults.contains(sub)) {\n                merged.subResults.add(sub);\n              }\n            }\n          }\n        }\n        \n        // find the 'first' node to put on the FacetResult root\n        CategoryPath min = null;\n        for (CategoryPath cp : mergedNodes.keySet()) {\n          if (min == null || cp.compareTo(min) < 0) {\n            min = cp;\n          }\n        }\n        FacetRequest dummy = new FacetRequest(min, frs.get(0).getFacetRequest().numResults) {\n          @Override\n          public double getValueOf(FacetArrays arrays, int idx) {\n            throw new UnsupportedOperationException(\"not supported by this request\");\n          }\n          \n          @Override\n          public FacetArraysSource getFacetArraysSource() {\n            throw new UnsupportedOperationException(\"not supported by this request\");\n          }\n        };\n        mergedResult = new FacetResult(dummy, mergedNodes.get(min), -1);\n      }\n      res.add(mergedResult);\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b1c67b5eba853532b31132bf5aef70a3b2be63f","date":1375351298,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/FacetResult#mergeHierarchies(List[FacetResult],TaxonomyReader,Map[String,FacetArrays]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/FacetResult#mergeHierarchies(List[FacetResult],TaxonomyReader,Map[String,FacetArrays]).mjava","sourceNew":"  /**\n   * A utility for merging multiple {@link FacetResult} of the same\n   * (hierarchical) dimension into a single {@link FacetResult}, to reconstruct\n   * the hierarchy. The results are merged according to the following rules:\n   * <ul>\n   * <li>If two results share the same dimension (first component in their\n   * {@link CategoryPath}), they are merged.\n   * <li>If a result is missing ancestors in the other results, e.g. A/B/C but\n   * no corresponding A or A/B, these nodes are 'filled' with their label,\n   * ordinal and value (obtained from the respective {@link FacetArrays}).\n   * <li>If a result does not share a dimension with other results, it is\n   * returned as is.\n   * </ul>\n   * <p>\n   * <b>NOTE:</b> the returned results are not guaranteed to be in the same\n   * order of the input ones.\n   * \n   * @param results\n   *          the results to merge\n   * @param taxoReader\n   *          the {@link TaxonomyReader} to use when creating missing ancestor\n   *          nodes\n   * @param dimArrays\n   *          a mapping from a dimension to the respective {@link FacetArrays}\n   *          from which to pull the nodes values\n   */\n  public static List<FacetResult> mergeHierarchies(List<FacetResult> results, TaxonomyReader taxoReader,\n      Map<String, FacetArrays> dimArrays) throws IOException {\n    final Map<String, List<FacetResult>> dims = new HashMap<String,List<FacetResult>>();\n    for (FacetResult fr : results) {\n      String dim = fr.getFacetRequest().categoryPath.components[0];\n      List<FacetResult> frs = dims.get(dim);\n      if (frs == null) {\n        frs = new ArrayList<FacetResult>();\n        dims.put(dim, frs);\n      }\n      frs.add(fr);\n    }\n\n    final List<FacetResult> res = new ArrayList<FacetResult>();\n    for (List<FacetResult> frs : dims.values()) {\n      FacetResult mergedResult = frs.get(0);\n      if (frs.size() > 1) {\n        CollectionUtil.introSort(frs, new Comparator<FacetResult>() {\n          @Override\n          public int compare(FacetResult fr1, FacetResult fr2) {\n            return fr1.getFacetRequest().categoryPath.compareTo(fr2.getFacetRequest().categoryPath);\n          }\n        });\n        Map<CategoryPath, FacetResultNode> mergedNodes = new HashMap<CategoryPath,FacetResultNode>();\n        FacetArrays arrays = dimArrays != null ? dimArrays.get(frs.get(0).getFacetRequest().categoryPath.components[0]) : null;\n        for (FacetResult fr : frs) {\n          FacetRequest freq = fr.getFacetRequest();\n          OrdinalValueResolver resolver = null;\n          if (arrays != null) {\n            resolver = freq.createFacetsAggregator(FacetIndexingParams.DEFAULT).createOrdinalValueResolver(freq, arrays);\n          }\n          FacetResultNode frn = fr.getFacetResultNode();\n          FacetResultNode merged = mergedNodes.get(frn.label);\n          if (merged == null) {\n            CategoryPath parent = frn.label.subpath(frn.label.length - 1);\n            FacetResultNode childNode = frn;\n            FacetResultNode parentNode = null;\n            while (parent.length > 0 && (parentNode = mergedNodes.get(parent)) == null) {\n              int parentOrd = taxoReader.getOrdinal(parent);\n              double parentValue = -1;\n              if (arrays != null) {\n                parentValue = resolver.valueOf(parentOrd);\n              }\n              parentNode = new FacetResultNode(parentOrd, parentValue);\n              parentNode.label = parent;\n              parentNode.subResults = new ArrayList<FacetResultNode>();\n              parentNode.subResults.add(childNode);\n              mergedNodes.put(parent, parentNode);\n              childNode = parentNode;\n              parent = parent.subpath(parent.length - 1);\n            }\n\n            // at least one parent was added, so link the final (existing)\n            // parent with the child\n            if (parent.length > 0) {\n              if (!(parentNode.subResults instanceof ArrayList)) {\n                parentNode.subResults = new ArrayList<FacetResultNode>(parentNode.subResults);\n              }\n              parentNode.subResults.add(childNode);\n            }\n\n            // for missing FRNs, add new ones with label and value=-1\n            // first time encountered this label, add it and all its children to\n            // the map.\n            mergedNodes.put(frn.label, frn);\n            for (FacetResultNode child : frn.subResults) {\n              addIfNotExist(mergedNodes, child);\n            }\n          } else {\n            if (!(merged.subResults instanceof ArrayList)) {\n              merged.subResults = new ArrayList<FacetResultNode>(merged.subResults);\n            }\n            for (FacetResultNode sub : frn.subResults) {\n              // make sure sub wasn't already added\n              sub = addIfNotExist(mergedNodes, sub);\n              if (!merged.subResults.contains(sub)) {\n                merged.subResults.add(sub);\n              }\n            }\n          }\n        }\n        \n        // find the 'first' node to put on the FacetResult root\n        CategoryPath min = null;\n        for (CategoryPath cp : mergedNodes.keySet()) {\n          if (min == null || cp.compareTo(min) < 0) {\n            min = cp;\n          }\n        }\n        FacetRequest dummy = new FacetRequest(min, frs.get(0).getFacetRequest().numResults) {\n          @Override\n          public FacetsAggregator createFacetsAggregator(FacetIndexingParams fip) {\n            throw new UnsupportedOperationException(\"not supported by this request\");\n          }\n        };\n        mergedResult = new FacetResult(dummy, mergedNodes.get(min), -1);\n      }\n      res.add(mergedResult);\n    }\n    return res;\n  }\n\n","sourceOld":"  /**\n   * A utility for merging multiple {@link FacetResult} of the same\n   * (hierarchical) dimension into a single {@link FacetResult}, to reconstruct\n   * the hierarchy. The results are merged according to the following rules:\n   * <ul>\n   * <li>If two results share the same dimension (first component in their\n   * {@link CategoryPath}), they are merged.\n   * <li>If a result is missing ancestors in the other results, e.g. A/B/C but\n   * no corresponding A or A/B, these nodes are 'filled' with their label,\n   * ordinal and value (obtained from the respective {@link FacetArrays}).\n   * <li>If a result does not share a dimension with other results, it is\n   * returned as is.\n   * </ul>\n   * <p>\n   * <b>NOTE:</b> the returned results are not guaranteed to be in the same\n   * order of the input ones.\n   * \n   * @param results\n   *          the results to merge\n   * @param taxoReader\n   *          the {@link TaxonomyReader} to use when creating missing ancestor\n   *          nodes\n   * @param dimArrays\n   *          a mapping from a dimension to the respective {@link FacetArrays}\n   *          from which to pull the nodes values\n   */\n  public static List<FacetResult> mergeHierarchies(List<FacetResult> results, TaxonomyReader taxoReader,\n      Map<String, FacetArrays> dimArrays) throws IOException {\n    final Map<String, List<FacetResult>> dims = new HashMap<String,List<FacetResult>>();\n    for (FacetResult fr : results) {\n      String dim = fr.getFacetRequest().categoryPath.components[0];\n      List<FacetResult> frs = dims.get(dim);\n      if (frs == null) {\n        frs = new ArrayList<FacetResult>();\n        dims.put(dim, frs);\n      }\n      frs.add(fr);\n    }\n\n    final List<FacetResult> res = new ArrayList<FacetResult>();\n    for (List<FacetResult> frs : dims.values()) {\n      FacetResult mergedResult = frs.get(0);\n      if (frs.size() > 1) {\n        CollectionUtil.introSort(frs, new Comparator<FacetResult>() {\n          @Override\n          public int compare(FacetResult fr1, FacetResult fr2) {\n            return fr1.getFacetRequest().categoryPath.compareTo(fr2.getFacetRequest().categoryPath);\n          }\n        });\n        Map<CategoryPath, FacetResultNode> mergedNodes = new HashMap<CategoryPath,FacetResultNode>();\n        FacetArrays arrays = dimArrays != null ? dimArrays.get(frs.get(0).getFacetRequest().categoryPath.components[0]) : null;\n        for (FacetResult fr : frs) {\n          FacetResultNode frn = fr.getFacetResultNode();\n          FacetResultNode merged = mergedNodes.get(frn.label);\n          if (merged == null) {\n            CategoryPath parent = frn.label.subpath(frn.label.length - 1);\n            FacetResultNode childNode = frn;\n            FacetResultNode parentNode = null;\n            while (parent.length > 0 && (parentNode = mergedNodes.get(parent)) == null) {\n              int parentOrd = taxoReader.getOrdinal(parent);\n              double parentValue = arrays != null ? fr.getFacetRequest().getValueOf(arrays, parentOrd) : -1;\n              parentNode = new FacetResultNode(parentOrd, parentValue);\n              parentNode.label = parent;\n              parentNode.subResults = new ArrayList<FacetResultNode>();\n              parentNode.subResults.add(childNode);\n              mergedNodes.put(parent, parentNode);\n              childNode = parentNode;\n              parent = parent.subpath(parent.length - 1);\n            }\n\n            // at least one parent was added, so link the final (existing)\n            // parent with the child\n            if (parent.length > 0) {\n              if (!(parentNode.subResults instanceof ArrayList)) {\n                parentNode.subResults = new ArrayList<FacetResultNode>(parentNode.subResults);\n              }\n              parentNode.subResults.add(childNode);\n            }\n\n            // for missing FRNs, add new ones with label and value=-1\n            // first time encountered this label, add it and all its children to\n            // the map.\n            mergedNodes.put(frn.label, frn);\n            for (FacetResultNode child : frn.subResults) {\n              addIfNotExist(mergedNodes, child);\n            }\n          } else {\n            if (!(merged.subResults instanceof ArrayList)) {\n              merged.subResults = new ArrayList<FacetResultNode>(merged.subResults);\n            }\n            for (FacetResultNode sub : frn.subResults) {\n              // make sure sub wasn't already added\n              sub = addIfNotExist(mergedNodes, sub);\n              if (!merged.subResults.contains(sub)) {\n                merged.subResults.add(sub);\n              }\n            }\n          }\n        }\n        \n        // find the 'first' node to put on the FacetResult root\n        CategoryPath min = null;\n        for (CategoryPath cp : mergedNodes.keySet()) {\n          if (min == null || cp.compareTo(min) < 0) {\n            min = cp;\n          }\n        }\n        FacetRequest dummy = new FacetRequest(min, frs.get(0).getFacetRequest().numResults) {\n          @Override\n          public FacetsAggregator createFacetsAggregator(FacetIndexingParams fip) {\n            throw new UnsupportedOperationException(\"not supported by this request\");\n          }\n          \n          @Override\n          public double getValueOf(FacetArrays arrays, int idx) {\n            throw new UnsupportedOperationException(\"not supported by this request\");\n          }\n          \n          @Override\n          public FacetArraysSource getFacetArraysSource() {\n            throw new UnsupportedOperationException(\"not supported by this request\");\n          }\n        };\n        mergedResult = new FacetResult(dummy, mergedNodes.get(min), -1);\n      }\n      res.add(mergedResult);\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/FacetResult#mergeHierarchies(List[FacetResult],TaxonomyReader,Map[String,FacetArrays]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/FacetResult#mergeHierarchies(List[FacetResult],TaxonomyReader,Map[String,FacetArrays]).mjava","sourceNew":"  /**\n   * A utility for merging multiple {@link FacetResult} of the same\n   * (hierarchical) dimension into a single {@link FacetResult}, to reconstruct\n   * the hierarchy. The results are merged according to the following rules:\n   * <ul>\n   * <li>If two results share the same dimension (first component in their\n   * {@link CategoryPath}), they are merged.\n   * <li>If a result is missing ancestors in the other results, e.g. A/B/C but\n   * no corresponding A or A/B, these nodes are 'filled' with their label,\n   * ordinal and value (obtained from the respective {@link FacetArrays}).\n   * <li>If a result does not share a dimension with other results, it is\n   * returned as is.\n   * </ul>\n   * <p>\n   * <b>NOTE:</b> the returned results are not guaranteed to be in the same\n   * order of the input ones.\n   * \n   * @param results\n   *          the results to merge\n   * @param taxoReader\n   *          the {@link TaxonomyReader} to use when creating missing ancestor\n   *          nodes\n   * @param dimArrays\n   *          a mapping from a dimension to the respective {@link FacetArrays}\n   *          from which to pull the nodes values\n   */\n  public static List<FacetResult> mergeHierarchies(List<FacetResult> results, TaxonomyReader taxoReader,\n      Map<String, FacetArrays> dimArrays) throws IOException {\n    final Map<String, List<FacetResult>> dims = new HashMap<String,List<FacetResult>>();\n    for (FacetResult fr : results) {\n      String dim = fr.getFacetRequest().categoryPath.components[0];\n      List<FacetResult> frs = dims.get(dim);\n      if (frs == null) {\n        frs = new ArrayList<FacetResult>();\n        dims.put(dim, frs);\n      }\n      frs.add(fr);\n    }\n\n    final List<FacetResult> res = new ArrayList<FacetResult>();\n    for (List<FacetResult> frs : dims.values()) {\n      FacetResult mergedResult = frs.get(0);\n      if (frs.size() > 1) {\n        CollectionUtil.introSort(frs, new Comparator<FacetResult>() {\n          @Override\n          public int compare(FacetResult fr1, FacetResult fr2) {\n            return fr1.getFacetRequest().categoryPath.compareTo(fr2.getFacetRequest().categoryPath);\n          }\n        });\n        Map<CategoryPath, FacetResultNode> mergedNodes = new HashMap<CategoryPath,FacetResultNode>();\n        FacetArrays arrays = dimArrays != null ? dimArrays.get(frs.get(0).getFacetRequest().categoryPath.components[0]) : null;\n        for (FacetResult fr : frs) {\n          FacetRequest freq = fr.getFacetRequest();\n          OrdinalValueResolver resolver = null;\n          if (arrays != null) {\n            resolver = freq.createFacetsAggregator(FacetIndexingParams.DEFAULT).createOrdinalValueResolver(freq, arrays);\n          }\n          FacetResultNode frn = fr.getFacetResultNode();\n          FacetResultNode merged = mergedNodes.get(frn.label);\n          if (merged == null) {\n            CategoryPath parent = frn.label.subpath(frn.label.length - 1);\n            FacetResultNode childNode = frn;\n            FacetResultNode parentNode = null;\n            while (parent.length > 0 && (parentNode = mergedNodes.get(parent)) == null) {\n              int parentOrd = taxoReader.getOrdinal(parent);\n              double parentValue = -1;\n              if (arrays != null) {\n                parentValue = resolver.valueOf(parentOrd);\n              }\n              parentNode = new FacetResultNode(parentOrd, parentValue);\n              parentNode.label = parent;\n              parentNode.subResults = new ArrayList<FacetResultNode>();\n              parentNode.subResults.add(childNode);\n              mergedNodes.put(parent, parentNode);\n              childNode = parentNode;\n              parent = parent.subpath(parent.length - 1);\n            }\n\n            // at least one parent was added, so link the final (existing)\n            // parent with the child\n            if (parent.length > 0) {\n              if (!(parentNode.subResults instanceof ArrayList)) {\n                parentNode.subResults = new ArrayList<FacetResultNode>(parentNode.subResults);\n              }\n              parentNode.subResults.add(childNode);\n            }\n\n            // for missing FRNs, add new ones with label and value=-1\n            // first time encountered this label, add it and all its children to\n            // the map.\n            mergedNodes.put(frn.label, frn);\n            for (FacetResultNode child : frn.subResults) {\n              addIfNotExist(mergedNodes, child);\n            }\n          } else {\n            if (!(merged.subResults instanceof ArrayList)) {\n              merged.subResults = new ArrayList<FacetResultNode>(merged.subResults);\n            }\n            for (FacetResultNode sub : frn.subResults) {\n              // make sure sub wasn't already added\n              sub = addIfNotExist(mergedNodes, sub);\n              if (!merged.subResults.contains(sub)) {\n                merged.subResults.add(sub);\n              }\n            }\n          }\n        }\n        \n        // find the 'first' node to put on the FacetResult root\n        CategoryPath min = null;\n        for (CategoryPath cp : mergedNodes.keySet()) {\n          if (min == null || cp.compareTo(min) < 0) {\n            min = cp;\n          }\n        }\n        FacetRequest dummy = new FacetRequest(min, frs.get(0).getFacetRequest().numResults) {\n          @Override\n          public FacetsAggregator createFacetsAggregator(FacetIndexingParams fip) {\n            throw new UnsupportedOperationException(\"not supported by this request\");\n          }\n        };\n        mergedResult = new FacetResult(dummy, mergedNodes.get(min), -1);\n      }\n      res.add(mergedResult);\n    }\n    return res;\n  }\n\n","sourceOld":"  /**\n   * A utility for merging multiple {@link FacetResult} of the same\n   * (hierarchical) dimension into a single {@link FacetResult}, to reconstruct\n   * the hierarchy. The results are merged according to the following rules:\n   * <ul>\n   * <li>If two results share the same dimension (first component in their\n   * {@link CategoryPath}), they are merged.\n   * <li>If a result is missing ancestors in the other results, e.g. A/B/C but\n   * no corresponding A or A/B, these nodes are 'filled' with their label,\n   * ordinal and value (obtained from the respective {@link FacetArrays}).\n   * <li>If a result does not share a dimension with other results, it is\n   * returned as is.\n   * </ul>\n   * <p>\n   * <b>NOTE:</b> the returned results are not guaranteed to be in the same\n   * order of the input ones.\n   * \n   * @param results\n   *          the results to merge\n   * @param taxoReader\n   *          the {@link TaxonomyReader} to use when creating missing ancestor\n   *          nodes\n   * @param dimArrays\n   *          a mapping from a dimension to the respective {@link FacetArrays}\n   *          from which to pull the nodes values\n   */\n  public static List<FacetResult> mergeHierarchies(List<FacetResult> results, TaxonomyReader taxoReader,\n      Map<String, FacetArrays> dimArrays) throws IOException {\n    final Map<String, List<FacetResult>> dims = new HashMap<String,List<FacetResult>>();\n    for (FacetResult fr : results) {\n      String dim = fr.getFacetRequest().categoryPath.components[0];\n      List<FacetResult> frs = dims.get(dim);\n      if (frs == null) {\n        frs = new ArrayList<FacetResult>();\n        dims.put(dim, frs);\n      }\n      frs.add(fr);\n    }\n\n    final List<FacetResult> res = new ArrayList<FacetResult>();\n    for (List<FacetResult> frs : dims.values()) {\n      FacetResult mergedResult = frs.get(0);\n      if (frs.size() > 1) {\n        CollectionUtil.introSort(frs, new Comparator<FacetResult>() {\n          @Override\n          public int compare(FacetResult fr1, FacetResult fr2) {\n            return fr1.getFacetRequest().categoryPath.compareTo(fr2.getFacetRequest().categoryPath);\n          }\n        });\n        Map<CategoryPath, FacetResultNode> mergedNodes = new HashMap<CategoryPath,FacetResultNode>();\n        FacetArrays arrays = dimArrays != null ? dimArrays.get(frs.get(0).getFacetRequest().categoryPath.components[0]) : null;\n        for (FacetResult fr : frs) {\n          FacetResultNode frn = fr.getFacetResultNode();\n          FacetResultNode merged = mergedNodes.get(frn.label);\n          if (merged == null) {\n            CategoryPath parent = frn.label.subpath(frn.label.length - 1);\n            FacetResultNode childNode = frn;\n            FacetResultNode parentNode = null;\n            while (parent.length > 0 && (parentNode = mergedNodes.get(parent)) == null) {\n              int parentOrd = taxoReader.getOrdinal(parent);\n              double parentValue = arrays != null ? fr.getFacetRequest().getValueOf(arrays, parentOrd) : -1;\n              parentNode = new FacetResultNode(parentOrd, parentValue);\n              parentNode.label = parent;\n              parentNode.subResults = new ArrayList<FacetResultNode>();\n              parentNode.subResults.add(childNode);\n              mergedNodes.put(parent, parentNode);\n              childNode = parentNode;\n              parent = parent.subpath(parent.length - 1);\n            }\n\n            // at least one parent was added, so link the final (existing)\n            // parent with the child\n            if (parent.length > 0) {\n              if (!(parentNode.subResults instanceof ArrayList)) {\n                parentNode.subResults = new ArrayList<FacetResultNode>(parentNode.subResults);\n              }\n              parentNode.subResults.add(childNode);\n            }\n\n            // for missing FRNs, add new ones with label and value=-1\n            // first time encountered this label, add it and all its children to\n            // the map.\n            mergedNodes.put(frn.label, frn);\n            for (FacetResultNode child : frn.subResults) {\n              addIfNotExist(mergedNodes, child);\n            }\n          } else {\n            if (!(merged.subResults instanceof ArrayList)) {\n              merged.subResults = new ArrayList<FacetResultNode>(merged.subResults);\n            }\n            for (FacetResultNode sub : frn.subResults) {\n              // make sure sub wasn't already added\n              sub = addIfNotExist(mergedNodes, sub);\n              if (!merged.subResults.contains(sub)) {\n                merged.subResults.add(sub);\n              }\n            }\n          }\n        }\n        \n        // find the 'first' node to put on the FacetResult root\n        CategoryPath min = null;\n        for (CategoryPath cp : mergedNodes.keySet()) {\n          if (min == null || cp.compareTo(min) < 0) {\n            min = cp;\n          }\n        }\n        FacetRequest dummy = new FacetRequest(min, frs.get(0).getFacetRequest().numResults) {\n          @Override\n          public double getValueOf(FacetArrays arrays, int idx) {\n            throw new UnsupportedOperationException(\"not supported by this request\");\n          }\n          \n          @Override\n          public FacetArraysSource getFacetArraysSource() {\n            throw new UnsupportedOperationException(\"not supported by this request\");\n          }\n        };\n        mergedResult = new FacetResult(dummy, mergedNodes.get(min), -1);\n      }\n      res.add(mergedResult);\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c190847801a50f4dd20fd639bdc29b54ea3b288b","date":1384461522,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/FacetResult#mergeHierarchies(List[FacetResult],TaxonomyReader,Map[String,FacetArrays]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/FacetResult#mergeHierarchies(List[FacetResult],TaxonomyReader,Map[String,FacetArrays]).mjava","sourceNew":"  /**\n   * A utility for merging multiple {@link FacetResult} of the same\n   * (hierarchical) dimension into a single {@link FacetResult}, to reconstruct\n   * the hierarchy. The results are merged according to the following rules:\n   * <ul>\n   * <li>If two results share the same dimension (first component in their\n   * {@link FacetLabel}), they are merged.\n   * <li>If a result is missing ancestors in the other results, e.g. A/B/C but\n   * no corresponding A or A/B, these nodes are 'filled' with their label,\n   * ordinal and value (obtained from the respective {@link FacetArrays}).\n   * <li>If a result does not share a dimension with other results, it is\n   * returned as is.\n   * </ul>\n   * <p>\n   * <b>NOTE:</b> the returned results are not guaranteed to be in the same\n   * order of the input ones.\n   * \n   * @param results\n   *          the results to merge\n   * @param taxoReader\n   *          the {@link TaxonomyReader} to use when creating missing ancestor\n   *          nodes\n   * @param dimArrays\n   *          a mapping from a dimension to the respective {@link FacetArrays}\n   *          from which to pull the nodes values\n   */\n  public static List<FacetResult> mergeHierarchies(List<FacetResult> results, TaxonomyReader taxoReader,\n      Map<String, FacetArrays> dimArrays) throws IOException {\n    final Map<String, List<FacetResult>> dims = new HashMap<String,List<FacetResult>>();\n    for (FacetResult fr : results) {\n      String dim = fr.getFacetRequest().categoryPath.components[0];\n      List<FacetResult> frs = dims.get(dim);\n      if (frs == null) {\n        frs = new ArrayList<FacetResult>();\n        dims.put(dim, frs);\n      }\n      frs.add(fr);\n    }\n\n    final List<FacetResult> res = new ArrayList<FacetResult>();\n    for (List<FacetResult> frs : dims.values()) {\n      FacetResult mergedResult = frs.get(0);\n      if (frs.size() > 1) {\n        CollectionUtil.introSort(frs, new Comparator<FacetResult>() {\n          @Override\n          public int compare(FacetResult fr1, FacetResult fr2) {\n            return fr1.getFacetRequest().categoryPath.compareTo(fr2.getFacetRequest().categoryPath);\n          }\n        });\n        Map<FacetLabel, FacetResultNode> mergedNodes = new HashMap<FacetLabel,FacetResultNode>();\n        FacetArrays arrays = dimArrays != null ? dimArrays.get(frs.get(0).getFacetRequest().categoryPath.components[0]) : null;\n        for (FacetResult fr : frs) {\n          FacetRequest freq = fr.getFacetRequest();\n          OrdinalValueResolver resolver = null;\n          if (arrays != null) {\n            resolver = freq.createFacetsAggregator(FacetIndexingParams.DEFAULT).createOrdinalValueResolver(freq, arrays);\n          }\n          FacetResultNode frn = fr.getFacetResultNode();\n          FacetResultNode merged = mergedNodes.get(frn.label);\n          if (merged == null) {\n            FacetLabel parent = frn.label.subpath(frn.label.length - 1);\n            FacetResultNode childNode = frn;\n            FacetResultNode parentNode = null;\n            while (parent.length > 0 && (parentNode = mergedNodes.get(parent)) == null) {\n              int parentOrd = taxoReader.getOrdinal(parent);\n              double parentValue = -1;\n              if (arrays != null) {\n                parentValue = resolver.valueOf(parentOrd);\n              }\n              parentNode = new FacetResultNode(parentOrd, parentValue);\n              parentNode.label = parent;\n              parentNode.subResults = new ArrayList<FacetResultNode>();\n              parentNode.subResults.add(childNode);\n              mergedNodes.put(parent, parentNode);\n              childNode = parentNode;\n              parent = parent.subpath(parent.length - 1);\n            }\n\n            // at least one parent was added, so link the final (existing)\n            // parent with the child\n            if (parent.length > 0) {\n              if (!(parentNode.subResults instanceof ArrayList)) {\n                parentNode.subResults = new ArrayList<FacetResultNode>(parentNode.subResults);\n              }\n              parentNode.subResults.add(childNode);\n            }\n\n            // for missing FRNs, add new ones with label and value=-1\n            // first time encountered this label, add it and all its children to\n            // the map.\n            mergedNodes.put(frn.label, frn);\n            for (FacetResultNode child : frn.subResults) {\n              addIfNotExist(mergedNodes, child);\n            }\n          } else {\n            if (!(merged.subResults instanceof ArrayList)) {\n              merged.subResults = new ArrayList<FacetResultNode>(merged.subResults);\n            }\n            for (FacetResultNode sub : frn.subResults) {\n              // make sure sub wasn't already added\n              sub = addIfNotExist(mergedNodes, sub);\n              if (!merged.subResults.contains(sub)) {\n                merged.subResults.add(sub);\n              }\n            }\n          }\n        }\n        \n        // find the 'first' node to put on the FacetResult root\n        FacetLabel min = null;\n        for (FacetLabel cp : mergedNodes.keySet()) {\n          if (min == null || cp.compareTo(min) < 0) {\n            min = cp;\n          }\n        }\n        FacetRequest dummy = new FacetRequest(min, frs.get(0).getFacetRequest().numResults) {\n          @Override\n          public FacetsAggregator createFacetsAggregator(FacetIndexingParams fip) {\n            throw new UnsupportedOperationException(\"not supported by this request\");\n          }\n        };\n        mergedResult = new FacetResult(dummy, mergedNodes.get(min), -1);\n      }\n      res.add(mergedResult);\n    }\n    return res;\n  }\n\n","sourceOld":"  /**\n   * A utility for merging multiple {@link FacetResult} of the same\n   * (hierarchical) dimension into a single {@link FacetResult}, to reconstruct\n   * the hierarchy. The results are merged according to the following rules:\n   * <ul>\n   * <li>If two results share the same dimension (first component in their\n   * {@link CategoryPath}), they are merged.\n   * <li>If a result is missing ancestors in the other results, e.g. A/B/C but\n   * no corresponding A or A/B, these nodes are 'filled' with their label,\n   * ordinal and value (obtained from the respective {@link FacetArrays}).\n   * <li>If a result does not share a dimension with other results, it is\n   * returned as is.\n   * </ul>\n   * <p>\n   * <b>NOTE:</b> the returned results are not guaranteed to be in the same\n   * order of the input ones.\n   * \n   * @param results\n   *          the results to merge\n   * @param taxoReader\n   *          the {@link TaxonomyReader} to use when creating missing ancestor\n   *          nodes\n   * @param dimArrays\n   *          a mapping from a dimension to the respective {@link FacetArrays}\n   *          from which to pull the nodes values\n   */\n  public static List<FacetResult> mergeHierarchies(List<FacetResult> results, TaxonomyReader taxoReader,\n      Map<String, FacetArrays> dimArrays) throws IOException {\n    final Map<String, List<FacetResult>> dims = new HashMap<String,List<FacetResult>>();\n    for (FacetResult fr : results) {\n      String dim = fr.getFacetRequest().categoryPath.components[0];\n      List<FacetResult> frs = dims.get(dim);\n      if (frs == null) {\n        frs = new ArrayList<FacetResult>();\n        dims.put(dim, frs);\n      }\n      frs.add(fr);\n    }\n\n    final List<FacetResult> res = new ArrayList<FacetResult>();\n    for (List<FacetResult> frs : dims.values()) {\n      FacetResult mergedResult = frs.get(0);\n      if (frs.size() > 1) {\n        CollectionUtil.introSort(frs, new Comparator<FacetResult>() {\n          @Override\n          public int compare(FacetResult fr1, FacetResult fr2) {\n            return fr1.getFacetRequest().categoryPath.compareTo(fr2.getFacetRequest().categoryPath);\n          }\n        });\n        Map<CategoryPath, FacetResultNode> mergedNodes = new HashMap<CategoryPath,FacetResultNode>();\n        FacetArrays arrays = dimArrays != null ? dimArrays.get(frs.get(0).getFacetRequest().categoryPath.components[0]) : null;\n        for (FacetResult fr : frs) {\n          FacetRequest freq = fr.getFacetRequest();\n          OrdinalValueResolver resolver = null;\n          if (arrays != null) {\n            resolver = freq.createFacetsAggregator(FacetIndexingParams.DEFAULT).createOrdinalValueResolver(freq, arrays);\n          }\n          FacetResultNode frn = fr.getFacetResultNode();\n          FacetResultNode merged = mergedNodes.get(frn.label);\n          if (merged == null) {\n            CategoryPath parent = frn.label.subpath(frn.label.length - 1);\n            FacetResultNode childNode = frn;\n            FacetResultNode parentNode = null;\n            while (parent.length > 0 && (parentNode = mergedNodes.get(parent)) == null) {\n              int parentOrd = taxoReader.getOrdinal(parent);\n              double parentValue = -1;\n              if (arrays != null) {\n                parentValue = resolver.valueOf(parentOrd);\n              }\n              parentNode = new FacetResultNode(parentOrd, parentValue);\n              parentNode.label = parent;\n              parentNode.subResults = new ArrayList<FacetResultNode>();\n              parentNode.subResults.add(childNode);\n              mergedNodes.put(parent, parentNode);\n              childNode = parentNode;\n              parent = parent.subpath(parent.length - 1);\n            }\n\n            // at least one parent was added, so link the final (existing)\n            // parent with the child\n            if (parent.length > 0) {\n              if (!(parentNode.subResults instanceof ArrayList)) {\n                parentNode.subResults = new ArrayList<FacetResultNode>(parentNode.subResults);\n              }\n              parentNode.subResults.add(childNode);\n            }\n\n            // for missing FRNs, add new ones with label and value=-1\n            // first time encountered this label, add it and all its children to\n            // the map.\n            mergedNodes.put(frn.label, frn);\n            for (FacetResultNode child : frn.subResults) {\n              addIfNotExist(mergedNodes, child);\n            }\n          } else {\n            if (!(merged.subResults instanceof ArrayList)) {\n              merged.subResults = new ArrayList<FacetResultNode>(merged.subResults);\n            }\n            for (FacetResultNode sub : frn.subResults) {\n              // make sure sub wasn't already added\n              sub = addIfNotExist(mergedNodes, sub);\n              if (!merged.subResults.contains(sub)) {\n                merged.subResults.add(sub);\n              }\n            }\n          }\n        }\n        \n        // find the 'first' node to put on the FacetResult root\n        CategoryPath min = null;\n        for (CategoryPath cp : mergedNodes.keySet()) {\n          if (min == null || cp.compareTo(min) < 0) {\n            min = cp;\n          }\n        }\n        FacetRequest dummy = new FacetRequest(min, frs.get(0).getFacetRequest().numResults) {\n          @Override\n          public FacetsAggregator createFacetsAggregator(FacetIndexingParams fip) {\n            throw new UnsupportedOperationException(\"not supported by this request\");\n          }\n        };\n        mergedResult = new FacetResult(dummy, mergedNodes.get(min), -1);\n      }\n      res.add(mergedResult);\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca39562b2d7687143fdb601d5de1b8f7b778f1db","date":1385299806,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/FacetResult#mergeHierarchies(List[FacetResult],TaxonomyReader,Map[String,FacetArrays]).mjava","sourceNew":null,"sourceOld":"  /**\n   * A utility for merging multiple {@link FacetResult} of the same\n   * (hierarchical) dimension into a single {@link FacetResult}, to reconstruct\n   * the hierarchy. The results are merged according to the following rules:\n   * <ul>\n   * <li>If two results share the same dimension (first component in their\n   * {@link FacetLabel}), they are merged.\n   * <li>If a result is missing ancestors in the other results, e.g. A/B/C but\n   * no corresponding A or A/B, these nodes are 'filled' with their label,\n   * ordinal and value (obtained from the respective {@link FacetArrays}).\n   * <li>If a result does not share a dimension with other results, it is\n   * returned as is.\n   * </ul>\n   * <p>\n   * <b>NOTE:</b> the returned results are not guaranteed to be in the same\n   * order of the input ones.\n   * \n   * @param results\n   *          the results to merge\n   * @param taxoReader\n   *          the {@link TaxonomyReader} to use when creating missing ancestor\n   *          nodes\n   * @param dimArrays\n   *          a mapping from a dimension to the respective {@link FacetArrays}\n   *          from which to pull the nodes values\n   */\n  public static List<FacetResult> mergeHierarchies(List<FacetResult> results, TaxonomyReader taxoReader,\n      Map<String, FacetArrays> dimArrays) throws IOException {\n    final Map<String, List<FacetResult>> dims = new HashMap<String,List<FacetResult>>();\n    for (FacetResult fr : results) {\n      String dim = fr.getFacetRequest().categoryPath.components[0];\n      List<FacetResult> frs = dims.get(dim);\n      if (frs == null) {\n        frs = new ArrayList<FacetResult>();\n        dims.put(dim, frs);\n      }\n      frs.add(fr);\n    }\n\n    final List<FacetResult> res = new ArrayList<FacetResult>();\n    for (List<FacetResult> frs : dims.values()) {\n      FacetResult mergedResult = frs.get(0);\n      if (frs.size() > 1) {\n        CollectionUtil.introSort(frs, new Comparator<FacetResult>() {\n          @Override\n          public int compare(FacetResult fr1, FacetResult fr2) {\n            return fr1.getFacetRequest().categoryPath.compareTo(fr2.getFacetRequest().categoryPath);\n          }\n        });\n        Map<FacetLabel, FacetResultNode> mergedNodes = new HashMap<FacetLabel,FacetResultNode>();\n        FacetArrays arrays = dimArrays != null ? dimArrays.get(frs.get(0).getFacetRequest().categoryPath.components[0]) : null;\n        for (FacetResult fr : frs) {\n          FacetRequest freq = fr.getFacetRequest();\n          OrdinalValueResolver resolver = null;\n          if (arrays != null) {\n            resolver = freq.createFacetsAggregator(FacetIndexingParams.DEFAULT).createOrdinalValueResolver(freq, arrays);\n          }\n          FacetResultNode frn = fr.getFacetResultNode();\n          FacetResultNode merged = mergedNodes.get(frn.label);\n          if (merged == null) {\n            FacetLabel parent = frn.label.subpath(frn.label.length - 1);\n            FacetResultNode childNode = frn;\n            FacetResultNode parentNode = null;\n            while (parent.length > 0 && (parentNode = mergedNodes.get(parent)) == null) {\n              int parentOrd = taxoReader.getOrdinal(parent);\n              double parentValue = -1;\n              if (arrays != null) {\n                parentValue = resolver.valueOf(parentOrd);\n              }\n              parentNode = new FacetResultNode(parentOrd, parentValue);\n              parentNode.label = parent;\n              parentNode.subResults = new ArrayList<FacetResultNode>();\n              parentNode.subResults.add(childNode);\n              mergedNodes.put(parent, parentNode);\n              childNode = parentNode;\n              parent = parent.subpath(parent.length - 1);\n            }\n\n            // at least one parent was added, so link the final (existing)\n            // parent with the child\n            if (parent.length > 0) {\n              if (!(parentNode.subResults instanceof ArrayList)) {\n                parentNode.subResults = new ArrayList<FacetResultNode>(parentNode.subResults);\n              }\n              parentNode.subResults.add(childNode);\n            }\n\n            // for missing FRNs, add new ones with label and value=-1\n            // first time encountered this label, add it and all its children to\n            // the map.\n            mergedNodes.put(frn.label, frn);\n            for (FacetResultNode child : frn.subResults) {\n              addIfNotExist(mergedNodes, child);\n            }\n          } else {\n            if (!(merged.subResults instanceof ArrayList)) {\n              merged.subResults = new ArrayList<FacetResultNode>(merged.subResults);\n            }\n            for (FacetResultNode sub : frn.subResults) {\n              // make sure sub wasn't already added\n              sub = addIfNotExist(mergedNodes, sub);\n              if (!merged.subResults.contains(sub)) {\n                merged.subResults.add(sub);\n              }\n            }\n          }\n        }\n        \n        // find the 'first' node to put on the FacetResult root\n        FacetLabel min = null;\n        for (FacetLabel cp : mergedNodes.keySet()) {\n          if (min == null || cp.compareTo(min) < 0) {\n            min = cp;\n          }\n        }\n        FacetRequest dummy = new FacetRequest(min, frs.get(0).getFacetRequest().numResults) {\n          @Override\n          public FacetsAggregator createFacetsAggregator(FacetIndexingParams fip) {\n            throw new UnsupportedOperationException(\"not supported by this request\");\n          }\n        };\n        mergedResult = new FacetResult(dummy, mergedNodes.get(min), -1);\n      }\n      res.add(mergedResult);\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":4,"author":"Michael McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/FacetResult#mergeHierarchies(List[FacetResult],TaxonomyReader,Map[String,FacetArrays]).mjava","sourceNew":null,"sourceOld":"  /**\n   * A utility for merging multiple {@link FacetResult} of the same\n   * (hierarchical) dimension into a single {@link FacetResult}, to reconstruct\n   * the hierarchy. The results are merged according to the following rules:\n   * <ul>\n   * <li>If two results share the same dimension (first component in their\n   * {@link CategoryPath}), they are merged.\n   * <li>If a result is missing ancestors in the other results, e.g. A/B/C but\n   * no corresponding A or A/B, these nodes are 'filled' with their label,\n   * ordinal and value (obtained from the respective {@link FacetArrays}).\n   * <li>If a result does not share a dimension with other results, it is\n   * returned as is.\n   * </ul>\n   * <p>\n   * <b>NOTE:</b> the returned results are not guaranteed to be in the same\n   * order of the input ones.\n   * \n   * @param results\n   *          the results to merge\n   * @param taxoReader\n   *          the {@link TaxonomyReader} to use when creating missing ancestor\n   *          nodes\n   * @param dimArrays\n   *          a mapping from a dimension to the respective {@link FacetArrays}\n   *          from which to pull the nodes values\n   */\n  public static List<FacetResult> mergeHierarchies(List<FacetResult> results, TaxonomyReader taxoReader,\n      Map<String, FacetArrays> dimArrays) throws IOException {\n    final Map<String, List<FacetResult>> dims = new HashMap<String,List<FacetResult>>();\n    for (FacetResult fr : results) {\n      String dim = fr.getFacetRequest().categoryPath.components[0];\n      List<FacetResult> frs = dims.get(dim);\n      if (frs == null) {\n        frs = new ArrayList<FacetResult>();\n        dims.put(dim, frs);\n      }\n      frs.add(fr);\n    }\n\n    final List<FacetResult> res = new ArrayList<FacetResult>();\n    for (List<FacetResult> frs : dims.values()) {\n      FacetResult mergedResult = frs.get(0);\n      if (frs.size() > 1) {\n        CollectionUtil.introSort(frs, new Comparator<FacetResult>() {\n          @Override\n          public int compare(FacetResult fr1, FacetResult fr2) {\n            return fr1.getFacetRequest().categoryPath.compareTo(fr2.getFacetRequest().categoryPath);\n          }\n        });\n        Map<CategoryPath, FacetResultNode> mergedNodes = new HashMap<CategoryPath,FacetResultNode>();\n        FacetArrays arrays = dimArrays != null ? dimArrays.get(frs.get(0).getFacetRequest().categoryPath.components[0]) : null;\n        for (FacetResult fr : frs) {\n          FacetRequest freq = fr.getFacetRequest();\n          OrdinalValueResolver resolver = null;\n          if (arrays != null) {\n            resolver = freq.createFacetsAggregator(FacetIndexingParams.DEFAULT).createOrdinalValueResolver(freq, arrays);\n          }\n          FacetResultNode frn = fr.getFacetResultNode();\n          FacetResultNode merged = mergedNodes.get(frn.label);\n          if (merged == null) {\n            CategoryPath parent = frn.label.subpath(frn.label.length - 1);\n            FacetResultNode childNode = frn;\n            FacetResultNode parentNode = null;\n            while (parent.length > 0 && (parentNode = mergedNodes.get(parent)) == null) {\n              int parentOrd = taxoReader.getOrdinal(parent);\n              double parentValue = -1;\n              if (arrays != null) {\n                parentValue = resolver.valueOf(parentOrd);\n              }\n              parentNode = new FacetResultNode(parentOrd, parentValue);\n              parentNode.label = parent;\n              parentNode.subResults = new ArrayList<FacetResultNode>();\n              parentNode.subResults.add(childNode);\n              mergedNodes.put(parent, parentNode);\n              childNode = parentNode;\n              parent = parent.subpath(parent.length - 1);\n            }\n\n            // at least one parent was added, so link the final (existing)\n            // parent with the child\n            if (parent.length > 0) {\n              if (!(parentNode.subResults instanceof ArrayList)) {\n                parentNode.subResults = new ArrayList<FacetResultNode>(parentNode.subResults);\n              }\n              parentNode.subResults.add(childNode);\n            }\n\n            // for missing FRNs, add new ones with label and value=-1\n            // first time encountered this label, add it and all its children to\n            // the map.\n            mergedNodes.put(frn.label, frn);\n            for (FacetResultNode child : frn.subResults) {\n              addIfNotExist(mergedNodes, child);\n            }\n          } else {\n            if (!(merged.subResults instanceof ArrayList)) {\n              merged.subResults = new ArrayList<FacetResultNode>(merged.subResults);\n            }\n            for (FacetResultNode sub : frn.subResults) {\n              // make sure sub wasn't already added\n              sub = addIfNotExist(mergedNodes, sub);\n              if (!merged.subResults.contains(sub)) {\n                merged.subResults.add(sub);\n              }\n            }\n          }\n        }\n        \n        // find the 'first' node to put on the FacetResult root\n        CategoryPath min = null;\n        for (CategoryPath cp : mergedNodes.keySet()) {\n          if (min == null || cp.compareTo(min) < 0) {\n            min = cp;\n          }\n        }\n        FacetRequest dummy = new FacetRequest(min, frs.get(0).getFacetRequest().numResults) {\n          @Override\n          public FacetsAggregator createFacetsAggregator(FacetIndexingParams fip) {\n            throw new UnsupportedOperationException(\"not supported by this request\");\n          }\n        };\n        mergedResult = new FacetResult(dummy, mergedNodes.get(min), -1);\n      }\n      res.add(mergedResult);\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3b1c67b5eba853532b31132bf5aef70a3b2be63f":["6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49"],"ff6a0dc6ca67172f353dbc6b826e324f84d378ef":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"35d59eaf6a197e412d53262def39f05f06d71a06":["ff6a0dc6ca67172f353dbc6b826e324f84d378ef"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["35d59eaf6a197e412d53262def39f05f06d71a06"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["3b1c67b5eba853532b31132bf5aef70a3b2be63f","ca39562b2d7687143fdb601d5de1b8f7b778f1db"],"6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49":["35d59eaf6a197e412d53262def39f05f06d71a06"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"ca39562b2d7687143fdb601d5de1b8f7b778f1db":["c190847801a50f4dd20fd639bdc29b54ea3b288b"],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["3b1c67b5eba853532b31132bf5aef70a3b2be63f"]},"commit2Childs":{"3b1c67b5eba853532b31132bf5aef70a3b2be63f":["3cc728b07df73b197e6d940d27f9b08b63918f13","c190847801a50f4dd20fd639bdc29b54ea3b288b"],"ff6a0dc6ca67172f353dbc6b826e324f84d378ef":["35d59eaf6a197e412d53262def39f05f06d71a06"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ff6a0dc6ca67172f353dbc6b826e324f84d378ef"],"35d59eaf6a197e412d53262def39f05f06d71a06":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"3cc728b07df73b197e6d940d27f9b08b63918f13":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49":["3b1c67b5eba853532b31132bf5aef70a3b2be63f"],"ca39562b2d7687143fdb601d5de1b8f7b778f1db":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["ca39562b2d7687143fdb601d5de1b8f7b778f1db"]},"heads":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}