{"path":"lucene/core/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(LightAutomaton).mjava","commits":[{"id":"ac34f0c5bb9274821fb0cb18075234e02002e9bf","date":1402508126,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(LightAutomaton).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  public static LightAutomaton determinize(LightAutomaton a) {\n    if (a.getNumStates() == 0) {\n      return a;\n    }\n\n    // subset construction\n    LightAutomaton.Builder b = new LightAutomaton.Builder();\n\n    //System.out.println(\"DET:\");\n    //a.writeDot(\"/l/la/lucene/core/detin.dot\");\n\n    SortedIntSetLight.FrozenIntSetLight initialset = new SortedIntSetLight.FrozenIntSetLight(0, 0);\n\n    // Create state 0:\n    b.createState();\n\n    LinkedList<SortedIntSetLight.FrozenIntSetLight> worklist = new LinkedList<>();\n    Map<SortedIntSetLight.FrozenIntSetLight,Integer> newstate = new HashMap<>();\n\n    worklist.add(initialset);\n\n    b.setAccept(0, a.isAccept(0));\n    newstate.put(initialset, 0);\n\n    int newStateUpto = 0;\n    int[] newStatesArray = new int[5];\n    newStatesArray[newStateUpto] = 0;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSetLight points = new PointTransitionSetLight();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSetLight statesSet = new SortedIntSetLight(5);\n\n    LightAutomaton.Transition scratch = new LightAutomaton.Transition();\n\n    while (worklist.size() > 0) {\n      SortedIntSetLight.FrozenIntSetLight s = worklist.removeFirst();\n      //System.out.println(\"det: pop set=\" + s);\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final int s0 = s.values[i];\n        int numTransitions = a.getNumTransitions(s0);\n        a.initTransition(s0, scratch);\n        for(int j=0;j<numTransitions;j++) {\n          a.getNextTransition(scratch);\n          points.add(scratch);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final int r = s.state;\n\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          Integer q = newstate.get(statesSet);\n          if (q == null) {\n            q = b.createState();\n            final SortedIntSetLight.FrozenIntSetLight p = statesSet.freeze(q);\n            //System.out.println(\"  make new state=\" + q + \" -> \" + p + \" accCount=\" + accCount);\n            worklist.add(p);\n            b.setAccept(q, accCount > 0);\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == b.isAccept(q): \"accCount=\" + accCount + \" vs existing accept=\" +\n              b.isAccept(q) + \" states=\" + statesSet;\n          }\n\n          // System.out.println(\"  add trans src=\" + r + \" dest=\" + q + \" min=\" + lastPoint + \" max=\" + (point-1));\n\n          b.addTransition(r, q, lastPoint, point-1);\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        int[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.decr(dest);\n          accCount -= a.isAccept(dest) ? 1:0;\n        }\n        points.points[i].ends.next = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.incr(dest);\n          accCount += a.isAccept(dest) ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.next = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n\n    return b.finish();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0c8cfaac638acc80d26d08288440ede37e6539e9","date":1402678000,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(LightAutomaton).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(LightAutomaton).mjava","sourceNew":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  public static LightAutomaton determinize(LightAutomaton a) {\n    if (a.getNumStates() == 0) {\n      return a;\n    }\n\n    // subset construction\n    LightAutomaton.Builder b = new LightAutomaton.Builder();\n\n    //System.out.println(\"DET:\");\n    //a.writeDot(\"/l/la/lucene/core/detin.dot\");\n\n    SortedIntSetLight.FrozenIntSetLight initialset = new SortedIntSetLight.FrozenIntSetLight(0, 0);\n\n    // Create state 0:\n    b.createState();\n\n    LinkedList<SortedIntSetLight.FrozenIntSetLight> worklist = new LinkedList<>();\n    Map<SortedIntSetLight.FrozenIntSetLight,Integer> newstate = new HashMap<>();\n\n    worklist.add(initialset);\n\n    b.setAccept(0, a.isAccept(0));\n    newstate.put(initialset, 0);\n\n    int newStateUpto = 0;\n    int[] newStatesArray = new int[5];\n    newStatesArray[newStateUpto] = 0;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSetLight points = new PointTransitionSetLight();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSetLight statesSet = new SortedIntSetLight(5);\n\n    Transition t = new Transition();\n\n    while (worklist.size() > 0) {\n      SortedIntSetLight.FrozenIntSetLight s = worklist.removeFirst();\n      //System.out.println(\"det: pop set=\" + s);\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final int s0 = s.values[i];\n        int numTransitions = a.getNumTransitions(s0);\n        a.initTransition(s0, t);\n        for(int j=0;j<numTransitions;j++) {\n          a.getNextTransition(t);\n          points.add(t);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final int r = s.state;\n\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          Integer q = newstate.get(statesSet);\n          if (q == null) {\n            q = b.createState();\n            final SortedIntSetLight.FrozenIntSetLight p = statesSet.freeze(q);\n            //System.out.println(\"  make new state=\" + q + \" -> \" + p + \" accCount=\" + accCount);\n            worklist.add(p);\n            b.setAccept(q, accCount > 0);\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == b.isAccept(q): \"accCount=\" + accCount + \" vs existing accept=\" +\n              b.isAccept(q) + \" states=\" + statesSet;\n          }\n\n          // System.out.println(\"  add trans src=\" + r + \" dest=\" + q + \" min=\" + lastPoint + \" max=\" + (point-1));\n\n          b.addTransition(r, q, lastPoint, point-1);\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        int[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.decr(dest);\n          accCount -= a.isAccept(dest) ? 1:0;\n        }\n        points.points[i].ends.next = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.incr(dest);\n          accCount += a.isAccept(dest) ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.next = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n\n    return b.finish();\n  }\n\n","sourceOld":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  public static LightAutomaton determinize(LightAutomaton a) {\n    if (a.getNumStates() == 0) {\n      return a;\n    }\n\n    // subset construction\n    LightAutomaton.Builder b = new LightAutomaton.Builder();\n\n    //System.out.println(\"DET:\");\n    //a.writeDot(\"/l/la/lucene/core/detin.dot\");\n\n    SortedIntSetLight.FrozenIntSetLight initialset = new SortedIntSetLight.FrozenIntSetLight(0, 0);\n\n    // Create state 0:\n    b.createState();\n\n    LinkedList<SortedIntSetLight.FrozenIntSetLight> worklist = new LinkedList<>();\n    Map<SortedIntSetLight.FrozenIntSetLight,Integer> newstate = new HashMap<>();\n\n    worklist.add(initialset);\n\n    b.setAccept(0, a.isAccept(0));\n    newstate.put(initialset, 0);\n\n    int newStateUpto = 0;\n    int[] newStatesArray = new int[5];\n    newStatesArray[newStateUpto] = 0;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSetLight points = new PointTransitionSetLight();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSetLight statesSet = new SortedIntSetLight(5);\n\n    LightAutomaton.Transition scratch = new LightAutomaton.Transition();\n\n    while (worklist.size() > 0) {\n      SortedIntSetLight.FrozenIntSetLight s = worklist.removeFirst();\n      //System.out.println(\"det: pop set=\" + s);\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final int s0 = s.values[i];\n        int numTransitions = a.getNumTransitions(s0);\n        a.initTransition(s0, scratch);\n        for(int j=0;j<numTransitions;j++) {\n          a.getNextTransition(scratch);\n          points.add(scratch);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final int r = s.state;\n\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          Integer q = newstate.get(statesSet);\n          if (q == null) {\n            q = b.createState();\n            final SortedIntSetLight.FrozenIntSetLight p = statesSet.freeze(q);\n            //System.out.println(\"  make new state=\" + q + \" -> \" + p + \" accCount=\" + accCount);\n            worklist.add(p);\n            b.setAccept(q, accCount > 0);\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == b.isAccept(q): \"accCount=\" + accCount + \" vs existing accept=\" +\n              b.isAccept(q) + \" states=\" + statesSet;\n          }\n\n          // System.out.println(\"  add trans src=\" + r + \" dest=\" + q + \" min=\" + lastPoint + \" max=\" + (point-1));\n\n          b.addTransition(r, q, lastPoint, point-1);\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        int[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.decr(dest);\n          accCount -= a.isAccept(dest) ? 1:0;\n        }\n        points.points[i].ends.next = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.incr(dest);\n          accCount += a.isAccept(dest) ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.next = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n\n    return b.finish();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a67285d1a68175d877eb9fd1624fccad3db028ff","date":1402779028,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(LightAutomaton).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(LightAutomaton).mjava","sourceNew":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  public static LightAutomaton determinize(LightAutomaton a) {\n    if (a.isDeterministic()) {\n      return a;\n    }\n    if (a.getNumStates() == 0) {\n      return a;\n    }\n\n    // subset construction\n    LightAutomaton.Builder b = new LightAutomaton.Builder();\n\n    //System.out.println(\"DET:\");\n    //a.writeDot(\"/l/la/lucene/core/detin.dot\");\n\n    SortedIntSetLight.FrozenIntSetLight initialset = new SortedIntSetLight.FrozenIntSetLight(0, 0);\n\n    // Create state 0:\n    b.createState();\n\n    LinkedList<SortedIntSetLight.FrozenIntSetLight> worklist = new LinkedList<>();\n    Map<SortedIntSetLight.FrozenIntSetLight,Integer> newstate = new HashMap<>();\n\n    worklist.add(initialset);\n\n    b.setAccept(0, a.isAccept(0));\n    newstate.put(initialset, 0);\n\n    int newStateUpto = 0;\n    int[] newStatesArray = new int[5];\n    newStatesArray[newStateUpto] = 0;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSetLight points = new PointTransitionSetLight();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSetLight statesSet = new SortedIntSetLight(5);\n\n    Transition t = new Transition();\n\n    while (worklist.size() > 0) {\n      SortedIntSetLight.FrozenIntSetLight s = worklist.removeFirst();\n      //System.out.println(\"det: pop set=\" + s);\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final int s0 = s.values[i];\n        int numTransitions = a.getNumTransitions(s0);\n        a.initTransition(s0, t);\n        for(int j=0;j<numTransitions;j++) {\n          a.getNextTransition(t);\n          points.add(t);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final int r = s.state;\n\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          Integer q = newstate.get(statesSet);\n          if (q == null) {\n            q = b.createState();\n            final SortedIntSetLight.FrozenIntSetLight p = statesSet.freeze(q);\n            //System.out.println(\"  make new state=\" + q + \" -> \" + p + \" accCount=\" + accCount);\n            worklist.add(p);\n            b.setAccept(q, accCount > 0);\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == b.isAccept(q): \"accCount=\" + accCount + \" vs existing accept=\" +\n              b.isAccept(q) + \" states=\" + statesSet;\n          }\n\n          // System.out.println(\"  add trans src=\" + r + \" dest=\" + q + \" min=\" + lastPoint + \" max=\" + (point-1));\n\n          b.addTransition(r, q, lastPoint, point-1);\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        int[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.decr(dest);\n          accCount -= a.isAccept(dest) ? 1:0;\n        }\n        points.points[i].ends.next = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.incr(dest);\n          accCount += a.isAccept(dest) ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.next = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n\n    LightAutomaton result = b.finish();\n    assert result.isDeterministic();\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  public static LightAutomaton determinize(LightAutomaton a) {\n    if (a.getNumStates() == 0) {\n      return a;\n    }\n\n    // subset construction\n    LightAutomaton.Builder b = new LightAutomaton.Builder();\n\n    //System.out.println(\"DET:\");\n    //a.writeDot(\"/l/la/lucene/core/detin.dot\");\n\n    SortedIntSetLight.FrozenIntSetLight initialset = new SortedIntSetLight.FrozenIntSetLight(0, 0);\n\n    // Create state 0:\n    b.createState();\n\n    LinkedList<SortedIntSetLight.FrozenIntSetLight> worklist = new LinkedList<>();\n    Map<SortedIntSetLight.FrozenIntSetLight,Integer> newstate = new HashMap<>();\n\n    worklist.add(initialset);\n\n    b.setAccept(0, a.isAccept(0));\n    newstate.put(initialset, 0);\n\n    int newStateUpto = 0;\n    int[] newStatesArray = new int[5];\n    newStatesArray[newStateUpto] = 0;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSetLight points = new PointTransitionSetLight();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSetLight statesSet = new SortedIntSetLight(5);\n\n    Transition t = new Transition();\n\n    while (worklist.size() > 0) {\n      SortedIntSetLight.FrozenIntSetLight s = worklist.removeFirst();\n      //System.out.println(\"det: pop set=\" + s);\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final int s0 = s.values[i];\n        int numTransitions = a.getNumTransitions(s0);\n        a.initTransition(s0, t);\n        for(int j=0;j<numTransitions;j++) {\n          a.getNextTransition(t);\n          points.add(t);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final int r = s.state;\n\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          Integer q = newstate.get(statesSet);\n          if (q == null) {\n            q = b.createState();\n            final SortedIntSetLight.FrozenIntSetLight p = statesSet.freeze(q);\n            //System.out.println(\"  make new state=\" + q + \" -> \" + p + \" accCount=\" + accCount);\n            worklist.add(p);\n            b.setAccept(q, accCount > 0);\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == b.isAccept(q): \"accCount=\" + accCount + \" vs existing accept=\" +\n              b.isAccept(q) + \" states=\" + statesSet;\n          }\n\n          // System.out.println(\"  add trans src=\" + r + \" dest=\" + q + \" min=\" + lastPoint + \" max=\" + (point-1));\n\n          b.addTransition(r, q, lastPoint, point-1);\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        int[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.decr(dest);\n          accCount -= a.isAccept(dest) ? 1:0;\n        }\n        points.points[i].ends.next = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.incr(dest);\n          accCount += a.isAccept(dest) ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.next = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n\n    return b.finish();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9","date":1402946522,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(LightAutomaton).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(LightAutomaton).mjava","sourceNew":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  public static LightAutomaton determinize(LightAutomaton a) {\n    if (a.isDeterministic()) {\n      // Already determinized\n      return a;\n    }\n    if (a.getNumStates() <= 1) {\n      // Already determinized\n      return a;\n    }\n\n    // subset construction\n    LightAutomaton.Builder b = new LightAutomaton.Builder();\n\n    //System.out.println(\"DET:\");\n    //a.writeDot(\"/l/la/lucene/core/detin.dot\");\n\n    SortedIntSetLight.FrozenIntSetLight initialset = new SortedIntSetLight.FrozenIntSetLight(0, 0);\n\n    // Create state 0:\n    b.createState();\n\n    LinkedList<SortedIntSetLight.FrozenIntSetLight> worklist = new LinkedList<>();\n    Map<SortedIntSetLight.FrozenIntSetLight,Integer> newstate = new HashMap<>();\n\n    worklist.add(initialset);\n\n    b.setAccept(0, a.isAccept(0));\n    newstate.put(initialset, 0);\n\n    int newStateUpto = 0;\n    int[] newStatesArray = new int[5];\n    newStatesArray[newStateUpto] = 0;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSetLight points = new PointTransitionSetLight();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSetLight statesSet = new SortedIntSetLight(5);\n\n    Transition t = new Transition();\n\n    while (worklist.size() > 0) {\n      SortedIntSetLight.FrozenIntSetLight s = worklist.removeFirst();\n      //System.out.println(\"det: pop set=\" + s);\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final int s0 = s.values[i];\n        int numTransitions = a.getNumTransitions(s0);\n        a.initTransition(s0, t);\n        for(int j=0;j<numTransitions;j++) {\n          a.getNextTransition(t);\n          points.add(t);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final int r = s.state;\n\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          Integer q = newstate.get(statesSet);\n          if (q == null) {\n            q = b.createState();\n            final SortedIntSetLight.FrozenIntSetLight p = statesSet.freeze(q);\n            //System.out.println(\"  make new state=\" + q + \" -> \" + p + \" accCount=\" + accCount);\n            worklist.add(p);\n            b.setAccept(q, accCount > 0);\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == b.isAccept(q): \"accCount=\" + accCount + \" vs existing accept=\" +\n              b.isAccept(q) + \" states=\" + statesSet;\n          }\n\n          // System.out.println(\"  add trans src=\" + r + \" dest=\" + q + \" min=\" + lastPoint + \" max=\" + (point-1));\n\n          b.addTransition(r, q, lastPoint, point-1);\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        int[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.decr(dest);\n          accCount -= a.isAccept(dest) ? 1:0;\n        }\n        points.points[i].ends.next = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.incr(dest);\n          accCount += a.isAccept(dest) ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.next = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n\n    LightAutomaton result = b.finish();\n    assert result.isDeterministic();\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  public static LightAutomaton determinize(LightAutomaton a) {\n    if (a.isDeterministic()) {\n      return a;\n    }\n    if (a.getNumStates() == 0) {\n      return a;\n    }\n\n    // subset construction\n    LightAutomaton.Builder b = new LightAutomaton.Builder();\n\n    //System.out.println(\"DET:\");\n    //a.writeDot(\"/l/la/lucene/core/detin.dot\");\n\n    SortedIntSetLight.FrozenIntSetLight initialset = new SortedIntSetLight.FrozenIntSetLight(0, 0);\n\n    // Create state 0:\n    b.createState();\n\n    LinkedList<SortedIntSetLight.FrozenIntSetLight> worklist = new LinkedList<>();\n    Map<SortedIntSetLight.FrozenIntSetLight,Integer> newstate = new HashMap<>();\n\n    worklist.add(initialset);\n\n    b.setAccept(0, a.isAccept(0));\n    newstate.put(initialset, 0);\n\n    int newStateUpto = 0;\n    int[] newStatesArray = new int[5];\n    newStatesArray[newStateUpto] = 0;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSetLight points = new PointTransitionSetLight();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSetLight statesSet = new SortedIntSetLight(5);\n\n    Transition t = new Transition();\n\n    while (worklist.size() > 0) {\n      SortedIntSetLight.FrozenIntSetLight s = worklist.removeFirst();\n      //System.out.println(\"det: pop set=\" + s);\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final int s0 = s.values[i];\n        int numTransitions = a.getNumTransitions(s0);\n        a.initTransition(s0, t);\n        for(int j=0;j<numTransitions;j++) {\n          a.getNextTransition(t);\n          points.add(t);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final int r = s.state;\n\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          Integer q = newstate.get(statesSet);\n          if (q == null) {\n            q = b.createState();\n            final SortedIntSetLight.FrozenIntSetLight p = statesSet.freeze(q);\n            //System.out.println(\"  make new state=\" + q + \" -> \" + p + \" accCount=\" + accCount);\n            worklist.add(p);\n            b.setAccept(q, accCount > 0);\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == b.isAccept(q): \"accCount=\" + accCount + \" vs existing accept=\" +\n              b.isAccept(q) + \" states=\" + statesSet;\n          }\n\n          // System.out.println(\"  add trans src=\" + r + \" dest=\" + q + \" min=\" + lastPoint + \" max=\" + (point-1));\n\n          b.addTransition(r, q, lastPoint, point-1);\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        int[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.decr(dest);\n          accCount -= a.isAccept(dest) ? 1:0;\n        }\n        points.points[i].ends.next = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.incr(dest);\n          accCount += a.isAccept(dest) ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.next = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n\n    LightAutomaton result = b.finish();\n    assert result.isDeterministic();\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ca1c732df8923f5624f6c06b1dcca9e69d98c96","date":1402957391,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/Operations#determinize(Automaton).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/BasicOperations#determinize(LightAutomaton).mjava","sourceNew":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  public static Automaton determinize(Automaton a) {\n    if (a.isDeterministic()) {\n      // Already determinized\n      return a;\n    }\n    if (a.getNumStates() <= 1) {\n      // Already determinized\n      return a;\n    }\n\n    // subset construction\n    Automaton.Builder b = new Automaton.Builder();\n\n    //System.out.println(\"DET:\");\n    //a.writeDot(\"/l/la/lucene/core/detin.dot\");\n\n    SortedIntSet.FrozenIntSet initialset = new SortedIntSet.FrozenIntSet(0, 0);\n\n    // Create state 0:\n    b.createState();\n\n    LinkedList<SortedIntSet.FrozenIntSet> worklist = new LinkedList<>();\n    Map<SortedIntSet.FrozenIntSet,Integer> newstate = new HashMap<>();\n\n    worklist.add(initialset);\n\n    b.setAccept(0, a.isAccept(0));\n    newstate.put(initialset, 0);\n\n    int newStateUpto = 0;\n    int[] newStatesArray = new int[5];\n    newStatesArray[newStateUpto] = 0;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSet points = new PointTransitionSet();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSet statesSet = new SortedIntSet(5);\n\n    Transition t = new Transition();\n\n    while (worklist.size() > 0) {\n      SortedIntSet.FrozenIntSet s = worklist.removeFirst();\n      //System.out.println(\"det: pop set=\" + s);\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final int s0 = s.values[i];\n        int numTransitions = a.getNumTransitions(s0);\n        a.initTransition(s0, t);\n        for(int j=0;j<numTransitions;j++) {\n          a.getNextTransition(t);\n          points.add(t);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final int r = s.state;\n\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          Integer q = newstate.get(statesSet);\n          if (q == null) {\n            q = b.createState();\n            final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);\n            //System.out.println(\"  make new state=\" + q + \" -> \" + p + \" accCount=\" + accCount);\n            worklist.add(p);\n            b.setAccept(q, accCount > 0);\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == b.isAccept(q): \"accCount=\" + accCount + \" vs existing accept=\" +\n              b.isAccept(q) + \" states=\" + statesSet;\n          }\n\n          // System.out.println(\"  add trans src=\" + r + \" dest=\" + q + \" min=\" + lastPoint + \" max=\" + (point-1));\n\n          b.addTransition(r, q, lastPoint, point-1);\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        int[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.decr(dest);\n          accCount -= a.isAccept(dest) ? 1:0;\n        }\n        points.points[i].ends.next = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.incr(dest);\n          accCount += a.isAccept(dest) ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.next = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n\n    Automaton result = b.finish();\n    assert result.isDeterministic();\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Determinizes the given automaton.\n   * <p>\n   * Worst case complexity: exponential in number of states.\n   */\n  public static LightAutomaton determinize(LightAutomaton a) {\n    if (a.isDeterministic()) {\n      // Already determinized\n      return a;\n    }\n    if (a.getNumStates() <= 1) {\n      // Already determinized\n      return a;\n    }\n\n    // subset construction\n    LightAutomaton.Builder b = new LightAutomaton.Builder();\n\n    //System.out.println(\"DET:\");\n    //a.writeDot(\"/l/la/lucene/core/detin.dot\");\n\n    SortedIntSetLight.FrozenIntSetLight initialset = new SortedIntSetLight.FrozenIntSetLight(0, 0);\n\n    // Create state 0:\n    b.createState();\n\n    LinkedList<SortedIntSetLight.FrozenIntSetLight> worklist = new LinkedList<>();\n    Map<SortedIntSetLight.FrozenIntSetLight,Integer> newstate = new HashMap<>();\n\n    worklist.add(initialset);\n\n    b.setAccept(0, a.isAccept(0));\n    newstate.put(initialset, 0);\n\n    int newStateUpto = 0;\n    int[] newStatesArray = new int[5];\n    newStatesArray[newStateUpto] = 0;\n    newStateUpto++;\n\n    // like Set<Integer,PointTransitions>\n    final PointTransitionSetLight points = new PointTransitionSetLight();\n\n    // like SortedMap<Integer,Integer>\n    final SortedIntSetLight statesSet = new SortedIntSetLight(5);\n\n    Transition t = new Transition();\n\n    while (worklist.size() > 0) {\n      SortedIntSetLight.FrozenIntSetLight s = worklist.removeFirst();\n      //System.out.println(\"det: pop set=\" + s);\n\n      // Collate all outgoing transitions by min/1+max:\n      for(int i=0;i<s.values.length;i++) {\n        final int s0 = s.values[i];\n        int numTransitions = a.getNumTransitions(s0);\n        a.initTransition(s0, t);\n        for(int j=0;j<numTransitions;j++) {\n          a.getNextTransition(t);\n          points.add(t);\n        }\n      }\n\n      if (points.count == 0) {\n        // No outgoing transitions -- skip it\n        continue;\n      }\n\n      points.sort();\n\n      int lastPoint = -1;\n      int accCount = 0;\n\n      final int r = s.state;\n\n      for(int i=0;i<points.count;i++) {\n\n        final int point = points.points[i].point;\n\n        if (statesSet.upto > 0) {\n          assert lastPoint != -1;\n\n          statesSet.computeHash();\n          \n          Integer q = newstate.get(statesSet);\n          if (q == null) {\n            q = b.createState();\n            final SortedIntSetLight.FrozenIntSetLight p = statesSet.freeze(q);\n            //System.out.println(\"  make new state=\" + q + \" -> \" + p + \" accCount=\" + accCount);\n            worklist.add(p);\n            b.setAccept(q, accCount > 0);\n            newstate.put(p, q);\n          } else {\n            assert (accCount > 0 ? true:false) == b.isAccept(q): \"accCount=\" + accCount + \" vs existing accept=\" +\n              b.isAccept(q) + \" states=\" + statesSet;\n          }\n\n          // System.out.println(\"  add trans src=\" + r + \" dest=\" + q + \" min=\" + lastPoint + \" max=\" + (point-1));\n\n          b.addTransition(r, q, lastPoint, point-1);\n        }\n\n        // process transitions that end on this point\n        // (closes an overlapping interval)\n        int[] transitions = points.points[i].ends.transitions;\n        int limit = points.points[i].ends.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.decr(dest);\n          accCount -= a.isAccept(dest) ? 1:0;\n        }\n        points.points[i].ends.next = 0;\n\n        // process transitions that start on this point\n        // (opens a new interval)\n        transitions = points.points[i].starts.transitions;\n        limit = points.points[i].starts.next;\n        for(int j=0;j<limit;j+=3) {\n          int dest = transitions[j];\n          statesSet.incr(dest);\n          accCount += a.isAccept(dest) ? 1:0;\n        }\n        lastPoint = point;\n        points.points[i].starts.next = 0;\n      }\n      points.reset();\n      assert statesSet.upto == 0: \"upto=\" + statesSet.upto;\n    }\n\n    LightAutomaton result = b.finish();\n    assert result.isDeterministic();\n    return result;\n  }\n\n","bugFix":null,"bugIntro":["d6b23a02f76f15e0dd99a6951055a45aa5c43c48"],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9":["a67285d1a68175d877eb9fd1624fccad3db028ff"],"a67285d1a68175d877eb9fd1624fccad3db028ff":["0c8cfaac638acc80d26d08288440ede37e6539e9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9"],"0c8cfaac638acc80d26d08288440ede37e6539e9":["ac34f0c5bb9274821fb0cb18075234e02002e9bf"],"ac34f0c5bb9274821fb0cb18075234e02002e9bf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"a67285d1a68175d877eb9fd1624fccad3db028ff":["31d9b8f9a2d48c7d06f33dd5734fbbca9d176ec9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ac34f0c5bb9274821fb0cb18075234e02002e9bf","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":[],"0c8cfaac638acc80d26d08288440ede37e6539e9":["a67285d1a68175d877eb9fd1624fccad3db028ff"],"ac34f0c5bb9274821fb0cb18075234e02002e9bf":["0c8cfaac638acc80d26d08288440ede37e6539e9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}