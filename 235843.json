{"path":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,CoreDescriptor,ConfigSet,String,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","commits":[{"id":"e80876f1ee57780ad756fa083e88c95d7c1d0c0b","date":1595653703,"type":1,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,CoreDescriptor,ConfigSet,String,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,ConfigSet,CoreDescriptor,String,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   */\n  private SolrCore(CoreContainer coreContainer, CoreDescriptor coreDescriptor, ConfigSet configSet,\n                   String dataDir, UpdateHandler updateHandler,\n                   IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    final CountDownLatch latch = new CountDownLatch(1);\n    try {\n      this.coreContainer = coreContainer;\n      this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      setName(coreDescriptor.getName());\n\n      this.solrConfig = configSet.getSolrConfig();\n      this.resourceLoader = configSet.getSolrConfig().getResourceLoader();\n      this.resourceLoader.core = this;\n      schemaPluginsLoader = new PackageListeningClassLoader(coreContainer, resourceLoader,\n              solrConfig::maxPackageVersion,\n              () -> setLatestSchema(configSet.getIndexSchema(true)));\n      this.packageListeners.addListener(schemaPluginsLoader);\n      IndexSchema schema = configSet.getIndexSchema();\n\n      this.configSetProperties = configSet.getProperties();\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(solrConfig);\n      this.circuitBreakerManager = initCircuitBreakerManager();\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, solrConfig, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      if (log.isInfoEnabled()) {\n        log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, getInstancePath(), this.dataDir);\n      }\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n      setLatestSchema(schema);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      this.maxWarmingSearchers = solrConfig.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = solrConfig.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   */\n  private SolrCore(CoreContainer coreContainer, String name, ConfigSet configSet, CoreDescriptor coreDescriptor,\n                  String dataDir, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n      this.solrConfig = configSet.getSolrConfig();\n      this.resourceLoader = configSet.getSolrConfig().getResourceLoader();\n      this.resourceLoader.core = this;\n      schemaPluginsLoader = new PackageListeningClassLoader(coreContainer, resourceLoader,\n              solrConfig::maxPackageVersion,\n              () -> setLatestSchema(configSet.getIndexSchema(true)));\n      this.packageListeners.addListener(schemaPluginsLoader);\n      IndexSchema schema = configSet.getIndexSchema();\n\n      this.configSetProperties = configSet.getProperties();\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(solrConfig);\n      this.circuitBreakerManager = initCircuitBreakerManager();\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, solrConfig, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      if (log.isInfoEnabled()) {\n        log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, getInstancePath(), this.dataDir);\n      }\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n      setLatestSchema(schema);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      this.maxWarmingSearchers = solrConfig.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = solrConfig.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d16198391f70a4ee52a8c8792c91eb87a30f1d6","date":1596695552,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,CoreDescriptor,ConfigSet,String,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,CoreDescriptor,ConfigSet,String,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   */\n  private SolrCore(CoreContainer coreContainer, CoreDescriptor coreDescriptor, ConfigSet configSet,\n                   String dataDir, UpdateHandler updateHandler,\n                   IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    final CountDownLatch latch = new CountDownLatch(1);\n    try {\n      this.coreContainer = coreContainer;\n      this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      setName(coreDescriptor.getName());\n\n      this.solrConfig = configSet.getSolrConfig();\n      this.resourceLoader = configSet.getSolrConfig().getResourceLoader();\n      this.resourceLoader.core = this;\n      schemaPluginsLoader = new PackageListeningClassLoader(coreContainer, resourceLoader,\n              solrConfig::maxPackageVersion,\n              () -> setLatestSchema(configSet.getIndexSchema(true)));\n      this.packageListeners.addListener(schemaPluginsLoader);\n      IndexSchema schema = configSet.getIndexSchema();\n\n      this.configSetProperties = configSet.getProperties();\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(solrConfig);\n      this.circuitBreakerManager = initCircuitBreakerManager();\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, solrConfig, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      if (log.isInfoEnabled()) {\n        log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, getInstancePath(), this.dataDir);\n      }\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n      setLatestSchema(schema);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      this.maxWarmingSearchers = solrConfig.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = solrConfig.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   */\n  private SolrCore(CoreContainer coreContainer, CoreDescriptor coreDescriptor, ConfigSet configSet,\n                   String dataDir, UpdateHandler updateHandler,\n                   IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    final CountDownLatch latch = new CountDownLatch(1);\n    try {\n      this.coreContainer = coreContainer;\n      this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      setName(coreDescriptor.getName());\n\n      this.solrConfig = configSet.getSolrConfig();\n      this.resourceLoader = configSet.getSolrConfig().getResourceLoader();\n      this.resourceLoader.core = this;\n      schemaPluginsLoader = new PackageListeningClassLoader(coreContainer, resourceLoader,\n              solrConfig::maxPackageVersion,\n              () -> setLatestSchema(configSet.getIndexSchema(true)));\n      this.packageListeners.addListener(schemaPluginsLoader);\n      IndexSchema schema = configSet.getIndexSchema();\n\n      this.configSetProperties = configSet.getProperties();\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(solrConfig);\n      this.circuitBreakerManager = initCircuitBreakerManager();\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, solrConfig, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      if (log.isInfoEnabled()) {\n        log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, getInstancePath(), this.dataDir);\n      }\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n      setLatestSchema(schema);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      this.maxWarmingSearchers = solrConfig.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = solrConfig.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0c1f39a1c5a00532404e216378a8157523b83551","date":1597798332,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,CoreDescriptor,ConfigSet,String,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,CoreDescriptor,ConfigSet,String,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   */\n  private SolrCore(CoreContainer coreContainer, CoreDescriptor coreDescriptor, ConfigSet configSet,\n                   String dataDir, UpdateHandler updateHandler,\n                   IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    final CountDownLatch latch = new CountDownLatch(1);\n    try {\n      this.coreContainer = coreContainer;\n      this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      setName(coreDescriptor.getName());\n\n      this.solrConfig = configSet.getSolrConfig();\n      this.resourceLoader = configSet.getSolrConfig().getResourceLoader();\n      schemaPluginsLoader = new PackageListeningClassLoader(coreContainer, resourceLoader,\n              solrConfig::maxPackageVersion,\n              () -> setLatestSchema(configSet.getIndexSchema()));\n      this.packageListeners.addListener(schemaPluginsLoader);\n      IndexSchema schema = configSet.getIndexSchema();\n\n      this.configSetProperties = configSet.getProperties();\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(solrConfig);\n      this.circuitBreakerManager = initCircuitBreakerManager();\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, solrConfig, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      if (log.isInfoEnabled()) {\n        log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, getInstancePath(), this.dataDir);\n      }\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n      setLatestSchema(schema);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      this.maxWarmingSearchers = solrConfig.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = solrConfig.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   */\n  private SolrCore(CoreContainer coreContainer, CoreDescriptor coreDescriptor, ConfigSet configSet,\n                   String dataDir, UpdateHandler updateHandler,\n                   IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    final CountDownLatch latch = new CountDownLatch(1);\n    try {\n      this.coreContainer = coreContainer;\n      this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      setName(coreDescriptor.getName());\n\n      this.solrConfig = configSet.getSolrConfig();\n      this.resourceLoader = configSet.getSolrConfig().getResourceLoader();\n      this.resourceLoader.core = this;\n      schemaPluginsLoader = new PackageListeningClassLoader(coreContainer, resourceLoader,\n              solrConfig::maxPackageVersion,\n              () -> setLatestSchema(configSet.getIndexSchema(true)));\n      this.packageListeners.addListener(schemaPluginsLoader);\n      IndexSchema schema = configSet.getIndexSchema();\n\n      this.configSetProperties = configSet.getProperties();\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(solrConfig);\n      this.circuitBreakerManager = initCircuitBreakerManager();\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, solrConfig, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      if (log.isInfoEnabled()) {\n        log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, getInstancePath(), this.dataDir);\n      }\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n      setLatestSchema(schema);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      this.maxWarmingSearchers = solrConfig.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = solrConfig.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1fc1087854af39c9b439f47d913fd3ac1d85ac5c","date":1599523122,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,CoreDescriptor,ConfigSet,String,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,CoreDescriptor,ConfigSet,String,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   */\n  private SolrCore(CoreContainer coreContainer, CoreDescriptor coreDescriptor, ConfigSet configSet,\n                   String dataDir, UpdateHandler updateHandler,\n                   IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    final CountDownLatch latch = new CountDownLatch(1);\n    try {\n      this.coreContainer = coreContainer;\n      this.configSet = configSet;\n      this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      setName(coreDescriptor.getName());\n\n      this.solrConfig = configSet.getSolrConfig();\n      this.resourceLoader = configSet.getSolrConfig().getResourceLoader();\n      IndexSchema schema = configSet.getIndexSchema();\n\n      this.configSetProperties = configSet.getProperties();\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(solrConfig);\n      this.circuitBreakerManager = initCircuitBreakerManager();\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, solrConfig, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      if (log.isInfoEnabled()) {\n        log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, getInstancePath(), this.dataDir);\n      }\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n      setLatestSchema(schema);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      this.maxWarmingSearchers = solrConfig.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = solrConfig.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   */\n  private SolrCore(CoreContainer coreContainer, CoreDescriptor coreDescriptor, ConfigSet configSet,\n                   String dataDir, UpdateHandler updateHandler,\n                   IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    final CountDownLatch latch = new CountDownLatch(1);\n    try {\n      this.coreContainer = coreContainer;\n      this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      setName(coreDescriptor.getName());\n\n      this.solrConfig = configSet.getSolrConfig();\n      this.resourceLoader = configSet.getSolrConfig().getResourceLoader();\n      schemaPluginsLoader = new PackageListeningClassLoader(coreContainer, resourceLoader,\n              solrConfig::maxPackageVersion,\n              () -> setLatestSchema(configSet.getIndexSchema()));\n      this.packageListeners.addListener(schemaPluginsLoader);\n      IndexSchema schema = configSet.getIndexSchema();\n\n      this.configSetProperties = configSet.getProperties();\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(solrConfig);\n      this.circuitBreakerManager = initCircuitBreakerManager();\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, solrConfig, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      if (log.isInfoEnabled()) {\n        log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, getInstancePath(), this.dataDir);\n      }\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n      setLatestSchema(schema);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      this.maxWarmingSearchers = solrConfig.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = solrConfig.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"938fe8fd4d30ae70161827366f67c2382985e446","date":1600050178,"type":3,"author":"noblepaul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,CoreDescriptor,ConfigSet,String,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,CoreDescriptor,ConfigSet,String,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   */\n  private SolrCore(CoreContainer coreContainer, CoreDescriptor coreDescriptor, ConfigSet configSet,\n                   String dataDir, UpdateHandler updateHandler,\n                   IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    final CountDownLatch latch = new CountDownLatch(1);\n    try {\n      this.coreContainer = coreContainer;\n      this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      setName(coreDescriptor.getName());\n\n      this.solrConfig = configSet.getSolrConfig();\n      this.resourceLoader = configSet.getSolrConfig().getResourceLoader();\n      schemaPluginsLoader = new PackageListeningClassLoader(coreContainer, resourceLoader,\n              solrConfig::maxPackageVersion,\n              () -> setLatestSchema(configSet.getIndexSchema()));\n      this.packageListeners.addListener(schemaPluginsLoader);\n      IndexSchema schema = configSet.getIndexSchema();\n\n      this.configSetProperties = configSet.getProperties();\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(solrConfig);\n      this.circuitBreakerManager = initCircuitBreakerManager();\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, solrConfig, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      if (log.isInfoEnabled()) {\n        log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, getInstancePath(), this.dataDir);\n      }\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n      setLatestSchema(schema);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      this.maxWarmingSearchers = solrConfig.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = solrConfig.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   */\n  private SolrCore(CoreContainer coreContainer, CoreDescriptor coreDescriptor, ConfigSet configSet,\n                   String dataDir, UpdateHandler updateHandler,\n                   IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    final CountDownLatch latch = new CountDownLatch(1);\n    try {\n      this.coreContainer = coreContainer;\n      this.configSet = configSet;\n      this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      setName(coreDescriptor.getName());\n\n      this.solrConfig = configSet.getSolrConfig();\n      this.resourceLoader = configSet.getSolrConfig().getResourceLoader();\n      IndexSchema schema = configSet.getIndexSchema();\n\n      this.configSetProperties = configSet.getProperties();\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(solrConfig);\n      this.circuitBreakerManager = initCircuitBreakerManager();\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, solrConfig, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      if (log.isInfoEnabled()) {\n        log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, getInstancePath(), this.dataDir);\n      }\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n      setLatestSchema(schema);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      this.maxWarmingSearchers = solrConfig.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = solrConfig.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e451e492cce54699988e2ce0aea55e3ff170cb0","date":1600305561,"type":3,"author":"noblepaul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,CoreDescriptor,ConfigSet,String,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,CoreDescriptor,ConfigSet,String,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   */\n  private SolrCore(CoreContainer coreContainer, CoreDescriptor coreDescriptor, ConfigSet configSet,\n                   String dataDir, UpdateHandler updateHandler,\n                   IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    final CountDownLatch latch = new CountDownLatch(1);\n    try {\n      this.coreContainer = coreContainer;\n      this.configSet = configSet;\n      this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      setName(coreDescriptor.getName());\n\n      this.solrConfig = configSet.getSolrConfig();\n      this.resourceLoader = configSet.getSolrConfig().getResourceLoader();\n      IndexSchema schema = configSet.getIndexSchema();\n\n      this.configSetProperties = configSet.getProperties();\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(solrConfig);\n      this.circuitBreakerManager = initCircuitBreakerManager();\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, solrConfig, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      if (log.isInfoEnabled()) {\n        log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, getInstancePath(), this.dataDir);\n      }\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n      setLatestSchema(schema);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      this.maxWarmingSearchers = solrConfig.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = solrConfig.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   */\n  private SolrCore(CoreContainer coreContainer, CoreDescriptor coreDescriptor, ConfigSet configSet,\n                   String dataDir, UpdateHandler updateHandler,\n                   IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    final CountDownLatch latch = new CountDownLatch(1);\n    try {\n      this.coreContainer = coreContainer;\n      this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      setName(coreDescriptor.getName());\n\n      this.solrConfig = configSet.getSolrConfig();\n      this.resourceLoader = configSet.getSolrConfig().getResourceLoader();\n      schemaPluginsLoader = new PackageListeningClassLoader(coreContainer, resourceLoader,\n              solrConfig::maxPackageVersion,\n              () -> setLatestSchema(configSet.getIndexSchema()));\n      this.packageListeners.addListener(schemaPluginsLoader);\n      IndexSchema schema = configSet.getIndexSchema();\n\n      this.configSetProperties = configSet.getProperties();\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(solrConfig);\n      this.circuitBreakerManager = initCircuitBreakerManager();\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, solrConfig, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      if (log.isInfoEnabled()) {\n        log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, getInstancePath(), this.dataDir);\n      }\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n      setLatestSchema(schema);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      this.maxWarmingSearchers = solrConfig.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = solrConfig.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"403c3219db9547cd15baeb98f0804fbb65f36c0f","date":1600394849,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,CoreDescriptor,ConfigSet,String,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,CoreDescriptor,ConfigSet,String,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   */\n  private SolrCore(CoreContainer coreContainer, CoreDescriptor coreDescriptor, ConfigSet configSet,\n                   String dataDir, UpdateHandler updateHandler,\n                   IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    final CountDownLatch latch = new CountDownLatch(1);\n    try {\n      this.coreContainer = coreContainer;\n      this.configSet = configSet;\n      this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      setName(coreDescriptor.getName());\n      coreProvider = new Provider(coreContainer, getName(), uniqueId);\n\n      this.solrConfig = configSet.getSolrConfig();\n      this.resourceLoader = configSet.getSolrConfig().getResourceLoader();\n      IndexSchema schema = configSet.getIndexSchema();\n\n      this.configSetProperties = configSet.getProperties();\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(solrConfig);\n      this.circuitBreakerManager = initCircuitBreakerManager();\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, solrConfig, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      if (log.isInfoEnabled()) {\n        log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, getInstancePath(), this.dataDir);\n      }\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n      setLatestSchema(schema);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      this.maxWarmingSearchers = solrConfig.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = solrConfig.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   */\n  private SolrCore(CoreContainer coreContainer, CoreDescriptor coreDescriptor, ConfigSet configSet,\n                   String dataDir, UpdateHandler updateHandler,\n                   IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    final CountDownLatch latch = new CountDownLatch(1);\n    try {\n      this.coreContainer = coreContainer;\n      this.configSet = configSet;\n      this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      setName(coreDescriptor.getName());\n\n      this.solrConfig = configSet.getSolrConfig();\n      this.resourceLoader = configSet.getSolrConfig().getResourceLoader();\n      IndexSchema schema = configSet.getIndexSchema();\n\n      this.configSetProperties = configSet.getProperties();\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(solrConfig);\n      this.circuitBreakerManager = initCircuitBreakerManager();\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, solrConfig, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      if (log.isInfoEnabled()) {\n        log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, getInstancePath(), this.dataDir);\n      }\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n      setLatestSchema(schema);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      this.maxWarmingSearchers = solrConfig.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = solrConfig.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"403c3219db9547cd15baeb98f0804fbb65f36c0f":["0e451e492cce54699988e2ce0aea55e3ff170cb0"],"0c1f39a1c5a00532404e216378a8157523b83551":["0d16198391f70a4ee52a8c8792c91eb87a30f1d6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1fc1087854af39c9b439f47d913fd3ac1d85ac5c":["0c1f39a1c5a00532404e216378a8157523b83551"],"0d16198391f70a4ee52a8c8792c91eb87a30f1d6":["e80876f1ee57780ad756fa083e88c95d7c1d0c0b"],"938fe8fd4d30ae70161827366f67c2382985e446":["1fc1087854af39c9b439f47d913fd3ac1d85ac5c"],"0e451e492cce54699988e2ce0aea55e3ff170cb0":["938fe8fd4d30ae70161827366f67c2382985e446"],"e80876f1ee57780ad756fa083e88c95d7c1d0c0b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["403c3219db9547cd15baeb98f0804fbb65f36c0f"]},"commit2Childs":{"403c3219db9547cd15baeb98f0804fbb65f36c0f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0c1f39a1c5a00532404e216378a8157523b83551":["1fc1087854af39c9b439f47d913fd3ac1d85ac5c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e80876f1ee57780ad756fa083e88c95d7c1d0c0b"],"1fc1087854af39c9b439f47d913fd3ac1d85ac5c":["938fe8fd4d30ae70161827366f67c2382985e446"],"0d16198391f70a4ee52a8c8792c91eb87a30f1d6":["0c1f39a1c5a00532404e216378a8157523b83551"],"938fe8fd4d30ae70161827366f67c2382985e446":["0e451e492cce54699988e2ce0aea55e3ff170cb0"],"0e451e492cce54699988e2ce0aea55e3ff170cb0":["403c3219db9547cd15baeb98f0804fbb65f36c0f"],"e80876f1ee57780ad756fa083e88c95d7c1d0c0b":["0d16198391f70a4ee52a8c8792c91eb87a30f1d6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}