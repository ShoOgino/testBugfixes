{"path":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#handleGroupByFacet(String,String,List[Map.Entry[String,Class]],String,List[Pair[String,String]],List[String],List[Pair[String,String]],String,String).mjava","commits":[{"id":"d5cb41f0427fb7a75b0bfefe992561738c11fd80","date":1486576891,"type":1,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#handleGroupByFacet(String,String,List[Map.Entry[String,Class]],String,List[Pair[String,String]],List[String],List[Pair[String,String]],String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#handleGroupByFacet(String,String,List[Map.Entry[String,Class]],String,List[Pair[String,String]],List[String],List[Pair[String,String]],String).mjava","sourceNew":"  private TupleStream handleGroupByFacet(String zkHost,\n                                         String collection,\n                                         final List<Map.Entry<String, Class>> fields,\n                                         final String query,\n                                         final List<Pair<String, String>> orders,\n                                         final List<String> bucketFields,\n                                         final List<Pair<String, String>> metricPairs,\n                                         final String lim,\n                                         final String havingPredicate) throws IOException {\n\n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.add(CommonParams.Q, query);\n\n    Bucket[] buckets = buildBuckets(bucketFields, fields);\n    Metric[] metrics = buildMetrics(metricPairs).toArray(new Metric[0]);\n    if(metrics.length == 0) {\n      metrics = new Metric[1];\n      metrics[0] = new CountMetric();\n    }\n\n    int limit = lim != null ? Integer.parseInt(lim) : 100;\n\n    FieldComparator[] sorts = null;\n\n    if(orders == null || orders.size() == 0) {\n      sorts = new FieldComparator[buckets.length];\n      for(int i=0; i<sorts.length; i++) {\n        sorts[i] = new FieldComparator(\"index\", ComparatorOrder.ASCENDING);\n      }\n    } else {\n      sorts = getComps(orders);\n    }\n\n    TupleStream tupleStream = new FacetStream(zkHost,\n                                              collection,\n                                              solrParams,\n                                              buckets,\n                                              metrics,\n                                              sorts,\n                                              limit);\n\n\n\n    StreamFactory factory = new StreamFactory()\n        .withFunctionName(\"search\", CloudSolrStream.class)\n        .withFunctionName(\"parallel\", ParallelStream.class)\n        .withFunctionName(\"rollup\", RollupStream.class)\n        .withFunctionName(\"sum\", SumMetric.class)\n        .withFunctionName(\"min\", MinMetric.class)\n        .withFunctionName(\"max\", MaxMetric.class)\n        .withFunctionName(\"avg\", MeanMetric.class)\n        .withFunctionName(\"count\", CountMetric.class)\n        .withFunctionName(\"and\", AndOperation.class)\n        .withFunctionName(\"or\", OrOperation.class)\n        .withFunctionName(\"not\", NotOperation.class)\n        .withFunctionName(\"eq\", EqualsOperation.class)\n        .withFunctionName(\"gt\", GreaterThanOperation.class)\n        .withFunctionName(\"lt\", LessThanOperation.class)\n        .withFunctionName(\"lteq\", LessThanEqualToOperation.class)\n        .withFunctionName(\"gteq\", GreaterThanEqualToOperation.class);\n\n    if(havingPredicate != null) {\n      BooleanOperation booleanOperation = (BooleanOperation)factory.constructOperation(StreamExpressionParser.parse(havingPredicate));\n      tupleStream = new HavingStream(tupleStream, booleanOperation);\n    }\n\n    if(lim != null)\n    {\n      tupleStream = new LimitStream(tupleStream, limit);\n    }\n\n    return tupleStream;\n  }\n\n","sourceOld":"  private TupleStream handleGroupByFacet(String zkHost,\n                                         String collection,\n                                         final List<Map.Entry<String, Class>> fields,\n                                         final String query,\n                                         final List<Pair<String, String>> orders,\n                                         final List<String> bucketFields,\n                                         final List<Pair<String, String>> metricPairs,\n                                         final String lim) throws IOException {\n\n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.add(CommonParams.Q, query);\n\n    Bucket[] buckets = buildBuckets(bucketFields, fields);\n    Metric[] metrics = buildMetrics(metricPairs).toArray(new Metric[0]);\n    if(metrics.length == 0) {\n      metrics = new Metric[1];\n      metrics[0] = new CountMetric();\n    }\n\n    int limit = lim != null ? Integer.parseInt(lim) : 100;\n\n    FieldComparator[] sorts = null;\n\n    if(orders == null || orders.size() == 0) {\n      sorts = new FieldComparator[buckets.length];\n      for(int i=0; i<sorts.length; i++) {\n        sorts[i] = new FieldComparator(\"index\", ComparatorOrder.ASCENDING);\n      }\n    } else {\n      sorts = getComps(orders);\n    }\n\n    TupleStream tupleStream = new FacetStream(zkHost,\n                                              collection,\n                                              solrParams,\n                                              buckets,\n                                              metrics,\n                                              sorts,\n                                              limit);\n\n\n    if(lim != null)\n    {\n      tupleStream = new LimitStream(tupleStream, limit);\n    }\n\n    return tupleStream;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f20deebda1cf327549c84cb60464135abd31c71","date":1487004368,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#handleGroupByFacet(String,String,List[Map.Entry[String,Class]],String,List[Pair[String,String]],List[String],List[Pair[String,String]],String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#handleGroupByFacet(String,String,List[Map.Entry[String,Class]],String,List[Pair[String,String]],List[String],List[Pair[String,String]],String,String).mjava","sourceNew":"  private TupleStream handleGroupByFacet(String zkHost,\n                                         String collection,\n                                         final List<Map.Entry<String, Class>> fields,\n                                         final String query,\n                                         final List<Pair<String, String>> orders,\n                                         final List<String> bucketFields,\n                                         final List<Pair<String, String>> metricPairs,\n                                         final String lim,\n                                         final String havingPredicate) throws IOException {\n\n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.add(CommonParams.Q, query);\n\n    Bucket[] buckets = buildBuckets(bucketFields, fields);\n    Metric[] metrics = buildMetrics(metricPairs, true).toArray(new Metric[0]);\n    if(metrics.length == 0) {\n      metrics = new Metric[1];\n      metrics[0] = new CountMetric();\n    }\n\n    int limit = lim != null ? Integer.parseInt(lim) : 1000;\n\n    FieldComparator[] sorts = null;\n\n    if(orders == null || orders.size() == 0) {\n      sorts = new FieldComparator[buckets.length];\n      for(int i=0; i<sorts.length; i++) {\n        sorts[i] = new FieldComparator(\"index\", ComparatorOrder.ASCENDING);\n      }\n    } else {\n      sorts = getComps(orders);\n    }\n\n    int overfetch = (int)(limit * 1.25);\n\n    TupleStream tupleStream = new FacetStream(zkHost,\n                                              collection,\n                                              solrParams,\n                                              buckets,\n                                              metrics,\n                                              sorts,\n                                              overfetch);\n\n\n\n    StreamFactory factory = new StreamFactory()\n        .withFunctionName(\"search\", CloudSolrStream.class)\n        .withFunctionName(\"parallel\", ParallelStream.class)\n        .withFunctionName(\"rollup\", RollupStream.class)\n        .withFunctionName(\"sum\", SumMetric.class)\n        .withFunctionName(\"min\", MinMetric.class)\n        .withFunctionName(\"max\", MaxMetric.class)\n        .withFunctionName(\"avg\", MeanMetric.class)\n        .withFunctionName(\"count\", CountMetric.class)\n        .withFunctionName(\"and\", AndOperation.class)\n        .withFunctionName(\"or\", OrOperation.class)\n        .withFunctionName(\"not\", NotOperation.class)\n        .withFunctionName(\"eq\", EqualsOperation.class)\n        .withFunctionName(\"gt\", GreaterThanOperation.class)\n        .withFunctionName(\"lt\", LessThanOperation.class)\n        .withFunctionName(\"lteq\", LessThanEqualToOperation.class)\n        .withFunctionName(\"gteq\", GreaterThanEqualToOperation.class);\n\n    if(havingPredicate != null) {\n      BooleanOperation booleanOperation = (BooleanOperation)factory.constructOperation(StreamExpressionParser.parse(havingPredicate));\n      tupleStream = new HavingStream(tupleStream, booleanOperation);\n    }\n\n    if(lim != null)\n    {\n      tupleStream = new LimitStream(tupleStream, limit);\n    }\n\n    return tupleStream;\n  }\n\n","sourceOld":"  private TupleStream handleGroupByFacet(String zkHost,\n                                         String collection,\n                                         final List<Map.Entry<String, Class>> fields,\n                                         final String query,\n                                         final List<Pair<String, String>> orders,\n                                         final List<String> bucketFields,\n                                         final List<Pair<String, String>> metricPairs,\n                                         final String lim,\n                                         final String havingPredicate) throws IOException {\n\n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.add(CommonParams.Q, query);\n\n    Bucket[] buckets = buildBuckets(bucketFields, fields);\n    Metric[] metrics = buildMetrics(metricPairs).toArray(new Metric[0]);\n    if(metrics.length == 0) {\n      metrics = new Metric[1];\n      metrics[0] = new CountMetric();\n    }\n\n    int limit = lim != null ? Integer.parseInt(lim) : 100;\n\n    FieldComparator[] sorts = null;\n\n    if(orders == null || orders.size() == 0) {\n      sorts = new FieldComparator[buckets.length];\n      for(int i=0; i<sorts.length; i++) {\n        sorts[i] = new FieldComparator(\"index\", ComparatorOrder.ASCENDING);\n      }\n    } else {\n      sorts = getComps(orders);\n    }\n\n    TupleStream tupleStream = new FacetStream(zkHost,\n                                              collection,\n                                              solrParams,\n                                              buckets,\n                                              metrics,\n                                              sorts,\n                                              limit);\n\n\n\n    StreamFactory factory = new StreamFactory()\n        .withFunctionName(\"search\", CloudSolrStream.class)\n        .withFunctionName(\"parallel\", ParallelStream.class)\n        .withFunctionName(\"rollup\", RollupStream.class)\n        .withFunctionName(\"sum\", SumMetric.class)\n        .withFunctionName(\"min\", MinMetric.class)\n        .withFunctionName(\"max\", MaxMetric.class)\n        .withFunctionName(\"avg\", MeanMetric.class)\n        .withFunctionName(\"count\", CountMetric.class)\n        .withFunctionName(\"and\", AndOperation.class)\n        .withFunctionName(\"or\", OrOperation.class)\n        .withFunctionName(\"not\", NotOperation.class)\n        .withFunctionName(\"eq\", EqualsOperation.class)\n        .withFunctionName(\"gt\", GreaterThanOperation.class)\n        .withFunctionName(\"lt\", LessThanOperation.class)\n        .withFunctionName(\"lteq\", LessThanEqualToOperation.class)\n        .withFunctionName(\"gteq\", GreaterThanEqualToOperation.class);\n\n    if(havingPredicate != null) {\n      BooleanOperation booleanOperation = (BooleanOperation)factory.constructOperation(StreamExpressionParser.parse(havingPredicate));\n      tupleStream = new HavingStream(tupleStream, booleanOperation);\n    }\n\n    if(lim != null)\n    {\n      tupleStream = new LimitStream(tupleStream, limit);\n    }\n\n    return tupleStream;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"116fdd6b9e04e18a6547a5650bc0afd3fda020aa","date":1487184909,"type":0,"author":"Joel Bernstein","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#handleGroupByFacet(String,String,List[Map.Entry[String,Class]],String,List[Pair[String,String]],List[String],List[Pair[String,String]],String,String).mjava","pathOld":"/dev/null","sourceNew":"  private TupleStream handleGroupByFacet(String zkHost,\n                                         String collection,\n                                         final List<Map.Entry<String, Class>> fields,\n                                         final String query,\n                                         final List<Pair<String, String>> orders,\n                                         final List<String> bucketFields,\n                                         final List<Pair<String, String>> metricPairs,\n                                         final String lim,\n                                         final String havingPredicate) throws IOException {\n\n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.add(CommonParams.Q, query);\n\n    Bucket[] buckets = buildBuckets(bucketFields, fields);\n    Metric[] metrics = buildMetrics(metricPairs, true).toArray(new Metric[0]);\n    if(metrics.length == 0) {\n      metrics = new Metric[1];\n      metrics[0] = new CountMetric();\n    }\n\n    int limit = lim != null ? Integer.parseInt(lim) : 1000;\n\n    FieldComparator[] sorts = null;\n\n    if(orders == null || orders.size() == 0) {\n      sorts = new FieldComparator[buckets.length];\n      for(int i=0; i<sorts.length; i++) {\n        sorts[i] = new FieldComparator(\"index\", ComparatorOrder.ASCENDING);\n      }\n    } else {\n      sorts = getComps(orders);\n    }\n\n    int overfetch = (int)(limit * 1.25);\n\n    TupleStream tupleStream = new FacetStream(zkHost,\n                                              collection,\n                                              solrParams,\n                                              buckets,\n                                              metrics,\n                                              sorts,\n                                              overfetch);\n\n\n\n    StreamFactory factory = new StreamFactory()\n        .withFunctionName(\"search\", CloudSolrStream.class)\n        .withFunctionName(\"parallel\", ParallelStream.class)\n        .withFunctionName(\"rollup\", RollupStream.class)\n        .withFunctionName(\"sum\", SumMetric.class)\n        .withFunctionName(\"min\", MinMetric.class)\n        .withFunctionName(\"max\", MaxMetric.class)\n        .withFunctionName(\"avg\", MeanMetric.class)\n        .withFunctionName(\"count\", CountMetric.class)\n        .withFunctionName(\"and\", AndOperation.class)\n        .withFunctionName(\"or\", OrOperation.class)\n        .withFunctionName(\"not\", NotOperation.class)\n        .withFunctionName(\"eq\", EqualsOperation.class)\n        .withFunctionName(\"gt\", GreaterThanOperation.class)\n        .withFunctionName(\"lt\", LessThanOperation.class)\n        .withFunctionName(\"lteq\", LessThanEqualToOperation.class)\n        .withFunctionName(\"gteq\", GreaterThanEqualToOperation.class);\n\n    if(havingPredicate != null) {\n      BooleanOperation booleanOperation = (BooleanOperation)factory.constructOperation(StreamExpressionParser.parse(havingPredicate));\n      tupleStream = new HavingStream(tupleStream, booleanOperation);\n    }\n\n    if(lim != null)\n    {\n      tupleStream = new LimitStream(tupleStream, limit);\n    }\n\n    return tupleStream;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f48c9aed8d697923300603241ba117b0c19bf774","date":1487186484,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#handleGroupByFacet(String,String,List[Map.Entry[String,Class]],String,List[Pair[String,String]],List[String],List[Pair[String,String]],String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#handleGroupByFacet(String,String,List[Map.Entry[String,Class]],String,List[Pair[String,String]],List[String],List[Pair[String,String]],String,String).mjava","sourceNew":"  private TupleStream handleGroupByFacet(String zkHost,\n                                         String collection,\n                                         final List<Map.Entry<String, Class>> fields,\n                                         final String query,\n                                         final List<Pair<String, String>> orders,\n                                         final List<String> bucketFields,\n                                         final List<Pair<String, String>> metricPairs,\n                                         final String lim,\n                                         final String havingPredicate) throws IOException {\n\n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.add(CommonParams.Q, query);\n\n    Bucket[] buckets = buildBuckets(bucketFields, fields);\n    Metric[] metrics = buildMetrics(metricPairs, true).toArray(new Metric[0]);\n    if(metrics.length == 0) {\n      metrics = new Metric[1];\n      metrics[0] = new CountMetric();\n    }\n\n    int limit = lim != null ? Integer.parseInt(lim) : 1000;\n\n    FieldComparator[] sorts = null;\n\n    if(orders == null || orders.size() == 0) {\n      sorts = new FieldComparator[buckets.length];\n      for(int i=0; i<sorts.length; i++) {\n        sorts[i] = new FieldComparator(\"index\", ComparatorOrder.ASCENDING);\n      }\n    } else {\n      sorts = getComps(orders);\n    }\n\n    int overfetch = (int)(limit * 1.25);\n\n    TupleStream tupleStream = new FacetStream(zkHost,\n                                              collection,\n                                              solrParams,\n                                              buckets,\n                                              metrics,\n                                              sorts,\n                                              overfetch);\n\n\n\n    StreamFactory factory = new StreamFactory()\n        .withFunctionName(\"search\", CloudSolrStream.class)\n        .withFunctionName(\"parallel\", ParallelStream.class)\n        .withFunctionName(\"rollup\", RollupStream.class)\n        .withFunctionName(\"sum\", SumMetric.class)\n        .withFunctionName(\"min\", MinMetric.class)\n        .withFunctionName(\"max\", MaxMetric.class)\n        .withFunctionName(\"avg\", MeanMetric.class)\n        .withFunctionName(\"count\", CountMetric.class)\n        .withFunctionName(\"and\", AndEvaluator.class)\n        .withFunctionName(\"or\", OrEvaluator.class)\n        .withFunctionName(\"not\", NotEvaluator.class)\n        .withFunctionName(\"eq\", EqualsEvaluator.class)\n        .withFunctionName(\"val\", RawValueEvaluator.class)\n        .withFunctionName(\"gt\", GreaterThanEvaluator.class)\n        .withFunctionName(\"lt\", LessThanEvaluator.class)\n        .withFunctionName(\"lteq\", LessThanEqualToEvaluator.class)\n        .withFunctionName(\"gteq\", GreaterThanEqualToEvaluator.class);\n\n    if(havingPredicate != null) {\n      BooleanEvaluator booleanOperation = (BooleanEvaluator)factory.constructEvaluator(StreamExpressionParser.parse(havingPredicate));\n      tupleStream = new HavingStream(tupleStream, booleanOperation);\n    }\n\n    if(lim != null)\n    {\n      tupleStream = new LimitStream(tupleStream, limit);\n    }\n\n    return tupleStream;\n  }\n\n","sourceOld":"  private TupleStream handleGroupByFacet(String zkHost,\n                                         String collection,\n                                         final List<Map.Entry<String, Class>> fields,\n                                         final String query,\n                                         final List<Pair<String, String>> orders,\n                                         final List<String> bucketFields,\n                                         final List<Pair<String, String>> metricPairs,\n                                         final String lim,\n                                         final String havingPredicate) throws IOException {\n\n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.add(CommonParams.Q, query);\n\n    Bucket[] buckets = buildBuckets(bucketFields, fields);\n    Metric[] metrics = buildMetrics(metricPairs, true).toArray(new Metric[0]);\n    if(metrics.length == 0) {\n      metrics = new Metric[1];\n      metrics[0] = new CountMetric();\n    }\n\n    int limit = lim != null ? Integer.parseInt(lim) : 1000;\n\n    FieldComparator[] sorts = null;\n\n    if(orders == null || orders.size() == 0) {\n      sorts = new FieldComparator[buckets.length];\n      for(int i=0; i<sorts.length; i++) {\n        sorts[i] = new FieldComparator(\"index\", ComparatorOrder.ASCENDING);\n      }\n    } else {\n      sorts = getComps(orders);\n    }\n\n    int overfetch = (int)(limit * 1.25);\n\n    TupleStream tupleStream = new FacetStream(zkHost,\n                                              collection,\n                                              solrParams,\n                                              buckets,\n                                              metrics,\n                                              sorts,\n                                              overfetch);\n\n\n\n    StreamFactory factory = new StreamFactory()\n        .withFunctionName(\"search\", CloudSolrStream.class)\n        .withFunctionName(\"parallel\", ParallelStream.class)\n        .withFunctionName(\"rollup\", RollupStream.class)\n        .withFunctionName(\"sum\", SumMetric.class)\n        .withFunctionName(\"min\", MinMetric.class)\n        .withFunctionName(\"max\", MaxMetric.class)\n        .withFunctionName(\"avg\", MeanMetric.class)\n        .withFunctionName(\"count\", CountMetric.class)\n        .withFunctionName(\"and\", AndOperation.class)\n        .withFunctionName(\"or\", OrOperation.class)\n        .withFunctionName(\"not\", NotOperation.class)\n        .withFunctionName(\"eq\", EqualsOperation.class)\n        .withFunctionName(\"gt\", GreaterThanOperation.class)\n        .withFunctionName(\"lt\", LessThanOperation.class)\n        .withFunctionName(\"lteq\", LessThanEqualToOperation.class)\n        .withFunctionName(\"gteq\", GreaterThanEqualToOperation.class);\n\n    if(havingPredicate != null) {\n      BooleanOperation booleanOperation = (BooleanOperation)factory.constructOperation(StreamExpressionParser.parse(havingPredicate));\n      tupleStream = new HavingStream(tupleStream, booleanOperation);\n    }\n\n    if(lim != null)\n    {\n      tupleStream = new LimitStream(tupleStream, limit);\n    }\n\n    return tupleStream;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9fe3175bbaa122d67f736a75c2984617c502cc0","date":1490722938,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#handleGroupByFacet(String,String,List[Map.Entry[String,Class]],String,List[Pair[String,String]],List[String],List[Pair[String,String]],String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#handleGroupByFacet(String,String,List[Map.Entry[String,Class]],String,List[Pair[String,String]],List[String],List[Pair[String,String]],String,String).mjava","sourceNew":"  private TupleStream handleGroupByFacet(String zkHost,\n                                         String collection,\n                                         final List<Map.Entry<String, Class>> fields,\n                                         final String query,\n                                         final List<Pair<String, String>> orders,\n                                         final List<String> bucketFields,\n                                         final List<Pair<String, String>> metricPairs,\n                                         final String lim,\n                                         final String havingPredicate) throws IOException {\n\n\n    Map<String, Class> fmap = new HashMap();\n    for(Map.Entry<String, Class> f : fields) {\n      fmap.put(f.getKey(), f.getValue());\n    }\n\n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.add(CommonParams.Q, query);\n\n    Bucket[] buckets = buildBuckets(bucketFields, fields);\n    Metric[] metrics = buildMetrics(metricPairs, true).toArray(new Metric[0]);\n    if(metrics.length == 0) {\n      metrics = new Metric[1];\n      metrics[0] = new CountMetric();\n    } else {\n      for(Metric metric : metrics) {\n        Class c = fmap.get(metric.getIdentifier());\n        if(Long.class.equals(c)) {\n          metric.outputLong = true;\n        }\n      }\n    }\n\n    int limit = lim != null ? Integer.parseInt(lim) : 1000;\n\n    FieldComparator[] sorts = null;\n\n    if(orders == null || orders.size() == 0) {\n      sorts = new FieldComparator[buckets.length];\n      for(int i=0; i<sorts.length; i++) {\n        sorts[i] = new FieldComparator(\"index\", ComparatorOrder.ASCENDING);\n      }\n    } else {\n      sorts = getComps(orders);\n    }\n\n    int overfetch = (int)(limit * 1.25);\n\n    TupleStream tupleStream = new FacetStream(zkHost,\n                                              collection,\n                                              solrParams,\n                                              buckets,\n                                              metrics,\n                                              sorts,\n                                              overfetch);\n\n\n\n    StreamFactory factory = new StreamFactory()\n        .withFunctionName(\"search\", CloudSolrStream.class)\n        .withFunctionName(\"parallel\", ParallelStream.class)\n        .withFunctionName(\"rollup\", RollupStream.class)\n        .withFunctionName(\"sum\", SumMetric.class)\n        .withFunctionName(\"min\", MinMetric.class)\n        .withFunctionName(\"max\", MaxMetric.class)\n        .withFunctionName(\"avg\", MeanMetric.class)\n        .withFunctionName(\"count\", CountMetric.class)\n        .withFunctionName(\"and\", AndEvaluator.class)\n        .withFunctionName(\"or\", OrEvaluator.class)\n        .withFunctionName(\"not\", NotEvaluator.class)\n        .withFunctionName(\"eq\", EqualsEvaluator.class)\n        .withFunctionName(\"val\", RawValueEvaluator.class)\n        .withFunctionName(\"gt\", GreaterThanEvaluator.class)\n        .withFunctionName(\"lt\", LessThanEvaluator.class)\n        .withFunctionName(\"lteq\", LessThanEqualToEvaluator.class)\n        .withFunctionName(\"gteq\", GreaterThanEqualToEvaluator.class);\n\n    if(havingPredicate != null) {\n      BooleanEvaluator booleanOperation = (BooleanEvaluator)factory.constructEvaluator(StreamExpressionParser.parse(havingPredicate));\n      tupleStream = new HavingStream(tupleStream, booleanOperation);\n    }\n\n    if(lim != null)\n    {\n      tupleStream = new LimitStream(tupleStream, limit);\n    }\n\n    return tupleStream;\n  }\n\n","sourceOld":"  private TupleStream handleGroupByFacet(String zkHost,\n                                         String collection,\n                                         final List<Map.Entry<String, Class>> fields,\n                                         final String query,\n                                         final List<Pair<String, String>> orders,\n                                         final List<String> bucketFields,\n                                         final List<Pair<String, String>> metricPairs,\n                                         final String lim,\n                                         final String havingPredicate) throws IOException {\n\n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.add(CommonParams.Q, query);\n\n    Bucket[] buckets = buildBuckets(bucketFields, fields);\n    Metric[] metrics = buildMetrics(metricPairs, true).toArray(new Metric[0]);\n    if(metrics.length == 0) {\n      metrics = new Metric[1];\n      metrics[0] = new CountMetric();\n    }\n\n    int limit = lim != null ? Integer.parseInt(lim) : 1000;\n\n    FieldComparator[] sorts = null;\n\n    if(orders == null || orders.size() == 0) {\n      sorts = new FieldComparator[buckets.length];\n      for(int i=0; i<sorts.length; i++) {\n        sorts[i] = new FieldComparator(\"index\", ComparatorOrder.ASCENDING);\n      }\n    } else {\n      sorts = getComps(orders);\n    }\n\n    int overfetch = (int)(limit * 1.25);\n\n    TupleStream tupleStream = new FacetStream(zkHost,\n                                              collection,\n                                              solrParams,\n                                              buckets,\n                                              metrics,\n                                              sorts,\n                                              overfetch);\n\n\n\n    StreamFactory factory = new StreamFactory()\n        .withFunctionName(\"search\", CloudSolrStream.class)\n        .withFunctionName(\"parallel\", ParallelStream.class)\n        .withFunctionName(\"rollup\", RollupStream.class)\n        .withFunctionName(\"sum\", SumMetric.class)\n        .withFunctionName(\"min\", MinMetric.class)\n        .withFunctionName(\"max\", MaxMetric.class)\n        .withFunctionName(\"avg\", MeanMetric.class)\n        .withFunctionName(\"count\", CountMetric.class)\n        .withFunctionName(\"and\", AndEvaluator.class)\n        .withFunctionName(\"or\", OrEvaluator.class)\n        .withFunctionName(\"not\", NotEvaluator.class)\n        .withFunctionName(\"eq\", EqualsEvaluator.class)\n        .withFunctionName(\"val\", RawValueEvaluator.class)\n        .withFunctionName(\"gt\", GreaterThanEvaluator.class)\n        .withFunctionName(\"lt\", LessThanEvaluator.class)\n        .withFunctionName(\"lteq\", LessThanEqualToEvaluator.class)\n        .withFunctionName(\"gteq\", GreaterThanEqualToEvaluator.class);\n\n    if(havingPredicate != null) {\n      BooleanEvaluator booleanOperation = (BooleanEvaluator)factory.constructEvaluator(StreamExpressionParser.parse(havingPredicate));\n      tupleStream = new HavingStream(tupleStream, booleanOperation);\n    }\n\n    if(lim != null)\n    {\n      tupleStream = new LimitStream(tupleStream, limit);\n    }\n\n    return tupleStream;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a9b741b54c163686a5fd077895a797daa9b0b95f","date":1490873946,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#handleGroupByFacet(String,String,List[Map.Entry[String,Class]],String,List[Pair[String,String]],List[String],List[Pair[String,String]],String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#handleGroupByFacet(String,String,List[Map.Entry[String,Class]],String,List[Pair[String,String]],List[String],List[Pair[String,String]],String,String).mjava","sourceNew":"  private TupleStream handleGroupByFacet(String zkHost,\n                                         String collection,\n                                         final List<Map.Entry<String, Class>> fields,\n                                         final String query,\n                                         final List<Pair<String, String>> orders,\n                                         final List<String> bucketFields,\n                                         final List<Pair<String, String>> metricPairs,\n                                         final String lim,\n                                         final String havingPredicate) throws IOException {\n\n\n    Map<String, Class> fmap = new HashMap();\n    for(Map.Entry<String, Class> f : fields) {\n      fmap.put(f.getKey(), f.getValue());\n    }\n\n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.add(CommonParams.Q, query);\n\n    Bucket[] buckets = buildBuckets(bucketFields, fields);\n    Metric[] metrics = buildMetrics(metricPairs, true).toArray(new Metric[0]);\n    if(metrics.length == 0) {\n      metrics = new Metric[1];\n      metrics[0] = new CountMetric();\n    } else {\n      for(Metric metric : metrics) {\n        Class c = fmap.get(metric.getIdentifier());\n        if(Long.class.equals(c)) {\n          metric.outputLong = true;\n        }\n      }\n    }\n\n    int limit = lim != null ? Integer.parseInt(lim) : 1000;\n\n    FieldComparator[] sorts = null;\n\n    if(orders == null || orders.size() == 0) {\n      sorts = new FieldComparator[buckets.length];\n      for(int i=0; i<sorts.length; i++) {\n        sorts[i] = new FieldComparator(\"index\", ComparatorOrder.ASCENDING);\n      }\n    } else {\n      sorts = getComps(orders);\n    }\n\n    int overfetch = (int)(limit * 1.25);\n\n    TupleStream tupleStream = new FacetStream(zkHost,\n                                              collection,\n                                              solrParams,\n                                              buckets,\n                                              metrics,\n                                              sorts,\n                                              overfetch);\n\n\n\n    StreamFactory factory = new StreamFactory()\n        .withFunctionName(\"search\", CloudSolrStream.class)\n        .withFunctionName(\"parallel\", ParallelStream.class)\n        .withFunctionName(\"rollup\", RollupStream.class)\n        .withFunctionName(\"sum\", SumMetric.class)\n        .withFunctionName(\"min\", MinMetric.class)\n        .withFunctionName(\"max\", MaxMetric.class)\n        .withFunctionName(\"avg\", MeanMetric.class)\n        .withFunctionName(\"count\", CountMetric.class)\n        .withFunctionName(\"and\", AndEvaluator.class)\n        .withFunctionName(\"or\", OrEvaluator.class)\n        .withFunctionName(\"not\", NotEvaluator.class)\n        .withFunctionName(\"eq\", EqualsEvaluator.class)\n        .withFunctionName(\"val\", RawValueEvaluator.class)\n        .withFunctionName(\"gt\", GreaterThanEvaluator.class)\n        .withFunctionName(\"lt\", LessThanEvaluator.class)\n        .withFunctionName(\"lteq\", LessThanEqualToEvaluator.class)\n        .withFunctionName(\"gteq\", GreaterThanEqualToEvaluator.class);\n\n    if(havingPredicate != null) {\n      BooleanEvaluator booleanOperation = (BooleanEvaluator)factory.constructEvaluator(StreamExpressionParser.parse(havingPredicate));\n      tupleStream = new HavingStream(tupleStream, booleanOperation);\n    }\n\n    if(lim != null)\n    {\n      tupleStream = new LimitStream(tupleStream, limit);\n    }\n\n    return tupleStream;\n  }\n\n","sourceOld":"  private TupleStream handleGroupByFacet(String zkHost,\n                                         String collection,\n                                         final List<Map.Entry<String, Class>> fields,\n                                         final String query,\n                                         final List<Pair<String, String>> orders,\n                                         final List<String> bucketFields,\n                                         final List<Pair<String, String>> metricPairs,\n                                         final String lim,\n                                         final String havingPredicate) throws IOException {\n\n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.add(CommonParams.Q, query);\n\n    Bucket[] buckets = buildBuckets(bucketFields, fields);\n    Metric[] metrics = buildMetrics(metricPairs, true).toArray(new Metric[0]);\n    if(metrics.length == 0) {\n      metrics = new Metric[1];\n      metrics[0] = new CountMetric();\n    }\n\n    int limit = lim != null ? Integer.parseInt(lim) : 1000;\n\n    FieldComparator[] sorts = null;\n\n    if(orders == null || orders.size() == 0) {\n      sorts = new FieldComparator[buckets.length];\n      for(int i=0; i<sorts.length; i++) {\n        sorts[i] = new FieldComparator(\"index\", ComparatorOrder.ASCENDING);\n      }\n    } else {\n      sorts = getComps(orders);\n    }\n\n    int overfetch = (int)(limit * 1.25);\n\n    TupleStream tupleStream = new FacetStream(zkHost,\n                                              collection,\n                                              solrParams,\n                                              buckets,\n                                              metrics,\n                                              sorts,\n                                              overfetch);\n\n\n\n    StreamFactory factory = new StreamFactory()\n        .withFunctionName(\"search\", CloudSolrStream.class)\n        .withFunctionName(\"parallel\", ParallelStream.class)\n        .withFunctionName(\"rollup\", RollupStream.class)\n        .withFunctionName(\"sum\", SumMetric.class)\n        .withFunctionName(\"min\", MinMetric.class)\n        .withFunctionName(\"max\", MaxMetric.class)\n        .withFunctionName(\"avg\", MeanMetric.class)\n        .withFunctionName(\"count\", CountMetric.class)\n        .withFunctionName(\"and\", AndEvaluator.class)\n        .withFunctionName(\"or\", OrEvaluator.class)\n        .withFunctionName(\"not\", NotEvaluator.class)\n        .withFunctionName(\"eq\", EqualsEvaluator.class)\n        .withFunctionName(\"val\", RawValueEvaluator.class)\n        .withFunctionName(\"gt\", GreaterThanEvaluator.class)\n        .withFunctionName(\"lt\", LessThanEvaluator.class)\n        .withFunctionName(\"lteq\", LessThanEqualToEvaluator.class)\n        .withFunctionName(\"gteq\", GreaterThanEqualToEvaluator.class);\n\n    if(havingPredicate != null) {\n      BooleanEvaluator booleanOperation = (BooleanEvaluator)factory.constructEvaluator(StreamExpressionParser.parse(havingPredicate));\n      tupleStream = new HavingStream(tupleStream, booleanOperation);\n    }\n\n    if(lim != null)\n    {\n      tupleStream = new LimitStream(tupleStream, limit);\n    }\n\n    return tupleStream;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba1e7de64990e3928b90142a52fb92eeff556475","date":1503713257,"type":3,"author":"Dennis Gove","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#handleGroupByFacet(String,String,List[Map.Entry[String,Class]],String,List[Pair[String,String]],List[String],List[Pair[String,String]],String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#handleGroupByFacet(String,String,List[Map.Entry[String,Class]],String,List[Pair[String,String]],List[String],List[Pair[String,String]],String,String).mjava","sourceNew":"  private TupleStream handleGroupByFacet(String zkHost,\n                                         String collection,\n                                         final List<Map.Entry<String, Class>> fields,\n                                         final String query,\n                                         final List<Pair<String, String>> orders,\n                                         final List<String> bucketFields,\n                                         final List<Pair<String, String>> metricPairs,\n                                         final String lim,\n                                         final String havingPredicate) throws IOException {\n\n\n    Map<String, Class> fmap = new HashMap();\n    for(Map.Entry<String, Class> f : fields) {\n      fmap.put(f.getKey(), f.getValue());\n    }\n\n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.add(CommonParams.Q, query);\n\n    Bucket[] buckets = buildBuckets(bucketFields, fields);\n    Metric[] metrics = buildMetrics(metricPairs, true).toArray(new Metric[0]);\n    if(metrics.length == 0) {\n      metrics = new Metric[1];\n      metrics[0] = new CountMetric();\n    } else {\n      for(Metric metric : metrics) {\n        Class c = fmap.get(metric.getIdentifier());\n        if(Long.class.equals(c)) {\n          metric.outputLong = true;\n        }\n      }\n    }\n\n    int limit = lim != null ? Integer.parseInt(lim) : 1000;\n\n    FieldComparator[] sorts = null;\n\n    if(orders == null || orders.size() == 0) {\n      sorts = new FieldComparator[buckets.length];\n      for(int i=0; i<sorts.length; i++) {\n        sorts[i] = new FieldComparator(\"index\", ComparatorOrder.ASCENDING);\n      }\n    } else {\n      sorts = getComps(orders);\n    }\n\n    int overfetch = (int)(limit * 1.25);\n\n    TupleStream tupleStream = new FacetStream(zkHost,\n                                              collection,\n                                              solrParams,\n                                              buckets,\n                                              metrics,\n                                              sorts,\n                                              overfetch);\n\n\n\n    StreamFactory factory = new StreamFactory()\n        .withFunctionName(\"search\", CloudSolrStream.class)\n        .withFunctionName(\"parallel\", ParallelStream.class)\n        .withFunctionName(\"rollup\", RollupStream.class)\n        .withFunctionName(\"sum\", SumMetric.class)\n        .withFunctionName(\"min\", MinMetric.class)\n        .withFunctionName(\"max\", MaxMetric.class)\n        .withFunctionName(\"avg\", MeanMetric.class)\n        .withFunctionName(\"count\", CountMetric.class)\n        .withFunctionName(\"and\", AndEvaluator.class)\n        .withFunctionName(\"or\", OrEvaluator.class)\n        .withFunctionName(\"not\", NotEvaluator.class)\n        .withFunctionName(\"eq\", EqualToEvaluator.class)\n        .withFunctionName(\"val\", RawValueEvaluator.class)\n        .withFunctionName(\"gt\", GreaterThanEvaluator.class)\n        .withFunctionName(\"lt\", LessThanEvaluator.class)\n        .withFunctionName(\"lteq\", LessThanEqualToEvaluator.class)\n        .withFunctionName(\"gteq\", GreaterThanEqualToEvaluator.class);\n\n    if(havingPredicate != null) {\n      RecursiveBooleanEvaluator booleanOperation = (RecursiveBooleanEvaluator)factory.constructEvaluator(StreamExpressionParser.parse(havingPredicate));\n      tupleStream = new HavingStream(tupleStream, booleanOperation);\n    }\n\n    if(lim != null)\n    {\n      tupleStream = new LimitStream(tupleStream, limit);\n    }\n\n    return tupleStream;\n  }\n\n","sourceOld":"  private TupleStream handleGroupByFacet(String zkHost,\n                                         String collection,\n                                         final List<Map.Entry<String, Class>> fields,\n                                         final String query,\n                                         final List<Pair<String, String>> orders,\n                                         final List<String> bucketFields,\n                                         final List<Pair<String, String>> metricPairs,\n                                         final String lim,\n                                         final String havingPredicate) throws IOException {\n\n\n    Map<String, Class> fmap = new HashMap();\n    for(Map.Entry<String, Class> f : fields) {\n      fmap.put(f.getKey(), f.getValue());\n    }\n\n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.add(CommonParams.Q, query);\n\n    Bucket[] buckets = buildBuckets(bucketFields, fields);\n    Metric[] metrics = buildMetrics(metricPairs, true).toArray(new Metric[0]);\n    if(metrics.length == 0) {\n      metrics = new Metric[1];\n      metrics[0] = new CountMetric();\n    } else {\n      for(Metric metric : metrics) {\n        Class c = fmap.get(metric.getIdentifier());\n        if(Long.class.equals(c)) {\n          metric.outputLong = true;\n        }\n      }\n    }\n\n    int limit = lim != null ? Integer.parseInt(lim) : 1000;\n\n    FieldComparator[] sorts = null;\n\n    if(orders == null || orders.size() == 0) {\n      sorts = new FieldComparator[buckets.length];\n      for(int i=0; i<sorts.length; i++) {\n        sorts[i] = new FieldComparator(\"index\", ComparatorOrder.ASCENDING);\n      }\n    } else {\n      sorts = getComps(orders);\n    }\n\n    int overfetch = (int)(limit * 1.25);\n\n    TupleStream tupleStream = new FacetStream(zkHost,\n                                              collection,\n                                              solrParams,\n                                              buckets,\n                                              metrics,\n                                              sorts,\n                                              overfetch);\n\n\n\n    StreamFactory factory = new StreamFactory()\n        .withFunctionName(\"search\", CloudSolrStream.class)\n        .withFunctionName(\"parallel\", ParallelStream.class)\n        .withFunctionName(\"rollup\", RollupStream.class)\n        .withFunctionName(\"sum\", SumMetric.class)\n        .withFunctionName(\"min\", MinMetric.class)\n        .withFunctionName(\"max\", MaxMetric.class)\n        .withFunctionName(\"avg\", MeanMetric.class)\n        .withFunctionName(\"count\", CountMetric.class)\n        .withFunctionName(\"and\", AndEvaluator.class)\n        .withFunctionName(\"or\", OrEvaluator.class)\n        .withFunctionName(\"not\", NotEvaluator.class)\n        .withFunctionName(\"eq\", EqualsEvaluator.class)\n        .withFunctionName(\"val\", RawValueEvaluator.class)\n        .withFunctionName(\"gt\", GreaterThanEvaluator.class)\n        .withFunctionName(\"lt\", LessThanEvaluator.class)\n        .withFunctionName(\"lteq\", LessThanEqualToEvaluator.class)\n        .withFunctionName(\"gteq\", GreaterThanEqualToEvaluator.class);\n\n    if(havingPredicate != null) {\n      BooleanEvaluator booleanOperation = (BooleanEvaluator)factory.constructEvaluator(StreamExpressionParser.parse(havingPredicate));\n      tupleStream = new HavingStream(tupleStream, booleanOperation);\n    }\n\n    if(lim != null)\n    {\n      tupleStream = new LimitStream(tupleStream, limit);\n    }\n\n    return tupleStream;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"45c28dbb559366e1f4ef8077346552bfb3f7ecf6","date":1503738439,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#handleGroupByFacet(String,String,List[Map.Entry[String,Class]],String,List[Pair[String,String]],List[String],List[Pair[String,String]],String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#handleGroupByFacet(String,String,List[Map.Entry[String,Class]],String,List[Pair[String,String]],List[String],List[Pair[String,String]],String,String).mjava","sourceNew":"  private TupleStream handleGroupByFacet(String zkHost,\n                                         String collection,\n                                         final List<Map.Entry<String, Class>> fields,\n                                         final String query,\n                                         final List<Pair<String, String>> orders,\n                                         final List<String> bucketFields,\n                                         final List<Pair<String, String>> metricPairs,\n                                         final String lim,\n                                         final String havingPredicate) throws IOException {\n\n\n    Map<String, Class> fmap = new HashMap();\n    for(Map.Entry<String, Class> f : fields) {\n      fmap.put(f.getKey(), f.getValue());\n    }\n\n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.add(CommonParams.Q, query);\n\n    Bucket[] buckets = buildBuckets(bucketFields, fields);\n    Metric[] metrics = buildMetrics(metricPairs, true).toArray(new Metric[0]);\n    if(metrics.length == 0) {\n      metrics = new Metric[1];\n      metrics[0] = new CountMetric();\n    } else {\n      for(Metric metric : metrics) {\n        Class c = fmap.get(metric.getIdentifier());\n        if(Long.class.equals(c)) {\n          metric.outputLong = true;\n        }\n      }\n    }\n\n    int limit = lim != null ? Integer.parseInt(lim) : 1000;\n\n    FieldComparator[] sorts = null;\n\n    if(orders == null || orders.size() == 0) {\n      sorts = new FieldComparator[buckets.length];\n      for(int i=0; i<sorts.length; i++) {\n        sorts[i] = new FieldComparator(\"index\", ComparatorOrder.ASCENDING);\n      }\n    } else {\n      sorts = getComps(orders);\n    }\n\n    int overfetch = (int)(limit * 1.25);\n\n    TupleStream tupleStream = new FacetStream(zkHost,\n                                              collection,\n                                              solrParams,\n                                              buckets,\n                                              metrics,\n                                              sorts,\n                                              overfetch);\n\n\n\n    StreamFactory factory = new StreamFactory()\n        .withFunctionName(\"search\", CloudSolrStream.class)\n        .withFunctionName(\"parallel\", ParallelStream.class)\n        .withFunctionName(\"rollup\", RollupStream.class)\n        .withFunctionName(\"sum\", SumMetric.class)\n        .withFunctionName(\"min\", MinMetric.class)\n        .withFunctionName(\"max\", MaxMetric.class)\n        .withFunctionName(\"avg\", MeanMetric.class)\n        .withFunctionName(\"count\", CountMetric.class)\n        .withFunctionName(\"and\", AndEvaluator.class)\n        .withFunctionName(\"or\", OrEvaluator.class)\n        .withFunctionName(\"not\", NotEvaluator.class)\n        .withFunctionName(\"eq\", EqualToEvaluator.class)\n        .withFunctionName(\"val\", RawValueEvaluator.class)\n        .withFunctionName(\"gt\", GreaterThanEvaluator.class)\n        .withFunctionName(\"lt\", LessThanEvaluator.class)\n        .withFunctionName(\"lteq\", LessThanEqualToEvaluator.class)\n        .withFunctionName(\"gteq\", GreaterThanEqualToEvaluator.class);\n\n    if(havingPredicate != null) {\n      RecursiveBooleanEvaluator booleanOperation = (RecursiveBooleanEvaluator)factory.constructEvaluator(StreamExpressionParser.parse(havingPredicate));\n      tupleStream = new HavingStream(tupleStream, booleanOperation);\n    }\n\n    if(lim != null)\n    {\n      tupleStream = new LimitStream(tupleStream, limit);\n    }\n\n    return tupleStream;\n  }\n\n","sourceOld":"  private TupleStream handleGroupByFacet(String zkHost,\n                                         String collection,\n                                         final List<Map.Entry<String, Class>> fields,\n                                         final String query,\n                                         final List<Pair<String, String>> orders,\n                                         final List<String> bucketFields,\n                                         final List<Pair<String, String>> metricPairs,\n                                         final String lim,\n                                         final String havingPredicate) throws IOException {\n\n\n    Map<String, Class> fmap = new HashMap();\n    for(Map.Entry<String, Class> f : fields) {\n      fmap.put(f.getKey(), f.getValue());\n    }\n\n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.add(CommonParams.Q, query);\n\n    Bucket[] buckets = buildBuckets(bucketFields, fields);\n    Metric[] metrics = buildMetrics(metricPairs, true).toArray(new Metric[0]);\n    if(metrics.length == 0) {\n      metrics = new Metric[1];\n      metrics[0] = new CountMetric();\n    } else {\n      for(Metric metric : metrics) {\n        Class c = fmap.get(metric.getIdentifier());\n        if(Long.class.equals(c)) {\n          metric.outputLong = true;\n        }\n      }\n    }\n\n    int limit = lim != null ? Integer.parseInt(lim) : 1000;\n\n    FieldComparator[] sorts = null;\n\n    if(orders == null || orders.size() == 0) {\n      sorts = new FieldComparator[buckets.length];\n      for(int i=0; i<sorts.length; i++) {\n        sorts[i] = new FieldComparator(\"index\", ComparatorOrder.ASCENDING);\n      }\n    } else {\n      sorts = getComps(orders);\n    }\n\n    int overfetch = (int)(limit * 1.25);\n\n    TupleStream tupleStream = new FacetStream(zkHost,\n                                              collection,\n                                              solrParams,\n                                              buckets,\n                                              metrics,\n                                              sorts,\n                                              overfetch);\n\n\n\n    StreamFactory factory = new StreamFactory()\n        .withFunctionName(\"search\", CloudSolrStream.class)\n        .withFunctionName(\"parallel\", ParallelStream.class)\n        .withFunctionName(\"rollup\", RollupStream.class)\n        .withFunctionName(\"sum\", SumMetric.class)\n        .withFunctionName(\"min\", MinMetric.class)\n        .withFunctionName(\"max\", MaxMetric.class)\n        .withFunctionName(\"avg\", MeanMetric.class)\n        .withFunctionName(\"count\", CountMetric.class)\n        .withFunctionName(\"and\", AndEvaluator.class)\n        .withFunctionName(\"or\", OrEvaluator.class)\n        .withFunctionName(\"not\", NotEvaluator.class)\n        .withFunctionName(\"eq\", EqualsEvaluator.class)\n        .withFunctionName(\"val\", RawValueEvaluator.class)\n        .withFunctionName(\"gt\", GreaterThanEvaluator.class)\n        .withFunctionName(\"lt\", LessThanEvaluator.class)\n        .withFunctionName(\"lteq\", LessThanEqualToEvaluator.class)\n        .withFunctionName(\"gteq\", GreaterThanEqualToEvaluator.class);\n\n    if(havingPredicate != null) {\n      BooleanEvaluator booleanOperation = (BooleanEvaluator)factory.constructEvaluator(StreamExpressionParser.parse(havingPredicate));\n      tupleStream = new HavingStream(tupleStream, booleanOperation);\n    }\n\n    if(lim != null)\n    {\n      tupleStream = new LimitStream(tupleStream, limit);\n    }\n\n    return tupleStream;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a7809d1d753b67f48b1a706e17034bf8b624ea3","date":1504366927,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#handleGroupByFacet(String,String,List[Map.Entry[String,Class]],String,List[Pair[String,String]],List[String],List[Pair[String,String]],String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#handleGroupByFacet(String,String,List[Map.Entry[String,Class]],String,List[Pair[String,String]],List[String],List[Pair[String,String]],String,String).mjava","sourceNew":"  private TupleStream handleGroupByFacet(String zkHost,\n                                         String collection,\n                                         final List<Map.Entry<String, Class>> fields,\n                                         final String query,\n                                         final List<Pair<String, String>> orders,\n                                         final List<String> bucketFields,\n                                         final List<Pair<String, String>> metricPairs,\n                                         final String lim,\n                                         final String havingPredicate) throws IOException {\n\n\n    Map<String, Class> fmap = new HashMap();\n    for(Map.Entry<String, Class> f : fields) {\n      fmap.put(f.getKey(), f.getValue());\n    }\n\n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.add(CommonParams.Q, query);\n\n    Bucket[] buckets = buildBuckets(bucketFields, fields);\n    Metric[] metrics = buildMetrics(metricPairs, true).toArray(new Metric[0]);\n    if(metrics.length == 0) {\n      metrics = new Metric[1];\n      metrics[0] = new CountMetric();\n    } else {\n      for(Metric metric : metrics) {\n        Class c = fmap.get(metric.getIdentifier());\n        if(Long.class.equals(c)) {\n          metric.outputLong = true;\n        }\n      }\n    }\n\n    int limit = lim != null ? Integer.parseInt(lim) : 1000;\n\n    FieldComparator[] sorts = null;\n\n    if(orders == null || orders.size() == 0) {\n      sorts = new FieldComparator[buckets.length];\n      for(int i=0; i<sorts.length; i++) {\n        sorts[i] = new FieldComparator(\"index\", ComparatorOrder.ASCENDING);\n      }\n    } else {\n      sorts = getComps(orders);\n    }\n\n    int overfetch = (int)(limit * 1.25);\n\n    TupleStream tupleStream = new FacetStream(zkHost,\n                                              collection,\n                                              solrParams,\n                                              buckets,\n                                              metrics,\n                                              sorts,\n                                              overfetch);\n\n\n\n    StreamFactory factory = new StreamFactory()\n        .withFunctionName(\"search\", CloudSolrStream.class)\n        .withFunctionName(\"parallel\", ParallelStream.class)\n        .withFunctionName(\"rollup\", RollupStream.class)\n        .withFunctionName(\"sum\", SumMetric.class)\n        .withFunctionName(\"min\", MinMetric.class)\n        .withFunctionName(\"max\", MaxMetric.class)\n        .withFunctionName(\"avg\", MeanMetric.class)\n        .withFunctionName(\"count\", CountMetric.class)\n        .withFunctionName(\"and\", AndEvaluator.class)\n        .withFunctionName(\"or\", OrEvaluator.class)\n        .withFunctionName(\"not\", NotEvaluator.class)\n        .withFunctionName(\"eq\", EqualToEvaluator.class)\n        .withFunctionName(\"val\", RawValueEvaluator.class)\n        .withFunctionName(\"gt\", GreaterThanEvaluator.class)\n        .withFunctionName(\"lt\", LessThanEvaluator.class)\n        .withFunctionName(\"lteq\", LessThanEqualToEvaluator.class)\n        .withFunctionName(\"gteq\", GreaterThanEqualToEvaluator.class);\n\n    if(havingPredicate != null) {\n      RecursiveBooleanEvaluator booleanOperation = (RecursiveBooleanEvaluator)factory.constructEvaluator(StreamExpressionParser.parse(havingPredicate));\n      tupleStream = new HavingStream(tupleStream, booleanOperation);\n    }\n\n    if(lim != null)\n    {\n      tupleStream = new LimitStream(tupleStream, limit);\n    }\n\n    return tupleStream;\n  }\n\n","sourceOld":"  private TupleStream handleGroupByFacet(String zkHost,\n                                         String collection,\n                                         final List<Map.Entry<String, Class>> fields,\n                                         final String query,\n                                         final List<Pair<String, String>> orders,\n                                         final List<String> bucketFields,\n                                         final List<Pair<String, String>> metricPairs,\n                                         final String lim,\n                                         final String havingPredicate) throws IOException {\n\n\n    Map<String, Class> fmap = new HashMap();\n    for(Map.Entry<String, Class> f : fields) {\n      fmap.put(f.getKey(), f.getValue());\n    }\n\n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.add(CommonParams.Q, query);\n\n    Bucket[] buckets = buildBuckets(bucketFields, fields);\n    Metric[] metrics = buildMetrics(metricPairs, true).toArray(new Metric[0]);\n    if(metrics.length == 0) {\n      metrics = new Metric[1];\n      metrics[0] = new CountMetric();\n    } else {\n      for(Metric metric : metrics) {\n        Class c = fmap.get(metric.getIdentifier());\n        if(Long.class.equals(c)) {\n          metric.outputLong = true;\n        }\n      }\n    }\n\n    int limit = lim != null ? Integer.parseInt(lim) : 1000;\n\n    FieldComparator[] sorts = null;\n\n    if(orders == null || orders.size() == 0) {\n      sorts = new FieldComparator[buckets.length];\n      for(int i=0; i<sorts.length; i++) {\n        sorts[i] = new FieldComparator(\"index\", ComparatorOrder.ASCENDING);\n      }\n    } else {\n      sorts = getComps(orders);\n    }\n\n    int overfetch = (int)(limit * 1.25);\n\n    TupleStream tupleStream = new FacetStream(zkHost,\n                                              collection,\n                                              solrParams,\n                                              buckets,\n                                              metrics,\n                                              sorts,\n                                              overfetch);\n\n\n\n    StreamFactory factory = new StreamFactory()\n        .withFunctionName(\"search\", CloudSolrStream.class)\n        .withFunctionName(\"parallel\", ParallelStream.class)\n        .withFunctionName(\"rollup\", RollupStream.class)\n        .withFunctionName(\"sum\", SumMetric.class)\n        .withFunctionName(\"min\", MinMetric.class)\n        .withFunctionName(\"max\", MaxMetric.class)\n        .withFunctionName(\"avg\", MeanMetric.class)\n        .withFunctionName(\"count\", CountMetric.class)\n        .withFunctionName(\"and\", AndEvaluator.class)\n        .withFunctionName(\"or\", OrEvaluator.class)\n        .withFunctionName(\"not\", NotEvaluator.class)\n        .withFunctionName(\"eq\", EqualsEvaluator.class)\n        .withFunctionName(\"val\", RawValueEvaluator.class)\n        .withFunctionName(\"gt\", GreaterThanEvaluator.class)\n        .withFunctionName(\"lt\", LessThanEvaluator.class)\n        .withFunctionName(\"lteq\", LessThanEqualToEvaluator.class)\n        .withFunctionName(\"gteq\", GreaterThanEqualToEvaluator.class);\n\n    if(havingPredicate != null) {\n      BooleanEvaluator booleanOperation = (BooleanEvaluator)factory.constructEvaluator(StreamExpressionParser.parse(havingPredicate));\n      tupleStream = new HavingStream(tupleStream, booleanOperation);\n    }\n\n    if(lim != null)\n    {\n      tupleStream = new LimitStream(tupleStream, limit);\n    }\n\n    return tupleStream;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8582f07e9350eaeb33bf6c4617b8c9895d99c839","date":1591307386,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#handleGroupByFacet(String,String,List[Map.Entry[String,Class]],String,List[Pair[String,String]],List[String],List[Pair[String,String]],String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/sql/SolrTable#handleGroupByFacet(String,String,List[Map.Entry[String,Class]],String,List[Pair[String,String]],List[String],List[Pair[String,String]],String,String).mjava","sourceNew":"  @SuppressWarnings({\"rawtypes\"})\n  private TupleStream handleGroupByFacet(String zkHost,\n                                         String collection,\n                                         final List<Map.Entry<String, Class>> fields,\n                                         final String query,\n                                         final List<Pair<String, String>> orders,\n                                         final List<String> bucketFields,\n                                         final List<Pair<String, String>> metricPairs,\n                                         final String lim,\n                                         final String havingPredicate) throws IOException {\n\n\n    Map<String, Class> fmap = new HashMap<>();\n    for(Map.Entry<String, Class> f : fields) {\n      fmap.put(f.getKey(), f.getValue());\n    }\n\n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.add(CommonParams.Q, query);\n\n    Bucket[] buckets = buildBuckets(bucketFields, fields);\n    Metric[] metrics = buildMetrics(metricPairs, true).toArray(new Metric[0]);\n    if(metrics.length == 0) {\n      metrics = new Metric[1];\n      metrics[0] = new CountMetric();\n    } else {\n      for(Metric metric : metrics) {\n        Class c = fmap.get(metric.getIdentifier());\n        if(Long.class.equals(c)) {\n          metric.outputLong = true;\n        }\n      }\n    }\n\n    int limit = lim != null ? Integer.parseInt(lim) : 1000;\n\n    FieldComparator[] sorts = null;\n\n    if(orders == null || orders.size() == 0) {\n      sorts = new FieldComparator[buckets.length];\n      for(int i=0; i<sorts.length; i++) {\n        sorts[i] = new FieldComparator(\"index\", ComparatorOrder.ASCENDING);\n      }\n    } else {\n      sorts = getComps(orders);\n    }\n\n    int overfetch = (int)(limit * 1.25);\n\n    TupleStream tupleStream = new FacetStream(zkHost,\n                                              collection,\n                                              solrParams,\n                                              buckets,\n                                              metrics,\n                                              sorts,\n                                              overfetch);\n\n\n\n    StreamFactory factory = new StreamFactory()\n        .withFunctionName(\"search\", CloudSolrStream.class)\n        .withFunctionName(\"parallel\", ParallelStream.class)\n        .withFunctionName(\"rollup\", RollupStream.class)\n        .withFunctionName(\"sum\", SumMetric.class)\n        .withFunctionName(\"min\", MinMetric.class)\n        .withFunctionName(\"max\", MaxMetric.class)\n        .withFunctionName(\"avg\", MeanMetric.class)\n        .withFunctionName(\"count\", CountMetric.class)\n        .withFunctionName(\"and\", AndEvaluator.class)\n        .withFunctionName(\"or\", OrEvaluator.class)\n        .withFunctionName(\"not\", NotEvaluator.class)\n        .withFunctionName(\"eq\", EqualToEvaluator.class)\n        .withFunctionName(\"val\", RawValueEvaluator.class)\n        .withFunctionName(\"gt\", GreaterThanEvaluator.class)\n        .withFunctionName(\"lt\", LessThanEvaluator.class)\n        .withFunctionName(\"lteq\", LessThanEqualToEvaluator.class)\n        .withFunctionName(\"gteq\", GreaterThanEqualToEvaluator.class);\n\n    if(havingPredicate != null) {\n      RecursiveBooleanEvaluator booleanOperation = (RecursiveBooleanEvaluator)factory.constructEvaluator(StreamExpressionParser.parse(havingPredicate));\n      tupleStream = new HavingStream(tupleStream, booleanOperation);\n    }\n\n    if(lim != null)\n    {\n      tupleStream = new LimitStream(tupleStream, limit);\n    }\n\n    return tupleStream;\n  }\n\n","sourceOld":"  private TupleStream handleGroupByFacet(String zkHost,\n                                         String collection,\n                                         final List<Map.Entry<String, Class>> fields,\n                                         final String query,\n                                         final List<Pair<String, String>> orders,\n                                         final List<String> bucketFields,\n                                         final List<Pair<String, String>> metricPairs,\n                                         final String lim,\n                                         final String havingPredicate) throws IOException {\n\n\n    Map<String, Class> fmap = new HashMap();\n    for(Map.Entry<String, Class> f : fields) {\n      fmap.put(f.getKey(), f.getValue());\n    }\n\n    ModifiableSolrParams solrParams = new ModifiableSolrParams();\n    solrParams.add(CommonParams.Q, query);\n\n    Bucket[] buckets = buildBuckets(bucketFields, fields);\n    Metric[] metrics = buildMetrics(metricPairs, true).toArray(new Metric[0]);\n    if(metrics.length == 0) {\n      metrics = new Metric[1];\n      metrics[0] = new CountMetric();\n    } else {\n      for(Metric metric : metrics) {\n        Class c = fmap.get(metric.getIdentifier());\n        if(Long.class.equals(c)) {\n          metric.outputLong = true;\n        }\n      }\n    }\n\n    int limit = lim != null ? Integer.parseInt(lim) : 1000;\n\n    FieldComparator[] sorts = null;\n\n    if(orders == null || orders.size() == 0) {\n      sorts = new FieldComparator[buckets.length];\n      for(int i=0; i<sorts.length; i++) {\n        sorts[i] = new FieldComparator(\"index\", ComparatorOrder.ASCENDING);\n      }\n    } else {\n      sorts = getComps(orders);\n    }\n\n    int overfetch = (int)(limit * 1.25);\n\n    TupleStream tupleStream = new FacetStream(zkHost,\n                                              collection,\n                                              solrParams,\n                                              buckets,\n                                              metrics,\n                                              sorts,\n                                              overfetch);\n\n\n\n    StreamFactory factory = new StreamFactory()\n        .withFunctionName(\"search\", CloudSolrStream.class)\n        .withFunctionName(\"parallel\", ParallelStream.class)\n        .withFunctionName(\"rollup\", RollupStream.class)\n        .withFunctionName(\"sum\", SumMetric.class)\n        .withFunctionName(\"min\", MinMetric.class)\n        .withFunctionName(\"max\", MaxMetric.class)\n        .withFunctionName(\"avg\", MeanMetric.class)\n        .withFunctionName(\"count\", CountMetric.class)\n        .withFunctionName(\"and\", AndEvaluator.class)\n        .withFunctionName(\"or\", OrEvaluator.class)\n        .withFunctionName(\"not\", NotEvaluator.class)\n        .withFunctionName(\"eq\", EqualToEvaluator.class)\n        .withFunctionName(\"val\", RawValueEvaluator.class)\n        .withFunctionName(\"gt\", GreaterThanEvaluator.class)\n        .withFunctionName(\"lt\", LessThanEvaluator.class)\n        .withFunctionName(\"lteq\", LessThanEqualToEvaluator.class)\n        .withFunctionName(\"gteq\", GreaterThanEqualToEvaluator.class);\n\n    if(havingPredicate != null) {\n      RecursiveBooleanEvaluator booleanOperation = (RecursiveBooleanEvaluator)factory.constructEvaluator(StreamExpressionParser.parse(havingPredicate));\n      tupleStream = new HavingStream(tupleStream, booleanOperation);\n    }\n\n    if(lim != null)\n    {\n      tupleStream = new LimitStream(tupleStream, limit);\n    }\n\n    return tupleStream;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a9b741b54c163686a5fd077895a797daa9b0b95f":["f48c9aed8d697923300603241ba117b0c19bf774"],"116fdd6b9e04e18a6547a5650bc0afd3fda020aa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3f20deebda1cf327549c84cb60464135abd31c71"],"d5cb41f0427fb7a75b0bfefe992561738c11fd80":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":["a9b741b54c163686a5fd077895a797daa9b0b95f","45c28dbb559366e1f4ef8077346552bfb3f7ecf6"],"d9fe3175bbaa122d67f736a75c2984617c502cc0":["f48c9aed8d697923300603241ba117b0c19bf774"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"45c28dbb559366e1f4ef8077346552bfb3f7ecf6":["d9fe3175bbaa122d67f736a75c2984617c502cc0","ba1e7de64990e3928b90142a52fb92eeff556475"],"ba1e7de64990e3928b90142a52fb92eeff556475":["d9fe3175bbaa122d67f736a75c2984617c502cc0"],"3f20deebda1cf327549c84cb60464135abd31c71":["d5cb41f0427fb7a75b0bfefe992561738c11fd80"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8582f07e9350eaeb33bf6c4617b8c9895d99c839"],"8582f07e9350eaeb33bf6c4617b8c9895d99c839":["45c28dbb559366e1f4ef8077346552bfb3f7ecf6"],"f48c9aed8d697923300603241ba117b0c19bf774":["116fdd6b9e04e18a6547a5650bc0afd3fda020aa"]},"commit2Childs":{"a9b741b54c163686a5fd077895a797daa9b0b95f":["3a7809d1d753b67f48b1a706e17034bf8b624ea3"],"116fdd6b9e04e18a6547a5650bc0afd3fda020aa":["f48c9aed8d697923300603241ba117b0c19bf774"],"d5cb41f0427fb7a75b0bfefe992561738c11fd80":["3f20deebda1cf327549c84cb60464135abd31c71"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":[],"d9fe3175bbaa122d67f736a75c2984617c502cc0":["45c28dbb559366e1f4ef8077346552bfb3f7ecf6","ba1e7de64990e3928b90142a52fb92eeff556475"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["116fdd6b9e04e18a6547a5650bc0afd3fda020aa","d5cb41f0427fb7a75b0bfefe992561738c11fd80"],"45c28dbb559366e1f4ef8077346552bfb3f7ecf6":["3a7809d1d753b67f48b1a706e17034bf8b624ea3","8582f07e9350eaeb33bf6c4617b8c9895d99c839"],"ba1e7de64990e3928b90142a52fb92eeff556475":["45c28dbb559366e1f4ef8077346552bfb3f7ecf6"],"3f20deebda1cf327549c84cb60464135abd31c71":["116fdd6b9e04e18a6547a5650bc0afd3fda020aa"],"f48c9aed8d697923300603241ba117b0c19bf774":["a9b741b54c163686a5fd077895a797daa9b0b95f","d9fe3175bbaa122d67f736a75c2984617c502cc0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"8582f07e9350eaeb33bf6c4617b8c9895d99c839":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["3a7809d1d753b67f48b1a706e17034bf8b624ea3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}