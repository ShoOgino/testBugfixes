{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],double).mjava","commits":[{"id":"99b0a9e4d18bb364d2546e5230cc61abcd2d366b","date":1461241852,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],double).mjava","pathOld":"/dev/null","sourceNew":"  /** Create a GeoPolygon using the specified points and holes, using order to determine \n   * siding of the polygon.  Much like ESRI, this method uses clockwise to indicate the space\n   * on the same side of the shape as being inside, and counter-clockwise to indicate the\n   * space on the opposite side as being inside.\n   * @param pointList is a list of the GeoPoints to build an arbitrary polygon out of.  If points go\n   *  clockwise from a given pole, then that pole should be within the polygon.  If points go\n   *  counter-clockwise, then that pole should be outside the polygon.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Null == none.\n   * @param leniencyValue is the maximum distance (in units) that a point can be from the plane and still be considered as\n   *  belonging to the plane.  Any value greater than zero may cause some of the provided points that are in fact outside\n   *  the strict definition of co-planarity, but are within this distance, to be discarded for the purposes of creating a\n   *  \"safe\" polygon.\n   * @return a GeoPolygon corresponding to what was specified, or null if a valid polygon cannot be generated\n   *  from this input.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> pointList,\n    final List<GeoPolygon> holes,\n    final double leniencyValue) {\n    // First, exercise a sanity filter on the provided pointList, and remove identical points, linear points, and backtracks\n    //System.err.println(\" filtering \"+pointList.size()+\" points...\");\n    //final long startTime = System.currentTimeMillis();\n    final List<GeoPoint> filteredPointList = filterPoints(pointList, leniencyValue);\n    //System.err.println(\"  ...done in \"+(System.currentTimeMillis()-startTime)+\"ms (\"+((filteredPointList==null)?\"degenerate\":(filteredPointList.size()+\" points\"))+\")\");\n    if (filteredPointList == null) {\n      return null;\n    }\n    //System.err.println(\"points=\"+pointList);\n    // Create a random number generator.  Effectively this furnishes us with a repeatable sequence\n    // of points to use for poles.\n    final Random generator = new Random(1234);\n    for (int counter = 0; counter < 1000000; counter++) {\n      //counter++;\n      // Pick the next random pole\n      final GeoPoint pole = pickPole(generator, planetModel, filteredPointList);\n      // Is it inside or outside?\n      final Boolean isPoleInside = isInsidePolygon(pole, filteredPointList);\n      if (isPoleInside != null) {\n        // Legal pole\n        //System.out.println(\"Took \"+counter+\" iterations to find pole\");\n        //System.out.println(\"Pole = \"+pole+\"; isInside=\"+isPoleInside+\"; pointList = \"+pointList);\n        return generateGeoPolygon(planetModel, filteredPointList, holes, pole, isPoleInside);\n      }\n      // If pole choice was illegal, try another one\n    }\n    throw new IllegalArgumentException(\"cannot find a point that is inside the polygon \"+filteredPointList);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["ba81c43c13d92ea74a6388471cf358eb7068744d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba81c43c13d92ea74a6388471cf358eb7068744d","date":1461408282,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],double).mjava","sourceNew":"  /** Create a GeoPolygon using the specified points and holes, using order to determine \n   * siding of the polygon.  Much like ESRI, this method uses clockwise to indicate the space\n   * on the same side of the shape as being inside, and counter-clockwise to indicate the\n   * space on the opposite side as being inside.\n   * @param pointList is a list of the GeoPoints to build an arbitrary polygon out of.  If points go\n   *  clockwise from a given pole, then that pole should be within the polygon.  If points go\n   *  counter-clockwise, then that pole should be outside the polygon.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Holes describe the area outside\n   *  each hole as being \"in set\".  Null == none.\n   * @param leniencyValue is the maximum distance (in units) that a point can be from the plane and still be considered as\n   *  belonging to the plane.  Any value greater than zero may cause some of the provided points that are in fact outside\n   *  the strict definition of co-planarity, but are within this distance, to be discarded for the purposes of creating a\n   *  \"safe\" polygon.\n   * @return a GeoPolygon corresponding to what was specified, or null if a valid polygon cannot be generated\n   *  from this input.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> pointList,\n    final List<GeoPolygon> holes,\n    final double leniencyValue) {\n    // First, exercise a sanity filter on the provided pointList, and remove identical points, linear points, and backtracks\n    //System.err.println(\" filtering \"+pointList.size()+\" points...\");\n    //final long startTime = System.currentTimeMillis();\n    final List<GeoPoint> filteredPointList = filterPoints(pointList, leniencyValue);\n    //System.err.println(\"  ...done in \"+(System.currentTimeMillis()-startTime)+\"ms (\"+((filteredPointList==null)?\"degenerate\":(filteredPointList.size()+\" points\"))+\")\");\n    if (filteredPointList == null) {\n      return null;\n    }\n    //System.err.println(\"points=\"+pointList);\n    // Create a random number generator.  Effectively this furnishes us with a repeatable sequence\n    // of points to use for poles.\n    final Random generator = new Random(1234);\n    for (int counter = 0; counter < 1000000; counter++) {\n      //counter++;\n      // Pick the next random pole\n      final GeoPoint pole = pickPole(generator, planetModel, filteredPointList);\n      // Is it inside or outside?\n      final Boolean isPoleInside = isInsidePolygon(pole, filteredPointList);\n      if (isPoleInside != null) {\n        // Legal pole\n        //System.out.println(\"Took \"+counter+\" iterations to find pole\");\n        //System.out.println(\"Pole = \"+pole+\"; isInside=\"+isPoleInside+\"; pointList = \"+pointList);\n        return generateGeoPolygon(planetModel, filteredPointList, holes, pole, isPoleInside);\n      }\n      // If pole choice was illegal, try another one\n    }\n    throw new IllegalArgumentException(\"cannot find a point that is inside the polygon \"+filteredPointList);\n  }\n\n","sourceOld":"  /** Create a GeoPolygon using the specified points and holes, using order to determine \n   * siding of the polygon.  Much like ESRI, this method uses clockwise to indicate the space\n   * on the same side of the shape as being inside, and counter-clockwise to indicate the\n   * space on the opposite side as being inside.\n   * @param pointList is a list of the GeoPoints to build an arbitrary polygon out of.  If points go\n   *  clockwise from a given pole, then that pole should be within the polygon.  If points go\n   *  counter-clockwise, then that pole should be outside the polygon.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Null == none.\n   * @param leniencyValue is the maximum distance (in units) that a point can be from the plane and still be considered as\n   *  belonging to the plane.  Any value greater than zero may cause some of the provided points that are in fact outside\n   *  the strict definition of co-planarity, but are within this distance, to be discarded for the purposes of creating a\n   *  \"safe\" polygon.\n   * @return a GeoPolygon corresponding to what was specified, or null if a valid polygon cannot be generated\n   *  from this input.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> pointList,\n    final List<GeoPolygon> holes,\n    final double leniencyValue) {\n    // First, exercise a sanity filter on the provided pointList, and remove identical points, linear points, and backtracks\n    //System.err.println(\" filtering \"+pointList.size()+\" points...\");\n    //final long startTime = System.currentTimeMillis();\n    final List<GeoPoint> filteredPointList = filterPoints(pointList, leniencyValue);\n    //System.err.println(\"  ...done in \"+(System.currentTimeMillis()-startTime)+\"ms (\"+((filteredPointList==null)?\"degenerate\":(filteredPointList.size()+\" points\"))+\")\");\n    if (filteredPointList == null) {\n      return null;\n    }\n    //System.err.println(\"points=\"+pointList);\n    // Create a random number generator.  Effectively this furnishes us with a repeatable sequence\n    // of points to use for poles.\n    final Random generator = new Random(1234);\n    for (int counter = 0; counter < 1000000; counter++) {\n      //counter++;\n      // Pick the next random pole\n      final GeoPoint pole = pickPole(generator, planetModel, filteredPointList);\n      // Is it inside or outside?\n      final Boolean isPoleInside = isInsidePolygon(pole, filteredPointList);\n      if (isPoleInside != null) {\n        // Legal pole\n        //System.out.println(\"Took \"+counter+\" iterations to find pole\");\n        //System.out.println(\"Pole = \"+pole+\"; isInside=\"+isPoleInside+\"; pointList = \"+pointList);\n        return generateGeoPolygon(planetModel, filteredPointList, holes, pole, isPoleInside);\n      }\n      // If pole choice was illegal, try another one\n    }\n    throw new IllegalArgumentException(\"cannot find a point that is inside the polygon \"+filteredPointList);\n  }\n\n","bugFix":["99b0a9e4d18bb364d2546e5230cc61abcd2d366b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba1a26cce088d68dd4a3c599994fbc52c06e37b4","date":1461672182,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],double).mjava","sourceNew":"  /** Create a GeoPolygon using the specified points and holes, using order to determine \n   * siding of the polygon.  Much like ESRI, this method uses clockwise to indicate the space\n   * on the same side of the shape as being inside, and counter-clockwise to indicate the\n   * space on the opposite side as being inside.\n   * @param pointList is a list of the GeoPoints to build an arbitrary polygon out of.  If points go\n   *  clockwise from a given pole, then that pole should be within the polygon.  If points go\n   *  counter-clockwise, then that pole should be outside the polygon.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Null == none.\n   * @param leniencyValue is the maximum distance (in units) that a point can be from the plane and still be considered as\n   *  belonging to the plane.  Any value greater than zero may cause some of the provided points that are in fact outside\n   *  the strict definition of co-planarity, but are within this distance, to be discarded for the purposes of creating a\n   *  \"safe\" polygon.\n   * @return a GeoPolygon corresponding to what was specified, or null if a valid polygon cannot be generated\n   *  from this input.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> pointList,\n    final List<GeoPolygon> holes,\n    final double leniencyValue) {\n    // First, exercise a sanity filter on the provided pointList, and remove identical points, linear points, and backtracks\n    //System.err.println(\" filtering \"+pointList.size()+\" points...\");\n    //final long startTime = System.currentTimeMillis();\n    final List<GeoPoint> filteredPointList = filterEdges(filterPoints(pointList), leniencyValue);\n    //System.err.println(\"  ...done in \"+(System.currentTimeMillis()-startTime)+\"ms (\"+((filteredPointList==null)?\"degenerate\":(filteredPointList.size()+\" points\"))+\")\");\n    if (filteredPointList == null) {\n      return null;\n    }\n    //System.err.println(\"points=\"+pointList);\n    // Create a random number generator.  Effectively this furnishes us with a repeatable sequence\n    // of points to use for poles.\n    final Random generator = new Random(1234);\n    for (int counter = 0; counter < 1000000; counter++) {\n      //counter++;\n      // Pick the next random pole\n      final GeoPoint pole = pickPole(generator, planetModel, filteredPointList);\n      // Is it inside or outside?\n      final Boolean isPoleInside = isInsidePolygon(pole, filteredPointList);\n      if (isPoleInside != null) {\n        // Legal pole\n        //System.out.println(\"Took \"+counter+\" iterations to find pole\");\n        //System.out.println(\"Pole = \"+pole+\"; isInside=\"+isPoleInside+\"; pointList = \"+pointList);\n        return generateGeoPolygon(planetModel, filteredPointList, holes, pole, isPoleInside);\n      }\n      // If pole choice was illegal, try another one\n    }\n    throw new IllegalArgumentException(\"cannot find a point that is inside the polygon \"+filteredPointList);\n  }\n\n","sourceOld":"  /** Create a GeoPolygon using the specified points and holes, using order to determine \n   * siding of the polygon.  Much like ESRI, this method uses clockwise to indicate the space\n   * on the same side of the shape as being inside, and counter-clockwise to indicate the\n   * space on the opposite side as being inside.\n   * @param pointList is a list of the GeoPoints to build an arbitrary polygon out of.  If points go\n   *  clockwise from a given pole, then that pole should be within the polygon.  If points go\n   *  counter-clockwise, then that pole should be outside the polygon.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Null == none.\n   * @param leniencyValue is the maximum distance (in units) that a point can be from the plane and still be considered as\n   *  belonging to the plane.  Any value greater than zero may cause some of the provided points that are in fact outside\n   *  the strict definition of co-planarity, but are within this distance, to be discarded for the purposes of creating a\n   *  \"safe\" polygon.\n   * @return a GeoPolygon corresponding to what was specified, or null if a valid polygon cannot be generated\n   *  from this input.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> pointList,\n    final List<GeoPolygon> holes,\n    final double leniencyValue) {\n    // First, exercise a sanity filter on the provided pointList, and remove identical points, linear points, and backtracks\n    //System.err.println(\" filtering \"+pointList.size()+\" points...\");\n    //final long startTime = System.currentTimeMillis();\n    final List<GeoPoint> filteredPointList = filterPoints(pointList, leniencyValue);\n    //System.err.println(\"  ...done in \"+(System.currentTimeMillis()-startTime)+\"ms (\"+((filteredPointList==null)?\"degenerate\":(filteredPointList.size()+\" points\"))+\")\");\n    if (filteredPointList == null) {\n      return null;\n    }\n    //System.err.println(\"points=\"+pointList);\n    // Create a random number generator.  Effectively this furnishes us with a repeatable sequence\n    // of points to use for poles.\n    final Random generator = new Random(1234);\n    for (int counter = 0; counter < 1000000; counter++) {\n      //counter++;\n      // Pick the next random pole\n      final GeoPoint pole = pickPole(generator, planetModel, filteredPointList);\n      // Is it inside or outside?\n      final Boolean isPoleInside = isInsidePolygon(pole, filteredPointList);\n      if (isPoleInside != null) {\n        // Legal pole\n        //System.out.println(\"Took \"+counter+\" iterations to find pole\");\n        //System.out.println(\"Pole = \"+pole+\"; isInside=\"+isPoleInside+\"; pointList = \"+pointList);\n        return generateGeoPolygon(planetModel, filteredPointList, holes, pole, isPoleInside);\n      }\n      // If pole choice was illegal, try another one\n    }\n    throw new IllegalArgumentException(\"cannot find a point that is inside the polygon \"+filteredPointList);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f7f901826e47f75f810d7aae24b0455d21ea1fe2","date":1461678892,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],double).mjava","sourceNew":"  /** Create a GeoPolygon using the specified points and holes, using order to determine \n   * siding of the polygon.  Much like ESRI, this method uses clockwise to indicate the space\n   * on the same side of the shape as being inside, and counter-clockwise to indicate the\n   * space on the opposite side as being inside.\n   * @param pointList is a list of the GeoPoints to build an arbitrary polygon out of.  If points go\n   *  clockwise from a given pole, then that pole should be within the polygon.  If points go\n   *  counter-clockwise, then that pole should be outside the polygon.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Holes describe the area outside\n   *  each hole as being \"in set\".  Null == none.\n   * @param leniencyValue is the maximum distance (in units) that a point can be from the plane and still be considered as\n   *  belonging to the plane.  Any value greater than zero may cause some of the provided points that are in fact outside\n   *  the strict definition of co-planarity, but are within this distance, to be discarded for the purposes of creating a\n   *  \"safe\" polygon.\n   * @return a GeoPolygon corresponding to what was specified, or null if a valid polygon cannot be generated\n   *  from this input.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> pointList,\n    final List<GeoPolygon> holes,\n    final double leniencyValue) {\n    // First, exercise a sanity filter on the provided pointList, and remove identical points, linear points, and backtracks\n    //System.err.println(\" filtering \"+pointList.size()+\" points...\");\n    //final long startTime = System.currentTimeMillis();\n    final List<GeoPoint> filteredPointList = filterPoints(pointList, leniencyValue);\n    //System.err.println(\"  ...done in \"+(System.currentTimeMillis()-startTime)+\"ms (\"+((filteredPointList==null)?\"degenerate\":(filteredPointList.size()+\" points\"))+\")\");\n    if (filteredPointList == null) {\n      return null;\n    }\n    //System.err.println(\"points=\"+pointList);\n    // Create a random number generator.  Effectively this furnishes us with a repeatable sequence\n    // of points to use for poles.\n    final Random generator = new Random(1234);\n    for (int counter = 0; counter < 1000000; counter++) {\n      //counter++;\n      // Pick the next random pole\n      final GeoPoint pole = pickPole(generator, planetModel, filteredPointList);\n      // Is it inside or outside?\n      final Boolean isPoleInside = isInsidePolygon(pole, filteredPointList);\n      if (isPoleInside != null) {\n        // Legal pole\n        //System.out.println(\"Took \"+counter+\" iterations to find pole\");\n        //System.out.println(\"Pole = \"+pole+\"; isInside=\"+isPoleInside+\"; pointList = \"+pointList);\n        return generateGeoPolygon(planetModel, filteredPointList, holes, pole, isPoleInside);\n      }\n      // If pole choice was illegal, try another one\n    }\n    throw new IllegalArgumentException(\"cannot find a point that is inside the polygon \"+filteredPointList);\n  }\n\n","sourceOld":"  /** Create a GeoPolygon using the specified points and holes, using order to determine \n   * siding of the polygon.  Much like ESRI, this method uses clockwise to indicate the space\n   * on the same side of the shape as being inside, and counter-clockwise to indicate the\n   * space on the opposite side as being inside.\n   * @param pointList is a list of the GeoPoints to build an arbitrary polygon out of.  If points go\n   *  clockwise from a given pole, then that pole should be within the polygon.  If points go\n   *  counter-clockwise, then that pole should be outside the polygon.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Null == none.\n   * @param leniencyValue is the maximum distance (in units) that a point can be from the plane and still be considered as\n   *  belonging to the plane.  Any value greater than zero may cause some of the provided points that are in fact outside\n   *  the strict definition of co-planarity, but are within this distance, to be discarded for the purposes of creating a\n   *  \"safe\" polygon.\n   * @return a GeoPolygon corresponding to what was specified, or null if a valid polygon cannot be generated\n   *  from this input.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> pointList,\n    final List<GeoPolygon> holes,\n    final double leniencyValue) {\n    // First, exercise a sanity filter on the provided pointList, and remove identical points, linear points, and backtracks\n    //System.err.println(\" filtering \"+pointList.size()+\" points...\");\n    //final long startTime = System.currentTimeMillis();\n    final List<GeoPoint> filteredPointList = filterPoints(pointList, leniencyValue);\n    //System.err.println(\"  ...done in \"+(System.currentTimeMillis()-startTime)+\"ms (\"+((filteredPointList==null)?\"degenerate\":(filteredPointList.size()+\" points\"))+\")\");\n    if (filteredPointList == null) {\n      return null;\n    }\n    //System.err.println(\"points=\"+pointList);\n    // Create a random number generator.  Effectively this furnishes us with a repeatable sequence\n    // of points to use for poles.\n    final Random generator = new Random(1234);\n    for (int counter = 0; counter < 1000000; counter++) {\n      //counter++;\n      // Pick the next random pole\n      final GeoPoint pole = pickPole(generator, planetModel, filteredPointList);\n      // Is it inside or outside?\n      final Boolean isPoleInside = isInsidePolygon(pole, filteredPointList);\n      if (isPoleInside != null) {\n        // Legal pole\n        //System.out.println(\"Took \"+counter+\" iterations to find pole\");\n        //System.out.println(\"Pole = \"+pole+\"; isInside=\"+isPoleInside+\"; pointList = \"+pointList);\n        return generateGeoPolygon(planetModel, filteredPointList, holes, pole, isPoleInside);\n      }\n      // If pole choice was illegal, try another one\n    }\n    throw new IllegalArgumentException(\"cannot find a point that is inside the polygon \"+filteredPointList);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f57114b5ef2859c0e501343c6e66f3c769d096a8","date":1461886056,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],double).mjava","sourceNew":"  /** Create a GeoPolygon using the specified points and holes, using order to determine \n   * siding of the polygon.  Much like ESRI, this method uses clockwise to indicate the space\n   * on the same side of the shape as being inside, and counter-clockwise to indicate the\n   * space on the opposite side as being inside.\n   * @param pointList is a list of the GeoPoints to build an arbitrary polygon out of.  If points go\n   *  clockwise from a given pole, then that pole should be within the polygon.  If points go\n   *  counter-clockwise, then that pole should be outside the polygon.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Null == none.\n   * @param leniencyValue is the maximum distance (in units) that a point can be from the plane and still be considered as\n   *  belonging to the plane.  Any value greater than zero may cause some of the provided points that are in fact outside\n   *  the strict definition of co-planarity, but are within this distance, to be discarded for the purposes of creating a\n   *  \"safe\" polygon.\n   * @return a GeoPolygon corresponding to what was specified, or null if a valid polygon cannot be generated\n   *  from this input.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> pointList,\n    final List<GeoPolygon> holes,\n    final double leniencyValue) {\n    // First, exercise a sanity filter on the provided pointList, and remove identical points, linear points, and backtracks\n    //System.err.println(\" filtering \"+pointList.size()+\" points...\");\n    //final long startTime = System.currentTimeMillis();\n    final List<GeoPoint> firstFilteredPointList = filterPoints(pointList);\n    if (firstFilteredPointList == null) {\n      return null;\n    }\n    final List<GeoPoint> filteredPointList = filterEdges(firstFilteredPointList, leniencyValue);\n    //System.err.println(\"  ...done in \"+(System.currentTimeMillis()-startTime)+\"ms (\"+((filteredPointList==null)?\"degenerate\":(filteredPointList.size()+\" points\"))+\")\");\n    if (filteredPointList == null) {\n      return null;\n    }\n    //System.err.println(\"points=\"+pointList);\n    // Create a random number generator.  Effectively this furnishes us with a repeatable sequence\n    // of points to use for poles.\n    final Random generator = new Random(1234);\n    for (int counter = 0; counter < 1000000; counter++) {\n      //counter++;\n      // Pick the next random pole\n      final GeoPoint pole = pickPole(generator, planetModel, filteredPointList);\n      // Is it inside or outside?\n      final Boolean isPoleInside = isInsidePolygon(pole, filteredPointList);\n      if (isPoleInside != null) {\n        // Legal pole\n        //System.out.println(\"Took \"+counter+\" iterations to find pole\");\n        //System.out.println(\"Pole = \"+pole+\"; isInside=\"+isPoleInside+\"; pointList = \"+pointList);\n        return generateGeoPolygon(planetModel, filteredPointList, holes, pole, isPoleInside);\n      }\n      // If pole choice was illegal, try another one\n    }\n    throw new IllegalArgumentException(\"cannot find a point that is inside the polygon \"+filteredPointList);\n  }\n\n","sourceOld":"  /** Create a GeoPolygon using the specified points and holes, using order to determine \n   * siding of the polygon.  Much like ESRI, this method uses clockwise to indicate the space\n   * on the same side of the shape as being inside, and counter-clockwise to indicate the\n   * space on the opposite side as being inside.\n   * @param pointList is a list of the GeoPoints to build an arbitrary polygon out of.  If points go\n   *  clockwise from a given pole, then that pole should be within the polygon.  If points go\n   *  counter-clockwise, then that pole should be outside the polygon.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Null == none.\n   * @param leniencyValue is the maximum distance (in units) that a point can be from the plane and still be considered as\n   *  belonging to the plane.  Any value greater than zero may cause some of the provided points that are in fact outside\n   *  the strict definition of co-planarity, but are within this distance, to be discarded for the purposes of creating a\n   *  \"safe\" polygon.\n   * @return a GeoPolygon corresponding to what was specified, or null if a valid polygon cannot be generated\n   *  from this input.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> pointList,\n    final List<GeoPolygon> holes,\n    final double leniencyValue) {\n    // First, exercise a sanity filter on the provided pointList, and remove identical points, linear points, and backtracks\n    //System.err.println(\" filtering \"+pointList.size()+\" points...\");\n    //final long startTime = System.currentTimeMillis();\n    final List<GeoPoint> filteredPointList = filterEdges(filterPoints(pointList), leniencyValue);\n    //System.err.println(\"  ...done in \"+(System.currentTimeMillis()-startTime)+\"ms (\"+((filteredPointList==null)?\"degenerate\":(filteredPointList.size()+\" points\"))+\")\");\n    if (filteredPointList == null) {\n      return null;\n    }\n    //System.err.println(\"points=\"+pointList);\n    // Create a random number generator.  Effectively this furnishes us with a repeatable sequence\n    // of points to use for poles.\n    final Random generator = new Random(1234);\n    for (int counter = 0; counter < 1000000; counter++) {\n      //counter++;\n      // Pick the next random pole\n      final GeoPoint pole = pickPole(generator, planetModel, filteredPointList);\n      // Is it inside or outside?\n      final Boolean isPoleInside = isInsidePolygon(pole, filteredPointList);\n      if (isPoleInside != null) {\n        // Legal pole\n        //System.out.println(\"Took \"+counter+\" iterations to find pole\");\n        //System.out.println(\"Pole = \"+pole+\"; isInside=\"+isPoleInside+\"; pointList = \"+pointList);\n        return generateGeoPolygon(planetModel, filteredPointList, holes, pole, isPoleInside);\n      }\n      // If pole choice was illegal, try another one\n    }\n    throw new IllegalArgumentException(\"cannot find a point that is inside the polygon \"+filteredPointList);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0","date":1461888019,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],double).mjava","sourceNew":"  /** Create a GeoPolygon using the specified points and holes, using order to determine \n   * siding of the polygon.  Much like ESRI, this method uses clockwise to indicate the space\n   * on the same side of the shape as being inside, and counter-clockwise to indicate the\n   * space on the opposite side as being inside.\n   * @param pointList is a list of the GeoPoints to build an arbitrary polygon out of.  If points go\n   *  clockwise from a given pole, then that pole should be within the polygon.  If points go\n   *  counter-clockwise, then that pole should be outside the polygon.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Holes describe the area outside\n   *  each hole as being \"in set\".  Null == none.\n   * @param leniencyValue is the maximum distance (in units) that a point can be from the plane and still be considered as\n   *  belonging to the plane.  Any value greater than zero may cause some of the provided points that are in fact outside\n   *  the strict definition of co-planarity, but are within this distance, to be discarded for the purposes of creating a\n   *  \"safe\" polygon.\n   * @return a GeoPolygon corresponding to what was specified, or null if a valid polygon cannot be generated\n   *  from this input.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> pointList,\n    final List<GeoPolygon> holes,\n    final double leniencyValue) {\n    // First, exercise a sanity filter on the provided pointList, and remove identical points, linear points, and backtracks\n    //System.err.println(\" filtering \"+pointList.size()+\" points...\");\n    //final long startTime = System.currentTimeMillis();\n    final List<GeoPoint> firstFilteredPointList = filterPoints(pointList);\n    if (firstFilteredPointList == null) {\n      return null;\n    }\n    final List<GeoPoint> filteredPointList = filterEdges(firstFilteredPointList, leniencyValue);\n    //System.err.println(\"  ...done in \"+(System.currentTimeMillis()-startTime)+\"ms (\"+((filteredPointList==null)?\"degenerate\":(filteredPointList.size()+\" points\"))+\")\");\n    if (filteredPointList == null) {\n      return null;\n    }\n    //System.err.println(\"points=\"+pointList);\n    // Create a random number generator.  Effectively this furnishes us with a repeatable sequence\n    // of points to use for poles.\n    final Random generator = new Random(1234);\n    for (int counter = 0; counter < 1000000; counter++) {\n      //counter++;\n      // Pick the next random pole\n      final GeoPoint pole = pickPole(generator, planetModel, filteredPointList);\n      // Is it inside or outside?\n      final Boolean isPoleInside = isInsidePolygon(pole, filteredPointList);\n      if (isPoleInside != null) {\n        // Legal pole\n        //System.out.println(\"Took \"+counter+\" iterations to find pole\");\n        //System.out.println(\"Pole = \"+pole+\"; isInside=\"+isPoleInside+\"; pointList = \"+pointList);\n        return generateGeoPolygon(planetModel, filteredPointList, holes, pole, isPoleInside);\n      }\n      // If pole choice was illegal, try another one\n    }\n    throw new IllegalArgumentException(\"cannot find a point that is inside the polygon \"+filteredPointList);\n  }\n\n","sourceOld":"  /** Create a GeoPolygon using the specified points and holes, using order to determine \n   * siding of the polygon.  Much like ESRI, this method uses clockwise to indicate the space\n   * on the same side of the shape as being inside, and counter-clockwise to indicate the\n   * space on the opposite side as being inside.\n   * @param pointList is a list of the GeoPoints to build an arbitrary polygon out of.  If points go\n   *  clockwise from a given pole, then that pole should be within the polygon.  If points go\n   *  counter-clockwise, then that pole should be outside the polygon.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Holes describe the area outside\n   *  each hole as being \"in set\".  Null == none.\n   * @param leniencyValue is the maximum distance (in units) that a point can be from the plane and still be considered as\n   *  belonging to the plane.  Any value greater than zero may cause some of the provided points that are in fact outside\n   *  the strict definition of co-planarity, but are within this distance, to be discarded for the purposes of creating a\n   *  \"safe\" polygon.\n   * @return a GeoPolygon corresponding to what was specified, or null if a valid polygon cannot be generated\n   *  from this input.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> pointList,\n    final List<GeoPolygon> holes,\n    final double leniencyValue) {\n    // First, exercise a sanity filter on the provided pointList, and remove identical points, linear points, and backtracks\n    //System.err.println(\" filtering \"+pointList.size()+\" points...\");\n    //final long startTime = System.currentTimeMillis();\n    final List<GeoPoint> filteredPointList = filterPoints(pointList, leniencyValue);\n    //System.err.println(\"  ...done in \"+(System.currentTimeMillis()-startTime)+\"ms (\"+((filteredPointList==null)?\"degenerate\":(filteredPointList.size()+\" points\"))+\")\");\n    if (filteredPointList == null) {\n      return null;\n    }\n    //System.err.println(\"points=\"+pointList);\n    // Create a random number generator.  Effectively this furnishes us with a repeatable sequence\n    // of points to use for poles.\n    final Random generator = new Random(1234);\n    for (int counter = 0; counter < 1000000; counter++) {\n      //counter++;\n      // Pick the next random pole\n      final GeoPoint pole = pickPole(generator, planetModel, filteredPointList);\n      // Is it inside or outside?\n      final Boolean isPoleInside = isInsidePolygon(pole, filteredPointList);\n      if (isPoleInside != null) {\n        // Legal pole\n        //System.out.println(\"Took \"+counter+\" iterations to find pole\");\n        //System.out.println(\"Pole = \"+pole+\"; isInside=\"+isPoleInside+\"; pointList = \"+pointList);\n        return generateGeoPolygon(planetModel, filteredPointList, holes, pole, isPoleInside);\n      }\n      // If pole choice was illegal, try another one\n    }\n    throw new IllegalArgumentException(\"cannot find a point that is inside the polygon \"+filteredPointList);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55b50463286869f584cf849d1587a0fcd54d1dfa","date":1462378517,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],double).mjava","sourceNew":"  /** Create a GeoPolygon using the specified points and holes, using order to determine \n   * siding of the polygon.  Much like ESRI, this method uses clockwise to indicate the space\n   * on the same side of the shape as being inside, and counter-clockwise to indicate the\n   * space on the opposite side as being inside.\n   * @param pointList is a list of the GeoPoints to build an arbitrary polygon out of.  If points go\n   *  clockwise from a given pole, then that pole should be within the polygon.  If points go\n   *  counter-clockwise, then that pole should be outside the polygon.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Holes describe the area outside\n   *  each hole as being \"in set\".  Null == none.\n   * @param leniencyValue is the maximum distance (in units) that a point can be from the plane and still be considered as\n   *  belonging to the plane.  Any value greater than zero may cause some of the provided points that are in fact outside\n   *  the strict definition of co-planarity, but are within this distance, to be discarded for the purposes of creating a\n   *  \"safe\" polygon.\n   * @return a GeoPolygon corresponding to what was specified, or null if a valid polygon cannot be generated\n   *  from this input.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> pointList,\n    final List<GeoPolygon> holes,\n    final double leniencyValue) {\n    // First, exercise a sanity filter on the provided pointList, and remove identical points, linear points, and backtracks\n    //System.err.println(\" filtering \"+pointList.size()+\" points...\");\n    //final long startTime = System.currentTimeMillis();\n    final List<GeoPoint> firstFilteredPointList = filterPoints(pointList);\n    if (firstFilteredPointList == null) {\n      return null;\n    }\n    final List<GeoPoint> filteredPointList = filterEdges(firstFilteredPointList, leniencyValue);\n    //System.err.println(\"  ...done in \"+(System.currentTimeMillis()-startTime)+\"ms (\"+((filteredPointList==null)?\"degenerate\":(filteredPointList.size()+\" points\"))+\")\");\n    if (filteredPointList == null) {\n      return null;\n    }\n    //System.err.println(\"points=\"+pointList);\n    // Create a random number generator.  Effectively this furnishes us with a repeatable sequence\n    // of points to use for poles.\n    final Random generator = new Random(1234);\n    for (int counter = 0; counter < 1000000; counter++) {\n      //counter++;\n      // Pick the next random pole\n      final GeoPoint pole = pickPole(generator, planetModel, filteredPointList);\n      // Is it inside or outside?\n      final Boolean isPoleInside = isInsidePolygon(pole, filteredPointList);\n      if (isPoleInside != null) {\n        // Legal pole\n        //System.out.println(\"Took \"+counter+\" iterations to find pole\");\n        //System.out.println(\"Pole = \"+pole+\"; isInside=\"+isPoleInside+\"; pointList = \"+pointList);\n        return generateGeoPolygon(planetModel, filteredPointList, holes, pole, isPoleInside);\n      }\n      // If pole choice was illegal, try another one\n    }\n    throw new IllegalArgumentException(\"cannot find a point that is inside the polygon \"+filteredPointList);\n  }\n\n","sourceOld":"  /** Create a GeoPolygon using the specified points and holes, using order to determine \n   * siding of the polygon.  Much like ESRI, this method uses clockwise to indicate the space\n   * on the same side of the shape as being inside, and counter-clockwise to indicate the\n   * space on the opposite side as being inside.\n   * @param pointList is a list of the GeoPoints to build an arbitrary polygon out of.  If points go\n   *  clockwise from a given pole, then that pole should be within the polygon.  If points go\n   *  counter-clockwise, then that pole should be outside the polygon.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Holes describe the area outside\n   *  each hole as being \"in set\".  Null == none.\n   * @param leniencyValue is the maximum distance (in units) that a point can be from the plane and still be considered as\n   *  belonging to the plane.  Any value greater than zero may cause some of the provided points that are in fact outside\n   *  the strict definition of co-planarity, but are within this distance, to be discarded for the purposes of creating a\n   *  \"safe\" polygon.\n   * @return a GeoPolygon corresponding to what was specified, or null if a valid polygon cannot be generated\n   *  from this input.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> pointList,\n    final List<GeoPolygon> holes,\n    final double leniencyValue) {\n    // First, exercise a sanity filter on the provided pointList, and remove identical points, linear points, and backtracks\n    //System.err.println(\" filtering \"+pointList.size()+\" points...\");\n    //final long startTime = System.currentTimeMillis();\n    final List<GeoPoint> filteredPointList = filterPoints(pointList, leniencyValue);\n    //System.err.println(\"  ...done in \"+(System.currentTimeMillis()-startTime)+\"ms (\"+((filteredPointList==null)?\"degenerate\":(filteredPointList.size()+\" points\"))+\")\");\n    if (filteredPointList == null) {\n      return null;\n    }\n    //System.err.println(\"points=\"+pointList);\n    // Create a random number generator.  Effectively this furnishes us with a repeatable sequence\n    // of points to use for poles.\n    final Random generator = new Random(1234);\n    for (int counter = 0; counter < 1000000; counter++) {\n      //counter++;\n      // Pick the next random pole\n      final GeoPoint pole = pickPole(generator, planetModel, filteredPointList);\n      // Is it inside or outside?\n      final Boolean isPoleInside = isInsidePolygon(pole, filteredPointList);\n      if (isPoleInside != null) {\n        // Legal pole\n        //System.out.println(\"Took \"+counter+\" iterations to find pole\");\n        //System.out.println(\"Pole = \"+pole+\"; isInside=\"+isPoleInside+\"; pointList = \"+pointList);\n        return generateGeoPolygon(planetModel, filteredPointList, holes, pole, isPoleInside);\n      }\n      // If pole choice was illegal, try another one\n    }\n    throw new IllegalArgumentException(\"cannot find a point that is inside the polygon \"+filteredPointList);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a9b3ef6cc46c18893efb19aa54f8bcd3425c9db","date":1516894422,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],double).mjava","sourceNew":"  /** Create a GeoPolygon using the specified points and holes, using order to determine \n   * siding of the polygon.  Much like ESRI, this method uses clockwise to indicate the space\n   * on the same side of the shape as being inside, and counter-clockwise to indicate the\n   * space on the opposite side as being inside.\n   * @param pointList is a list of the GeoPoints to build an arbitrary polygon out of.  If points go\n   *  clockwise from a given pole, then that pole should be within the polygon.  If points go\n   *  counter-clockwise, then that pole should be outside the polygon.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Holes describe the area outside\n   *  each hole as being \"in set\".  Null == none.\n   * @param leniencyValue is the maximum distance (in units) that a point can be from the plane and still be considered as\n   *  belonging to the plane.  Any value greater than zero may cause some of the provided points that are in fact outside\n   *  the strict definition of co-planarity, but are within this distance, to be discarded for the purposes of creating a\n   *  \"safe\" polygon.\n   * @return a GeoPolygon corresponding to what was specified, or null if a valid polygon cannot be generated\n   *  from this input.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> pointList,\n    final List<GeoPolygon> holes,\n    final double leniencyValue) {\n    // First, exercise a sanity filter on the provided pointList, and remove identical points, linear points, and backtracks\n    //System.err.println(\" filtering \"+pointList.size()+\" points...\");\n    //final long startTime = System.currentTimeMillis();\n    final List<GeoPoint> firstFilteredPointList = filterPoints(pointList);\n    if (firstFilteredPointList == null) {\n      return null;\n    }\n    final List<GeoPoint> filteredPointList = filterEdges(firstFilteredPointList, leniencyValue);\n    //System.err.println(\"  ...done in \"+(System.currentTimeMillis()-startTime)+\"ms (\"+((filteredPointList==null)?\"degenerate\":(filteredPointList.size()+\" points\"))+\")\");\n    if (filteredPointList == null) {\n      return null;\n    }\n\n    //First approximation to find a point\n    final GeoPoint centerOfMass = getCenterOfMass(filteredPointList);\n    final Boolean isCenterOfMassInside = isInsidePolygon(centerOfMass, filteredPointList);\n    if (isCenterOfMassInside != null) {\n      return generateGeoPolygon(planetModel, filteredPointList, holes, centerOfMass, isCenterOfMassInside);\n    }\n    \n    //System.err.println(\"points=\"+pointList);\n    // Create a random number generator.  Effectively this furnishes us with a repeatable sequence\n    // of points to use for poles.\n    final Random generator = new Random(1234);\n    for (int counter = 0; counter < 1000000; counter++) {\n      //counter++;\n      // Pick the next random pole\n      final GeoPoint pole = pickPole(generator, planetModel, filteredPointList);\n      // Is it inside or outside?\n      final Boolean isPoleInside = isInsidePolygon(pole, filteredPointList);\n      if (isPoleInside != null) {\n        // Legal pole\n        //System.out.println(\"Took \"+counter+\" iterations to find pole\");\n        //System.out.println(\"Pole = \"+pole+\"; isInside=\"+isPoleInside+\"; pointList = \"+pointList);\n        return generateGeoPolygon(planetModel, filteredPointList, holes, pole, isPoleInside);\n      }\n      // If pole choice was illegal, try another one\n    }\n    throw new IllegalArgumentException(\"cannot find a point that is inside the polygon \"+filteredPointList);\n  }\n\n","sourceOld":"  /** Create a GeoPolygon using the specified points and holes, using order to determine \n   * siding of the polygon.  Much like ESRI, this method uses clockwise to indicate the space\n   * on the same side of the shape as being inside, and counter-clockwise to indicate the\n   * space on the opposite side as being inside.\n   * @param pointList is a list of the GeoPoints to build an arbitrary polygon out of.  If points go\n   *  clockwise from a given pole, then that pole should be within the polygon.  If points go\n   *  counter-clockwise, then that pole should be outside the polygon.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Holes describe the area outside\n   *  each hole as being \"in set\".  Null == none.\n   * @param leniencyValue is the maximum distance (in units) that a point can be from the plane and still be considered as\n   *  belonging to the plane.  Any value greater than zero may cause some of the provided points that are in fact outside\n   *  the strict definition of co-planarity, but are within this distance, to be discarded for the purposes of creating a\n   *  \"safe\" polygon.\n   * @return a GeoPolygon corresponding to what was specified, or null if a valid polygon cannot be generated\n   *  from this input.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> pointList,\n    final List<GeoPolygon> holes,\n    final double leniencyValue) {\n    // First, exercise a sanity filter on the provided pointList, and remove identical points, linear points, and backtracks\n    //System.err.println(\" filtering \"+pointList.size()+\" points...\");\n    //final long startTime = System.currentTimeMillis();\n    final List<GeoPoint> firstFilteredPointList = filterPoints(pointList);\n    if (firstFilteredPointList == null) {\n      return null;\n    }\n    final List<GeoPoint> filteredPointList = filterEdges(firstFilteredPointList, leniencyValue);\n    //System.err.println(\"  ...done in \"+(System.currentTimeMillis()-startTime)+\"ms (\"+((filteredPointList==null)?\"degenerate\":(filteredPointList.size()+\" points\"))+\")\");\n    if (filteredPointList == null) {\n      return null;\n    }\n    //System.err.println(\"points=\"+pointList);\n    // Create a random number generator.  Effectively this furnishes us with a repeatable sequence\n    // of points to use for poles.\n    final Random generator = new Random(1234);\n    for (int counter = 0; counter < 1000000; counter++) {\n      //counter++;\n      // Pick the next random pole\n      final GeoPoint pole = pickPole(generator, planetModel, filteredPointList);\n      // Is it inside or outside?\n      final Boolean isPoleInside = isInsidePolygon(pole, filteredPointList);\n      if (isPoleInside != null) {\n        // Legal pole\n        //System.out.println(\"Took \"+counter+\" iterations to find pole\");\n        //System.out.println(\"Pole = \"+pole+\"; isInside=\"+isPoleInside+\"; pointList = \"+pointList);\n        return generateGeoPolygon(planetModel, filteredPointList, holes, pole, isPoleInside);\n      }\n      // If pole choice was illegal, try another one\n    }\n    throw new IllegalArgumentException(\"cannot find a point that is inside the polygon \"+filteredPointList);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8dc2dbc28de286321b0c897c64f47895835e0df2","date":1521403949,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],double).mjava","sourceNew":"  /** Create a GeoPolygon using the specified points and holes, using order to determine \n   * siding of the polygon.  Much like ESRI, this method uses clockwise to indicate the space\n   * on the same side of the shape as being inside, and counter-clockwise to indicate the\n   * space on the opposite side as being inside.\n   * @param pointList is a list of the GeoPoints to build an arbitrary polygon out of.  If points go\n   *  clockwise from a given pole, then that pole should be within the polygon.  If points go\n   *  counter-clockwise, then that pole should be outside the polygon.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Holes describe the area outside\n   *  each hole as being \"in set\".  Null == none.\n   * @param leniencyValue is the maximum distance (in units) that a point can be from the plane and still be considered as\n   *  belonging to the plane.  Any value greater than zero may cause some of the provided points that are in fact outside\n   *  the strict definition of co-planarity, but are within this distance, to be discarded for the purposes of creating a\n   *  \"safe\" polygon.\n   * @return a GeoPolygon corresponding to what was specified, or null if a valid polygon cannot be generated\n   *  from this input.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> pointList,\n    final List<GeoPolygon> holes,\n    final double leniencyValue) {\n    // First, exercise a sanity filter on the provided pointList, and remove identical points, linear points, and backtracks\n    //System.err.println(\" filtering \"+pointList.size()+\" points...\");\n    //final long startTime = System.currentTimeMillis();\n    final List<GeoPoint> firstFilteredPointList = filterPoints(pointList);\n    if (firstFilteredPointList == null) {\n      return null;\n    }\n    final List<GeoPoint> filteredPointList = filterEdges(firstFilteredPointList, leniencyValue);\n    //System.err.println(\"  ...done in \"+(System.currentTimeMillis()-startTime)+\"ms (\"+((filteredPointList==null)?\"degenerate\":(filteredPointList.size()+\" points\"))+\")\");\n    if (filteredPointList == null) {\n      return null;\n    }\n\n    //First approximation to find a point\n    final GeoPoint centerOfMass = getCenterOfMass(planetModel, filteredPointList);\n    final Boolean isCenterOfMassInside = isInsidePolygon(centerOfMass, filteredPointList);\n    if (isCenterOfMassInside != null) {\n      return generateGeoPolygon(planetModel, filteredPointList, holes, centerOfMass, isCenterOfMassInside);\n    }\n    \n    //System.err.println(\"points=\"+pointList);\n    // Create a random number generator.  Effectively this furnishes us with a repeatable sequence\n    // of points to use for poles.\n    final Random generator = new Random(1234);\n    for (int counter = 0; counter < 1000000; counter++) {\n      //counter++;\n      // Pick the next random pole\n      final GeoPoint pole = pickPole(generator, planetModel, filteredPointList);\n      // Is it inside or outside?\n      final Boolean isPoleInside = isInsidePolygon(pole, filteredPointList);\n      if (isPoleInside != null) {\n        // Legal pole\n        //System.out.println(\"Took \"+counter+\" iterations to find pole\");\n        //System.out.println(\"Pole = \"+pole+\"; isInside=\"+isPoleInside+\"; pointList = \"+pointList);\n        return generateGeoPolygon(planetModel, filteredPointList, holes, pole, isPoleInside);\n      }\n      // If pole choice was illegal, try another one\n    }\n    throw new IllegalArgumentException(\"cannot find a point that is inside the polygon \"+filteredPointList);\n  }\n\n","sourceOld":"  /** Create a GeoPolygon using the specified points and holes, using order to determine \n   * siding of the polygon.  Much like ESRI, this method uses clockwise to indicate the space\n   * on the same side of the shape as being inside, and counter-clockwise to indicate the\n   * space on the opposite side as being inside.\n   * @param pointList is a list of the GeoPoints to build an arbitrary polygon out of.  If points go\n   *  clockwise from a given pole, then that pole should be within the polygon.  If points go\n   *  counter-clockwise, then that pole should be outside the polygon.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Holes describe the area outside\n   *  each hole as being \"in set\".  Null == none.\n   * @param leniencyValue is the maximum distance (in units) that a point can be from the plane and still be considered as\n   *  belonging to the plane.  Any value greater than zero may cause some of the provided points that are in fact outside\n   *  the strict definition of co-planarity, but are within this distance, to be discarded for the purposes of creating a\n   *  \"safe\" polygon.\n   * @return a GeoPolygon corresponding to what was specified, or null if a valid polygon cannot be generated\n   *  from this input.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> pointList,\n    final List<GeoPolygon> holes,\n    final double leniencyValue) {\n    // First, exercise a sanity filter on the provided pointList, and remove identical points, linear points, and backtracks\n    //System.err.println(\" filtering \"+pointList.size()+\" points...\");\n    //final long startTime = System.currentTimeMillis();\n    final List<GeoPoint> firstFilteredPointList = filterPoints(pointList);\n    if (firstFilteredPointList == null) {\n      return null;\n    }\n    final List<GeoPoint> filteredPointList = filterEdges(firstFilteredPointList, leniencyValue);\n    //System.err.println(\"  ...done in \"+(System.currentTimeMillis()-startTime)+\"ms (\"+((filteredPointList==null)?\"degenerate\":(filteredPointList.size()+\" points\"))+\")\");\n    if (filteredPointList == null) {\n      return null;\n    }\n\n    //First approximation to find a point\n    final GeoPoint centerOfMass = getCenterOfMass(filteredPointList);\n    final Boolean isCenterOfMassInside = isInsidePolygon(centerOfMass, filteredPointList);\n    if (isCenterOfMassInside != null) {\n      return generateGeoPolygon(planetModel, filteredPointList, holes, centerOfMass, isCenterOfMassInside);\n    }\n    \n    //System.err.println(\"points=\"+pointList);\n    // Create a random number generator.  Effectively this furnishes us with a repeatable sequence\n    // of points to use for poles.\n    final Random generator = new Random(1234);\n    for (int counter = 0; counter < 1000000; counter++) {\n      //counter++;\n      // Pick the next random pole\n      final GeoPoint pole = pickPole(generator, planetModel, filteredPointList);\n      // Is it inside or outside?\n      final Boolean isPoleInside = isInsidePolygon(pole, filteredPointList);\n      if (isPoleInside != null) {\n        // Legal pole\n        //System.out.println(\"Took \"+counter+\" iterations to find pole\");\n        //System.out.println(\"Pole = \"+pole+\"; isInside=\"+isPoleInside+\"; pointList = \"+pointList);\n        return generateGeoPolygon(planetModel, filteredPointList, holes, pole, isPoleInside);\n      }\n      // If pole choice was illegal, try another one\n    }\n    throw new IllegalArgumentException(\"cannot find a point that is inside the polygon \"+filteredPointList);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a1452bbfea2334e79ba7ac6b6e1508344526145c","date":1521980228,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],double).mjava","sourceNew":"  /** Create a GeoPolygon using the specified points and holes, using order to determine \n   * siding of the polygon.  Much like ESRI, this method uses clockwise to indicate the space\n   * on the same side of the shape as being inside, and counter-clockwise to indicate the\n   * space on the opposite side as being inside.\n   * @param pointList is a list of the GeoPoints to build an arbitrary polygon out of.  If points go\n   *  clockwise from a given pole, then that pole should be within the polygon.  If points go\n   *  counter-clockwise, then that pole should be outside the polygon.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Holes describe the area outside\n   *  each hole as being \"in set\".  Null == none.\n   * @param leniencyValue is the maximum distance (in units) that a point can be from the plane and still be considered as\n   *  belonging to the plane.  Any value greater than zero may cause some of the provided points that are in fact outside\n   *  the strict definition of co-planarity, but are within this distance, to be discarded for the purposes of creating a\n   *  \"safe\" polygon.\n   * @return a GeoPolygon corresponding to what was specified, or null if a valid polygon cannot be generated\n   *  from this input.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> pointList,\n    final List<GeoPolygon> holes,\n    final double leniencyValue) {\n    // First, exercise a sanity filter on the provided pointList, and remove identical points, linear points, and backtracks\n    //System.err.println(\" filtering \"+pointList.size()+\" points...\");\n    //final long startTime = System.currentTimeMillis();\n    final List<GeoPoint> firstFilteredPointList = filterPoints(pointList);\n    if (firstFilteredPointList == null) {\n      return null;\n    }\n    final List<GeoPoint> filteredPointList = filterEdges(firstFilteredPointList, leniencyValue);\n    //System.err.println(\"  ...done in \"+(System.currentTimeMillis()-startTime)+\"ms (\"+((filteredPointList==null)?\"degenerate\":(filteredPointList.size()+\" points\"))+\")\");\n    if (filteredPointList == null) {\n      return null;\n    }\n\n    try {\n      //First approximation to find a point\n      final GeoPoint centerOfMass = getCenterOfMass(planetModel, filteredPointList);\n      final Boolean isCenterOfMassInside = isInsidePolygon(centerOfMass, filteredPointList);\n      if (isCenterOfMassInside != null) {\n        return generateGeoPolygon(planetModel, filteredPointList, holes, centerOfMass, isCenterOfMassInside);\n      }\n      \n      //System.err.println(\"points=\"+pointList);\n      // Create a random number generator.  Effectively this furnishes us with a repeatable sequence\n      // of points to use for poles.\n      final Random generator = new Random(1234);\n      for (int counter = 0; counter < 1000000; counter++) {\n        //counter++;\n        // Pick the next random pole\n        final GeoPoint pole = pickPole(generator, planetModel, filteredPointList);\n        // Is it inside or outside?\n        final Boolean isPoleInside = isInsidePolygon(pole, filteredPointList);\n        if (isPoleInside != null) {\n          // Legal pole\n          //System.out.println(\"Took \"+counter+\" iterations to find pole\");\n          //System.out.println(\"Pole = \"+pole+\"; isInside=\"+isPoleInside+\"; pointList = \"+pointList);\n          return generateGeoPolygon(planetModel, filteredPointList, holes, pole, isPoleInside);\n        }\n        // If pole choice was illegal, try another one\n      }\n      throw new IllegalArgumentException(\"cannot find a point that is inside the polygon \"+filteredPointList);\n    } catch (TileException e) {\n      // Couldn't tile the polygon; use GeoComplexPolygon instead, if we can.\n      if (holes != null && holes.size() > 0) {\n        // We currently cannot get the list of points that went into making a hole back out, so don't allow this case.\n        // In order to support it, we really need to change the API contract, which is a bigger deal.\n        throw new IllegalArgumentException(e.getMessage());\n      }\n      final List<PolygonDescription> description = new ArrayList<>(1);\n      description.add(new PolygonDescription(pointList));\n      return makeLargeGeoPolygon(planetModel, description);\n    }\n  }\n\n","sourceOld":"  /** Create a GeoPolygon using the specified points and holes, using order to determine \n   * siding of the polygon.  Much like ESRI, this method uses clockwise to indicate the space\n   * on the same side of the shape as being inside, and counter-clockwise to indicate the\n   * space on the opposite side as being inside.\n   * @param pointList is a list of the GeoPoints to build an arbitrary polygon out of.  If points go\n   *  clockwise from a given pole, then that pole should be within the polygon.  If points go\n   *  counter-clockwise, then that pole should be outside the polygon.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Holes describe the area outside\n   *  each hole as being \"in set\".  Null == none.\n   * @param leniencyValue is the maximum distance (in units) that a point can be from the plane and still be considered as\n   *  belonging to the plane.  Any value greater than zero may cause some of the provided points that are in fact outside\n   *  the strict definition of co-planarity, but are within this distance, to be discarded for the purposes of creating a\n   *  \"safe\" polygon.\n   * @return a GeoPolygon corresponding to what was specified, or null if a valid polygon cannot be generated\n   *  from this input.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> pointList,\n    final List<GeoPolygon> holes,\n    final double leniencyValue) {\n    // First, exercise a sanity filter on the provided pointList, and remove identical points, linear points, and backtracks\n    //System.err.println(\" filtering \"+pointList.size()+\" points...\");\n    //final long startTime = System.currentTimeMillis();\n    final List<GeoPoint> firstFilteredPointList = filterPoints(pointList);\n    if (firstFilteredPointList == null) {\n      return null;\n    }\n    final List<GeoPoint> filteredPointList = filterEdges(firstFilteredPointList, leniencyValue);\n    //System.err.println(\"  ...done in \"+(System.currentTimeMillis()-startTime)+\"ms (\"+((filteredPointList==null)?\"degenerate\":(filteredPointList.size()+\" points\"))+\")\");\n    if (filteredPointList == null) {\n      return null;\n    }\n\n    //First approximation to find a point\n    final GeoPoint centerOfMass = getCenterOfMass(planetModel, filteredPointList);\n    final Boolean isCenterOfMassInside = isInsidePolygon(centerOfMass, filteredPointList);\n    if (isCenterOfMassInside != null) {\n      return generateGeoPolygon(planetModel, filteredPointList, holes, centerOfMass, isCenterOfMassInside);\n    }\n    \n    //System.err.println(\"points=\"+pointList);\n    // Create a random number generator.  Effectively this furnishes us with a repeatable sequence\n    // of points to use for poles.\n    final Random generator = new Random(1234);\n    for (int counter = 0; counter < 1000000; counter++) {\n      //counter++;\n      // Pick the next random pole\n      final GeoPoint pole = pickPole(generator, planetModel, filteredPointList);\n      // Is it inside or outside?\n      final Boolean isPoleInside = isInsidePolygon(pole, filteredPointList);\n      if (isPoleInside != null) {\n        // Legal pole\n        //System.out.println(\"Took \"+counter+\" iterations to find pole\");\n        //System.out.println(\"Pole = \"+pole+\"; isInside=\"+isPoleInside+\"; pointList = \"+pointList);\n        return generateGeoPolygon(planetModel, filteredPointList, holes, pole, isPoleInside);\n      }\n      // If pole choice was illegal, try another one\n    }\n    throw new IllegalArgumentException(\"cannot find a point that is inside the polygon \"+filteredPointList);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f57114b5ef2859c0e501343c6e66f3c769d096a8":["ba1a26cce088d68dd4a3c599994fbc52c06e37b4"],"8dc2dbc28de286321b0c897c64f47895835e0df2":["3a9b3ef6cc46c18893efb19aa54f8bcd3425c9db"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["99b0a9e4d18bb364d2546e5230cc61abcd2d366b","ba81c43c13d92ea74a6388471cf358eb7068744d"],"a1452bbfea2334e79ba7ac6b6e1508344526145c":["8dc2dbc28de286321b0c897c64f47895835e0df2"],"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0":["f7f901826e47f75f810d7aae24b0455d21ea1fe2","f57114b5ef2859c0e501343c6e66f3c769d096a8"],"3a9b3ef6cc46c18893efb19aa54f8bcd3425c9db":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"ba1a26cce088d68dd4a3c599994fbc52c06e37b4":["99b0a9e4d18bb364d2546e5230cc61abcd2d366b"],"99b0a9e4d18bb364d2546e5230cc61abcd2d366b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a1452bbfea2334e79ba7ac6b6e1508344526145c"],"ba81c43c13d92ea74a6388471cf358eb7068744d":["99b0a9e4d18bb364d2546e5230cc61abcd2d366b"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["f7f901826e47f75f810d7aae24b0455d21ea1fe2","c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"]},"commit2Childs":{"f57114b5ef2859c0e501343c6e66f3c769d096a8":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"8dc2dbc28de286321b0c897c64f47895835e0df2":["a1452bbfea2334e79ba7ac6b6e1508344526145c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["99b0a9e4d18bb364d2546e5230cc61abcd2d366b"],"f7f901826e47f75f810d7aae24b0455d21ea1fe2":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0","55b50463286869f584cf849d1587a0fcd54d1dfa"],"a1452bbfea2334e79ba7ac6b6e1508344526145c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0":["3a9b3ef6cc46c18893efb19aa54f8bcd3425c9db","55b50463286869f584cf849d1587a0fcd54d1dfa"],"3a9b3ef6cc46c18893efb19aa54f8bcd3425c9db":["8dc2dbc28de286321b0c897c64f47895835e0df2"],"ba1a26cce088d68dd4a3c599994fbc52c06e37b4":["f57114b5ef2859c0e501343c6e66f3c769d096a8"],"99b0a9e4d18bb364d2546e5230cc61abcd2d366b":["f7f901826e47f75f810d7aae24b0455d21ea1fe2","ba1a26cce088d68dd4a3c599994fbc52c06e37b4","ba81c43c13d92ea74a6388471cf358eb7068744d"],"ba81c43c13d92ea74a6388471cf358eb7068744d":["f7f901826e47f75f810d7aae24b0455d21ea1fe2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"55b50463286869f584cf849d1587a0fcd54d1dfa":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","55b50463286869f584cf849d1587a0fcd54d1dfa"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}