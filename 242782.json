{"path":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","commits":[{"id":"3f767f8c99eaedb984df754fe61f21c5de260f94","date":1344105153,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.CloudStateUpdater#updateState(CloudState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.get(ZkStateReader.COLLECTION_PROP);\n        final String zkCoreNodeName = message.get(ZkStateReader.NODE_NAME_PROP) + \"_\" + message.get(ZkStateReader.CORE_NAME_PROP);\n        final Integer numShards = message.get(ZkStateReader.NUM_SHARDS_PROP)!=null?Integer.parseInt(message.get(ZkStateReader.NUM_SHARDS_PROP)):null;\n        \n        //collection does not yet exist, create placeholders if num shards is specified\n        if (!state.getCollections().contains(collection)\n            && numShards!=null) {\n          state = createCollection(state, collection, numShards);\n        }\n        \n        // use the provided non null shardId\n        String shardId = message.get(ZkStateReader.SHARD_ID_PROP);\n        if (shardId == null) {\n          String nodeName = message.get(ZkStateReader.NODE_NAME_PROP);\n          //get shardId from ClusterState\n          shardId = getAssignedId(state, nodeName, message);\n        }\n        if(shardId == null) {\n          //request new shardId \n          shardId = AssignShard.assignShard(collection, state, numShards);\n        }\n          \n          Map<String,String> props = new HashMap<String,String>();\n          Map<String,String> coreProps = new HashMap<String,String>(message.getProperties().size());\n          coreProps.putAll(message.getProperties());\n          // we don't put num_shards in the clusterstate\n          coreProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          coreProps.remove(QUEUE_OPERATION);\n          for (Entry<String,String> entry : coreProps.entrySet()) {\n            props.put(entry.getKey(), entry.getValue());\n          }\n          ZkNodeProps zkProps = new ZkNodeProps(props);\n          Slice slice = state.getSlice(collection, shardId);\n          Map<String,ZkNodeProps> shardProps;\n          if (slice == null) {\n            shardProps = new HashMap<String,ZkNodeProps>();\n          } else {\n            shardProps = state.getSlice(collection, shardId).getShardsCopy();\n          }\n          shardProps.put(zkCoreNodeName, zkProps);\n\n          slice = new Slice(shardId, shardProps);\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private CloudState updateState(CloudState state, final ZkNodeProps message) {\n        final String collection = message.get(ZkStateReader.COLLECTION_PROP);\n        final String zkCoreNodeName = message.get(ZkStateReader.NODE_NAME_PROP) + \"_\" + message.get(ZkStateReader.CORE_NAME_PROP);\n        final Integer numShards = message.get(ZkStateReader.NUM_SHARDS_PROP)!=null?Integer.parseInt(message.get(ZkStateReader.NUM_SHARDS_PROP)):null;\n        \n        //collection does not yet exist, create placeholders if num shards is specified\n        if (!state.getCollections().contains(collection)\n            && numShards!=null) {\n          state = createCollection(state, collection, numShards);\n        }\n        \n        // use the provided non null shardId\n        String shardId = message.get(ZkStateReader.SHARD_ID_PROP);\n        if (shardId == null) {\n          String nodeName = message.get(ZkStateReader.NODE_NAME_PROP);\n          //get shardId from CloudState\n          shardId = getAssignedId(state, nodeName, message);\n        }\n        if(shardId == null) {\n          //request new shardId \n          shardId = AssignShard.assignShard(collection, state, numShards);\n        }\n          \n          Map<String,String> props = new HashMap<String,String>();\n          Map<String,String> coreProps = new HashMap<String,String>(message.getProperties().size());\n          coreProps.putAll(message.getProperties());\n          // we don't put num_shards in the clusterstate\n          coreProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          coreProps.remove(QUEUE_OPERATION);\n          for (Entry<String,String> entry : coreProps.entrySet()) {\n            props.put(entry.getKey(), entry.getValue());\n          }\n          ZkNodeProps zkProps = new ZkNodeProps(props);\n          Slice slice = state.getSlice(collection, shardId);\n          Map<String,ZkNodeProps> shardProps;\n          if (slice == null) {\n            shardProps = new HashMap<String,ZkNodeProps>();\n          } else {\n            shardProps = state.getSlice(collection, shardId).getShardsCopy();\n          }\n          shardProps.put(zkCoreNodeName, zkProps);\n\n          slice = new Slice(shardId, shardProps);\n          CloudState newCloudState = updateSlice(state, collection, slice);\n          return newCloudState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8fd5be977c105554c6a7b68afcdbc511439723ab","date":1344115570,"type":1,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.CloudStateUpdater#updateState(CloudState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.get(ZkStateReader.COLLECTION_PROP);\n        final String zkCoreNodeName = message.get(ZkStateReader.NODE_NAME_PROP) + \"_\" + message.get(ZkStateReader.CORE_NAME_PROP);\n        final Integer numShards = message.get(ZkStateReader.NUM_SHARDS_PROP)!=null?Integer.parseInt(message.get(ZkStateReader.NUM_SHARDS_PROP)):null;\n        \n        //collection does not yet exist, create placeholders if num shards is specified\n        if (!state.getCollections().contains(collection)\n            && numShards!=null) {\n          state = createCollection(state, collection, numShards);\n        }\n        \n        // use the provided non null shardId\n        String shardId = message.get(ZkStateReader.SHARD_ID_PROP);\n        if (shardId == null) {\n          String nodeName = message.get(ZkStateReader.NODE_NAME_PROP);\n          //get shardId from ClusterState\n          shardId = getAssignedId(state, nodeName, message);\n        }\n        if(shardId == null) {\n          //request new shardId \n          shardId = AssignShard.assignShard(collection, state, numShards);\n        }\n          \n          Map<String,String> props = new HashMap<String,String>();\n          Map<String,String> coreProps = new HashMap<String,String>(message.getProperties().size());\n          coreProps.putAll(message.getProperties());\n          // we don't put num_shards in the clusterstate\n          coreProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          coreProps.remove(QUEUE_OPERATION);\n          for (Entry<String,String> entry : coreProps.entrySet()) {\n            props.put(entry.getKey(), entry.getValue());\n          }\n          ZkNodeProps zkProps = new ZkNodeProps(props);\n          Slice slice = state.getSlice(collection, shardId);\n          Map<String,ZkNodeProps> shardProps;\n          if (slice == null) {\n            shardProps = new HashMap<String,ZkNodeProps>();\n          } else {\n            shardProps = state.getSlice(collection, shardId).getShardsCopy();\n          }\n          shardProps.put(zkCoreNodeName, zkProps);\n\n          slice = new Slice(shardId, shardProps);\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private CloudState updateState(CloudState state, final ZkNodeProps message) {\n        final String collection = message.get(ZkStateReader.COLLECTION_PROP);\n        final String zkCoreNodeName = message.get(ZkStateReader.NODE_NAME_PROP) + \"_\" + message.get(ZkStateReader.CORE_NAME_PROP);\n        final Integer numShards = message.get(ZkStateReader.NUM_SHARDS_PROP)!=null?Integer.parseInt(message.get(ZkStateReader.NUM_SHARDS_PROP)):null;\n        \n        //collection does not yet exist, create placeholders if num shards is specified\n        if (!state.getCollections().contains(collection)\n            && numShards!=null) {\n          state = createCollection(state, collection, numShards);\n        }\n        \n        // use the provided non null shardId\n        String shardId = message.get(ZkStateReader.SHARD_ID_PROP);\n        if (shardId == null) {\n          String nodeName = message.get(ZkStateReader.NODE_NAME_PROP);\n          //get shardId from CloudState\n          shardId = getAssignedId(state, nodeName, message);\n        }\n        if(shardId == null) {\n          //request new shardId \n          shardId = AssignShard.assignShard(collection, state, numShards);\n        }\n          \n          Map<String,String> props = new HashMap<String,String>();\n          Map<String,String> coreProps = new HashMap<String,String>(message.getProperties().size());\n          coreProps.putAll(message.getProperties());\n          // we don't put num_shards in the clusterstate\n          coreProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          coreProps.remove(QUEUE_OPERATION);\n          for (Entry<String,String> entry : coreProps.entrySet()) {\n            props.put(entry.getKey(), entry.getValue());\n          }\n          ZkNodeProps zkProps = new ZkNodeProps(props);\n          Slice slice = state.getSlice(collection, shardId);\n          Map<String,ZkNodeProps> shardProps;\n          if (slice == null) {\n            shardProps = new HashMap<String,ZkNodeProps>();\n          } else {\n            shardProps = state.getSlice(collection, shardId).getShardsCopy();\n          }\n          shardProps.put(zkCoreNodeName, zkProps);\n\n          slice = new Slice(shardId, shardProps);\n          CloudState newCloudState = updateSlice(state, collection, slice);\n          return newCloudState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"/dev/null","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.get(ZkStateReader.COLLECTION_PROP);\n        final String zkCoreNodeName = message.get(ZkStateReader.NODE_NAME_PROP) + \"_\" + message.get(ZkStateReader.CORE_NAME_PROP);\n        final Integer numShards = message.get(ZkStateReader.NUM_SHARDS_PROP)!=null?Integer.parseInt(message.get(ZkStateReader.NUM_SHARDS_PROP)):null;\n        \n        //collection does not yet exist, create placeholders if num shards is specified\n        if (!state.getCollections().contains(collection)\n            && numShards!=null) {\n          state = createCollection(state, collection, numShards);\n        }\n        \n        // use the provided non null shardId\n        String shardId = message.get(ZkStateReader.SHARD_ID_PROP);\n        if (shardId == null) {\n          String nodeName = message.get(ZkStateReader.NODE_NAME_PROP);\n          //get shardId from ClusterState\n          shardId = getAssignedId(state, nodeName, message);\n        }\n        if(shardId == null) {\n          //request new shardId \n          shardId = AssignShard.assignShard(collection, state, numShards);\n        }\n          \n          Map<String,String> props = new HashMap<String,String>();\n          Map<String,String> coreProps = new HashMap<String,String>(message.getProperties().size());\n          coreProps.putAll(message.getProperties());\n          // we don't put num_shards in the clusterstate\n          coreProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          coreProps.remove(QUEUE_OPERATION);\n          for (Entry<String,String> entry : coreProps.entrySet()) {\n            props.put(entry.getKey(), entry.getValue());\n          }\n          ZkNodeProps zkProps = new ZkNodeProps(props);\n          Slice slice = state.getSlice(collection, shardId);\n          Map<String,ZkNodeProps> shardProps;\n          if (slice == null) {\n            shardProps = new HashMap<String,ZkNodeProps>();\n          } else {\n            shardProps = state.getSlice(collection, shardId).getShardsCopy();\n          }\n          shardProps.put(zkCoreNodeName, zkProps);\n\n          slice = new Slice(shardId, shardProps);\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa64435b5902ce266c23755a4a00691a3285dab8","date":1347243290,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        final String zkCoreNodeName = message.getStr(ZkStateReader.NODE_NAME_PROP) + \"_\" + message.getStr(ZkStateReader.CORE_NAME_PROP);\n        final Integer numShards = message.getStr(ZkStateReader.NUM_SHARDS_PROP)!=null?Integer.parseInt(message.getStr(ZkStateReader.NUM_SHARDS_PROP)):null;\n        \n        //collection does not yet exist, create placeholders if num shards is specified\n        if (!state.getCollections().contains(collection)\n            && numShards!=null) {\n          state = createCollection(state, collection, numShards);\n        }\n        \n        // use the provided non null shardId\n        String shardId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (shardId == null) {\n          String nodeName = message.getStr(ZkStateReader.NODE_NAME_PROP);\n          //get shardId from ClusterState\n          shardId = getAssignedId(state, nodeName, message);\n        }\n        if(shardId == null) {\n          //request new shardId \n          shardId = AssignShard.assignShard(collection, state, numShards);\n        }\n          \n          Map<String,Object> props = new HashMap<String,Object>();\n          Map<String,Object> coreProps = new HashMap<String,Object>(message.getProperties().size());\n          coreProps.putAll(message.getProperties());\n          // we don't put num_shards in the clusterstate\n          coreProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          coreProps.remove(QUEUE_OPERATION);\n          for (Entry<String,Object> entry : coreProps.entrySet()) {\n            props.put(entry.getKey(), entry.getValue());\n          }\n          Replica zkProps = new Replica(zkCoreNodeName, props);\n          Slice slice = state.getSlice(collection, shardId);\n          Map<String,Replica> shardProps;\n          if (slice == null) {\n            shardProps = new HashMap<String,Replica>();\n          } else {\n            shardProps = state.getSlice(collection, shardId).getReplicasCopy();\n          }\n          shardProps.put(zkCoreNodeName, zkProps);\n\n          slice = new Slice(shardId, shardProps);\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.get(ZkStateReader.COLLECTION_PROP);\n        final String zkCoreNodeName = message.get(ZkStateReader.NODE_NAME_PROP) + \"_\" + message.get(ZkStateReader.CORE_NAME_PROP);\n        final Integer numShards = message.get(ZkStateReader.NUM_SHARDS_PROP)!=null?Integer.parseInt(message.get(ZkStateReader.NUM_SHARDS_PROP)):null;\n        \n        //collection does not yet exist, create placeholders if num shards is specified\n        if (!state.getCollections().contains(collection)\n            && numShards!=null) {\n          state = createCollection(state, collection, numShards);\n        }\n        \n        // use the provided non null shardId\n        String shardId = message.get(ZkStateReader.SHARD_ID_PROP);\n        if (shardId == null) {\n          String nodeName = message.get(ZkStateReader.NODE_NAME_PROP);\n          //get shardId from ClusterState\n          shardId = getAssignedId(state, nodeName, message);\n        }\n        if(shardId == null) {\n          //request new shardId \n          shardId = AssignShard.assignShard(collection, state, numShards);\n        }\n          \n          Map<String,String> props = new HashMap<String,String>();\n          Map<String,String> coreProps = new HashMap<String,String>(message.getProperties().size());\n          coreProps.putAll(message.getProperties());\n          // we don't put num_shards in the clusterstate\n          coreProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          coreProps.remove(QUEUE_OPERATION);\n          for (Entry<String,String> entry : coreProps.entrySet()) {\n            props.put(entry.getKey(), entry.getValue());\n          }\n          ZkNodeProps zkProps = new ZkNodeProps(props);\n          Slice slice = state.getSlice(collection, shardId);\n          Map<String,ZkNodeProps> shardProps;\n          if (slice == null) {\n            shardProps = new HashMap<String,ZkNodeProps>();\n          } else {\n            shardProps = state.getSlice(collection, shardId).getShardsCopy();\n          }\n          shardProps.put(zkCoreNodeName, zkProps);\n\n          slice = new Slice(shardId, shardProps);\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":["1525b4dfbc0d413b8d7247da232009778e624836"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7e7d59baa18f0aed2bb5f93a76ffce5343aee13d","date":1347918051,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        final String zkCoreNodeName = message.getStr(ZkStateReader.NODE_NAME_PROP) + \"_\" + message.getStr(ZkStateReader.CORE_NAME_PROP);\n        final Integer numShards = message.getStr(ZkStateReader.NUM_SHARDS_PROP)!=null?Integer.parseInt(message.getStr(ZkStateReader.NUM_SHARDS_PROP)):null;\n        \n        //collection does not yet exist, create placeholders if num shards is specified\n        if (!state.getCollections().contains(collection)\n            && numShards!=null) {\n          state = createCollection(state, collection, numShards);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          String nodeName = message.getStr(ZkStateReader.NODE_NAME_PROP);\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, nodeName, message);\n        }\n        if(sliceName == null) {\n          //request new shardId \n          sliceName = AssignShard.assignShard(collection, state, numShards);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(zkCoreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put num_shards in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n\n\n          Replica replica = new Replica(zkCoreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        final String zkCoreNodeName = message.getStr(ZkStateReader.NODE_NAME_PROP) + \"_\" + message.getStr(ZkStateReader.CORE_NAME_PROP);\n        final Integer numShards = message.getStr(ZkStateReader.NUM_SHARDS_PROP)!=null?Integer.parseInt(message.getStr(ZkStateReader.NUM_SHARDS_PROP)):null;\n        \n        //collection does not yet exist, create placeholders if num shards is specified\n        if (!state.getCollections().contains(collection)\n            && numShards!=null) {\n          state = createCollection(state, collection, numShards);\n        }\n        \n        // use the provided non null shardId\n        String shardId = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (shardId == null) {\n          String nodeName = message.getStr(ZkStateReader.NODE_NAME_PROP);\n          //get shardId from ClusterState\n          shardId = getAssignedId(state, nodeName, message);\n        }\n        if(shardId == null) {\n          //request new shardId \n          shardId = AssignShard.assignShard(collection, state, numShards);\n        }\n          \n          Map<String,Object> props = new HashMap<String,Object>();\n          Map<String,Object> coreProps = new HashMap<String,Object>(message.getProperties().size());\n          coreProps.putAll(message.getProperties());\n          // we don't put num_shards in the clusterstate\n          coreProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          coreProps.remove(QUEUE_OPERATION);\n          for (Entry<String,Object> entry : coreProps.entrySet()) {\n            props.put(entry.getKey(), entry.getValue());\n          }\n          Replica zkProps = new Replica(zkCoreNodeName, props);\n          Slice slice = state.getSlice(collection, shardId);\n          Map<String,Replica> shardProps;\n          if (slice == null) {\n            shardProps = new HashMap<String,Replica>();\n          } else {\n            shardProps = state.getSlice(collection, shardId).getReplicasCopy();\n          }\n          shardProps.put(zkCoreNodeName, zkProps);\n\n          slice = new Slice(shardId, shardProps);\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1525b4dfbc0d413b8d7247da232009778e624836","date":1351101135,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        final String zkCoreNodeName = message.getStr(ZkStateReader.NODE_NAME_PROP) + \"_\" + message.getStr(ZkStateReader.CORE_NAME_PROP);\n        Integer numShards = message.getStr(ZkStateReader.NUM_SHARDS_PROP)!=null?Integer.parseInt(message.getStr(ZkStateReader.NUM_SHARDS_PROP)):null;\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.getCollections().contains(collection);\n        if (!collectionExists && numShards!=null) {\n          state = createCollection(state, collection, numShards);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          String nodeName = message.getStr(ZkStateReader.NODE_NAME_PROP);\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, nodeName, message);\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).size();\n          }\n          sliceName = AssignShard.assignShard(collection, state, numShards);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(zkCoreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put num_shards in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n\n\n          Replica replica = new Replica(zkCoreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        final String zkCoreNodeName = message.getStr(ZkStateReader.NODE_NAME_PROP) + \"_\" + message.getStr(ZkStateReader.CORE_NAME_PROP);\n        final Integer numShards = message.getStr(ZkStateReader.NUM_SHARDS_PROP)!=null?Integer.parseInt(message.getStr(ZkStateReader.NUM_SHARDS_PROP)):null;\n        \n        //collection does not yet exist, create placeholders if num shards is specified\n        if (!state.getCollections().contains(collection)\n            && numShards!=null) {\n          state = createCollection(state, collection, numShards);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          String nodeName = message.getStr(ZkStateReader.NODE_NAME_PROP);\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, nodeName, message);\n        }\n        if(sliceName == null) {\n          //request new shardId \n          sliceName = AssignShard.assignShard(collection, state, numShards);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(zkCoreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put num_shards in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n\n\n          Replica replica = new Replica(zkCoreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":["fa64435b5902ce266c23755a4a00691a3285dab8","a5093a9e893633cc091cf2f729d7863671c2b715"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f2126b84bd093fa3d921582a109a0ee578c28126","date":1351522501,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        final String zkCoreNodeName = message.getStr(ZkStateReader.NODE_NAME_PROP) + \"_\" + message.getStr(ZkStateReader.CORE_NAME_PROP);\n        Integer numShards = message.getStr(ZkStateReader.NUM_SHARDS_PROP)!=null?Integer.parseInt(message.getStr(ZkStateReader.NUM_SHARDS_PROP)):null;\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.getCollections().contains(collection);\n        if (!collectionExists && numShards!=null) {\n          state = createCollection(state, collection, numShards);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          String nodeName = message.getStr(ZkStateReader.NODE_NAME_PROP);\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, nodeName, message);\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).size();\n          }\n          sliceName = AssignShard.assignShard(collection, state, numShards);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(zkCoreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put num_shards in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n\n\n          Replica replica = new Replica(zkCoreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        final String zkCoreNodeName = message.getStr(ZkStateReader.NODE_NAME_PROP) + \"_\" + message.getStr(ZkStateReader.CORE_NAME_PROP);\n        final Integer numShards = message.getStr(ZkStateReader.NUM_SHARDS_PROP)!=null?Integer.parseInt(message.getStr(ZkStateReader.NUM_SHARDS_PROP)):null;\n        \n        //collection does not yet exist, create placeholders if num shards is specified\n        if (!state.getCollections().contains(collection)\n            && numShards!=null) {\n          state = createCollection(state, collection, numShards);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          String nodeName = message.getStr(ZkStateReader.NODE_NAME_PROP);\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, nodeName, message);\n        }\n        if(sliceName == null) {\n          //request new shardId \n          sliceName = AssignShard.assignShard(collection, state, numShards);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(zkCoreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put num_shards in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n\n\n          Replica replica = new Replica(zkCoreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a3053de358cec5245047361c5d9cf20e67225d5","date":1353438257,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        final String zkCoreNodeName = message.getStr(ZkStateReader.NODE_NAME_PROP) + \"_\" + message.getStr(ZkStateReader.CORE_NAME_PROP);\n        Integer numShards = message.getStr(ZkStateReader.NUM_SHARDS_PROP)!=null?Integer.parseInt(message.getStr(ZkStateReader.NUM_SHARDS_PROP)):null;\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.getCollections().contains(collection);\n        if (!collectionExists && numShards!=null) {\n          state = createCollection(state, collection, numShards);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          String nodeName = message.getStr(ZkStateReader.NODE_NAME_PROP);\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, nodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = AssignShard.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(zkCoreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put num_shards in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n\n\n          Replica replica = new Replica(zkCoreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        final String zkCoreNodeName = message.getStr(ZkStateReader.NODE_NAME_PROP) + \"_\" + message.getStr(ZkStateReader.CORE_NAME_PROP);\n        Integer numShards = message.getStr(ZkStateReader.NUM_SHARDS_PROP)!=null?Integer.parseInt(message.getStr(ZkStateReader.NUM_SHARDS_PROP)):null;\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.getCollections().contains(collection);\n        if (!collectionExists && numShards!=null) {\n          state = createCollection(state, collection, numShards);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          String nodeName = message.getStr(ZkStateReader.NODE_NAME_PROP);\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, nodeName, message);\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).size();\n          }\n          sliceName = AssignShard.assignShard(collection, state, numShards);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(zkCoreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put num_shards in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n\n\n          Replica replica = new Replica(zkCoreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5a558d54519c651068ddb202f03befefb1514a7","date":1354382006,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        final String zkCoreNodeName = message.getStr(ZkStateReader.NODE_NAME_PROP) + \"_\" + message.getStr(ZkStateReader.CORE_NAME_PROP);\n        Integer numShards = message.getStr(ZkStateReader.NUM_SHARDS_PROP)!=null?Integer.parseInt(message.getStr(ZkStateReader.NUM_SHARDS_PROP)):null;\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.getCollections().contains(collection);\n        if (!collectionExists && numShards!=null) {\n          state = createCollection(state, collection, numShards);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          String nodeName = message.getStr(ZkStateReader.NODE_NAME_PROP);\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, nodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = AssignShard.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(zkCoreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put num_shards in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n\n\n          Replica replica = new Replica(zkCoreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        final String zkCoreNodeName = message.getStr(ZkStateReader.NODE_NAME_PROP) + \"_\" + message.getStr(ZkStateReader.CORE_NAME_PROP);\n        Integer numShards = message.getStr(ZkStateReader.NUM_SHARDS_PROP)!=null?Integer.parseInt(message.getStr(ZkStateReader.NUM_SHARDS_PROP)):null;\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.getCollections().contains(collection);\n        if (!collectionExists && numShards!=null) {\n          state = createCollection(state, collection, numShards);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          String nodeName = message.getStr(ZkStateReader.NODE_NAME_PROP);\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, nodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = AssignShard.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(zkCoreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put num_shards in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n\n\n          Replica replica = new Replica(zkCoreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        final String zkCoreNodeName = message.getStr(ZkStateReader.NODE_NAME_PROP) + \"_\" + message.getStr(ZkStateReader.CORE_NAME_PROP);\n        Integer numShards = message.getStr(ZkStateReader.NUM_SHARDS_PROP)!=null?Integer.parseInt(message.getStr(ZkStateReader.NUM_SHARDS_PROP)):null;\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.getCollections().contains(collection);\n        if (!collectionExists && numShards!=null) {\n          state = createCollection(state, collection, numShards);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          String nodeName = message.getStr(ZkStateReader.NODE_NAME_PROP);\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, nodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = AssignShard.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(zkCoreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put num_shards in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n\n\n          Replica replica = new Replica(zkCoreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        final String zkCoreNodeName = message.getStr(ZkStateReader.NODE_NAME_PROP) + \"_\" + message.getStr(ZkStateReader.CORE_NAME_PROP);\n        Integer numShards = message.getStr(ZkStateReader.NUM_SHARDS_PROP)!=null?Integer.parseInt(message.getStr(ZkStateReader.NUM_SHARDS_PROP)):null;\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.getCollections().contains(collection);\n        if (!collectionExists && numShards!=null) {\n          state = createCollection(state, collection, numShards);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          String nodeName = message.getStr(ZkStateReader.NODE_NAME_PROP);\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, nodeName, message);\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).size();\n          }\n          sliceName = AssignShard.assignShard(collection, state, numShards);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(zkCoreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put num_shards in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n\n\n          Replica replica = new Replica(zkCoreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb4a195b8dc1808cd01748bd2e0fba26ca915d4d","date":1361851792,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          // it must be the default then\n          coreNodeName = message.getStr(ZkStateReader.NODE_NAME_PROP) + \"_\" + message.getStr(ZkStateReader.CORE_NAME_PROP);\n        }\n        Integer numShards = message.getStr(ZkStateReader.NUM_SHARDS_PROP)!=null?Integer.parseInt(message.getStr(ZkStateReader.NUM_SHARDS_PROP)):null;\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.getCollections().contains(collection);\n        if (!collectionExists && numShards!=null) {\n          state = createCollection(state, collection, numShards);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          //String nodeName = message.getStr(ZkStateReader.NODE_NAME_PROP);\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = AssignShard.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put num_shards in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        final String zkCoreNodeName = message.getStr(ZkStateReader.NODE_NAME_PROP) + \"_\" + message.getStr(ZkStateReader.CORE_NAME_PROP);\n        Integer numShards = message.getStr(ZkStateReader.NUM_SHARDS_PROP)!=null?Integer.parseInt(message.getStr(ZkStateReader.NUM_SHARDS_PROP)):null;\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.getCollections().contains(collection);\n        if (!collectionExists && numShards!=null) {\n          state = createCollection(state, collection, numShards);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          String nodeName = message.getStr(ZkStateReader.NODE_NAME_PROP);\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, nodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = AssignShard.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(zkCoreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put num_shards in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n\n\n          Replica replica = new Replica(zkCoreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0beaed456aa3358e5e4a99ea2aea994ef6c81de3","date":1365434191,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          // it must be the default then\n          coreNodeName = message.getStr(ZkStateReader.NODE_NAME_PROP) + \"_\" + message.getStr(ZkStateReader.CORE_NAME_PROP);\n        }\n        Integer numShards = message.getStr(ZkStateReader.NUM_SHARDS_PROP)!=null?Integer.parseInt(message.getStr(ZkStateReader.NUM_SHARDS_PROP)):null;\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.getCollections().contains(collection);\n        if (!collectionExists && numShards!=null) {\n          state = createCollection(state, collection, numShards);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          //String nodeName = message.getStr(ZkStateReader.NODE_NAME_PROP);\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = AssignShard.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          String sliceState = slice.getState();\n          \n          // throw an exception if the slice is not yet active.\n\n          //if(!sliceState.equals(Slice.ACTIVE)) {\n          //  throw new SolrException(ErrorCode.BAD_REQUEST, \"Can not assign core to a non-active slice [\" + slice.getName() + \"]\");\n          //}\n          \n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put num_shards in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          // it must be the default then\n          coreNodeName = message.getStr(ZkStateReader.NODE_NAME_PROP) + \"_\" + message.getStr(ZkStateReader.CORE_NAME_PROP);\n        }\n        Integer numShards = message.getStr(ZkStateReader.NUM_SHARDS_PROP)!=null?Integer.parseInt(message.getStr(ZkStateReader.NUM_SHARDS_PROP)):null;\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.getCollections().contains(collection);\n        if (!collectionExists && numShards!=null) {\n          state = createCollection(state, collection, numShards);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          //String nodeName = message.getStr(ZkStateReader.NODE_NAME_PROP);\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = AssignShard.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put num_shards in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"849494cf2f3a96af5c8c84995108ddd8456fcd04","date":1372277913,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(state, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, state);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n        }\n        Integer numShards = message.getStr(ZkStateReader.NUM_SHARDS_PROP)!=null?Integer.parseInt(message.getStr(ZkStateReader.NUM_SHARDS_PROP)):null;\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.getCollections().contains(collection);\n        if (!collectionExists && numShards!=null) {\n          state = createCollection(state, collection, numShards);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          String sliceState = slice.getState();\n          \n          // throw an exception if the slice is not yet active.\n\n          //if(!sliceState.equals(Slice.ACTIVE)) {\n          //  throw new SolrException(ErrorCode.BAD_REQUEST, \"Can not assign core to a non-active slice [\" + slice.getName() + \"]\");\n          //}\n          \n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          // it must be the default then\n          coreNodeName = message.getStr(ZkStateReader.NODE_NAME_PROP) + \"_\" + message.getStr(ZkStateReader.CORE_NAME_PROP);\n        }\n        Integer numShards = message.getStr(ZkStateReader.NUM_SHARDS_PROP)!=null?Integer.parseInt(message.getStr(ZkStateReader.NUM_SHARDS_PROP)):null;\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.getCollections().contains(collection);\n        if (!collectionExists && numShards!=null) {\n          state = createCollection(state, collection, numShards);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          //String nodeName = message.getStr(ZkStateReader.NODE_NAME_PROP);\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = AssignShard.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          String sliceState = slice.getState();\n          \n          // throw an exception if the slice is not yet active.\n\n          //if(!sliceState.equals(Slice.ACTIVE)) {\n          //  throw new SolrException(ErrorCode.BAD_REQUEST, \"Can not assign core to a non-active slice [\" + slice.getName() + \"]\");\n          //}\n          \n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put num_shards in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"660ba5d2f171f4cff12238ecf42746100549ce63","date":1373483187,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        assert collection.length() > 0 : message;\n        \n        try {\n          if (!zkClient.exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n            log.warn(\"Could not find collection node for \" + collection + \", skipping publish state\");\n          }\n        } catch (KeeperException e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVER_ERROR, e);\n        }\n        \n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(state, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, state);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n        }\n        Integer numShards = message.getStr(ZkStateReader.NUM_SHARDS_PROP)!=null?Integer.parseInt(message.getStr(ZkStateReader.NUM_SHARDS_PROP)):null;\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.getCollections().contains(collection);\n        if (!collectionExists && numShards!=null) {\n          state = createCollection(state, collection, numShards);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          String sliceState = slice.getState();\n          \n          // throw an exception if the slice is not yet active.\n\n          //if(!sliceState.equals(Slice.ACTIVE)) {\n          //  throw new SolrException(ErrorCode.BAD_REQUEST, \"Can not assign core to a non-active slice [\" + slice.getName() + \"]\");\n          //}\n          \n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(state, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, state);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n        }\n        Integer numShards = message.getStr(ZkStateReader.NUM_SHARDS_PROP)!=null?Integer.parseInt(message.getStr(ZkStateReader.NUM_SHARDS_PROP)):null;\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.getCollections().contains(collection);\n        if (!collectionExists && numShards!=null) {\n          state = createCollection(state, collection, numShards);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          String sliceState = slice.getState();\n          \n          // throw an exception if the slice is not yet active.\n\n          //if(!sliceState.equals(Slice.ACTIVE)) {\n          //  throw new SolrException(ErrorCode.BAD_REQUEST, \"Can not assign core to a non-active slice [\" + slice.getName() + \"]\");\n          //}\n          \n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":["993d0b0d77c623d30cb24cdadbff9bb3b5f516bb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        assert collection.length() > 0 : message;\n        \n        try {\n          if (!zkClient.exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n            log.warn(\"Could not find collection node for \" + collection + \", skipping publish state\");\n          }\n        } catch (KeeperException e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVER_ERROR, e);\n        }\n        \n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(state, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, state);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n        }\n        Integer numShards = message.getStr(ZkStateReader.NUM_SHARDS_PROP)!=null?Integer.parseInt(message.getStr(ZkStateReader.NUM_SHARDS_PROP)):null;\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.getCollections().contains(collection);\n        if (!collectionExists && numShards!=null) {\n          state = createCollection(state, collection, numShards);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          String sliceState = slice.getState();\n          \n          // throw an exception if the slice is not yet active.\n\n          //if(!sliceState.equals(Slice.ACTIVE)) {\n          //  throw new SolrException(ErrorCode.BAD_REQUEST, \"Can not assign core to a non-active slice [\" + slice.getName() + \"]\");\n          //}\n          \n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          // it must be the default then\n          coreNodeName = message.getStr(ZkStateReader.NODE_NAME_PROP) + \"_\" + message.getStr(ZkStateReader.CORE_NAME_PROP);\n        }\n        Integer numShards = message.getStr(ZkStateReader.NUM_SHARDS_PROP)!=null?Integer.parseInt(message.getStr(ZkStateReader.NUM_SHARDS_PROP)):null;\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.getCollections().contains(collection);\n        if (!collectionExists && numShards!=null) {\n          state = createCollection(state, collection, numShards);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          //String nodeName = message.getStr(ZkStateReader.NODE_NAME_PROP);\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = AssignShard.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          String sliceState = slice.getState();\n          \n          // throw an exception if the slice is not yet active.\n\n          //if(!sliceState.equals(Slice.ACTIVE)) {\n          //  throw new SolrException(ErrorCode.BAD_REQUEST, \"Can not assign core to a non-active slice [\" + slice.getName() + \"]\");\n          //}\n          \n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put num_shards in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1eeda7e62e149f90eee8895af874c74efa7d4852","date":1375293182,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        assert collection.length() > 0 : message;\n        \n        try {\n          if (!zkClient.exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n            log.warn(\"Could not find collection node for \" + collection + \", skipping publish state\");\n          }\n        } catch (KeeperException e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVER_ERROR, e);\n        }\n        \n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(state, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, state);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n        }\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        String router = message.getStr(OverseerCollectionProcessor.ROUTER,DocRouter.DEFAULT_NAME);\n        List<String> shardNames  = new ArrayList<String>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.getCollections().contains(collection);\n        if (!collectionExists && numShards!=null) {\n          if(ImplicitDocRouter.NAME.equals(router)){\n            getShardNames(shardNames, message.getStr(\"shards\",null));\n            numShards = shardNames.size();\n          }else {\n            getShardNames(numShards, shardNames);\n          }\n          state = createCollection(state, collection, shardNames, message);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          String sliceState = slice.getState();\n          \n          // throw an exception if the slice is not yet active.\n\n          //if(!sliceState.equals(Slice.ACTIVE)) {\n          //  throw new SolrException(ErrorCode.BAD_REQUEST, \"Can not assign core to a non-active slice [\" + slice.getName() + \"]\");\n          //}\n          \n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        assert collection.length() > 0 : message;\n        \n        try {\n          if (!zkClient.exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n            log.warn(\"Could not find collection node for \" + collection + \", skipping publish state\");\n          }\n        } catch (KeeperException e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVER_ERROR, e);\n        }\n        \n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(state, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, state);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n        }\n        Integer numShards = message.getStr(ZkStateReader.NUM_SHARDS_PROP)!=null?Integer.parseInt(message.getStr(ZkStateReader.NUM_SHARDS_PROP)):null;\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.getCollections().contains(collection);\n        if (!collectionExists && numShards!=null) {\n          state = createCollection(state, collection, numShards);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          String sliceState = slice.getState();\n          \n          // throw an exception if the slice is not yet active.\n\n          //if(!sliceState.equals(Slice.ACTIVE)) {\n          //  throw new SolrException(ErrorCode.BAD_REQUEST, \"Can not assign core to a non-active slice [\" + slice.getName() + \"]\");\n          //}\n          \n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":["1b891e9f867c36643e4dffe81653ecb336ac50dd"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        assert collection.length() > 0 : message;\n        \n        try {\n          if (!zkClient.exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n            log.warn(\"Could not find collection node for \" + collection + \", skipping publish state\");\n          }\n        } catch (KeeperException e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVER_ERROR, e);\n        }\n        \n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(state, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, state);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n        }\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        String router = message.getStr(OverseerCollectionProcessor.ROUTER,DocRouter.DEFAULT_NAME);\n        List<String> shardNames  = new ArrayList<String>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.getCollections().contains(collection);\n        if (!collectionExists && numShards!=null) {\n          if(ImplicitDocRouter.NAME.equals(router)){\n            getShardNames(shardNames, message.getStr(\"shards\",null));\n            numShards = shardNames.size();\n          }else {\n            getShardNames(numShards, shardNames);\n          }\n          state = createCollection(state, collection, shardNames, message);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          String sliceState = slice.getState();\n          \n          // throw an exception if the slice is not yet active.\n\n          //if(!sliceState.equals(Slice.ACTIVE)) {\n          //  throw new SolrException(ErrorCode.BAD_REQUEST, \"Can not assign core to a non-active slice [\" + slice.getName() + \"]\");\n          //}\n          \n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        assert collection.length() > 0 : message;\n        \n        try {\n          if (!zkClient.exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n            log.warn(\"Could not find collection node for \" + collection + \", skipping publish state\");\n          }\n        } catch (KeeperException e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVER_ERROR, e);\n        }\n        \n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(state, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, state);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n        }\n        Integer numShards = message.getStr(ZkStateReader.NUM_SHARDS_PROP)!=null?Integer.parseInt(message.getStr(ZkStateReader.NUM_SHARDS_PROP)):null;\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.getCollections().contains(collection);\n        if (!collectionExists && numShards!=null) {\n          state = createCollection(state, collection, numShards);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          String sliceState = slice.getState();\n          \n          // throw an exception if the slice is not yet active.\n\n          //if(!sliceState.equals(Slice.ACTIVE)) {\n          //  throw new SolrException(ErrorCode.BAD_REQUEST, \"Can not assign core to a non-active slice [\" + slice.getName() + \"]\");\n          //}\n          \n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"993d0b0d77c623d30cb24cdadbff9bb3b5f516bb","date":1376485874,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        assert collection.length() > 0 : message;\n        \n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(state, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, state);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n        }\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        String router = message.getStr(OverseerCollectionProcessor.ROUTER,DocRouter.DEFAULT_NAME);\n        List<String> shardNames  = new ArrayList<String>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.getCollections().contains(collection);\n        if (!collectionExists && numShards!=null) {\n          if(ImplicitDocRouter.NAME.equals(router)){\n            getShardNames(shardNames, message.getStr(\"shards\",null));\n            numShards = shardNames.size();\n          }else {\n            getShardNames(numShards, shardNames);\n          }\n          state = createCollection(state, collection, shardNames, message);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          String sliceState = slice.getState();\n          \n          // throw an exception if the slice is not yet active.\n\n          //if(!sliceState.equals(Slice.ACTIVE)) {\n          //  throw new SolrException(ErrorCode.BAD_REQUEST, \"Can not assign core to a non-active slice [\" + slice.getName() + \"]\");\n          //}\n          \n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        assert collection.length() > 0 : message;\n        \n        try {\n          if (!zkClient.exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n            log.warn(\"Could not find collection node for \" + collection + \", skipping publish state\");\n          }\n        } catch (KeeperException e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVER_ERROR, e);\n        }\n        \n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(state, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, state);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n        }\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        String router = message.getStr(OverseerCollectionProcessor.ROUTER,DocRouter.DEFAULT_NAME);\n        List<String> shardNames  = new ArrayList<String>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.getCollections().contains(collection);\n        if (!collectionExists && numShards!=null) {\n          if(ImplicitDocRouter.NAME.equals(router)){\n            getShardNames(shardNames, message.getStr(\"shards\",null));\n            numShards = shardNames.size();\n          }else {\n            getShardNames(numShards, shardNames);\n          }\n          state = createCollection(state, collection, shardNames, message);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          String sliceState = slice.getState();\n          \n          // throw an exception if the slice is not yet active.\n\n          //if(!sliceState.equals(Slice.ACTIVE)) {\n          //  throw new SolrException(ErrorCode.BAD_REQUEST, \"Can not assign core to a non-active slice [\" + slice.getName() + \"]\");\n          //}\n          \n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":["660ba5d2f171f4cff12238ecf42746100549ce63"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        assert collection.length() > 0 : message;\n        \n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(state, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, state);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n        }\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        String router = message.getStr(OverseerCollectionProcessor.ROUTER,DocRouter.DEFAULT_NAME);\n        List<String> shardNames  = new ArrayList<String>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.getCollections().contains(collection);\n        if (!collectionExists && numShards!=null) {\n          if(ImplicitDocRouter.NAME.equals(router)){\n            getShardNames(shardNames, message.getStr(\"shards\",null));\n            numShards = shardNames.size();\n          }else {\n            getShardNames(numShards, shardNames);\n          }\n          state = createCollection(state, collection, shardNames, message);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          String sliceState = slice.getState();\n          \n          // throw an exception if the slice is not yet active.\n\n          //if(!sliceState.equals(Slice.ACTIVE)) {\n          //  throw new SolrException(ErrorCode.BAD_REQUEST, \"Can not assign core to a non-active slice [\" + slice.getName() + \"]\");\n          //}\n          \n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        assert collection.length() > 0 : message;\n        \n        try {\n          if (!zkClient.exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n            log.warn(\"Could not find collection node for \" + collection + \", skipping publish state\");\n          }\n        } catch (KeeperException e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(ErrorCode.SERVER_ERROR, e);\n        }\n        \n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(state, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, state);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n        }\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        String router = message.getStr(OverseerCollectionProcessor.ROUTER,DocRouter.DEFAULT_NAME);\n        List<String> shardNames  = new ArrayList<String>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.getCollections().contains(collection);\n        if (!collectionExists && numShards!=null) {\n          if(ImplicitDocRouter.NAME.equals(router)){\n            getShardNames(shardNames, message.getStr(\"shards\",null));\n            numShards = shardNames.size();\n          }else {\n            getShardNames(numShards, shardNames);\n          }\n          state = createCollection(state, collection, shardNames, message);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          String sliceState = slice.getState();\n          \n          // throw an exception if the slice is not yet active.\n\n          //if(!sliceState.equals(Slice.ACTIVE)) {\n          //  throw new SolrException(ErrorCode.BAD_REQUEST, \"Can not assign core to a non-active slice [\" + slice.getName() + \"]\");\n          //}\n          \n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1b891e9f867c36643e4dffe81653ecb336ac50dd","date":1381314855,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        assert collection.length() > 0 : message;\n        \n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(state, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, state);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n        }\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        List<String> shardNames  = new ArrayList<String>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.getCollections().contains(collection);\n        if (!collectionExists && numShards!=null) {\n          getShardNames(numShards, shardNames);\n          state = createCollection(state, collection, shardNames, message);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          String sliceState = slice.getState();\n          \n          // throw an exception if the slice is not yet active.\n\n          //if(!sliceState.equals(Slice.ACTIVE)) {\n          //  throw new SolrException(ErrorCode.BAD_REQUEST, \"Can not assign core to a non-active slice [\" + slice.getName() + \"]\");\n          //}\n          \n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        assert collection.length() > 0 : message;\n        \n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(state, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, state);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n        }\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        String router = message.getStr(OverseerCollectionProcessor.ROUTER,DocRouter.DEFAULT_NAME);\n        List<String> shardNames  = new ArrayList<String>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.getCollections().contains(collection);\n        if (!collectionExists && numShards!=null) {\n          if(ImplicitDocRouter.NAME.equals(router)){\n            getShardNames(shardNames, message.getStr(\"shards\",null));\n            numShards = shardNames.size();\n          }else {\n            getShardNames(numShards, shardNames);\n          }\n          state = createCollection(state, collection, shardNames, message);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          String sliceState = slice.getState();\n          \n          // throw an exception if the slice is not yet active.\n\n          //if(!sliceState.equals(Slice.ACTIVE)) {\n          //  throw new SolrException(ErrorCode.BAD_REQUEST, \"Can not assign core to a non-active slice [\" + slice.getName() + \"]\");\n          //}\n          \n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":["1eeda7e62e149f90eee8895af874c74efa7d4852"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bc841231667f1f315bae6799c068f9aad6543967","date":1381415189,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        assert collection.length() > 0 : message;\n        \n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(state, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, state);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n        }\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        List<String> shardNames  = new ArrayList<String>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.getCollections().contains(collection);\n        if (!collectionExists && numShards!=null) {\n          getShardNames(numShards, shardNames);\n          state = createCollection(state, collection, shardNames, message);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n          String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            state = checkAndCompleteShardSplit(state, collection, coreNodeName, sliceName, replicaProps);\n            // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n            slice = state.getSlice(collection, sliceName);\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n            sliceProps.put(Slice.PARENT, shardParent);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        assert collection.length() > 0 : message;\n        \n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(state, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, state);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n        }\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        List<String> shardNames  = new ArrayList<String>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.getCollections().contains(collection);\n        if (!collectionExists && numShards!=null) {\n          getShardNames(numShards, shardNames);\n          state = createCollection(state, collection, shardNames, message);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          String sliceState = slice.getState();\n          \n          // throw an exception if the slice is not yet active.\n\n          //if(!sliceState.equals(Slice.ACTIVE)) {\n          //  throw new SolrException(ErrorCode.BAD_REQUEST, \"Can not assign core to a non-active slice [\" + slice.getName() + \"]\");\n          //}\n          \n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"40dce2b6d4360eb09fa16fb6c40a18b25507ed73","date":1383035822,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        assert collection.length() > 0 : message;\n        \n\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        List<String> shardNames  = new ArrayList<String>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.hasCollection(collection);\n        if (!collectionExists && numShards!=null) {\n          getShardNames(numShards, shardNames);\n          state = createCollection(state, collection, shardNames, message);\n        }\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(state, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, state);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n        } else {\n          //probably, this core was removed explicitly\n          if (sliceName !=null && collectionExists &&  !\"true\".equals(state.getCollection(collection).getStr(\"autoCreated\"))) {\n            Slice slice = state.getSlice(collection, sliceName);\n            if (slice.getReplica(coreNodeName) == null) {\n              log.info(\"core_deleted . Just return\");\n              return state;\n            }\n          }\n\n        }\n        // use the provided non null shardId\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n          String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            state = checkAndCompleteShardSplit(state, collection, coreNodeName, sliceName, replicaProps);\n            // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n            slice = state.getSlice(collection, sliceName);\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n            sliceProps.put(Slice.PARENT, shardParent);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        assert collection.length() > 0 : message;\n        \n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(state, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, state);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n        }\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        List<String> shardNames  = new ArrayList<String>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.getCollections().contains(collection);\n        if (!collectionExists && numShards!=null) {\n          getShardNames(numShards, shardNames);\n          state = createCollection(state, collection, shardNames, message);\n        }\n        \n        // use the provided non null shardId\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n          String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            state = checkAndCompleteShardSplit(state, collection, coreNodeName, sliceName, replicaProps);\n            // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n            slice = state.getSlice(collection, sliceName);\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n            sliceProps.put(Slice.PARENT, shardParent);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cdc8313ba7bdaaa48ff54059d0eabff4436ab175","date":1386102048,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        assert collection.length() > 0 : message;\n        \n\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        List<String> shardNames  = new ArrayList<String>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.hasCollection(collection);\n        if (!collectionExists && numShards!=null) {\n          getShardNames(numShards, shardNames);\n          state = createCollection(state, collection, shardNames, message);\n        }\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(state, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, state);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n        } else {\n          //probably, this core was removed explicitly\n          if (sliceName !=null && collectionExists &&  !\"true\".equals(state.getCollection(collection).getStr(\"autoCreated\"))) {\n            Slice slice = state.getSlice(collection, sliceName);\n            if (slice.getReplica(coreNodeName) == null) {\n              log.info(\"core_deleted . Just return\");\n              return state;\n            }\n          }\n\n        }\n        // use the provided non null shardId\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollection(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n          String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            state = checkAndCompleteShardSplit(state, collection, coreNodeName, sliceName, replicaProps);\n            // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n            slice = state.getSlice(collection, sliceName);\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n            sliceProps.put(Slice.PARENT, shardParent);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        assert collection.length() > 0 : message;\n        \n\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        List<String> shardNames  = new ArrayList<String>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.hasCollection(collection);\n        if (!collectionExists && numShards!=null) {\n          getShardNames(numShards, shardNames);\n          state = createCollection(state, collection, shardNames, message);\n        }\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(state, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, state);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n        } else {\n          //probably, this core was removed explicitly\n          if (sliceName !=null && collectionExists &&  !\"true\".equals(state.getCollection(collection).getStr(\"autoCreated\"))) {\n            Slice slice = state.getSlice(collection, sliceName);\n            if (slice.getReplica(coreNodeName) == null) {\n              log.info(\"core_deleted . Just return\");\n              return state;\n            }\n          }\n\n        }\n        // use the provided non null shardId\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n          String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            state = checkAndCompleteShardSplit(state, collection, coreNodeName, sliceName, replicaProps);\n            // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n            slice = state.getSlice(collection, sliceName);\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n            sliceProps.put(Slice.PARENT, shardParent);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        assert collection.length() > 0 : message;\n        \n\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        List<String> shardNames  = new ArrayList<String>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.hasCollection(collection);\n        if (!collectionExists && numShards!=null) {\n          getShardNames(numShards, shardNames);\n          state = createCollection(state, collection, shardNames, message);\n        }\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(state, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, state);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n        } else {\n          //probably, this core was removed explicitly\n          if (sliceName !=null && collectionExists &&  !\"true\".equals(state.getCollection(collection).getStr(\"autoCreated\"))) {\n            Slice slice = state.getSlice(collection, sliceName);\n            if (slice.getReplica(coreNodeName) == null) {\n              log.info(\"core_deleted . Just return\");\n              return state;\n            }\n          }\n\n        }\n        // use the provided non null shardId\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollection(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n          String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            state = checkAndCompleteShardSplit(state, collection, coreNodeName, sliceName, replicaProps);\n            // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n            slice = state.getSlice(collection, sliceName);\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n            sliceProps.put(Slice.PARENT, shardParent);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        assert collection.length() > 0 : message;\n        \n\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        List<String> shardNames  = new ArrayList<String>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.hasCollection(collection);\n        if (!collectionExists && numShards!=null) {\n          getShardNames(numShards, shardNames);\n          state = createCollection(state, collection, shardNames, message);\n        }\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(state, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, state);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n        } else {\n          //probably, this core was removed explicitly\n          if (sliceName !=null && collectionExists &&  !\"true\".equals(state.getCollection(collection).getStr(\"autoCreated\"))) {\n            Slice slice = state.getSlice(collection, sliceName);\n            if (slice.getReplica(coreNodeName) == null) {\n              log.info(\"core_deleted . Just return\");\n              return state;\n            }\n          }\n\n        }\n        // use the provided non null shardId\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollectionStates().get(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n          String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            state = checkAndCompleteShardSplit(state, collection, coreNodeName, sliceName, replicaProps);\n            // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n            slice = state.getSlice(collection, sliceName);\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n            sliceProps.put(Slice.PARENT, shardParent);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ea066add3bcc9f5b952f08999880ff9704e5ba48","date":1388272743,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        assert collection.length() > 0 : message;\n        \n\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        List<String> shardNames  = new ArrayList<String>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.hasCollection(collection);\n        if (!collectionExists && numShards!=null) {\n          getShardNames(numShards, shardNames);\n          state = createCollection(state, collection, shardNames, message);\n        }\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(state, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, state);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n              coreNodeName);\n        }\n\n        // use the provided non null shardId\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollection(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n          String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            state = checkAndCompleteShardSplit(state, collection, coreNodeName, sliceName, replicaProps);\n            // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n            slice = state.getSlice(collection, sliceName);\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n            sliceProps.put(Slice.PARENT, shardParent);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        assert collection.length() > 0 : message;\n        \n\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        List<String> shardNames  = new ArrayList<String>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.hasCollection(collection);\n        if (!collectionExists && numShards!=null) {\n          getShardNames(numShards, shardNames);\n          state = createCollection(state, collection, shardNames, message);\n        }\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(state, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, state);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);\n        } else {\n          //probably, this core was removed explicitly\n          if (sliceName !=null && collectionExists &&  !\"true\".equals(state.getCollection(collection).getStr(\"autoCreated\"))) {\n            Slice slice = state.getSlice(collection, sliceName);\n            if (slice.getReplica(coreNodeName) == null) {\n              log.info(\"core_deleted . Just return\");\n              return state;\n            }\n          }\n\n        }\n        // use the provided non null shardId\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollection(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n          String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            state = checkAndCompleteShardSplit(state, collection, coreNodeName, sliceName, replicaProps);\n            // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n            slice = state.getSlice(collection, sliceName);\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n            sliceProps.put(Slice.PARENT, shardParent);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29f5eaf296600e1665151e7929d42a3cbe22e481","date":1393983215,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        checkCollection(message, collection);\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        List<String> shardNames  = new ArrayList<String>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.hasCollection(collection);\n        if (!collectionExists && numShards!=null) {\n          getShardNames(numShards, shardNames);\n          state = createCollection(state, collection, shardNames, message);\n        }\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(state, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, state);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n              coreNodeName);\n        }\n\n        // use the provided non null shardId\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollection(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n          String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            state = checkAndCompleteShardSplit(state, collection, coreNodeName, sliceName, replicaProps);\n            // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n            slice = state.getSlice(collection, sliceName);\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n            sliceProps.put(Slice.PARENT, shardParent);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        assert collection.length() > 0 : message;\n        \n\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        List<String> shardNames  = new ArrayList<String>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.hasCollection(collection);\n        if (!collectionExists && numShards!=null) {\n          getShardNames(numShards, shardNames);\n          state = createCollection(state, collection, shardNames, message);\n        }\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(state, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, state);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n              coreNodeName);\n        }\n\n        // use the provided non null shardId\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollection(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n          String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            state = checkAndCompleteShardSplit(state, collection, coreNodeName, sliceName, replicaProps);\n            // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n            slice = state.getSlice(collection, sliceName);\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n            sliceProps.put(Slice.PARENT, shardParent);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6df412542f3e2161f4bc2b13357b4a973195bfb7","date":1394040511,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState clusterState, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        if (!checkCollectionKeyExistence(message)) return clusterState;\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        List<String> shardNames  = new ArrayList<String>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = clusterState.hasCollection(collection);\n        if (!collectionExists && numShards!=null) {\n          getShardNames(numShards, shardNames);\n          clusterState = createCollection(clusterState, collection, shardNames, message);\n        }\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(clusterState, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, clusterState);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n              coreNodeName);\n        }\n\n        // use the provided non null shardId\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(clusterState, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = clusterState.getCollection(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, clusterState, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = clusterState.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n          String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            clusterState = checkAndCompleteShardSplit(clusterState, collection, coreNodeName, sliceName, replicaProps);\n            // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n            slice = clusterState.getSlice(collection, sliceName);\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n            sliceProps.put(Slice.PARENT, shardParent);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(clusterState, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        checkCollection(message, collection);\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        List<String> shardNames  = new ArrayList<String>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.hasCollection(collection);\n        if (!collectionExists && numShards!=null) {\n          getShardNames(numShards, shardNames);\n          state = createCollection(state, collection, shardNames, message);\n        }\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(state, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, state);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n              coreNodeName);\n        }\n\n        // use the provided non null shardId\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollection(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n          String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            state = checkAndCompleteShardSplit(state, collection, coreNodeName, sliceName, replicaProps);\n            // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n            slice = state.getSlice(collection, sliceName);\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n            sliceProps.put(Slice.PARENT, shardParent);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"96ea64d994d340044e0d57aeb6a5871539d10ca5","date":1394225445,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState clusterState, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        if (!checkCollectionKeyExistence(message)) return clusterState;\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        List<String> shardNames  = new ArrayList<String>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = clusterState.hasCollection(collection);\n        if (!collectionExists && numShards!=null) {\n          getShardNames(numShards, shardNames);\n          clusterState = createCollection(clusterState, collection, shardNames, message);\n        }\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(clusterState, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, clusterState);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n              coreNodeName);\n        }\n\n        // use the provided non null shardId\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(clusterState, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = clusterState.getCollection(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, clusterState, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = clusterState.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n          String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            clusterState = checkAndCompleteShardSplit(clusterState, collection, coreNodeName, sliceName, replicaProps);\n            // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n            slice = clusterState.getSlice(collection, sliceName);\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n            sliceProps.put(Slice.PARENT, shardParent);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(clusterState, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState state, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        assert collection.length() > 0 : message;\n        \n\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        List<String> shardNames  = new ArrayList<String>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = state.hasCollection(collection);\n        if (!collectionExists && numShards!=null) {\n          getShardNames(numShards, shardNames);\n          state = createCollection(state, collection, shardNames, message);\n        }\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(state, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, state);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n              coreNodeName);\n        }\n\n        // use the provided non null shardId\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(state, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = state.getCollection(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, state, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = state.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n          String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            state = checkAndCompleteShardSplit(state, collection, coreNodeName, sliceName, replicaProps);\n            // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n            slice = state.getSlice(collection, sliceName);\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n            sliceProps.put(Slice.PARENT, shardParent);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(state, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState clusterState, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        if (!checkCollectionKeyExistence(message)) return clusterState;\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        List<String> shardNames  = new ArrayList<>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = clusterState.hasCollection(collection);\n        if (!collectionExists && numShards!=null) {\n          getShardNames(numShards, shardNames);\n          clusterState = createCollection(clusterState, collection, shardNames, message);\n        }\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(clusterState, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, clusterState);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n              coreNodeName);\n        }\n\n        // use the provided non null shardId\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(clusterState, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = clusterState.getCollection(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, clusterState, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = clusterState.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n          String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            clusterState = checkAndCompleteShardSplit(clusterState, collection, coreNodeName, sliceName, replicaProps);\n            // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n            slice = clusterState.getSlice(collection, sliceName);\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<>(1);\n            sliceProps = new HashMap<>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n            sliceProps.put(Slice.PARENT, shardParent);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(clusterState, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState clusterState, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        if (!checkCollectionKeyExistence(message)) return clusterState;\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        List<String> shardNames  = new ArrayList<String>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = clusterState.hasCollection(collection);\n        if (!collectionExists && numShards!=null) {\n          getShardNames(numShards, shardNames);\n          clusterState = createCollection(clusterState, collection, shardNames, message);\n        }\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(clusterState, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, clusterState);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n              coreNodeName);\n        }\n\n        // use the provided non null shardId\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(clusterState, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = clusterState.getCollection(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, clusterState, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = clusterState.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<String,Object>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<String>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n          String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            clusterState = checkAndCompleteShardSplit(clusterState, collection, coreNodeName, sliceName, replicaProps);\n            // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n            slice = clusterState.getSlice(collection, sliceName);\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<String, Replica>(1);\n            sliceProps = new HashMap<String, Object>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n            sliceProps.put(Slice.PARENT, shardParent);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(clusterState, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6f693ed86f289b2e42b46684409b3997f2c264a","date":1404319832,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState clusterState, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        if (!checkCollectionKeyExistence(message)) return clusterState;\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        List<String> shardNames  = new ArrayList<>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = clusterState.hasCollection(collection);\n        if (!collectionExists && numShards!=null) {\n          getShardNames(numShards, shardNames);\n          clusterState = createCollection(clusterState, collection, shardNames, message);\n        }\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(clusterState, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, clusterState);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n              coreNodeName);\n        }\n\n        // use the provided non null shardId\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(clusterState, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = clusterState.getCollection(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, clusterState, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = clusterState.getSlice(collection, sliceName);\n\n        Map<String,Object> replicaProps = new LinkedHashMap<>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n\n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n          String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            clusterState = checkAndCompleteShardSplit(clusterState, collection, coreNodeName, sliceName, replicaProps);\n            // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n            slice = clusterState.getSlice(collection, sliceName);\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<>(1);\n            sliceProps = new HashMap<>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n            sliceProps.put(Slice.PARENT, shardParent);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(clusterState, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState clusterState, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        if (!checkCollectionKeyExistence(message)) return clusterState;\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        List<String> shardNames  = new ArrayList<>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = clusterState.hasCollection(collection);\n        if (!collectionExists && numShards!=null) {\n          getShardNames(numShards, shardNames);\n          clusterState = createCollection(clusterState, collection, shardNames, message);\n        }\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(clusterState, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, clusterState);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n              coreNodeName);\n        }\n\n        // use the provided non null shardId\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(clusterState, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = clusterState.getCollection(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, clusterState, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = clusterState.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n          String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            clusterState = checkAndCompleteShardSplit(clusterState, collection, coreNodeName, sliceName, replicaProps);\n            // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n            slice = clusterState.getSlice(collection, sliceName);\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<>(1);\n            sliceProps = new HashMap<>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n            sliceProps.put(Slice.PARENT, shardParent);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(clusterState, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4c07fa58a256dccf8b95364855fd5e9ad4d1401","date":1404386015,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState clusterState, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        if (!checkCollectionKeyExistence(message)) return clusterState;\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        List<String> shardNames  = new ArrayList<>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = clusterState.hasCollection(collection);\n        if (!collectionExists && numShards!=null) {\n          getShardNames(numShards, shardNames);\n          clusterState = createCollection(clusterState, collection, shardNames, message);\n        }\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(clusterState, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, clusterState);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n              coreNodeName);\n        }\n\n        // use the provided non null shardId\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(clusterState, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = clusterState.getCollection(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, clusterState, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = clusterState.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n          String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            clusterState = checkAndCompleteShardSplit(clusterState, collection, coreNodeName, sliceName, replicaProps);\n            // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n            slice = clusterState.getSlice(collection, sliceName);\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<>(1);\n            sliceProps = new HashMap<>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n            sliceProps.put(Slice.PARENT, shardParent);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(clusterState, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState clusterState, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        if (!checkCollectionKeyExistence(message)) return clusterState;\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        List<String> shardNames  = new ArrayList<>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = clusterState.hasCollection(collection);\n        if (!collectionExists && numShards!=null) {\n          getShardNames(numShards, shardNames);\n          clusterState = createCollection(clusterState, collection, shardNames, message);\n        }\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(clusterState, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, clusterState);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n              coreNodeName);\n        }\n\n        // use the provided non null shardId\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(clusterState, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = clusterState.getCollection(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, clusterState, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = clusterState.getSlice(collection, sliceName);\n\n        Map<String,Object> replicaProps = new LinkedHashMap<>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n\n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n          String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            clusterState = checkAndCompleteShardSplit(clusterState, collection, coreNodeName, sliceName, replicaProps);\n            // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n            slice = clusterState.getSlice(collection, sliceName);\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<>(1);\n            sliceProps = new HashMap<>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n            sliceProps.put(Slice.PARENT, shardParent);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(clusterState, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9279b175e5e66258442d2123a50f052219a9cc1b","date":1410531077,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState clusterState, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        if (!checkCollectionKeyExistence(message)) return clusterState;\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        List<String> shardNames  = new ArrayList<>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = clusterState.hasCollection(collection);\n        if (!collectionExists && numShards!=null) {\n          getShardNames(numShards, shardNames);\n          clusterState = createCollection(clusterState, collection, shardNames, message);\n        }\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(clusterState, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, clusterState);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n              coreNodeName);\n        }\n\n        // use the provided non null shardId\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(clusterState, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = clusterState.getCollection(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, clusterState, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = clusterState.getSlice(collection, sliceName);\n\n        Map<String,Object> replicaProps = new LinkedHashMap<>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n\n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n          String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            clusterState = checkAndCompleteShardSplit(clusterState, collection, coreNodeName, sliceName, replicaProps);\n            // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n            slice = clusterState.getSlice(collection, sliceName);\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<>(1);\n            sliceProps = new HashMap<>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n            sliceProps.put(Slice.PARENT, shardParent);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(clusterState, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState clusterState, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        if (!checkCollectionKeyExistence(message)) return clusterState;\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        List<String> shardNames  = new ArrayList<>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = clusterState.hasCollection(collection);\n        if (!collectionExists && numShards!=null) {\n          getShardNames(numShards, shardNames);\n          clusterState = createCollection(clusterState, collection, shardNames, message);\n        }\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(clusterState, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, clusterState);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n              coreNodeName);\n        }\n\n        // use the provided non null shardId\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(clusterState, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = clusterState.getCollection(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, clusterState, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = clusterState.getSlice(collection, sliceName);\n        \n        Map<String,Object> replicaProps = new LinkedHashMap<>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n          \n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n          String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            clusterState = checkAndCompleteShardSplit(clusterState, collection, coreNodeName, sliceName, replicaProps);\n            // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n            slice = clusterState.getSlice(collection, sliceName);\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<>(1);\n            sliceProps = new HashMap<>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n            sliceProps.put(Slice.PARENT, shardParent);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(clusterState, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"64707d25b6352cf02909d3916038a3b3cec7f0a8","date":1412782122,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState clusterState, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        if (!checkCollectionKeyExistence(message)) return clusterState;\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        List<String> shardNames  = new ArrayList<>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = clusterState.hasCollection(collection);\n        if (!collectionExists && numShards!=null) {\n          getShardNames(numShards, shardNames);\n          clusterState = createCollection(clusterState, collection, shardNames, message);\n        }\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(clusterState, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, clusterState);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n              coreNodeName);\n        }\n\n        // use the provided non null shardId\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(clusterState, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = clusterState.getCollection(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, clusterState, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = clusterState.getSlice(collection, sliceName);\n\n        Map<String,Object> replicaProps = new LinkedHashMap<>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null) {\n            if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n              replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n            }\n            // Move custom props over.\n            for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n              if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n                replicaProps.put(ent.getKey(), ent.getValue());\n              }\n            }\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n\n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n          String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            clusterState = checkAndCompleteShardSplit(clusterState, collection, coreNodeName, sliceName, replicaProps);\n            // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n            slice = clusterState.getSlice(collection, sliceName);\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<>(1);\n            sliceProps = new HashMap<>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n            sliceProps.put(Slice.PARENT, shardParent);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(clusterState, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState clusterState, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        if (!checkCollectionKeyExistence(message)) return clusterState;\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        List<String> shardNames  = new ArrayList<>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = clusterState.hasCollection(collection);\n        if (!collectionExists && numShards!=null) {\n          getShardNames(numShards, shardNames);\n          clusterState = createCollection(clusterState, collection, shardNames, message);\n        }\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(clusterState, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, clusterState);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n              coreNodeName);\n        }\n\n        // use the provided non null shardId\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(clusterState, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = clusterState.getCollection(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, clusterState, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = clusterState.getSlice(collection, sliceName);\n\n        Map<String,Object> replicaProps = new LinkedHashMap<>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n\n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n          String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            clusterState = checkAndCompleteShardSplit(clusterState, collection, coreNodeName, sliceName, replicaProps);\n            // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n            slice = clusterState.getSlice(collection, sliceName);\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<>(1);\n            sliceProps = new HashMap<>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n            sliceProps.put(Slice.PARENT, shardParent);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(clusterState, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState clusterState, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        if (!checkCollectionKeyExistence(message)) return clusterState;\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        List<String> shardNames  = new ArrayList<>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = clusterState.hasCollection(collection);\n        if (!collectionExists && numShards!=null) {\n          getShardNames(numShards, shardNames);\n          clusterState = createCollection(clusterState, collection, shardNames, message);\n        }\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(clusterState, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, clusterState);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n              coreNodeName);\n        }\n\n        // use the provided non null shardId\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(clusterState, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = clusterState.getCollection(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, clusterState, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = clusterState.getSlice(collection, sliceName);\n\n        Map<String,Object> replicaProps = new LinkedHashMap<>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null) {\n            if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n              replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n            }\n            // Move custom props over.\n            for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n              if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n                replicaProps.put(ent.getKey(), ent.getValue());\n              }\n            }\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n\n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n          String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            clusterState = checkAndCompleteShardSplit(clusterState, collection, coreNodeName, sliceName, replicaProps);\n            // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n            slice = clusterState.getSlice(collection, sliceName);\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<>(1);\n            sliceProps = new HashMap<>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n            sliceProps.put(Slice.PARENT, shardParent);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(clusterState, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState clusterState, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        if (!checkCollectionKeyExistence(message)) return clusterState;\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        List<String> shardNames  = new ArrayList<>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = clusterState.hasCollection(collection);\n        if (!collectionExists && numShards!=null) {\n          getShardNames(numShards, shardNames);\n          clusterState = createCollection(clusterState, collection, shardNames, message);\n        }\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(clusterState, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, clusterState);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n              coreNodeName);\n        }\n\n        // use the provided non null shardId\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(clusterState, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = clusterState.getCollection(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, clusterState, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = clusterState.getSlice(collection, sliceName);\n\n        Map<String,Object> replicaProps = new LinkedHashMap<>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n            replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n\n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n          String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            clusterState = checkAndCompleteShardSplit(clusterState, collection, coreNodeName, sliceName, replicaProps);\n            // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n            slice = clusterState.getSlice(collection, sliceName);\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<>(1);\n            sliceProps = new HashMap<>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n            sliceProps.put(Slice.PARENT, shardParent);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(clusterState, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bfb6f3c8c119796b6a4ca83753599e3064b65305","date":1416760830,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState clusterState, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        if (!checkCollectionKeyExistence(message)) return clusterState;\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n\n        List<String> shardNames  = new ArrayList<>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = clusterState.hasCollection(collection);\n        if (!collectionExists && numShards!=null) {\n          getShardNames(numShards, shardNames);\n          clusterState = createCollection(clusterState, collection, shardNames, message);\n        }\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(clusterState, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, clusterState);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n              coreNodeName);\n        }\n\n        // use the provided non null shardId\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(clusterState, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = clusterState.getCollection(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, clusterState, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = clusterState.getSlice(collection, sliceName);\n\n        Map<String,Object> replicaProps = new LinkedHashMap<>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null) {\n            if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n              replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n            }\n            // Move custom props over.\n            for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n              if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n                replicaProps.put(ent.getKey(), ent.getValue());\n              }\n            }\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n\n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n          String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            clusterState = checkAndCompleteShardSplit(clusterState, collection, coreNodeName, sliceName, replicaProps);\n            // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n            slice = clusterState.getSlice(collection, sliceName);\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<>(1);\n            sliceProps = new HashMap<>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n            sliceProps.put(Slice.PARENT, shardParent);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(clusterState, collection, slice);\n          return newClusterState;\n      }\n\n","sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState clusterState, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        if (!checkCollectionKeyExistence(message)) return clusterState;\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n        log.info(\"Update state numShards={} message={}\", numShards, message);\n\n        List<String> shardNames  = new ArrayList<>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = clusterState.hasCollection(collection);\n        if (!collectionExists && numShards!=null) {\n          getShardNames(numShards, shardNames);\n          clusterState = createCollection(clusterState, collection, shardNames, message);\n        }\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(clusterState, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, clusterState);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n              coreNodeName);\n        }\n\n        // use the provided non null shardId\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(clusterState, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = clusterState.getCollection(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, clusterState, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = clusterState.getSlice(collection, sliceName);\n\n        Map<String,Object> replicaProps = new LinkedHashMap<>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null) {\n            if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n              replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n            }\n            // Move custom props over.\n            for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n              if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n                replicaProps.put(ent.getKey(), ent.getValue());\n              }\n            }\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n\n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n          String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            clusterState = checkAndCompleteShardSplit(clusterState, collection, coreNodeName, sliceName, replicaProps);\n            // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n            slice = clusterState.getSlice(collection, sliceName);\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<>(1);\n            sliceProps = new HashMap<>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n            sliceProps.put(Slice.PARENT, shardParent);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(clusterState, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"24a5da2a0d397ff29f3de8f6cf451d3412c2509a","date":1417276391,"type":4,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/Overseer.ClusterStateUpdater#updateState(ClusterState,ZkNodeProps).mjava","sourceNew":null,"sourceOld":"      /**\n       * Try to assign core to the cluster. \n       */\n      private ClusterState updateState(ClusterState clusterState, final ZkNodeProps message) {\n        final String collection = message.getStr(ZkStateReader.COLLECTION_PROP);\n        if (!checkCollectionKeyExistence(message)) return clusterState;\n        Integer numShards = message.getInt(ZkStateReader.NUM_SHARDS_PROP, null);\n\n        List<String> shardNames  = new ArrayList<>();\n\n        //collection does not yet exist, create placeholders if num shards is specified\n        boolean collectionExists = clusterState.hasCollection(collection);\n        if (!collectionExists && numShards!=null) {\n          getShardNames(numShards, shardNames);\n          clusterState = createCollection(clusterState, collection, shardNames, message);\n        }\n        String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);\n\n        String coreNodeName = message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);\n        if (coreNodeName == null) {\n          coreNodeName = getAssignedCoreNodeName(clusterState, message);\n          if (coreNodeName != null) {\n            log.info(\"node=\" + coreNodeName + \" is already registered\");\n          } else {\n            // if coreNodeName is null, auto assign one\n            coreNodeName = Assign.assignNode(collection, clusterState);\n          }\n          message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,\n              coreNodeName);\n        }\n\n        // use the provided non null shardId\n        if (sliceName == null) {\n          //get shardId from ClusterState\n          sliceName = getAssignedId(clusterState, coreNodeName, message);\n          if (sliceName != null) {\n            log.info(\"shard=\" + sliceName + \" is already registered\");\n          }\n        }\n        if(sliceName == null) {\n          //request new shardId \n          if (collectionExists) {\n            // use existing numShards\n            numShards = clusterState.getCollection(collection).getSlices().size();\n            log.info(\"Collection already exists with \" + ZkStateReader.NUM_SHARDS_PROP + \"=\" + numShards);\n          }\n          sliceName = Assign.assignShard(collection, clusterState, numShards);\n          log.info(\"Assigning new node to shard shard=\" + sliceName);\n        }\n\n        Slice slice = clusterState.getSlice(collection, sliceName);\n\n        Map<String,Object> replicaProps = new LinkedHashMap<>();\n\n        replicaProps.putAll(message.getProperties());\n        // System.out.println(\"########## UPDATE MESSAGE: \" + JSONUtil.toJSON(message));\n        if (slice != null) {\n          Replica oldReplica = slice.getReplicasMap().get(coreNodeName);\n          if (oldReplica != null) {\n            if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {\n              replicaProps.put(ZkStateReader.LEADER_PROP, oldReplica.get(ZkStateReader.LEADER_PROP));\n            }\n            // Move custom props over.\n            for (Map.Entry<String, Object> ent : oldReplica.getProperties().entrySet()) {\n              if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {\n                replicaProps.put(ent.getKey(), ent.getValue());\n              }\n            }\n          }\n        }\n\n        // we don't put these in the clusterstate\n          replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          replicaProps.remove(ZkStateReader.SHARD_ID_PROP);\n          replicaProps.remove(ZkStateReader.COLLECTION_PROP);\n          replicaProps.remove(QUEUE_OPERATION);\n\n          // remove any props with null values\n          Set<Entry<String,Object>> entrySet = replicaProps.entrySet();\n          List<String> removeKeys = new ArrayList<>();\n          for (Entry<String,Object> entry : entrySet) {\n            if (entry.getValue() == null) {\n              removeKeys.add(entry.getKey());\n            }\n          }\n          for (String removeKey : removeKeys) {\n            replicaProps.remove(removeKey);\n          }\n          replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);\n          // remove shard specific properties\n          String shardRange = (String) replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);\n          String shardState = (String) replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);\n          String shardParent = (String) replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);\n\n\n          Replica replica = new Replica(coreNodeName, replicaProps);\n\n         // TODO: where do we get slice properties in this message?  or should there be a separate create-slice message if we want that?\n\n          Map<String,Object> sliceProps = null;\n          Map<String,Replica> replicas;\n\n          if (slice != null) {\n            clusterState = checkAndCompleteShardSplit(clusterState, collection, coreNodeName, sliceName, replicaProps);\n            // get the current slice again because it may have been updated due to checkAndCompleteShardSplit method\n            slice = clusterState.getSlice(collection, sliceName);\n            sliceProps = slice.getProperties();\n            replicas = slice.getReplicasCopy();\n          } else {\n            replicas = new HashMap<>(1);\n            sliceProps = new HashMap<>();\n            sliceProps.put(Slice.RANGE, shardRange);\n            sliceProps.put(Slice.STATE, shardState);\n            sliceProps.put(Slice.PARENT, shardParent);\n          }\n\n          replicas.put(replica.getName(), replica);\n          slice = new Slice(sliceName, replicas, sliceProps);\n\n          ClusterState newClusterState = updateSlice(clusterState, collection, slice);\n          return newClusterState;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ea066add3bcc9f5b952f08999880ff9704e5ba48":["cdc8313ba7bdaaa48ff54059d0eabff4436ab175"],"96ea64d994d340044e0d57aeb6a5871539d10ca5":["ea066add3bcc9f5b952f08999880ff9704e5ba48","6df412542f3e2161f4bc2b13357b4a973195bfb7"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["0beaed456aa3358e5e4a99ea2aea994ef6c81de3","660ba5d2f171f4cff12238ecf42746100549ce63"],"64707d25b6352cf02909d3916038a3b3cec7f0a8":["9279b175e5e66258442d2123a50f052219a9cc1b"],"1eeda7e62e149f90eee8895af874c74efa7d4852":["660ba5d2f171f4cff12238ecf42746100549ce63"],"29f5eaf296600e1665151e7929d42a3cbe22e481":["ea066add3bcc9f5b952f08999880ff9704e5ba48"],"24a5da2a0d397ff29f3de8f6cf451d3412c2509a":["bfb6f3c8c119796b6a4ca83753599e3064b65305"],"bc841231667f1f315bae6799c068f9aad6543967":["1b891e9f867c36643e4dffe81653ecb336ac50dd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f2126b84bd093fa3d921582a109a0ee578c28126":["7e7d59baa18f0aed2bb5f93a76ffce5343aee13d","1525b4dfbc0d413b8d7247da232009778e624836"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6df412542f3e2161f4bc2b13357b4a973195bfb7"],"55980207f1977bd1463465de1659b821347e2fa8":["9279b175e5e66258442d2123a50f052219a9cc1b","64707d25b6352cf02909d3916038a3b3cec7f0a8"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["37a0f60745e53927c4c876cfe5b5a58170f0646c","1eeda7e62e149f90eee8895af874c74efa7d4852"],"993d0b0d77c623d30cb24cdadbff9bb3b5f516bb":["1eeda7e62e149f90eee8895af874c74efa7d4852"],"bfb6f3c8c119796b6a4ca83753599e3064b65305":["64707d25b6352cf02909d3916038a3b3cec7f0a8"],"7e7d59baa18f0aed2bb5f93a76ffce5343aee13d":["fa64435b5902ce266c23755a4a00691a3285dab8"],"fa64435b5902ce266c23755a4a00691a3285dab8":["3f767f8c99eaedb984df754fe61f21c5de260f94"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","993d0b0d77c623d30cb24cdadbff9bb3b5f516bb"],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"407687e67faf6e1f02a211ca078d8e3eed631027":["1525b4dfbc0d413b8d7247da232009778e624836","c5a558d54519c651068ddb202f03befefb1514a7"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3f767f8c99eaedb984df754fe61f21c5de260f94"],"0beaed456aa3358e5e4a99ea2aea994ef6c81de3":["cb4a195b8dc1808cd01748bd2e0fba26ca915d4d"],"9279b175e5e66258442d2123a50f052219a9cc1b":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["0beaed456aa3358e5e4a99ea2aea994ef6c81de3"],"3f767f8c99eaedb984df754fe61f21c5de260f94":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a6f693ed86f289b2e42b46684409b3997f2c264a":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"660ba5d2f171f4cff12238ecf42746100549ce63":["849494cf2f3a96af5c8c84995108ddd8456fcd04"],"c5a558d54519c651068ddb202f03befefb1514a7":["0a3053de358cec5245047361c5d9cf20e67225d5"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3f767f8c99eaedb984df754fe61f21c5de260f94"],"6df412542f3e2161f4bc2b13357b4a973195bfb7":["29f5eaf296600e1665151e7929d42a3cbe22e481"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["40dce2b6d4360eb09fa16fb6c40a18b25507ed73","cdc8313ba7bdaaa48ff54059d0eabff4436ab175"],"0a3053de358cec5245047361c5d9cf20e67225d5":["1525b4dfbc0d413b8d7247da232009778e624836"],"40dce2b6d4360eb09fa16fb6c40a18b25507ed73":["bc841231667f1f315bae6799c068f9aad6543967"],"1b891e9f867c36643e4dffe81653ecb336ac50dd":["993d0b0d77c623d30cb24cdadbff9bb3b5f516bb"],"cb4a195b8dc1808cd01748bd2e0fba26ca915d4d":["c5a558d54519c651068ddb202f03befefb1514a7"],"1525b4dfbc0d413b8d7247da232009778e624836":["7e7d59baa18f0aed2bb5f93a76ffce5343aee13d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a"],"cdc8313ba7bdaaa48ff54059d0eabff4436ab175":["40dce2b6d4360eb09fa16fb6c40a18b25507ed73"]},"commit2Childs":{"ea066add3bcc9f5b952f08999880ff9704e5ba48":["96ea64d994d340044e0d57aeb6a5871539d10ca5","29f5eaf296600e1665151e7929d42a3cbe22e481"],"96ea64d994d340044e0d57aeb6a5871539d10ca5":[],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec"],"64707d25b6352cf02909d3916038a3b3cec7f0a8":["55980207f1977bd1463465de1659b821347e2fa8","bfb6f3c8c119796b6a4ca83753599e3064b65305"],"1eeda7e62e149f90eee8895af874c74efa7d4852":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","993d0b0d77c623d30cb24cdadbff9bb3b5f516bb"],"29f5eaf296600e1665151e7929d42a3cbe22e481":["6df412542f3e2161f4bc2b13357b4a973195bfb7"],"24a5da2a0d397ff29f3de8f6cf451d3412c2509a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bc841231667f1f315bae6799c068f9aad6543967":["40dce2b6d4360eb09fa16fb6c40a18b25507ed73"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8fd5be977c105554c6a7b68afcdbc511439723ab","3f767f8c99eaedb984df754fe61f21c5de260f94","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"f2126b84bd093fa3d921582a109a0ee578c28126":[],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"55980207f1977bd1463465de1659b821347e2fa8":[],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576"],"993d0b0d77c623d30cb24cdadbff9bb3b5f516bb":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","1b891e9f867c36643e4dffe81653ecb336ac50dd"],"bfb6f3c8c119796b6a4ca83753599e3064b65305":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a"],"7e7d59baa18f0aed2bb5f93a76ffce5343aee13d":["f2126b84bd093fa3d921582a109a0ee578c28126","1525b4dfbc0d413b8d7247da232009778e624836"],"fa64435b5902ce266c23755a4a00691a3285dab8":["7e7d59baa18f0aed2bb5f93a76ffce5343aee13d"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["9279b175e5e66258442d2123a50f052219a9cc1b"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"8fd5be977c105554c6a7b68afcdbc511439723ab":[],"0beaed456aa3358e5e4a99ea2aea994ef6c81de3":["37a0f60745e53927c4c876cfe5b5a58170f0646c","849494cf2f3a96af5c8c84995108ddd8456fcd04"],"9279b175e5e66258442d2123a50f052219a9cc1b":["64707d25b6352cf02909d3916038a3b3cec7f0a8","55980207f1977bd1463465de1659b821347e2fa8"],"3f767f8c99eaedb984df754fe61f21c5de260f94":["fa64435b5902ce266c23755a4a00691a3285dab8","8fd5be977c105554c6a7b68afcdbc511439723ab","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["660ba5d2f171f4cff12238ecf42746100549ce63"],"a6f693ed86f289b2e42b46684409b3997f2c264a":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"],"660ba5d2f171f4cff12238ecf42746100549ce63":["37a0f60745e53927c4c876cfe5b5a58170f0646c","1eeda7e62e149f90eee8895af874c74efa7d4852"],"c5a558d54519c651068ddb202f03befefb1514a7":["407687e67faf6e1f02a211ca078d8e3eed631027","cb4a195b8dc1808cd01748bd2e0fba26ca915d4d"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"6df412542f3e2161f4bc2b13357b4a973195bfb7":["96ea64d994d340044e0d57aeb6a5871539d10ca5","634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"0a3053de358cec5245047361c5d9cf20e67225d5":["c5a558d54519c651068ddb202f03befefb1514a7"],"40dce2b6d4360eb09fa16fb6c40a18b25507ed73":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","cdc8313ba7bdaaa48ff54059d0eabff4436ab175"],"1b891e9f867c36643e4dffe81653ecb336ac50dd":["bc841231667f1f315bae6799c068f9aad6543967"],"cb4a195b8dc1808cd01748bd2e0fba26ca915d4d":["0beaed456aa3358e5e4a99ea2aea994ef6c81de3"],"1525b4dfbc0d413b8d7247da232009778e624836":["f2126b84bd093fa3d921582a109a0ee578c28126","407687e67faf6e1f02a211ca078d8e3eed631027","0a3053de358cec5245047361c5d9cf20e67225d5"],"cdc8313ba7bdaaa48ff54059d0eabff4436ab175":["ea066add3bcc9f5b952f08999880ff9704e5ba48","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["96ea64d994d340044e0d57aeb6a5871539d10ca5","f2126b84bd093fa3d921582a109a0ee578c28126","55980207f1977bd1463465de1659b821347e2fa8","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","407687e67faf6e1f02a211ca078d8e3eed631027","8fd5be977c105554c6a7b68afcdbc511439723ab","d6f074e73200c07d54f242d3880a8da5a35ff97b","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}