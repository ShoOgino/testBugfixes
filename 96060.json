{"path":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput2().mjava","commits":[{"id":"c024a3e8fec0a081cbf9539845db12f0dc84d029","date":1376654698,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput2().mjava","pathOld":"/dev/null","sourceNew":"  // Writes random byte/s into PagedBytes via\n  // .getDataOutput(), then verifies with\n  // PagedBytes.getDataInput(): \n  public void testDataInputOutput2() throws Exception {\n    Random random = random();\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      final int blockBits = _TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final DataOutput out = p.getDataOutput();\n      final int numBytes = random().nextInt(10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final DataInput in = p.getDataInput();\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["71da933d30aea361ccc224d6544c451cbf49916d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2ceca04c06658aeb20e0a319ade784ad9a0576dd","date":1376662287,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput2().mjava","pathOld":"/dev/null","sourceNew":"  // Writes random byte/s into PagedBytes via\n  // .getDataOutput(), then verifies with\n  // PagedBytes.getDataInput(): \n  public void testDataInputOutput2() throws Exception {\n    Random random = random();\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      final int blockBits = _TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final DataOutput out = p.getDataOutput();\n      final int numBytes = random().nextInt(10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final DataInput in = p.getDataInput();\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":0,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput2().mjava","pathOld":"/dev/null","sourceNew":"  // Writes random byte/s into PagedBytes via\n  // .getDataOutput(), then verifies with\n  // PagedBytes.getDataInput(): \n  public void testDataInputOutput2() throws Exception {\n    Random random = random();\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      final int blockBits = _TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final DataOutput out = p.getDataOutput();\n      final int numBytes = random().nextInt(10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final DataInput in = p.getDataInput();\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput2().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput2().mjava","sourceNew":"  // Writes random byte/s into PagedBytes via\n  // .getDataOutput(), then verifies with\n  // PagedBytes.getDataInput(): \n  public void testDataInputOutput2() throws Exception {\n    Random random = random();\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      final int blockBits = TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final DataOutput out = p.getDataOutput();\n      final int numBytes = random().nextInt(10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final DataInput in = p.getDataInput();\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // Writes random byte/s into PagedBytes via\n  // .getDataOutput(), then verifies with\n  // PagedBytes.getDataInput(): \n  public void testDataInputOutput2() throws Exception {\n    Random random = random();\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      final int blockBits = _TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final DataOutput out = p.getDataOutput();\n      final int numBytes = random().nextInt(10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final DataInput in = p.getDataInput();\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"71da933d30aea361ccc224d6544c451cbf49916d","date":1579874339,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput2().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput2().mjava","sourceNew":"  // Writes random byte/s into PagedBytes via\n  // .getDataOutput(), then verifies with\n  // PagedBytes.getDataInput(): \n  public void testDataInputOutput2() throws Exception {\n    Random random = random();\n    int numIters = atLeast(1);\n    for(int iter=0;iter<numIters;iter++) {\n      final int blockBits = TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final DataOutput out = p.getDataOutput();\n      final int numBytes = random().nextInt(10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final DataInput in = p.getDataInput();\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // Writes random byte/s into PagedBytes via\n  // .getDataOutput(), then verifies with\n  // PagedBytes.getDataInput(): \n  public void testDataInputOutput2() throws Exception {\n    Random random = random();\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      final int blockBits = TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final DataOutput out = p.getDataOutput();\n      final int numBytes = random().nextInt(10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final DataInput in = p.getDataInput();\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n    }\n  }\n\n","bugFix":["c024a3e8fec0a081cbf9539845db12f0dc84d029"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5acb8730dbbbb0f88bb8db80769aa6e9b29d817b","date":1583461779,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput2().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput2().mjava","sourceNew":"  // Writes random byte/s into PagedBytes via\n  // .getDataOutput(), then verifies with\n  // PagedBytes.getDataInput(): \n  public void testDataInputOutput2() throws Exception {\n    Random random = random();\n    int numIters = atLeast(1);\n    for(int iter=0;iter<numIters;iter++) {\n      final int blockBits = TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final DataOutput out = p.getDataOutput();\n      final int numBytes;\n      if (TEST_NIGHTLY) {\n        numBytes = random().nextInt(10_000_000);\n      } else {\n        numBytes = random().nextInt(1_000_000);\n      }\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final DataInput in = p.getDataInput();\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // Writes random byte/s into PagedBytes via\n  // .getDataOutput(), then verifies with\n  // PagedBytes.getDataInput(): \n  public void testDataInputOutput2() throws Exception {\n    Random random = random();\n    int numIters = atLeast(1);\n    for(int iter=0;iter<numIters;iter++) {\n      final int blockBits = TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final DataOutput out = p.getDataOutput();\n      final int numBytes = random().nextInt(10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final DataInput in = p.getDataInput();\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6613659748fe4411a7dcf85266e55db1f95f7315":["c024a3e8fec0a081cbf9539845db12f0dc84d029"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c024a3e8fec0a081cbf9539845db12f0dc84d029"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c024a3e8fec0a081cbf9539845db12f0dc84d029":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5acb8730dbbbb0f88bb8db80769aa6e9b29d817b":["71da933d30aea361ccc224d6544c451cbf49916d"],"2ceca04c06658aeb20e0a319ade784ad9a0576dd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c024a3e8fec0a081cbf9539845db12f0dc84d029"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5acb8730dbbbb0f88bb8db80769aa6e9b29d817b"],"71da933d30aea361ccc224d6544c451cbf49916d":["6613659748fe4411a7dcf85266e55db1f95f7315"]},"commit2Childs":{"6613659748fe4411a7dcf85266e55db1f95f7315":["71da933d30aea361ccc224d6544c451cbf49916d"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","c024a3e8fec0a081cbf9539845db12f0dc84d029","2ceca04c06658aeb20e0a319ade784ad9a0576dd"],"c024a3e8fec0a081cbf9539845db12f0dc84d029":["6613659748fe4411a7dcf85266e55db1f95f7315","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","2ceca04c06658aeb20e0a319ade784ad9a0576dd"],"5acb8730dbbbb0f88bb8db80769aa6e9b29d817b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2ceca04c06658aeb20e0a319ade784ad9a0576dd":[],"71da933d30aea361ccc224d6544c451cbf49916d":["5acb8730dbbbb0f88bb8db80769aa6e9b29d817b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","2ceca04c06658aeb20e0a319ade784ad9a0576dd","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}