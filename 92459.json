{"path":"lucene/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","pathOld":"src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","sourceNew":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    final Random r = newRandom();\n\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, r);\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = File.createTempFile(\"IndexInput\", \"tmpFile\");\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(tmpInputFile,\n                                                inputBufferSize, 10), inputBufferSize, r);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(tmpInputFile,\n                                             inputBufferSize, 10), inputBufferSize, r);\n  }\n\n","sourceOld":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    final Random r = newRandom();\n\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, r);\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = File.createTempFile(\"IndexInput\", \"tmpFile\");\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(tmpInputFile,\n                                                inputBufferSize, 10), inputBufferSize, r);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(tmpInputFile,\n                                             inputBufferSize, 10), inputBufferSize, r);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1f653cfcf159baeaafe5d01682a911e95bba4012","date":1284122058,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","pathOld":"lucene/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","sourceNew":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, random);\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = File.createTempFile(\"IndexInput\", \"tmpFile\");\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(tmpInputFile,\n                                                inputBufferSize, 10), inputBufferSize, random);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(tmpInputFile,\n                                             inputBufferSize, 10), inputBufferSize, random);\n  }\n\n","sourceOld":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    final Random r = newRandom();\n\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, r);\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = File.createTempFile(\"IndexInput\", \"tmpFile\");\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(tmpInputFile,\n                                                inputBufferSize, 10), inputBufferSize, r);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(tmpInputFile,\n                                             inputBufferSize, 10), inputBufferSize, r);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","pathOld":"lucene/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","sourceNew":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, random);\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = File.createTempFile(\"IndexInput\", \"tmpFile\");\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(tmpInputFile,\n                                                inputBufferSize, 10), inputBufferSize, random);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(tmpInputFile,\n                                             inputBufferSize, 10), inputBufferSize, random);\n  }\n\n","sourceOld":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    final Random r = newRandom();\n\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, r);\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = File.createTempFile(\"IndexInput\", \"tmpFile\");\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(tmpInputFile,\n                                                inputBufferSize, 10), inputBufferSize, r);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(tmpInputFile,\n                                             inputBufferSize, 10), inputBufferSize, r);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e538cbd7f572f646f36c73053aea561d95c2cb2","date":1306660868,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","pathOld":"lucene/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","sourceNew":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, random);\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = _TestUtil.createTempFile(\"IndexInput\", \"tmpFile\", TEMP_DIR);\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(tmpInputFile,\n                                                inputBufferSize, 10), inputBufferSize, random);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(tmpInputFile,\n                                             inputBufferSize, 10), inputBufferSize, random);\n  }\n\n","sourceOld":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, random);\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = File.createTempFile(\"IndexInput\", \"tmpFile\");\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(tmpInputFile,\n                                                inputBufferSize, 10), inputBufferSize, random);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(tmpInputFile,\n                                             inputBufferSize, 10), inputBufferSize, random);\n  }\n\n","bugFix":["37cdff042fc21a4f3d9c437c1022deac5d3bab72"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","pathOld":"lucene/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","sourceNew":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, random);\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = _TestUtil.createTempFile(\"IndexInput\", \"tmpFile\", TEMP_DIR);\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(tmpInputFile,\n                                                inputBufferSize, 10), inputBufferSize, random);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(tmpInputFile,\n                                             inputBufferSize, 10), inputBufferSize, random);\n  }\n\n","sourceOld":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, random);\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = File.createTempFile(\"IndexInput\", \"tmpFile\");\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(tmpInputFile,\n                                                inputBufferSize, 10), inputBufferSize, random);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(tmpInputFile,\n                                             inputBufferSize, 10), inputBufferSize, random);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e10cb22a8bdb44339e282925a29182bb2f3174d","date":1306841137,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","pathOld":"lucene/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","sourceNew":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, random);\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = _TestUtil.createTempFile(\"IndexInput\", \"tmpFile\", TEMP_DIR);\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(tmpInputFile,\n                                                inputBufferSize, 10), inputBufferSize, random);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(tmpInputFile,\n                                             inputBufferSize, 10), inputBufferSize, random);\n  }\n\n","sourceOld":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, random);\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = File.createTempFile(\"IndexInput\", \"tmpFile\");\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(tmpInputFile,\n                                                inputBufferSize, 10), inputBufferSize, random);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(tmpInputFile,\n                                             inputBufferSize, 10), inputBufferSize, random);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"639c36565ce03aed5b0fce7c9e4448e53a1f7efd","date":1308580104,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","pathOld":"lucene/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","sourceNew":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, random);\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = _TestUtil.createTempFile(\"IndexInput\", \"tmpFile\", TEMP_DIR);\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(tmpInputFile,\n                                                IOContext.DEFAULT, 10), inputBufferSize, random);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(tmpInputFile,\n                                             IOContext.DEFAULT, 10), inputBufferSize, random);\n  }\n\n","sourceOld":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, random);\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = _TestUtil.createTempFile(\"IndexInput\", \"tmpFile\", TEMP_DIR);\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(tmpInputFile,\n                                                inputBufferSize, 10), inputBufferSize, random);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(tmpInputFile,\n                                             inputBufferSize, 10), inputBufferSize, random);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6f9be74ca7baaef11857ad002cad40419979516","date":1309449808,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","pathOld":"lucene/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","sourceNew":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, random);\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = _TestUtil.createTempFile(\"IndexInput\", \"tmpFile\", TEMP_DIR);\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(tmpInputFile,\n        newIOContext(random), 10), inputBufferSize, random);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(tmpInputFile,\n        newIOContext(random), 10), inputBufferSize, random);\n  }\n\n","sourceOld":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, random);\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = _TestUtil.createTempFile(\"IndexInput\", \"tmpFile\", TEMP_DIR);\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(tmpInputFile,\n                                                IOContext.DEFAULT, 10), inputBufferSize, random);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(tmpInputFile,\n                                             IOContext.DEFAULT, 10), inputBufferSize, random);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ddc4c914be86e34b54f70023f45a60fa7f04e929","date":1310115160,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","pathOld":"lucene/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","sourceNew":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, random);\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = _TestUtil.createTempFile(\"IndexInput\", \"tmpFile\", TEMP_DIR);\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(tmpInputFile,\n        newIOContext(random), 10), inputBufferSize, random);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(tmpInputFile,\n        newIOContext(random), 10), inputBufferSize, random);\n  }\n\n","sourceOld":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, random);\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = _TestUtil.createTempFile(\"IndexInput\", \"tmpFile\", TEMP_DIR);\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(tmpInputFile,\n                                                inputBufferSize, 10), inputBufferSize, random);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(tmpInputFile,\n                                             inputBufferSize, 10), inputBufferSize, random);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5d004d0e0b3f65bb40da76d476d659d7888270e8","date":1310158940,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","pathOld":"lucene/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","sourceNew":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, random);\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = _TestUtil.createTempFile(\"IndexInput\", \"tmpFile\", TEMP_DIR);\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(tmpInputFile,\n        newIOContext(random), 10), inputBufferSize, random);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(tmpInputFile,\n        newIOContext(random), 10), inputBufferSize, random);\n  }\n\n","sourceOld":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, random);\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = _TestUtil.createTempFile(\"IndexInput\", \"tmpFile\", TEMP_DIR);\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(tmpInputFile,\n                                                inputBufferSize, 10), inputBufferSize, random);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(tmpInputFile,\n                                             inputBufferSize, 10), inputBufferSize, random);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f1efe3edca215dd9891cb42af283fed96f792ca0","date":1320428891,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","pathOld":"lucene/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","sourceNew":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, random);\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = _TestUtil.createTempFile(\"IndexInput\", \"tmpFile\", TEMP_DIR);\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(\"SimpleFSIndexInput(path=\\\"\" + tmpInputFile + \"\\\")\", tmpInputFile,\n        newIOContext(random), 10), inputBufferSize, random);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(tmpInputFile,\n        newIOContext(random), 10), inputBufferSize, random);\n  }\n\n","sourceOld":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, random);\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = _TestUtil.createTempFile(\"IndexInput\", \"tmpFile\", TEMP_DIR);\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(tmpInputFile,\n        newIOContext(random), 10), inputBufferSize, random);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(tmpInputFile,\n        newIOContext(random), 10), inputBufferSize, random);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","pathOld":"lucene/src/test/org/apache/lucene/store/TestBufferedIndexInput#testReadBytes().mjava","sourceNew":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, random);\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = _TestUtil.createTempFile(\"IndexInput\", \"tmpFile\", TEMP_DIR);\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(\"SimpleFSIndexInput(path=\\\"\" + tmpInputFile + \"\\\")\", tmpInputFile,\n        newIOContext(random), 10), inputBufferSize, random);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(tmpInputFile,\n        newIOContext(random), 10), inputBufferSize, random);\n  }\n\n","sourceOld":"  // Call readBytes() repeatedly, with various chunk sizes (from 1 byte to\n  // larger than the buffer size), and see that it returns the bytes we expect.\n  // Our input comes from a dynamically generated \"file\" -\n  // see MyBufferedIndexInput below.\n  public void testReadBytes() throws Exception {\n    MyBufferedIndexInput input = new MyBufferedIndexInput();\n    runReadBytes(input, BufferedIndexInput.BUFFER_SIZE, random);\n\n    // This tests the workaround code for LUCENE-1566 where readBytesInternal\n    // provides a workaround for a JVM Bug that incorrectly raises a OOM Error\n    // when a large byte buffer is passed to a file read.\n    // NOTE: this does only test the chunked reads and NOT if the Bug is triggered.\n    //final int tmpFileSize = 1024 * 1024 * 5;\n    final int inputBufferSize = 128;\n    File tmpInputFile = _TestUtil.createTempFile(\"IndexInput\", \"tmpFile\", TEMP_DIR);\n    tmpInputFile.deleteOnExit();\n    writeBytes(tmpInputFile, TEST_FILE_LENGTH);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new SimpleFSIndexInput(\"SimpleFSIndexInput(path=\\\"\" + tmpInputFile + \"\\\")\", tmpInputFile,\n        newIOContext(random), 10), inputBufferSize, random);\n\n    // run test with chunk size of 10 bytes\n    runReadBytesAndClose(new NIOFSIndexInput(tmpInputFile,\n        newIOContext(random), 10), inputBufferSize, random);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["f1efe3edca215dd9891cb42af283fed96f792ca0"],"f1efe3edca215dd9891cb42af283fed96f792ca0":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"1e538cbd7f572f646f36c73053aea561d95c2cb2":["1f653cfcf159baeaafe5d01682a911e95bba4012"],"639c36565ce03aed5b0fce7c9e4448e53a1f7efd":["1e538cbd7f572f646f36c73053aea561d95c2cb2"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["9454a6510e2db155fb01faa5c049b06ece95fab9","1f653cfcf159baeaafe5d01682a911e95bba4012"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["1f653cfcf159baeaafe5d01682a911e95bba4012","1e538cbd7f572f646f36c73053aea561d95c2cb2"],"1f653cfcf159baeaafe5d01682a911e95bba4012":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b6f9be74ca7baaef11857ad002cad40419979516":["639c36565ce03aed5b0fce7c9e4448e53a1f7efd"],"5d004d0e0b3f65bb40da76d476d659d7888270e8":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","ddc4c914be86e34b54f70023f45a60fa7f04e929"],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["1e538cbd7f572f646f36c73053aea561d95c2cb2","b6f9be74ca7baaef11857ad002cad40419979516"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2e10cb22a8bdb44339e282925a29182bb2f3174d":["1f653cfcf159baeaafe5d01682a911e95bba4012","1e538cbd7f572f646f36c73053aea561d95c2cb2"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f1efe3edca215dd9891cb42af283fed96f792ca0":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"1e538cbd7f572f646f36c73053aea561d95c2cb2":["639c36565ce03aed5b0fce7c9e4448e53a1f7efd","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","ddc4c914be86e34b54f70023f45a60fa7f04e929","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"639c36565ce03aed5b0fce7c9e4448e53a1f7efd":["b6f9be74ca7baaef11857ad002cad40419979516"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["5d004d0e0b3f65bb40da76d476d659d7888270e8"],"1f653cfcf159baeaafe5d01682a911e95bba4012":["1e538cbd7f572f646f36c73053aea561d95c2cb2","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"b6f9be74ca7baaef11857ad002cad40419979516":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"5d004d0e0b3f65bb40da76d476d659d7888270e8":[],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["f1efe3edca215dd9891cb42af283fed96f792ca0","5d004d0e0b3f65bb40da76d476d659d7888270e8"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","1f653cfcf159baeaafe5d01682a911e95bba4012"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"2e10cb22a8bdb44339e282925a29182bb2f3174d":[]},"heads":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","5d004d0e0b3f65bb40da76d476d659d7888270e8","cd5edd1f2b162a5cfa08efd17851a07373a96817","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}