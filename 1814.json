{"path":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50CompoundReader#Lucene50CompoundReader(Directory,SegmentInfo,IOContext).mjava","commits":[{"id":"9c34e07420c03a037d73169b35f349c2ad6fd8c7","date":1412304383,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50CompoundReader#Lucene50CompoundReader(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50CompoundReader#Lucene50CompoundReader(byte[],Directory,String,IOContext).mjava","sourceNew":"  /**\n   * Create a new CompoundFileDirectory.\n   */\n  public Lucene50CompoundReader(Directory directory, SegmentInfo si, IOContext context) throws IOException {\n    this.directory = directory;\n    this.segmentName = si.name;\n    String dataFileName = IndexFileNames.segmentFileName(segmentName, \"\", Lucene50CompoundFormat.DATA_EXTENSION);\n    String entriesFileName = IndexFileNames.segmentFileName(segmentName, \"\", Lucene50CompoundFormat.ENTRIES_EXTENSION);\n    this.entries = readEntries(si.getId(), directory, entriesFileName);\n    boolean success = false;\n    handle = directory.openInput(dataFileName, context);\n    try {\n      CodecUtil.checkSegmentHeader(handle, Lucene50CompoundFormat.DATA_CODEC, version, version, si.getId(), \"\");\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(handle);\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(handle);\n      }\n    }\n    this.isOpen = true;\n  }\n\n","sourceOld":"  /**\n   * Create a new CompoundFileDirectory.\n   */\n  public Lucene50CompoundReader(byte[] segmentID, Directory directory, String fileName, IOContext context) throws IOException {\n    this.directory = directory;\n    this.fileName = fileName;\n    this.entries = readEntries(segmentID, directory, fileName);\n    boolean success = false;\n    handle = directory.openInput(fileName, context);\n    try {\n      CodecUtil.checkSegmentHeader(handle, Lucene50CompoundFormat.DATA_CODEC, version, version, segmentID, \"\");\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(handle);\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(handle);\n      }\n    }\n    this.isOpen = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c761d502ca1f6c5324aa909468ebc4f761c92c1f","date":1412431978,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50CompoundReader#Lucene50CompoundReader(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50CompoundReader#Lucene50CompoundReader(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  /**\n   * Create a new CompoundFileDirectory.\n   */\n  // TODO: we should just pre-strip \"entries\" and append segment name up-front like simpletext?\n  // this need not be a \"general purpose\" directory anymore (it only writes index files)\n  public Lucene50CompoundReader(Directory directory, SegmentInfo si, IOContext context) throws IOException {\n    this.directory = directory;\n    this.segmentName = si.name;\n    String dataFileName = IndexFileNames.segmentFileName(segmentName, \"\", Lucene50CompoundFormat.DATA_EXTENSION);\n    String entriesFileName = IndexFileNames.segmentFileName(segmentName, \"\", Lucene50CompoundFormat.ENTRIES_EXTENSION);\n    this.entries = readEntries(si.getId(), directory, entriesFileName);\n    boolean success = false;\n    handle = directory.openInput(dataFileName, context);\n    try {\n      CodecUtil.checkSegmentHeader(handle, Lucene50CompoundFormat.DATA_CODEC, version, version, si.getId(), \"\");\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(handle);\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(handle);\n      }\n    }\n    this.isOpen = true;\n  }\n\n","sourceOld":"  /**\n   * Create a new CompoundFileDirectory.\n   */\n  public Lucene50CompoundReader(Directory directory, SegmentInfo si, IOContext context) throws IOException {\n    this.directory = directory;\n    this.segmentName = si.name;\n    String dataFileName = IndexFileNames.segmentFileName(segmentName, \"\", Lucene50CompoundFormat.DATA_EXTENSION);\n    String entriesFileName = IndexFileNames.segmentFileName(segmentName, \"\", Lucene50CompoundFormat.ENTRIES_EXTENSION);\n    this.entries = readEntries(si.getId(), directory, entriesFileName);\n    boolean success = false;\n    handle = directory.openInput(dataFileName, context);\n    try {\n      CodecUtil.checkSegmentHeader(handle, Lucene50CompoundFormat.DATA_CODEC, version, version, si.getId(), \"\");\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(handle);\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(handle);\n      }\n    }\n    this.isOpen = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9bb9a29a5e71a90295f175df8919802993142c9a","date":1412517673,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50CompoundReader#Lucene50CompoundReader(Directory,SegmentInfo,IOContext).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Create a new CompoundFileDirectory.\n   */\n  // TODO: we should just pre-strip \"entries\" and append segment name up-front like simpletext?\n  // this need not be a \"general purpose\" directory anymore (it only writes index files)\n  public Lucene50CompoundReader(Directory directory, SegmentInfo si, IOContext context) throws IOException {\n    this.directory = directory;\n    this.segmentName = si.name;\n    String dataFileName = IndexFileNames.segmentFileName(segmentName, \"\", Lucene50CompoundFormat.DATA_EXTENSION);\n    String entriesFileName = IndexFileNames.segmentFileName(segmentName, \"\", Lucene50CompoundFormat.ENTRIES_EXTENSION);\n    this.entries = readEntries(si.getId(), directory, entriesFileName);\n    boolean success = false;\n    handle = directory.openInput(dataFileName, context);\n    try {\n      CodecUtil.checkSegmentHeader(handle, Lucene50CompoundFormat.DATA_CODEC, version, version, si.getId(), \"\");\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(handle);\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(handle);\n      }\n    }\n    this.isOpen = true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3384e6013a93e4d11b7d75388693f8d0388602bf","date":1413951663,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50CompoundReader#Lucene50CompoundReader(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50CompoundReader#Lucene50CompoundReader(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  /**\n   * Create a new CompoundFileDirectory.\n   */\n  // TODO: we should just pre-strip \"entries\" and append segment name up-front like simpletext?\n  // this need not be a \"general purpose\" directory anymore (it only writes index files)\n  public Lucene50CompoundReader(Directory directory, SegmentInfo si, IOContext context) throws IOException {\n    this.directory = directory;\n    this.segmentName = si.name;\n    String dataFileName = IndexFileNames.segmentFileName(segmentName, \"\", Lucene50CompoundFormat.DATA_EXTENSION);\n    String entriesFileName = IndexFileNames.segmentFileName(segmentName, \"\", Lucene50CompoundFormat.ENTRIES_EXTENSION);\n    this.entries = readEntries(si.getId(), directory, entriesFileName);\n    boolean success = false;\n    handle = directory.openInput(dataFileName, context);\n    try {\n      CodecUtil.checkIndexHeader(handle, Lucene50CompoundFormat.DATA_CODEC, version, version, si.getId(), \"\");\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(handle);\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(handle);\n      }\n    }\n    this.isOpen = true;\n  }\n\n","sourceOld":"  /**\n   * Create a new CompoundFileDirectory.\n   */\n  // TODO: we should just pre-strip \"entries\" and append segment name up-front like simpletext?\n  // this need not be a \"general purpose\" directory anymore (it only writes index files)\n  public Lucene50CompoundReader(Directory directory, SegmentInfo si, IOContext context) throws IOException {\n    this.directory = directory;\n    this.segmentName = si.name;\n    String dataFileName = IndexFileNames.segmentFileName(segmentName, \"\", Lucene50CompoundFormat.DATA_EXTENSION);\n    String entriesFileName = IndexFileNames.segmentFileName(segmentName, \"\", Lucene50CompoundFormat.ENTRIES_EXTENSION);\n    this.entries = readEntries(si.getId(), directory, entriesFileName);\n    boolean success = false;\n    handle = directory.openInput(dataFileName, context);\n    try {\n      CodecUtil.checkSegmentHeader(handle, Lucene50CompoundFormat.DATA_CODEC, version, version, si.getId(), \"\");\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(handle);\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(handle);\n      }\n    }\n    this.isOpen = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db68c63cbfaa8698b9c4475f75ed2b9c9696d238","date":1414118621,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50CompoundReader#Lucene50CompoundReader(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50CompoundReader#Lucene50CompoundReader(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  /**\n   * Create a new CompoundFileDirectory.\n   */\n  // TODO: we should just pre-strip \"entries\" and append segment name up-front like simpletext?\n  // this need not be a \"general purpose\" directory anymore (it only writes index files)\n  public Lucene50CompoundReader(Directory directory, SegmentInfo si, IOContext context) throws IOException {\n    this.directory = directory;\n    this.segmentName = si.name;\n    String dataFileName = IndexFileNames.segmentFileName(segmentName, \"\", Lucene50CompoundFormat.DATA_EXTENSION);\n    String entriesFileName = IndexFileNames.segmentFileName(segmentName, \"\", Lucene50CompoundFormat.ENTRIES_EXTENSION);\n    this.entries = readEntries(si.getId(), directory, entriesFileName);\n    boolean success = false;\n    handle = directory.openInput(dataFileName, context);\n    try {\n      CodecUtil.checkIndexHeader(handle, Lucene50CompoundFormat.DATA_CODEC, version, version, si.getId(), \"\");\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(handle);\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(handle);\n      }\n    }\n    this.isOpen = true;\n  }\n\n","sourceOld":"  /**\n   * Create a new CompoundFileDirectory.\n   */\n  // TODO: we should just pre-strip \"entries\" and append segment name up-front like simpletext?\n  // this need not be a \"general purpose\" directory anymore (it only writes index files)\n  public Lucene50CompoundReader(Directory directory, SegmentInfo si, IOContext context) throws IOException {\n    this.directory = directory;\n    this.segmentName = si.name;\n    String dataFileName = IndexFileNames.segmentFileName(segmentName, \"\", Lucene50CompoundFormat.DATA_EXTENSION);\n    String entriesFileName = IndexFileNames.segmentFileName(segmentName, \"\", Lucene50CompoundFormat.ENTRIES_EXTENSION);\n    this.entries = readEntries(si.getId(), directory, entriesFileName);\n    boolean success = false;\n    handle = directory.openInput(dataFileName, context);\n    try {\n      CodecUtil.checkSegmentHeader(handle, Lucene50CompoundFormat.DATA_CODEC, version, version, si.getId(), \"\");\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(handle);\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(handle);\n      }\n    }\n    this.isOpen = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"285cdc737de75b7cc7c284a156b20214deb67bca","date":1415535483,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50CompoundReader#Lucene50CompoundReader(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50CompoundReader#Lucene50CompoundReader(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  /**\n   * Create a new CompoundFileDirectory.\n   */\n  // TODO: we should just pre-strip \"entries\" and append segment name up-front like simpletext?\n  // this need not be a \"general purpose\" directory anymore (it only writes index files)\n  public Lucene50CompoundReader(Directory directory, SegmentInfo si, IOContext context) throws IOException {\n    this.directory = directory;\n    this.segmentName = si.name;\n    String dataFileName = IndexFileNames.segmentFileName(segmentName, \"\", Lucene50CompoundFormat.DATA_EXTENSION);\n    String entriesFileName = IndexFileNames.segmentFileName(segmentName, \"\", Lucene50CompoundFormat.ENTRIES_EXTENSION);\n    this.entries = readEntries(si.getId(), directory, entriesFileName);\n    boolean success = false;\n    handle = directory.openInput(dataFileName, context);\n    try {\n      CodecUtil.checkIndexHeader(handle, Lucene50CompoundFormat.DATA_CODEC, version, version, si.getId(), \"\");\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(handle);\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(handle);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a new CompoundFileDirectory.\n   */\n  // TODO: we should just pre-strip \"entries\" and append segment name up-front like simpletext?\n  // this need not be a \"general purpose\" directory anymore (it only writes index files)\n  public Lucene50CompoundReader(Directory directory, SegmentInfo si, IOContext context) throws IOException {\n    this.directory = directory;\n    this.segmentName = si.name;\n    String dataFileName = IndexFileNames.segmentFileName(segmentName, \"\", Lucene50CompoundFormat.DATA_EXTENSION);\n    String entriesFileName = IndexFileNames.segmentFileName(segmentName, \"\", Lucene50CompoundFormat.ENTRIES_EXTENSION);\n    this.entries = readEntries(si.getId(), directory, entriesFileName);\n    boolean success = false;\n    handle = directory.openInput(dataFileName, context);\n    try {\n      CodecUtil.checkIndexHeader(handle, Lucene50CompoundFormat.DATA_CODEC, version, version, si.getId(), \"\");\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(handle);\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(handle);\n      }\n    }\n    this.isOpen = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b485ce675d4e8b9dbfafd122ca9b7b33a883be7b","date":1453975275,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50CompoundReader#Lucene50CompoundReader(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50CompoundReader#Lucene50CompoundReader(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  /**\n   * Create a new CompoundFileDirectory.\n   */\n  // TODO: we should just pre-strip \"entries\" and append segment name up-front like simpletext?\n  // this need not be a \"general purpose\" directory anymore (it only writes index files)\n  public Lucene50CompoundReader(Directory directory, SegmentInfo si, IOContext context) throws IOException {\n    this.directory = directory;\n    this.segmentName = si.name;\n    String dataFileName = IndexFileNames.segmentFileName(segmentName, \"\", Lucene50CompoundFormat.DATA_EXTENSION);\n    String entriesFileName = IndexFileNames.segmentFileName(segmentName, \"\", Lucene50CompoundFormat.ENTRIES_EXTENSION);\n    this.entries = readEntries(si.getId(), directory, entriesFileName);\n    boolean success = false;\n\n    long expectedLength = CodecUtil.indexHeaderLength(Lucene50CompoundFormat.DATA_CODEC, \"\");\n    for(Map.Entry<String,FileEntry> ent : entries.entrySet()) {\n      expectedLength += ent.getValue().length;\n    }\n    expectedLength += CodecUtil.footerLength(); \n\n    handle = directory.openInput(dataFileName, context);\n    try {\n      CodecUtil.checkIndexHeader(handle, Lucene50CompoundFormat.DATA_CODEC, version, version, si.getId(), \"\");\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(handle);\n\n      // We also validate length, because e.g. if you strip 16 bytes off the .cfs we otherwise\n      // would not detect it:\n      if (handle.length() != expectedLength) {\n        throw new CorruptIndexException(\"length should be \" + expectedLength + \" bytes, but is \" + handle.length() + \" instead\", handle);\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(handle);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a new CompoundFileDirectory.\n   */\n  // TODO: we should just pre-strip \"entries\" and append segment name up-front like simpletext?\n  // this need not be a \"general purpose\" directory anymore (it only writes index files)\n  public Lucene50CompoundReader(Directory directory, SegmentInfo si, IOContext context) throws IOException {\n    this.directory = directory;\n    this.segmentName = si.name;\n    String dataFileName = IndexFileNames.segmentFileName(segmentName, \"\", Lucene50CompoundFormat.DATA_EXTENSION);\n    String entriesFileName = IndexFileNames.segmentFileName(segmentName, \"\", Lucene50CompoundFormat.ENTRIES_EXTENSION);\n    this.entries = readEntries(si.getId(), directory, entriesFileName);\n    boolean success = false;\n    handle = directory.openInput(dataFileName, context);\n    try {\n      CodecUtil.checkIndexHeader(handle, Lucene50CompoundFormat.DATA_CODEC, version, version, si.getId(), \"\");\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(handle);\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(handle);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8d15e34266d75e4e8b95da046cd0afc812367b38","date":1454246129,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50CompoundReader#Lucene50CompoundReader(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50CompoundReader#Lucene50CompoundReader(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  /**\n   * Create a new CompoundFileDirectory.\n   */\n  // TODO: we should just pre-strip \"entries\" and append segment name up-front like simpletext?\n  // this need not be a \"general purpose\" directory anymore (it only writes index files)\n  public Lucene50CompoundReader(Directory directory, SegmentInfo si, IOContext context) throws IOException {\n    this.directory = directory;\n    this.segmentName = si.name;\n    String dataFileName = IndexFileNames.segmentFileName(segmentName, \"\", Lucene50CompoundFormat.DATA_EXTENSION);\n    String entriesFileName = IndexFileNames.segmentFileName(segmentName, \"\", Lucene50CompoundFormat.ENTRIES_EXTENSION);\n    this.entries = readEntries(si.getId(), directory, entriesFileName);\n    boolean success = false;\n\n    long expectedLength = CodecUtil.indexHeaderLength(Lucene50CompoundFormat.DATA_CODEC, \"\");\n    for(Map.Entry<String,FileEntry> ent : entries.entrySet()) {\n      expectedLength += ent.getValue().length;\n    }\n    expectedLength += CodecUtil.footerLength(); \n\n    handle = directory.openInput(dataFileName, context);\n    try {\n      CodecUtil.checkIndexHeader(handle, Lucene50CompoundFormat.DATA_CODEC, version, version, si.getId(), \"\");\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(handle);\n\n      // We also validate length, because e.g. if you strip 16 bytes off the .cfs we otherwise\n      // would not detect it:\n      if (handle.length() != expectedLength) {\n        throw new CorruptIndexException(\"length should be \" + expectedLength + \" bytes, but is \" + handle.length() + \" instead\", handle);\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(handle);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a new CompoundFileDirectory.\n   */\n  // TODO: we should just pre-strip \"entries\" and append segment name up-front like simpletext?\n  // this need not be a \"general purpose\" directory anymore (it only writes index files)\n  public Lucene50CompoundReader(Directory directory, SegmentInfo si, IOContext context) throws IOException {\n    this.directory = directory;\n    this.segmentName = si.name;\n    String dataFileName = IndexFileNames.segmentFileName(segmentName, \"\", Lucene50CompoundFormat.DATA_EXTENSION);\n    String entriesFileName = IndexFileNames.segmentFileName(segmentName, \"\", Lucene50CompoundFormat.ENTRIES_EXTENSION);\n    this.entries = readEntries(si.getId(), directory, entriesFileName);\n    boolean success = false;\n    handle = directory.openInput(dataFileName, context);\n    try {\n      CodecUtil.checkIndexHeader(handle, Lucene50CompoundFormat.DATA_CODEC, version, version, si.getId(), \"\");\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(handle);\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(handle);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50CompoundReader#Lucene50CompoundReader(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50CompoundReader#Lucene50CompoundReader(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  /**\n   * Create a new CompoundFileDirectory.\n   */\n  // TODO: we should just pre-strip \"entries\" and append segment name up-front like simpletext?\n  // this need not be a \"general purpose\" directory anymore (it only writes index files)\n  public Lucene50CompoundReader(Directory directory, SegmentInfo si, IOContext context) throws IOException {\n    this.directory = directory;\n    this.segmentName = si.name;\n    String dataFileName = IndexFileNames.segmentFileName(segmentName, \"\", Lucene50CompoundFormat.DATA_EXTENSION);\n    String entriesFileName = IndexFileNames.segmentFileName(segmentName, \"\", Lucene50CompoundFormat.ENTRIES_EXTENSION);\n    this.entries = readEntries(si.getId(), directory, entriesFileName);\n    boolean success = false;\n\n    long expectedLength = CodecUtil.indexHeaderLength(Lucene50CompoundFormat.DATA_CODEC, \"\");\n    for(Map.Entry<String,FileEntry> ent : entries.entrySet()) {\n      expectedLength += ent.getValue().length;\n    }\n    expectedLength += CodecUtil.footerLength(); \n\n    handle = directory.openInput(dataFileName, context);\n    try {\n      CodecUtil.checkIndexHeader(handle, Lucene50CompoundFormat.DATA_CODEC, version, version, si.getId(), \"\");\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(handle);\n\n      // We also validate length, because e.g. if you strip 16 bytes off the .cfs we otherwise\n      // would not detect it:\n      if (handle.length() != expectedLength) {\n        throw new CorruptIndexException(\"length should be \" + expectedLength + \" bytes, but is \" + handle.length() + \" instead\", handle);\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(handle);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a new CompoundFileDirectory.\n   */\n  // TODO: we should just pre-strip \"entries\" and append segment name up-front like simpletext?\n  // this need not be a \"general purpose\" directory anymore (it only writes index files)\n  public Lucene50CompoundReader(Directory directory, SegmentInfo si, IOContext context) throws IOException {\n    this.directory = directory;\n    this.segmentName = si.name;\n    String dataFileName = IndexFileNames.segmentFileName(segmentName, \"\", Lucene50CompoundFormat.DATA_EXTENSION);\n    String entriesFileName = IndexFileNames.segmentFileName(segmentName, \"\", Lucene50CompoundFormat.ENTRIES_EXTENSION);\n    this.entries = readEntries(si.getId(), directory, entriesFileName);\n    boolean success = false;\n    handle = directory.openInput(dataFileName, context);\n    try {\n      CodecUtil.checkIndexHeader(handle, Lucene50CompoundFormat.DATA_CODEC, version, version, si.getId(), \"\");\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(handle);\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(handle);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c761d502ca1f6c5324aa909468ebc4f761c92c1f":["9c34e07420c03a037d73169b35f349c2ad6fd8c7"],"9bb9a29a5e71a90295f175df8919802993142c9a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c761d502ca1f6c5324aa909468ebc4f761c92c1f"],"9c34e07420c03a037d73169b35f349c2ad6fd8c7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b485ce675d4e8b9dbfafd122ca9b7b33a883be7b":["285cdc737de75b7cc7c284a156b20214deb67bca"],"285cdc737de75b7cc7c284a156b20214deb67bca":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["285cdc737de75b7cc7c284a156b20214deb67bca","8d15e34266d75e4e8b95da046cd0afc812367b38"],"3384e6013a93e4d11b7d75388693f8d0388602bf":["c761d502ca1f6c5324aa909468ebc4f761c92c1f"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["9bb9a29a5e71a90295f175df8919802993142c9a","3384e6013a93e4d11b7d75388693f8d0388602bf"],"8d15e34266d75e4e8b95da046cd0afc812367b38":["285cdc737de75b7cc7c284a156b20214deb67bca","b485ce675d4e8b9dbfafd122ca9b7b33a883be7b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8d15e34266d75e4e8b95da046cd0afc812367b38"]},"commit2Childs":{"c761d502ca1f6c5324aa909468ebc4f761c92c1f":["9bb9a29a5e71a90295f175df8919802993142c9a","3384e6013a93e4d11b7d75388693f8d0388602bf"],"9c34e07420c03a037d73169b35f349c2ad6fd8c7":["c761d502ca1f6c5324aa909468ebc4f761c92c1f"],"9bb9a29a5e71a90295f175df8919802993142c9a":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"b485ce675d4e8b9dbfafd122ca9b7b33a883be7b":["8d15e34266d75e4e8b95da046cd0afc812367b38"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9bb9a29a5e71a90295f175df8919802993142c9a","9c34e07420c03a037d73169b35f349c2ad6fd8c7"],"285cdc737de75b7cc7c284a156b20214deb67bca":["b485ce675d4e8b9dbfafd122ca9b7b33a883be7b","1e6acbaae7af722f17204ceccf0f7db5753eccf3","8d15e34266d75e4e8b95da046cd0afc812367b38"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"3384e6013a93e4d11b7d75388693f8d0388602bf":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["285cdc737de75b7cc7c284a156b20214deb67bca"],"8d15e34266d75e4e8b95da046cd0afc812367b38":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}