{"path":"solr/core/src/java/org/apache/solr/packagemanager/PackageManager#getDeployedCollections(String).mjava","commits":[{"id":"120bc33d5cbe83eca2e5fce597baf4fef208d579","date":1573735895,"type":0,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/packagemanager/PackageManager#getDeployedCollections(String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Given a package, return a map of collections where this package is\n   * installed to the installed version (which can be {@link PackagePluginHolder#LATEST})\n   */\n  public Map<String, String> getDeployedCollections(String packageName) {\n    List<String> allCollections;\n    try {\n      allCollections = zkClient.getChildren(\"/collections\", null, true);\n    } catch (KeeperException | InterruptedException e) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n    }\n    Map<String, String> deployed = new HashMap<String, String>();\n    for (String collection: allCollections) {\n      // Check package version installed\n      String paramsJson = PackageUtils.getJsonStringFromUrl(solrClient.getHttpClient(), solrBaseUrl + \"/api/collections/\" + collection + \"/config/params/PKG_VERSIONS?omitHeader=true\");\n      String version = null;\n      try {\n        version = JsonPath.parse(paramsJson, PackageUtils.jsonPathConfiguration())\n            .read(\"$['response'].['params'].['PKG_VERSIONS'].['\"+packageName+\"'])\");\n      } catch (PathNotFoundException ex) {\n        // Don't worry if PKG_VERSION wasn't found. It just means this collection was never touched by the package manager.\n      }\n      if (version != null) {\n        deployed.put(collection, version);\n      }\n    }\n    return deployed;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"62d55718cd611235e975fa73a6bdf263fbd58859","date":1576386842,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/packagemanager/PackageManager#getDeployedCollections(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/packagemanager/PackageManager#getDeployedCollections(String).mjava","sourceNew":"  /**\n   * Given a package, return a map of collections where this package is\n   * installed to the installed version (which can be {@link PackagePluginHolder#LATEST})\n   */\n  public Map<String, String> getDeployedCollections(String packageName) {\n    List<String> allCollections;\n    try {\n      allCollections = zkClient.getChildren(ZkStateReader.COLLECTIONS_ZKNODE, null, true);\n    } catch (KeeperException | InterruptedException e) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n    }\n    Map<String, String> deployed = new HashMap<String, String>();\n    for (String collection: allCollections) {\n      // Check package version installed\n      String paramsJson = PackageUtils.getJsonStringFromUrl(solrClient.getHttpClient(), solrBaseUrl + PackageUtils.getCollectionParamsPath(collection) + \"/PKG_VERSIONS?omitHeader=true\");\n      String version = null;\n      try {\n        version = JsonPath.parse(paramsJson, PackageUtils.jsonPathConfiguration())\n            .read(\"$['response'].['params'].['PKG_VERSIONS'].['\"+packageName+\"'])\");\n      } catch (PathNotFoundException ex) {\n        // Don't worry if PKG_VERSION wasn't found. It just means this collection was never touched by the package manager.\n      }\n      if (version != null) {\n        deployed.put(collection, version);\n      }\n    }\n    return deployed;\n  }\n\n","sourceOld":"  /**\n   * Given a package, return a map of collections where this package is\n   * installed to the installed version (which can be {@link PackagePluginHolder#LATEST})\n   */\n  public Map<String, String> getDeployedCollections(String packageName) {\n    List<String> allCollections;\n    try {\n      allCollections = zkClient.getChildren(\"/collections\", null, true);\n    } catch (KeeperException | InterruptedException e) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n    }\n    Map<String, String> deployed = new HashMap<String, String>();\n    for (String collection: allCollections) {\n      // Check package version installed\n      String paramsJson = PackageUtils.getJsonStringFromUrl(solrClient.getHttpClient(), solrBaseUrl + \"/api/collections/\" + collection + \"/config/params/PKG_VERSIONS?omitHeader=true\");\n      String version = null;\n      try {\n        version = JsonPath.parse(paramsJson, PackageUtils.jsonPathConfiguration())\n            .read(\"$['response'].['params'].['PKG_VERSIONS'].['\"+packageName+\"'])\");\n      } catch (PathNotFoundException ex) {\n        // Don't worry if PKG_VERSION wasn't found. It just means this collection was never touched by the package manager.\n      }\n      if (version != null) {\n        deployed.put(collection, version);\n      }\n    }\n    return deployed;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06595b0c22c7d3075c4104d3820cccf95d9d8a43","date":1576491645,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/packagemanager/PackageManager#getDeployedCollections(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/packagemanager/PackageManager#getDeployedCollections(String).mjava","sourceNew":"  /**\n   * Given a package, return a map of collections where this package is\n   * installed to the installed version (which can be {@link PackagePluginHolder#LATEST})\n   */\n  public Map<String, String> getDeployedCollections(String packageName) {\n    List<String> allCollections;\n    try {\n      allCollections = zkClient.getChildren(ZkStateReader.COLLECTIONS_ZKNODE, null, true);\n    } catch (KeeperException | InterruptedException e) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n    }\n    Map<String, String> deployed = new HashMap<String, String>();\n    for (String collection: allCollections) {\n      // Check package version installed\n      String paramsJson = PackageUtils.getJsonStringFromUrl(solrClient.getHttpClient(), solrBaseUrl + PackageUtils.getCollectionParamsPath(collection) + \"/PKG_VERSIONS?omitHeader=true\");\n      String version = null;\n      try {\n        version = JsonPath.parse(paramsJson, PackageUtils.jsonPathConfiguration())\n            .read(\"$['response'].['params'].['PKG_VERSIONS'].['\"+packageName+\"'])\");\n      } catch (PathNotFoundException ex) {\n        // Don't worry if PKG_VERSION wasn't found. It just means this collection was never touched by the package manager.\n      }\n      if (version != null) {\n        deployed.put(collection, version);\n      }\n    }\n    return deployed;\n  }\n\n","sourceOld":"  /**\n   * Given a package, return a map of collections where this package is\n   * installed to the installed version (which can be {@link PackagePluginHolder#LATEST})\n   */\n  public Map<String, String> getDeployedCollections(String packageName) {\n    List<String> allCollections;\n    try {\n      allCollections = zkClient.getChildren(\"/collections\", null, true);\n    } catch (KeeperException | InterruptedException e) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n    }\n    Map<String, String> deployed = new HashMap<String, String>();\n    for (String collection: allCollections) {\n      // Check package version installed\n      String paramsJson = PackageUtils.getJsonStringFromUrl(solrClient.getHttpClient(), solrBaseUrl + \"/api/collections/\" + collection + \"/config/params/PKG_VERSIONS?omitHeader=true\");\n      String version = null;\n      try {\n        version = JsonPath.parse(paramsJson, PackageUtils.jsonPathConfiguration())\n            .read(\"$['response'].['params'].['PKG_VERSIONS'].['\"+packageName+\"'])\");\n      } catch (PathNotFoundException ex) {\n        // Don't worry if PKG_VERSION wasn't found. It just means this collection was never touched by the package manager.\n      }\n      if (version != null) {\n        deployed.put(collection, version);\n      }\n    }\n    return deployed;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b2ed9b72e5fa27a7bd4857f222ca815341979d4a","date":1594879524,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/packagemanager/PackageManager#getDeployedCollections(String).mjava","pathOld":"solr/core/src/java/org/apache/solr/packagemanager/PackageManager#getDeployedCollections(String).mjava","sourceNew":"  /**\n   * Given a package, return a map of collections where this package is\n   * installed to the installed version (which can be {@link PackageLoader#LATEST})\n   */\n  public Map<String, String> getDeployedCollections(String packageName) {\n    List<String> allCollections;\n    try {\n      allCollections = zkClient.getChildren(ZkStateReader.COLLECTIONS_ZKNODE, null, true);\n    } catch (KeeperException | InterruptedException e) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n    }\n    Map<String, String> deployed = new HashMap<String, String>();\n    for (String collection: allCollections) {\n      // Check package version installed\n      String paramsJson = PackageUtils.getJsonStringFromUrl(solrClient.getHttpClient(), solrBaseUrl + PackageUtils.getCollectionParamsPath(collection) + \"/PKG_VERSIONS?omitHeader=true\");\n      String version = null;\n      try {\n        version = JsonPath.parse(paramsJson, PackageUtils.jsonPathConfiguration())\n            .read(\"$['response'].['params'].['PKG_VERSIONS'].['\"+packageName+\"'])\");\n      } catch (PathNotFoundException ex) {\n        // Don't worry if PKG_VERSION wasn't found. It just means this collection was never touched by the package manager.\n      }\n      if (version != null) {\n        deployed.put(collection, version);\n      }\n    }\n    return deployed;\n  }\n\n","sourceOld":"  /**\n   * Given a package, return a map of collections where this package is\n   * installed to the installed version (which can be {@link PackagePluginHolder#LATEST})\n   */\n  public Map<String, String> getDeployedCollections(String packageName) {\n    List<String> allCollections;\n    try {\n      allCollections = zkClient.getChildren(ZkStateReader.COLLECTIONS_ZKNODE, null, true);\n    } catch (KeeperException | InterruptedException e) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, e);\n    }\n    Map<String, String> deployed = new HashMap<String, String>();\n    for (String collection: allCollections) {\n      // Check package version installed\n      String paramsJson = PackageUtils.getJsonStringFromUrl(solrClient.getHttpClient(), solrBaseUrl + PackageUtils.getCollectionParamsPath(collection) + \"/PKG_VERSIONS?omitHeader=true\");\n      String version = null;\n      try {\n        version = JsonPath.parse(paramsJson, PackageUtils.jsonPathConfiguration())\n            .read(\"$['response'].['params'].['PKG_VERSIONS'].['\"+packageName+\"'])\");\n      } catch (PathNotFoundException ex) {\n        // Don't worry if PKG_VERSION wasn't found. It just means this collection was never touched by the package manager.\n      }\n      if (version != null) {\n        deployed.put(collection, version);\n      }\n    }\n    return deployed;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b2ed9b72e5fa27a7bd4857f222ca815341979d4a":["62d55718cd611235e975fa73a6bdf263fbd58859"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"06595b0c22c7d3075c4104d3820cccf95d9d8a43":["120bc33d5cbe83eca2e5fce597baf4fef208d579","62d55718cd611235e975fa73a6bdf263fbd58859"],"62d55718cd611235e975fa73a6bdf263fbd58859":["120bc33d5cbe83eca2e5fce597baf4fef208d579"],"120bc33d5cbe83eca2e5fce597baf4fef208d579":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b2ed9b72e5fa27a7bd4857f222ca815341979d4a"]},"commit2Childs":{"b2ed9b72e5fa27a7bd4857f222ca815341979d4a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["120bc33d5cbe83eca2e5fce597baf4fef208d579"],"06595b0c22c7d3075c4104d3820cccf95d9d8a43":[],"62d55718cd611235e975fa73a6bdf263fbd58859":["b2ed9b72e5fa27a7bd4857f222ca815341979d4a","06595b0c22c7d3075c4104d3820cccf95d9d8a43"],"120bc33d5cbe83eca2e5fce597baf4fef208d579":["06595b0c22c7d3075c4104d3820cccf95d9d8a43","62d55718cd611235e975fa73a6bdf263fbd58859"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["06595b0c22c7d3075c4104d3820cccf95d9d8a43","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}