{"path":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads(IndexWriter).mjava","commits":[{"id":"7af110b00ea8df9429309d83e38e0533d82e144f","date":1376924768,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads(IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","sourceNew":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  final boolean flushAllThreads(final IndexWriter indexWriter)\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", Thread.currentThread().getName() + \" startFullFlush\");\n    }\n    \n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      flushControl.markForFullFlush(); // swaps the delQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      } \n      ticketQueue.forcePurge(indexWriter);\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    return anythingFlushed;\n  }\n\n","sourceOld":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  final boolean flushAllThreads()\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", Thread.currentThread().getName() + \" startFullFlush\");\n    }\n    \n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      flushControl.markForFullFlush(); // swaps the delQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletesAndPurge(this, flushingDeleteQueue);\n      } else {\n        ticketQueue.forcePurge(this);\n      }\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    return anythingFlushed;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31d4861802ca404d78ca1d15f4550eec415b9199","date":1376947894,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads(IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","sourceNew":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  final boolean flushAllThreads(final IndexWriter indexWriter)\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", Thread.currentThread().getName() + \" startFullFlush\");\n    }\n    \n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      flushControl.markForFullFlush(); // swaps the delQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      } \n      ticketQueue.forcePurge(indexWriter);\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    return anythingFlushed;\n  }\n\n","sourceOld":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  final boolean flushAllThreads()\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", Thread.currentThread().getName() + \" startFullFlush\");\n    }\n    \n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      flushControl.markForFullFlush(); // swaps the delQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletesAndPurge(this, flushingDeleteQueue);\n      } else {\n        ticketQueue.forcePurge(this);\n      }\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    return anythingFlushed;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":0,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads(IndexWriter).mjava","pathOld":"/dev/null","sourceNew":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  final boolean flushAllThreads(final IndexWriter indexWriter)\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", Thread.currentThread().getName() + \" startFullFlush\");\n    }\n    \n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      flushControl.markForFullFlush(); // swaps the delQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      } \n      ticketQueue.forcePurge(indexWriter);\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    return anythingFlushed;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2f4e10b67010a116686d0b726f629cb29595d57a","date":1395353694,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads(IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads(IndexWriter).mjava","sourceNew":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  final boolean flushAllThreads(final IndexWriter indexWriter)\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n    \n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      flushControl.markForFullFlush(); // swaps the delQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      } \n      ticketQueue.forcePurge(indexWriter);\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    return anythingFlushed;\n  }\n\n","sourceOld":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  final boolean flushAllThreads(final IndexWriter indexWriter)\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", Thread.currentThread().getName() + \" startFullFlush\");\n    }\n    \n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      flushControl.markForFullFlush(); // swaps the delQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      } \n      ticketQueue.forcePurge(indexWriter);\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    return anythingFlushed;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9299079153fd7895bf3cf6835cf7019af2ba89b3","date":1417813477,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads(IndexWriter).mjava","sourceNew":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  final boolean flushAllThreads()\n    throws IOException, AbortingException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n    \n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      flushControl.markForFullFlush(); // swaps the delQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      } \n      ticketQueue.forcePurge(writer);\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    return anythingFlushed;\n  }\n\n","sourceOld":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  final boolean flushAllThreads(final IndexWriter indexWriter)\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n    \n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      flushControl.markForFullFlush(); // swaps the delQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (!anythingFlushed && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      } \n      ticketQueue.forcePurge(indexWriter);\n      assert !flushingDeleteQueue.anyChanges() && !ticketQueue.hasTickets();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    return anythingFlushed;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"86a2e8a56b368d37ef3ba7180541fa317d6fd6c7","date":1524496660,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads(IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","sourceNew":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads(IndexWriter writer)\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (anythingFlushed == false && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      ticketQueue.forcePurge(writer);\n      // we can't assert that we don't have any tickets in teh queue since we might add a DocumentsWriterDeleteQueue\n      // concurrently if we have very small ram buffers this happens quite frequently\n      assert !flushingDeleteQueue.anyChanges();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","sourceOld":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads()\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (anythingFlushed == false && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      ticketQueue.forcePurge(writer);\n      // we can't assert that we don't have any tickets in teh queue since we might add a DocumentsWriterDeleteQueue\n      // concurrently if we have very small ram buffers this happens quite frequently\n      assert !flushingDeleteQueue.anyChanges();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b8498afacfc8322268ca0d659d274fcce08d557","date":1524577248,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#flushAllThreads(IndexWriter).mjava","sourceNew":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads()\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (anythingFlushed == false && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      // we can't assert that we don't have any tickets in teh queue since we might add a DocumentsWriterDeleteQueue\n      // concurrently if we have very small ram buffers this happens quite frequently\n      assert !flushingDeleteQueue.anyChanges();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","sourceOld":"  /*\n   * FlushAllThreads is synced by IW fullFlushLock. Flushing all threads is a\n   * two stage operation; the caller must ensure (in try/finally) that finishFlush\n   * is called after this method, to release the flush lock in DWFlushControl\n   */\n  long flushAllThreads(IndexWriter writer)\n    throws IOException {\n    final DocumentsWriterDeleteQueue flushingDeleteQueue;\n    if (infoStream.isEnabled(\"DW\")) {\n      infoStream.message(\"DW\", \"startFullFlush\");\n    }\n\n    long seqNo;\n\n    synchronized (this) {\n      pendingChangesInCurrentFullFlush = anyChanges();\n      flushingDeleteQueue = deleteQueue;\n      /* Cutover to a new delete queue.  This must be synced on the flush control\n       * otherwise a new DWPT could sneak into the loop with an already flushing\n       * delete queue */\n      seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl\n      assert setFlushingDeleteQueue(flushingDeleteQueue);\n    }\n    assert currentFullFlushDelQueue != null;\n    assert currentFullFlushDelQueue != deleteQueue;\n    \n    boolean anythingFlushed = false;\n    try {\n      DocumentsWriterPerThread flushingDWPT;\n      // Help out with flushing:\n      while ((flushingDWPT = flushControl.nextPendingFlush()) != null) {\n        anythingFlushed |= doFlush(flushingDWPT);\n      }\n      // If a concurrent flush is still in flight wait for it\n      flushControl.waitForFlush();  \n      if (anythingFlushed == false && flushingDeleteQueue.anyChanges()) { // apply deletes if we did not flush any document\n        if (infoStream.isEnabled(\"DW\")) {\n          infoStream.message(\"DW\", Thread.currentThread().getName() + \": flush naked frozen global deletes\");\n        }\n        ticketQueue.addDeletes(flushingDeleteQueue);\n      }\n      ticketQueue.forcePurge(writer);\n      // we can't assert that we don't have any tickets in teh queue since we might add a DocumentsWriterDeleteQueue\n      // concurrently if we have very small ram buffers this happens quite frequently\n      assert !flushingDeleteQueue.anyChanges();\n    } finally {\n      assert flushingDeleteQueue == currentFullFlushDelQueue;\n    }\n    if (anythingFlushed) {\n      return -seqNo;\n    } else {\n      return seqNo;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7af110b00ea8df9429309d83e38e0533d82e144f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6b8498afacfc8322268ca0d659d274fcce08d557":["86a2e8a56b368d37ef3ba7180541fa317d6fd6c7"],"86a2e8a56b368d37ef3ba7180541fa317d6fd6c7":["9299079153fd7895bf3cf6835cf7019af2ba89b3"],"2f4e10b67010a116686d0b726f629cb29595d57a":["7af110b00ea8df9429309d83e38e0533d82e144f"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7af110b00ea8df9429309d83e38e0533d82e144f"],"31d4861802ca404d78ca1d15f4550eec415b9199":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7af110b00ea8df9429309d83e38e0533d82e144f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9299079153fd7895bf3cf6835cf7019af2ba89b3":["2f4e10b67010a116686d0b726f629cb29595d57a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6b8498afacfc8322268ca0d659d274fcce08d557"]},"commit2Childs":{"7af110b00ea8df9429309d83e38e0533d82e144f":["2f4e10b67010a116686d0b726f629cb29595d57a","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199"],"6b8498afacfc8322268ca0d659d274fcce08d557":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"86a2e8a56b368d37ef3ba7180541fa317d6fd6c7":["6b8498afacfc8322268ca0d659d274fcce08d557"],"2f4e10b67010a116686d0b726f629cb29595d57a":["9299079153fd7895bf3cf6835cf7019af2ba89b3"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"31d4861802ca404d78ca1d15f4550eec415b9199":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7af110b00ea8df9429309d83e38e0533d82e144f","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199"],"9299079153fd7895bf3cf6835cf7019af2ba89b3":["86a2e8a56b368d37ef3ba7180541fa317d6fd6c7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}