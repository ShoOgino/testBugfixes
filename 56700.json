{"path":"solr/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader.Node#build(List[String],String,boolean,boolean,int).mjava","commits":[{"id":"893269407f5c988a4b2ee13c7ffc01ec43136c1d","date":1268598046,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader.Node#build(List[String],String,boolean,boolean,int).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Build a Node tree structure representing all Xpaths of intrest to us.\n     * This must be done before parsing of the XML stream starts. Each node \n     * holds one portion of an Xpath. Taking each Xpath segment in turn this\n     * method walks the Node tree  and finds where the new segment should be\n     * inserted. It creates a Node representing a field's name, XPATH and \n     * some flags and inserts the Node into the Node tree.\n     */\n    private void build(\n        List<String> paths,   // a List of segments from the split xpaths\n        String fieldName,     // the fieldName assoc with this Xpath\n        boolean multiValued,  // flag if this fieldName is multiValued or not\n        boolean record,       // is this xpath a record or a field\n        int flags             // are we to flatten matching xpaths\n        ) {\n      // recursivly walk the paths Lists adding new Nodes as required\n      String xpseg = paths.remove(0); // shift out next Xpath segment\n\n      if (paths.isEmpty() && xpseg.startsWith(\"@\")) {\n        // we have reached end of element portion of Xpath and can now only\n        // have an element attribute. Add it to this nodes list of attributes\n        if (attributes == null) {\n          attributes = new ArrayList<Node>();\n        }\n        xpseg = xpseg.substring(1); // strip the '@'\n        attributes.add(new Node(xpseg, fieldName, multiValued));\n      }\n      else if ( xpseg.length() == 0) {\n        // we have a '//' selector for all decendents of the current nodes\n        xpseg = paths.remove(0); // shift out next Xpath segment\n        if (wildCardNodes == null) wildCardNodes = new ArrayList<Node>();\n        Node n = getOrAddNode(xpseg, wildCardNodes);\n        if (paths.isEmpty()) {\n          // We are current a leaf node.\n          // xpath with content we want to store and return\n          n.hasText = true;        // we have to store text found here\n          n.fieldName = fieldName; // name to store collected text against\n          n.multiValued = multiValued; // true: text be stored in a List\n          n.flatten = flags == FLATTEN; // true: store text from child tags\n        }\n        else {\n          // recurse to handle next paths segment\n          n.build(paths, fieldName, multiValued, record, flags);\n        }\n      }\n      else {\n        if (childNodes == null)\n          childNodes = new ArrayList<Node>();\n        // does this \"name\" already exist as a child node.\n        Node n = getOrAddNode(xpseg,childNodes);\n        if (paths.isEmpty()) {\n          // We have emptied paths, we are for the moment a leaf of the tree.\n          // When parsing the actual input we have traversed to a position \n          // where we actutally have to do something. getOrAddNode() will\n          // have created and returned a new minimal Node with name and\n          // xpathName already populated. We need to add more information.\n          if (record) {\n            // forEach attribute\n            n.isRecord = true; // flag: forEach attribute, prepare to emit rec\n            n.forEachPath = fieldName; // the full forEach attribute xpath\n          } else {\n            // xpath with content we want to store and return\n            n.hasText = true;        // we have to store text found here\n            n.fieldName = fieldName; // name to store collected text against\n            n.multiValued = multiValued; // true: text be stored in a List\n            n.flatten = flags == FLATTEN; // true: store text from child tags\n          }\n        } else {\n          // recurse to handle next paths segment\n          n.build(paths, fieldName, multiValued, record, flags);\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","date":1268599006,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader.Node#build(List[String],String,boolean,boolean,int).mjava","sourceNew":null,"sourceOld":"    /**\n     * Build a Node tree structure representing all Xpaths of intrest to us.\n     * This must be done before parsing of the XML stream starts. Each node \n     * holds one portion of an Xpath. Taking each Xpath segment in turn this\n     * method walks the Node tree  and finds where the new segment should be\n     * inserted. It creates a Node representing a field's name, XPATH and \n     * some flags and inserts the Node into the Node tree.\n     */\n    private void build(\n        List<String> paths,   // a List of segments from the split xpaths\n        String fieldName,     // the fieldName assoc with this Xpath\n        boolean multiValued,  // flag if this fieldName is multiValued or not\n        boolean record,       // is this xpath a record or a field\n        int flags             // are we to flatten matching xpaths\n        ) {\n      // recursivly walk the paths Lists adding new Nodes as required\n      String xpseg = paths.remove(0); // shift out next Xpath segment\n\n      if (paths.isEmpty() && xpseg.startsWith(\"@\")) {\n        // we have reached end of element portion of Xpath and can now only\n        // have an element attribute. Add it to this nodes list of attributes\n        if (attributes == null) {\n          attributes = new ArrayList<Node>();\n        }\n        xpseg = xpseg.substring(1); // strip the '@'\n        attributes.add(new Node(xpseg, fieldName, multiValued));\n      }\n      else if ( xpseg.length() == 0) {\n        // we have a '//' selector for all decendents of the current nodes\n        xpseg = paths.remove(0); // shift out next Xpath segment\n        if (wildCardNodes == null) wildCardNodes = new ArrayList<Node>();\n        Node n = getOrAddNode(xpseg, wildCardNodes);\n        if (paths.isEmpty()) {\n          // We are current a leaf node.\n          // xpath with content we want to store and return\n          n.hasText = true;        // we have to store text found here\n          n.fieldName = fieldName; // name to store collected text against\n          n.multiValued = multiValued; // true: text be stored in a List\n          n.flatten = flags == FLATTEN; // true: store text from child tags\n        }\n        else {\n          // recurse to handle next paths segment\n          n.build(paths, fieldName, multiValued, record, flags);\n        }\n      }\n      else {\n        if (childNodes == null)\n          childNodes = new ArrayList<Node>();\n        // does this \"name\" already exist as a child node.\n        Node n = getOrAddNode(xpseg,childNodes);\n        if (paths.isEmpty()) {\n          // We have emptied paths, we are for the moment a leaf of the tree.\n          // When parsing the actual input we have traversed to a position \n          // where we actutally have to do something. getOrAddNode() will\n          // have created and returned a new minimal Node with name and\n          // xpathName already populated. We need to add more information.\n          if (record) {\n            // forEach attribute\n            n.isRecord = true; // flag: forEach attribute, prepare to emit rec\n            n.forEachPath = fieldName; // the full forEach attribute xpath\n          } else {\n            // xpath with content we want to store and return\n            n.hasText = true;        // we have to store text found here\n            n.fieldName = fieldName; // name to store collected text against\n            n.multiValued = multiValued; // true: text be stored in a List\n            n.flatten = flags == FLATTEN; // true: store text from child tags\n          }\n        } else {\n          // recurse to handle next paths segment\n          n.build(paths, fieldName, multiValued, record, flags);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader.Node#build(List[String],String,boolean,boolean,int).mjava","pathOld":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader.Node#build(List[String],String,boolean,boolean,int).mjava","sourceNew":"    /**\n     * Build a Node tree structure representing all Xpaths of intrest to us.\n     * This must be done before parsing of the XML stream starts. Each node \n     * holds one portion of an Xpath. Taking each Xpath segment in turn this\n     * method walks the Node tree  and finds where the new segment should be\n     * inserted. It creates a Node representing a field's name, XPATH and \n     * some flags and inserts the Node into the Node tree.\n     */\n    private void build(\n        List<String> paths,   // a List of segments from the split xpaths\n        String fieldName,     // the fieldName assoc with this Xpath\n        boolean multiValued,  // flag if this fieldName is multiValued or not\n        boolean record,       // is this xpath a record or a field\n        int flags             // are we to flatten matching xpaths\n        ) {\n      // recursivly walk the paths Lists adding new Nodes as required\n      String xpseg = paths.remove(0); // shift out next Xpath segment\n\n      if (paths.isEmpty() && xpseg.startsWith(\"@\")) {\n        // we have reached end of element portion of Xpath and can now only\n        // have an element attribute. Add it to this nodes list of attributes\n        if (attributes == null) {\n          attributes = new ArrayList<Node>();\n        }\n        xpseg = xpseg.substring(1); // strip the '@'\n        attributes.add(new Node(xpseg, fieldName, multiValued));\n      }\n      else if ( xpseg.length() == 0) {\n        // we have a '//' selector for all decendents of the current nodes\n        xpseg = paths.remove(0); // shift out next Xpath segment\n        if (wildCardNodes == null) wildCardNodes = new ArrayList<Node>();\n        Node n = getOrAddNode(xpseg, wildCardNodes);\n        if (paths.isEmpty()) {\n          // We are current a leaf node.\n          // xpath with content we want to store and return\n          n.hasText = true;        // we have to store text found here\n          n.fieldName = fieldName; // name to store collected text against\n          n.multiValued = multiValued; // true: text be stored in a List\n          n.flatten = flags == FLATTEN; // true: store text from child tags\n        }\n        else {\n          // recurse to handle next paths segment\n          n.build(paths, fieldName, multiValued, record, flags);\n        }\n      }\n      else {\n        if (childNodes == null)\n          childNodes = new ArrayList<Node>();\n        // does this \"name\" already exist as a child node.\n        Node n = getOrAddNode(xpseg,childNodes);\n        if (paths.isEmpty()) {\n          // We have emptied paths, we are for the moment a leaf of the tree.\n          // When parsing the actual input we have traversed to a position \n          // where we actutally have to do something. getOrAddNode() will\n          // have created and returned a new minimal Node with name and\n          // xpathName already populated. We need to add more information.\n          if (record) {\n            // forEach attribute\n            n.isRecord = true; // flag: forEach attribute, prepare to emit rec\n            n.forEachPath = fieldName; // the full forEach attribute xpath\n          } else {\n            // xpath with content we want to store and return\n            n.hasText = true;        // we have to store text found here\n            n.fieldName = fieldName; // name to store collected text against\n            n.multiValued = multiValued; // true: text be stored in a List\n            n.flatten = flags == FLATTEN; // true: store text from child tags\n          }\n        } else {\n          // recurse to handle next paths segment\n          n.build(paths, fieldName, multiValued, record, flags);\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Build a Node tree structure representing all Xpaths of intrest to us.\n     * This must be done before parsing of the XML stream starts. Each node \n     * holds one portion of an Xpath. Taking each Xpath segment in turn this\n     * method walks the Node tree  and finds where the new segment should be\n     * inserted. It creates a Node representing a field's name, XPATH and \n     * some flags and inserts the Node into the Node tree.\n     */\n    private void build(\n        List<String> paths,   // a List of segments from the split xpaths\n        String fieldName,     // the fieldName assoc with this Xpath\n        boolean multiValued,  // flag if this fieldName is multiValued or not\n        boolean record,       // is this xpath a record or a field\n        int flags             // are we to flatten matching xpaths\n        ) {\n      // recursivly walk the paths Lists adding new Nodes as required\n      String xpseg = paths.remove(0); // shift out next Xpath segment\n\n      if (paths.isEmpty() && xpseg.startsWith(\"@\")) {\n        // we have reached end of element portion of Xpath and can now only\n        // have an element attribute. Add it to this nodes list of attributes\n        if (attributes == null) {\n          attributes = new ArrayList<Node>();\n        }\n        xpseg = xpseg.substring(1); // strip the '@'\n        attributes.add(new Node(xpseg, fieldName, multiValued));\n      }\n      else if ( xpseg.length() == 0) {\n        // we have a '//' selector for all decendents of the current nodes\n        xpseg = paths.remove(0); // shift out next Xpath segment\n        if (wildCardNodes == null) wildCardNodes = new ArrayList<Node>();\n        Node n = getOrAddNode(xpseg, wildCardNodes);\n        if (paths.isEmpty()) {\n          // We are current a leaf node.\n          // xpath with content we want to store and return\n          n.hasText = true;        // we have to store text found here\n          n.fieldName = fieldName; // name to store collected text against\n          n.multiValued = multiValued; // true: text be stored in a List\n          n.flatten = flags == FLATTEN; // true: store text from child tags\n        }\n        else {\n          // recurse to handle next paths segment\n          n.build(paths, fieldName, multiValued, record, flags);\n        }\n      }\n      else {\n        if (childNodes == null)\n          childNodes = new ArrayList<Node>();\n        // does this \"name\" already exist as a child node.\n        Node n = getOrAddNode(xpseg,childNodes);\n        if (paths.isEmpty()) {\n          // We have emptied paths, we are for the moment a leaf of the tree.\n          // When parsing the actual input we have traversed to a position \n          // where we actutally have to do something. getOrAddNode() will\n          // have created and returned a new minimal Node with name and\n          // xpathName already populated. We need to add more information.\n          if (record) {\n            // forEach attribute\n            n.isRecord = true; // flag: forEach attribute, prepare to emit rec\n            n.forEachPath = fieldName; // the full forEach attribute xpath\n          } else {\n            // xpath with content we want to store and return\n            n.hasText = true;        // we have to store text found here\n            n.fieldName = fieldName; // name to store collected text against\n            n.multiValued = multiValued; // true: text be stored in a List\n            n.flatten = flags == FLATTEN; // true: store text from child tags\n          }\n        } else {\n          // recurse to handle next paths segment\n          n.build(paths, fieldName, multiValued, record, flags);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da8d55113b689b06716246649de6f62430f15c0","date":1453508340,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader.Node#build(List[String],String,boolean,boolean,int).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Build a Node tree structure representing all Xpaths of intrest to us.\n     * This must be done before parsing of the XML stream starts. Each node \n     * holds one portion of an Xpath. Taking each Xpath segment in turn this\n     * method walks the Node tree  and finds where the new segment should be\n     * inserted. It creates a Node representing a field's name, XPATH and \n     * some flags and inserts the Node into the Node tree.\n     */\n    private void build(\n        List<String> paths,   // a List of segments from the split xpaths\n        String fieldName,     // the fieldName assoc with this Xpath\n        boolean multiValued,  // flag if this fieldName is multiValued or not\n        boolean record,       // is this xpath a record or a field\n        int flags             // are we to flatten matching xpaths\n        ) {\n      // recursivly walk the paths Lists adding new Nodes as required\n      String xpseg = paths.remove(0); // shift out next Xpath segment\n\n      if (paths.isEmpty() && xpseg.startsWith(\"@\")) {\n        // we have reached end of element portion of Xpath and can now only\n        // have an element attribute. Add it to this nodes list of attributes\n        if (attributes == null) {\n          attributes = new ArrayList<Node>();\n        }\n        xpseg = xpseg.substring(1); // strip the '@'\n        attributes.add(new Node(xpseg, fieldName, multiValued));\n      }\n      else if ( xpseg.length() == 0) {\n        // we have a '//' selector for all decendents of the current nodes\n        xpseg = paths.remove(0); // shift out next Xpath segment\n        if (wildCardNodes == null) wildCardNodes = new ArrayList<Node>();\n        Node n = getOrAddNode(xpseg, wildCardNodes);\n        if (paths.isEmpty()) {\n          // We are current a leaf node.\n          // xpath with content we want to store and return\n          n.hasText = true;        // we have to store text found here\n          n.fieldName = fieldName; // name to store collected text against\n          n.multiValued = multiValued; // true: text be stored in a List\n          n.flatten = flags == FLATTEN; // true: store text from child tags\n        }\n        else {\n          // recurse to handle next paths segment\n          n.build(paths, fieldName, multiValued, record, flags);\n        }\n      }\n      else {\n        if (childNodes == null)\n          childNodes = new ArrayList<Node>();\n        // does this \"name\" already exist as a child node.\n        Node n = getOrAddNode(xpseg,childNodes);\n        if (paths.isEmpty()) {\n          // We have emptied paths, we are for the moment a leaf of the tree.\n          // When parsing the actual input we have traversed to a position \n          // where we actutally have to do something. getOrAddNode() will\n          // have created and returned a new minimal Node with name and\n          // xpathName already populated. We need to add more information.\n          if (record) {\n            // forEach attribute\n            n.isRecord = true; // flag: forEach attribute, prepare to emit rec\n            n.forEachPath = fieldName; // the full forEach attribute xpath\n          } else {\n            // xpath with content we want to store and return\n            n.hasText = true;        // we have to store text found here\n            n.fieldName = fieldName; // name to store collected text against\n            n.multiValued = multiValued; // true: text be stored in a List\n            n.flatten = flags == FLATTEN; // true: store text from child tags\n          }\n        } else {\n          // recurse to handle next paths segment\n          n.build(paths, fieldName, multiValued, record, flags);\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/XPathRecordReader.Node#build(List[String],String,boolean,boolean,int).mjava","pathOld":"solr/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader.Node#build(List[String],String,boolean,boolean,int).mjava","sourceNew":"    /**\n     * Build a Node tree structure representing all Xpaths of intrest to us.\n     * This must be done before parsing of the XML stream starts. Each node \n     * holds one portion of an Xpath. Taking each Xpath segment in turn this\n     * method walks the Node tree  and finds where the new segment should be\n     * inserted. It creates a Node representing a field's name, XPATH and \n     * some flags and inserts the Node into the Node tree.\n     */\n    private void build(\n        List<String> paths,   // a List of segments from the split xpaths\n        String fieldName,     // the fieldName assoc with this Xpath\n        boolean multiValued,  // flag if this fieldName is multiValued or not\n        boolean record,       // is this xpath a record or a field\n        int flags             // are we to flatten matching xpaths\n        ) {\n      // recursivly walk the paths Lists adding new Nodes as required\n      String xpseg = paths.remove(0); // shift out next Xpath segment\n\n      if (paths.isEmpty() && xpseg.startsWith(\"@\")) {\n        // we have reached end of element portion of Xpath and can now only\n        // have an element attribute. Add it to this nodes list of attributes\n        if (attributes == null) {\n          attributes = new ArrayList<Node>();\n        }\n        xpseg = xpseg.substring(1); // strip the '@'\n        attributes.add(new Node(xpseg, fieldName, multiValued));\n      }\n      else if ( xpseg.length() == 0) {\n        // we have a '//' selector for all decendents of the current nodes\n        xpseg = paths.remove(0); // shift out next Xpath segment\n        if (wildCardNodes == null) wildCardNodes = new ArrayList<Node>();\n        Node n = getOrAddNode(xpseg, wildCardNodes);\n        if (paths.isEmpty()) {\n          // We are current a leaf node.\n          // xpath with content we want to store and return\n          n.hasText = true;        // we have to store text found here\n          n.fieldName = fieldName; // name to store collected text against\n          n.multiValued = multiValued; // true: text be stored in a List\n          n.flatten = flags == FLATTEN; // true: store text from child tags\n        }\n        else {\n          // recurse to handle next paths segment\n          n.build(paths, fieldName, multiValued, record, flags);\n        }\n      }\n      else {\n        if (childNodes == null)\n          childNodes = new ArrayList<Node>();\n        // does this \"name\" already exist as a child node.\n        Node n = getOrAddNode(xpseg,childNodes);\n        if (paths.isEmpty()) {\n          // We have emptied paths, we are for the moment a leaf of the tree.\n          // When parsing the actual input we have traversed to a position \n          // where we actutally have to do something. getOrAddNode() will\n          // have created and returned a new minimal Node with name and\n          // xpathName already populated. We need to add more information.\n          if (record) {\n            // forEach attribute\n            n.isRecord = true; // flag: forEach attribute, prepare to emit rec\n            n.forEachPath = fieldName; // the full forEach attribute xpath\n          } else {\n            // xpath with content we want to store and return\n            n.hasText = true;        // we have to store text found here\n            n.fieldName = fieldName; // name to store collected text against\n            n.multiValued = multiValued; // true: text be stored in a List\n            n.flatten = flags == FLATTEN; // true: store text from child tags\n          }\n        } else {\n          // recurse to handle next paths segment\n          n.build(paths, fieldName, multiValued, record, flags);\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Build a Node tree structure representing all Xpaths of intrest to us.\n     * This must be done before parsing of the XML stream starts. Each node \n     * holds one portion of an Xpath. Taking each Xpath segment in turn this\n     * method walks the Node tree  and finds where the new segment should be\n     * inserted. It creates a Node representing a field's name, XPATH and \n     * some flags and inserts the Node into the Node tree.\n     */\n    private void build(\n        List<String> paths,   // a List of segments from the split xpaths\n        String fieldName,     // the fieldName assoc with this Xpath\n        boolean multiValued,  // flag if this fieldName is multiValued or not\n        boolean record,       // is this xpath a record or a field\n        int flags             // are we to flatten matching xpaths\n        ) {\n      // recursivly walk the paths Lists adding new Nodes as required\n      String xpseg = paths.remove(0); // shift out next Xpath segment\n\n      if (paths.isEmpty() && xpseg.startsWith(\"@\")) {\n        // we have reached end of element portion of Xpath and can now only\n        // have an element attribute. Add it to this nodes list of attributes\n        if (attributes == null) {\n          attributes = new ArrayList<Node>();\n        }\n        xpseg = xpseg.substring(1); // strip the '@'\n        attributes.add(new Node(xpseg, fieldName, multiValued));\n      }\n      else if ( xpseg.length() == 0) {\n        // we have a '//' selector for all decendents of the current nodes\n        xpseg = paths.remove(0); // shift out next Xpath segment\n        if (wildCardNodes == null) wildCardNodes = new ArrayList<Node>();\n        Node n = getOrAddNode(xpseg, wildCardNodes);\n        if (paths.isEmpty()) {\n          // We are current a leaf node.\n          // xpath with content we want to store and return\n          n.hasText = true;        // we have to store text found here\n          n.fieldName = fieldName; // name to store collected text against\n          n.multiValued = multiValued; // true: text be stored in a List\n          n.flatten = flags == FLATTEN; // true: store text from child tags\n        }\n        else {\n          // recurse to handle next paths segment\n          n.build(paths, fieldName, multiValued, record, flags);\n        }\n      }\n      else {\n        if (childNodes == null)\n          childNodes = new ArrayList<Node>();\n        // does this \"name\" already exist as a child node.\n        Node n = getOrAddNode(xpseg,childNodes);\n        if (paths.isEmpty()) {\n          // We have emptied paths, we are for the moment a leaf of the tree.\n          // When parsing the actual input we have traversed to a position \n          // where we actutally have to do something. getOrAddNode() will\n          // have created and returned a new minimal Node with name and\n          // xpathName already populated. We need to add more information.\n          if (record) {\n            // forEach attribute\n            n.isRecord = true; // flag: forEach attribute, prepare to emit rec\n            n.forEachPath = fieldName; // the full forEach attribute xpath\n          } else {\n            // xpath with content we want to store and return\n            n.hasText = true;        // we have to store text found here\n            n.fieldName = fieldName; // name to store collected text against\n            n.multiValued = multiValued; // true: text be stored in a List\n            n.flatten = flags == FLATTEN; // true: store text from child tags\n          }\n        } else {\n          // recurse to handle next paths segment\n          n.build(paths, fieldName, multiValued, record, flags);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/XPathRecordReader.Node#build(List[String],String,boolean,boolean,int).mjava","pathOld":"solr/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader.Node#build(List[String],String,boolean,boolean,int).mjava","sourceNew":"    /**\n     * Build a Node tree structure representing all Xpaths of intrest to us.\n     * This must be done before parsing of the XML stream starts. Each node \n     * holds one portion of an Xpath. Taking each Xpath segment in turn this\n     * method walks the Node tree  and finds where the new segment should be\n     * inserted. It creates a Node representing a field's name, XPATH and \n     * some flags and inserts the Node into the Node tree.\n     */\n    private void build(\n        List<String> paths,   // a List of segments from the split xpaths\n        String fieldName,     // the fieldName assoc with this Xpath\n        boolean multiValued,  // flag if this fieldName is multiValued or not\n        boolean record,       // is this xpath a record or a field\n        int flags             // are we to flatten matching xpaths\n        ) {\n      // recursivly walk the paths Lists adding new Nodes as required\n      String xpseg = paths.remove(0); // shift out next Xpath segment\n\n      if (paths.isEmpty() && xpseg.startsWith(\"@\")) {\n        // we have reached end of element portion of Xpath and can now only\n        // have an element attribute. Add it to this nodes list of attributes\n        if (attributes == null) {\n          attributes = new ArrayList<Node>();\n        }\n        xpseg = xpseg.substring(1); // strip the '@'\n        attributes.add(new Node(xpseg, fieldName, multiValued));\n      }\n      else if ( xpseg.length() == 0) {\n        // we have a '//' selector for all decendents of the current nodes\n        xpseg = paths.remove(0); // shift out next Xpath segment\n        if (wildCardNodes == null) wildCardNodes = new ArrayList<Node>();\n        Node n = getOrAddNode(xpseg, wildCardNodes);\n        if (paths.isEmpty()) {\n          // We are current a leaf node.\n          // xpath with content we want to store and return\n          n.hasText = true;        // we have to store text found here\n          n.fieldName = fieldName; // name to store collected text against\n          n.multiValued = multiValued; // true: text be stored in a List\n          n.flatten = flags == FLATTEN; // true: store text from child tags\n        }\n        else {\n          // recurse to handle next paths segment\n          n.build(paths, fieldName, multiValued, record, flags);\n        }\n      }\n      else {\n        if (childNodes == null)\n          childNodes = new ArrayList<Node>();\n        // does this \"name\" already exist as a child node.\n        Node n = getOrAddNode(xpseg,childNodes);\n        if (paths.isEmpty()) {\n          // We have emptied paths, we are for the moment a leaf of the tree.\n          // When parsing the actual input we have traversed to a position \n          // where we actutally have to do something. getOrAddNode() will\n          // have created and returned a new minimal Node with name and\n          // xpathName already populated. We need to add more information.\n          if (record) {\n            // forEach attribute\n            n.isRecord = true; // flag: forEach attribute, prepare to emit rec\n            n.forEachPath = fieldName; // the full forEach attribute xpath\n          } else {\n            // xpath with content we want to store and return\n            n.hasText = true;        // we have to store text found here\n            n.fieldName = fieldName; // name to store collected text against\n            n.multiValued = multiValued; // true: text be stored in a List\n            n.flatten = flags == FLATTEN; // true: store text from child tags\n          }\n        } else {\n          // recurse to handle next paths segment\n          n.build(paths, fieldName, multiValued, record, flags);\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Build a Node tree structure representing all Xpaths of intrest to us.\n     * This must be done before parsing of the XML stream starts. Each node \n     * holds one portion of an Xpath. Taking each Xpath segment in turn this\n     * method walks the Node tree  and finds where the new segment should be\n     * inserted. It creates a Node representing a field's name, XPATH and \n     * some flags and inserts the Node into the Node tree.\n     */\n    private void build(\n        List<String> paths,   // a List of segments from the split xpaths\n        String fieldName,     // the fieldName assoc with this Xpath\n        boolean multiValued,  // flag if this fieldName is multiValued or not\n        boolean record,       // is this xpath a record or a field\n        int flags             // are we to flatten matching xpaths\n        ) {\n      // recursivly walk the paths Lists adding new Nodes as required\n      String xpseg = paths.remove(0); // shift out next Xpath segment\n\n      if (paths.isEmpty() && xpseg.startsWith(\"@\")) {\n        // we have reached end of element portion of Xpath and can now only\n        // have an element attribute. Add it to this nodes list of attributes\n        if (attributes == null) {\n          attributes = new ArrayList<Node>();\n        }\n        xpseg = xpseg.substring(1); // strip the '@'\n        attributes.add(new Node(xpseg, fieldName, multiValued));\n      }\n      else if ( xpseg.length() == 0) {\n        // we have a '//' selector for all decendents of the current nodes\n        xpseg = paths.remove(0); // shift out next Xpath segment\n        if (wildCardNodes == null) wildCardNodes = new ArrayList<Node>();\n        Node n = getOrAddNode(xpseg, wildCardNodes);\n        if (paths.isEmpty()) {\n          // We are current a leaf node.\n          // xpath with content we want to store and return\n          n.hasText = true;        // we have to store text found here\n          n.fieldName = fieldName; // name to store collected text against\n          n.multiValued = multiValued; // true: text be stored in a List\n          n.flatten = flags == FLATTEN; // true: store text from child tags\n        }\n        else {\n          // recurse to handle next paths segment\n          n.build(paths, fieldName, multiValued, record, flags);\n        }\n      }\n      else {\n        if (childNodes == null)\n          childNodes = new ArrayList<Node>();\n        // does this \"name\" already exist as a child node.\n        Node n = getOrAddNode(xpseg,childNodes);\n        if (paths.isEmpty()) {\n          // We have emptied paths, we are for the moment a leaf of the tree.\n          // When parsing the actual input we have traversed to a position \n          // where we actutally have to do something. getOrAddNode() will\n          // have created and returned a new minimal Node with name and\n          // xpathName already populated. We need to add more information.\n          if (record) {\n            // forEach attribute\n            n.isRecord = true; // flag: forEach attribute, prepare to emit rec\n            n.forEachPath = fieldName; // the full forEach attribute xpath\n          } else {\n            // xpath with content we want to store and return\n            n.hasText = true;        // we have to store text found here\n            n.fieldName = fieldName; // name to store collected text against\n            n.multiValued = multiValued; // true: text be stored in a List\n            n.flatten = flags == FLATTEN; // true: store text from child tags\n          }\n        } else {\n          // recurse to handle next paths segment\n          n.build(paths, fieldName, multiValued, record, flags);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1da8d55113b689b06716246649de6f62430f15c0":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","ad94625fb8d088209f46650c8097196fec67f00c"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["1da8d55113b689b06716246649de6f62430f15c0","1da8d55113b689b06716246649de6f62430f15c0"],"c26f00b574427b55127e869b935845554afde1fa":["1da8d55113b689b06716246649de6f62430f15c0","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"ad94625fb8d088209f46650c8097196fec67f00c":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"]},"commit2Childs":{"1da8d55113b689b06716246649de6f62430f15c0":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","c26f00b574427b55127e869b935845554afde1fa"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["1da8d55113b689b06716246649de6f62430f15c0"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["c26f00b574427b55127e869b935845554afde1fa"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["ad94625fb8d088209f46650c8097196fec67f00c"],"ad94625fb8d088209f46650c8097196fec67f00c":["1da8d55113b689b06716246649de6f62430f15c0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}