{"path":"solr/core/src/java/org/apache/solr/handler/component/StatsField.HllOptions#parseHllOptions(SolrParams,SchemaField).mjava","commits":[{"id":"4a4e2c829188fb99886a64558664d79c9ac0fdf1","date":1431021538,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/StatsField.HllOptions#parseHllOptions(SolrParams,SchemaField).mjava","pathOld":"/dev/null","sourceNew":"    /** \n     * Creates an HllOptions based on the (local) params specified (if appropriate).\n     *\n     * @param localParams the LocalParams for this {@link StatsField}\n     * @param field the field corrisponding to this {@link StatsField}, may be null if these stats are over a value source\n     * @return the {@link HllOptions} to use basd on the params, or null if no {@link HLL} should be computed\n     * @throws SolrException if there are invalid options\n     */\n    public static HllOptions parseHllOptions(SolrParams localParams, SchemaField field) \n      throws SolrException {\n\n      String cardinalityOpt = localParams.get(Stat.cardinality.name());\n      if (StringUtils.isBlank(cardinalityOpt)) {\n        return null;\n      }\n\n      final NumericType hashableNumType = getHashableNumericType(field);\n\n      // some sane defaults\n      int log2m = 13;   // roughly equivilent to \"cardinality='0.33'\"\n      int regwidth = 6; // with decent hash, this is plenty for all valid long hashes\n\n      if (NumericType.FLOAT.equals(hashableNumType) || NumericType.INT.equals(hashableNumType)) {\n        // for 32bit values, we can adjust our default regwidth down a bit\n        regwidth--;\n\n        // NOTE: EnumField uses NumericType.INT, and in theory we could be super conservative\n        // with it, but there's no point - just let the EXPLICIT HLL handle it\n      }\n\n      // TODO: we could attempt additional reductions in the default regwidth based on index\n      // statistics -- but thta doesn't seem worth the effort.  for tiny indexes, the \n      // EXPLICIT and SPARSE HLL representations have us nicely covered, and in general we don't \n      // want to be too aggresive about lowering regwidth or we could really poor results if \n      // log2m is also low and  there is heavy hashkey collision\n\n      try {\n        // NFE will short out here if it's not a number\n        final double accuracyOpt = Double.parseDouble(cardinalityOpt);\n\n        // if a float between 0 and 1 is specified, treat it as a prefrence of accuracy\n        // - 0 means accuracy is not a concern, save RAM\n        // - 1 means be as accurate as possible, using as much RAM as needed.\n\n        if (accuracyOpt < 0D || 1.0D < accuracyOpt) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, ERR);\n        }\n\n        // use accuracyOpt as a scaling factor between min & max legal log2m values\n        log2m = HLL.MINIMUM_LOG2M_PARAM\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_LOG2M_PARAM - HLL.MINIMUM_LOG2M_PARAM));\n\n        // use accuracyOpt as a scaling factor for regwidth as well, BUT...\n        // be more conservative -- HLL.MIN_REGWIDTH_PARAM is too absurdly low to be useful\n        // use previously computed (hashableNumType) default regwidth -1 as lower bound for scaling\n        final int MIN_HUERISTIC_REGWIDTH = regwidth-1;\n        regwidth = MIN_HUERISTIC_REGWIDTH\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_REGWIDTH_PARAM - MIN_HUERISTIC_REGWIDTH));\n\n      } catch (NumberFormatException nfe) {\n        // param value isn't a number -- let's check for simple true/false\n        if (! localParams.getBool(Stat.cardinality.name(), false)) {\n          return null;\n        }\n      }\n\n      // let explicit params override both the default and/or any accuracy specification\n      log2m = localParams.getInt(\"hllLog2m\", log2m);\n      regwidth = localParams.getInt(\"hllRegwidth\", regwidth);\n\n      // validate legal values\n      if (log2m < HLL.MINIMUM_LOG2M_PARAM || HLL.MAXIMUM_LOG2M_PARAM < log2m) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllLog2m must be at least \" + \n                                HLL.MINIMUM_LOG2M_PARAM + \" and at most \" + HLL.MAXIMUM_LOG2M_PARAM\n                                + \" (\" + log2m +\")\");\n      }\n      if (regwidth < HLL.MINIMUM_REGWIDTH_PARAM || HLL.MAXIMUM_REGWIDTH_PARAM < regwidth) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllRegwidth must be at least \" + \n                                HLL.MINIMUM_REGWIDTH_PARAM + \" and at most \" + HLL.MAXIMUM_REGWIDTH_PARAM);\n      }\n      \n      HashFunction hasher = localParams.getBool(\"hllPreHashed\", false) ? null : Hashing.murmur3_128();\n\n      if (null == hasher) {\n        // if this is a function, or a non Long field, pre-hashed is invalid\n        // NOTE: we ignore hashableNumType - it's LONG for non numerics like Strings\n        if (null == field || !NumericType.LONG.equals(field.getType().getNumericType())) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"hllPreHashed is only supported with Long based fields\");\n        }\n      }\n\n      // if we're still here, then we need an HLL...\n      return new HllOptions(log2m, regwidth, hasher);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["9f4251f14d2db68330fc1e6f0495c053a905d560"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6d8714f9ceaaff94f0968d1c2d037978c3fde569","date":1437042727,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/StatsField.HllOptions#parseHllOptions(SolrParams,SchemaField).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/StatsField.HllOptions#parseHllOptions(SolrParams,SchemaField).mjava","sourceNew":"    /** \n     * Creates an HllOptions based on the (local) params specified (if appropriate).\n     *\n     * @param localParams the LocalParams for this {@link StatsField}\n     * @param field the field corresponding to this {@link StatsField}, may be null if these stats are over a value source\n     * @return the {@link HllOptions} to use based on the params, or null if no {@link HLL} should be computed\n     * @throws SolrException if there are invalid options\n     */\n    public static HllOptions parseHllOptions(SolrParams localParams, SchemaField field) \n      throws SolrException {\n\n      String cardinalityOpt = localParams.get(Stat.cardinality.name());\n      if (StringUtils.isBlank(cardinalityOpt)) {\n        return null;\n      }\n\n      final NumericType hashableNumType = getHashableNumericType(field);\n\n      // some sane defaults\n      int log2m = 13;   // roughly equivilent to \"cardinality='0.33'\"\n      int regwidth = 6; // with decent hash, this is plenty for all valid long hashes\n\n      if (NumericType.FLOAT.equals(hashableNumType) || NumericType.INT.equals(hashableNumType)) {\n        // for 32bit values, we can adjust our default regwidth down a bit\n        regwidth--;\n\n        // NOTE: EnumField uses NumericType.INT, and in theory we could be super conservative\n        // with it, but there's no point - just let the EXPLICIT HLL handle it\n      }\n\n      // TODO: we could attempt additional reductions in the default regwidth based on index\n      // statistics -- but thta doesn't seem worth the effort.  for tiny indexes, the \n      // EXPLICIT and SPARSE HLL representations have us nicely covered, and in general we don't \n      // want to be too aggresive about lowering regwidth or we could really poor results if \n      // log2m is also low and  there is heavy hashkey collision\n\n      try {\n        // NFE will short out here if it's not a number\n        final double accuracyOpt = Double.parseDouble(cardinalityOpt);\n\n        // if a float between 0 and 1 is specified, treat it as a prefrence of accuracy\n        // - 0 means accuracy is not a concern, save RAM\n        // - 1 means be as accurate as possible, using as much RAM as needed.\n\n        if (accuracyOpt < 0D || 1.0D < accuracyOpt) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, ERR);\n        }\n\n        // use accuracyOpt as a scaling factor between min & max legal log2m values\n        log2m = HLL.MINIMUM_LOG2M_PARAM\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_LOG2M_PARAM - HLL.MINIMUM_LOG2M_PARAM));\n\n        // use accuracyOpt as a scaling factor for regwidth as well, BUT...\n        // be more conservative -- HLL.MIN_REGWIDTH_PARAM is too absurdly low to be useful\n        // use previously computed (hashableNumType) default regwidth -1 as lower bound for scaling\n        final int MIN_HUERISTIC_REGWIDTH = regwidth-1;\n        regwidth = MIN_HUERISTIC_REGWIDTH\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_REGWIDTH_PARAM - MIN_HUERISTIC_REGWIDTH));\n\n      } catch (NumberFormatException nfe) {\n        // param value isn't a number -- let's check for simple true/false\n        if (! localParams.getBool(Stat.cardinality.name(), false)) {\n          return null;\n        }\n      }\n\n      // let explicit params override both the default and/or any accuracy specification\n      log2m = localParams.getInt(\"hllLog2m\", log2m);\n      regwidth = localParams.getInt(\"hllRegwidth\", regwidth);\n\n      // validate legal values\n      if (log2m < HLL.MINIMUM_LOG2M_PARAM || HLL.MAXIMUM_LOG2M_PARAM < log2m) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllLog2m must be at least \" + \n                                HLL.MINIMUM_LOG2M_PARAM + \" and at most \" + HLL.MAXIMUM_LOG2M_PARAM\n                                + \" (\" + log2m +\")\");\n      }\n      if (regwidth < HLL.MINIMUM_REGWIDTH_PARAM || HLL.MAXIMUM_REGWIDTH_PARAM < regwidth) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllRegwidth must be at least \" + \n                                HLL.MINIMUM_REGWIDTH_PARAM + \" and at most \" + HLL.MAXIMUM_REGWIDTH_PARAM);\n      }\n      \n      HashFunction hasher = localParams.getBool(\"hllPreHashed\", false) ? null : Hashing.murmur3_128();\n\n      if (null == hasher) {\n        // if this is a function, or a non Long field, pre-hashed is invalid\n        // NOTE: we ignore hashableNumType - it's LONG for non numerics like Strings\n        if (null == field || !NumericType.LONG.equals(field.getType().getNumericType())) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"hllPreHashed is only supported with Long based fields\");\n        }\n      }\n\n      // if we're still here, then we need an HLL...\n      return new HllOptions(log2m, regwidth, hasher);\n    }\n\n","sourceOld":"    /** \n     * Creates an HllOptions based on the (local) params specified (if appropriate).\n     *\n     * @param localParams the LocalParams for this {@link StatsField}\n     * @param field the field corrisponding to this {@link StatsField}, may be null if these stats are over a value source\n     * @return the {@link HllOptions} to use basd on the params, or null if no {@link HLL} should be computed\n     * @throws SolrException if there are invalid options\n     */\n    public static HllOptions parseHllOptions(SolrParams localParams, SchemaField field) \n      throws SolrException {\n\n      String cardinalityOpt = localParams.get(Stat.cardinality.name());\n      if (StringUtils.isBlank(cardinalityOpt)) {\n        return null;\n      }\n\n      final NumericType hashableNumType = getHashableNumericType(field);\n\n      // some sane defaults\n      int log2m = 13;   // roughly equivilent to \"cardinality='0.33'\"\n      int regwidth = 6; // with decent hash, this is plenty for all valid long hashes\n\n      if (NumericType.FLOAT.equals(hashableNumType) || NumericType.INT.equals(hashableNumType)) {\n        // for 32bit values, we can adjust our default regwidth down a bit\n        regwidth--;\n\n        // NOTE: EnumField uses NumericType.INT, and in theory we could be super conservative\n        // with it, but there's no point - just let the EXPLICIT HLL handle it\n      }\n\n      // TODO: we could attempt additional reductions in the default regwidth based on index\n      // statistics -- but thta doesn't seem worth the effort.  for tiny indexes, the \n      // EXPLICIT and SPARSE HLL representations have us nicely covered, and in general we don't \n      // want to be too aggresive about lowering regwidth or we could really poor results if \n      // log2m is also low and  there is heavy hashkey collision\n\n      try {\n        // NFE will short out here if it's not a number\n        final double accuracyOpt = Double.parseDouble(cardinalityOpt);\n\n        // if a float between 0 and 1 is specified, treat it as a prefrence of accuracy\n        // - 0 means accuracy is not a concern, save RAM\n        // - 1 means be as accurate as possible, using as much RAM as needed.\n\n        if (accuracyOpt < 0D || 1.0D < accuracyOpt) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, ERR);\n        }\n\n        // use accuracyOpt as a scaling factor between min & max legal log2m values\n        log2m = HLL.MINIMUM_LOG2M_PARAM\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_LOG2M_PARAM - HLL.MINIMUM_LOG2M_PARAM));\n\n        // use accuracyOpt as a scaling factor for regwidth as well, BUT...\n        // be more conservative -- HLL.MIN_REGWIDTH_PARAM is too absurdly low to be useful\n        // use previously computed (hashableNumType) default regwidth -1 as lower bound for scaling\n        final int MIN_HUERISTIC_REGWIDTH = regwidth-1;\n        regwidth = MIN_HUERISTIC_REGWIDTH\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_REGWIDTH_PARAM - MIN_HUERISTIC_REGWIDTH));\n\n      } catch (NumberFormatException nfe) {\n        // param value isn't a number -- let's check for simple true/false\n        if (! localParams.getBool(Stat.cardinality.name(), false)) {\n          return null;\n        }\n      }\n\n      // let explicit params override both the default and/or any accuracy specification\n      log2m = localParams.getInt(\"hllLog2m\", log2m);\n      regwidth = localParams.getInt(\"hllRegwidth\", regwidth);\n\n      // validate legal values\n      if (log2m < HLL.MINIMUM_LOG2M_PARAM || HLL.MAXIMUM_LOG2M_PARAM < log2m) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllLog2m must be at least \" + \n                                HLL.MINIMUM_LOG2M_PARAM + \" and at most \" + HLL.MAXIMUM_LOG2M_PARAM\n                                + \" (\" + log2m +\")\");\n      }\n      if (regwidth < HLL.MINIMUM_REGWIDTH_PARAM || HLL.MAXIMUM_REGWIDTH_PARAM < regwidth) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllRegwidth must be at least \" + \n                                HLL.MINIMUM_REGWIDTH_PARAM + \" and at most \" + HLL.MAXIMUM_REGWIDTH_PARAM);\n      }\n      \n      HashFunction hasher = localParams.getBool(\"hllPreHashed\", false) ? null : Hashing.murmur3_128();\n\n      if (null == hasher) {\n        // if this is a function, or a non Long field, pre-hashed is invalid\n        // NOTE: we ignore hashableNumType - it's LONG for non numerics like Strings\n        if (null == field || !NumericType.LONG.equals(field.getType().getNumericType())) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"hllPreHashed is only supported with Long based fields\");\n        }\n      }\n\n      // if we're still here, then we need an HLL...\n      return new HllOptions(log2m, regwidth, hasher);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3b5ee4c66244bdfcc4796a114519d47701b2c026","date":1437132013,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/StatsField.HllOptions#parseHllOptions(SolrParams,SchemaField).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/StatsField.HllOptions#parseHllOptions(SolrParams,SchemaField).mjava","sourceNew":"    /** \n     * Creates an HllOptions based on the (local) params specified (if appropriate).\n     *\n     * @param localParams the LocalParams for this {@link StatsField}\n     * @param field the field corresponding to this {@link StatsField}, may be null if these stats are over a value source\n     * @return the {@link HllOptions} to use based on the params, or null if no {@link HLL} should be computed\n     * @throws SolrException if there are invalid options\n     */\n    public static HllOptions parseHllOptions(SolrParams localParams, SchemaField field) \n      throws SolrException {\n\n      String cardinalityOpt = localParams.get(Stat.cardinality.name());\n      if (StringUtils.isBlank(cardinalityOpt)) {\n        return null;\n      }\n\n      final NumericType hashableNumType = getHashableNumericType(field);\n\n      // some sane defaults\n      int log2m = 13;   // roughly equivilent to \"cardinality='0.33'\"\n      int regwidth = 6; // with decent hash, this is plenty for all valid long hashes\n\n      if (NumericType.FLOAT.equals(hashableNumType) || NumericType.INT.equals(hashableNumType)) {\n        // for 32bit values, we can adjust our default regwidth down a bit\n        regwidth--;\n\n        // NOTE: EnumField uses NumericType.INT, and in theory we could be super conservative\n        // with it, but there's no point - just let the EXPLICIT HLL handle it\n      }\n\n      // TODO: we could attempt additional reductions in the default regwidth based on index\n      // statistics -- but thta doesn't seem worth the effort.  for tiny indexes, the \n      // EXPLICIT and SPARSE HLL representations have us nicely covered, and in general we don't \n      // want to be too aggresive about lowering regwidth or we could really poor results if \n      // log2m is also low and  there is heavy hashkey collision\n\n      try {\n        // NFE will short out here if it's not a number\n        final double accuracyOpt = Double.parseDouble(cardinalityOpt);\n\n        // if a float between 0 and 1 is specified, treat it as a prefrence of accuracy\n        // - 0 means accuracy is not a concern, save RAM\n        // - 1 means be as accurate as possible, using as much RAM as needed.\n\n        if (accuracyOpt < 0D || 1.0D < accuracyOpt) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, ERR);\n        }\n\n        // use accuracyOpt as a scaling factor between min & max legal log2m values\n        log2m = HLL.MINIMUM_LOG2M_PARAM\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_LOG2M_PARAM - HLL.MINIMUM_LOG2M_PARAM));\n\n        // use accuracyOpt as a scaling factor for regwidth as well, BUT...\n        // be more conservative -- HLL.MIN_REGWIDTH_PARAM is too absurdly low to be useful\n        // use previously computed (hashableNumType) default regwidth -1 as lower bound for scaling\n        final int MIN_HUERISTIC_REGWIDTH = regwidth-1;\n        regwidth = MIN_HUERISTIC_REGWIDTH\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_REGWIDTH_PARAM - MIN_HUERISTIC_REGWIDTH));\n\n      } catch (NumberFormatException nfe) {\n        // param value isn't a number -- let's check for simple true/false\n        if (! localParams.getBool(Stat.cardinality.name(), false)) {\n          return null;\n        }\n      }\n\n      // let explicit params override both the default and/or any accuracy specification\n      log2m = localParams.getInt(\"hllLog2m\", log2m);\n      regwidth = localParams.getInt(\"hllRegwidth\", regwidth);\n\n      // validate legal values\n      if (log2m < HLL.MINIMUM_LOG2M_PARAM || HLL.MAXIMUM_LOG2M_PARAM < log2m) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllLog2m must be at least \" + \n                                HLL.MINIMUM_LOG2M_PARAM + \" and at most \" + HLL.MAXIMUM_LOG2M_PARAM\n                                + \" (\" + log2m +\")\");\n      }\n      if (regwidth < HLL.MINIMUM_REGWIDTH_PARAM || HLL.MAXIMUM_REGWIDTH_PARAM < regwidth) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllRegwidth must be at least \" + \n                                HLL.MINIMUM_REGWIDTH_PARAM + \" and at most \" + HLL.MAXIMUM_REGWIDTH_PARAM);\n      }\n      \n      HashFunction hasher = localParams.getBool(\"hllPreHashed\", false) ? null : Hashing.murmur3_128();\n\n      if (null == hasher) {\n        // if this is a function, or a non Long field, pre-hashed is invalid\n        // NOTE: we ignore hashableNumType - it's LONG for non numerics like Strings\n        if (null == field || !NumericType.LONG.equals(field.getType().getNumericType())) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"hllPreHashed is only supported with Long based fields\");\n        }\n      }\n\n      // if we're still here, then we need an HLL...\n      return new HllOptions(log2m, regwidth, hasher);\n    }\n\n","sourceOld":"    /** \n     * Creates an HllOptions based on the (local) params specified (if appropriate).\n     *\n     * @param localParams the LocalParams for this {@link StatsField}\n     * @param field the field corrisponding to this {@link StatsField}, may be null if these stats are over a value source\n     * @return the {@link HllOptions} to use basd on the params, or null if no {@link HLL} should be computed\n     * @throws SolrException if there are invalid options\n     */\n    public static HllOptions parseHllOptions(SolrParams localParams, SchemaField field) \n      throws SolrException {\n\n      String cardinalityOpt = localParams.get(Stat.cardinality.name());\n      if (StringUtils.isBlank(cardinalityOpt)) {\n        return null;\n      }\n\n      final NumericType hashableNumType = getHashableNumericType(field);\n\n      // some sane defaults\n      int log2m = 13;   // roughly equivilent to \"cardinality='0.33'\"\n      int regwidth = 6; // with decent hash, this is plenty for all valid long hashes\n\n      if (NumericType.FLOAT.equals(hashableNumType) || NumericType.INT.equals(hashableNumType)) {\n        // for 32bit values, we can adjust our default regwidth down a bit\n        regwidth--;\n\n        // NOTE: EnumField uses NumericType.INT, and in theory we could be super conservative\n        // with it, but there's no point - just let the EXPLICIT HLL handle it\n      }\n\n      // TODO: we could attempt additional reductions in the default regwidth based on index\n      // statistics -- but thta doesn't seem worth the effort.  for tiny indexes, the \n      // EXPLICIT and SPARSE HLL representations have us nicely covered, and in general we don't \n      // want to be too aggresive about lowering regwidth or we could really poor results if \n      // log2m is also low and  there is heavy hashkey collision\n\n      try {\n        // NFE will short out here if it's not a number\n        final double accuracyOpt = Double.parseDouble(cardinalityOpt);\n\n        // if a float between 0 and 1 is specified, treat it as a prefrence of accuracy\n        // - 0 means accuracy is not a concern, save RAM\n        // - 1 means be as accurate as possible, using as much RAM as needed.\n\n        if (accuracyOpt < 0D || 1.0D < accuracyOpt) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, ERR);\n        }\n\n        // use accuracyOpt as a scaling factor between min & max legal log2m values\n        log2m = HLL.MINIMUM_LOG2M_PARAM\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_LOG2M_PARAM - HLL.MINIMUM_LOG2M_PARAM));\n\n        // use accuracyOpt as a scaling factor for regwidth as well, BUT...\n        // be more conservative -- HLL.MIN_REGWIDTH_PARAM is too absurdly low to be useful\n        // use previously computed (hashableNumType) default regwidth -1 as lower bound for scaling\n        final int MIN_HUERISTIC_REGWIDTH = regwidth-1;\n        regwidth = MIN_HUERISTIC_REGWIDTH\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_REGWIDTH_PARAM - MIN_HUERISTIC_REGWIDTH));\n\n      } catch (NumberFormatException nfe) {\n        // param value isn't a number -- let's check for simple true/false\n        if (! localParams.getBool(Stat.cardinality.name(), false)) {\n          return null;\n        }\n      }\n\n      // let explicit params override both the default and/or any accuracy specification\n      log2m = localParams.getInt(\"hllLog2m\", log2m);\n      regwidth = localParams.getInt(\"hllRegwidth\", regwidth);\n\n      // validate legal values\n      if (log2m < HLL.MINIMUM_LOG2M_PARAM || HLL.MAXIMUM_LOG2M_PARAM < log2m) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllLog2m must be at least \" + \n                                HLL.MINIMUM_LOG2M_PARAM + \" and at most \" + HLL.MAXIMUM_LOG2M_PARAM\n                                + \" (\" + log2m +\")\");\n      }\n      if (regwidth < HLL.MINIMUM_REGWIDTH_PARAM || HLL.MAXIMUM_REGWIDTH_PARAM < regwidth) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllRegwidth must be at least \" + \n                                HLL.MINIMUM_REGWIDTH_PARAM + \" and at most \" + HLL.MAXIMUM_REGWIDTH_PARAM);\n      }\n      \n      HashFunction hasher = localParams.getBool(\"hllPreHashed\", false) ? null : Hashing.murmur3_128();\n\n      if (null == hasher) {\n        // if this is a function, or a non Long field, pre-hashed is invalid\n        // NOTE: we ignore hashableNumType - it's LONG for non numerics like Strings\n        if (null == field || !NumericType.LONG.equals(field.getType().getNumericType())) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"hllPreHashed is only supported with Long based fields\");\n        }\n      }\n\n      // if we're still here, then we need an HLL...\n      return new HllOptions(log2m, regwidth, hasher);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"770342641f7b505eaa8dccdc666158bff2419109","date":1449868421,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/StatsField.HllOptions#parseHllOptions(SolrParams,SchemaField).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/StatsField.HllOptions#parseHllOptions(SolrParams,SchemaField).mjava","sourceNew":"    /** \n     * Creates an HllOptions based on the (local) params specified (if appropriate).\n     *\n     * @param localParams the LocalParams for this {@link StatsField}\n     * @param field the field corresponding to this {@link StatsField}, may be null if these stats are over a value source\n     * @return the {@link HllOptions} to use based on the params, or null if no {@link HLL} should be computed\n     * @throws SolrException if there are invalid options\n     */\n    public static HllOptions parseHllOptions(SolrParams localParams, SchemaField field) \n      throws SolrException {\n\n      String cardinalityOpt = localParams.get(Stat.cardinality.name());\n      if (StringUtils.isBlank(cardinalityOpt)) {\n        return null;\n      }\n\n      final FieldType.LegacyNumericType hashableNumType = getHashableNumericType(field);\n\n      // some sane defaults\n      int log2m = 13;   // roughly equivilent to \"cardinality='0.33'\"\n      int regwidth = 6; // with decent hash, this is plenty for all valid long hashes\n\n      if (LegacyNumericType.FLOAT.equals(hashableNumType) || FieldType.LegacyNumericType.INT.equals(hashableNumType)) {\n        // for 32bit values, we can adjust our default regwidth down a bit\n        regwidth--;\n\n        // NOTE: EnumField uses LegacyNumericType.INT, and in theory we could be super conservative\n        // with it, but there's no point - just let the EXPLICIT HLL handle it\n      }\n\n      // TODO: we could attempt additional reductions in the default regwidth based on index\n      // statistics -- but thta doesn't seem worth the effort.  for tiny indexes, the \n      // EXPLICIT and SPARSE HLL representations have us nicely covered, and in general we don't \n      // want to be too aggresive about lowering regwidth or we could really poor results if \n      // log2m is also low and  there is heavy hashkey collision\n\n      try {\n        // NFE will short out here if it's not a number\n        final double accuracyOpt = Double.parseDouble(cardinalityOpt);\n\n        // if a float between 0 and 1 is specified, treat it as a prefrence of accuracy\n        // - 0 means accuracy is not a concern, save RAM\n        // - 1 means be as accurate as possible, using as much RAM as needed.\n\n        if (accuracyOpt < 0D || 1.0D < accuracyOpt) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, ERR);\n        }\n\n        // use accuracyOpt as a scaling factor between min & max legal log2m values\n        log2m = HLL.MINIMUM_LOG2M_PARAM\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_LOG2M_PARAM - HLL.MINIMUM_LOG2M_PARAM));\n\n        // use accuracyOpt as a scaling factor for regwidth as well, BUT...\n        // be more conservative -- HLL.MIN_REGWIDTH_PARAM is too absurdly low to be useful\n        // use previously computed (hashableNumType) default regwidth -1 as lower bound for scaling\n        final int MIN_HUERISTIC_REGWIDTH = regwidth-1;\n        regwidth = MIN_HUERISTIC_REGWIDTH\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_REGWIDTH_PARAM - MIN_HUERISTIC_REGWIDTH));\n\n      } catch (NumberFormatException nfe) {\n        // param value isn't a number -- let's check for simple true/false\n        if (! localParams.getBool(Stat.cardinality.name(), false)) {\n          return null;\n        }\n      }\n\n      // let explicit params override both the default and/or any accuracy specification\n      log2m = localParams.getInt(\"hllLog2m\", log2m);\n      regwidth = localParams.getInt(\"hllRegwidth\", regwidth);\n\n      // validate legal values\n      if (log2m < HLL.MINIMUM_LOG2M_PARAM || HLL.MAXIMUM_LOG2M_PARAM < log2m) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllLog2m must be at least \" + \n                                HLL.MINIMUM_LOG2M_PARAM + \" and at most \" + HLL.MAXIMUM_LOG2M_PARAM\n                                + \" (\" + log2m +\")\");\n      }\n      if (regwidth < HLL.MINIMUM_REGWIDTH_PARAM || HLL.MAXIMUM_REGWIDTH_PARAM < regwidth) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllRegwidth must be at least \" + \n                                HLL.MINIMUM_REGWIDTH_PARAM + \" and at most \" + HLL.MAXIMUM_REGWIDTH_PARAM);\n      }\n      \n      HashFunction hasher = localParams.getBool(\"hllPreHashed\", false) ? null : Hashing.murmur3_128();\n\n      if (null == hasher) {\n        // if this is a function, or a non Long field, pre-hashed is invalid\n        // NOTE: we ignore hashableNumType - it's LONG for non numerics like Strings\n        if (null == field || !FieldType.LegacyNumericType.LONG.equals(field.getType().getNumericType())) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"hllPreHashed is only supported with Long based fields\");\n        }\n      }\n\n      // if we're still here, then we need an HLL...\n      return new HllOptions(log2m, regwidth, hasher);\n    }\n\n","sourceOld":"    /** \n     * Creates an HllOptions based on the (local) params specified (if appropriate).\n     *\n     * @param localParams the LocalParams for this {@link StatsField}\n     * @param field the field corresponding to this {@link StatsField}, may be null if these stats are over a value source\n     * @return the {@link HllOptions} to use based on the params, or null if no {@link HLL} should be computed\n     * @throws SolrException if there are invalid options\n     */\n    public static HllOptions parseHllOptions(SolrParams localParams, SchemaField field) \n      throws SolrException {\n\n      String cardinalityOpt = localParams.get(Stat.cardinality.name());\n      if (StringUtils.isBlank(cardinalityOpt)) {\n        return null;\n      }\n\n      final NumericType hashableNumType = getHashableNumericType(field);\n\n      // some sane defaults\n      int log2m = 13;   // roughly equivilent to \"cardinality='0.33'\"\n      int regwidth = 6; // with decent hash, this is plenty for all valid long hashes\n\n      if (NumericType.FLOAT.equals(hashableNumType) || NumericType.INT.equals(hashableNumType)) {\n        // for 32bit values, we can adjust our default regwidth down a bit\n        regwidth--;\n\n        // NOTE: EnumField uses NumericType.INT, and in theory we could be super conservative\n        // with it, but there's no point - just let the EXPLICIT HLL handle it\n      }\n\n      // TODO: we could attempt additional reductions in the default regwidth based on index\n      // statistics -- but thta doesn't seem worth the effort.  for tiny indexes, the \n      // EXPLICIT and SPARSE HLL representations have us nicely covered, and in general we don't \n      // want to be too aggresive about lowering regwidth or we could really poor results if \n      // log2m is also low and  there is heavy hashkey collision\n\n      try {\n        // NFE will short out here if it's not a number\n        final double accuracyOpt = Double.parseDouble(cardinalityOpt);\n\n        // if a float between 0 and 1 is specified, treat it as a prefrence of accuracy\n        // - 0 means accuracy is not a concern, save RAM\n        // - 1 means be as accurate as possible, using as much RAM as needed.\n\n        if (accuracyOpt < 0D || 1.0D < accuracyOpt) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, ERR);\n        }\n\n        // use accuracyOpt as a scaling factor between min & max legal log2m values\n        log2m = HLL.MINIMUM_LOG2M_PARAM\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_LOG2M_PARAM - HLL.MINIMUM_LOG2M_PARAM));\n\n        // use accuracyOpt as a scaling factor for regwidth as well, BUT...\n        // be more conservative -- HLL.MIN_REGWIDTH_PARAM is too absurdly low to be useful\n        // use previously computed (hashableNumType) default regwidth -1 as lower bound for scaling\n        final int MIN_HUERISTIC_REGWIDTH = regwidth-1;\n        regwidth = MIN_HUERISTIC_REGWIDTH\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_REGWIDTH_PARAM - MIN_HUERISTIC_REGWIDTH));\n\n      } catch (NumberFormatException nfe) {\n        // param value isn't a number -- let's check for simple true/false\n        if (! localParams.getBool(Stat.cardinality.name(), false)) {\n          return null;\n        }\n      }\n\n      // let explicit params override both the default and/or any accuracy specification\n      log2m = localParams.getInt(\"hllLog2m\", log2m);\n      regwidth = localParams.getInt(\"hllRegwidth\", regwidth);\n\n      // validate legal values\n      if (log2m < HLL.MINIMUM_LOG2M_PARAM || HLL.MAXIMUM_LOG2M_PARAM < log2m) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllLog2m must be at least \" + \n                                HLL.MINIMUM_LOG2M_PARAM + \" and at most \" + HLL.MAXIMUM_LOG2M_PARAM\n                                + \" (\" + log2m +\")\");\n      }\n      if (regwidth < HLL.MINIMUM_REGWIDTH_PARAM || HLL.MAXIMUM_REGWIDTH_PARAM < regwidth) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllRegwidth must be at least \" + \n                                HLL.MINIMUM_REGWIDTH_PARAM + \" and at most \" + HLL.MAXIMUM_REGWIDTH_PARAM);\n      }\n      \n      HashFunction hasher = localParams.getBool(\"hllPreHashed\", false) ? null : Hashing.murmur3_128();\n\n      if (null == hasher) {\n        // if this is a function, or a non Long field, pre-hashed is invalid\n        // NOTE: we ignore hashableNumType - it's LONG for non numerics like Strings\n        if (null == field || !NumericType.LONG.equals(field.getType().getNumericType())) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"hllPreHashed is only supported with Long based fields\");\n        }\n      }\n\n      // if we're still here, then we need an HLL...\n      return new HllOptions(log2m, regwidth, hasher);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5af5ba0166322092193d4c29880b0f7670fc7ca0","date":1471440525,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/StatsField.HllOptions#parseHllOptions(SolrParams,SchemaField).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/StatsField.HllOptions#parseHllOptions(SolrParams,SchemaField).mjava","sourceNew":"    /** \n     * Creates an HllOptions based on the (local) params specified (if appropriate).\n     *\n     * @param localParams the LocalParams for this {@link StatsField}\n     * @param field the field corresponding to this {@link StatsField}, may be null if these stats are over a value source\n     * @return the {@link HllOptions} to use based on the params, or null if no {@link HLL} should be computed\n     * @throws SolrException if there are invalid options\n     */\n    public static HllOptions parseHllOptions(SolrParams localParams, SchemaField field) \n      throws SolrException {\n\n      String cardinalityOpt = localParams.get(Stat.cardinality.name());\n      if (StringUtils.isBlank(cardinalityOpt)) {\n        return null;\n      }\n\n      final LegacyNumericType hashableNumType = getHashableNumericType(field);\n\n      // some sane defaults\n      int log2m = 13;   // roughly equivilent to \"cardinality='0.33'\"\n      int regwidth = 6; // with decent hash, this is plenty for all valid long hashes\n\n      if (LegacyNumericType.FLOAT.equals(hashableNumType) || LegacyNumericType.INT.equals(hashableNumType)) {\n        // for 32bit values, we can adjust our default regwidth down a bit\n        regwidth--;\n\n        // NOTE: EnumField uses LegacyNumericType.INT, and in theory we could be super conservative\n        // with it, but there's no point - just let the EXPLICIT HLL handle it\n      }\n\n      // TODO: we could attempt additional reductions in the default regwidth based on index\n      // statistics -- but thta doesn't seem worth the effort.  for tiny indexes, the \n      // EXPLICIT and SPARSE HLL representations have us nicely covered, and in general we don't \n      // want to be too aggresive about lowering regwidth or we could really poor results if \n      // log2m is also low and  there is heavy hashkey collision\n\n      try {\n        // NFE will short out here if it's not a number\n        final double accuracyOpt = Double.parseDouble(cardinalityOpt);\n\n        // if a float between 0 and 1 is specified, treat it as a prefrence of accuracy\n        // - 0 means accuracy is not a concern, save RAM\n        // - 1 means be as accurate as possible, using as much RAM as needed.\n\n        if (accuracyOpt < 0D || 1.0D < accuracyOpt) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, ERR);\n        }\n\n        // use accuracyOpt as a scaling factor between min & max legal log2m values\n        log2m = HLL.MINIMUM_LOG2M_PARAM\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_LOG2M_PARAM - HLL.MINIMUM_LOG2M_PARAM));\n\n        // use accuracyOpt as a scaling factor for regwidth as well, BUT...\n        // be more conservative -- HLL.MIN_REGWIDTH_PARAM is too absurdly low to be useful\n        // use previously computed (hashableNumType) default regwidth -1 as lower bound for scaling\n        final int MIN_HUERISTIC_REGWIDTH = regwidth-1;\n        regwidth = MIN_HUERISTIC_REGWIDTH\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_REGWIDTH_PARAM - MIN_HUERISTIC_REGWIDTH));\n\n      } catch (NumberFormatException nfe) {\n        // param value isn't a number -- let's check for simple true/false\n        if (! localParams.getBool(Stat.cardinality.name(), false)) {\n          return null;\n        }\n      }\n\n      // let explicit params override both the default and/or any accuracy specification\n      log2m = localParams.getInt(\"hllLog2m\", log2m);\n      regwidth = localParams.getInt(\"hllRegwidth\", regwidth);\n\n      // validate legal values\n      if (log2m < HLL.MINIMUM_LOG2M_PARAM || HLL.MAXIMUM_LOG2M_PARAM < log2m) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllLog2m must be at least \" + \n                                HLL.MINIMUM_LOG2M_PARAM + \" and at most \" + HLL.MAXIMUM_LOG2M_PARAM\n                                + \" (\" + log2m +\")\");\n      }\n      if (regwidth < HLL.MINIMUM_REGWIDTH_PARAM || HLL.MAXIMUM_REGWIDTH_PARAM < regwidth) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllRegwidth must be at least \" + \n                                HLL.MINIMUM_REGWIDTH_PARAM + \" and at most \" + HLL.MAXIMUM_REGWIDTH_PARAM);\n      }\n      \n      HashFunction hasher = localParams.getBool(\"hllPreHashed\", false) ? null : Hashing.murmur3_128();\n\n      if (null == hasher) {\n        // if this is a function, or a non Long field, pre-hashed is invalid\n        // NOTE: we ignore hashableNumType - it's LONG for non numerics like Strings\n        if (null == field || !LegacyNumericType.LONG.equals(field.getType().getNumericType())) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"hllPreHashed is only supported with Long based fields\");\n        }\n      }\n\n      // if we're still here, then we need an HLL...\n      return new HllOptions(log2m, regwidth, hasher);\n    }\n\n","sourceOld":"    /** \n     * Creates an HllOptions based on the (local) params specified (if appropriate).\n     *\n     * @param localParams the LocalParams for this {@link StatsField}\n     * @param field the field corresponding to this {@link StatsField}, may be null if these stats are over a value source\n     * @return the {@link HllOptions} to use based on the params, or null if no {@link HLL} should be computed\n     * @throws SolrException if there are invalid options\n     */\n    public static HllOptions parseHllOptions(SolrParams localParams, SchemaField field) \n      throws SolrException {\n\n      String cardinalityOpt = localParams.get(Stat.cardinality.name());\n      if (StringUtils.isBlank(cardinalityOpt)) {\n        return null;\n      }\n\n      final FieldType.LegacyNumericType hashableNumType = getHashableNumericType(field);\n\n      // some sane defaults\n      int log2m = 13;   // roughly equivilent to \"cardinality='0.33'\"\n      int regwidth = 6; // with decent hash, this is plenty for all valid long hashes\n\n      if (LegacyNumericType.FLOAT.equals(hashableNumType) || FieldType.LegacyNumericType.INT.equals(hashableNumType)) {\n        // for 32bit values, we can adjust our default regwidth down a bit\n        regwidth--;\n\n        // NOTE: EnumField uses LegacyNumericType.INT, and in theory we could be super conservative\n        // with it, but there's no point - just let the EXPLICIT HLL handle it\n      }\n\n      // TODO: we could attempt additional reductions in the default regwidth based on index\n      // statistics -- but thta doesn't seem worth the effort.  for tiny indexes, the \n      // EXPLICIT and SPARSE HLL representations have us nicely covered, and in general we don't \n      // want to be too aggresive about lowering regwidth or we could really poor results if \n      // log2m is also low and  there is heavy hashkey collision\n\n      try {\n        // NFE will short out here if it's not a number\n        final double accuracyOpt = Double.parseDouble(cardinalityOpt);\n\n        // if a float between 0 and 1 is specified, treat it as a prefrence of accuracy\n        // - 0 means accuracy is not a concern, save RAM\n        // - 1 means be as accurate as possible, using as much RAM as needed.\n\n        if (accuracyOpt < 0D || 1.0D < accuracyOpt) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, ERR);\n        }\n\n        // use accuracyOpt as a scaling factor between min & max legal log2m values\n        log2m = HLL.MINIMUM_LOG2M_PARAM\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_LOG2M_PARAM - HLL.MINIMUM_LOG2M_PARAM));\n\n        // use accuracyOpt as a scaling factor for regwidth as well, BUT...\n        // be more conservative -- HLL.MIN_REGWIDTH_PARAM is too absurdly low to be useful\n        // use previously computed (hashableNumType) default regwidth -1 as lower bound for scaling\n        final int MIN_HUERISTIC_REGWIDTH = regwidth-1;\n        regwidth = MIN_HUERISTIC_REGWIDTH\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_REGWIDTH_PARAM - MIN_HUERISTIC_REGWIDTH));\n\n      } catch (NumberFormatException nfe) {\n        // param value isn't a number -- let's check for simple true/false\n        if (! localParams.getBool(Stat.cardinality.name(), false)) {\n          return null;\n        }\n      }\n\n      // let explicit params override both the default and/or any accuracy specification\n      log2m = localParams.getInt(\"hllLog2m\", log2m);\n      regwidth = localParams.getInt(\"hllRegwidth\", regwidth);\n\n      // validate legal values\n      if (log2m < HLL.MINIMUM_LOG2M_PARAM || HLL.MAXIMUM_LOG2M_PARAM < log2m) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllLog2m must be at least \" + \n                                HLL.MINIMUM_LOG2M_PARAM + \" and at most \" + HLL.MAXIMUM_LOG2M_PARAM\n                                + \" (\" + log2m +\")\");\n      }\n      if (regwidth < HLL.MINIMUM_REGWIDTH_PARAM || HLL.MAXIMUM_REGWIDTH_PARAM < regwidth) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllRegwidth must be at least \" + \n                                HLL.MINIMUM_REGWIDTH_PARAM + \" and at most \" + HLL.MAXIMUM_REGWIDTH_PARAM);\n      }\n      \n      HashFunction hasher = localParams.getBool(\"hllPreHashed\", false) ? null : Hashing.murmur3_128();\n\n      if (null == hasher) {\n        // if this is a function, or a non Long field, pre-hashed is invalid\n        // NOTE: we ignore hashableNumType - it's LONG for non numerics like Strings\n        if (null == field || !FieldType.LegacyNumericType.LONG.equals(field.getType().getNumericType())) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"hllPreHashed is only supported with Long based fields\");\n        }\n      }\n\n      // if we're still here, then we need an HLL...\n      return new HllOptions(log2m, regwidth, hasher);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6","date":1471496851,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/StatsField.HllOptions#parseHllOptions(SolrParams,SchemaField).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/StatsField.HllOptions#parseHllOptions(SolrParams,SchemaField).mjava","sourceNew":"    /** \n     * Creates an HllOptions based on the (local) params specified (if appropriate).\n     *\n     * @param localParams the LocalParams for this {@link StatsField}\n     * @param field the field corresponding to this {@link StatsField}, may be null if these stats are over a value source\n     * @return the {@link HllOptions} to use based on the params, or null if no {@link HLL} should be computed\n     * @throws SolrException if there are invalid options\n     */\n    public static HllOptions parseHllOptions(SolrParams localParams, SchemaField field) \n      throws SolrException {\n\n      String cardinalityOpt = localParams.get(Stat.cardinality.name());\n      if (StringUtils.isBlank(cardinalityOpt)) {\n        return null;\n      }\n\n      final LegacyNumericType hashableNumType = getHashableNumericType(field);\n\n      // some sane defaults\n      int log2m = 13;   // roughly equivilent to \"cardinality='0.33'\"\n      int regwidth = 6; // with decent hash, this is plenty for all valid long hashes\n\n      if (LegacyNumericType.FLOAT.equals(hashableNumType) || LegacyNumericType.INT.equals(hashableNumType)) {\n        // for 32bit values, we can adjust our default regwidth down a bit\n        regwidth--;\n\n        // NOTE: EnumField uses LegacyNumericType.INT, and in theory we could be super conservative\n        // with it, but there's no point - just let the EXPLICIT HLL handle it\n      }\n\n      // TODO: we could attempt additional reductions in the default regwidth based on index\n      // statistics -- but thta doesn't seem worth the effort.  for tiny indexes, the \n      // EXPLICIT and SPARSE HLL representations have us nicely covered, and in general we don't \n      // want to be too aggresive about lowering regwidth or we could really poor results if \n      // log2m is also low and  there is heavy hashkey collision\n\n      try {\n        // NFE will short out here if it's not a number\n        final double accuracyOpt = Double.parseDouble(cardinalityOpt);\n\n        // if a float between 0 and 1 is specified, treat it as a prefrence of accuracy\n        // - 0 means accuracy is not a concern, save RAM\n        // - 1 means be as accurate as possible, using as much RAM as needed.\n\n        if (accuracyOpt < 0D || 1.0D < accuracyOpt) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, ERR);\n        }\n\n        // use accuracyOpt as a scaling factor between min & max legal log2m values\n        log2m = HLL.MINIMUM_LOG2M_PARAM\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_LOG2M_PARAM - HLL.MINIMUM_LOG2M_PARAM));\n\n        // use accuracyOpt as a scaling factor for regwidth as well, BUT...\n        // be more conservative -- HLL.MIN_REGWIDTH_PARAM is too absurdly low to be useful\n        // use previously computed (hashableNumType) default regwidth -1 as lower bound for scaling\n        final int MIN_HUERISTIC_REGWIDTH = regwidth-1;\n        regwidth = MIN_HUERISTIC_REGWIDTH\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_REGWIDTH_PARAM - MIN_HUERISTIC_REGWIDTH));\n\n      } catch (NumberFormatException nfe) {\n        // param value isn't a number -- let's check for simple true/false\n        if (! localParams.getBool(Stat.cardinality.name(), false)) {\n          return null;\n        }\n      }\n\n      // let explicit params override both the default and/or any accuracy specification\n      log2m = localParams.getInt(\"hllLog2m\", log2m);\n      regwidth = localParams.getInt(\"hllRegwidth\", regwidth);\n\n      // validate legal values\n      if (log2m < HLL.MINIMUM_LOG2M_PARAM || HLL.MAXIMUM_LOG2M_PARAM < log2m) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllLog2m must be at least \" + \n                                HLL.MINIMUM_LOG2M_PARAM + \" and at most \" + HLL.MAXIMUM_LOG2M_PARAM\n                                + \" (\" + log2m +\")\");\n      }\n      if (regwidth < HLL.MINIMUM_REGWIDTH_PARAM || HLL.MAXIMUM_REGWIDTH_PARAM < regwidth) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllRegwidth must be at least \" + \n                                HLL.MINIMUM_REGWIDTH_PARAM + \" and at most \" + HLL.MAXIMUM_REGWIDTH_PARAM);\n      }\n      \n      HashFunction hasher = localParams.getBool(\"hllPreHashed\", false) ? null : Hashing.murmur3_128();\n\n      if (null == hasher) {\n        // if this is a function, or a non Long field, pre-hashed is invalid\n        // NOTE: we ignore hashableNumType - it's LONG for non numerics like Strings\n        if (null == field || !LegacyNumericType.LONG.equals(field.getType().getNumericType())) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"hllPreHashed is only supported with Long based fields\");\n        }\n      }\n\n      // if we're still here, then we need an HLL...\n      return new HllOptions(log2m, regwidth, hasher);\n    }\n\n","sourceOld":"    /** \n     * Creates an HllOptions based on the (local) params specified (if appropriate).\n     *\n     * @param localParams the LocalParams for this {@link StatsField}\n     * @param field the field corresponding to this {@link StatsField}, may be null if these stats are over a value source\n     * @return the {@link HllOptions} to use based on the params, or null if no {@link HLL} should be computed\n     * @throws SolrException if there are invalid options\n     */\n    public static HllOptions parseHllOptions(SolrParams localParams, SchemaField field) \n      throws SolrException {\n\n      String cardinalityOpt = localParams.get(Stat.cardinality.name());\n      if (StringUtils.isBlank(cardinalityOpt)) {\n        return null;\n      }\n\n      final FieldType.LegacyNumericType hashableNumType = getHashableNumericType(field);\n\n      // some sane defaults\n      int log2m = 13;   // roughly equivilent to \"cardinality='0.33'\"\n      int regwidth = 6; // with decent hash, this is plenty for all valid long hashes\n\n      if (LegacyNumericType.FLOAT.equals(hashableNumType) || FieldType.LegacyNumericType.INT.equals(hashableNumType)) {\n        // for 32bit values, we can adjust our default regwidth down a bit\n        regwidth--;\n\n        // NOTE: EnumField uses LegacyNumericType.INT, and in theory we could be super conservative\n        // with it, but there's no point - just let the EXPLICIT HLL handle it\n      }\n\n      // TODO: we could attempt additional reductions in the default regwidth based on index\n      // statistics -- but thta doesn't seem worth the effort.  for tiny indexes, the \n      // EXPLICIT and SPARSE HLL representations have us nicely covered, and in general we don't \n      // want to be too aggresive about lowering regwidth or we could really poor results if \n      // log2m is also low and  there is heavy hashkey collision\n\n      try {\n        // NFE will short out here if it's not a number\n        final double accuracyOpt = Double.parseDouble(cardinalityOpt);\n\n        // if a float between 0 and 1 is specified, treat it as a prefrence of accuracy\n        // - 0 means accuracy is not a concern, save RAM\n        // - 1 means be as accurate as possible, using as much RAM as needed.\n\n        if (accuracyOpt < 0D || 1.0D < accuracyOpt) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, ERR);\n        }\n\n        // use accuracyOpt as a scaling factor between min & max legal log2m values\n        log2m = HLL.MINIMUM_LOG2M_PARAM\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_LOG2M_PARAM - HLL.MINIMUM_LOG2M_PARAM));\n\n        // use accuracyOpt as a scaling factor for regwidth as well, BUT...\n        // be more conservative -- HLL.MIN_REGWIDTH_PARAM is too absurdly low to be useful\n        // use previously computed (hashableNumType) default regwidth -1 as lower bound for scaling\n        final int MIN_HUERISTIC_REGWIDTH = regwidth-1;\n        regwidth = MIN_HUERISTIC_REGWIDTH\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_REGWIDTH_PARAM - MIN_HUERISTIC_REGWIDTH));\n\n      } catch (NumberFormatException nfe) {\n        // param value isn't a number -- let's check for simple true/false\n        if (! localParams.getBool(Stat.cardinality.name(), false)) {\n          return null;\n        }\n      }\n\n      // let explicit params override both the default and/or any accuracy specification\n      log2m = localParams.getInt(\"hllLog2m\", log2m);\n      regwidth = localParams.getInt(\"hllRegwidth\", regwidth);\n\n      // validate legal values\n      if (log2m < HLL.MINIMUM_LOG2M_PARAM || HLL.MAXIMUM_LOG2M_PARAM < log2m) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllLog2m must be at least \" + \n                                HLL.MINIMUM_LOG2M_PARAM + \" and at most \" + HLL.MAXIMUM_LOG2M_PARAM\n                                + \" (\" + log2m +\")\");\n      }\n      if (regwidth < HLL.MINIMUM_REGWIDTH_PARAM || HLL.MAXIMUM_REGWIDTH_PARAM < regwidth) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllRegwidth must be at least \" + \n                                HLL.MINIMUM_REGWIDTH_PARAM + \" and at most \" + HLL.MAXIMUM_REGWIDTH_PARAM);\n      }\n      \n      HashFunction hasher = localParams.getBool(\"hllPreHashed\", false) ? null : Hashing.murmur3_128();\n\n      if (null == hasher) {\n        // if this is a function, or a non Long field, pre-hashed is invalid\n        // NOTE: we ignore hashableNumType - it's LONG for non numerics like Strings\n        if (null == field || !FieldType.LegacyNumericType.LONG.equals(field.getType().getNumericType())) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"hllPreHashed is only supported with Long based fields\");\n        }\n      }\n\n      // if we're still here, then we need an HLL...\n      return new HllOptions(log2m, regwidth, hasher);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"403d05f7f8d69b65659157eff1bc1d2717f04c66","date":1471692961,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/StatsField.HllOptions#parseHllOptions(SolrParams,SchemaField).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/StatsField.HllOptions#parseHllOptions(SolrParams,SchemaField).mjava","sourceNew":"    /** \n     * Creates an HllOptions based on the (local) params specified (if appropriate).\n     *\n     * @param localParams the LocalParams for this {@link StatsField}\n     * @param field the field corresponding to this {@link StatsField}, may be null if these stats are over a value source\n     * @return the {@link HllOptions} to use based on the params, or null if no {@link HLL} should be computed\n     * @throws SolrException if there are invalid options\n     */\n    public static HllOptions parseHllOptions(SolrParams localParams, SchemaField field) \n      throws SolrException {\n\n      String cardinalityOpt = localParams.get(Stat.cardinality.name());\n      if (StringUtils.isBlank(cardinalityOpt)) {\n        return null;\n      }\n\n      final LegacyNumericType hashableNumType = getHashableNumericType(field);\n\n      // some sane defaults\n      int log2m = 13;   // roughly equivilent to \"cardinality='0.33'\"\n      int regwidth = 6; // with decent hash, this is plenty for all valid long hashes\n\n      if (LegacyNumericType.FLOAT.equals(hashableNumType) || LegacyNumericType.INT.equals(hashableNumType)) {\n        // for 32bit values, we can adjust our default regwidth down a bit\n        regwidth--;\n\n        // NOTE: EnumField uses LegacyNumericType.INT, and in theory we could be super conservative\n        // with it, but there's no point - just let the EXPLICIT HLL handle it\n      }\n\n      // TODO: we could attempt additional reductions in the default regwidth based on index\n      // statistics -- but thta doesn't seem worth the effort.  for tiny indexes, the \n      // EXPLICIT and SPARSE HLL representations have us nicely covered, and in general we don't \n      // want to be too aggresive about lowering regwidth or we could really poor results if \n      // log2m is also low and  there is heavy hashkey collision\n\n      try {\n        // NFE will short out here if it's not a number\n        final double accuracyOpt = Double.parseDouble(cardinalityOpt);\n\n        // if a float between 0 and 1 is specified, treat it as a prefrence of accuracy\n        // - 0 means accuracy is not a concern, save RAM\n        // - 1 means be as accurate as possible, using as much RAM as needed.\n\n        if (accuracyOpt < 0D || 1.0D < accuracyOpt) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, ERR);\n        }\n\n        // use accuracyOpt as a scaling factor between min & max legal log2m values\n        log2m = HLL.MINIMUM_LOG2M_PARAM\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_LOG2M_PARAM - HLL.MINIMUM_LOG2M_PARAM));\n\n        // use accuracyOpt as a scaling factor for regwidth as well, BUT...\n        // be more conservative -- HLL.MIN_REGWIDTH_PARAM is too absurdly low to be useful\n        // use previously computed (hashableNumType) default regwidth -1 as lower bound for scaling\n        final int MIN_HUERISTIC_REGWIDTH = regwidth-1;\n        regwidth = MIN_HUERISTIC_REGWIDTH\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_REGWIDTH_PARAM - MIN_HUERISTIC_REGWIDTH));\n\n      } catch (NumberFormatException nfe) {\n        // param value isn't a number -- let's check for simple true/false\n        if (! localParams.getBool(Stat.cardinality.name(), false)) {\n          return null;\n        }\n      }\n\n      // let explicit params override both the default and/or any accuracy specification\n      log2m = localParams.getInt(\"hllLog2m\", log2m);\n      regwidth = localParams.getInt(\"hllRegwidth\", regwidth);\n\n      // validate legal values\n      if (log2m < HLL.MINIMUM_LOG2M_PARAM || HLL.MAXIMUM_LOG2M_PARAM < log2m) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllLog2m must be at least \" + \n                                HLL.MINIMUM_LOG2M_PARAM + \" and at most \" + HLL.MAXIMUM_LOG2M_PARAM\n                                + \" (\" + log2m +\")\");\n      }\n      if (regwidth < HLL.MINIMUM_REGWIDTH_PARAM || HLL.MAXIMUM_REGWIDTH_PARAM < regwidth) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllRegwidth must be at least \" + \n                                HLL.MINIMUM_REGWIDTH_PARAM + \" and at most \" + HLL.MAXIMUM_REGWIDTH_PARAM);\n      }\n      \n      HashFunction hasher = localParams.getBool(\"hllPreHashed\", false) ? null : Hashing.murmur3_128();\n\n      if (null == hasher) {\n        // if this is a function, or a non Long field, pre-hashed is invalid\n        // NOTE: we ignore hashableNumType - it's LONG for non numerics like Strings\n        if (null == field || !LegacyNumericType.LONG.equals(field.getType().getNumericType())) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"hllPreHashed is only supported with Long based fields\");\n        }\n      }\n\n      // if we're still here, then we need an HLL...\n      return new HllOptions(log2m, regwidth, hasher);\n    }\n\n","sourceOld":"    /** \n     * Creates an HllOptions based on the (local) params specified (if appropriate).\n     *\n     * @param localParams the LocalParams for this {@link StatsField}\n     * @param field the field corresponding to this {@link StatsField}, may be null if these stats are over a value source\n     * @return the {@link HllOptions} to use based on the params, or null if no {@link HLL} should be computed\n     * @throws SolrException if there are invalid options\n     */\n    public static HllOptions parseHllOptions(SolrParams localParams, SchemaField field) \n      throws SolrException {\n\n      String cardinalityOpt = localParams.get(Stat.cardinality.name());\n      if (StringUtils.isBlank(cardinalityOpt)) {\n        return null;\n      }\n\n      final FieldType.LegacyNumericType hashableNumType = getHashableNumericType(field);\n\n      // some sane defaults\n      int log2m = 13;   // roughly equivilent to \"cardinality='0.33'\"\n      int regwidth = 6; // with decent hash, this is plenty for all valid long hashes\n\n      if (LegacyNumericType.FLOAT.equals(hashableNumType) || FieldType.LegacyNumericType.INT.equals(hashableNumType)) {\n        // for 32bit values, we can adjust our default regwidth down a bit\n        regwidth--;\n\n        // NOTE: EnumField uses LegacyNumericType.INT, and in theory we could be super conservative\n        // with it, but there's no point - just let the EXPLICIT HLL handle it\n      }\n\n      // TODO: we could attempt additional reductions in the default regwidth based on index\n      // statistics -- but thta doesn't seem worth the effort.  for tiny indexes, the \n      // EXPLICIT and SPARSE HLL representations have us nicely covered, and in general we don't \n      // want to be too aggresive about lowering regwidth or we could really poor results if \n      // log2m is also low and  there is heavy hashkey collision\n\n      try {\n        // NFE will short out here if it's not a number\n        final double accuracyOpt = Double.parseDouble(cardinalityOpt);\n\n        // if a float between 0 and 1 is specified, treat it as a prefrence of accuracy\n        // - 0 means accuracy is not a concern, save RAM\n        // - 1 means be as accurate as possible, using as much RAM as needed.\n\n        if (accuracyOpt < 0D || 1.0D < accuracyOpt) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, ERR);\n        }\n\n        // use accuracyOpt as a scaling factor between min & max legal log2m values\n        log2m = HLL.MINIMUM_LOG2M_PARAM\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_LOG2M_PARAM - HLL.MINIMUM_LOG2M_PARAM));\n\n        // use accuracyOpt as a scaling factor for regwidth as well, BUT...\n        // be more conservative -- HLL.MIN_REGWIDTH_PARAM is too absurdly low to be useful\n        // use previously computed (hashableNumType) default regwidth -1 as lower bound for scaling\n        final int MIN_HUERISTIC_REGWIDTH = regwidth-1;\n        regwidth = MIN_HUERISTIC_REGWIDTH\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_REGWIDTH_PARAM - MIN_HUERISTIC_REGWIDTH));\n\n      } catch (NumberFormatException nfe) {\n        // param value isn't a number -- let's check for simple true/false\n        if (! localParams.getBool(Stat.cardinality.name(), false)) {\n          return null;\n        }\n      }\n\n      // let explicit params override both the default and/or any accuracy specification\n      log2m = localParams.getInt(\"hllLog2m\", log2m);\n      regwidth = localParams.getInt(\"hllRegwidth\", regwidth);\n\n      // validate legal values\n      if (log2m < HLL.MINIMUM_LOG2M_PARAM || HLL.MAXIMUM_LOG2M_PARAM < log2m) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllLog2m must be at least \" + \n                                HLL.MINIMUM_LOG2M_PARAM + \" and at most \" + HLL.MAXIMUM_LOG2M_PARAM\n                                + \" (\" + log2m +\")\");\n      }\n      if (regwidth < HLL.MINIMUM_REGWIDTH_PARAM || HLL.MAXIMUM_REGWIDTH_PARAM < regwidth) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllRegwidth must be at least \" + \n                                HLL.MINIMUM_REGWIDTH_PARAM + \" and at most \" + HLL.MAXIMUM_REGWIDTH_PARAM);\n      }\n      \n      HashFunction hasher = localParams.getBool(\"hllPreHashed\", false) ? null : Hashing.murmur3_128();\n\n      if (null == hasher) {\n        // if this is a function, or a non Long field, pre-hashed is invalid\n        // NOTE: we ignore hashableNumType - it's LONG for non numerics like Strings\n        if (null == field || !FieldType.LegacyNumericType.LONG.equals(field.getType().getNumericType())) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"hllPreHashed is only supported with Long based fields\");\n        }\n      }\n\n      // if we're still here, then we need an HLL...\n      return new HllOptions(log2m, regwidth, hasher);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/StatsField.HllOptions#parseHllOptions(SolrParams,SchemaField).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/StatsField.HllOptions#parseHllOptions(SolrParams,SchemaField).mjava","sourceNew":"    /** \n     * Creates an HllOptions based on the (local) params specified (if appropriate).\n     *\n     * @param localParams the LocalParams for this {@link StatsField}\n     * @param field the field corresponding to this {@link StatsField}, may be null if these stats are over a value source\n     * @return the {@link HllOptions} to use based on the params, or null if no {@link HLL} should be computed\n     * @throws SolrException if there are invalid options\n     */\n    public static HllOptions parseHllOptions(SolrParams localParams, SchemaField field) \n      throws SolrException {\n\n      String cardinalityOpt = localParams.get(Stat.cardinality.name());\n      if (StringUtils.isBlank(cardinalityOpt)) {\n        return null;\n      }\n\n      final LegacyNumericType hashableNumType = getHashableNumericType(field);\n\n      // some sane defaults\n      int log2m = 13;   // roughly equivilent to \"cardinality='0.33'\"\n      int regwidth = 6; // with decent hash, this is plenty for all valid long hashes\n\n      if (LegacyNumericType.FLOAT.equals(hashableNumType) || LegacyNumericType.INT.equals(hashableNumType)) {\n        // for 32bit values, we can adjust our default regwidth down a bit\n        regwidth--;\n\n        // NOTE: EnumField uses LegacyNumericType.INT, and in theory we could be super conservative\n        // with it, but there's no point - just let the EXPLICIT HLL handle it\n      }\n\n      // TODO: we could attempt additional reductions in the default regwidth based on index\n      // statistics -- but thta doesn't seem worth the effort.  for tiny indexes, the \n      // EXPLICIT and SPARSE HLL representations have us nicely covered, and in general we don't \n      // want to be too aggresive about lowering regwidth or we could really poor results if \n      // log2m is also low and  there is heavy hashkey collision\n\n      try {\n        // NFE will short out here if it's not a number\n        final double accuracyOpt = Double.parseDouble(cardinalityOpt);\n\n        // if a float between 0 and 1 is specified, treat it as a prefrence of accuracy\n        // - 0 means accuracy is not a concern, save RAM\n        // - 1 means be as accurate as possible, using as much RAM as needed.\n\n        if (accuracyOpt < 0D || 1.0D < accuracyOpt) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, ERR);\n        }\n\n        // use accuracyOpt as a scaling factor between min & max legal log2m values\n        log2m = HLL.MINIMUM_LOG2M_PARAM\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_LOG2M_PARAM - HLL.MINIMUM_LOG2M_PARAM));\n\n        // use accuracyOpt as a scaling factor for regwidth as well, BUT...\n        // be more conservative -- HLL.MIN_REGWIDTH_PARAM is too absurdly low to be useful\n        // use previously computed (hashableNumType) default regwidth -1 as lower bound for scaling\n        final int MIN_HUERISTIC_REGWIDTH = regwidth-1;\n        regwidth = MIN_HUERISTIC_REGWIDTH\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_REGWIDTH_PARAM - MIN_HUERISTIC_REGWIDTH));\n\n      } catch (NumberFormatException nfe) {\n        // param value isn't a number -- let's check for simple true/false\n        if (! localParams.getBool(Stat.cardinality.name(), false)) {\n          return null;\n        }\n      }\n\n      // let explicit params override both the default and/or any accuracy specification\n      log2m = localParams.getInt(\"hllLog2m\", log2m);\n      regwidth = localParams.getInt(\"hllRegwidth\", regwidth);\n\n      // validate legal values\n      if (log2m < HLL.MINIMUM_LOG2M_PARAM || HLL.MAXIMUM_LOG2M_PARAM < log2m) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllLog2m must be at least \" + \n                                HLL.MINIMUM_LOG2M_PARAM + \" and at most \" + HLL.MAXIMUM_LOG2M_PARAM\n                                + \" (\" + log2m +\")\");\n      }\n      if (regwidth < HLL.MINIMUM_REGWIDTH_PARAM || HLL.MAXIMUM_REGWIDTH_PARAM < regwidth) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllRegwidth must be at least \" + \n                                HLL.MINIMUM_REGWIDTH_PARAM + \" and at most \" + HLL.MAXIMUM_REGWIDTH_PARAM);\n      }\n      \n      HashFunction hasher = localParams.getBool(\"hllPreHashed\", false) ? null : Hashing.murmur3_128();\n\n      if (null == hasher) {\n        // if this is a function, or a non Long field, pre-hashed is invalid\n        // NOTE: we ignore hashableNumType - it's LONG for non numerics like Strings\n        if (null == field || !LegacyNumericType.LONG.equals(field.getType().getNumericType())) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"hllPreHashed is only supported with Long based fields\");\n        }\n      }\n\n      // if we're still here, then we need an HLL...\n      return new HllOptions(log2m, regwidth, hasher);\n    }\n\n","sourceOld":"    /** \n     * Creates an HllOptions based on the (local) params specified (if appropriate).\n     *\n     * @param localParams the LocalParams for this {@link StatsField}\n     * @param field the field corresponding to this {@link StatsField}, may be null if these stats are over a value source\n     * @return the {@link HllOptions} to use based on the params, or null if no {@link HLL} should be computed\n     * @throws SolrException if there are invalid options\n     */\n    public static HllOptions parseHllOptions(SolrParams localParams, SchemaField field) \n      throws SolrException {\n\n      String cardinalityOpt = localParams.get(Stat.cardinality.name());\n      if (StringUtils.isBlank(cardinalityOpt)) {\n        return null;\n      }\n\n      final FieldType.LegacyNumericType hashableNumType = getHashableNumericType(field);\n\n      // some sane defaults\n      int log2m = 13;   // roughly equivilent to \"cardinality='0.33'\"\n      int regwidth = 6; // with decent hash, this is plenty for all valid long hashes\n\n      if (LegacyNumericType.FLOAT.equals(hashableNumType) || FieldType.LegacyNumericType.INT.equals(hashableNumType)) {\n        // for 32bit values, we can adjust our default regwidth down a bit\n        regwidth--;\n\n        // NOTE: EnumField uses LegacyNumericType.INT, and in theory we could be super conservative\n        // with it, but there's no point - just let the EXPLICIT HLL handle it\n      }\n\n      // TODO: we could attempt additional reductions in the default regwidth based on index\n      // statistics -- but thta doesn't seem worth the effort.  for tiny indexes, the \n      // EXPLICIT and SPARSE HLL representations have us nicely covered, and in general we don't \n      // want to be too aggresive about lowering regwidth or we could really poor results if \n      // log2m is also low and  there is heavy hashkey collision\n\n      try {\n        // NFE will short out here if it's not a number\n        final double accuracyOpt = Double.parseDouble(cardinalityOpt);\n\n        // if a float between 0 and 1 is specified, treat it as a prefrence of accuracy\n        // - 0 means accuracy is not a concern, save RAM\n        // - 1 means be as accurate as possible, using as much RAM as needed.\n\n        if (accuracyOpt < 0D || 1.0D < accuracyOpt) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, ERR);\n        }\n\n        // use accuracyOpt as a scaling factor between min & max legal log2m values\n        log2m = HLL.MINIMUM_LOG2M_PARAM\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_LOG2M_PARAM - HLL.MINIMUM_LOG2M_PARAM));\n\n        // use accuracyOpt as a scaling factor for regwidth as well, BUT...\n        // be more conservative -- HLL.MIN_REGWIDTH_PARAM is too absurdly low to be useful\n        // use previously computed (hashableNumType) default regwidth -1 as lower bound for scaling\n        final int MIN_HUERISTIC_REGWIDTH = regwidth-1;\n        regwidth = MIN_HUERISTIC_REGWIDTH\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_REGWIDTH_PARAM - MIN_HUERISTIC_REGWIDTH));\n\n      } catch (NumberFormatException nfe) {\n        // param value isn't a number -- let's check for simple true/false\n        if (! localParams.getBool(Stat.cardinality.name(), false)) {\n          return null;\n        }\n      }\n\n      // let explicit params override both the default and/or any accuracy specification\n      log2m = localParams.getInt(\"hllLog2m\", log2m);\n      regwidth = localParams.getInt(\"hllRegwidth\", regwidth);\n\n      // validate legal values\n      if (log2m < HLL.MINIMUM_LOG2M_PARAM || HLL.MAXIMUM_LOG2M_PARAM < log2m) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllLog2m must be at least \" + \n                                HLL.MINIMUM_LOG2M_PARAM + \" and at most \" + HLL.MAXIMUM_LOG2M_PARAM\n                                + \" (\" + log2m +\")\");\n      }\n      if (regwidth < HLL.MINIMUM_REGWIDTH_PARAM || HLL.MAXIMUM_REGWIDTH_PARAM < regwidth) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllRegwidth must be at least \" + \n                                HLL.MINIMUM_REGWIDTH_PARAM + \" and at most \" + HLL.MAXIMUM_REGWIDTH_PARAM);\n      }\n      \n      HashFunction hasher = localParams.getBool(\"hllPreHashed\", false) ? null : Hashing.murmur3_128();\n\n      if (null == hasher) {\n        // if this is a function, or a non Long field, pre-hashed is invalid\n        // NOTE: we ignore hashableNumType - it's LONG for non numerics like Strings\n        if (null == field || !FieldType.LegacyNumericType.LONG.equals(field.getType().getNumericType())) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"hllPreHashed is only supported with Long based fields\");\n        }\n      }\n\n      // if we're still here, then we need an HLL...\n      return new HllOptions(log2m, regwidth, hasher);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d81baa64023bbb9b43f6d929ee168b105940d30","date":1486492702,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/StatsField.HllOptions#parseHllOptions(SolrParams,SchemaField).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/StatsField.HllOptions#parseHllOptions(SolrParams,SchemaField).mjava","sourceNew":"    /** \n     * Creates an HllOptions based on the (local) params specified (if appropriate).\n     *\n     * @param localParams the LocalParams for this {@link StatsField}\n     * @param field the field corresponding to this {@link StatsField}, may be null if these stats are over a value source\n     * @return the {@link HllOptions} to use based on the params, or null if no {@link HLL} should be computed\n     * @throws SolrException if there are invalid options\n     */\n    public static HllOptions parseHllOptions(SolrParams localParams, SchemaField field) \n      throws SolrException {\n\n      String cardinalityOpt = localParams.get(Stat.cardinality.name());\n      if (StringUtils.isBlank(cardinalityOpt)) {\n        return null;\n      }\n\n      final NumberType hashableNumType = getHashableNumericType(field);\n\n      // some sane defaults\n      int log2m = 13;   // roughly equivilent to \"cardinality='0.33'\"\n      int regwidth = 6; // with decent hash, this is plenty for all valid long hashes\n\n      if (NumberType.FLOAT.equals(hashableNumType) || NumberType.INTEGER.equals(hashableNumType)) {\n        // for 32bit values, we can adjust our default regwidth down a bit\n        regwidth--;\n\n        // NOTE: EnumField uses LegacyNumericType.INT, and in theory we could be super conservative\n        // with it, but there's no point - just let the EXPLICIT HLL handle it\n      }\n\n      // TODO: we could attempt additional reductions in the default regwidth based on index\n      // statistics -- but thta doesn't seem worth the effort.  for tiny indexes, the \n      // EXPLICIT and SPARSE HLL representations have us nicely covered, and in general we don't \n      // want to be too aggresive about lowering regwidth or we could really poor results if \n      // log2m is also low and  there is heavy hashkey collision\n\n      try {\n        // NFE will short out here if it's not a number\n        final double accuracyOpt = Double.parseDouble(cardinalityOpt);\n\n        // if a float between 0 and 1 is specified, treat it as a prefrence of accuracy\n        // - 0 means accuracy is not a concern, save RAM\n        // - 1 means be as accurate as possible, using as much RAM as needed.\n\n        if (accuracyOpt < 0D || 1.0D < accuracyOpt) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, ERR);\n        }\n\n        // use accuracyOpt as a scaling factor between min & max legal log2m values\n        log2m = HLL.MINIMUM_LOG2M_PARAM\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_LOG2M_PARAM - HLL.MINIMUM_LOG2M_PARAM));\n\n        // use accuracyOpt as a scaling factor for regwidth as well, BUT...\n        // be more conservative -- HLL.MIN_REGWIDTH_PARAM is too absurdly low to be useful\n        // use previously computed (hashableNumType) default regwidth -1 as lower bound for scaling\n        final int MIN_HUERISTIC_REGWIDTH = regwidth-1;\n        regwidth = MIN_HUERISTIC_REGWIDTH\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_REGWIDTH_PARAM - MIN_HUERISTIC_REGWIDTH));\n\n      } catch (NumberFormatException nfe) {\n        // param value isn't a number -- let's check for simple true/false\n        if (! localParams.getBool(Stat.cardinality.name(), false)) {\n          return null;\n        }\n      }\n\n      // let explicit params override both the default and/or any accuracy specification\n      log2m = localParams.getInt(\"hllLog2m\", log2m);\n      regwidth = localParams.getInt(\"hllRegwidth\", regwidth);\n\n      // validate legal values\n      if (log2m < HLL.MINIMUM_LOG2M_PARAM || HLL.MAXIMUM_LOG2M_PARAM < log2m) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllLog2m must be at least \" + \n                                HLL.MINIMUM_LOG2M_PARAM + \" and at most \" + HLL.MAXIMUM_LOG2M_PARAM\n                                + \" (\" + log2m +\")\");\n      }\n      if (regwidth < HLL.MINIMUM_REGWIDTH_PARAM || HLL.MAXIMUM_REGWIDTH_PARAM < regwidth) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllRegwidth must be at least \" + \n                                HLL.MINIMUM_REGWIDTH_PARAM + \" and at most \" + HLL.MAXIMUM_REGWIDTH_PARAM);\n      }\n      \n      HashFunction hasher = localParams.getBool(\"hllPreHashed\", false) ? null : Hashing.murmur3_128();\n\n      if (null == hasher) {\n        // if this is a function, or a non Long field, pre-hashed is invalid\n        // NOTE: we ignore hashableNumType - it's LONG for non numerics like Strings\n        if (null == field || !(NumberType.LONG.equals(field.getType().getNumberType()) || NumberType.DATE.equals(field.getType().getNumberType()))) { \n          throw new SolrException(ErrorCode.BAD_REQUEST, \"hllPreHashed is only supported with Long based fields\");\n        }\n      }\n\n      // if we're still here, then we need an HLL...\n      return new HllOptions(log2m, regwidth, hasher);\n    }\n\n","sourceOld":"    /** \n     * Creates an HllOptions based on the (local) params specified (if appropriate).\n     *\n     * @param localParams the LocalParams for this {@link StatsField}\n     * @param field the field corresponding to this {@link StatsField}, may be null if these stats are over a value source\n     * @return the {@link HllOptions} to use based on the params, or null if no {@link HLL} should be computed\n     * @throws SolrException if there are invalid options\n     */\n    public static HllOptions parseHllOptions(SolrParams localParams, SchemaField field) \n      throws SolrException {\n\n      String cardinalityOpt = localParams.get(Stat.cardinality.name());\n      if (StringUtils.isBlank(cardinalityOpt)) {\n        return null;\n      }\n\n      final LegacyNumericType hashableNumType = getHashableNumericType(field);\n\n      // some sane defaults\n      int log2m = 13;   // roughly equivilent to \"cardinality='0.33'\"\n      int regwidth = 6; // with decent hash, this is plenty for all valid long hashes\n\n      if (LegacyNumericType.FLOAT.equals(hashableNumType) || LegacyNumericType.INT.equals(hashableNumType)) {\n        // for 32bit values, we can adjust our default regwidth down a bit\n        regwidth--;\n\n        // NOTE: EnumField uses LegacyNumericType.INT, and in theory we could be super conservative\n        // with it, but there's no point - just let the EXPLICIT HLL handle it\n      }\n\n      // TODO: we could attempt additional reductions in the default regwidth based on index\n      // statistics -- but thta doesn't seem worth the effort.  for tiny indexes, the \n      // EXPLICIT and SPARSE HLL representations have us nicely covered, and in general we don't \n      // want to be too aggresive about lowering regwidth or we could really poor results if \n      // log2m is also low and  there is heavy hashkey collision\n\n      try {\n        // NFE will short out here if it's not a number\n        final double accuracyOpt = Double.parseDouble(cardinalityOpt);\n\n        // if a float between 0 and 1 is specified, treat it as a prefrence of accuracy\n        // - 0 means accuracy is not a concern, save RAM\n        // - 1 means be as accurate as possible, using as much RAM as needed.\n\n        if (accuracyOpt < 0D || 1.0D < accuracyOpt) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, ERR);\n        }\n\n        // use accuracyOpt as a scaling factor between min & max legal log2m values\n        log2m = HLL.MINIMUM_LOG2M_PARAM\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_LOG2M_PARAM - HLL.MINIMUM_LOG2M_PARAM));\n\n        // use accuracyOpt as a scaling factor for regwidth as well, BUT...\n        // be more conservative -- HLL.MIN_REGWIDTH_PARAM is too absurdly low to be useful\n        // use previously computed (hashableNumType) default regwidth -1 as lower bound for scaling\n        final int MIN_HUERISTIC_REGWIDTH = regwidth-1;\n        regwidth = MIN_HUERISTIC_REGWIDTH\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_REGWIDTH_PARAM - MIN_HUERISTIC_REGWIDTH));\n\n      } catch (NumberFormatException nfe) {\n        // param value isn't a number -- let's check for simple true/false\n        if (! localParams.getBool(Stat.cardinality.name(), false)) {\n          return null;\n        }\n      }\n\n      // let explicit params override both the default and/or any accuracy specification\n      log2m = localParams.getInt(\"hllLog2m\", log2m);\n      regwidth = localParams.getInt(\"hllRegwidth\", regwidth);\n\n      // validate legal values\n      if (log2m < HLL.MINIMUM_LOG2M_PARAM || HLL.MAXIMUM_LOG2M_PARAM < log2m) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllLog2m must be at least \" + \n                                HLL.MINIMUM_LOG2M_PARAM + \" and at most \" + HLL.MAXIMUM_LOG2M_PARAM\n                                + \" (\" + log2m +\")\");\n      }\n      if (regwidth < HLL.MINIMUM_REGWIDTH_PARAM || HLL.MAXIMUM_REGWIDTH_PARAM < regwidth) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllRegwidth must be at least \" + \n                                HLL.MINIMUM_REGWIDTH_PARAM + \" and at most \" + HLL.MAXIMUM_REGWIDTH_PARAM);\n      }\n      \n      HashFunction hasher = localParams.getBool(\"hllPreHashed\", false) ? null : Hashing.murmur3_128();\n\n      if (null == hasher) {\n        // if this is a function, or a non Long field, pre-hashed is invalid\n        // NOTE: we ignore hashableNumType - it's LONG for non numerics like Strings\n        if (null == field || !LegacyNumericType.LONG.equals(field.getType().getNumericType())) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, \"hllPreHashed is only supported with Long based fields\");\n        }\n      }\n\n      // if we're still here, then we need an HLL...\n      return new HllOptions(log2m, regwidth, hasher);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9f4251f14d2db68330fc1e6f0495c053a905d560","date":1537116380,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/StatsField.HllOptions#parseHllOptions(SolrParams,SchemaField).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/StatsField.HllOptions#parseHllOptions(SolrParams,SchemaField).mjava","sourceNew":"    /** \n     * Creates an HllOptions based on the (local) params specified (if appropriate).\n     *\n     * @param localParams the LocalParams for this {@link StatsField}\n     * @param field the field corresponding to this {@link StatsField}, may be null if these stats are over a value source\n     * @return the {@link HllOptions} to use based on the params, or null if no {@link HLL} should be computed\n     * @throws SolrException if there are invalid options\n     */\n    public static HllOptions parseHllOptions(SolrParams localParams, SchemaField field) \n      throws SolrException {\n\n      String cardinalityOpt = localParams.get(Stat.cardinality.name());\n      if (StringUtils.isBlank(cardinalityOpt)) {\n        return null;\n      }\n\n      final NumberType hashableNumType = getHashableNumericType(field);\n\n      // some sane defaults\n      int log2m = 13;   // roughly equivalent to \"cardinality='0.33'\"\n      int regwidth = 6; // with decent hash, this is plenty for all valid long hashes\n\n      if (NumberType.FLOAT.equals(hashableNumType) || NumberType.INTEGER.equals(hashableNumType)) {\n        // for 32bit values, we can adjust our default regwidth down a bit\n        regwidth--;\n\n        // NOTE: EnumField uses LegacyNumericType.INT, and in theory we could be super conservative\n        // with it, but there's no point - just let the EXPLICIT HLL handle it\n      }\n\n      // TODO: we could attempt additional reductions in the default regwidth based on index\n      // statistics -- but thta doesn't seem worth the effort.  for tiny indexes, the \n      // EXPLICIT and SPARSE HLL representations have us nicely covered, and in general we don't \n      // want to be too aggresive about lowering regwidth or we could really poor results if \n      // log2m is also low and  there is heavy hashkey collision\n\n      try {\n        // NFE will short out here if it's not a number\n        final double accuracyOpt = Double.parseDouble(cardinalityOpt);\n\n        // if a float between 0 and 1 is specified, treat it as a prefrence of accuracy\n        // - 0 means accuracy is not a concern, save RAM\n        // - 1 means be as accurate as possible, using as much RAM as needed.\n\n        if (accuracyOpt < 0D || 1.0D < accuracyOpt) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, ERR);\n        }\n\n        // use accuracyOpt as a scaling factor between min & max legal log2m values\n        log2m = HLL.MINIMUM_LOG2M_PARAM\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_LOG2M_PARAM - HLL.MINIMUM_LOG2M_PARAM));\n\n        // use accuracyOpt as a scaling factor for regwidth as well, BUT...\n        // be more conservative -- HLL.MIN_REGWIDTH_PARAM is too absurdly low to be useful\n        // use previously computed (hashableNumType) default regwidth -1 as lower bound for scaling\n        final int MIN_HUERISTIC_REGWIDTH = regwidth-1;\n        regwidth = MIN_HUERISTIC_REGWIDTH\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_REGWIDTH_PARAM - MIN_HUERISTIC_REGWIDTH));\n\n      } catch (NumberFormatException nfe) {\n        // param value isn't a number -- let's check for simple true/false\n        if (! localParams.getBool(Stat.cardinality.name(), false)) {\n          return null;\n        }\n      }\n\n      // let explicit params override both the default and/or any accuracy specification\n      log2m = localParams.getInt(\"hllLog2m\", log2m);\n      regwidth = localParams.getInt(\"hllRegwidth\", regwidth);\n\n      // validate legal values\n      if (log2m < HLL.MINIMUM_LOG2M_PARAM || HLL.MAXIMUM_LOG2M_PARAM < log2m) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllLog2m must be at least \" + \n                                HLL.MINIMUM_LOG2M_PARAM + \" and at most \" + HLL.MAXIMUM_LOG2M_PARAM\n                                + \" (\" + log2m +\")\");\n      }\n      if (regwidth < HLL.MINIMUM_REGWIDTH_PARAM || HLL.MAXIMUM_REGWIDTH_PARAM < regwidth) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllRegwidth must be at least \" + \n                                HLL.MINIMUM_REGWIDTH_PARAM + \" and at most \" + HLL.MAXIMUM_REGWIDTH_PARAM);\n      }\n      \n      HashFunction hasher = localParams.getBool(\"hllPreHashed\", false) ? null : Hashing.murmur3_128();\n\n      if (null == hasher) {\n        // if this is a function, or a non Long field, pre-hashed is invalid\n        // NOTE: we ignore hashableNumType - it's LONG for non numerics like Strings\n        if (null == field || !(NumberType.LONG.equals(field.getType().getNumberType()) || NumberType.DATE.equals(field.getType().getNumberType()))) { \n          throw new SolrException(ErrorCode.BAD_REQUEST, \"hllPreHashed is only supported with Long based fields\");\n        }\n      }\n\n      // if we're still here, then we need an HLL...\n      return new HllOptions(log2m, regwidth, hasher);\n    }\n\n","sourceOld":"    /** \n     * Creates an HllOptions based on the (local) params specified (if appropriate).\n     *\n     * @param localParams the LocalParams for this {@link StatsField}\n     * @param field the field corresponding to this {@link StatsField}, may be null if these stats are over a value source\n     * @return the {@link HllOptions} to use based on the params, or null if no {@link HLL} should be computed\n     * @throws SolrException if there are invalid options\n     */\n    public static HllOptions parseHllOptions(SolrParams localParams, SchemaField field) \n      throws SolrException {\n\n      String cardinalityOpt = localParams.get(Stat.cardinality.name());\n      if (StringUtils.isBlank(cardinalityOpt)) {\n        return null;\n      }\n\n      final NumberType hashableNumType = getHashableNumericType(field);\n\n      // some sane defaults\n      int log2m = 13;   // roughly equivilent to \"cardinality='0.33'\"\n      int regwidth = 6; // with decent hash, this is plenty for all valid long hashes\n\n      if (NumberType.FLOAT.equals(hashableNumType) || NumberType.INTEGER.equals(hashableNumType)) {\n        // for 32bit values, we can adjust our default regwidth down a bit\n        regwidth--;\n\n        // NOTE: EnumField uses LegacyNumericType.INT, and in theory we could be super conservative\n        // with it, but there's no point - just let the EXPLICIT HLL handle it\n      }\n\n      // TODO: we could attempt additional reductions in the default regwidth based on index\n      // statistics -- but thta doesn't seem worth the effort.  for tiny indexes, the \n      // EXPLICIT and SPARSE HLL representations have us nicely covered, and in general we don't \n      // want to be too aggresive about lowering regwidth or we could really poor results if \n      // log2m is also low and  there is heavy hashkey collision\n\n      try {\n        // NFE will short out here if it's not a number\n        final double accuracyOpt = Double.parseDouble(cardinalityOpt);\n\n        // if a float between 0 and 1 is specified, treat it as a prefrence of accuracy\n        // - 0 means accuracy is not a concern, save RAM\n        // - 1 means be as accurate as possible, using as much RAM as needed.\n\n        if (accuracyOpt < 0D || 1.0D < accuracyOpt) {\n          throw new SolrException(ErrorCode.BAD_REQUEST, ERR);\n        }\n\n        // use accuracyOpt as a scaling factor between min & max legal log2m values\n        log2m = HLL.MINIMUM_LOG2M_PARAM\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_LOG2M_PARAM - HLL.MINIMUM_LOG2M_PARAM));\n\n        // use accuracyOpt as a scaling factor for regwidth as well, BUT...\n        // be more conservative -- HLL.MIN_REGWIDTH_PARAM is too absurdly low to be useful\n        // use previously computed (hashableNumType) default regwidth -1 as lower bound for scaling\n        final int MIN_HUERISTIC_REGWIDTH = regwidth-1;\n        regwidth = MIN_HUERISTIC_REGWIDTH\n          + (int) Math.round(accuracyOpt * (HLL.MAXIMUM_REGWIDTH_PARAM - MIN_HUERISTIC_REGWIDTH));\n\n      } catch (NumberFormatException nfe) {\n        // param value isn't a number -- let's check for simple true/false\n        if (! localParams.getBool(Stat.cardinality.name(), false)) {\n          return null;\n        }\n      }\n\n      // let explicit params override both the default and/or any accuracy specification\n      log2m = localParams.getInt(\"hllLog2m\", log2m);\n      regwidth = localParams.getInt(\"hllRegwidth\", regwidth);\n\n      // validate legal values\n      if (log2m < HLL.MINIMUM_LOG2M_PARAM || HLL.MAXIMUM_LOG2M_PARAM < log2m) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllLog2m must be at least \" + \n                                HLL.MINIMUM_LOG2M_PARAM + \" and at most \" + HLL.MAXIMUM_LOG2M_PARAM\n                                + \" (\" + log2m +\")\");\n      }\n      if (regwidth < HLL.MINIMUM_REGWIDTH_PARAM || HLL.MAXIMUM_REGWIDTH_PARAM < regwidth) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"hllRegwidth must be at least \" + \n                                HLL.MINIMUM_REGWIDTH_PARAM + \" and at most \" + HLL.MAXIMUM_REGWIDTH_PARAM);\n      }\n      \n      HashFunction hasher = localParams.getBool(\"hllPreHashed\", false) ? null : Hashing.murmur3_128();\n\n      if (null == hasher) {\n        // if this is a function, or a non Long field, pre-hashed is invalid\n        // NOTE: we ignore hashableNumType - it's LONG for non numerics like Strings\n        if (null == field || !(NumberType.LONG.equals(field.getType().getNumberType()) || NumberType.DATE.equals(field.getType().getNumberType()))) { \n          throw new SolrException(ErrorCode.BAD_REQUEST, \"hllPreHashed is only supported with Long based fields\");\n        }\n      }\n\n      // if we're still here, then we need an HLL...\n      return new HllOptions(log2m, regwidth, hasher);\n    }\n\n","bugFix":["4a4e2c829188fb99886a64558664d79c9ac0fdf1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9f4251f14d2db68330fc1e6f0495c053a905d560":["3d81baa64023bbb9b43f6d929ee168b105940d30"],"4a4e2c829188fb99886a64558664d79c9ac0fdf1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"403d05f7f8d69b65659157eff1bc1d2717f04c66":["770342641f7b505eaa8dccdc666158bff2419109","2c8bedceb91e64a3f0e831450058fc4a76d2c0a6"],"3d81baa64023bbb9b43f6d929ee168b105940d30":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3b5ee4c66244bdfcc4796a114519d47701b2c026":["4a4e2c829188fb99886a64558664d79c9ac0fdf1","6d8714f9ceaaff94f0968d1c2d037978c3fde569"],"5af5ba0166322092193d4c29880b0f7670fc7ca0":["770342641f7b505eaa8dccdc666158bff2419109"],"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6":["770342641f7b505eaa8dccdc666158bff2419109","5af5ba0166322092193d4c29880b0f7670fc7ca0"],"770342641f7b505eaa8dccdc666158bff2419109":["3b5ee4c66244bdfcc4796a114519d47701b2c026"],"6d8714f9ceaaff94f0968d1c2d037978c3fde569":["4a4e2c829188fb99886a64558664d79c9ac0fdf1"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["770342641f7b505eaa8dccdc666158bff2419109","403d05f7f8d69b65659157eff1bc1d2717f04c66"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9f4251f14d2db68330fc1e6f0495c053a905d560"]},"commit2Childs":{"9f4251f14d2db68330fc1e6f0495c053a905d560":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4a4e2c829188fb99886a64558664d79c9ac0fdf1":["3b5ee4c66244bdfcc4796a114519d47701b2c026","6d8714f9ceaaff94f0968d1c2d037978c3fde569"],"403d05f7f8d69b65659157eff1bc1d2717f04c66":["3d81baa64023bbb9b43f6d929ee168b105940d30","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"3d81baa64023bbb9b43f6d929ee168b105940d30":["9f4251f14d2db68330fc1e6f0495c053a905d560"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4a4e2c829188fb99886a64558664d79c9ac0fdf1"],"3b5ee4c66244bdfcc4796a114519d47701b2c026":["770342641f7b505eaa8dccdc666158bff2419109"],"5af5ba0166322092193d4c29880b0f7670fc7ca0":["2c8bedceb91e64a3f0e831450058fc4a76d2c0a6"],"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"770342641f7b505eaa8dccdc666158bff2419109":["403d05f7f8d69b65659157eff1bc1d2717f04c66","5af5ba0166322092193d4c29880b0f7670fc7ca0","2c8bedceb91e64a3f0e831450058fc4a76d2c0a6","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"6d8714f9ceaaff94f0968d1c2d037978c3fde569":["3b5ee4c66244bdfcc4796a114519d47701b2c026"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}