{"path":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/BytesRefFieldSource#getValues(Map,AtomicReaderContext).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/BytesRefFieldSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"modules/queries/src/java/org/apache/lucene/queries/function/valuesource/BytesRefFieldSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    return new DocTermsIndexDocValues(this, readerContext, field) {\n\n      @Override\n      protected String toTerm(String readableValue) {\n        return readableValue;\n      }\n\n      @Override\n      public Object objectVal(int doc) {\n        return strVal(doc);\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + '=' + strVal(doc);\n      }\n\n    };\n  }\n\n","sourceOld":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    return new DocTermsIndexDocValues(this, readerContext, field) {\n\n      @Override\n      protected String toTerm(String readableValue) {\n        return readableValue;\n      }\n\n      @Override\n      public Object objectVal(int doc) {\n        return strVal(doc);\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + '=' + strVal(doc);\n      }\n\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d68b012e2c254aa7a4e9c125b76daf501111c8ae","date":1358889889,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/BytesRefFieldSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/BytesRefFieldSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    final FieldInfo fieldInfo = readerContext.reader().getFieldInfos().fieldInfo(field);\n    // To be sorted or not to be sorted, that is the question\n    // nocommit: do it cleaner?\n    if (fieldInfo != null && fieldInfo.hasDocValues() && fieldInfo.getDocValuesType() == DocValuesType.BINARY) {\n      final BinaryDocValues binaryValues = FieldCache.DEFAULT.getTerms(readerContext.reader(), field);\n      return new FunctionValues() {\n\n        @Override\n        public boolean exists(int doc) {\n          return true; // doc values are dense\n        }\n\n        @Override\n        public boolean bytesVal(int doc, BytesRef target) {\n          binaryValues.get(doc, target);\n          return target.length > 0;\n        }\n\n        public String strVal(int doc) {\n          final BytesRef bytes = new BytesRef();\n          return bytesVal(doc, bytes)\n              ? bytes.utf8ToString()\n              : null;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    } else {\n      return new DocTermsIndexDocValues(this, readerContext, field) {\n\n        @Override\n        protected String toTerm(String readableValue) {\n          return readableValue;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    return new DocTermsIndexDocValues(this, readerContext, field) {\n\n      @Override\n      protected String toTerm(String readableValue) {\n        return readableValue;\n      }\n\n      @Override\n      public Object objectVal(int doc) {\n        return strVal(doc);\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + '=' + strVal(doc);\n      }\n\n    };\n  }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","87d6f9603307ae2ad642fb01deedf031320fd0c3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"af44a20f9461383162a05815a16cf97d1d0fb3cb","date":1359988311,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/BytesRefFieldSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/BytesRefFieldSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    final FieldInfo fieldInfo = readerContext.reader().getFieldInfos().fieldInfo(field);\n    // To be sorted or not to be sorted, that is the question\n    // TODO: do it cleaner?\n    if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.BINARY) {\n      final BinaryDocValues binaryValues = FieldCache.DEFAULT.getTerms(readerContext.reader(), field);\n      return new FunctionValues() {\n\n        @Override\n        public boolean exists(int doc) {\n          return true; // doc values are dense\n        }\n\n        @Override\n        public boolean bytesVal(int doc, BytesRef target) {\n          binaryValues.get(doc, target);\n          return target.length > 0;\n        }\n\n        public String strVal(int doc) {\n          final BytesRef bytes = new BytesRef();\n          return bytesVal(doc, bytes)\n              ? bytes.utf8ToString()\n              : null;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    } else {\n      return new DocTermsIndexDocValues(this, readerContext, field) {\n\n        @Override\n        protected String toTerm(String readableValue) {\n          return readableValue;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    final FieldInfo fieldInfo = readerContext.reader().getFieldInfos().fieldInfo(field);\n    // To be sorted or not to be sorted, that is the question\n    // nocommit: do it cleaner?\n    if (fieldInfo != null && fieldInfo.hasDocValues() && fieldInfo.getDocValuesType() == DocValuesType.BINARY) {\n      final BinaryDocValues binaryValues = FieldCache.DEFAULT.getTerms(readerContext.reader(), field);\n      return new FunctionValues() {\n\n        @Override\n        public boolean exists(int doc) {\n          return true; // doc values are dense\n        }\n\n        @Override\n        public boolean bytesVal(int doc, BytesRef target) {\n          binaryValues.get(doc, target);\n          return target.length > 0;\n        }\n\n        public String strVal(int doc) {\n          final BytesRef bytes = new BytesRef();\n          return bytesVal(doc, bytes)\n              ? bytes.utf8ToString()\n              : null;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    } else {\n      return new DocTermsIndexDocValues(this, readerContext, field) {\n\n        @Override\n        protected String toTerm(String readableValue) {\n          return readableValue;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/BytesRefFieldSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/BytesRefFieldSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    final FieldInfo fieldInfo = readerContext.reader().getFieldInfos().fieldInfo(field);\n    // To be sorted or not to be sorted, that is the question\n    // TODO: do it cleaner?\n    if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.BINARY) {\n      final BinaryDocValues binaryValues = FieldCache.DEFAULT.getTerms(readerContext.reader(), field);\n      return new FunctionValues() {\n\n        @Override\n        public boolean exists(int doc) {\n          return true; // doc values are dense\n        }\n\n        @Override\n        public boolean bytesVal(int doc, BytesRef target) {\n          binaryValues.get(doc, target);\n          return target.length > 0;\n        }\n\n        public String strVal(int doc) {\n          final BytesRef bytes = new BytesRef();\n          return bytesVal(doc, bytes)\n              ? bytes.utf8ToString()\n              : null;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    } else {\n      return new DocTermsIndexDocValues(this, readerContext, field) {\n\n        @Override\n        protected String toTerm(String readableValue) {\n          return readableValue;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    return new DocTermsIndexDocValues(this, readerContext, field) {\n\n      @Override\n      protected String toTerm(String readableValue) {\n        return readableValue;\n      }\n\n      @Override\n      public Object objectVal(int doc) {\n        return strVal(doc);\n      }\n\n      @Override\n      public String toString(int doc) {\n        return description() + '=' + strVal(doc);\n      }\n\n    };\n  }\n\n","bugFix":["9b5937bd5a9c4cfdd2dbea83e1247d2f471cb3c8","8b48c85d1bf438ef65fbc1abe44f4e2c04a43e00"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"10307c7cc22e7e4087990972985e1d1043f01442","date":1376933032,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/BytesRefFieldSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/BytesRefFieldSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    final FieldInfo fieldInfo = readerContext.reader().getFieldInfos().fieldInfo(field);\n    // To be sorted or not to be sorted, that is the question\n    // TODO: do it cleaner?\n    if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.BINARY) {\n      final Bits docsWithField = FieldCache.DEFAULT.getDocsWithField(readerContext.reader(), field);\n      final BinaryDocValues binaryValues = FieldCache.DEFAULT.getTerms(readerContext.reader(), field);\n      return new FunctionValues() {\n\n        @Override\n        public boolean exists(int doc) {\n          return docsWithField.get(doc);\n        }\n\n        @Override\n        public boolean bytesVal(int doc, BytesRef target) {\n          binaryValues.get(doc, target);\n          return target.length > 0;\n        }\n\n        public String strVal(int doc) {\n          final BytesRef bytes = new BytesRef();\n          return bytesVal(doc, bytes)\n              ? bytes.utf8ToString()\n              : null;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    } else {\n      return new DocTermsIndexDocValues(this, readerContext, field) {\n\n        @Override\n        protected String toTerm(String readableValue) {\n          return readableValue;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    final FieldInfo fieldInfo = readerContext.reader().getFieldInfos().fieldInfo(field);\n    // To be sorted or not to be sorted, that is the question\n    // TODO: do it cleaner?\n    if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.BINARY) {\n      final BinaryDocValues binaryValues = FieldCache.DEFAULT.getTerms(readerContext.reader(), field);\n      return new FunctionValues() {\n\n        @Override\n        public boolean exists(int doc) {\n          return true; // doc values are dense\n        }\n\n        @Override\n        public boolean bytesVal(int doc, BytesRef target) {\n          binaryValues.get(doc, target);\n          return target.length > 0;\n        }\n\n        public String strVal(int doc) {\n          final BytesRef bytes = new BytesRef();\n          return bytesVal(doc, bytes)\n              ? bytes.utf8ToString()\n              : null;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    } else {\n      return new DocTermsIndexDocValues(this, readerContext, field) {\n\n        @Override\n        protected String toTerm(String readableValue) {\n          return readableValue;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff","date":1377034255,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/BytesRefFieldSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/BytesRefFieldSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    final FieldInfo fieldInfo = readerContext.reader().getFieldInfos().fieldInfo(field);\n    // To be sorted or not to be sorted, that is the question\n    // TODO: do it cleaner?\n    if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.BINARY) {\n      final Bits docsWithField = FieldCache.DEFAULT.getDocsWithField(readerContext.reader(), field);\n      final BinaryDocValues binaryValues = FieldCache.DEFAULT.getTerms(readerContext.reader(), field);\n      return new FunctionValues() {\n\n        @Override\n        public boolean exists(int doc) {\n          return docsWithField.get(doc);\n        }\n\n        @Override\n        public boolean bytesVal(int doc, BytesRef target) {\n          binaryValues.get(doc, target);\n          return target.length > 0;\n        }\n\n        public String strVal(int doc) {\n          final BytesRef bytes = new BytesRef();\n          return bytesVal(doc, bytes)\n              ? bytes.utf8ToString()\n              : null;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    } else {\n      return new DocTermsIndexDocValues(this, readerContext, field) {\n\n        @Override\n        protected String toTerm(String readableValue) {\n          return readableValue;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    final FieldInfo fieldInfo = readerContext.reader().getFieldInfos().fieldInfo(field);\n    // To be sorted or not to be sorted, that is the question\n    // TODO: do it cleaner?\n    if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.BINARY) {\n      final BinaryDocValues binaryValues = FieldCache.DEFAULT.getTerms(readerContext.reader(), field);\n      return new FunctionValues() {\n\n        @Override\n        public boolean exists(int doc) {\n          return true; // doc values are dense\n        }\n\n        @Override\n        public boolean bytesVal(int doc, BytesRef target) {\n          binaryValues.get(doc, target);\n          return target.length > 0;\n        }\n\n        public String strVal(int doc) {\n          final BytesRef bytes = new BytesRef();\n          return bytesVal(doc, bytes)\n              ? bytes.utf8ToString()\n              : null;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    } else {\n      return new DocTermsIndexDocValues(this, readerContext, field) {\n\n        @Override\n        protected String toTerm(String readableValue) {\n          return readableValue;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/BytesRefFieldSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/BytesRefFieldSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    final FieldInfo fieldInfo = readerContext.reader().getFieldInfos().fieldInfo(field);\n    // To be sorted or not to be sorted, that is the question\n    // TODO: do it cleaner?\n    if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.BINARY) {\n      final Bits docsWithField = FieldCache.DEFAULT.getDocsWithField(readerContext.reader(), field);\n      final BinaryDocValues binaryValues = FieldCache.DEFAULT.getTerms(readerContext.reader(), field);\n      return new FunctionValues() {\n\n        @Override\n        public boolean exists(int doc) {\n          return docsWithField.get(doc);\n        }\n\n        @Override\n        public boolean bytesVal(int doc, BytesRef target) {\n          binaryValues.get(doc, target);\n          return target.length > 0;\n        }\n\n        public String strVal(int doc) {\n          final BytesRef bytes = new BytesRef();\n          return bytesVal(doc, bytes)\n              ? bytes.utf8ToString()\n              : null;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    } else {\n      return new DocTermsIndexDocValues(this, readerContext, field) {\n\n        @Override\n        protected String toTerm(String readableValue) {\n          return readableValue;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    final FieldInfo fieldInfo = readerContext.reader().getFieldInfos().fieldInfo(field);\n    // To be sorted or not to be sorted, that is the question\n    // TODO: do it cleaner?\n    if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.BINARY) {\n      final BinaryDocValues binaryValues = FieldCache.DEFAULT.getTerms(readerContext.reader(), field);\n      return new FunctionValues() {\n\n        @Override\n        public boolean exists(int doc) {\n          return true; // doc values are dense\n        }\n\n        @Override\n        public boolean bytesVal(int doc, BytesRef target) {\n          binaryValues.get(doc, target);\n          return target.length > 0;\n        }\n\n        public String strVal(int doc) {\n          final BytesRef bytes = new BytesRef();\n          return bytesVal(doc, bytes)\n              ? bytes.utf8ToString()\n              : null;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    } else {\n      return new DocTermsIndexDocValues(this, readerContext, field) {\n\n        @Override\n        protected String toTerm(String readableValue) {\n          return readableValue;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"87d6f9603307ae2ad642fb01deedf031320fd0c3","date":1377877563,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/BytesRefFieldSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/BytesRefFieldSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    final FieldInfo fieldInfo = readerContext.reader().getFieldInfos().fieldInfo(field);\n    // To be sorted or not to be sorted, that is the question\n    // TODO: do it cleaner?\n    if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.BINARY) {\n      final BinaryDocValues binaryValues = FieldCache.DEFAULT.getTerms(readerContext.reader(), field, true);\n      final Bits docsWithField = FieldCache.DEFAULT.getDocsWithField(readerContext.reader(), field);\n      return new FunctionValues() {\n\n        @Override\n        public boolean exists(int doc) {\n          return docsWithField.get(doc);\n        }\n\n        @Override\n        public boolean bytesVal(int doc, BytesRef target) {\n          binaryValues.get(doc, target);\n          return target.length > 0;\n        }\n\n        public String strVal(int doc) {\n          final BytesRef bytes = new BytesRef();\n          return bytesVal(doc, bytes)\n              ? bytes.utf8ToString()\n              : null;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    } else {\n      return new DocTermsIndexDocValues(this, readerContext, field) {\n\n        @Override\n        protected String toTerm(String readableValue) {\n          return readableValue;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    final FieldInfo fieldInfo = readerContext.reader().getFieldInfos().fieldInfo(field);\n    // To be sorted or not to be sorted, that is the question\n    // TODO: do it cleaner?\n    if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.BINARY) {\n      final Bits docsWithField = FieldCache.DEFAULT.getDocsWithField(readerContext.reader(), field);\n      final BinaryDocValues binaryValues = FieldCache.DEFAULT.getTerms(readerContext.reader(), field);\n      return new FunctionValues() {\n\n        @Override\n        public boolean exists(int doc) {\n          return docsWithField.get(doc);\n        }\n\n        @Override\n        public boolean bytesVal(int doc, BytesRef target) {\n          binaryValues.get(doc, target);\n          return target.length > 0;\n        }\n\n        public String strVal(int doc) {\n          final BytesRef bytes = new BytesRef();\n          return bytesVal(doc, bytes)\n              ? bytes.utf8ToString()\n              : null;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    } else {\n      return new DocTermsIndexDocValues(this, readerContext, field) {\n\n        @Override\n        protected String toTerm(String readableValue) {\n          return readableValue;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    }\n  }\n\n","bugFix":["d68b012e2c254aa7a4e9c125b76daf501111c8ae"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c","date":1399816179,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/BytesRefFieldSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/BytesRefFieldSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    final FieldInfo fieldInfo = readerContext.reader().getFieldInfos().fieldInfo(field);\n    // To be sorted or not to be sorted, that is the question\n    // TODO: do it cleaner?\n    if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.BINARY) {\n      final BinaryDocValues binaryValues = DocValues.getBinary(readerContext.reader(), field);\n      final Bits docsWithField = DocValues.getDocsWithField(readerContext.reader(), field);\n      return new FunctionValues() {\n\n        @Override\n        public boolean exists(int doc) {\n          return docsWithField.get(doc);\n        }\n\n        @Override\n        public boolean bytesVal(int doc, BytesRef target) {\n          binaryValues.get(doc, target);\n          return target.length > 0;\n        }\n\n        public String strVal(int doc) {\n          final BytesRef bytes = new BytesRef();\n          return bytesVal(doc, bytes)\n              ? bytes.utf8ToString()\n              : null;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    } else {\n      return new DocTermsIndexDocValues(this, readerContext, field) {\n\n        @Override\n        protected String toTerm(String readableValue) {\n          return readableValue;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    final FieldInfo fieldInfo = readerContext.reader().getFieldInfos().fieldInfo(field);\n    // To be sorted or not to be sorted, that is the question\n    // TODO: do it cleaner?\n    if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.BINARY) {\n      final BinaryDocValues binaryValues = FieldCache.DEFAULT.getTerms(readerContext.reader(), field, true);\n      final Bits docsWithField = FieldCache.DEFAULT.getDocsWithField(readerContext.reader(), field);\n      return new FunctionValues() {\n\n        @Override\n        public boolean exists(int doc) {\n          return docsWithField.get(doc);\n        }\n\n        @Override\n        public boolean bytesVal(int doc, BytesRef target) {\n          binaryValues.get(doc, target);\n          return target.length > 0;\n        }\n\n        public String strVal(int doc) {\n          final BytesRef bytes = new BytesRef();\n          return bytesVal(doc, bytes)\n              ? bytes.utf8ToString()\n              : null;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    } else {\n      return new DocTermsIndexDocValues(this, readerContext, field) {\n\n        @Override\n        protected String toTerm(String readableValue) {\n          return readableValue;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ee2e49d7d238ef272447503afe1249fa73b41646","date":1399823449,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/BytesRefFieldSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/BytesRefFieldSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    final FieldInfo fieldInfo = readerContext.reader().getFieldInfos().fieldInfo(field);\n\n    // To be sorted or not to be sorted, that is the question\n    // TODO: do it cleaner?\n    if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.BINARY) {\n      final BinaryDocValues binaryValues = DocValues.getBinary(readerContext.reader(), field);\n      final Bits docsWithField = DocValues.getDocsWithField(readerContext.reader(), field);\n      return new FunctionValues() {\n\n        @Override\n        public boolean exists(int doc) {\n          return docsWithField.get(doc);\n        }\n\n        @Override\n        public boolean bytesVal(int doc, BytesRef target) {\n          binaryValues.get(doc, target);\n          return target.length > 0;\n        }\n\n        public String strVal(int doc) {\n          final BytesRef bytes = new BytesRef();\n          return bytesVal(doc, bytes)\n              ? bytes.utf8ToString()\n              : null;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n\n        @Override\n        public ValueFiller getValueFiller() {\n          return new ValueFiller() {\n            private final MutableValueStr mval = new MutableValueStr();\n\n            @Override\n            public MutableValue getValue() {\n              return mval;\n            }\n\n            @Override\n            public void fillValue(int doc) {\n              mval.exists = docsWithField.get(doc);\n              if (mval.exists) {\n                binaryValues.get(doc, mval.value);\n              }\n            }\n          };\n        }\n\n      };\n    } else {\n      return new DocTermsIndexDocValues(this, readerContext, field) {\n\n        @Override\n        protected String toTerm(String readableValue) {\n          return readableValue;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    final FieldInfo fieldInfo = readerContext.reader().getFieldInfos().fieldInfo(field);\n    // To be sorted or not to be sorted, that is the question\n    // TODO: do it cleaner?\n    if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.BINARY) {\n      final BinaryDocValues binaryValues = DocValues.getBinary(readerContext.reader(), field);\n      final Bits docsWithField = DocValues.getDocsWithField(readerContext.reader(), field);\n      return new FunctionValues() {\n\n        @Override\n        public boolean exists(int doc) {\n          return docsWithField.get(doc);\n        }\n\n        @Override\n        public boolean bytesVal(int doc, BytesRef target) {\n          binaryValues.get(doc, target);\n          return target.length > 0;\n        }\n\n        public String strVal(int doc) {\n          final BytesRef bytes = new BytesRef();\n          return bytesVal(doc, bytes)\n              ? bytes.utf8ToString()\n              : null;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    } else {\n      return new DocTermsIndexDocValues(this, readerContext, field) {\n\n        @Override\n        protected String toTerm(String readableValue) {\n          return readableValue;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6d1c58e9d1ed4b363d0b00ad5209e1b01c418347","date":1399827661,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/BytesRefFieldSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/BytesRefFieldSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    final FieldInfo fieldInfo = readerContext.reader().getFieldInfos().fieldInfo(field);\n\n    // To be sorted or not to be sorted, that is the question\n    // TODO: do it cleaner?\n    if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.BINARY) {\n      final BinaryDocValues binaryValues = DocValues.getBinary(readerContext.reader(), field);\n      final Bits docsWithField = DocValues.getDocsWithField(readerContext.reader(), field);\n      return new FunctionValues() {\n\n        @Override\n        public boolean exists(int doc) {\n          return docsWithField.get(doc);\n        }\n\n        @Override\n        public boolean bytesVal(int doc, BytesRef target) {\n          binaryValues.get(doc, target);\n          return target.length > 0;\n        }\n\n        public String strVal(int doc) {\n          final BytesRef bytes = new BytesRef();\n          return bytesVal(doc, bytes)\n              ? bytes.utf8ToString()\n              : null;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n\n        @Override\n        public ValueFiller getValueFiller() {\n          return new ValueFiller() {\n            private final MutableValueStr mval = new MutableValueStr();\n\n            @Override\n            public MutableValue getValue() {\n              return mval;\n            }\n\n            @Override\n            public void fillValue(int doc) {\n              mval.exists = docsWithField.get(doc);\n              if (mval.exists) {\n                binaryValues.get(doc, mval.value);\n              } else {\n                mval.value.bytes = BytesRef.EMPTY_BYTES;\n                mval.value.offset = 0;\n                mval.value.length = 0;\n              }\n            }\n          };\n        }\n\n      };\n    } else {\n      return new DocTermsIndexDocValues(this, readerContext, field) {\n\n        @Override\n        protected String toTerm(String readableValue) {\n          return readableValue;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    final FieldInfo fieldInfo = readerContext.reader().getFieldInfos().fieldInfo(field);\n\n    // To be sorted or not to be sorted, that is the question\n    // TODO: do it cleaner?\n    if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.BINARY) {\n      final BinaryDocValues binaryValues = DocValues.getBinary(readerContext.reader(), field);\n      final Bits docsWithField = DocValues.getDocsWithField(readerContext.reader(), field);\n      return new FunctionValues() {\n\n        @Override\n        public boolean exists(int doc) {\n          return docsWithField.get(doc);\n        }\n\n        @Override\n        public boolean bytesVal(int doc, BytesRef target) {\n          binaryValues.get(doc, target);\n          return target.length > 0;\n        }\n\n        public String strVal(int doc) {\n          final BytesRef bytes = new BytesRef();\n          return bytesVal(doc, bytes)\n              ? bytes.utf8ToString()\n              : null;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n\n        @Override\n        public ValueFiller getValueFiller() {\n          return new ValueFiller() {\n            private final MutableValueStr mval = new MutableValueStr();\n\n            @Override\n            public MutableValue getValue() {\n              return mval;\n            }\n\n            @Override\n            public void fillValue(int doc) {\n              mval.exists = docsWithField.get(doc);\n              if (mval.exists) {\n                binaryValues.get(doc, mval.value);\n              }\n            }\n          };\n        }\n\n      };\n    } else {\n      return new DocTermsIndexDocValues(this, readerContext, field) {\n\n        @Override\n        protected String toTerm(String readableValue) {\n          return readableValue;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93dd449115a9247533e44bab47e8429e5dccbc6d","date":1400258396,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/BytesRefFieldSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/BytesRefFieldSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    final FieldInfo fieldInfo = readerContext.reader().getFieldInfos().fieldInfo(field);\n\n    // To be sorted or not to be sorted, that is the question\n    // TODO: do it cleaner?\n    if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.BINARY) {\n      final BinaryDocValues binaryValues = DocValues.getBinary(readerContext.reader(), field);\n      final Bits docsWithField = DocValues.getDocsWithField(readerContext.reader(), field);\n      return new FunctionValues() {\n\n        @Override\n        public boolean exists(int doc) {\n          return docsWithField.get(doc);\n        }\n\n        @Override\n        public boolean bytesVal(int doc, BytesRef target) {\n          binaryValues.get(doc, target);\n          return target.length > 0;\n        }\n\n        public String strVal(int doc) {\n          final BytesRef bytes = new BytesRef();\n          return bytesVal(doc, bytes)\n              ? bytes.utf8ToString()\n              : null;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n\n        @Override\n        public ValueFiller getValueFiller() {\n          return new ValueFiller() {\n            private final MutableValueStr mval = new MutableValueStr();\n\n            @Override\n            public MutableValue getValue() {\n              return mval;\n            }\n\n            @Override\n            public void fillValue(int doc) {\n              mval.exists = docsWithField.get(doc);\n              if (mval.exists) {\n                binaryValues.get(doc, mval.value);\n              } else {\n                mval.value.bytes = BytesRef.EMPTY_BYTES;\n                mval.value.offset = 0;\n                mval.value.length = 0;\n              }\n            }\n          };\n        }\n\n      };\n    } else {\n      return new DocTermsIndexDocValues(this, readerContext, field) {\n\n        @Override\n        protected String toTerm(String readableValue) {\n          return readableValue;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    final FieldInfo fieldInfo = readerContext.reader().getFieldInfos().fieldInfo(field);\n    // To be sorted or not to be sorted, that is the question\n    // TODO: do it cleaner?\n    if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.BINARY) {\n      final BinaryDocValues binaryValues = FieldCache.DEFAULT.getTerms(readerContext.reader(), field, true);\n      final Bits docsWithField = FieldCache.DEFAULT.getDocsWithField(readerContext.reader(), field);\n      return new FunctionValues() {\n\n        @Override\n        public boolean exists(int doc) {\n          return docsWithField.get(doc);\n        }\n\n        @Override\n        public boolean bytesVal(int doc, BytesRef target) {\n          binaryValues.get(doc, target);\n          return target.length > 0;\n        }\n\n        public String strVal(int doc) {\n          final BytesRef bytes = new BytesRef();\n          return bytesVal(doc, bytes)\n              ? bytes.utf8ToString()\n              : null;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    } else {\n      return new DocTermsIndexDocValues(this, readerContext, field) {\n\n        @Override\n        protected String toTerm(String readableValue) {\n          return readableValue;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/BytesRefFieldSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/BytesRefFieldSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    final FieldInfo fieldInfo = readerContext.reader().getFieldInfos().fieldInfo(field);\n\n    // To be sorted or not to be sorted, that is the question\n    // TODO: do it cleaner?\n    if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.BINARY) {\n      final BinaryDocValues binaryValues = DocValues.getBinary(readerContext.reader(), field);\n      final Bits docsWithField = DocValues.getDocsWithField(readerContext.reader(), field);\n      return new FunctionValues() {\n\n        @Override\n        public boolean exists(int doc) {\n          return docsWithField.get(doc);\n        }\n\n        @Override\n        public boolean bytesVal(int doc, BytesRef target) {\n          binaryValues.get(doc, target);\n          return target.length > 0;\n        }\n\n        public String strVal(int doc) {\n          final BytesRef bytes = new BytesRef();\n          return bytesVal(doc, bytes)\n              ? bytes.utf8ToString()\n              : null;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n\n        @Override\n        public ValueFiller getValueFiller() {\n          return new ValueFiller() {\n            private final MutableValueStr mval = new MutableValueStr();\n\n            @Override\n            public MutableValue getValue() {\n              return mval;\n            }\n\n            @Override\n            public void fillValue(int doc) {\n              mval.exists = docsWithField.get(doc);\n              if (mval.exists) {\n                binaryValues.get(doc, mval.value);\n              } else {\n                mval.value.bytes = BytesRef.EMPTY_BYTES;\n                mval.value.offset = 0;\n                mval.value.length = 0;\n              }\n            }\n          };\n        }\n\n      };\n    } else {\n      return new DocTermsIndexDocValues(this, readerContext, field) {\n\n        @Override\n        protected String toTerm(String readableValue) {\n          return readableValue;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    final FieldInfo fieldInfo = readerContext.reader().getFieldInfos().fieldInfo(field);\n    // To be sorted or not to be sorted, that is the question\n    // TODO: do it cleaner?\n    if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.BINARY) {\n      final BinaryDocValues binaryValues = FieldCache.DEFAULT.getTerms(readerContext.reader(), field, true);\n      final Bits docsWithField = FieldCache.DEFAULT.getDocsWithField(readerContext.reader(), field);\n      return new FunctionValues() {\n\n        @Override\n        public boolean exists(int doc) {\n          return docsWithField.get(doc);\n        }\n\n        @Override\n        public boolean bytesVal(int doc, BytesRef target) {\n          binaryValues.get(doc, target);\n          return target.length > 0;\n        }\n\n        public String strVal(int doc) {\n          final BytesRef bytes = new BytesRef();\n          return bytesVal(doc, bytes)\n              ? bytes.utf8ToString()\n              : null;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    } else {\n      return new DocTermsIndexDocValues(this, readerContext, field) {\n\n        @Override\n        protected String toTerm(String readableValue) {\n          return readableValue;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf","date":1401983689,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/BytesRefFieldSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/BytesRefFieldSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    final FieldInfo fieldInfo = readerContext.reader().getFieldInfos().fieldInfo(field);\n\n    // To be sorted or not to be sorted, that is the question\n    // TODO: do it cleaner?\n    if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.BINARY) {\n      final BinaryDocValues binaryValues = DocValues.getBinary(readerContext.reader(), field);\n      final Bits docsWithField = DocValues.getDocsWithField(readerContext.reader(), field);\n      return new FunctionValues() {\n\n        @Override\n        public boolean exists(int doc) {\n          return docsWithField.get(doc);\n        }\n\n        @Override\n        public boolean bytesVal(int doc, BytesRef target) {\n          target.copyBytes(binaryValues.get(doc));\n          return target.length > 0;\n        }\n\n        public String strVal(int doc) {\n          final BytesRef bytes = new BytesRef();\n          return bytesVal(doc, bytes)\n              ? bytes.utf8ToString()\n              : null;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n\n        @Override\n        public ValueFiller getValueFiller() {\n          return new ValueFiller() {\n            private final MutableValueStr mval = new MutableValueStr();\n\n            @Override\n            public MutableValue getValue() {\n              return mval;\n            }\n\n            @Override\n            public void fillValue(int doc) {\n              mval.exists = docsWithField.get(doc);\n              mval.value.length = 0;\n              mval.value.copyBytes(binaryValues.get(doc));\n            }\n          };\n        }\n\n      };\n    } else {\n      return new DocTermsIndexDocValues(this, readerContext, field) {\n\n        @Override\n        protected String toTerm(String readableValue) {\n          return readableValue;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    final FieldInfo fieldInfo = readerContext.reader().getFieldInfos().fieldInfo(field);\n\n    // To be sorted or not to be sorted, that is the question\n    // TODO: do it cleaner?\n    if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.BINARY) {\n      final BinaryDocValues binaryValues = DocValues.getBinary(readerContext.reader(), field);\n      final Bits docsWithField = DocValues.getDocsWithField(readerContext.reader(), field);\n      return new FunctionValues() {\n\n        @Override\n        public boolean exists(int doc) {\n          return docsWithField.get(doc);\n        }\n\n        @Override\n        public boolean bytesVal(int doc, BytesRef target) {\n          binaryValues.get(doc, target);\n          return target.length > 0;\n        }\n\n        public String strVal(int doc) {\n          final BytesRef bytes = new BytesRef();\n          return bytesVal(doc, bytes)\n              ? bytes.utf8ToString()\n              : null;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n\n        @Override\n        public ValueFiller getValueFiller() {\n          return new ValueFiller() {\n            private final MutableValueStr mval = new MutableValueStr();\n\n            @Override\n            public MutableValue getValue() {\n              return mval;\n            }\n\n            @Override\n            public void fillValue(int doc) {\n              mval.exists = docsWithField.get(doc);\n              if (mval.exists) {\n                binaryValues.get(doc, mval.value);\n              } else {\n                mval.value.bytes = BytesRef.EMPTY_BYTES;\n                mval.value.offset = 0;\n                mval.value.length = 0;\n              }\n            }\n          };\n        }\n\n      };\n    } else {\n      return new DocTermsIndexDocValues(this, readerContext, field) {\n\n        @Override\n        protected String toTerm(String readableValue) {\n          return readableValue;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/BytesRefFieldSource#getValues(Map,AtomicReaderContext).mjava","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/BytesRefFieldSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    final FieldInfo fieldInfo = readerContext.reader().getFieldInfos().fieldInfo(field);\n\n    // To be sorted or not to be sorted, that is the question\n    // TODO: do it cleaner?\n    if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.BINARY) {\n      final BinaryDocValues binaryValues = DocValues.getBinary(readerContext.reader(), field);\n      final Bits docsWithField = DocValues.getDocsWithField(readerContext.reader(), field);\n      return new FunctionValues() {\n\n        @Override\n        public boolean exists(int doc) {\n          return docsWithField.get(doc);\n        }\n\n        @Override\n        public boolean bytesVal(int doc, BytesRefBuilder target) {\n          target.copyBytes(binaryValues.get(doc));\n          return target.length() > 0;\n        }\n\n        public String strVal(int doc) {\n          final BytesRefBuilder bytes = new BytesRefBuilder();\n          return bytesVal(doc, bytes)\n              ? bytes.get().utf8ToString()\n              : null;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n\n        @Override\n        public ValueFiller getValueFiller() {\n          return new ValueFiller() {\n            private final MutableValueStr mval = new MutableValueStr();\n\n            @Override\n            public MutableValue getValue() {\n              return mval;\n            }\n\n            @Override\n            public void fillValue(int doc) {\n              mval.exists = docsWithField.get(doc);\n              mval.value.clear();\n              mval.value.copyBytes(binaryValues.get(doc));\n            }\n          };\n        }\n\n      };\n    } else {\n      return new DocTermsIndexDocValues(this, readerContext, field) {\n\n        @Override\n        protected String toTerm(String readableValue) {\n          return readableValue;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    final FieldInfo fieldInfo = readerContext.reader().getFieldInfos().fieldInfo(field);\n\n    // To be sorted or not to be sorted, that is the question\n    // TODO: do it cleaner?\n    if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.BINARY) {\n      final BinaryDocValues binaryValues = DocValues.getBinary(readerContext.reader(), field);\n      final Bits docsWithField = DocValues.getDocsWithField(readerContext.reader(), field);\n      return new FunctionValues() {\n\n        @Override\n        public boolean exists(int doc) {\n          return docsWithField.get(doc);\n        }\n\n        @Override\n        public boolean bytesVal(int doc, BytesRef target) {\n          target.copyBytes(binaryValues.get(doc));\n          return target.length > 0;\n        }\n\n        public String strVal(int doc) {\n          final BytesRef bytes = new BytesRef();\n          return bytesVal(doc, bytes)\n              ? bytes.utf8ToString()\n              : null;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n\n        @Override\n        public ValueFiller getValueFiller() {\n          return new ValueFiller() {\n            private final MutableValueStr mval = new MutableValueStr();\n\n            @Override\n            public MutableValue getValue() {\n              return mval;\n            }\n\n            @Override\n            public void fillValue(int doc) {\n              mval.exists = docsWithField.get(doc);\n              mval.value.length = 0;\n              mval.value.copyBytes(binaryValues.get(doc));\n            }\n          };\n        }\n\n      };\n    } else {\n      return new DocTermsIndexDocValues(this, readerContext, field) {\n\n        @Override\n        protected String toTerm(String readableValue) {\n          return readableValue;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    }\n  }\n\n","bugFix":["53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf","d68b012e2c254aa7a4e9c125b76daf501111c8ae"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":4,"author":"Ryan Ernst","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/BytesRefFieldSource#getValues(Map,AtomicReaderContext).mjava","sourceNew":null,"sourceOld":"  @Override\n  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {\n    final FieldInfo fieldInfo = readerContext.reader().getFieldInfos().fieldInfo(field);\n\n    // To be sorted or not to be sorted, that is the question\n    // TODO: do it cleaner?\n    if (fieldInfo != null && fieldInfo.getDocValuesType() == DocValuesType.BINARY) {\n      final BinaryDocValues binaryValues = DocValues.getBinary(readerContext.reader(), field);\n      final Bits docsWithField = DocValues.getDocsWithField(readerContext.reader(), field);\n      return new FunctionValues() {\n\n        @Override\n        public boolean exists(int doc) {\n          return docsWithField.get(doc);\n        }\n\n        @Override\n        public boolean bytesVal(int doc, BytesRefBuilder target) {\n          target.copyBytes(binaryValues.get(doc));\n          return target.length() > 0;\n        }\n\n        public String strVal(int doc) {\n          final BytesRefBuilder bytes = new BytesRefBuilder();\n          return bytesVal(doc, bytes)\n              ? bytes.get().utf8ToString()\n              : null;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n\n        @Override\n        public ValueFiller getValueFiller() {\n          return new ValueFiller() {\n            private final MutableValueStr mval = new MutableValueStr();\n\n            @Override\n            public MutableValue getValue() {\n              return mval;\n            }\n\n            @Override\n            public void fillValue(int doc) {\n              mval.exists = docsWithField.get(doc);\n              mval.value.clear();\n              mval.value.copyBytes(binaryValues.get(doc));\n            }\n          };\n        }\n\n      };\n    } else {\n      return new DocTermsIndexDocValues(this, readerContext, field) {\n\n        @Override\n        protected String toTerm(String readableValue) {\n          return readableValue;\n        }\n\n        @Override\n        public Object objectVal(int doc) {\n          return strVal(doc);\n        }\n\n        @Override\n        public String toString(int doc) {\n          return description() + '=' + strVal(doc);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"10307c7cc22e7e4087990972985e1d1043f01442":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["d4d69c535930b5cce125cff868d40f6373dc27d4","e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c":["87d6f9603307ae2ad642fb01deedf031320fd0c3"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf"],"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff":["d4d69c535930b5cce125cff868d40f6373dc27d4","10307c7cc22e7e4087990972985e1d1043f01442"],"87d6f9603307ae2ad642fb01deedf031320fd0c3":["e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"56572ec06f1407c066d6b7399413178b33176cd8":["87d6f9603307ae2ad642fb01deedf031320fd0c3","93dd449115a9247533e44bab47e8429e5dccbc6d"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"af44a20f9461383162a05815a16cf97d1d0fb3cb":["d68b012e2c254aa7a4e9c125b76daf501111c8ae"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6d1c58e9d1ed4b363d0b00ad5209e1b01c418347":["ee2e49d7d238ef272447503afe1249fa73b41646"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["b89678825b68eccaf09e6ab71675fc0b0af1e099","af44a20f9461383162a05815a16cf97d1d0fb3cb"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["87d6f9603307ae2ad642fb01deedf031320fd0c3","6d1c58e9d1ed4b363d0b00ad5209e1b01c418347"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ee2e49d7d238ef272447503afe1249fa73b41646":["b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c"],"d68b012e2c254aa7a4e9c125b76daf501111c8ae":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c9fb5f46e264daf5ba3860defe623a89d202dd87"]},"commit2Childs":{"10307c7cc22e7e4087990972985e1d1043f01442":["e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c":["ee2e49d7d238ef272447503afe1249fa73b41646"],"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","87d6f9603307ae2ad642fb01deedf031320fd0c3"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"87d6f9603307ae2ad642fb01deedf031320fd0c3":["b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c","56572ec06f1407c066d6b7399413178b33176cd8","93dd449115a9247533e44bab47e8429e5dccbc6d"],"56572ec06f1407c066d6b7399413178b33176cd8":[],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"af44a20f9461383162a05815a16cf97d1d0fb3cb":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["d4d69c535930b5cce125cff868d40f6373dc27d4","d68b012e2c254aa7a4e9c125b76daf501111c8ae"],"6d1c58e9d1ed4b363d0b00ad5209e1b01c418347":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["10307c7cc22e7e4087990972985e1d1043f01442","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf","56572ec06f1407c066d6b7399413178b33176cd8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"ee2e49d7d238ef272447503afe1249fa73b41646":["6d1c58e9d1ed4b363d0b00ad5209e1b01c418347"],"d68b012e2c254aa7a4e9c125b76daf501111c8ae":["af44a20f9461383162a05815a16cf97d1d0fb3cb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","56572ec06f1407c066d6b7399413178b33176cd8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}