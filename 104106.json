{"path":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","pathOld":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose())\n          message(\"  merge thread: start\");\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            tWriter.mergeInit(merge);\n            updateMergeThreads();\n            if (verbose())\n              message(\"  merge thread: do another merge \" + merge.segString(dir));\n          } else {\n            done = true;\n            updateMergeThreads();\n            break;\n          }\n        }\n\n        if (verbose())\n          message(\"  merge thread: done\");\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            anyExceptions = true;\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        synchronized(ConcurrentMergeScheduler.this) {\n          ConcurrentMergeScheduler.this.notifyAll();\n          boolean removed = mergeThreads.remove(this);\n          assert removed;\n          updateMergeThreads();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose())\n          message(\"  merge thread: start\");\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            tWriter.mergeInit(merge);\n            updateMergeThreads();\n            if (verbose())\n              message(\"  merge thread: do another merge \" + merge.segString(dir));\n          } else {\n            done = true;\n            updateMergeThreads();\n            break;\n          }\n        }\n\n        if (verbose())\n          message(\"  merge thread: done\");\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            anyExceptions = true;\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        synchronized(ConcurrentMergeScheduler.this) {\n          ConcurrentMergeScheduler.this.notifyAll();\n          boolean removed = mergeThreads.remove(this);\n          assert removed;\n          updateMergeThreads();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7fc5a2665a7fa1b9450097ae658193a11ee4d02c","date":1292699695,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose())\n          message(\"  merge thread: start\");\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            tWriter.mergeInit(merge);\n            updateMergeThreads();\n            if (verbose())\n              message(\"  merge thread: do another merge \" + merge.segString(dir));\n          } else {\n            done = true;\n            updateMergeThreads();\n            break;\n          }\n        }\n\n        if (verbose())\n          message(\"  merge thread: done\");\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        synchronized(ConcurrentMergeScheduler.this) {\n          ConcurrentMergeScheduler.this.notifyAll();\n          boolean removed = mergeThreads.remove(this);\n          assert removed;\n          updateMergeThreads();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose())\n          message(\"  merge thread: start\");\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            tWriter.mergeInit(merge);\n            updateMergeThreads();\n            if (verbose())\n              message(\"  merge thread: do another merge \" + merge.segString(dir));\n          } else {\n            done = true;\n            updateMergeThreads();\n            break;\n          }\n        }\n\n        if (verbose())\n          message(\"  merge thread: done\");\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            anyExceptions = true;\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        synchronized(ConcurrentMergeScheduler.this) {\n          ConcurrentMergeScheduler.this.notifyAll();\n          boolean removed = mergeThreads.remove(this);\n          assert removed;\n          updateMergeThreads();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"db603debe12d21cac9f37467b795dd3a8559496a","date":1292767070,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose())\n          message(\"  merge thread: start\");\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            tWriter.mergeInit(merge);\n            updateMergeThreads();\n            if (verbose())\n              message(\"  merge thread: do another merge \" + merge.segString(dir));\n          } else {\n            done = true;\n            break;\n          }\n        }\n\n        if (verbose())\n          message(\"  merge thread: done\");\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        synchronized(ConcurrentMergeScheduler.this) {\n          updateMergeThreads();\n          ConcurrentMergeScheduler.this.notifyAll();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose())\n          message(\"  merge thread: start\");\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            tWriter.mergeInit(merge);\n            updateMergeThreads();\n            if (verbose())\n              message(\"  merge thread: do another merge \" + merge.segString(dir));\n          } else {\n            done = true;\n            updateMergeThreads();\n            break;\n          }\n        }\n\n        if (verbose())\n          message(\"  merge thread: done\");\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        synchronized(ConcurrentMergeScheduler.this) {\n          ConcurrentMergeScheduler.this.notifyAll();\n          boolean removed = mergeThreads.remove(this);\n          assert removed;\n          updateMergeThreads();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":["60679157c78fc286ee35471398529a1e5749621c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eb1b144119d471f0d0af58fe8cf3af07b40f72be","date":1292778444,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose())\n          message(\"  merge thread: start\");\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            tWriter.mergeInit(merge);\n            updateMergeThreads();\n            if (verbose())\n              message(\"  merge thread: do another merge \" + merge.segString(dir));\n          } else {\n            done = true;\n            updateMergeThreads();\n            break;\n          }\n        }\n\n        if (verbose())\n          message(\"  merge thread: done\");\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        synchronized(ConcurrentMergeScheduler.this) {\n          ConcurrentMergeScheduler.this.notifyAll();\n          boolean removed = mergeThreads.remove(this);\n          assert removed;\n          updateMergeThreads();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose())\n          message(\"  merge thread: start\");\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            tWriter.mergeInit(merge);\n            updateMergeThreads();\n            if (verbose())\n              message(\"  merge thread: do another merge \" + merge.segString(dir));\n          } else {\n            done = true;\n            break;\n          }\n        }\n\n        if (verbose())\n          message(\"  merge thread: done\");\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        synchronized(ConcurrentMergeScheduler.this) {\n          updateMergeThreads();\n          ConcurrentMergeScheduler.this.notifyAll();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":["60679157c78fc286ee35471398529a1e5749621c","737e811ac4583c640a0680e784121677f311a8af"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"60679157c78fc286ee35471398529a1e5749621c","date":1292841330,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose())\n          message(\"  merge thread: start\");\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            tWriter.mergeInit(merge);\n            updateMergeThreads();\n            if (verbose())\n              message(\"  merge thread: do another merge \" + merge.segString(dir));\n          } else {\n            break;\n          }\n        }\n\n        if (verbose())\n          message(\"  merge thread: done\");\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        done = true;\n        synchronized(ConcurrentMergeScheduler.this) {\n          updateMergeThreads();\n          ConcurrentMergeScheduler.this.notifyAll();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose())\n          message(\"  merge thread: start\");\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            tWriter.mergeInit(merge);\n            updateMergeThreads();\n            if (verbose())\n              message(\"  merge thread: do another merge \" + merge.segString(dir));\n          } else {\n            done = true;\n            updateMergeThreads();\n            break;\n          }\n        }\n\n        if (verbose())\n          message(\"  merge thread: done\");\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        synchronized(ConcurrentMergeScheduler.this) {\n          ConcurrentMergeScheduler.this.notifyAll();\n          boolean removed = mergeThreads.remove(this);\n          assert removed;\n          updateMergeThreads();\n        }\n      }\n    }\n\n","bugFix":["8984893e6e8e4eaf80ab863dafae092a2e9b0eaa","eb1b144119d471f0d0af58fe8cf3af07b40f72be","db603debe12d21cac9f37467b795dd3a8559496a"],"bugIntro":["737e811ac4583c640a0680e784121677f311a8af"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ab5cb6a74aefb78aa0569857970b9151dfe2e787","date":1292842407,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose())\n          message(\"  merge thread: start\");\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            tWriter.mergeInit(merge);\n            updateMergeThreads();\n            if (verbose())\n              message(\"  merge thread: do another merge \" + merge.segString(dir));\n          } else {\n            done = true;\n            updateMergeThreads();\n            break;\n          }\n        }\n\n        if (verbose())\n          message(\"  merge thread: done\");\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        synchronized(ConcurrentMergeScheduler.this) {\n          ConcurrentMergeScheduler.this.notifyAll();\n          boolean removed = mergeThreads.remove(this);\n          assert removed;\n          updateMergeThreads();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose())\n          message(\"  merge thread: start\");\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            tWriter.mergeInit(merge);\n            updateMergeThreads();\n            if (verbose())\n              message(\"  merge thread: do another merge \" + merge.segString(dir));\n          } else {\n            done = true;\n            updateMergeThreads();\n            break;\n          }\n        }\n\n        if (verbose())\n          message(\"  merge thread: done\");\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            anyExceptions = true;\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        synchronized(ConcurrentMergeScheduler.this) {\n          ConcurrentMergeScheduler.this.notifyAll();\n          boolean removed = mergeThreads.remove(this);\n          assert removed;\n          updateMergeThreads();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose())\n          message(\"  merge thread: start\");\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            tWriter.mergeInit(merge);\n            updateMergeThreads();\n            if (verbose())\n              message(\"  merge thread: do another merge \" + merge.segString(dir));\n          } else {\n            break;\n          }\n        }\n\n        if (verbose())\n          message(\"  merge thread: done\");\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        done = true;\n        synchronized(ConcurrentMergeScheduler.this) {\n          updateMergeThreads();\n          ConcurrentMergeScheduler.this.notifyAll();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose())\n          message(\"  merge thread: start\");\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            tWriter.mergeInit(merge);\n            updateMergeThreads();\n            if (verbose())\n              message(\"  merge thread: do another merge \" + merge.segString(dir));\n          } else {\n            done = true;\n            updateMergeThreads();\n            break;\n          }\n        }\n\n        if (verbose())\n          message(\"  merge thread: done\");\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            anyExceptions = true;\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        synchronized(ConcurrentMergeScheduler.this) {\n          ConcurrentMergeScheduler.this.notifyAll();\n          boolean removed = mergeThreads.remove(this);\n          assert removed;\n          updateMergeThreads();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70ad682703b8585f5d0a637efec044d57ec05efb","date":1294259117,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose())\n          message(\"  merge thread: start\");\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            tWriter.mergeInit(merge);\n            updateMergeThreads();\n            if (verbose())\n              message(\"  merge thread: do another merge \" + merge.segString(dir));\n          } else {\n            break;\n          }\n        }\n\n        if (verbose())\n          message(\"  merge thread: done\");\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        done = true;\n        synchronized(ConcurrentMergeScheduler.this) {\n          updateMergeThreads();\n          ConcurrentMergeScheduler.this.notifyAll();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose())\n          message(\"  merge thread: start\");\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            tWriter.mergeInit(merge);\n            updateMergeThreads();\n            if (verbose())\n              message(\"  merge thread: do another merge \" + merge.segString(dir));\n          } else {\n            done = true;\n            updateMergeThreads();\n            break;\n          }\n        }\n\n        if (verbose())\n          message(\"  merge thread: done\");\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        synchronized(ConcurrentMergeScheduler.this) {\n          ConcurrentMergeScheduler.this.notifyAll();\n          boolean removed = mergeThreads.remove(this);\n          assert removed;\n          updateMergeThreads();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0061262413ecc163d6eebba1b5c43ab91a0c2dc5","date":1311195279,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose())\n          message(\"  merge thread: start\");\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            tWriter.mergeInit(merge);\n            updateMergeThreads();\n            if (verbose())\n              message(\"  merge thread: do another merge \" + merge.segString(dir));\n          } else {\n            break;\n          }\n        }\n\n        if (verbose())\n          message(\"  merge thread: done\");\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          //System.out.println(Thread.currentThread().getName() + \": CMS: exc\");\n          //exc.printStackTrace(System.out);\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        done = true;\n        synchronized(ConcurrentMergeScheduler.this) {\n          updateMergeThreads();\n          ConcurrentMergeScheduler.this.notifyAll();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose())\n          message(\"  merge thread: start\");\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            tWriter.mergeInit(merge);\n            updateMergeThreads();\n            if (verbose())\n              message(\"  merge thread: do another merge \" + merge.segString(dir));\n          } else {\n            break;\n          }\n        }\n\n        if (verbose())\n          message(\"  merge thread: done\");\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        done = true;\n        synchronized(ConcurrentMergeScheduler.this) {\n          updateMergeThreads();\n          ConcurrentMergeScheduler.this.notifyAll();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c5df35ab57c223ea11aec64b53bf611904f3dced","date":1323640545,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose()) {\n          message(\"  merge thread: start\");\n        }\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            tWriter.mergeInit(merge);\n            updateMergeThreads();\n            if (verbose()) {\n              message(\"  merge thread: do another merge \" + merge.segString(dir));\n            }\n          } else {\n            break;\n          }\n        }\n\n        if (verbose()) {\n          message(\"  merge thread: done\");\n        }\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          //System.out.println(Thread.currentThread().getName() + \": CMS: exc\");\n          //exc.printStackTrace(System.out);\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        done = true;\n        synchronized(ConcurrentMergeScheduler.this) {\n          updateMergeThreads();\n          ConcurrentMergeScheduler.this.notifyAll();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose())\n          message(\"  merge thread: start\");\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            tWriter.mergeInit(merge);\n            updateMergeThreads();\n            if (verbose())\n              message(\"  merge thread: do another merge \" + merge.segString(dir));\n          } else {\n            break;\n          }\n        }\n\n        if (verbose())\n          message(\"  merge thread: done\");\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          //System.out.println(Thread.currentThread().getName() + \": CMS: exc\");\n          //exc.printStackTrace(System.out);\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        done = true;\n        synchronized(ConcurrentMergeScheduler.this) {\n          updateMergeThreads();\n          ConcurrentMergeScheduler.this.notifyAll();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","date":1323720782,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose()) {\n          message(\"  merge thread: start\");\n        }\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            tWriter.mergeInit(merge);\n            updateMergeThreads();\n            if (verbose()) {\n              message(\"  merge thread: do another merge \" + merge.segString(dir));\n            }\n          } else {\n            break;\n          }\n        }\n\n        if (verbose()) {\n          message(\"  merge thread: done\");\n        }\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          //System.out.println(Thread.currentThread().getName() + \": CMS: exc\");\n          //exc.printStackTrace(System.out);\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        done = true;\n        synchronized(ConcurrentMergeScheduler.this) {\n          updateMergeThreads();\n          ConcurrentMergeScheduler.this.notifyAll();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose())\n          message(\"  merge thread: start\");\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            tWriter.mergeInit(merge);\n            updateMergeThreads();\n            if (verbose())\n              message(\"  merge thread: do another merge \" + merge.segString(dir));\n          } else {\n            break;\n          }\n        }\n\n        if (verbose())\n          message(\"  merge thread: done\");\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          //System.out.println(Thread.currentThread().getName() + \": CMS: exc\");\n          //exc.printStackTrace(System.out);\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        done = true;\n        synchronized(ConcurrentMergeScheduler.this) {\n          updateMergeThreads();\n          ConcurrentMergeScheduler.this.notifyAll();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ce667c6d3400b22523701c549c0d35e26da8b46","date":1324405053,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose()) {\n          message(\"  merge thread: start\");\n        }\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            tWriter.mergeInit(merge);\n            updateMergeThreads();\n            if (verbose()) {\n              message(\"  merge thread: do another merge \" + tWriter.segString(merge.segments));\n            }\n          } else {\n            break;\n          }\n        }\n\n        if (verbose()) {\n          message(\"  merge thread: done\");\n        }\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          //System.out.println(Thread.currentThread().getName() + \": CMS: exc\");\n          //exc.printStackTrace(System.out);\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        done = true;\n        synchronized(ConcurrentMergeScheduler.this) {\n          updateMergeThreads();\n          ConcurrentMergeScheduler.this.notifyAll();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose()) {\n          message(\"  merge thread: start\");\n        }\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            tWriter.mergeInit(merge);\n            updateMergeThreads();\n            if (verbose()) {\n              message(\"  merge thread: do another merge \" + merge.segString(dir));\n            }\n          } else {\n            break;\n          }\n        }\n\n        if (verbose()) {\n          message(\"  merge thread: done\");\n        }\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          //System.out.println(Thread.currentThread().getName() + \": CMS: exc\");\n          //exc.printStackTrace(System.out);\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        done = true;\n        synchronized(ConcurrentMergeScheduler.this) {\n          updateMergeThreads();\n          ConcurrentMergeScheduler.this.notifyAll();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.MergeThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose()) {\n          message(\"  merge thread: start\");\n        }\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            tWriter.mergeInit(merge);\n            updateMergeThreads();\n            if (verbose()) {\n              message(\"  merge thread: do another merge \" + tWriter.segString(merge.segments));\n            }\n          } else {\n            break;\n          }\n        }\n\n        if (verbose()) {\n          message(\"  merge thread: done\");\n        }\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          //System.out.println(Thread.currentThread().getName() + \": CMS: exc\");\n          //exc.printStackTrace(System.out);\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        done = true;\n        synchronized(ConcurrentMergeScheduler.this) {\n          updateMergeThreads();\n          ConcurrentMergeScheduler.this.notifyAll();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      \n      // First time through the while loop we do the merge\n      // that we were started with:\n      MergePolicy.OneMerge merge = this.startMerge;\n      \n      try {\n\n        if (verbose()) {\n          message(\"  merge thread: start\");\n        }\n\n        while(true) {\n          setRunningMerge(merge);\n          doMerge(merge);\n\n          // Subsequent times through the loop we do any new\n          // merge that writer says is necessary:\n          merge = tWriter.getNextMerge();\n          if (merge != null) {\n            tWriter.mergeInit(merge);\n            updateMergeThreads();\n            if (verbose()) {\n              message(\"  merge thread: do another merge \" + tWriter.segString(merge.segments));\n            }\n          } else {\n            break;\n          }\n        }\n\n        if (verbose()) {\n          message(\"  merge thread: done\");\n        }\n\n      } catch (Throwable exc) {\n\n        // Ignore the exception if it was due to abort:\n        if (!(exc instanceof MergePolicy.MergeAbortedException)) {\n          //System.out.println(Thread.currentThread().getName() + \": CMS: exc\");\n          //exc.printStackTrace(System.out);\n          if (!suppressExceptions) {\n            // suppressExceptions is normally only set during\n            // testing.\n            handleMergeException(exc);\n          }\n        }\n      } finally {\n        done = true;\n        synchronized(ConcurrentMergeScheduler.this) {\n          updateMergeThreads();\n          ConcurrentMergeScheduler.this.notifyAll();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"c5df35ab57c223ea11aec64b53bf611904f3dced":["0061262413ecc163d6eebba1b5c43ab91a0c2dc5"],"7fc5a2665a7fa1b9450097ae658193a11ee4d02c":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"70ad682703b8585f5d0a637efec044d57ec05efb":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","60679157c78fc286ee35471398529a1e5749621c"],"0061262413ecc163d6eebba1b5c43ab91a0c2dc5":["60679157c78fc286ee35471398529a1e5749621c"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["9ce667c6d3400b22523701c549c0d35e26da8b46"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":["0061262413ecc163d6eebba1b5c43ab91a0c2dc5","c5df35ab57c223ea11aec64b53bf611904f3dced"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["9454a6510e2db155fb01faa5c049b06ece95fab9","7fc5a2665a7fa1b9450097ae658193a11ee4d02c"],"db603debe12d21cac9f37467b795dd3a8559496a":["7fc5a2665a7fa1b9450097ae658193a11ee4d02c"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["9454a6510e2db155fb01faa5c049b06ece95fab9","60679157c78fc286ee35471398529a1e5749621c"],"60679157c78fc286ee35471398529a1e5749621c":["eb1b144119d471f0d0af58fe8cf3af07b40f72be"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9ce667c6d3400b22523701c549c0d35e26da8b46":["c5df35ab57c223ea11aec64b53bf611904f3dced"],"eb1b144119d471f0d0af58fe8cf3af07b40f72be":["db603debe12d21cac9f37467b795dd3a8559496a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"c5df35ab57c223ea11aec64b53bf611904f3dced":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","9ce667c6d3400b22523701c549c0d35e26da8b46"],"7fc5a2665a7fa1b9450097ae658193a11ee4d02c":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","db603debe12d21cac9f37467b795dd3a8559496a"],"70ad682703b8585f5d0a637efec044d57ec05efb":[],"0061262413ecc163d6eebba1b5c43ab91a0c2dc5":["c5df35ab57c223ea11aec64b53bf611904f3dced","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":[],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["70ad682703b8585f5d0a637efec044d57ec05efb"],"db603debe12d21cac9f37467b795dd3a8559496a":["eb1b144119d471f0d0af58fe8cf3af07b40f72be"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"60679157c78fc286ee35471398529a1e5749621c":["70ad682703b8585f5d0a637efec044d57ec05efb","0061262413ecc163d6eebba1b5c43ab91a0c2dc5","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9ce667c6d3400b22523701c549c0d35e26da8b46":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"eb1b144119d471f0d0af58fe8cf3af07b40f72be":["60679157c78fc286ee35471398529a1e5749621c"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["7fc5a2665a7fa1b9450097ae658193a11ee4d02c","ab5cb6a74aefb78aa0569857970b9151dfe2e787","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["70ad682703b8585f5d0a637efec044d57ec05efb","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}