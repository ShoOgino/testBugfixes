{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/LeftOuterJoinStream#read().mjava","commits":[{"id":"333d804f5abfaf34c57493306a4cb2e01e55662d","date":1447206304,"type":0,"author":"Dennis Gove","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/LeftOuterJoinStream#read().mjava","pathOld":"/dev/null","sourceNew":"  public Tuple read() throws IOException {\n    // if we've already figured out the next joined tuple then just return it\n    if (joinedTuples.size() > 0) {\n      return joinedTuples.removeFirst();\n    }\n    \n    // keep going until we find something to return or left stream is empty\n    while (true) {\n      if (0 == leftTupleGroup.size()) {\n        Tuple firstMember = loadEqualTupleGroup(leftStream, leftTupleGroup, leftStreamComparator);\n        \n        // if first member of group is EOF then we're done\n        if (firstMember.EOF) {\n          return firstMember;\n        }\n      }\n      \n      if (0 == rightTupleGroup.size()) {\n        // Load the right tuple group, but don't end if it's EOF\n        loadEqualTupleGroup(rightStream, rightTupleGroup, rightStreamComparator);\n      }\n      \n      // If the right stream is at the EOF, we just return the next element from the left stream\n      if (0 == rightTupleGroup.size() || rightTupleGroup.get(0).EOF) {\n        return leftTupleGroup.removeFirst();\n      }\n      \n      // At this point we know both left and right groups have at least 1 member\n      if (eq.test(leftTupleGroup.get(0), rightTupleGroup.get(0))) {\n        // The groups are equal. Join em together and build the joinedTuples\n        for (Tuple left : leftTupleGroup) {\n          for (Tuple right : rightTupleGroup) {\n            Tuple clone = left.clone();\n            clone.merge(right);\n            joinedTuples.add(clone);\n          }\n        }\n        \n        // Cause each to advance next time we need to look\n        leftTupleGroup.clear();\n        rightTupleGroup.clear();\n        \n        return joinedTuples.removeFirst();\n      } else {\n        int c = iterationComparator.compare(leftTupleGroup.get(0), rightTupleGroup.get(0));\n        if (c < 0) {\n          // If there's no match, we still advance the left stream while returning every element.\n          // Because it's a left-outer join we still return the left tuple if no match on right.\n          return leftTupleGroup.removeFirst();\n        } else {\n          // advance right\n          rightTupleGroup.clear();\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"333d804f5abfaf34c57493306a4cb2e01e55662d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["333d804f5abfaf34c57493306a4cb2e01e55662d"]},"commit2Childs":{"333d804f5abfaf34c57493306a4cb2e01e55662d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["333d804f5abfaf34c57493306a4cb2e01e55662d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}