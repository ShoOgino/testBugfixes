{"path":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","commits":[{"id":"2d629ca62e3b8ab6e29a127aebe213163d490413","date":1405524223,"type":0,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    name = checkDefault(name);\n\n    // check for core-init errors first\n    CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n    if (loadFailure != null) {\n      // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n      // which we may not be able to do because of the init error.  So we just go with what we\n      // can glean from the CoreDescriptor - datadir and instancedir\n      SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n\n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.close();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["ca230c35a9895012bbcad3f191934e3d45a2825b","625b61328a0889d9b3d61cdcbfc490339f61096e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"531fe719c7218235a679452eb3d137bfd8fc6af1","date":1415191086,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    name = checkDefault(name);\n\n    // check for core-init errors first\n    CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n    if (loadFailure != null) {\n      // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n      // which we may not be able to do because of the init error.  So we just go with what we\n      // can glean from the CoreDescriptor - datadir and instancedir\n      SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    String collectionZkPath =  core.getResourceLoader() instanceof ZkSolrResourceLoader ?  ((ZkSolrResourceLoader)core.getResourceLoader()).getCollectionZkPath() : null;\n\n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.close();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd, collectionZkPath);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    name = checkDefault(name);\n\n    // check for core-init errors first\n    CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n    if (loadFailure != null) {\n      // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n      // which we may not be able to do because of the init error.  So we just go with what we\n      // can glean from the CoreDescriptor - datadir and instancedir\n      SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n\n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.close();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17778d9c1f3a8a67383edebf24754bf30a5120f8","date":1415342366,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    name = checkDefault(name);\n\n    // check for core-init errors first\n    CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n    if (loadFailure != null) {\n      // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n      // which we may not be able to do because of the init error.  So we just go with what we\n      // can glean from the CoreDescriptor - datadir and instancedir\n      SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    String configSetZkPath =  core.getResourceLoader() instanceof ZkSolrResourceLoader ?  ((ZkSolrResourceLoader)core.getResourceLoader()).getConfigSetZkPath() : null;\n\n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.close();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd, configSetZkPath);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    name = checkDefault(name);\n\n    // check for core-init errors first\n    CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n    if (loadFailure != null) {\n      // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n      // which we may not be able to do because of the init error.  So we just go with what we\n      // can glean from the CoreDescriptor - datadir and instancedir\n      SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    String collectionZkPath =  core.getResourceLoader() instanceof ZkSolrResourceLoader ?  ((ZkSolrResourceLoader)core.getResourceLoader()).getCollectionZkPath() : null;\n\n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.close();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd, collectionZkPath);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fd44bec977a26a118d9e809e2de6f7edb5ca0f39","date":1421673929,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    // check for core-init errors first\n    CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n    if (loadFailure != null) {\n      // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n      // which we may not be able to do because of the init error.  So we just go with what we\n      // can glean from the CoreDescriptor - datadir and instancedir\n      SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    String configSetZkPath =  core.getResourceLoader() instanceof ZkSolrResourceLoader ?  ((ZkSolrResourceLoader)core.getResourceLoader()).getConfigSetZkPath() : null;\n\n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.close();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd, configSetZkPath);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    name = checkDefault(name);\n\n    // check for core-init errors first\n    CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n    if (loadFailure != null) {\n      // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n      // which we may not be able to do because of the init error.  So we just go with what we\n      // can glean from the CoreDescriptor - datadir and instancedir\n      SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    String configSetZkPath =  core.getResourceLoader() instanceof ZkSolrResourceLoader ?  ((ZkSolrResourceLoader)core.getResourceLoader()).getConfigSetZkPath() : null;\n\n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.close();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd, configSetZkPath);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54bb8da55080e4569804e0661b83a3c72cbd8d4d","date":1429691126,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    // check for core-init errors first\n    CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n    if (loadFailure != null) {\n      // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n      // which we may not be able to do because of the init error.  So we just go with what we\n      // can glean from the CoreDescriptor - datadir and instancedir\n      SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    String configSetZkPath =  core.getResourceLoader() instanceof ZkSolrResourceLoader ?  ((ZkSolrResourceLoader)core.getResourceLoader()).getConfigSetZkPath() : null;\n\n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.close();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    // check for core-init errors first\n    CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n    if (loadFailure != null) {\n      // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n      // which we may not be able to do because of the init error.  So we just go with what we\n      // can glean from the CoreDescriptor - datadir and instancedir\n      SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    String configSetZkPath =  core.getResourceLoader() instanceof ZkSolrResourceLoader ?  ((ZkSolrResourceLoader)core.getResourceLoader()).getConfigSetZkPath() : null;\n\n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.close();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd, configSetZkPath);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"00e1c8e1340d9e31d2c6bee5f72d9040ce569049","date":1431584404,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    // check for core-init errors first\n    CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n    if (loadFailure != null) {\n      // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n      // which we may not be able to do because of the init error.  So we just go with what we\n      // can glean from the CoreDescriptor - datadir and instancedir\n      SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    \n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.close();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    // check for core-init errors first\n    CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n    if (loadFailure != null) {\n      // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n      // which we may not be able to do because of the init error.  So we just go with what we\n      // can glean from the CoreDescriptor - datadir and instancedir\n      SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    String configSetZkPath =  core.getResourceLoader() instanceof ZkSolrResourceLoader ?  ((ZkSolrResourceLoader)core.getResourceLoader()).getConfigSetZkPath() : null;\n\n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.close();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ca230c35a9895012bbcad3f191934e3d45a2825b","date":1436678935,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    \n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.close();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    // check for core-init errors first\n    CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n    if (loadFailure != null) {\n      // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n      // which we may not be able to do because of the init error.  So we just go with what we\n      // can glean from the CoreDescriptor - datadir and instancedir\n      SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    \n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.close();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","bugFix":["2d629ca62e3b8ab6e29a127aebe213163d490413"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"625b61328a0889d9b3d61cdcbfc490339f61096e","date":1452790491,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    \n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    \n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.close();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","bugFix":["2d629ca62e3b8ab6e29a127aebe213163d490413"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d1d231959c9d0545adc421b7a2fefa7db47300d8","date":1472269133,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      SolrException solrException = new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n      solrException.setMetadata(\"cause\", \"NonExistentCore\");\n      throw solrException;\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    \n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    \n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["092c3ae5fefa024f6d0c427be5f23dd3bfbdd20c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"092c3ae5fefa024f6d0c427be5f23dd3bfbdd20c","date":1472580862,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    \n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      SolrException solrException = new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n      solrException.setMetadata(\"cause\", \"NonExistentCore\");\n      throw solrException;\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    \n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","bugFix":["d1d231959c9d0545adc421b7a2fefa7db47300d8"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bc8f206328a706450934717bec7ccc22ad166fc0","date":1473142172,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    \n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      SolrException solrException = new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n      solrException.setMetadata(\"cause\", \"NonExistentCore\");\n      throw solrException;\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    \n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    \n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    \n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    \n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null)\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    \n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0265144286422ad99682a00904cc2536b79c8535","date":1482222684,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(SolrMetricManager.getRegistryName(SolrInfoMBean.Group.core, name));\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    \n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    \n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["a30bfa174128ad6cb3bcf568080886729e347fe9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","date":1482251961,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(SolrMetricManager.getRegistryName(SolrInfoMBean.Group.core, name));\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    \n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    \n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a30bfa174128ad6cb3bcf568080886729e347fe9","date":1485967817,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    \n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(SolrMetricManager.getRegistryName(SolrInfoMBean.Group.core, name));\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    \n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","bugFix":["0265144286422ad99682a00904cc2536b79c8535"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c3523a0ab04c3002eee3896c75ea5f10f388bcc","date":1485968422,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    \n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(SolrMetricManager.getRegistryName(SolrInfoMBean.Group.core, name));\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    \n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"729cb470f975115d4c60517b2cb7c42e37a7a2e1","date":1492041760,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    \n    core.unloadOnClose(cd, deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n    if (deleteInstanceDir) { // we aren't going to reload this if we delete the instance dir.\n      solrCores.removeCoreDescriptor(cd);\n    }\n  }\n\n","sourceOld":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    \n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    \n    core.unloadOnClose(cd, deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n    if (deleteInstanceDir) { // we aren't going to reload this if we delete the instance dir.\n      solrCores.removeCoreDescriptor(cd);\n    }\n  }\n\n","sourceOld":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    \n    core.unloadOnClose(deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61c45e99cf6676da48f19d7511c73712ad39402b","date":1495508331,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n      if (core.getCoreDescriptor().getCloudDescriptor().getReplicaType() == Replica.Type.PULL\n          || core.getCoreDescriptor().getCloudDescriptor().getReplicaType() == Replica.Type.TLOG) { \n        // Stop replication if this is part of a pull/tlog replica before closing the core\n        zkSys.getZkController().stopReplicationFromLeader(name);\n      }\n    }\n    \n    core.unloadOnClose(cd, deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n    if (deleteInstanceDir) { // we aren't going to reload this if we delete the instance dir.\n      solrCores.removeCoreDescriptor(cd);\n    }\n  }\n\n","sourceOld":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    \n    core.unloadOnClose(cd, deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n    if (deleteInstanceDir) { // we aren't going to reload this if we delete the instance dir.\n      solrCores.removeCoreDescriptor(cd);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a513b6a92751e54c76fb5447948c9e7d437163a7","date":1496136565,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n      if (core.getCoreDescriptor().getCloudDescriptor().getReplicaType() == Replica.Type.PULL\n          || core.getCoreDescriptor().getCloudDescriptor().getReplicaType() == Replica.Type.TLOG) {\n        // Stop replication if this is part of a pull/tlog replica before closing the core\n        zkSys.getZkController().stopReplicationFromLeader(name);\n      }\n    }\n    \n    core.unloadOnClose(cd, deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n    if (deleteInstanceDir) { // we aren't going to reload this if we delete the instance dir.\n      solrCores.removeCoreDescriptor(cd);\n    }\n  }\n\n","sourceOld":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n      if (core.getCoreDescriptor().getCloudDescriptor().getReplicaType() == Replica.Type.PULL\n          || core.getCoreDescriptor().getCloudDescriptor().getReplicaType() == Replica.Type.TLOG) { \n        // Stop replication if this is part of a pull/tlog replica before closing the core\n        zkSys.getZkController().stopReplicationFromLeader(name);\n      }\n    }\n    \n    core.unloadOnClose(cd, deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n    if (deleteInstanceDir) { // we aren't going to reload this if we delete the instance dir.\n      solrCores.removeCoreDescriptor(cd);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74aea047dff7f7c38a2d766827bd20d356f98c6a","date":1496721416,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n      if (core.getCoreDescriptor().getCloudDescriptor().getReplicaType() == Replica.Type.PULL\n          || core.getCoreDescriptor().getCloudDescriptor().getReplicaType() == Replica.Type.TLOG) {\n        // Stop replication if this is part of a pull/tlog replica before closing the core\n        zkSys.getZkController().stopReplicationFromLeader(name);\n      }\n    }\n    \n    core.unloadOnClose(cd, deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n    if (deleteInstanceDir) { // we aren't going to reload this if we delete the instance dir.\n      solrCores.removeCoreDescriptor(cd);\n    }\n  }\n\n","sourceOld":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n      if (core.getCoreDescriptor().getCloudDescriptor().getReplicaType() == Replica.Type.PULL\n          || core.getCoreDescriptor().getCloudDescriptor().getReplicaType() == Replica.Type.TLOG) { \n        // Stop replication if this is part of a pull/tlog replica before closing the core\n        zkSys.getZkController().stopReplicationFromLeader(name);\n      }\n    }\n    \n    core.unloadOnClose(cd, deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n    if (deleteInstanceDir) { // we aren't going to reload this if we delete the instance dir.\n      solrCores.removeCoreDescriptor(cd);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n      if (core.getCoreDescriptor().getCloudDescriptor().getReplicaType() == Replica.Type.PULL\n          || core.getCoreDescriptor().getCloudDescriptor().getReplicaType() == Replica.Type.TLOG) {\n        // Stop replication if this is part of a pull/tlog replica before closing the core\n        zkSys.getZkController().stopReplicationFromLeader(name);\n      }\n    }\n    \n    core.unloadOnClose(cd, deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n    if (deleteInstanceDir) { // we aren't going to reload this if we delete the instance dir.\n      solrCores.removeCoreDescriptor(cd);\n    }\n  }\n\n","sourceOld":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n    }\n    \n    core.unloadOnClose(cd, deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n    if (deleteInstanceDir) { // we aren't going to reload this if we delete the instance dir.\n      solrCores.removeCoreDescriptor(cd);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a946a349f268338bb6ef7cd87612926ae94e12f5","date":1497208405,"type":3,"author":"Erick","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n\n    solrCores.removeCoreDescriptor(cd);\n    coresLocator.delete(this, cd);\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n      if (cd.getCloudDescriptor().getReplicaType() == Replica.Type.PULL\n          || cd.getCloudDescriptor().getReplicaType() == Replica.Type.TLOG) {\n        // Stop replication if this is part of a pull/tlog replica before closing the core\n        zkSys.getZkController().stopReplicationFromLeader(name);\n      }\n    }\n    \n    core.unloadOnClose(cd, deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n      if (core.getCoreDescriptor().getCloudDescriptor().getReplicaType() == Replica.Type.PULL\n          || core.getCoreDescriptor().getCloudDescriptor().getReplicaType() == Replica.Type.TLOG) {\n        // Stop replication if this is part of a pull/tlog replica before closing the core\n        zkSys.getZkController().stopReplicationFromLeader(name);\n      }\n    }\n    \n    core.unloadOnClose(cd, deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n    if (deleteInstanceDir) { // we aren't going to reload this if we delete the instance dir.\n      solrCores.removeCoreDescriptor(cd);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n\n    solrCores.removeCoreDescriptor(cd);\n    coresLocator.delete(this, cd);\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n      if (cd.getCloudDescriptor().getReplicaType() == Replica.Type.PULL\n          || cd.getCloudDescriptor().getReplicaType() == Replica.Type.TLOG) {\n        // Stop replication if this is part of a pull/tlog replica before closing the core\n        zkSys.getZkController().stopReplicationFromLeader(name);\n      }\n    }\n    \n    core.unloadOnClose(cd, deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n      if (core.getCoreDescriptor().getCloudDescriptor().getReplicaType() == Replica.Type.PULL\n          || core.getCoreDescriptor().getCloudDescriptor().getReplicaType() == Replica.Type.TLOG) {\n        // Stop replication if this is part of a pull/tlog replica before closing the core\n        zkSys.getZkController().stopReplicationFromLeader(name);\n      }\n    }\n    \n    core.unloadOnClose(cd, deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n    if (deleteInstanceDir) { // we aren't going to reload this if we delete the instance dir.\n      solrCores.removeCoreDescriptor(cd);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7871f9c286dce2a9370bcf517a3e7d12e3bd9602","date":1498708934,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    \n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        // If last time around we didn't successfully load, make sure that all traces of the coreDescriptor are gone.\n        if (cd != null) {\n          solrCores.removeCoreDescriptor(cd);\n          coresLocator.delete(this, cd);\n        }\n        return;\n      }\n    }\n      \n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n\n    solrCores.removeCoreDescriptor(cd);\n    coresLocator.delete(this, cd);\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n      if (cd.getCloudDescriptor().getReplicaType() == Replica.Type.PULL\n          || cd.getCloudDescriptor().getReplicaType() == Replica.Type.TLOG) {\n        // Stop replication if this is part of a pull/tlog replica before closing the core\n        zkSys.getZkController().stopReplicationFromLeader(name);\n      }\n    }\n    \n    core.unloadOnClose(cd, deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n\n    solrCores.removeCoreDescriptor(cd);\n    coresLocator.delete(this, cd);\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n      if (cd.getCloudDescriptor().getReplicaType() == Replica.Type.PULL\n          || cd.getCloudDescriptor().getReplicaType() == Replica.Type.TLOG) {\n        // Stop replication if this is part of a pull/tlog replica before closing the core\n        zkSys.getZkController().stopReplicationFromLeader(name);\n      }\n    }\n    \n    core.unloadOnClose(cd, deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    \n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        // If last time around we didn't successfully load, make sure that all traces of the coreDescriptor are gone.\n        if (cd != null) {\n          solrCores.removeCoreDescriptor(cd);\n          coresLocator.delete(this, cd);\n        }\n        return;\n      }\n    }\n      \n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n\n    solrCores.removeCoreDescriptor(cd);\n    coresLocator.delete(this, cd);\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n      if (cd.getCloudDescriptor().getReplicaType() == Replica.Type.PULL\n          || cd.getCloudDescriptor().getReplicaType() == Replica.Type.TLOG) {\n        // Stop replication if this is part of a pull/tlog replica before closing the core\n        zkSys.getZkController().stopReplicationFromLeader(name);\n      }\n    }\n    \n    core.unloadOnClose(cd, deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n    coresLocator.delete(this, cd);\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n      if (core.getCoreDescriptor().getCloudDescriptor().getReplicaType() == Replica.Type.PULL\n          || core.getCoreDescriptor().getCloudDescriptor().getReplicaType() == Replica.Type.TLOG) { \n        // Stop replication if this is part of a pull/tlog replica before closing the core\n        zkSys.getZkController().stopReplicationFromLeader(name);\n      }\n    }\n    \n    core.unloadOnClose(cd, deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n    if (deleteInstanceDir) { // we aren't going to reload this if we delete the instance dir.\n      solrCores.removeCoreDescriptor(cd);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30c8e5574b55d57947e989443dfde611646530ee","date":1499131153,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    \n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        // If last time around we didn't successfully load, make sure that all traces of the coreDescriptor are gone.\n        if (cd != null) {\n          solrCores.removeCoreDescriptor(cd);\n          coresLocator.delete(this, cd);\n        }\n        return;\n      }\n    }\n      \n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n\n    solrCores.removeCoreDescriptor(cd);\n    coresLocator.delete(this, cd);\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n      if (cd.getCloudDescriptor().getReplicaType() == Replica.Type.PULL\n          || cd.getCloudDescriptor().getReplicaType() == Replica.Type.TLOG) {\n        // Stop replication if this is part of a pull/tlog replica before closing the core\n        zkSys.getZkController().stopReplicationFromLeader(name);\n      }\n    }\n    \n    core.unloadOnClose(cd, deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        return;\n      }\n    }\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n\n    solrCores.removeCoreDescriptor(cd);\n    coresLocator.delete(this, cd);\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n      if (cd.getCloudDescriptor().getReplicaType() == Replica.Type.PULL\n          || cd.getCloudDescriptor().getReplicaType() == Replica.Type.TLOG) {\n        // Stop replication if this is part of a pull/tlog replica before closing the core\n        zkSys.getZkController().stopReplicationFromLeader(name);\n      }\n    }\n    \n    core.unloadOnClose(cd, deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac","date":1503580177,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    \n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        // If last time around we didn't successfully load, make sure that all traces of the coreDescriptor are gone.\n        if (cd != null) {\n          solrCores.removeCoreDescriptor(cd);\n          coresLocator.delete(this, cd);\n        }\n        return;\n      }\n    }\n      \n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n\n    solrCores.removeCoreDescriptor(cd);\n    coresLocator.delete(this, cd);\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n      if (cd.getCloudDescriptor().getReplicaType() == Replica.Type.PULL\n          || cd.getCloudDescriptor().getReplicaType() == Replica.Type.TLOG) {\n        // Stop replication if this is part of a pull/tlog replica before closing the core\n        zkSys.getZkController().stopReplicationFromLeader(name);\n      }\n    }\n    \n    core.unloadOnClose(cd, deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    \n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        // If last time around we didn't successfully load, make sure that all traces of the coreDescriptor are gone.\n        if (cd != null) {\n          solrCores.removeCoreDescriptor(cd);\n          coresLocator.delete(this, cd);\n        }\n        return;\n      }\n    }\n      \n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n\n    solrCores.removeCoreDescriptor(cd);\n    coresLocator.delete(this, cd);\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n      if (cd.getCloudDescriptor().getReplicaType() == Replica.Type.PULL\n          || cd.getCloudDescriptor().getReplicaType() == Replica.Type.TLOG) {\n        // Stop replication if this is part of a pull/tlog replica before closing the core\n        zkSys.getZkController().stopReplicationFromLeader(name);\n      }\n    }\n    \n    core.unloadOnClose(cd, deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b869898f50ca80263bac2e3ae0949f7700e5c977","date":1503580229,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    \n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        // If last time around we didn't successfully load, make sure that all traces of the coreDescriptor are gone.\n        if (cd != null) {\n          solrCores.removeCoreDescriptor(cd);\n          coresLocator.delete(this, cd);\n        }\n        return;\n      }\n    }\n      \n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n\n    solrCores.removeCoreDescriptor(cd);\n    coresLocator.delete(this, cd);\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n      if (cd.getCloudDescriptor().getReplicaType() == Replica.Type.PULL\n          || cd.getCloudDescriptor().getReplicaType() == Replica.Type.TLOG) {\n        // Stop replication if this is part of a pull/tlog replica before closing the core\n        zkSys.getZkController().stopReplicationFromLeader(name);\n      }\n    }\n    \n    core.unloadOnClose(cd, deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    \n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        // If last time around we didn't successfully load, make sure that all traces of the coreDescriptor are gone.\n        if (cd != null) {\n          solrCores.removeCoreDescriptor(cd);\n          coresLocator.delete(this, cd);\n        }\n        return;\n      }\n    }\n      \n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n\n    solrCores.removeCoreDescriptor(cd);\n    coresLocator.delete(this, cd);\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n      if (cd.getCloudDescriptor().getReplicaType() == Replica.Type.PULL\n          || cd.getCloudDescriptor().getReplicaType() == Replica.Type.TLOG) {\n        // Stop replication if this is part of a pull/tlog replica before closing the core\n        zkSys.getZkController().stopReplicationFromLeader(name);\n      }\n    }\n    \n    core.unloadOnClose(cd, deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85212dad4ed576c7f7e6c165ee19e597b7b4efc8","date":1507997740,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    \n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        // If last time around we didn't successfully load, make sure that all traces of the coreDescriptor are gone.\n        if (cd != null) {\n          solrCores.removeCoreDescriptor(cd);\n          coresLocator.delete(this, cd);\n        }\n        return;\n      }\n    }\n      \n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n\n    solrCores.removeCoreDescriptor(cd);\n    coresLocator.delete(this, cd);\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n      if (cd.getCloudDescriptor().getReplicaType() == Replica.Type.PULL\n          || cd.getCloudDescriptor().getReplicaType() == Replica.Type.TLOG) {\n        // Stop replication if this is part of a pull/tlog replica before closing the core\n        zkSys.getZkController().stopReplicationFromLeader(name);\n      }\n    }\n    \n    core.unloadOnClose(cd, deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    \n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        // If last time around we didn't successfully load, make sure that all traces of the coreDescriptor are gone.\n        if (cd != null) {\n          solrCores.removeCoreDescriptor(cd);\n          coresLocator.delete(this, cd);\n        }\n        return;\n      }\n    }\n      \n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n\n    solrCores.removeCoreDescriptor(cd);\n    coresLocator.delete(this, cd);\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n      if (cd.getCloudDescriptor().getReplicaType() == Replica.Type.PULL\n          || cd.getCloudDescriptor().getReplicaType() == Replica.Type.TLOG) {\n        // Stop replication if this is part of a pull/tlog replica before closing the core\n        zkSys.getZkController().stopReplicationFromLeader(name);\n      }\n    }\n    \n    core.unloadOnClose(cd, deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b627755385655c7cd3fb296f17593658805cf4d5","date":1552455143,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        // If last time around we didn't successfully load, make sure that all traces of the coreDescriptor are gone.\n        if (cd != null) {\n          solrCores.removeCoreDescriptor(cd);\n          coresLocator.delete(this, cd);\n        }\n        return;\n      }\n    }\n\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n\n    solrCores.removeCoreDescriptor(cd);\n    coresLocator.delete(this, cd);\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n      if (cd.getCloudDescriptor().getReplicaType() == Replica.Type.PULL\n          || cd.getCloudDescriptor().getReplicaType() == Replica.Type.TLOG) {\n        // Stop replication if this is part of a pull/tlog replica before closing the core\n        zkSys.getZkController().stopReplicationFromLeader(name);\n      }\n    }\n\n    core.unloadOnClose(cd, deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n    \n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        // If last time around we didn't successfully load, make sure that all traces of the coreDescriptor are gone.\n        if (cd != null) {\n          solrCores.removeCoreDescriptor(cd);\n          coresLocator.delete(this, cd);\n        }\n        return;\n      }\n    }\n      \n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n\n    solrCores.removeCoreDescriptor(cd);\n    coresLocator.delete(this, cd);\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n      if (cd.getCloudDescriptor().getReplicaType() == Replica.Type.PULL\n          || cd.getCloudDescriptor().getReplicaType() == Replica.Type.TLOG) {\n        // Stop replication if this is part of a pull/tlog replica before closing the core\n        zkSys.getZkController().stopReplicationFromLeader(name);\n      }\n    }\n    \n    core.unloadOnClose(cd, deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2668c99990e4c94a78bac005aa682b7c5986d23a","date":1561446137,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreContainer#unload(String,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name              the name of the core to unload\n   * @param deleteIndexDir    if true, delete the core's index on close\n   * @param deleteDataDir     if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        // If last time around we didn't successfully load, make sure that all traces of the coreDescriptor are gone.\n        if (cd != null) {\n          solrCores.removeCoreDescriptor(cd);\n          coresLocator.delete(this, cd);\n        }\n        return;\n      }\n    }\n\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n\n    solrCores.removeCoreDescriptor(cd);\n    coresLocator.delete(this, cd);\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n      if (cd.getCloudDescriptor().getReplicaType() == Replica.Type.PULL\n          || cd.getCloudDescriptor().getReplicaType() == Replica.Type.TLOG) {\n        // Stop replication if this is part of a pull/tlog replica before closing the core\n        zkSys.getZkController().stopReplicationFromLeader(name);\n      }\n    }\n\n    core.unloadOnClose(cd, deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Unload a core from this container, optionally removing the core's data and configuration\n   *\n   * @param name the name of the core to unload\n   * @param deleteIndexDir if true, delete the core's index on close\n   * @param deleteDataDir if true, delete the core's data directory on close\n   * @param deleteInstanceDir if true, delete the core's instance directory on close\n   */\n  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n\n    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n\n    if (name != null) {\n      // check for core-init errors first\n      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n      if (loadFailure != null) {\n        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n        // which we may not be able to do because of the init error.  So we just go with what we\n        // can glean from the CoreDescriptor - datadir and instancedir\n        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n        // If last time around we didn't successfully load, make sure that all traces of the coreDescriptor are gone.\n        if (cd != null) {\n          solrCores.removeCoreDescriptor(cd);\n          coresLocator.delete(this, cd);\n        }\n        return;\n      }\n    }\n\n    if (cd == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n    }\n\n    boolean close = solrCores.isLoadedNotPendingClose(name);\n    SolrCore core = solrCores.remove(name);\n\n    solrCores.removeCoreDescriptor(cd);\n    coresLocator.delete(this, cd);\n    if (core == null) {\n      // transient core\n      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n      return;\n    }\n\n    // delete metrics specific to this core\n    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n\n    if (zkSys.getZkController() != null) {\n      // cancel recovery in cloud mode\n      core.getSolrCoreState().cancelRecovery();\n      if (cd.getCloudDescriptor().getReplicaType() == Replica.Type.PULL\n          || cd.getCloudDescriptor().getReplicaType() == Replica.Type.TLOG) {\n        // Stop replication if this is part of a pull/tlog replica before closing the core\n        zkSys.getZkController().stopReplicationFromLeader(name);\n      }\n    }\n\n    core.unloadOnClose(cd, deleteIndexDir, deleteDataDir, deleteInstanceDir);\n    if (close)\n      core.closeAndWait();\n\n    if (zkSys.getZkController() != null) {\n      try {\n        zkSys.getZkController().unregister(name, cd);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n      } catch (KeeperException e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["a30bfa174128ad6cb3bcf568080886729e347fe9"],"17778d9c1f3a8a67383edebf24754bf30a5120f8":["531fe719c7218235a679452eb3d137bfd8fc6af1"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":["5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","a30bfa174128ad6cb3bcf568080886729e347fe9"],"fd44bec977a26a118d9e809e2de6f7edb5ca0f39":["17778d9c1f3a8a67383edebf24754bf30a5120f8"],"bc8f206328a706450934717bec7ccc22ad166fc0":["d1d231959c9d0545adc421b7a2fefa7db47300d8","092c3ae5fefa024f6d0c427be5f23dd3bfbdd20c"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","74aea047dff7f7c38a2d766827bd20d356f98c6a"],"a30bfa174128ad6cb3bcf568080886729e347fe9":["0265144286422ad99682a00904cc2536b79c8535"],"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0265144286422ad99682a00904cc2536b79c8535"],"2668c99990e4c94a78bac005aa682b7c5986d23a":["b627755385655c7cd3fb296f17593658805cf4d5"],"a946a349f268338bb6ef7cd87612926ae94e12f5":["74aea047dff7f7c38a2d766827bd20d356f98c6a"],"74aea047dff7f7c38a2d766827bd20d356f98c6a":["61c45e99cf6676da48f19d7511c73712ad39402b","a513b6a92751e54c76fb5447948c9e7d437163a7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["625b61328a0889d9b3d61cdcbfc490339f61096e","092c3ae5fefa024f6d0c427be5f23dd3bfbdd20c"],"ca230c35a9895012bbcad3f191934e3d45a2825b":["00e1c8e1340d9e31d2c6bee5f72d9040ce569049"],"625b61328a0889d9b3d61cdcbfc490339f61096e":["ca230c35a9895012bbcad3f191934e3d45a2825b"],"d1d231959c9d0545adc421b7a2fefa7db47300d8":["625b61328a0889d9b3d61cdcbfc490339f61096e"],"531fe719c7218235a679452eb3d137bfd8fc6af1":["2d629ca62e3b8ab6e29a127aebe213163d490413"],"61c45e99cf6676da48f19d7511c73712ad39402b":["729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"54bb8da55080e4569804e0661b83a3c72cbd8d4d":["fd44bec977a26a118d9e809e2de6f7edb5ca0f39"],"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac":["30c8e5574b55d57947e989443dfde611646530ee"],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["28288370235ed02234a64753cdbf0c6ec096304a"],"7871f9c286dce2a9370bcf517a3e7d12e3bd9602":["a946a349f268338bb6ef7cd87612926ae94e12f5"],"30c8e5574b55d57947e989443dfde611646530ee":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","28288370235ed02234a64753cdbf0c6ec096304a"],"b869898f50ca80263bac2e3ae0949f7700e5c977":["c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["a30bfa174128ad6cb3bcf568080886729e347fe9"],"28288370235ed02234a64753cdbf0c6ec096304a":["61c45e99cf6676da48f19d7511c73712ad39402b","7871f9c286dce2a9370bcf517a3e7d12e3bd9602"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["625b61328a0889d9b3d61cdcbfc490339f61096e","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"092c3ae5fefa024f6d0c427be5f23dd3bfbdd20c":["d1d231959c9d0545adc421b7a2fefa7db47300d8"],"0265144286422ad99682a00904cc2536b79c8535":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a513b6a92751e54c76fb5447948c9e7d437163a7":["61c45e99cf6676da48f19d7511c73712ad39402b"],"2d629ca62e3b8ab6e29a127aebe213163d490413":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b627755385655c7cd3fb296f17593658805cf4d5":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["e9017cf144952056066919f1ebc7897ff9bd71b1","a946a349f268338bb6ef7cd87612926ae94e12f5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2668c99990e4c94a78bac005aa682b7c5986d23a"],"00e1c8e1340d9e31d2c6bee5f72d9040ce569049":["54bb8da55080e4569804e0661b83a3c72cbd8d4d"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"17778d9c1f3a8a67383edebf24754bf30a5120f8":["fd44bec977a26a118d9e809e2de6f7edb5ca0f39"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":[],"fd44bec977a26a118d9e809e2de6f7edb5ca0f39":["54bb8da55080e4569804e0661b83a3c72cbd8d4d"],"bc8f206328a706450934717bec7ccc22ad166fc0":[],"e9017cf144952056066919f1ebc7897ff9bd71b1":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"a30bfa174128ad6cb3bcf568080886729e347fe9":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","7c3523a0ab04c3002eee3896c75ea5f10f388bcc","729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc"],"74aea047dff7f7c38a2d766827bd20d356f98c6a":["e9017cf144952056066919f1ebc7897ff9bd71b1","a946a349f268338bb6ef7cd87612926ae94e12f5"],"2668c99990e4c94a78bac005aa682b7c5986d23a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a946a349f268338bb6ef7cd87612926ae94e12f5":["7871f9c286dce2a9370bcf517a3e7d12e3bd9602","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2d629ca62e3b8ab6e29a127aebe213163d490413"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0265144286422ad99682a00904cc2536b79c8535"],"ca230c35a9895012bbcad3f191934e3d45a2825b":["625b61328a0889d9b3d61cdcbfc490339f61096e"],"625b61328a0889d9b3d61cdcbfc490339f61096e":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","d1d231959c9d0545adc421b7a2fefa7db47300d8","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"d1d231959c9d0545adc421b7a2fefa7db47300d8":["bc8f206328a706450934717bec7ccc22ad166fc0","092c3ae5fefa024f6d0c427be5f23dd3bfbdd20c"],"531fe719c7218235a679452eb3d137bfd8fc6af1":["17778d9c1f3a8a67383edebf24754bf30a5120f8"],"61c45e99cf6676da48f19d7511c73712ad39402b":["74aea047dff7f7c38a2d766827bd20d356f98c6a","28288370235ed02234a64753cdbf0c6ec096304a","a513b6a92751e54c76fb5447948c9e7d437163a7"],"54bb8da55080e4569804e0661b83a3c72cbd8d4d":["00e1c8e1340d9e31d2c6bee5f72d9040ce569049"],"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac":["b869898f50ca80263bac2e3ae0949f7700e5c977"],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["b627755385655c7cd3fb296f17593658805cf4d5"],"7871f9c286dce2a9370bcf517a3e7d12e3bd9602":["28288370235ed02234a64753cdbf0c6ec096304a"],"30c8e5574b55d57947e989443dfde611646530ee":["c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac"],"b869898f50ca80263bac2e3ae0949f7700e5c977":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["61c45e99cf6676da48f19d7511c73712ad39402b"],"28288370235ed02234a64753cdbf0c6ec096304a":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8","30c8e5574b55d57947e989443dfde611646530ee"],"092c3ae5fefa024f6d0c427be5f23dd3bfbdd20c":["bc8f206328a706450934717bec7ccc22ad166fc0","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"0265144286422ad99682a00904cc2536b79c8535":["a30bfa174128ad6cb3bcf568080886729e347fe9","5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf"],"a513b6a92751e54c76fb5447948c9e7d437163a7":["74aea047dff7f7c38a2d766827bd20d356f98c6a"],"2d629ca62e3b8ab6e29a127aebe213163d490413":["531fe719c7218235a679452eb3d137bfd8fc6af1"],"b627755385655c7cd3fb296f17593658805cf4d5":["2668c99990e4c94a78bac005aa682b7c5986d23a"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["30c8e5574b55d57947e989443dfde611646530ee"],"00e1c8e1340d9e31d2c6bee5f72d9040ce569049":["ca230c35a9895012bbcad3f191934e3d45a2825b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc","bc8f206328a706450934717bec7ccc22ad166fc0","b869898f50ca80263bac2e3ae0949f7700e5c977","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}