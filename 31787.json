{"path":"solr/core/src/java/org/apache/solr/update/processor/DocBasedVersionConstraintsProcessorFactory.DocBasedVersionConstraintsProcessor#isVersionNewEnough(BytesRef,Object).mjava","commits":[{"id":"45a4348f3ba3bf4ff6cbb4169fe5bf7d28288cd0","date":1383246815,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocBasedVersionConstraintsProcessorFactory.DocBasedVersionConstraintsProcessor#isVersionNewEnough(BytesRef,Object).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Returns true if the specified new version value is greater the the one\n     * already known to exist for the document, or the document does not already\n     * exist.\n     * Returns false if the specified new version is not high enough but the\n     * processor has been configured with ignoreOldUpdates=true\n     * Throws a SolrException if the version is not high enough and\n     * ignoreOldUpdates=false\n     */\n    private boolean isVersionNewEnough(BytesRef indexedDocId,\n                                       Object newUserVersion) throws IOException {\n      assert null != indexedDocId;\n      assert null != newUserVersion;\n\n      oldSolrVersion = -1;\n\n      newUserVersion = convertFieldValueUsingType(userVersionField, newUserVersion);\n      Object oldUserVersion = null;\n      SolrInputDocument oldDoc = null;\n\n      if (useFieldCache) {\n        oldDoc = RealTimeGetComponent.getInputDocumentFromTlog(core, indexedDocId);\n        if (oldDoc == RealTimeGetComponent.DELETED) {\n          return true;\n        }\n        if (oldDoc == null) {\n          // need to look up in index now...\n          RefCounted<SolrIndexSearcher> newestSearcher = core.getRealtimeSearcher();\n          try {\n            SolrIndexSearcher searcher = newestSearcher.get();\n            long lookup = searcher.lookupId(indexedDocId);\n            if (lookup < 0) {\n              // doc not in index either...\n              return true;\n            }\n\n            ValueSource vs = solrVersionField.getType().getValueSource(solrVersionField, null);\n            Map context = ValueSource.newContext(searcher);\n            vs.createWeight(context, searcher);\n            FunctionValues fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int)(lookup>>32)));\n            oldSolrVersion = fv.longVal((int)lookup);\n\n            vs = userVersionField.getType().getValueSource(userVersionField, null);\n            context = ValueSource.newContext(searcher);\n            vs.createWeight(context, searcher);\n            fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int)(lookup>>32)));\n            oldUserVersion = fv.objectVal((int)lookup);\n\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error reading version from index\", e);\n          } finally {\n            if (newestSearcher != null) {\n              newestSearcher.decref();\n            }\n          }\n        }\n      } else {\n        // stored fields only...\n\n        oldDoc = RealTimeGetComponent.getInputDocument(core, indexedDocId);\n\n        if (null == oldDoc) {\n          return true;\n        }\n      }\n\n\n      if (oldDoc != null) {\n        oldUserVersion = oldDoc.getFieldValue(versionFieldName);\n        // Make the FieldType resolve any conversion we need.\n        oldUserVersion = convertFieldValueUsingType(userVersionField, oldUserVersion);\n\n        Object o = oldDoc.getFieldValue(solrVersionField.getName());\n        if (o == null) {\n          throw new SolrException(SERVER_ERROR, \"No _version_ for document \"+ oldDoc);\n        }\n        oldSolrVersion = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      }\n\n\n      if ( null == oldUserVersion) {\n        // could happen if they turn this feature on after building an index\n        // w/o the versionField\n        throw new SolrException(SERVER_ERROR,\n            \"Doc exists in index, but has null versionField: \"\n                + versionFieldName);\n      }\n\n\n      if (! (oldUserVersion instanceof Comparable && newUserVersion instanceof Comparable) ) {\n        throw new SolrException(BAD_REQUEST,\n            \"old version and new version are not comparable: \" +\n                oldUserVersion.getClass()+\" vs \"+newUserVersion.getClass());\n      }\n\n      try {\n        if (0 < ((Comparable)newUserVersion).compareTo((Comparable) oldUserVersion)) {\n          return true;\n        }\n        if (ignoreOldUpdates) {\n\n          return false;\n        } else {\n          throw new SolrException(CONFLICT,\n              \"user version is not high enough: \" + newUserVersion);\n        }\n      } catch (ClassCastException e) {\n        throw new SolrException(BAD_REQUEST,\n            \"old version and new version are not comparable: \" +\n                oldUserVersion.getClass()+\" vs \"+newUserVersion.getClass() +\n                \": \" + e.getMessage(), e);\n\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9a094a3cf22dfb1f022ba368c1605239343aa873","date":1384012589,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocBasedVersionConstraintsProcessorFactory.DocBasedVersionConstraintsProcessor#isVersionNewEnough(BytesRef,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocBasedVersionConstraintsProcessorFactory.DocBasedVersionConstraintsProcessor#isVersionNewEnough(BytesRef,Object).mjava","sourceNew":"    /**\n     * Returns true if the specified new version value is greater the the one\n     * already known to exist for the document, or the document does not already\n     * exist.\n     * Returns false if the specified new version is not high enough but the\n     * processor has been configured with ignoreOldUpdates=true\n     * Throws a SolrException if the version is not high enough and\n     * ignoreOldUpdates=false\n     */\n    private boolean isVersionNewEnough(BytesRef indexedDocId,\n                                       Object newUserVersion) throws IOException {\n      assert null != indexedDocId;\n      assert null != newUserVersion;\n\n      oldSolrVersion = -1;\n      // log.info(\"!!!!!!!!! isVersionNewEnough being called for \" + indexedDocId.utf8ToString() + \" newVersion=\" + newUserVersion);\n      newUserVersion = convertFieldValueUsingType(userVersionField, newUserVersion);\n      Object oldUserVersion = null;\n      SolrInputDocument oldDoc = null;\n\n      if (useFieldCache) {\n        oldDoc = RealTimeGetComponent.getInputDocumentFromTlog(core, indexedDocId);\n        if (oldDoc == RealTimeGetComponent.DELETED) {\n          return true;\n        }\n        if (oldDoc == null) {\n          // need to look up in index now...\n          RefCounted<SolrIndexSearcher> newestSearcher = core.getRealtimeSearcher();\n          try {\n            SolrIndexSearcher searcher = newestSearcher.get();\n            long lookup = searcher.lookupId(indexedDocId);\n            if (lookup < 0) {\n              // doc not in index either...\n              return true;\n            }\n\n            ValueSource vs = solrVersionField.getType().getValueSource(solrVersionField, null);\n            Map context = ValueSource.newContext(searcher);\n            vs.createWeight(context, searcher);\n            FunctionValues fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int)(lookup>>32)));\n            oldSolrVersion = fv.longVal((int)lookup);\n\n            vs = userVersionField.getType().getValueSource(userVersionField, null);\n            context = ValueSource.newContext(searcher);\n            vs.createWeight(context, searcher);\n            fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int)(lookup>>32)));\n            oldUserVersion = fv.objectVal((int)lookup);\n\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error reading version from index\", e);\n          } finally {\n            if (newestSearcher != null) {\n              newestSearcher.decref();\n            }\n          }\n        }\n      } else {\n        // stored fields only...\n\n        oldDoc = RealTimeGetComponent.getInputDocument(core, indexedDocId);\n\n        if (null == oldDoc) {\n          // log.info(\"VERSION no doc found, returning true\");\n          return true;\n        }\n      }\n\n\n      if (oldDoc != null) {\n        oldUserVersion = oldDoc.getFieldValue(versionFieldName);\n        // Make the FieldType resolve any conversion we need.\n        oldUserVersion = convertFieldValueUsingType(userVersionField, oldUserVersion);\n\n        Object o = oldDoc.getFieldValue(solrVersionField.getName());\n        if (o == null) {\n          throw new SolrException(SERVER_ERROR, \"No _version_ for document \"+ oldDoc);\n        }\n        oldSolrVersion = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      }\n\n      // log.info(\"VERSION old=\" + oldUserVersion + \" new=\" +newUserVersion );\n\n      if ( null == oldUserVersion) {\n        // could happen if they turn this feature on after building an index\n        // w/o the versionField\n        throw new SolrException(SERVER_ERROR,\n            \"Doc exists in index, but has null versionField: \"\n                + versionFieldName);\n      }\n\n\n      if (! (oldUserVersion instanceof Comparable && newUserVersion instanceof Comparable) ) {\n        throw new SolrException(BAD_REQUEST,\n            \"old version and new version are not comparable: \" +\n                oldUserVersion.getClass()+\" vs \"+newUserVersion.getClass());\n      }\n\n      try {\n        if (0 < ((Comparable)newUserVersion).compareTo((Comparable) oldUserVersion)) {\n          // log.info(\"VERSION returning true (proceed with update)\" );\n          return true;\n        }\n        if (ignoreOldUpdates) {\n          if (log.isDebugEnabled()) {\n            log.debug(\"Dropping update since user version is not high enough: \" + newUserVersion + \"; old user version=\" + oldUserVersion);\n          }\n          // log.info(\"VERSION returning false (dropping update)\" );\n          return false;\n        } else {\n          // log.info(\"VERSION will throw conflict\" );\n          throw new SolrException(CONFLICT,\n              \"user version is not high enough: \" + newUserVersion);\n        }\n      } catch (ClassCastException e) {\n        throw new SolrException(BAD_REQUEST,\n            \"old version and new version are not comparable: \" +\n                oldUserVersion.getClass()+\" vs \"+newUserVersion.getClass() +\n                \": \" + e.getMessage(), e);\n\n      }\n    }\n\n","sourceOld":"    /**\n     * Returns true if the specified new version value is greater the the one\n     * already known to exist for the document, or the document does not already\n     * exist.\n     * Returns false if the specified new version is not high enough but the\n     * processor has been configured with ignoreOldUpdates=true\n     * Throws a SolrException if the version is not high enough and\n     * ignoreOldUpdates=false\n     */\n    private boolean isVersionNewEnough(BytesRef indexedDocId,\n                                       Object newUserVersion) throws IOException {\n      assert null != indexedDocId;\n      assert null != newUserVersion;\n\n      oldSolrVersion = -1;\n\n      newUserVersion = convertFieldValueUsingType(userVersionField, newUserVersion);\n      Object oldUserVersion = null;\n      SolrInputDocument oldDoc = null;\n\n      if (useFieldCache) {\n        oldDoc = RealTimeGetComponent.getInputDocumentFromTlog(core, indexedDocId);\n        if (oldDoc == RealTimeGetComponent.DELETED) {\n          return true;\n        }\n        if (oldDoc == null) {\n          // need to look up in index now...\n          RefCounted<SolrIndexSearcher> newestSearcher = core.getRealtimeSearcher();\n          try {\n            SolrIndexSearcher searcher = newestSearcher.get();\n            long lookup = searcher.lookupId(indexedDocId);\n            if (lookup < 0) {\n              // doc not in index either...\n              return true;\n            }\n\n            ValueSource vs = solrVersionField.getType().getValueSource(solrVersionField, null);\n            Map context = ValueSource.newContext(searcher);\n            vs.createWeight(context, searcher);\n            FunctionValues fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int)(lookup>>32)));\n            oldSolrVersion = fv.longVal((int)lookup);\n\n            vs = userVersionField.getType().getValueSource(userVersionField, null);\n            context = ValueSource.newContext(searcher);\n            vs.createWeight(context, searcher);\n            fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int)(lookup>>32)));\n            oldUserVersion = fv.objectVal((int)lookup);\n\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error reading version from index\", e);\n          } finally {\n            if (newestSearcher != null) {\n              newestSearcher.decref();\n            }\n          }\n        }\n      } else {\n        // stored fields only...\n\n        oldDoc = RealTimeGetComponent.getInputDocument(core, indexedDocId);\n\n        if (null == oldDoc) {\n          return true;\n        }\n      }\n\n\n      if (oldDoc != null) {\n        oldUserVersion = oldDoc.getFieldValue(versionFieldName);\n        // Make the FieldType resolve any conversion we need.\n        oldUserVersion = convertFieldValueUsingType(userVersionField, oldUserVersion);\n\n        Object o = oldDoc.getFieldValue(solrVersionField.getName());\n        if (o == null) {\n          throw new SolrException(SERVER_ERROR, \"No _version_ for document \"+ oldDoc);\n        }\n        oldSolrVersion = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      }\n\n\n      if ( null == oldUserVersion) {\n        // could happen if they turn this feature on after building an index\n        // w/o the versionField\n        throw new SolrException(SERVER_ERROR,\n            \"Doc exists in index, but has null versionField: \"\n                + versionFieldName);\n      }\n\n\n      if (! (oldUserVersion instanceof Comparable && newUserVersion instanceof Comparable) ) {\n        throw new SolrException(BAD_REQUEST,\n            \"old version and new version are not comparable: \" +\n                oldUserVersion.getClass()+\" vs \"+newUserVersion.getClass());\n      }\n\n      try {\n        if (0 < ((Comparable)newUserVersion).compareTo((Comparable) oldUserVersion)) {\n          return true;\n        }\n        if (ignoreOldUpdates) {\n\n          return false;\n        } else {\n          throw new SolrException(CONFLICT,\n              \"user version is not high enough: \" + newUserVersion);\n        }\n      } catch (ClassCastException e) {\n        throw new SolrException(BAD_REQUEST,\n            \"old version and new version are not comparable: \" +\n                oldUserVersion.getClass()+\" vs \"+newUserVersion.getClass() +\n                \": \" + e.getMessage(), e);\n\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f8973f28b29873ff0d7a016e562c9036ae649a9","date":1428098193,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocBasedVersionConstraintsProcessorFactory.DocBasedVersionConstraintsProcessor#isVersionNewEnough(BytesRef,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocBasedVersionConstraintsProcessorFactory.DocBasedVersionConstraintsProcessor#isVersionNewEnough(BytesRef,Object).mjava","sourceNew":"    /**\n     * Returns true if the specified new version value is greater the the one\n     * already known to exist for the document, or the document does not already\n     * exist.\n     * Returns false if the specified new version is not high enough but the\n     * processor has been configured with ignoreOldUpdates=true\n     * Throws a SolrException if the version is not high enough and\n     * ignoreOldUpdates=false\n     */\n    private boolean isVersionNewEnough(BytesRef indexedDocId,\n                                       Object newUserVersion) throws IOException {\n      assert null != indexedDocId;\n      assert null != newUserVersion;\n\n      oldSolrVersion = -1;\n      // log.info(\"!!!!!!!!! isVersionNewEnough being called for \" + indexedDocId.utf8ToString() + \" newVersion=\" + newUserVersion);\n      newUserVersion = convertFieldValueUsingType(userVersionField, newUserVersion);\n      Object oldUserVersion = null;\n      SolrInputDocument oldDoc = null;\n\n      if (useFieldCache) {\n        oldDoc = RealTimeGetComponent.getInputDocumentFromTlog(core, indexedDocId);\n        if (oldDoc == RealTimeGetComponent.DELETED) {\n          return true;\n        }\n        if (oldDoc == null) {\n          // need to look up in index now...\n          RefCounted<SolrIndexSearcher> newestSearcher = core.getRealtimeSearcher();\n          try {\n            SolrIndexSearcher searcher = newestSearcher.get();\n            long lookup = searcher.lookupId(indexedDocId);\n            if (lookup < 0) {\n              // doc not in index either...\n              return true;\n            }\n\n            ValueSource vs = solrVersionField.getType().getValueSource(solrVersionField, null);\n            Map context = ValueSource.newContext(searcher);\n            vs.createWeight(context, searcher);\n            FunctionValues fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int)(lookup>>32)));\n            oldSolrVersion = fv.longVal((int)lookup);\n\n            vs = userVersionField.getType().getValueSource(userVersionField, null);\n            context = ValueSource.newContext(searcher);\n            vs.createWeight(context, searcher);\n            fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int)(lookup>>32)));\n            oldUserVersion = fv.objectVal((int)lookup);\n\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error reading version from index\", e);\n          } finally {\n            if (newestSearcher != null) {\n              newestSearcher.decref();\n            }\n          }\n        }\n      } else {\n        // stored fields only...\n\n        oldDoc = RealTimeGetComponent.getInputDocument(core, indexedDocId);\n\n        if (null == oldDoc) {\n          // log.info(\"VERSION no doc found, returning true\");\n          return true;\n        }\n      }\n\n\n      if (oldDoc != null) {\n        oldUserVersion = oldDoc.getFieldValue(versionFieldName);\n        // Make the FieldType resolve any conversion we need.\n        oldUserVersion = convertFieldValueUsingType(userVersionField, oldUserVersion);\n\n        Object o = oldDoc.getFieldValue(solrVersionField.getName());\n        if (o == null) {\n          throw new SolrException(SERVER_ERROR, \"No _version_ for document \"+ oldDoc);\n        }\n        oldSolrVersion = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      }\n\n      // log.info(\"VERSION old=\" + oldUserVersion + \" new=\" +newUserVersion );\n\n      if ( null == oldUserVersion) {\n        // could happen if they turn this feature on after building an index\n        // w/o the versionField\n        throw new SolrException(SERVER_ERROR,\n            \"Doc exists in index, but has null versionField: \"\n                + versionFieldName);\n      }\n\n\n      if (! (oldUserVersion instanceof Comparable && newUserVersion instanceof Comparable) ) {\n        throw new SolrException(BAD_REQUEST,\n            \"old version and new version are not comparable: \" +\n                oldUserVersion.getClass()+\" vs \"+newUserVersion.getClass());\n      }\n\n      try {\n        if (0 < ((Comparable)newUserVersion).compareTo((Comparable) oldUserVersion)) {\n          // log.info(\"VERSION returning true (proceed with update)\" );\n          return true;\n        }\n        if (ignoreOldUpdates) {\n          if (log.isDebugEnabled()) {\n            log.debug(\"Dropping update since user version is not high enough: \" + newUserVersion + \"; old user version=\" + oldUserVersion);\n          }\n          // log.info(\"VERSION returning false (dropping update)\" );\n          return false;\n        } else {\n          // log.info(\"VERSION will throw conflict\" );\n          throw new SolrException(CONFLICT,\n              \"user version is not high enough: \" + newUserVersion);\n        }\n      } catch (ClassCastException e) {\n        throw new SolrException(BAD_REQUEST,\n            \"old version and new version are not comparable: \" +\n                oldUserVersion.getClass()+\" vs \"+newUserVersion.getClass() +\n                \": \" + e.getMessage(), e);\n\n      }\n    }\n\n","sourceOld":"    /**\n     * Returns true if the specified new version value is greater the the one\n     * already known to exist for the document, or the document does not already\n     * exist.\n     * Returns false if the specified new version is not high enough but the\n     * processor has been configured with ignoreOldUpdates=true\n     * Throws a SolrException if the version is not high enough and\n     * ignoreOldUpdates=false\n     */\n    private boolean isVersionNewEnough(BytesRef indexedDocId,\n                                       Object newUserVersion) throws IOException {\n      assert null != indexedDocId;\n      assert null != newUserVersion;\n\n      oldSolrVersion = -1;\n      // log.info(\"!!!!!!!!! isVersionNewEnough being called for \" + indexedDocId.utf8ToString() + \" newVersion=\" + newUserVersion);\n      newUserVersion = convertFieldValueUsingType(userVersionField, newUserVersion);\n      Object oldUserVersion = null;\n      SolrInputDocument oldDoc = null;\n\n      if (useFieldCache) {\n        oldDoc = RealTimeGetComponent.getInputDocumentFromTlog(core, indexedDocId);\n        if (oldDoc == RealTimeGetComponent.DELETED) {\n          return true;\n        }\n        if (oldDoc == null) {\n          // need to look up in index now...\n          RefCounted<SolrIndexSearcher> newestSearcher = core.getRealtimeSearcher();\n          try {\n            SolrIndexSearcher searcher = newestSearcher.get();\n            long lookup = searcher.lookupId(indexedDocId);\n            if (lookup < 0) {\n              // doc not in index either...\n              return true;\n            }\n\n            ValueSource vs = solrVersionField.getType().getValueSource(solrVersionField, null);\n            Map context = ValueSource.newContext(searcher);\n            vs.createWeight(context, searcher);\n            FunctionValues fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int)(lookup>>32)));\n            oldSolrVersion = fv.longVal((int)lookup);\n\n            vs = userVersionField.getType().getValueSource(userVersionField, null);\n            context = ValueSource.newContext(searcher);\n            vs.createWeight(context, searcher);\n            fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int)(lookup>>32)));\n            oldUserVersion = fv.objectVal((int)lookup);\n\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error reading version from index\", e);\n          } finally {\n            if (newestSearcher != null) {\n              newestSearcher.decref();\n            }\n          }\n        }\n      } else {\n        // stored fields only...\n\n        oldDoc = RealTimeGetComponent.getInputDocument(core, indexedDocId);\n\n        if (null == oldDoc) {\n          // log.info(\"VERSION no doc found, returning true\");\n          return true;\n        }\n      }\n\n\n      if (oldDoc != null) {\n        oldUserVersion = oldDoc.getFieldValue(versionFieldName);\n        // Make the FieldType resolve any conversion we need.\n        oldUserVersion = convertFieldValueUsingType(userVersionField, oldUserVersion);\n\n        Object o = oldDoc.getFieldValue(solrVersionField.getName());\n        if (o == null) {\n          throw new SolrException(SERVER_ERROR, \"No _version_ for document \"+ oldDoc);\n        }\n        oldSolrVersion = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      }\n\n      // log.info(\"VERSION old=\" + oldUserVersion + \" new=\" +newUserVersion );\n\n      if ( null == oldUserVersion) {\n        // could happen if they turn this feature on after building an index\n        // w/o the versionField\n        throw new SolrException(SERVER_ERROR,\n            \"Doc exists in index, but has null versionField: \"\n                + versionFieldName);\n      }\n\n\n      if (! (oldUserVersion instanceof Comparable && newUserVersion instanceof Comparable) ) {\n        throw new SolrException(BAD_REQUEST,\n            \"old version and new version are not comparable: \" +\n                oldUserVersion.getClass()+\" vs \"+newUserVersion.getClass());\n      }\n\n      try {\n        if (0 < ((Comparable)newUserVersion).compareTo((Comparable) oldUserVersion)) {\n          // log.info(\"VERSION returning true (proceed with update)\" );\n          return true;\n        }\n        if (ignoreOldUpdates) {\n          if (log.isDebugEnabled()) {\n            log.debug(\"Dropping update since user version is not high enough: \" + newUserVersion + \"; old user version=\" + oldUserVersion);\n          }\n          // log.info(\"VERSION returning false (dropping update)\" );\n          return false;\n        } else {\n          // log.info(\"VERSION will throw conflict\" );\n          throw new SolrException(CONFLICT,\n              \"user version is not high enough: \" + newUserVersion);\n        }\n      } catch (ClassCastException e) {\n        throw new SolrException(BAD_REQUEST,\n            \"old version and new version are not comparable: \" +\n                oldUserVersion.getClass()+\" vs \"+newUserVersion.getClass() +\n                \": \" + e.getMessage(), e);\n\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"415bbbe7da8065dd3c477bdc3c703c6425622998","date":1485393793,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocBasedVersionConstraintsProcessorFactory.DocBasedVersionConstraintsProcessor#isVersionNewEnough(BytesRef,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocBasedVersionConstraintsProcessorFactory.DocBasedVersionConstraintsProcessor#isVersionNewEnough(BytesRef,Object).mjava","sourceNew":"    /**\n     * Returns true if the specified new version value is greater the the one\n     * already known to exist for the document, or the document does not already\n     * exist.\n     * Returns false if the specified new version is not high enough but the\n     * processor has been configured with ignoreOldUpdates=true\n     * Throws a SolrException if the version is not high enough and\n     * ignoreOldUpdates=false\n     */\n    private boolean isVersionNewEnough(BytesRef indexedDocId,\n                                       Object newUserVersion) throws IOException {\n      assert null != indexedDocId;\n      assert null != newUserVersion;\n\n      oldSolrVersion = -1;\n      // log.info(\"!!!!!!!!! isVersionNewEnough being called for \" + indexedDocId.utf8ToString() + \" newVersion=\" + newUserVersion);\n      newUserVersion = convertFieldValueUsingType(userVersionField, newUserVersion);\n      Object oldUserVersion = null;\n      SolrInputDocument oldDoc = null;\n\n      if (useFieldCache) {\n        oldDoc = RealTimeGetComponent.getInputDocumentFromTlog(core, indexedDocId, null, null, true);\n        if (oldDoc == RealTimeGetComponent.DELETED) {\n          return true;\n        }\n        if (oldDoc == null) {\n          // need to look up in index now...\n          RefCounted<SolrIndexSearcher> newestSearcher = core.getRealtimeSearcher();\n          try {\n            SolrIndexSearcher searcher = newestSearcher.get();\n            long lookup = searcher.lookupId(indexedDocId);\n            if (lookup < 0) {\n              // doc not in index either...\n              return true;\n            }\n\n            ValueSource vs = solrVersionField.getType().getValueSource(solrVersionField, null);\n            Map context = ValueSource.newContext(searcher);\n            vs.createWeight(context, searcher);\n            FunctionValues fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int)(lookup>>32)));\n            oldSolrVersion = fv.longVal((int)lookup);\n\n            vs = userVersionField.getType().getValueSource(userVersionField, null);\n            context = ValueSource.newContext(searcher);\n            vs.createWeight(context, searcher);\n            fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int)(lookup>>32)));\n            oldUserVersion = fv.objectVal((int)lookup);\n\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error reading version from index\", e);\n          } finally {\n            if (newestSearcher != null) {\n              newestSearcher.decref();\n            }\n          }\n        }\n      } else {\n        // stored fields only...\n\n        oldDoc = RealTimeGetComponent.getInputDocument(core, indexedDocId);\n\n        if (null == oldDoc) {\n          // log.info(\"VERSION no doc found, returning true\");\n          return true;\n        }\n      }\n\n\n      if (oldDoc != null) {\n        oldUserVersion = oldDoc.getFieldValue(versionFieldName);\n        // Make the FieldType resolve any conversion we need.\n        oldUserVersion = convertFieldValueUsingType(userVersionField, oldUserVersion);\n\n        Object o = oldDoc.getFieldValue(solrVersionField.getName());\n        if (o == null) {\n          throw new SolrException(SERVER_ERROR, \"No _version_ for document \"+ oldDoc);\n        }\n        oldSolrVersion = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      }\n\n      // log.info(\"VERSION old=\" + oldUserVersion + \" new=\" +newUserVersion );\n\n      if ( null == oldUserVersion) {\n        // could happen if they turn this feature on after building an index\n        // w/o the versionField\n        throw new SolrException(SERVER_ERROR,\n            \"Doc exists in index, but has null versionField: \"\n                + versionFieldName);\n      }\n\n\n      if (! (oldUserVersion instanceof Comparable && newUserVersion instanceof Comparable) ) {\n        throw new SolrException(BAD_REQUEST,\n            \"old version and new version are not comparable: \" +\n                oldUserVersion.getClass()+\" vs \"+newUserVersion.getClass());\n      }\n\n      try {\n        if (0 < ((Comparable)newUserVersion).compareTo((Comparable) oldUserVersion)) {\n          // log.info(\"VERSION returning true (proceed with update)\" );\n          return true;\n        }\n        if (ignoreOldUpdates) {\n          if (log.isDebugEnabled()) {\n            log.debug(\"Dropping update since user version is not high enough: \" + newUserVersion + \"; old user version=\" + oldUserVersion);\n          }\n          // log.info(\"VERSION returning false (dropping update)\" );\n          return false;\n        } else {\n          // log.info(\"VERSION will throw conflict\" );\n          throw new SolrException(CONFLICT,\n              \"user version is not high enough: \" + newUserVersion);\n        }\n      } catch (ClassCastException e) {\n        throw new SolrException(BAD_REQUEST,\n            \"old version and new version are not comparable: \" +\n                oldUserVersion.getClass()+\" vs \"+newUserVersion.getClass() +\n                \": \" + e.getMessage(), e);\n\n      }\n    }\n\n","sourceOld":"    /**\n     * Returns true if the specified new version value is greater the the one\n     * already known to exist for the document, or the document does not already\n     * exist.\n     * Returns false if the specified new version is not high enough but the\n     * processor has been configured with ignoreOldUpdates=true\n     * Throws a SolrException if the version is not high enough and\n     * ignoreOldUpdates=false\n     */\n    private boolean isVersionNewEnough(BytesRef indexedDocId,\n                                       Object newUserVersion) throws IOException {\n      assert null != indexedDocId;\n      assert null != newUserVersion;\n\n      oldSolrVersion = -1;\n      // log.info(\"!!!!!!!!! isVersionNewEnough being called for \" + indexedDocId.utf8ToString() + \" newVersion=\" + newUserVersion);\n      newUserVersion = convertFieldValueUsingType(userVersionField, newUserVersion);\n      Object oldUserVersion = null;\n      SolrInputDocument oldDoc = null;\n\n      if (useFieldCache) {\n        oldDoc = RealTimeGetComponent.getInputDocumentFromTlog(core, indexedDocId);\n        if (oldDoc == RealTimeGetComponent.DELETED) {\n          return true;\n        }\n        if (oldDoc == null) {\n          // need to look up in index now...\n          RefCounted<SolrIndexSearcher> newestSearcher = core.getRealtimeSearcher();\n          try {\n            SolrIndexSearcher searcher = newestSearcher.get();\n            long lookup = searcher.lookupId(indexedDocId);\n            if (lookup < 0) {\n              // doc not in index either...\n              return true;\n            }\n\n            ValueSource vs = solrVersionField.getType().getValueSource(solrVersionField, null);\n            Map context = ValueSource.newContext(searcher);\n            vs.createWeight(context, searcher);\n            FunctionValues fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int)(lookup>>32)));\n            oldSolrVersion = fv.longVal((int)lookup);\n\n            vs = userVersionField.getType().getValueSource(userVersionField, null);\n            context = ValueSource.newContext(searcher);\n            vs.createWeight(context, searcher);\n            fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int)(lookup>>32)));\n            oldUserVersion = fv.objectVal((int)lookup);\n\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error reading version from index\", e);\n          } finally {\n            if (newestSearcher != null) {\n              newestSearcher.decref();\n            }\n          }\n        }\n      } else {\n        // stored fields only...\n\n        oldDoc = RealTimeGetComponent.getInputDocument(core, indexedDocId);\n\n        if (null == oldDoc) {\n          // log.info(\"VERSION no doc found, returning true\");\n          return true;\n        }\n      }\n\n\n      if (oldDoc != null) {\n        oldUserVersion = oldDoc.getFieldValue(versionFieldName);\n        // Make the FieldType resolve any conversion we need.\n        oldUserVersion = convertFieldValueUsingType(userVersionField, oldUserVersion);\n\n        Object o = oldDoc.getFieldValue(solrVersionField.getName());\n        if (o == null) {\n          throw new SolrException(SERVER_ERROR, \"No _version_ for document \"+ oldDoc);\n        }\n        oldSolrVersion = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      }\n\n      // log.info(\"VERSION old=\" + oldUserVersion + \" new=\" +newUserVersion );\n\n      if ( null == oldUserVersion) {\n        // could happen if they turn this feature on after building an index\n        // w/o the versionField\n        throw new SolrException(SERVER_ERROR,\n            \"Doc exists in index, but has null versionField: \"\n                + versionFieldName);\n      }\n\n\n      if (! (oldUserVersion instanceof Comparable && newUserVersion instanceof Comparable) ) {\n        throw new SolrException(BAD_REQUEST,\n            \"old version and new version are not comparable: \" +\n                oldUserVersion.getClass()+\" vs \"+newUserVersion.getClass());\n      }\n\n      try {\n        if (0 < ((Comparable)newUserVersion).compareTo((Comparable) oldUserVersion)) {\n          // log.info(\"VERSION returning true (proceed with update)\" );\n          return true;\n        }\n        if (ignoreOldUpdates) {\n          if (log.isDebugEnabled()) {\n            log.debug(\"Dropping update since user version is not high enough: \" + newUserVersion + \"; old user version=\" + oldUserVersion);\n          }\n          // log.info(\"VERSION returning false (dropping update)\" );\n          return false;\n        } else {\n          // log.info(\"VERSION will throw conflict\" );\n          throw new SolrException(CONFLICT,\n              \"user version is not high enough: \" + newUserVersion);\n        }\n      } catch (ClassCastException e) {\n        throw new SolrException(BAD_REQUEST,\n            \"old version and new version are not comparable: \" +\n                oldUserVersion.getClass()+\" vs \"+newUserVersion.getClass() +\n                \": \" + e.getMessage(), e);\n\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"598b5d23aa7c9732bf473c21a9cd309c44599394","date":1485530378,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocBasedVersionConstraintsProcessorFactory.DocBasedVersionConstraintsProcessor#isVersionNewEnough(BytesRef,Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocBasedVersionConstraintsProcessorFactory.DocBasedVersionConstraintsProcessor#isVersionNewEnough(BytesRef,Object).mjava","sourceNew":"    /**\n     * Returns true if the specified new version value is greater the the one\n     * already known to exist for the document, or the document does not already\n     * exist.\n     * Returns false if the specified new version is not high enough but the\n     * processor has been configured with ignoreOldUpdates=true\n     * Throws a SolrException if the version is not high enough and\n     * ignoreOldUpdates=false\n     */\n    private boolean isVersionNewEnough(BytesRef indexedDocId,\n                                       Object newUserVersion) throws IOException {\n      assert null != indexedDocId;\n      assert null != newUserVersion;\n\n      oldSolrVersion = -1;\n      // log.info(\"!!!!!!!!! isVersionNewEnough being called for \" + indexedDocId.utf8ToString() + \" newVersion=\" + newUserVersion);\n      newUserVersion = convertFieldValueUsingType(userVersionField, newUserVersion);\n      Object oldUserVersion = null;\n      SolrInputDocument oldDoc = null;\n\n      if (useFieldCache) {\n        oldDoc = RealTimeGetComponent.getInputDocumentFromTlog(core, indexedDocId, null, null, true);\n        if (oldDoc == RealTimeGetComponent.DELETED) {\n          return true;\n        }\n        if (oldDoc == null) {\n          // need to look up in index now...\n          RefCounted<SolrIndexSearcher> newestSearcher = core.getRealtimeSearcher();\n          try {\n            SolrIndexSearcher searcher = newestSearcher.get();\n            long lookup = searcher.lookupId(indexedDocId);\n            if (lookup < 0) {\n              // doc not in index either...\n              return true;\n            }\n\n            ValueSource vs = solrVersionField.getType().getValueSource(solrVersionField, null);\n            Map context = ValueSource.newContext(searcher);\n            vs.createWeight(context, searcher);\n            FunctionValues fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int)(lookup>>32)));\n            oldSolrVersion = fv.longVal((int)lookup);\n\n            vs = userVersionField.getType().getValueSource(userVersionField, null);\n            context = ValueSource.newContext(searcher);\n            vs.createWeight(context, searcher);\n            fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int)(lookup>>32)));\n            oldUserVersion = fv.objectVal((int)lookup);\n\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error reading version from index\", e);\n          } finally {\n            if (newestSearcher != null) {\n              newestSearcher.decref();\n            }\n          }\n        }\n      } else {\n        // stored fields only...\n\n        oldDoc = RealTimeGetComponent.getInputDocument(core, indexedDocId);\n\n        if (null == oldDoc) {\n          // log.info(\"VERSION no doc found, returning true\");\n          return true;\n        }\n      }\n\n\n      if (oldDoc != null) {\n        oldUserVersion = oldDoc.getFieldValue(versionFieldName);\n        // Make the FieldType resolve any conversion we need.\n        oldUserVersion = convertFieldValueUsingType(userVersionField, oldUserVersion);\n\n        Object o = oldDoc.getFieldValue(solrVersionField.getName());\n        if (o == null) {\n          throw new SolrException(SERVER_ERROR, \"No _version_ for document \"+ oldDoc);\n        }\n        oldSolrVersion = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      }\n\n      // log.info(\"VERSION old=\" + oldUserVersion + \" new=\" +newUserVersion );\n\n      if ( null == oldUserVersion) {\n        // could happen if they turn this feature on after building an index\n        // w/o the versionField\n        throw new SolrException(SERVER_ERROR,\n            \"Doc exists in index, but has null versionField: \"\n                + versionFieldName);\n      }\n\n\n      if (! (oldUserVersion instanceof Comparable && newUserVersion instanceof Comparable) ) {\n        throw new SolrException(BAD_REQUEST,\n            \"old version and new version are not comparable: \" +\n                oldUserVersion.getClass()+\" vs \"+newUserVersion.getClass());\n      }\n\n      try {\n        if (0 < ((Comparable)newUserVersion).compareTo((Comparable) oldUserVersion)) {\n          // log.info(\"VERSION returning true (proceed with update)\" );\n          return true;\n        }\n        if (ignoreOldUpdates) {\n          if (log.isDebugEnabled()) {\n            log.debug(\"Dropping update since user version is not high enough: \" + newUserVersion + \"; old user version=\" + oldUserVersion);\n          }\n          // log.info(\"VERSION returning false (dropping update)\" );\n          return false;\n        } else {\n          // log.info(\"VERSION will throw conflict\" );\n          throw new SolrException(CONFLICT,\n              \"user version is not high enough: \" + newUserVersion);\n        }\n      } catch (ClassCastException e) {\n        throw new SolrException(BAD_REQUEST,\n            \"old version and new version are not comparable: \" +\n                oldUserVersion.getClass()+\" vs \"+newUserVersion.getClass() +\n                \": \" + e.getMessage(), e);\n\n      }\n    }\n\n","sourceOld":"    /**\n     * Returns true if the specified new version value is greater the the one\n     * already known to exist for the document, or the document does not already\n     * exist.\n     * Returns false if the specified new version is not high enough but the\n     * processor has been configured with ignoreOldUpdates=true\n     * Throws a SolrException if the version is not high enough and\n     * ignoreOldUpdates=false\n     */\n    private boolean isVersionNewEnough(BytesRef indexedDocId,\n                                       Object newUserVersion) throws IOException {\n      assert null != indexedDocId;\n      assert null != newUserVersion;\n\n      oldSolrVersion = -1;\n      // log.info(\"!!!!!!!!! isVersionNewEnough being called for \" + indexedDocId.utf8ToString() + \" newVersion=\" + newUserVersion);\n      newUserVersion = convertFieldValueUsingType(userVersionField, newUserVersion);\n      Object oldUserVersion = null;\n      SolrInputDocument oldDoc = null;\n\n      if (useFieldCache) {\n        oldDoc = RealTimeGetComponent.getInputDocumentFromTlog(core, indexedDocId);\n        if (oldDoc == RealTimeGetComponent.DELETED) {\n          return true;\n        }\n        if (oldDoc == null) {\n          // need to look up in index now...\n          RefCounted<SolrIndexSearcher> newestSearcher = core.getRealtimeSearcher();\n          try {\n            SolrIndexSearcher searcher = newestSearcher.get();\n            long lookup = searcher.lookupId(indexedDocId);\n            if (lookup < 0) {\n              // doc not in index either...\n              return true;\n            }\n\n            ValueSource vs = solrVersionField.getType().getValueSource(solrVersionField, null);\n            Map context = ValueSource.newContext(searcher);\n            vs.createWeight(context, searcher);\n            FunctionValues fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int)(lookup>>32)));\n            oldSolrVersion = fv.longVal((int)lookup);\n\n            vs = userVersionField.getType().getValueSource(userVersionField, null);\n            context = ValueSource.newContext(searcher);\n            vs.createWeight(context, searcher);\n            fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int)(lookup>>32)));\n            oldUserVersion = fv.objectVal((int)lookup);\n\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error reading version from index\", e);\n          } finally {\n            if (newestSearcher != null) {\n              newestSearcher.decref();\n            }\n          }\n        }\n      } else {\n        // stored fields only...\n\n        oldDoc = RealTimeGetComponent.getInputDocument(core, indexedDocId);\n\n        if (null == oldDoc) {\n          // log.info(\"VERSION no doc found, returning true\");\n          return true;\n        }\n      }\n\n\n      if (oldDoc != null) {\n        oldUserVersion = oldDoc.getFieldValue(versionFieldName);\n        // Make the FieldType resolve any conversion we need.\n        oldUserVersion = convertFieldValueUsingType(userVersionField, oldUserVersion);\n\n        Object o = oldDoc.getFieldValue(solrVersionField.getName());\n        if (o == null) {\n          throw new SolrException(SERVER_ERROR, \"No _version_ for document \"+ oldDoc);\n        }\n        oldSolrVersion = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      }\n\n      // log.info(\"VERSION old=\" + oldUserVersion + \" new=\" +newUserVersion );\n\n      if ( null == oldUserVersion) {\n        // could happen if they turn this feature on after building an index\n        // w/o the versionField\n        throw new SolrException(SERVER_ERROR,\n            \"Doc exists in index, but has null versionField: \"\n                + versionFieldName);\n      }\n\n\n      if (! (oldUserVersion instanceof Comparable && newUserVersion instanceof Comparable) ) {\n        throw new SolrException(BAD_REQUEST,\n            \"old version and new version are not comparable: \" +\n                oldUserVersion.getClass()+\" vs \"+newUserVersion.getClass());\n      }\n\n      try {\n        if (0 < ((Comparable)newUserVersion).compareTo((Comparable) oldUserVersion)) {\n          // log.info(\"VERSION returning true (proceed with update)\" );\n          return true;\n        }\n        if (ignoreOldUpdates) {\n          if (log.isDebugEnabled()) {\n            log.debug(\"Dropping update since user version is not high enough: \" + newUserVersion + \"; old user version=\" + oldUserVersion);\n          }\n          // log.info(\"VERSION returning false (dropping update)\" );\n          return false;\n        } else {\n          // log.info(\"VERSION will throw conflict\" );\n          throw new SolrException(CONFLICT,\n              \"user version is not high enough: \" + newUserVersion);\n        }\n      } catch (ClassCastException e) {\n        throw new SolrException(BAD_REQUEST,\n            \"old version and new version are not comparable: \" +\n                oldUserVersion.getClass()+\" vs \"+newUserVersion.getClass() +\n                \": \" + e.getMessage(), e);\n\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31b9d540ce892a94ad2ad89f9b9cddc9180b6c15","date":1523556268,"type":4,"author":"David Smiley","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocBasedVersionConstraintsProcessorFactory.DocBasedVersionConstraintsProcessor#isVersionNewEnough(BytesRef,Object).mjava","sourceNew":null,"sourceOld":"    /**\n     * Returns true if the specified new version value is greater the the one\n     * already known to exist for the document, or the document does not already\n     * exist.\n     * Returns false if the specified new version is not high enough but the\n     * processor has been configured with ignoreOldUpdates=true\n     * Throws a SolrException if the version is not high enough and\n     * ignoreOldUpdates=false\n     */\n    private boolean isVersionNewEnough(BytesRef indexedDocId,\n                                       Object newUserVersion) throws IOException {\n      assert null != indexedDocId;\n      assert null != newUserVersion;\n\n      oldSolrVersion = -1;\n      // log.info(\"!!!!!!!!! isVersionNewEnough being called for \" + indexedDocId.utf8ToString() + \" newVersion=\" + newUserVersion);\n      newUserVersion = convertFieldValueUsingType(userVersionField, newUserVersion);\n      Object oldUserVersion = null;\n      SolrInputDocument oldDoc = null;\n\n      if (useFieldCache) {\n        oldDoc = RealTimeGetComponent.getInputDocumentFromTlog(core, indexedDocId, null, null, true);\n        if (oldDoc == RealTimeGetComponent.DELETED) {\n          return true;\n        }\n        if (oldDoc == null) {\n          // need to look up in index now...\n          RefCounted<SolrIndexSearcher> newestSearcher = core.getRealtimeSearcher();\n          try {\n            SolrIndexSearcher searcher = newestSearcher.get();\n            long lookup = searcher.lookupId(indexedDocId);\n            if (lookup < 0) {\n              // doc not in index either...\n              return true;\n            }\n\n            ValueSource vs = solrVersionField.getType().getValueSource(solrVersionField, null);\n            Map context = ValueSource.newContext(searcher);\n            vs.createWeight(context, searcher);\n            FunctionValues fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int)(lookup>>32)));\n            oldSolrVersion = fv.longVal((int)lookup);\n\n            vs = userVersionField.getType().getValueSource(userVersionField, null);\n            context = ValueSource.newContext(searcher);\n            vs.createWeight(context, searcher);\n            fv = vs.getValues(context, searcher.getTopReaderContext().leaves().get((int)(lookup>>32)));\n            oldUserVersion = fv.objectVal((int)lookup);\n\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error reading version from index\", e);\n          } finally {\n            if (newestSearcher != null) {\n              newestSearcher.decref();\n            }\n          }\n        }\n      } else {\n        // stored fields only...\n\n        oldDoc = RealTimeGetComponent.getInputDocument(core, indexedDocId);\n\n        if (null == oldDoc) {\n          // log.info(\"VERSION no doc found, returning true\");\n          return true;\n        }\n      }\n\n\n      if (oldDoc != null) {\n        oldUserVersion = oldDoc.getFieldValue(versionFieldName);\n        // Make the FieldType resolve any conversion we need.\n        oldUserVersion = convertFieldValueUsingType(userVersionField, oldUserVersion);\n\n        Object o = oldDoc.getFieldValue(solrVersionField.getName());\n        if (o == null) {\n          throw new SolrException(SERVER_ERROR, \"No _version_ for document \"+ oldDoc);\n        }\n        oldSolrVersion = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      }\n\n      // log.info(\"VERSION old=\" + oldUserVersion + \" new=\" +newUserVersion );\n\n      if ( null == oldUserVersion) {\n        // could happen if they turn this feature on after building an index\n        // w/o the versionField\n        throw new SolrException(SERVER_ERROR,\n            \"Doc exists in index, but has null versionField: \"\n                + versionFieldName);\n      }\n\n\n      if (! (oldUserVersion instanceof Comparable && newUserVersion instanceof Comparable) ) {\n        throw new SolrException(BAD_REQUEST,\n            \"old version and new version are not comparable: \" +\n                oldUserVersion.getClass()+\" vs \"+newUserVersion.getClass());\n      }\n\n      try {\n        if (0 < ((Comparable)newUserVersion).compareTo((Comparable) oldUserVersion)) {\n          // log.info(\"VERSION returning true (proceed with update)\" );\n          return true;\n        }\n        if (ignoreOldUpdates) {\n          if (log.isDebugEnabled()) {\n            log.debug(\"Dropping update since user version is not high enough: \" + newUserVersion + \"; old user version=\" + oldUserVersion);\n          }\n          // log.info(\"VERSION returning false (dropping update)\" );\n          return false;\n        } else {\n          // log.info(\"VERSION will throw conflict\" );\n          throw new SolrException(CONFLICT,\n              \"user version is not high enough: \" + newUserVersion);\n        }\n      } catch (ClassCastException e) {\n        throw new SolrException(BAD_REQUEST,\n            \"old version and new version are not comparable: \" +\n                oldUserVersion.getClass()+\" vs \"+newUserVersion.getClass() +\n                \": \" + e.getMessage(), e);\n\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["3f8973f28b29873ff0d7a016e562c9036ae649a9"],"598b5d23aa7c9732bf473c21a9cd309c44599394":["3f8973f28b29873ff0d7a016e562c9036ae649a9","415bbbe7da8065dd3c477bdc3c703c6425622998"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"45a4348f3ba3bf4ff6cbb4169fe5bf7d28288cd0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"31b9d540ce892a94ad2ad89f9b9cddc9180b6c15":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"3f8973f28b29873ff0d7a016e562c9036ae649a9":["9a094a3cf22dfb1f022ba368c1605239343aa873"],"9a094a3cf22dfb1f022ba368c1605239343aa873":["45a4348f3ba3bf4ff6cbb4169fe5bf7d28288cd0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["31b9d540ce892a94ad2ad89f9b9cddc9180b6c15"]},"commit2Childs":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["598b5d23aa7c9732bf473c21a9cd309c44599394","31b9d540ce892a94ad2ad89f9b9cddc9180b6c15"],"598b5d23aa7c9732bf473c21a9cd309c44599394":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["45a4348f3ba3bf4ff6cbb4169fe5bf7d28288cd0"],"45a4348f3ba3bf4ff6cbb4169fe5bf7d28288cd0":["9a094a3cf22dfb1f022ba368c1605239343aa873"],"3f8973f28b29873ff0d7a016e562c9036ae649a9":["415bbbe7da8065dd3c477bdc3c703c6425622998","598b5d23aa7c9732bf473c21a9cd309c44599394"],"31b9d540ce892a94ad2ad89f9b9cddc9180b6c15":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9a094a3cf22dfb1f022ba368c1605239343aa873":["3f8973f28b29873ff0d7a016e562c9036ae649a9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["598b5d23aa7c9732bf473c21a9cd309c44599394","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}