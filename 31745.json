{"path":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,int,boolean,CurrentCoreDescriptorProvider).mjava","commits":[{"id":"a0b5db1c20d7a379233ae3955449a9e42caef007","date":1394048511,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,int,boolean,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,boolean,CurrentCoreDescriptorProvider).mjava","sourceNew":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n        String localHostContext, int leaderVoteWait, int leaderConflictResolveWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) \n      throws InterruptedException, TimeoutException, IOException\n  {\n\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.hostName = normalizeHostName(localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.leaderConflictResolveWait = leaderConflictResolveWait;\n    \n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, new DefaultConnectionStrategy(),\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              ElectionContext context = new OverseerElectionContext(zkClient,\n                  overseer, getNodeName());\n              \n              ElectionContext prevContext = overseerElector.getContext();\n              if (prevContext != null) {\n                prevContext.cancelElection();\n              }\n\n              overseerElector.setup(context);\n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n            markAllAsNotLeader(registerOnReconnect);\n          }\n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    this.baseURL = zkStateReader.getBaseUrlForNodeName(this.nodeName);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, int leaderVoteWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.hostName = normalizeHostName(localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, new DefaultConnectionStrategy(),\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              ElectionContext context = new OverseerElectionContext(zkClient,\n                  overseer, getNodeName());\n              \n              ElectionContext prevContext = overseerElector.getContext();\n              if (prevContext != null) {\n                prevContext.cancelElection();\n              }\n\n              overseerElector.setup(context);\n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n            markAllAsNotLeader(registerOnReconnect);\n          }\n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    this.baseURL = zkStateReader.getBaseUrlForNodeName(this.nodeName);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"96ea64d994d340044e0d57aeb6a5871539d10ca5","date":1394225445,"type":1,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,int,boolean,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,boolean,CurrentCoreDescriptorProvider).mjava","sourceNew":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n        String localHostContext, int leaderVoteWait, int leaderConflictResolveWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) \n      throws InterruptedException, TimeoutException, IOException\n  {\n\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.hostName = normalizeHostName(localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.leaderConflictResolveWait = leaderConflictResolveWait;\n    \n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, new DefaultConnectionStrategy(),\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              ElectionContext context = new OverseerElectionContext(zkClient,\n                  overseer, getNodeName());\n              \n              ElectionContext prevContext = overseerElector.getContext();\n              if (prevContext != null) {\n                prevContext.cancelElection();\n              }\n\n              overseerElector.setup(context);\n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n            markAllAsNotLeader(registerOnReconnect);\n          }\n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    this.baseURL = zkStateReader.getBaseUrlForNodeName(this.nodeName);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n      String localHostContext, int leaderVoteWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) throws InterruptedException,\n      TimeoutException, IOException {\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.hostName = normalizeHostName(localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, new DefaultConnectionStrategy(),\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              ElectionContext context = new OverseerElectionContext(zkClient,\n                  overseer, getNodeName());\n              \n              ElectionContext prevContext = overseerElector.getContext();\n              if (prevContext != null) {\n                prevContext.cancelElection();\n              }\n\n              overseerElector.setup(context);\n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n            markAllAsNotLeader(registerOnReconnect);\n          }\n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    this.baseURL = zkStateReader.getBaseUrlForNodeName(this.nodeName);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"058f5a3debcfa0ea477da3eabb4cbe2ec0fac211","date":1394784078,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,int,boolean,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,int,boolean,CurrentCoreDescriptorProvider).mjava","sourceNew":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n        String localHostContext, int leaderVoteWait, int leaderConflictResolveWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) \n      throws InterruptedException, TimeoutException, IOException\n  {\n\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.hostName = normalizeHostName(localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.leaderConflictResolveWait = leaderConflictResolveWait;\n    \n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, new DefaultConnectionStrategy(),\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              ElectionContext context = new OverseerElectionContext(zkClient,\n                  overseer, getNodeName());\n              \n              ElectionContext prevContext = overseerElector.getContext();\n              if (prevContext != null) {\n                prevContext.cancelElection();\n              }\n\n              overseerElector.setup(context);\n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n            markAllAsNotLeader(registerOnReconnect);\n          }\n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    this.overseerRunningMap = Overseer.getRunningMap(zkClient);\n    this.overseerCompletedMap = Overseer.getCompletedMap(zkClient);\n    this.overseerFailureMap = Overseer.getFailureMap(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    this.baseURL = zkStateReader.getBaseUrlForNodeName(this.nodeName);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n        String localHostContext, int leaderVoteWait, int leaderConflictResolveWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) \n      throws InterruptedException, TimeoutException, IOException\n  {\n\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.hostName = normalizeHostName(localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.leaderConflictResolveWait = leaderConflictResolveWait;\n    \n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, new DefaultConnectionStrategy(),\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              ElectionContext context = new OverseerElectionContext(zkClient,\n                  overseer, getNodeName());\n              \n              ElectionContext prevContext = overseerElector.getContext();\n              if (prevContext != null) {\n                prevContext.cancelElection();\n              }\n\n              overseerElector.setup(context);\n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n            markAllAsNotLeader(registerOnReconnect);\n          }\n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    this.baseURL = zkStateReader.getBaseUrlForNodeName(this.nodeName);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7a6cdd05fdf31629707e61bf652dd5e04be675ee","date":1407343591,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,int,boolean,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,int,boolean,CurrentCoreDescriptorProvider).mjava","sourceNew":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n        String localHostContext, int leaderVoteWait, int leaderConflictResolveWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) \n      throws InterruptedException, TimeoutException, IOException\n  {\n\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.hostName = normalizeHostName(localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.leaderConflictResolveWait = leaderConflictResolveWait;\n    \n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, new DefaultConnectionStrategy(),\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              if (!zkRunOnly) {\n                ElectionContext context = new OverseerElectionContext(zkClient,\n                    overseer, getNodeName());\n                \n                ElectionContext prevContext = overseerElector.getContext();\n                if (prevContext != null) {\n                  prevContext.cancelElection();\n                }\n                \n                overseerElector.setup(context);\n                overseerElector.joinElection(context, true);\n              }\n              \n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n            markAllAsNotLeader(registerOnReconnect);\n          }\n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    this.overseerRunningMap = Overseer.getRunningMap(zkClient);\n    this.overseerCompletedMap = Overseer.getCompletedMap(zkClient);\n    this.overseerFailureMap = Overseer.getFailureMap(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    this.baseURL = zkStateReader.getBaseUrlForNodeName(this.nodeName);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n        String localHostContext, int leaderVoteWait, int leaderConflictResolveWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) \n      throws InterruptedException, TimeoutException, IOException\n  {\n\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.hostName = normalizeHostName(localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.leaderConflictResolveWait = leaderConflictResolveWait;\n    \n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, new DefaultConnectionStrategy(),\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              ElectionContext context = new OverseerElectionContext(zkClient,\n                  overseer, getNodeName());\n              \n              ElectionContext prevContext = overseerElector.getContext();\n              if (prevContext != null) {\n                prevContext.cancelElection();\n              }\n\n              overseerElector.setup(context);\n              overseerElector.joinElection(context, true);\n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n            markAllAsNotLeader(registerOnReconnect);\n          }\n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    this.overseerRunningMap = Overseer.getRunningMap(zkClient);\n    this.overseerCompletedMap = Overseer.getCompletedMap(zkClient);\n    this.overseerFailureMap = Overseer.getFailureMap(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    this.baseURL = zkStateReader.getBaseUrlForNodeName(this.nodeName);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ad7bdba3e91cf3373cda2e52239cb761fc0b452","date":1408019547,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,int,boolean,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,int,boolean,CurrentCoreDescriptorProvider).mjava","sourceNew":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n        String localHostContext, int leaderVoteWait, int leaderConflictResolveWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) \n      throws InterruptedException, TimeoutException, IOException\n  {\n\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.hostName = normalizeHostName(localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.leaderConflictResolveWait = leaderConflictResolveWait;\n    \n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, new DefaultConnectionStrategy(),\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              if (!zkRunOnly) {\n                ElectionContext context = new OverseerElectionContext(zkClient,\n                    overseer, getNodeName());\n                \n                ElectionContext prevContext = overseerElector.getContext();\n                if (prevContext != null) {\n                  prevContext.cancelElection();\n                }\n                \n                overseerElector.setup(context);\n                overseerElector.joinElection(context, true);\n              }\n              \n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    // unload solrcores that have been 'failed over'\n                    throwErrorIfReplicaReplaced(descriptor);\n\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n            markAllAsNotLeader(registerOnReconnect);\n          }\n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    this.overseerRunningMap = Overseer.getRunningMap(zkClient);\n    this.overseerCompletedMap = Overseer.getCompletedMap(zkClient);\n    this.overseerFailureMap = Overseer.getFailureMap(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    this.baseURL = zkStateReader.getBaseUrlForNodeName(this.nodeName);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n        String localHostContext, int leaderVoteWait, int leaderConflictResolveWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) \n      throws InterruptedException, TimeoutException, IOException\n  {\n\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.hostName = normalizeHostName(localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.leaderConflictResolveWait = leaderConflictResolveWait;\n    \n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, new DefaultConnectionStrategy(),\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              if (!zkRunOnly) {\n                ElectionContext context = new OverseerElectionContext(zkClient,\n                    overseer, getNodeName());\n                \n                ElectionContext prevContext = overseerElector.getContext();\n                if (prevContext != null) {\n                  prevContext.cancelElection();\n                }\n                \n                overseerElector.setup(context);\n                overseerElector.joinElection(context, true);\n              }\n              \n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n            markAllAsNotLeader(registerOnReconnect);\n          }\n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    this.overseerRunningMap = Overseer.getRunningMap(zkClient);\n    this.overseerCompletedMap = Overseer.getCompletedMap(zkClient);\n    this.overseerFailureMap = Overseer.getFailureMap(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    this.baseURL = zkStateReader.getBaseUrlForNodeName(this.nodeName);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c83f985d9828d30801541f1eed26aa3169646baf","date":1409315453,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,int,boolean,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,int,boolean,CurrentCoreDescriptorProvider).mjava","sourceNew":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n        String localHostContext, int leaderVoteWait, int leaderConflictResolveWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) \n      throws InterruptedException, TimeoutException, IOException\n  {\n\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.hostName = normalizeHostName(localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.leaderConflictResolveWait = leaderConflictResolveWait;\n    \n    this.clientTimeout = zkClientTimeout;\n    DefaultConnectionStrategy strat = new DefaultConnectionStrategy();\n    String zkACLProviderClass = cc.getConfig().getZkACLProviderClass();\n    ZkACLProvider zkACLProvider = null;\n    if (zkACLProviderClass != null && zkACLProviderClass.trim().length() > 0) {\n      zkACLProvider  = cc.getResourceLoader().newInstance(zkACLProviderClass, ZkACLProvider.class);\n    } else {\n      zkACLProvider = new DefaultZkACLProvider();\n    }\n    \n    String zkCredentialProviderClass = cc.getConfig().getZkCredentialProviderClass();\n    if (zkCredentialProviderClass != null && zkCredentialProviderClass.trim().length() > 0) {\n      strat.setZkCredentialsToAddAutomatically(cc.getResourceLoader().newInstance(zkCredentialProviderClass, ZkCredentialsProvider.class));\n    } else {\n      strat.setZkCredentialsToAddAutomatically(new DefaultZkCredentialsProvider());\n    }\n    \n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, strat,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              if (!zkRunOnly) {\n                ElectionContext context = new OverseerElectionContext(zkClient,\n                    overseer, getNodeName());\n                \n                ElectionContext prevContext = overseerElector.getContext();\n                if (prevContext != null) {\n                  prevContext.cancelElection();\n                }\n                \n                overseerElector.setup(context);\n                overseerElector.joinElection(context, true);\n              }\n              \n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    // unload solrcores that have been 'failed over'\n                    throwErrorIfReplicaReplaced(descriptor);\n\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n            markAllAsNotLeader(registerOnReconnect);\n          }\n        }, zkACLProvider);\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    this.overseerRunningMap = Overseer.getRunningMap(zkClient);\n    this.overseerCompletedMap = Overseer.getCompletedMap(zkClient);\n    this.overseerFailureMap = Overseer.getFailureMap(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    this.baseURL = zkStateReader.getBaseUrlForNodeName(this.nodeName);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n        String localHostContext, int leaderVoteWait, int leaderConflictResolveWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) \n      throws InterruptedException, TimeoutException, IOException\n  {\n\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.hostName = normalizeHostName(localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.leaderConflictResolveWait = leaderConflictResolveWait;\n    \n    this.clientTimeout = zkClientTimeout;\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, new DefaultConnectionStrategy(),\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              if (!zkRunOnly) {\n                ElectionContext context = new OverseerElectionContext(zkClient,\n                    overseer, getNodeName());\n                \n                ElectionContext prevContext = overseerElector.getContext();\n                if (prevContext != null) {\n                  prevContext.cancelElection();\n                }\n                \n                overseerElector.setup(context);\n                overseerElector.joinElection(context, true);\n              }\n              \n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    // unload solrcores that have been 'failed over'\n                    throwErrorIfReplicaReplaced(descriptor);\n\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n            markAllAsNotLeader(registerOnReconnect);\n          }\n        });\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    this.overseerRunningMap = Overseer.getRunningMap(zkClient);\n    this.overseerCompletedMap = Overseer.getCompletedMap(zkClient);\n    this.overseerFailureMap = Overseer.getFailureMap(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    this.baseURL = zkStateReader.getBaseUrlForNodeName(this.nodeName);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":["368b2f45f347fa0ff807b6474c1b8b78c5cb9e24"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1596015c8bad249c0b9a52182de1d47e1d56fdde","date":1412350121,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,int,boolean,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,int,boolean,CurrentCoreDescriptorProvider).mjava","sourceNew":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n        String localHostContext, int leaderVoteWait, int leaderConflictResolveWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) \n      throws InterruptedException, TimeoutException, IOException\n  {\n\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.hostName = normalizeHostName(localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.leaderConflictResolveWait = leaderConflictResolveWait;\n    \n    this.clientTimeout = zkClientTimeout;\n    DefaultConnectionStrategy strat = new DefaultConnectionStrategy();\n    String zkACLProviderClass = cc.getConfig().getZkACLProviderClass();\n    ZkACLProvider zkACLProvider = null;\n    if (zkACLProviderClass != null && zkACLProviderClass.trim().length() > 0) {\n      zkACLProvider  = cc.getResourceLoader().newInstance(zkACLProviderClass, ZkACLProvider.class);\n    } else {\n      zkACLProvider = new DefaultZkACLProvider();\n    }\n    \n    String zkCredentialProviderClass = cc.getConfig().getZkCredentialProviderClass();\n    if (zkCredentialProviderClass != null && zkCredentialProviderClass.trim().length() > 0) {\n      strat.setZkCredentialsToAddAutomatically(cc.getResourceLoader().newInstance(zkCredentialProviderClass, ZkCredentialsProvider.class));\n    } else {\n      strat.setZkCredentialsToAddAutomatically(new DefaultZkCredentialsProvider());\n    }\n    \n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, strat,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            log.info(\"ZooKeeper session re-connected ... refreshing core states after session expiration.\");\n\n            try {\n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              if (!zkRunOnly) {\n                ElectionContext context = new OverseerElectionContext(zkClient,\n                    overseer, getNodeName());\n                \n                ElectionContext prevContext = overseerElector.getContext();\n                if (prevContext != null) {\n                  prevContext.cancelElection();\n                }\n                \n                overseerElector.setup(context);\n                overseerElector.joinElection(context, true);\n              }\n              \n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    // unload solrcores that have been 'failed over'\n                    throwErrorIfReplicaReplaced(descriptor);\n\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n\n              // notify any other objects that need to know when the session was re-connected\n              synchronized (reconnectListeners) {\n                for (OnReconnect listener : reconnectListeners) {\n                  try {\n                    listener.command();\n                  } catch (Exception exc) {\n                    // not much we can do here other than warn in the log\n                    log.warn(\"Error when notifying OnReconnect listener \"+listener+\" after session re-connected.\", exc);\n                  }\n                }\n              }\n\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n            markAllAsNotLeader(registerOnReconnect);\n          }\n        }, zkACLProvider);\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    this.overseerRunningMap = Overseer.getRunningMap(zkClient);\n    this.overseerCompletedMap = Overseer.getCompletedMap(zkClient);\n    this.overseerFailureMap = Overseer.getFailureMap(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    this.baseURL = zkStateReader.getBaseUrlForNodeName(this.nodeName);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n        String localHostContext, int leaderVoteWait, int leaderConflictResolveWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) \n      throws InterruptedException, TimeoutException, IOException\n  {\n\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.hostName = normalizeHostName(localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.leaderConflictResolveWait = leaderConflictResolveWait;\n    \n    this.clientTimeout = zkClientTimeout;\n    DefaultConnectionStrategy strat = new DefaultConnectionStrategy();\n    String zkACLProviderClass = cc.getConfig().getZkACLProviderClass();\n    ZkACLProvider zkACLProvider = null;\n    if (zkACLProviderClass != null && zkACLProviderClass.trim().length() > 0) {\n      zkACLProvider  = cc.getResourceLoader().newInstance(zkACLProviderClass, ZkACLProvider.class);\n    } else {\n      zkACLProvider = new DefaultZkACLProvider();\n    }\n    \n    String zkCredentialProviderClass = cc.getConfig().getZkCredentialProviderClass();\n    if (zkCredentialProviderClass != null && zkCredentialProviderClass.trim().length() > 0) {\n      strat.setZkCredentialsToAddAutomatically(cc.getResourceLoader().newInstance(zkCredentialProviderClass, ZkCredentialsProvider.class));\n    } else {\n      strat.setZkCredentialsToAddAutomatically(new DefaultZkCredentialsProvider());\n    }\n    \n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, strat,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              if (!zkRunOnly) {\n                ElectionContext context = new OverseerElectionContext(zkClient,\n                    overseer, getNodeName());\n                \n                ElectionContext prevContext = overseerElector.getContext();\n                if (prevContext != null) {\n                  prevContext.cancelElection();\n                }\n                \n                overseerElector.setup(context);\n                overseerElector.joinElection(context, true);\n              }\n              \n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    // unload solrcores that have been 'failed over'\n                    throwErrorIfReplicaReplaced(descriptor);\n\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n            markAllAsNotLeader(registerOnReconnect);\n          }\n        }, zkACLProvider);\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    this.overseerRunningMap = Overseer.getRunningMap(zkClient);\n    this.overseerCompletedMap = Overseer.getCompletedMap(zkClient);\n    this.overseerFailureMap = Overseer.getFailureMap(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    this.baseURL = zkStateReader.getBaseUrlForNodeName(this.nodeName);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":["29e08b0fe8c5c0149b9e904e43afc1f270f8a6c3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d9a47902d6207303f5ed3e7aaca62ca33433af66","date":1412435312,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,int,boolean,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,int,boolean,CurrentCoreDescriptorProvider).mjava","sourceNew":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n        String localHostContext, int leaderVoteWait, int leaderConflictResolveWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) \n      throws InterruptedException, TimeoutException, IOException\n  {\n\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.hostName = normalizeHostName(localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.leaderConflictResolveWait = leaderConflictResolveWait;\n    \n    this.clientTimeout = zkClientTimeout;\n    DefaultConnectionStrategy strat = new DefaultConnectionStrategy();\n    String zkACLProviderClass = cc.getConfig().getZkACLProviderClass();\n    ZkACLProvider zkACLProvider = null;\n    if (zkACLProviderClass != null && zkACLProviderClass.trim().length() > 0) {\n      zkACLProvider  = cc.getResourceLoader().newInstance(zkACLProviderClass, ZkACLProvider.class);\n    } else {\n      zkACLProvider = new DefaultZkACLProvider();\n    }\n    \n    String zkCredentialProviderClass = cc.getConfig().getZkCredentialProviderClass();\n    if (zkCredentialProviderClass != null && zkCredentialProviderClass.trim().length() > 0) {\n      strat.setZkCredentialsToAddAutomatically(cc.getResourceLoader().newInstance(zkCredentialProviderClass, ZkCredentialsProvider.class));\n    } else {\n      strat.setZkCredentialsToAddAutomatically(new DefaultZkCredentialsProvider());\n    }\n    \n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, strat,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            log.info(\"ZooKeeper session re-connected ... refreshing core states after session expiration.\");\n\n            try {\n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              if (!zkRunOnly) {\n                ElectionContext context = new OverseerElectionContext(zkClient,\n                    overseer, getNodeName());\n                \n                ElectionContext prevContext = overseerElector.getContext();\n                if (prevContext != null) {\n                  prevContext.cancelElection();\n                }\n                \n                overseerElector.setup(context);\n                overseerElector.joinElection(context, true);\n              }\n              \n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    // unload solrcores that have been 'failed over'\n                    throwErrorIfReplicaReplaced(descriptor);\n\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n\n              // notify any other objects that need to know when the session was re-connected\n              synchronized (reconnectListeners) {\n                for (OnReconnect listener : reconnectListeners) {\n                  try {\n                    listener.command();\n                  } catch (Exception exc) {\n                    // not much we can do here other than warn in the log\n                    log.warn(\"Error when notifying OnReconnect listener \"+listener+\" after session re-connected.\", exc);\n                  }\n                }\n              }\n\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n            markAllAsNotLeader(registerOnReconnect);\n          }\n        }, zkACLProvider);\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    this.overseerRunningMap = Overseer.getRunningMap(zkClient);\n    this.overseerCompletedMap = Overseer.getCompletedMap(zkClient);\n    this.overseerFailureMap = Overseer.getFailureMap(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    this.baseURL = zkStateReader.getBaseUrlForNodeName(this.nodeName);\n    \n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n        String localHostContext, int leaderVoteWait, int leaderConflictResolveWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) \n      throws InterruptedException, TimeoutException, IOException\n  {\n\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.hostName = normalizeHostName(localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.leaderConflictResolveWait = leaderConflictResolveWait;\n    \n    this.clientTimeout = zkClientTimeout;\n    DefaultConnectionStrategy strat = new DefaultConnectionStrategy();\n    String zkACLProviderClass = cc.getConfig().getZkACLProviderClass();\n    ZkACLProvider zkACLProvider = null;\n    if (zkACLProviderClass != null && zkACLProviderClass.trim().length() > 0) {\n      zkACLProvider  = cc.getResourceLoader().newInstance(zkACLProviderClass, ZkACLProvider.class);\n    } else {\n      zkACLProvider = new DefaultZkACLProvider();\n    }\n    \n    String zkCredentialProviderClass = cc.getConfig().getZkCredentialProviderClass();\n    if (zkCredentialProviderClass != null && zkCredentialProviderClass.trim().length() > 0) {\n      strat.setZkCredentialsToAddAutomatically(cc.getResourceLoader().newInstance(zkCredentialProviderClass, ZkCredentialsProvider.class));\n    } else {\n      strat.setZkCredentialsToAddAutomatically(new DefaultZkCredentialsProvider());\n    }\n    \n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, strat,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              \n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              if (!zkRunOnly) {\n                ElectionContext context = new OverseerElectionContext(zkClient,\n                    overseer, getNodeName());\n                \n                ElectionContext prevContext = overseerElector.getContext();\n                if (prevContext != null) {\n                  prevContext.cancelElection();\n                }\n                \n                overseerElector.setup(context);\n                overseerElector.joinElection(context, true);\n              }\n              \n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    // unload solrcores that have been 'failed over'\n                    throwErrorIfReplicaReplaced(descriptor);\n\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n              \n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n            markAllAsNotLeader(registerOnReconnect);\n          }\n        }, zkACLProvider);\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    this.overseerRunningMap = Overseer.getRunningMap(zkClient);\n    this.overseerCompletedMap = Overseer.getCompletedMap(zkClient);\n    this.overseerFailureMap = Overseer.getFailureMap(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    this.baseURL = zkStateReader.getBaseUrlForNodeName(this.nodeName);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"531fe719c7218235a679452eb3d137bfd8fc6af1","date":1415191086,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,int,boolean,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,int,boolean,CurrentCoreDescriptorProvider).mjava","sourceNew":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n                      String localHostContext, int leaderVoteWait, int leaderConflictResolveWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect)\n      throws InterruptedException, TimeoutException, IOException {\n\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n\n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.hostName = normalizeHostName(localHost);\n    this.nodeName = generateNodeName(this.hostName,\n        this.localHostPort,\n        this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.leaderConflictResolveWait = leaderConflictResolveWait;\n\n    this.clientTimeout = zkClientTimeout;\n    DefaultConnectionStrategy strat = new DefaultConnectionStrategy();\n    String zkACLProviderClass = cc.getConfig().getZkACLProviderClass();\n    ZkACLProvider zkACLProvider = null;\n    if (zkACLProviderClass != null && zkACLProviderClass.trim().length() > 0) {\n      zkACLProvider = cc.getResourceLoader().newInstance(zkACLProviderClass, ZkACLProvider.class);\n    } else {\n      zkACLProvider = new DefaultZkACLProvider();\n    }\n\n    String zkCredentialProviderClass = cc.getConfig().getZkCredentialProviderClass();\n    if (zkCredentialProviderClass != null && zkCredentialProviderClass.trim().length() > 0) {\n      strat.setZkCredentialsToAddAutomatically(cc.getResourceLoader().newInstance(zkCredentialProviderClass, ZkCredentialsProvider.class));\n    } else {\n      strat.setZkCredentialsToAddAutomatically(new DefaultZkCredentialsProvider());\n    }\n    addOnReconnectListener(getConfigDirListener());\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, strat,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          @Override\n          public void command() {\n            log.info(\"ZooKeeper session re-connected ... refreshing core states after session expiration.\");\n\n            try {\n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n\n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n\n              cc.cancelCoreRecoveries();\n\n              registerAllCoresAsDown(registerOnReconnect, false);\n\n              if (!zkRunOnly) {\n                ElectionContext context = new OverseerElectionContext(zkClient,\n                    overseer, getNodeName());\n\n                ElectionContext prevContext = overseerElector.getContext();\n                if (prevContext != null) {\n                  prevContext.cancelElection();\n                }\n\n                overseerElector.setup(context);\n                overseerElector.joinElection(context, true);\n              }\n\n              zkStateReader.createClusterStateWatchersAndUpdate();\n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n\n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    // unload solrcores that have been 'failed over'\n                    throwErrorIfReplicaReplaced(descriptor);\n\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n\n              // notify any other objects that need to know when the session was re-connected\n              synchronized (reconnectListeners) {\n                for (OnReconnect listener : reconnectListeners) {\n                  try {\n                    listener.command();\n                  } catch (Exception exc) {\n                    // not much we can do here other than warn in the log\n                    log.warn(\"Error when notifying OnReconnect listener \" + listener + \" after session re-connected.\", exc);\n                  }\n                }\n              }\n\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n\n        }, new BeforeReconnect() {\n\n      @Override\n      public void command() {\n        try {\n          ZkController.this.overseer.close();\n        } catch (Exception e) {\n          log.error(\"Error trying to stop any Overseer threads\", e);\n        }\n        markAllAsNotLeader(registerOnReconnect);\n      }\n    }, zkACLProvider);\n\n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    this.overseerRunningMap = Overseer.getRunningMap(zkClient);\n    this.overseerCompletedMap = Overseer.getCompletedMap(zkClient);\n    this.overseerFailureMap = Overseer.getFailureMap(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n\n    this.baseURL = zkStateReader.getBaseUrlForNodeName(this.nodeName);\n\n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n        String localHostContext, int leaderVoteWait, int leaderConflictResolveWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect) \n      throws InterruptedException, TimeoutException, IOException\n  {\n\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n    \n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.hostName = normalizeHostName(localHost);\n    this.nodeName = generateNodeName(this.hostName, \n                                     this.localHostPort, \n                                     this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.leaderConflictResolveWait = leaderConflictResolveWait;\n    \n    this.clientTimeout = zkClientTimeout;\n    DefaultConnectionStrategy strat = new DefaultConnectionStrategy();\n    String zkACLProviderClass = cc.getConfig().getZkACLProviderClass();\n    ZkACLProvider zkACLProvider = null;\n    if (zkACLProviderClass != null && zkACLProviderClass.trim().length() > 0) {\n      zkACLProvider  = cc.getResourceLoader().newInstance(zkACLProviderClass, ZkACLProvider.class);\n    } else {\n      zkACLProvider = new DefaultZkACLProvider();\n    }\n    \n    String zkCredentialProviderClass = cc.getConfig().getZkCredentialProviderClass();\n    if (zkCredentialProviderClass != null && zkCredentialProviderClass.trim().length() > 0) {\n      strat.setZkCredentialsToAddAutomatically(cc.getResourceLoader().newInstance(zkCredentialProviderClass, ZkCredentialsProvider.class));\n    } else {\n      strat.setZkCredentialsToAddAutomatically(new DefaultZkCredentialsProvider());\n    }\n    \n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, strat,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n          \n          @Override\n          public void command() {\n            log.info(\"ZooKeeper session re-connected ... refreshing core states after session expiration.\");\n\n            try {\n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n              \n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n              \n              cc.cancelCoreRecoveries();\n              \n              registerAllCoresAsDown(registerOnReconnect, false);\n              \n              if (!zkRunOnly) {\n                ElectionContext context = new OverseerElectionContext(zkClient,\n                    overseer, getNodeName());\n                \n                ElectionContext prevContext = overseerElector.getContext();\n                if (prevContext != null) {\n                  prevContext.cancelElection();\n                }\n                \n                overseerElector.setup(context);\n                overseerElector.joinElection(context, true);\n              }\n              \n              zkStateReader.createClusterStateWatchersAndUpdate();\n              \n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n              \n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    // unload solrcores that have been 'failed over'\n                    throwErrorIfReplicaReplaced(descriptor);\n\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n\n              // notify any other objects that need to know when the session was re-connected\n              synchronized (reconnectListeners) {\n                for (OnReconnect listener : reconnectListeners) {\n                  try {\n                    listener.command();\n                  } catch (Exception exc) {\n                    // not much we can do here other than warn in the log\n                    log.warn(\"Error when notifying OnReconnect listener \"+listener+\" after session re-connected.\", exc);\n                  }\n                }\n              }\n\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n          \n        }, new BeforeReconnect() {\n          \n          @Override\n          public void command() {\n            try {\n              ZkController.this.overseer.close();\n            } catch (Exception e) {\n              log.error(\"Error trying to stop any Overseer threads\", e);\n            }\n            markAllAsNotLeader(registerOnReconnect);\n          }\n        }, zkACLProvider);\n    \n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    this.overseerRunningMap = Overseer.getRunningMap(zkClient);\n    this.overseerCompletedMap = Overseer.getCompletedMap(zkClient);\n    this.overseerFailureMap = Overseer.getFailureMap(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n    \n    this.baseURL = zkStateReader.getBaseUrlForNodeName(this.nodeName);\n    \n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","29e08b0fe8c5c0149b9e904e43afc1f270f8a6c3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"368b2f45f347fa0ff807b6474c1b8b78c5cb9e24","date":1415233558,"type":3,"author":"Gregory Chanan","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,int,boolean,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,int,boolean,CurrentCoreDescriptorProvider).mjava","sourceNew":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n                      String localHostContext, int leaderVoteWait, int leaderConflictResolveWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect)\n      throws InterruptedException, TimeoutException, IOException {\n\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n\n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.hostName = normalizeHostName(localHost);\n    this.nodeName = generateNodeName(this.hostName,\n        this.localHostPort,\n        this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.leaderConflictResolveWait = leaderConflictResolveWait;\n\n    this.clientTimeout = zkClientTimeout;\n    DefaultConnectionStrategy strat = new DefaultConnectionStrategy();\n    String zkACLProviderClass = cc.getConfig().getZkACLProviderClass();\n    ZkACLProvider zkACLProvider = null;\n    if (zkACLProviderClass != null && zkACLProviderClass.trim().length() > 0) {\n      zkACLProvider = cc.getResourceLoader().newInstance(zkACLProviderClass, ZkACLProvider.class);\n    } else {\n      zkACLProvider = new DefaultZkACLProvider();\n    }\n\n    String zkCredentialsProviderClass = cc.getConfig().getZkCredentialsProviderClass();\n    if (zkCredentialsProviderClass != null && zkCredentialsProviderClass.trim().length() > 0) {\n      strat.setZkCredentialsToAddAutomatically(cc.getResourceLoader().newInstance(zkCredentialsProviderClass, ZkCredentialsProvider.class));\n    } else {\n      strat.setZkCredentialsToAddAutomatically(new DefaultZkCredentialsProvider());\n    }\n    addOnReconnectListener(getConfigDirListener());\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, strat,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          @Override\n          public void command() {\n            log.info(\"ZooKeeper session re-connected ... refreshing core states after session expiration.\");\n\n            try {\n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n\n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n\n              cc.cancelCoreRecoveries();\n\n              registerAllCoresAsDown(registerOnReconnect, false);\n\n              if (!zkRunOnly) {\n                ElectionContext context = new OverseerElectionContext(zkClient,\n                    overseer, getNodeName());\n\n                ElectionContext prevContext = overseerElector.getContext();\n                if (prevContext != null) {\n                  prevContext.cancelElection();\n                }\n\n                overseerElector.setup(context);\n                overseerElector.joinElection(context, true);\n              }\n\n              zkStateReader.createClusterStateWatchersAndUpdate();\n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n\n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    // unload solrcores that have been 'failed over'\n                    throwErrorIfReplicaReplaced(descriptor);\n\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n\n              // notify any other objects that need to know when the session was re-connected\n              synchronized (reconnectListeners) {\n                for (OnReconnect listener : reconnectListeners) {\n                  try {\n                    listener.command();\n                  } catch (Exception exc) {\n                    // not much we can do here other than warn in the log\n                    log.warn(\"Error when notifying OnReconnect listener \" + listener + \" after session re-connected.\", exc);\n                  }\n                }\n              }\n\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n\n        }, new BeforeReconnect() {\n\n      @Override\n      public void command() {\n        try {\n          ZkController.this.overseer.close();\n        } catch (Exception e) {\n          log.error(\"Error trying to stop any Overseer threads\", e);\n        }\n        markAllAsNotLeader(registerOnReconnect);\n      }\n    }, zkACLProvider);\n\n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    this.overseerRunningMap = Overseer.getRunningMap(zkClient);\n    this.overseerCompletedMap = Overseer.getCompletedMap(zkClient);\n    this.overseerFailureMap = Overseer.getFailureMap(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n\n    this.baseURL = zkStateReader.getBaseUrlForNodeName(this.nodeName);\n\n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n                      String localHostContext, int leaderVoteWait, int leaderConflictResolveWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect)\n      throws InterruptedException, TimeoutException, IOException {\n\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n\n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.hostName = normalizeHostName(localHost);\n    this.nodeName = generateNodeName(this.hostName,\n        this.localHostPort,\n        this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.leaderConflictResolveWait = leaderConflictResolveWait;\n\n    this.clientTimeout = zkClientTimeout;\n    DefaultConnectionStrategy strat = new DefaultConnectionStrategy();\n    String zkACLProviderClass = cc.getConfig().getZkACLProviderClass();\n    ZkACLProvider zkACLProvider = null;\n    if (zkACLProviderClass != null && zkACLProviderClass.trim().length() > 0) {\n      zkACLProvider = cc.getResourceLoader().newInstance(zkACLProviderClass, ZkACLProvider.class);\n    } else {\n      zkACLProvider = new DefaultZkACLProvider();\n    }\n\n    String zkCredentialProviderClass = cc.getConfig().getZkCredentialProviderClass();\n    if (zkCredentialProviderClass != null && zkCredentialProviderClass.trim().length() > 0) {\n      strat.setZkCredentialsToAddAutomatically(cc.getResourceLoader().newInstance(zkCredentialProviderClass, ZkCredentialsProvider.class));\n    } else {\n      strat.setZkCredentialsToAddAutomatically(new DefaultZkCredentialsProvider());\n    }\n    addOnReconnectListener(getConfigDirListener());\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, strat,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          @Override\n          public void command() {\n            log.info(\"ZooKeeper session re-connected ... refreshing core states after session expiration.\");\n\n            try {\n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n\n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n\n              cc.cancelCoreRecoveries();\n\n              registerAllCoresAsDown(registerOnReconnect, false);\n\n              if (!zkRunOnly) {\n                ElectionContext context = new OverseerElectionContext(zkClient,\n                    overseer, getNodeName());\n\n                ElectionContext prevContext = overseerElector.getContext();\n                if (prevContext != null) {\n                  prevContext.cancelElection();\n                }\n\n                overseerElector.setup(context);\n                overseerElector.joinElection(context, true);\n              }\n\n              zkStateReader.createClusterStateWatchersAndUpdate();\n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n\n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    // unload solrcores that have been 'failed over'\n                    throwErrorIfReplicaReplaced(descriptor);\n\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n\n              // notify any other objects that need to know when the session was re-connected\n              synchronized (reconnectListeners) {\n                for (OnReconnect listener : reconnectListeners) {\n                  try {\n                    listener.command();\n                  } catch (Exception exc) {\n                    // not much we can do here other than warn in the log\n                    log.warn(\"Error when notifying OnReconnect listener \" + listener + \" after session re-connected.\", exc);\n                  }\n                }\n              }\n\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n\n        }, new BeforeReconnect() {\n\n      @Override\n      public void command() {\n        try {\n          ZkController.this.overseer.close();\n        } catch (Exception e) {\n          log.error(\"Error trying to stop any Overseer threads\", e);\n        }\n        markAllAsNotLeader(registerOnReconnect);\n      }\n    }, zkACLProvider);\n\n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    this.overseerRunningMap = Overseer.getRunningMap(zkClient);\n    this.overseerCompletedMap = Overseer.getCompletedMap(zkClient);\n    this.overseerFailureMap = Overseer.getFailureMap(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n\n    this.baseURL = zkStateReader.getBaseUrlForNodeName(this.nodeName);\n\n    init(registerOnReconnect);\n  }\n\n","bugFix":["c83f985d9828d30801541f1eed26aa3169646baf"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e15199583d3635cb940942caed05132dd6c4c7c6","date":1424875551,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,CloudConfig,CurrentCoreDescriptorProvider).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,int,boolean,CurrentCoreDescriptorProvider).mjava","sourceNew":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientConnectTimeout, CloudConfig cloudConfig, final CurrentCoreDescriptorProvider registerOnReconnect)\n      throws InterruptedException, TimeoutException, IOException {\n\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n\n    this.cloudConfig = cloudConfig;\n\n    this.genericCoreNodeNames = cloudConfig.getGenericCoreNodeNames();\n\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    String localHostContext = trimLeadingAndTrailingSlashes(cloudConfig.getSolrHostContext());\n\n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = cloudConfig.getSolrHostPort();\n    this.hostName = normalizeHostName(cloudConfig.getHost());\n    this.nodeName = generateNodeName(this.hostName, Integer.toString(this.localHostPort), localHostContext);\n\n    this.leaderVoteWait = cloudConfig.getLeaderVoteWait();\n    this.leaderConflictResolveWait = cloudConfig.getLeaderConflictResolveWait();\n\n    this.clientTimeout = cloudConfig.getZkClientTimeout();\n    DefaultConnectionStrategy strat = new DefaultConnectionStrategy();\n    String zkACLProviderClass = cloudConfig.getZkACLProviderClass();\n    ZkACLProvider zkACLProvider = null;\n    if (zkACLProviderClass != null && zkACLProviderClass.trim().length() > 0) {\n      zkACLProvider = cc.getResourceLoader().newInstance(zkACLProviderClass, ZkACLProvider.class);\n    } else {\n      zkACLProvider = new DefaultZkACLProvider();\n    }\n\n    String zkCredentialsProviderClass = cloudConfig.getZkCredentialsProviderClass();\n    if (zkCredentialsProviderClass != null && zkCredentialsProviderClass.trim().length() > 0) {\n      strat.setZkCredentialsToAddAutomatically(cc.getResourceLoader().newInstance(zkCredentialsProviderClass, ZkCredentialsProvider.class));\n    } else {\n      strat.setZkCredentialsToAddAutomatically(new DefaultZkCredentialsProvider());\n    }\n    addOnReconnectListener(getConfigDirListener());\n\n    zkClient = new SolrZkClient(zkServerAddress, clientTimeout, zkClientConnectTimeout, strat,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          @Override\n          public void command() {\n            log.info(\"ZooKeeper session re-connected ... refreshing core states after session expiration.\");\n\n            try {\n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n\n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n\n              cc.cancelCoreRecoveries();\n\n              registerAllCoresAsDown(registerOnReconnect, false);\n\n              if (!zkRunOnly) {\n                ElectionContext context = new OverseerElectionContext(zkClient,\n                    overseer, getNodeName());\n\n                ElectionContext prevContext = overseerElector.getContext();\n                if (prevContext != null) {\n                  prevContext.cancelElection();\n                }\n\n                overseerElector.setup(context);\n                overseerElector.joinElection(context, true);\n              }\n\n              zkStateReader.createClusterStateWatchersAndUpdate();\n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n\n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    // unload solrcores that have been 'failed over'\n                    throwErrorIfReplicaReplaced(descriptor);\n\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n\n              // notify any other objects that need to know when the session was re-connected\n              synchronized (reconnectListeners) {\n                for (OnReconnect listener : reconnectListeners) {\n                  try {\n                    listener.command();\n                  } catch (Exception exc) {\n                    // not much we can do here other than warn in the log\n                    log.warn(\"Error when notifying OnReconnect listener \" + listener + \" after session re-connected.\", exc);\n                  }\n                }\n              }\n\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n\n        }, new BeforeReconnect() {\n\n      @Override\n      public void command() {\n        try {\n          ZkController.this.overseer.close();\n        } catch (Exception e) {\n          log.error(\"Error trying to stop any Overseer threads\", e);\n        }\n        markAllAsNotLeader(registerOnReconnect);\n      }\n    }, zkACLProvider);\n\n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    this.overseerRunningMap = Overseer.getRunningMap(zkClient);\n    this.overseerCompletedMap = Overseer.getCompletedMap(zkClient);\n    this.overseerFailureMap = Overseer.getFailureMap(zkClient);\n    cmdExecutor = new ZkCmdExecutor(clientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n\n    this.baseURL = zkStateReader.getBaseUrlForNodeName(this.nodeName);\n\n    init(registerOnReconnect);\n  }\n\n","sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n                      String localHostContext, int leaderVoteWait, int leaderConflictResolveWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect)\n      throws InterruptedException, TimeoutException, IOException {\n\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n\n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.hostName = normalizeHostName(localHost);\n    this.nodeName = generateNodeName(this.hostName,\n        this.localHostPort,\n        this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.leaderConflictResolveWait = leaderConflictResolveWait;\n\n    this.clientTimeout = zkClientTimeout;\n    DefaultConnectionStrategy strat = new DefaultConnectionStrategy();\n    String zkACLProviderClass = cc.getConfig().getZkACLProviderClass();\n    ZkACLProvider zkACLProvider = null;\n    if (zkACLProviderClass != null && zkACLProviderClass.trim().length() > 0) {\n      zkACLProvider = cc.getResourceLoader().newInstance(zkACLProviderClass, ZkACLProvider.class);\n    } else {\n      zkACLProvider = new DefaultZkACLProvider();\n    }\n\n    String zkCredentialsProviderClass = cc.getConfig().getZkCredentialsProviderClass();\n    if (zkCredentialsProviderClass != null && zkCredentialsProviderClass.trim().length() > 0) {\n      strat.setZkCredentialsToAddAutomatically(cc.getResourceLoader().newInstance(zkCredentialsProviderClass, ZkCredentialsProvider.class));\n    } else {\n      strat.setZkCredentialsToAddAutomatically(new DefaultZkCredentialsProvider());\n    }\n    addOnReconnectListener(getConfigDirListener());\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, strat,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          @Override\n          public void command() {\n            log.info(\"ZooKeeper session re-connected ... refreshing core states after session expiration.\");\n\n            try {\n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n\n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n\n              cc.cancelCoreRecoveries();\n\n              registerAllCoresAsDown(registerOnReconnect, false);\n\n              if (!zkRunOnly) {\n                ElectionContext context = new OverseerElectionContext(zkClient,\n                    overseer, getNodeName());\n\n                ElectionContext prevContext = overseerElector.getContext();\n                if (prevContext != null) {\n                  prevContext.cancelElection();\n                }\n\n                overseerElector.setup(context);\n                overseerElector.joinElection(context, true);\n              }\n\n              zkStateReader.createClusterStateWatchersAndUpdate();\n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n\n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    // unload solrcores that have been 'failed over'\n                    throwErrorIfReplicaReplaced(descriptor);\n\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n\n              // notify any other objects that need to know when the session was re-connected\n              synchronized (reconnectListeners) {\n                for (OnReconnect listener : reconnectListeners) {\n                  try {\n                    listener.command();\n                  } catch (Exception exc) {\n                    // not much we can do here other than warn in the log\n                    log.warn(\"Error when notifying OnReconnect listener \" + listener + \" after session re-connected.\", exc);\n                  }\n                }\n              }\n\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n\n        }, new BeforeReconnect() {\n\n      @Override\n      public void command() {\n        try {\n          ZkController.this.overseer.close();\n        } catch (Exception e) {\n          log.error(\"Error trying to stop any Overseer threads\", e);\n        }\n        markAllAsNotLeader(registerOnReconnect);\n      }\n    }, zkACLProvider);\n\n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    this.overseerRunningMap = Overseer.getRunningMap(zkClient);\n    this.overseerCompletedMap = Overseer.getCompletedMap(zkClient);\n    this.overseerFailureMap = Overseer.getFailureMap(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n\n    this.baseURL = zkStateReader.getBaseUrlForNodeName(this.nodeName);\n\n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":4,"author":"Ryan Ernst","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#ZkController(CoreContainer,String,int,int,String,String,String,int,int,boolean,CurrentCoreDescriptorProvider).mjava","sourceNew":null,"sourceOld":"  public ZkController(final CoreContainer cc, String zkServerAddress, int zkClientTimeout, int zkClientConnectTimeout, String localHost, String locaHostPort,\n                      String localHostContext, int leaderVoteWait, int leaderConflictResolveWait, boolean genericCoreNodeNames, final CurrentCoreDescriptorProvider registerOnReconnect)\n      throws InterruptedException, TimeoutException, IOException {\n\n    if (cc == null) throw new IllegalArgumentException(\"CoreContainer cannot be null.\");\n    this.cc = cc;\n    this.genericCoreNodeNames = genericCoreNodeNames;\n    // be forgiving and strip this off leading/trailing slashes\n    // this allows us to support users specifying hostContext=\"/\" in \n    // solr.xml to indicate the root context, instead of hostContext=\"\" \n    // which means the default of \"solr\"\n    localHostContext = trimLeadingAndTrailingSlashes(localHostContext);\n\n    this.zkServerAddress = zkServerAddress;\n    this.localHostPort = locaHostPort;\n    this.localHostContext = localHostContext;\n    this.hostName = normalizeHostName(localHost);\n    this.nodeName = generateNodeName(this.hostName,\n        this.localHostPort,\n        this.localHostContext);\n\n    this.leaderVoteWait = leaderVoteWait;\n    this.leaderConflictResolveWait = leaderConflictResolveWait;\n\n    this.clientTimeout = zkClientTimeout;\n    DefaultConnectionStrategy strat = new DefaultConnectionStrategy();\n    String zkACLProviderClass = cc.getConfig().getZkACLProviderClass();\n    ZkACLProvider zkACLProvider = null;\n    if (zkACLProviderClass != null && zkACLProviderClass.trim().length() > 0) {\n      zkACLProvider = cc.getResourceLoader().newInstance(zkACLProviderClass, ZkACLProvider.class);\n    } else {\n      zkACLProvider = new DefaultZkACLProvider();\n    }\n\n    String zkCredentialsProviderClass = cc.getConfig().getZkCredentialsProviderClass();\n    if (zkCredentialsProviderClass != null && zkCredentialsProviderClass.trim().length() > 0) {\n      strat.setZkCredentialsToAddAutomatically(cc.getResourceLoader().newInstance(zkCredentialsProviderClass, ZkCredentialsProvider.class));\n    } else {\n      strat.setZkCredentialsToAddAutomatically(new DefaultZkCredentialsProvider());\n    }\n    addOnReconnectListener(getConfigDirListener());\n\n    zkClient = new SolrZkClient(zkServerAddress, zkClientTimeout,\n        zkClientConnectTimeout, strat,\n        // on reconnect, reload cloud info\n        new OnReconnect() {\n\n          @Override\n          public void command() {\n            log.info(\"ZooKeeper session re-connected ... refreshing core states after session expiration.\");\n\n            try {\n              // this is troublesome - we dont want to kill anything the old\n              // leader accepted\n              // though I guess sync will likely get those updates back? But\n              // only if\n              // he is involved in the sync, and he certainly may not be\n              // ExecutorUtil.shutdownAndAwaitTermination(cc.getCmdDistribExecutor());\n              // we need to create all of our lost watches\n\n              // seems we dont need to do this again...\n              // Overseer.createClientNodes(zkClient, getNodeName());\n\n              cc.cancelCoreRecoveries();\n\n              registerAllCoresAsDown(registerOnReconnect, false);\n\n              if (!zkRunOnly) {\n                ElectionContext context = new OverseerElectionContext(zkClient,\n                    overseer, getNodeName());\n\n                ElectionContext prevContext = overseerElector.getContext();\n                if (prevContext != null) {\n                  prevContext.cancelElection();\n                }\n\n                overseerElector.setup(context);\n                overseerElector.joinElection(context, true);\n              }\n\n              zkStateReader.createClusterStateWatchersAndUpdate();\n\n              // we have to register as live first to pick up docs in the buffer\n              createEphemeralLiveNode();\n\n              List<CoreDescriptor> descriptors = registerOnReconnect\n                  .getCurrentDescriptors();\n              // re register all descriptors\n              if (descriptors != null) {\n                for (CoreDescriptor descriptor : descriptors) {\n                  // TODO: we need to think carefully about what happens when it\n                  // was\n                  // a leader that was expired - as well as what to do about\n                  // leaders/overseers\n                  // with connection loss\n                  try {\n                    // unload solrcores that have been 'failed over'\n                    throwErrorIfReplicaReplaced(descriptor);\n\n                    register(descriptor.getName(), descriptor, true, true);\n                  } catch (Exception e) {\n                    SolrException.log(log, \"Error registering SolrCore\", e);\n                  }\n                }\n              }\n\n              // notify any other objects that need to know when the session was re-connected\n              synchronized (reconnectListeners) {\n                for (OnReconnect listener : reconnectListeners) {\n                  try {\n                    listener.command();\n                  } catch (Exception exc) {\n                    // not much we can do here other than warn in the log\n                    log.warn(\"Error when notifying OnReconnect listener \" + listener + \" after session re-connected.\", exc);\n                  }\n                }\n              }\n\n            } catch (InterruptedException e) {\n              // Restore the interrupted status\n              Thread.currentThread().interrupt();\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            } catch (Exception e) {\n              SolrException.log(log, \"\", e);\n              throw new ZooKeeperException(\n                  SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n            }\n          }\n\n        }, new BeforeReconnect() {\n\n      @Override\n      public void command() {\n        try {\n          ZkController.this.overseer.close();\n        } catch (Exception e) {\n          log.error(\"Error trying to stop any Overseer threads\", e);\n        }\n        markAllAsNotLeader(registerOnReconnect);\n      }\n    }, zkACLProvider);\n\n    this.overseerJobQueue = Overseer.getInQueue(zkClient);\n    this.overseerCollectionQueue = Overseer.getCollectionQueue(zkClient);\n    this.overseerRunningMap = Overseer.getRunningMap(zkClient);\n    this.overseerCompletedMap = Overseer.getCompletedMap(zkClient);\n    this.overseerFailureMap = Overseer.getFailureMap(zkClient);\n    cmdExecutor = new ZkCmdExecutor(zkClientTimeout);\n    leaderElector = new LeaderElector(zkClient);\n    zkStateReader = new ZkStateReader(zkClient);\n\n    this.baseURL = zkStateReader.getBaseUrlForNodeName(this.nodeName);\n\n    init(registerOnReconnect);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"531fe719c7218235a679452eb3d137bfd8fc6af1":["1596015c8bad249c0b9a52182de1d47e1d56fdde"],"96ea64d994d340044e0d57aeb6a5871539d10ca5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a0b5db1c20d7a379233ae3955449a9e42caef007"],"058f5a3debcfa0ea477da3eabb4cbe2ec0fac211":["a0b5db1c20d7a379233ae3955449a9e42caef007"],"d9a47902d6207303f5ed3e7aaca62ca33433af66":["c83f985d9828d30801541f1eed26aa3169646baf","1596015c8bad249c0b9a52182de1d47e1d56fdde"],"a0b5db1c20d7a379233ae3955449a9e42caef007":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e15199583d3635cb940942caed05132dd6c4c7c6":["368b2f45f347fa0ff807b6474c1b8b78c5cb9e24"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["368b2f45f347fa0ff807b6474c1b8b78c5cb9e24","e15199583d3635cb940942caed05132dd6c4c7c6"],"1596015c8bad249c0b9a52182de1d47e1d56fdde":["c83f985d9828d30801541f1eed26aa3169646baf"],"7a6cdd05fdf31629707e61bf652dd5e04be675ee":["058f5a3debcfa0ea477da3eabb4cbe2ec0fac211"],"0ad7bdba3e91cf3373cda2e52239cb761fc0b452":["7a6cdd05fdf31629707e61bf652dd5e04be675ee"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"368b2f45f347fa0ff807b6474c1b8b78c5cb9e24":["531fe719c7218235a679452eb3d137bfd8fc6af1"],"c83f985d9828d30801541f1eed26aa3169646baf":["0ad7bdba3e91cf3373cda2e52239cb761fc0b452"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e15199583d3635cb940942caed05132dd6c4c7c6"]},"commit2Childs":{"531fe719c7218235a679452eb3d137bfd8fc6af1":["368b2f45f347fa0ff807b6474c1b8b78c5cb9e24"],"96ea64d994d340044e0d57aeb6a5871539d10ca5":[],"058f5a3debcfa0ea477da3eabb4cbe2ec0fac211":["7a6cdd05fdf31629707e61bf652dd5e04be675ee"],"d9a47902d6207303f5ed3e7aaca62ca33433af66":[],"a0b5db1c20d7a379233ae3955449a9e42caef007":["96ea64d994d340044e0d57aeb6a5871539d10ca5","058f5a3debcfa0ea477da3eabb4cbe2ec0fac211"],"e15199583d3635cb940942caed05132dd6c4c7c6":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"1596015c8bad249c0b9a52182de1d47e1d56fdde":["531fe719c7218235a679452eb3d137bfd8fc6af1","d9a47902d6207303f5ed3e7aaca62ca33433af66"],"7a6cdd05fdf31629707e61bf652dd5e04be675ee":["0ad7bdba3e91cf3373cda2e52239cb761fc0b452"],"0ad7bdba3e91cf3373cda2e52239cb761fc0b452":["c83f985d9828d30801541f1eed26aa3169646baf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["96ea64d994d340044e0d57aeb6a5871539d10ca5","a0b5db1c20d7a379233ae3955449a9e42caef007"],"368b2f45f347fa0ff807b6474c1b8b78c5cb9e24":["e15199583d3635cb940942caed05132dd6c4c7c6","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"c83f985d9828d30801541f1eed26aa3169646baf":["d9a47902d6207303f5ed3e7aaca62ca33433af66","1596015c8bad249c0b9a52182de1d47e1d56fdde"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["96ea64d994d340044e0d57aeb6a5871539d10ca5","d9a47902d6207303f5ed3e7aaca62ca33433af66","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}