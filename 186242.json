{"path":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","commits":[{"id":"50e7972fe4865715af8951d4ba15555e3426fc5d","date":1115024647,"type":0,"author":"Erik Hatcher","isMerge":false,"pathNew":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","pathOld":"/dev/null","sourceNew":"\t/**\n\t * Convenience method that efficiently returns the relevance score by\n\t * matching this index against the given Lucene query expression.\n\t * \n\t * @param query\n\t *            an arbitrary Lucene query to run against this index\n\t * @return the relevance score of the matchmaking; A number in the range\n\t *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n\t *         the better the match.\n\t * @see org.apache.lucene.queryParser.QueryParser#parse(String, String,\n\t *      Analyzer)\n\t */\n\tpublic float search(Query query) {\n\t\tif (query == null) \n\t\t\tthrow new IllegalArgumentException(\"query must not be null\");\n\t\t\n\t\tif (fields.size() == 0) return 0.0f; // nothing to do\n\t\tSearcher searcher = createSearcher();\n\t\ttry {\n\t\t\tfinal float[] scores = new float[1]; // inits to 0.0f (no match)\n\t\t\tsearcher.search(query, new HitCollector() {\n\t\t\t\tpublic void collect(int doc, float score) {\n\t\t\t\t\tscores[0] = score;\n\t\t\t\t}\n\t\t\t});\n\t\t\tfloat score = scores[0];\n\t\t\treturn score;\n\t\t} catch (IOException e) { // can never happen (RAMDirectory)\n\t\t\tthrow new RuntimeException(e);\n\t\t} finally {\n\t\t\t// searcher.close();\n\t\t\t/*\n\t\t\t * Note that it is harmless and important for good performance to\n\t\t\t * NOT close the index reader!!! This avoids all sorts of\n\t\t\t * unnecessary baggage and locking in the Lucene IndexReader\n\t\t\t * superclass, all of which is completely unnecessary for this main\n\t\t\t * memory index data structure without thread-safety claims.\n\t\t\t * \n\t\t\t * Wishing IndexReader would be an interface...\n\t\t\t * \n\t\t\t * Actually with the new tight createSearcher() API auto-closing is now\n\t\t\t * made impossible, hence searcher.close() would be harmless...\n\t\t\t */\n\t\t}\t\t\n\t}\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c8f14489323057ef6de92ba5ea2d0cfe6e34755f","date":1120167605,"type":3,"author":"Mark Harwood","isMerge":false,"pathNew":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","sourceNew":"\t/**\r\n\t * Convenience method that efficiently returns the relevance score by\r\n\t * matching this index against the given Lucene query expression.\r\n\t * \r\n\t * @param query\r\n\t *            an arbitrary Lucene query to run against this index\r\n\t * @return the relevance score of the matchmaking; A number in the range\r\n\t *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\r\n\t *         the better the match.\r\n\t * @see org.apache.lucene.queryParser.QueryParser#parse(String, String,\r\n\t *      Analyzer)\r\n\t */\r\n\tpublic float search(Query query) {\r\n\t\tif (query == null) \r\n\t\t\tthrow new IllegalArgumentException(\"query must not be null\");\r\n\t\t\r\n\t\tSearcher searcher = createSearcher();\r\n\t\ttry {\r\n\t\t\tfinal float[] scores = new float[1]; // inits to 0.0f (no match)\r\n\t\t\tsearcher.search(query, new HitCollector() {\r\n\t\t\t\tpublic void collect(int doc, float score) {\r\n\t\t\t\t\tscores[0] = score;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tfloat score = scores[0];\r\n\t\t\treturn score;\r\n\t\t} catch (IOException e) { // can never happen (RAMDirectory)\r\n\t\t\tthrow new RuntimeException(e);\r\n\t\t} finally {\r\n\t\t\t// searcher.close();\r\n\t\t\t/*\r\n\t\t\t * Note that it is harmless and important for good performance to\r\n\t\t\t * NOT close the index reader!!! This avoids all sorts of\r\n\t\t\t * unnecessary baggage and locking in the Lucene IndexReader\r\n\t\t\t * superclass, all of which is completely unnecessary for this main\r\n\t\t\t * memory index data structure without thread-safety claims.\r\n\t\t\t * \r\n\t\t\t * Wishing IndexReader would be an interface...\r\n\t\t\t * \r\n\t\t\t * Actually with the new tight createSearcher() API auto-closing is now\r\n\t\t\t * made impossible, hence searcher.close() would be harmless...\r\n\t\t\t */\r\n\t\t}\t\t\r\n\t}\r\n\n","sourceOld":"\t/**\n\t * Convenience method that efficiently returns the relevance score by\n\t * matching this index against the given Lucene query expression.\n\t * \n\t * @param query\n\t *            an arbitrary Lucene query to run against this index\n\t * @return the relevance score of the matchmaking; A number in the range\n\t *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n\t *         the better the match.\n\t * @see org.apache.lucene.queryParser.QueryParser#parse(String, String,\n\t *      Analyzer)\n\t */\n\tpublic float search(Query query) {\n\t\tif (query == null) \n\t\t\tthrow new IllegalArgumentException(\"query must not be null\");\n\t\t\n\t\tif (fields.size() == 0) return 0.0f; // nothing to do\n\t\tSearcher searcher = createSearcher();\n\t\ttry {\n\t\t\tfinal float[] scores = new float[1]; // inits to 0.0f (no match)\n\t\t\tsearcher.search(query, new HitCollector() {\n\t\t\t\tpublic void collect(int doc, float score) {\n\t\t\t\t\tscores[0] = score;\n\t\t\t\t}\n\t\t\t});\n\t\t\tfloat score = scores[0];\n\t\t\treturn score;\n\t\t} catch (IOException e) { // can never happen (RAMDirectory)\n\t\t\tthrow new RuntimeException(e);\n\t\t} finally {\n\t\t\t// searcher.close();\n\t\t\t/*\n\t\t\t * Note that it is harmless and important for good performance to\n\t\t\t * NOT close the index reader!!! This avoids all sorts of\n\t\t\t * unnecessary baggage and locking in the Lucene IndexReader\n\t\t\t * superclass, all of which is completely unnecessary for this main\n\t\t\t * memory index data structure without thread-safety claims.\n\t\t\t * \n\t\t\t * Wishing IndexReader would be an interface...\n\t\t\t * \n\t\t\t * Actually with the new tight createSearcher() API auto-closing is now\n\t\t\t * made impossible, hence searcher.close() would be harmless...\n\t\t\t */\n\t\t}\t\t\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"35dd40ede4dd66fa47506858c4a073d295c5a76e","date":1133587328,"type":4,"author":"Wolfgang Hoschek","isMerge":false,"pathNew":"/dev/null","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","sourceNew":null,"sourceOld":"\t/**\r\n\t * Convenience method that efficiently returns the relevance score by\r\n\t * matching this index against the given Lucene query expression.\r\n\t * \r\n\t * @param query\r\n\t *            an arbitrary Lucene query to run against this index\r\n\t * @return the relevance score of the matchmaking; A number in the range\r\n\t *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\r\n\t *         the better the match.\r\n\t * @see org.apache.lucene.queryParser.QueryParser#parse(String, String,\r\n\t *      Analyzer)\r\n\t */\r\n\tpublic float search(Query query) {\r\n\t\tif (query == null) \r\n\t\t\tthrow new IllegalArgumentException(\"query must not be null\");\r\n\t\t\r\n\t\tSearcher searcher = createSearcher();\r\n\t\ttry {\r\n\t\t\tfinal float[] scores = new float[1]; // inits to 0.0f (no match)\r\n\t\t\tsearcher.search(query, new HitCollector() {\r\n\t\t\t\tpublic void collect(int doc, float score) {\r\n\t\t\t\t\tscores[0] = score;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tfloat score = scores[0];\r\n\t\t\treturn score;\r\n\t\t} catch (IOException e) { // can never happen (RAMDirectory)\r\n\t\t\tthrow new RuntimeException(e);\r\n\t\t} finally {\r\n\t\t\t// searcher.close();\r\n\t\t\t/*\r\n\t\t\t * Note that it is harmless and important for good performance to\r\n\t\t\t * NOT close the index reader!!! This avoids all sorts of\r\n\t\t\t * unnecessary baggage and locking in the Lucene IndexReader\r\n\t\t\t * superclass, all of which is completely unnecessary for this main\r\n\t\t\t * memory index data structure without thread-safety claims.\r\n\t\t\t * \r\n\t\t\t * Wishing IndexReader would be an interface...\r\n\t\t\t * \r\n\t\t\t * Actually with the new tight createSearcher() API auto-closing is now\r\n\t\t\t * made impossible, hence searcher.close() would be harmless...\r\n\t\t\t */\r\n\t\t}\t\t\r\n\t}\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a93e1e4a21be8ebb98e53e6933412a363931faa1","date":1133587471,"type":0,"author":"Wolfgang Hoschek","isMerge":false,"pathNew":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","pathOld":"/dev/null","sourceNew":"\t/**\n\t * Convenience method that efficiently returns the relevance score by\n\t * matching this index against the given Lucene query expression.\n\t * \n\t * @param query\n\t *            an arbitrary Lucene query to run against this index\n\t * @return the relevance score of the matchmaking; A number in the range\n\t *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n\t *         the better the match.\n\t * @see org.apache.lucene.queryParser.QueryParser#parse(String, String,\n\t *      Analyzer)\n\t */\n\tpublic float search(Query query) {\n\t\tif (query == null) \n\t\t\tthrow new IllegalArgumentException(\"query must not be null\");\n\t\t\n\t\tSearcher searcher = createSearcher();\n\t\ttry {\n\t\t\tfinal float[] scores = new float[1]; // inits to 0.0f (no match)\n\t\t\tsearcher.search(query, new HitCollector() {\n\t\t\t\tpublic void collect(int doc, float score) {\n\t\t\t\t\tscores[0] = score;\n\t\t\t\t}\n\t\t\t});\n\t\t\tfloat score = scores[0];\n\t\t\treturn score;\n\t\t} catch (IOException e) { // can never happen (RAMDirectory)\n\t\t\tthrow new RuntimeException(e);\n\t\t} finally {\n\t\t\t// searcher.close();\n\t\t\t/*\n\t\t\t * Note that it is harmless and important for good performance to\n\t\t\t * NOT close the index reader!!! This avoids all sorts of\n\t\t\t * unnecessary baggage and locking in the Lucene IndexReader\n\t\t\t * superclass, all of which is completely unnecessary for this main\n\t\t\t * memory index data structure without thread-safety claims.\n\t\t\t * \n\t\t\t * Wishing IndexReader would be an interface...\n\t\t\t * \n\t\t\t * Actually with the new tight createSearcher() API auto-closing is now\n\t\t\t * made impossible, hence searcher.close() would be harmless...\n\t\t\t */\n\t\t}\t\t\n\t}\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b08308242cb802f3a154e260d3881c2ed523c52b","date":1133766662,"type":3,"author":"Wolfgang Hoschek","isMerge":false,"pathNew":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","sourceNew":"\t/**\n\t * Convenience method that efficiently returns the relevance score by\n\t * matching this index against the given Lucene query expression.\n\t * \n\t * @param query\n\t *            an arbitrary Lucene query to run against this index\n\t * @return the relevance score of the matchmaking; A number in the range\n\t *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n\t *         the better the match.\n\t * @see org.apache.lucene.queryParser.QueryParser#parse(String)\n\t */\n\tpublic float search(Query query) {\n\t\tif (query == null) \n\t\t\tthrow new IllegalArgumentException(\"query must not be null\");\n\t\t\n\t\tSearcher searcher = createSearcher();\n\t\ttry {\n\t\t\tfinal float[] scores = new float[1]; // inits to 0.0f (no match)\n\t\t\tsearcher.search(query, new HitCollector() {\n\t\t\t\tpublic void collect(int doc, float score) {\n\t\t\t\t\tscores[0] = score;\n\t\t\t\t}\n\t\t\t});\n\t\t\tfloat score = scores[0];\n\t\t\treturn score;\n\t\t} catch (IOException e) { // can never happen (RAMDirectory)\n\t\t\tthrow new RuntimeException(e);\n\t\t} finally {\n\t\t\t// searcher.close();\n\t\t\t/*\n\t\t\t * Note that it is harmless and important for good performance to\n\t\t\t * NOT close the index reader!!! This avoids all sorts of\n\t\t\t * unnecessary baggage and locking in the Lucene IndexReader\n\t\t\t * superclass, all of which is completely unnecessary for this main\n\t\t\t * memory index data structure without thread-safety claims.\n\t\t\t * \n\t\t\t * Wishing IndexReader would be an interface...\n\t\t\t * \n\t\t\t * Actually with the new tight createSearcher() API auto-closing is now\n\t\t\t * made impossible, hence searcher.close() would be harmless...\n\t\t\t */\n\t\t}\t\t\n\t}\n\n","sourceOld":"\t/**\n\t * Convenience method that efficiently returns the relevance score by\n\t * matching this index against the given Lucene query expression.\n\t * \n\t * @param query\n\t *            an arbitrary Lucene query to run against this index\n\t * @return the relevance score of the matchmaking; A number in the range\n\t *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n\t *         the better the match.\n\t * @see org.apache.lucene.queryParser.QueryParser#parse(String, String,\n\t *      Analyzer)\n\t */\n\tpublic float search(Query query) {\n\t\tif (query == null) \n\t\t\tthrow new IllegalArgumentException(\"query must not be null\");\n\t\t\n\t\tSearcher searcher = createSearcher();\n\t\ttry {\n\t\t\tfinal float[] scores = new float[1]; // inits to 0.0f (no match)\n\t\t\tsearcher.search(query, new HitCollector() {\n\t\t\t\tpublic void collect(int doc, float score) {\n\t\t\t\t\tscores[0] = score;\n\t\t\t\t}\n\t\t\t});\n\t\t\tfloat score = scores[0];\n\t\t\treturn score;\n\t\t} catch (IOException e) { // can never happen (RAMDirectory)\n\t\t\tthrow new RuntimeException(e);\n\t\t} finally {\n\t\t\t// searcher.close();\n\t\t\t/*\n\t\t\t * Note that it is harmless and important for good performance to\n\t\t\t * NOT close the index reader!!! This avoids all sorts of\n\t\t\t * unnecessary baggage and locking in the Lucene IndexReader\n\t\t\t * superclass, all of which is completely unnecessary for this main\n\t\t\t * memory index data structure without thread-safety claims.\n\t\t\t * \n\t\t\t * Wishing IndexReader would be an interface...\n\t\t\t * \n\t\t\t * Actually with the new tight createSearcher() API auto-closing is now\n\t\t\t * made impossible, hence searcher.close() would be harmless...\n\t\t\t */\n\t\t}\t\t\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7f68e24227d5556d33ee6d586fd9010cd9ff8bec","date":1150091176,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","sourceNew":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   * @see org.apache.lucene.queryParser.QueryParser#parse(String)\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    Searcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new HitCollector() {\n        public void collect(int doc, float score) {\n          scores[0] = score;\n        }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless...\n       */\n    }   \n  }\n\n","sourceOld":"\t/**\n\t * Convenience method that efficiently returns the relevance score by\n\t * matching this index against the given Lucene query expression.\n\t * \n\t * @param query\n\t *            an arbitrary Lucene query to run against this index\n\t * @return the relevance score of the matchmaking; A number in the range\n\t *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n\t *         the better the match.\n\t * @see org.apache.lucene.queryParser.QueryParser#parse(String)\n\t */\n\tpublic float search(Query query) {\n\t\tif (query == null) \n\t\t\tthrow new IllegalArgumentException(\"query must not be null\");\n\t\t\n\t\tSearcher searcher = createSearcher();\n\t\ttry {\n\t\t\tfinal float[] scores = new float[1]; // inits to 0.0f (no match)\n\t\t\tsearcher.search(query, new HitCollector() {\n\t\t\t\tpublic void collect(int doc, float score) {\n\t\t\t\t\tscores[0] = score;\n\t\t\t\t}\n\t\t\t});\n\t\t\tfloat score = scores[0];\n\t\t\treturn score;\n\t\t} catch (IOException e) { // can never happen (RAMDirectory)\n\t\t\tthrow new RuntimeException(e);\n\t\t} finally {\n\t\t\t// searcher.close();\n\t\t\t/*\n\t\t\t * Note that it is harmless and important for good performance to\n\t\t\t * NOT close the index reader!!! This avoids all sorts of\n\t\t\t * unnecessary baggage and locking in the Lucene IndexReader\n\t\t\t * superclass, all of which is completely unnecessary for this main\n\t\t\t * memory index data structure without thread-safety claims.\n\t\t\t * \n\t\t\t * Wishing IndexReader would be an interface...\n\t\t\t * \n\t\t\t * Actually with the new tight createSearcher() API auto-closing is now\n\t\t\t * made impossible, hence searcher.close() would be harmless...\n\t\t\t */\n\t\t}\t\t\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f30297381762542dcb61724b89bc3b143bafbb68","date":1164188889,"type":3,"author":"Wolfgang Hoschek","isMerge":false,"pathNew":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","sourceNew":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   * @see org.apache.lucene.queryParser.QueryParser#parse(String)\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    Searcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new HitCollector() {\n        public void collect(int doc, float score) {\n          scores[0] = score;\n        }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","sourceOld":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   * @see org.apache.lucene.queryParser.QueryParser#parse(String)\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    Searcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new HitCollector() {\n        public void collect(int doc, float score) {\n          scores[0] = score;\n        }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless...\n       */\n    }   \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"24677ebe836c841fc7c198375595e77fcbc11468","date":1251328462,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","sourceNew":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    Searcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new HitCollector() {\n        public void collect(int doc, float score) {\n          scores[0] = score;\n        }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","sourceOld":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   * @see org.apache.lucene.queryParser.QueryParser#parse(String)\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    Searcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new HitCollector() {\n        public void collect(int doc, float score) {\n          scores[0] = score;\n        }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61cbcf396559d597a914594d7e2830c142ecfd91","date":1255444081,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","sourceNew":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    Searcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new Collector() {\n        private Scorer scorer;\n\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n\n        public void setNextReader(IndexReader reader, int docBase) { }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","sourceOld":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    Searcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new HitCollector() {\n        public void collect(int doc, float score) {\n          scores[0] = score;\n        }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","bugFix":null,"bugIntro":["781239fc84d36be12b84e4d3e2618f5f07a182e3","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d57eb7c98c08c03af6e4cd83509df31c81ac16af","date":1257684312,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","sourceNew":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    Searcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new Collector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n\n        @Override\n        public void setNextReader(IndexReader reader, int docBase) { }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","sourceOld":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    Searcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new Collector() {\n        private Scorer scorer;\n\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n\n        public void setNextReader(IndexReader reader, int docBase) { }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","sourceNew":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    Searcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new Collector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n\n        @Override\n        public void setNextReader(IndexReader reader, int docBase) { }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","sourceOld":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    Searcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new Collector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n\n        @Override\n        public void setNextReader(IndexReader reader, int docBase) { }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"24677ebe836c841fc7c198375595e77fcbc11468":["f30297381762542dcb61724b89bc3b143bafbb68"],"35dd40ede4dd66fa47506858c4a073d295c5a76e":["c8f14489323057ef6de92ba5ea2d0cfe6e34755f"],"f30297381762542dcb61724b89bc3b143bafbb68":["7f68e24227d5556d33ee6d586fd9010cd9ff8bec"],"b08308242cb802f3a154e260d3881c2ed523c52b":["a93e1e4a21be8ebb98e53e6933412a363931faa1"],"c8f14489323057ef6de92ba5ea2d0cfe6e34755f":["50e7972fe4865715af8951d4ba15555e3426fc5d"],"7f68e24227d5556d33ee6d586fd9010cd9ff8bec":["b08308242cb802f3a154e260d3881c2ed523c52b"],"d57eb7c98c08c03af6e4cd83509df31c81ac16af":["61cbcf396559d597a914594d7e2830c142ecfd91"],"a93e1e4a21be8ebb98e53e6933412a363931faa1":["35dd40ede4dd66fa47506858c4a073d295c5a76e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"61cbcf396559d597a914594d7e2830c142ecfd91":["24677ebe836c841fc7c198375595e77fcbc11468"],"50e7972fe4865715af8951d4ba15555e3426fc5d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["d57eb7c98c08c03af6e4cd83509df31c81ac16af"]},"commit2Childs":{"24677ebe836c841fc7c198375595e77fcbc11468":["61cbcf396559d597a914594d7e2830c142ecfd91"],"35dd40ede4dd66fa47506858c4a073d295c5a76e":["a93e1e4a21be8ebb98e53e6933412a363931faa1"],"f30297381762542dcb61724b89bc3b143bafbb68":["24677ebe836c841fc7c198375595e77fcbc11468"],"b08308242cb802f3a154e260d3881c2ed523c52b":["7f68e24227d5556d33ee6d586fd9010cd9ff8bec"],"c8f14489323057ef6de92ba5ea2d0cfe6e34755f":["35dd40ede4dd66fa47506858c4a073d295c5a76e"],"7f68e24227d5556d33ee6d586fd9010cd9ff8bec":["f30297381762542dcb61724b89bc3b143bafbb68"],"d57eb7c98c08c03af6e4cd83509df31c81ac16af":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a93e1e4a21be8ebb98e53e6933412a363931faa1":["b08308242cb802f3a154e260d3881c2ed523c52b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["50e7972fe4865715af8951d4ba15555e3426fc5d"],"61cbcf396559d597a914594d7e2830c142ecfd91":["d57eb7c98c08c03af6e4cd83509df31c81ac16af"],"50e7972fe4865715af8951d4ba15555e3426fc5d":["c8f14489323057ef6de92ba5ea2d0cfe6e34755f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}