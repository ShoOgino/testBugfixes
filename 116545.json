{"path":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIDistributedZkTest#waitForStable(int,CollectionAdminRequest.Create[]).mjava","commits":[{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":0,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIDistributedZkTest#waitForStable(int,CollectionAdminRequest.Create[]).mjava","pathOld":"/dev/null","sourceNew":"  private void waitForStable(int cnt, CollectionAdminRequest.Create[] createRequests) throws InterruptedException {\n    for (int i = 0; i < cnt; i++) {\n      String collectionName = \"awhollynewcollection_\" + i;\n      final int j = i;\n      waitForState(\"Expected to see collection \" + collectionName, collectionName,\n          (n, c) -> {\n            CollectionAdminRequest.Create req = createRequests[j];\n            return DocCollection.isFullyActive(n, c, req.getNumShards(), req.getReplicationFactor());\n          });\n      \n      ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n      // make sure we have leaders for each shard\n      for (int z = 1; z < createRequests[j].getNumShards(); z++) {\n        zkStateReader.getLeaderRetry(collectionName, \"shard\" + z, 10000);\n      }      // make sure we again have leaders for each shard\n      \n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["273ff2f5b0b365591fcbe91ea23b5e97027ca60d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"273ff2f5b0b365591fcbe91ea23b5e97027ca60d","date":1551111277,"type":3,"author":"Kevin Risden","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIDistributedZkTest#waitForStable(int,CollectionAdminRequest.Create[]).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIDistributedZkTest#waitForStable(int,CollectionAdminRequest.Create[]).mjava","sourceNew":"  private void waitForStable(int cnt, CollectionAdminRequest.Create[] createRequests) throws InterruptedException {\n    for (int i = 0; i < cnt; i++) {\n      String collectionName = \"awhollynewcollection_\" + i;\n      final int j = i;\n      waitForState(\"Expected to see collection \" + collectionName, collectionName,\n          (n, c) -> {\n            CollectionAdminRequest.Create req = createRequests[j];\n            return DocCollection.isFullyActive(n, c, req.getNumShards(), req.getReplicationFactor());\n          });\n      \n      ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n      // make sure we have leaders for each shard\n      for (int z = 1; z < createRequests[j].getNumShards(); z++) {\n        zkStateReader.getLeaderRetry(collectionName, \"shard\" + z, 10000);\n      }      // make sure we again have leaders for each shard\n    }\n  }\n\n","sourceOld":"  private void waitForStable(int cnt, CollectionAdminRequest.Create[] createRequests) throws InterruptedException {\n    for (int i = 0; i < cnt; i++) {\n      String collectionName = \"awhollynewcollection_\" + i;\n      final int j = i;\n      waitForState(\"Expected to see collection \" + collectionName, collectionName,\n          (n, c) -> {\n            CollectionAdminRequest.Create req = createRequests[j];\n            return DocCollection.isFullyActive(n, c, req.getNumShards(), req.getReplicationFactor());\n          });\n      \n      ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n      // make sure we have leaders for each shard\n      for (int z = 1; z < createRequests[j].getNumShards(); z++) {\n        zkStateReader.getLeaderRetry(collectionName, \"shard\" + z, 10000);\n      }      // make sure we again have leaders for each shard\n      \n    }\n  }\n\n","bugFix":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"91f7dccce9b0ec051304926da532b96944956895","date":1551188806,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIDistributedZkTest#waitForStable(int,CollectionAdminRequest.Create[]).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIDistributedZkTest#waitForStable(int,CollectionAdminRequest.Create[]).mjava","sourceNew":"  private void waitForStable(int cnt, CollectionAdminRequest.Create[] createRequests) throws InterruptedException {\n    for (int i = 0; i < cnt; i++) {\n      String collectionName = \"awhollynewcollection_\" + i;\n      final int j = i;\n      waitForState(\"Expected to see collection \" + collectionName, collectionName,\n          (n, c) -> {\n            CollectionAdminRequest.Create req = createRequests[j];\n            return DocCollection.isFullyActive(n, c, req.getNumShards(), req.getReplicationFactor());\n          });\n      \n      ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n      // make sure we have leaders for each shard\n      for (int z = 1; z < createRequests[j].getNumShards(); z++) {\n        zkStateReader.getLeaderRetry(collectionName, \"shard\" + z, 10000);\n      }      // make sure we again have leaders for each shard\n    }\n  }\n\n","sourceOld":"  private void waitForStable(int cnt, CollectionAdminRequest.Create[] createRequests) throws InterruptedException {\n    for (int i = 0; i < cnt; i++) {\n      String collectionName = \"awhollynewcollection_\" + i;\n      final int j = i;\n      waitForState(\"Expected to see collection \" + collectionName, collectionName,\n          (n, c) -> {\n            CollectionAdminRequest.Create req = createRequests[j];\n            return DocCollection.isFullyActive(n, c, req.getNumShards(), req.getReplicationFactor());\n          });\n      \n      ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n      // make sure we have leaders for each shard\n      for (int z = 1; z < createRequests[j].getNumShards(); z++) {\n        zkStateReader.getLeaderRetry(collectionName, \"shard\" + z, 10000);\n      }      // make sure we again have leaders for each shard\n      \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"91f7dccce9b0ec051304926da532b96944956895":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","273ff2f5b0b365591fcbe91ea23b5e97027ca60d"],"273ff2f5b0b365591fcbe91ea23b5e97027ca60d":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["91f7dccce9b0ec051304926da532b96944956895"]},"commit2Childs":{"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["91f7dccce9b0ec051304926da532b96944956895","273ff2f5b0b365591fcbe91ea23b5e97027ca60d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"91f7dccce9b0ec051304926da532b96944956895":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"273ff2f5b0b365591fcbe91ea23b5e97027ca60d":["91f7dccce9b0ec051304926da532b96944956895"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}