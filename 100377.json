{"path":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/IndexedDISICache#fillCache(IndexInput,AtomicInteger,AtomicInteger,AtomicInteger).mjava","commits":[{"id":"fb9d1512598fc72005b830d5e2b88e61a0f4b374","date":1543843391,"type":0,"author":"Toke Eskildsen","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/IndexedDISICache#fillCache(IndexInput,AtomicInteger,AtomicInteger,AtomicInteger).mjava","pathOld":"/dev/null","sourceNew":"  private int fillCache(\n      IndexInput slice, AtomicInteger statBlockALL, AtomicInteger statBlockDENSE, AtomicInteger statBlockSPARSE)\n      throws IOException {\n    int largestBlock = -1;\n    long index = 0;\n    int rankIndex = -1;\n    while (slice.getFilePointer() < slice.length()) {\n      final long startFilePointer = slice.getFilePointer();\n\n      final int blockIndex = Short.toUnsignedInt(slice.readShort());\n      final int numValues = 1 + Short.toUnsignedInt(slice.readShort());\n\n      assert blockIndex > largestBlock;\n      if (blockIndex == DocIdSetIterator.NO_MORE_DOCS >>> 16) { // End reached\n        assert Short.toUnsignedInt(slice.readShort()) == (DocIdSetIterator.NO_MORE_DOCS & 0xFFFF);\n        break;\n      }\n      largestBlock = blockIndex;\n\n      blockCache = ArrayUtil.grow(blockCache, blockIndex+1); // No-op if large enough\n      blockCache[blockIndex] = (index << BLOCK_INDEX_SHIFT) | startFilePointer;\n      index += numValues;\n\n      if (numValues <= MAX_ARRAY_LENGTH) { // SPARSE\n        statBlockSPARSE.incrementAndGet();\n        slice.seek(slice.getFilePointer() + (numValues << 1));\n        continue;\n      }\n      if (numValues == 65536) { // ALL\n        statBlockALL.incrementAndGet();\n        // Already at next block offset\n        continue;\n      }\n\n      // The block is DENSE\n      statBlockDENSE.incrementAndGet();\n      long nextBlockOffset = slice.getFilePointer() + (1 << 13);\n      slice.seek(nextBlockOffset);\n    }\n\n    return largestBlock;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"91afec3d1be3c4538a6f92102a22573087f69d68","date":1543843480,"type":3,"author":"Toke Eskildsen","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/IndexedDISICache#fillCache(IndexInput,AtomicInteger,AtomicInteger,AtomicInteger).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/IndexedDISICache#fillCache(IndexInput,AtomicInteger,AtomicInteger,AtomicInteger).mjava","sourceNew":"  private int fillCache(\n      IndexInput slice, AtomicInteger statBlockALL, AtomicInteger statBlockDENSE, AtomicInteger statBlockSPARSE)\n      throws IOException {\n    char[] buildRank = new char[256];\n    int largestBlock = -1;\n    long index = 0;\n    int rankIndex = -1;\n    while (slice.getFilePointer() < slice.length()) {\n      final long startFilePointer = slice.getFilePointer();\n\n      final int blockIndex = Short.toUnsignedInt(slice.readShort());\n      final int numValues = 1 + Short.toUnsignedInt(slice.readShort());\n\n      assert blockIndex > largestBlock;\n      if (blockIndex == DocIdSetIterator.NO_MORE_DOCS >>> 16) { // End reached\n        assert Short.toUnsignedInt(slice.readShort()) == (DocIdSetIterator.NO_MORE_DOCS & 0xFFFF);\n        break;\n      }\n      largestBlock = blockIndex;\n\n      blockCache = ArrayUtil.grow(blockCache, blockIndex+1); // No-op if large enough\n      blockCache[blockIndex] = (index << BLOCK_INDEX_SHIFT) | startFilePointer;\n      index += numValues;\n\n      if (numValues <= MAX_ARRAY_LENGTH) { // SPARSE\n        statBlockSPARSE.incrementAndGet();\n        slice.seek(slice.getFilePointer() + (numValues << 1));\n        continue;\n      }\n      if (numValues == 65536) { // ALL\n        statBlockALL.incrementAndGet();\n        // Already at next block offset\n        continue;\n      }\n\n      // The block is DENSE\n      statBlockDENSE.incrementAndGet();\n      long nextBlockOffset = slice.getFilePointer() + (1 << 13);\n      int setBits = 0;\n      int rankOrigo = blockIndex << 16 >> 9; // Double shift for clarity: The compiler will simplify it\n      for (int rankDelta = 0 ; rankDelta < RANKS_PER_BLOCK ; rankDelta++) { // 128 rank-entries in a block\n        rankIndex = rankOrigo + rankDelta;\n        buildRank = ArrayUtil.grow(buildRank, rankIndex+1);\n        buildRank[rankIndex] = (char)setBits;\n        for (int i = 0 ; i < 512/64 ; i++) { // 8 longs for each rank-entry\n          setBits += Long.bitCount(slice.readLong());\n        }\n      }\n      assert slice.getFilePointer() == nextBlockOffset;\n    }\n    // Compress the buildRank as it is potentially very sparse\n    if (rankIndex < 0) {\n      rank = null;\n    } else {\n      PackedInts.Mutable ranks = PackedInts.getMutable(rankIndex, 16, PackedInts.DEFAULT); // Char = 16 bit\n      for (int i = 0 ; i < rankIndex ; i++) {\n        ranks.set(i, buildRank[i]);\n      }\n      rank = LongCompressor.compress(ranks);\n    }\n\n    return largestBlock;\n  }\n\n","sourceOld":"  private int fillCache(\n      IndexInput slice, AtomicInteger statBlockALL, AtomicInteger statBlockDENSE, AtomicInteger statBlockSPARSE)\n      throws IOException {\n    int largestBlock = -1;\n    long index = 0;\n    int rankIndex = -1;\n    while (slice.getFilePointer() < slice.length()) {\n      final long startFilePointer = slice.getFilePointer();\n\n      final int blockIndex = Short.toUnsignedInt(slice.readShort());\n      final int numValues = 1 + Short.toUnsignedInt(slice.readShort());\n\n      assert blockIndex > largestBlock;\n      if (blockIndex == DocIdSetIterator.NO_MORE_DOCS >>> 16) { // End reached\n        assert Short.toUnsignedInt(slice.readShort()) == (DocIdSetIterator.NO_MORE_DOCS & 0xFFFF);\n        break;\n      }\n      largestBlock = blockIndex;\n\n      blockCache = ArrayUtil.grow(blockCache, blockIndex+1); // No-op if large enough\n      blockCache[blockIndex] = (index << BLOCK_INDEX_SHIFT) | startFilePointer;\n      index += numValues;\n\n      if (numValues <= MAX_ARRAY_LENGTH) { // SPARSE\n        statBlockSPARSE.incrementAndGet();\n        slice.seek(slice.getFilePointer() + (numValues << 1));\n        continue;\n      }\n      if (numValues == 65536) { // ALL\n        statBlockALL.incrementAndGet();\n        // Already at next block offset\n        continue;\n      }\n\n      // The block is DENSE\n      statBlockDENSE.incrementAndGet();\n      long nextBlockOffset = slice.getFilePointer() + (1 << 13);\n      slice.seek(nextBlockOffset);\n    }\n\n    return largestBlock;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"90c33633162a86e6323f4cf2b93e2bb168b1dc22","date":1544534062,"type":3,"author":"Toke Eskildsen","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/IndexedDISICache#fillCache(IndexInput,AtomicInteger,AtomicInteger,AtomicInteger).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/IndexedDISICache#fillCache(IndexInput,AtomicInteger,AtomicInteger,AtomicInteger).mjava","sourceNew":"  private int fillCache(\n      IndexInput slice, AtomicInteger statBlockALL, AtomicInteger statBlockDENSE, AtomicInteger statBlockSPARSE)\n      throws IOException {\n    int largestBlock = -1;\n    long index = 0;\n    int rankIndex = -1;\n    while (slice.getFilePointer() < slice.length()) {\n      final long startFilePointer = slice.getFilePointer();\n\n      final int blockIndex = Short.toUnsignedInt(slice.readShort());\n      final int numValues = 1 + Short.toUnsignedInt(slice.readShort());\n\n      assert blockIndex > largestBlock;\n      if (blockIndex == DocIdSetIterator.NO_MORE_DOCS >>> 16) { // End reached\n        assert Short.toUnsignedInt(slice.readShort()) == (DocIdSetIterator.NO_MORE_DOCS & 0xFFFF);\n        break;\n      }\n      largestBlock = blockIndex;\n\n      blockCache = ArrayUtil.grow(blockCache, blockIndex+1); // No-op if large enough\n      blockCache[blockIndex] = (index << BLOCK_INDEX_SHIFT) | startFilePointer;\n      index += numValues;\n\n      if (numValues <= MAX_ARRAY_LENGTH) { // SPARSE\n        statBlockSPARSE.incrementAndGet();\n        slice.seek(slice.getFilePointer() + (numValues << 1));\n        continue;\n      }\n      if (numValues == 65536) { // ALL\n        statBlockALL.incrementAndGet();\n        // Already at next block offset\n        continue;\n      }\n\n      // The block is DENSE\n      statBlockDENSE.incrementAndGet();\n      long nextBlockOffset = slice.getFilePointer() + (1 << 13);\n      slice.seek(nextBlockOffset);\n    }\n\n    return largestBlock;\n  }\n\n","sourceOld":"  private int fillCache(\n      IndexInput slice, AtomicInteger statBlockALL, AtomicInteger statBlockDENSE, AtomicInteger statBlockSPARSE)\n      throws IOException {\n    char[] buildRank = new char[256];\n    int largestBlock = -1;\n    long index = 0;\n    int rankIndex = -1;\n    while (slice.getFilePointer() < slice.length()) {\n      final long startFilePointer = slice.getFilePointer();\n\n      final int blockIndex = Short.toUnsignedInt(slice.readShort());\n      final int numValues = 1 + Short.toUnsignedInt(slice.readShort());\n\n      assert blockIndex > largestBlock;\n      if (blockIndex == DocIdSetIterator.NO_MORE_DOCS >>> 16) { // End reached\n        assert Short.toUnsignedInt(slice.readShort()) == (DocIdSetIterator.NO_MORE_DOCS & 0xFFFF);\n        break;\n      }\n      largestBlock = blockIndex;\n\n      blockCache = ArrayUtil.grow(blockCache, blockIndex+1); // No-op if large enough\n      blockCache[blockIndex] = (index << BLOCK_INDEX_SHIFT) | startFilePointer;\n      index += numValues;\n\n      if (numValues <= MAX_ARRAY_LENGTH) { // SPARSE\n        statBlockSPARSE.incrementAndGet();\n        slice.seek(slice.getFilePointer() + (numValues << 1));\n        continue;\n      }\n      if (numValues == 65536) { // ALL\n        statBlockALL.incrementAndGet();\n        // Already at next block offset\n        continue;\n      }\n\n      // The block is DENSE\n      statBlockDENSE.incrementAndGet();\n      long nextBlockOffset = slice.getFilePointer() + (1 << 13);\n      int setBits = 0;\n      int rankOrigo = blockIndex << 16 >> 9; // Double shift for clarity: The compiler will simplify it\n      for (int rankDelta = 0 ; rankDelta < RANKS_PER_BLOCK ; rankDelta++) { // 128 rank-entries in a block\n        rankIndex = rankOrigo + rankDelta;\n        buildRank = ArrayUtil.grow(buildRank, rankIndex+1);\n        buildRank[rankIndex] = (char)setBits;\n        for (int i = 0 ; i < 512/64 ; i++) { // 8 longs for each rank-entry\n          setBits += Long.bitCount(slice.readLong());\n        }\n      }\n      assert slice.getFilePointer() == nextBlockOffset;\n    }\n    // Compress the buildRank as it is potentially very sparse\n    if (rankIndex < 0) {\n      rank = null;\n    } else {\n      PackedInts.Mutable ranks = PackedInts.getMutable(rankIndex, 16, PackedInts.DEFAULT); // Char = 16 bit\n      for (int i = 0 ; i < rankIndex ; i++) {\n        ranks.set(i, buildRank[i]);\n      }\n      rank = LongCompressor.compress(ranks);\n    }\n\n    return largestBlock;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c74cb19c6e988ccfef4286a1f3f0e5930f0863e","date":1544534277,"type":4,"author":"Toke Eskildsen","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/IndexedDISICache#fillCache(IndexInput,AtomicInteger,AtomicInteger,AtomicInteger).mjava","sourceNew":null,"sourceOld":"  private int fillCache(\n      IndexInput slice, AtomicInteger statBlockALL, AtomicInteger statBlockDENSE, AtomicInteger statBlockSPARSE)\n      throws IOException {\n    int largestBlock = -1;\n    long index = 0;\n    int rankIndex = -1;\n    while (slice.getFilePointer() < slice.length()) {\n      final long startFilePointer = slice.getFilePointer();\n\n      final int blockIndex = Short.toUnsignedInt(slice.readShort());\n      final int numValues = 1 + Short.toUnsignedInt(slice.readShort());\n\n      assert blockIndex > largestBlock;\n      if (blockIndex == DocIdSetIterator.NO_MORE_DOCS >>> 16) { // End reached\n        assert Short.toUnsignedInt(slice.readShort()) == (DocIdSetIterator.NO_MORE_DOCS & 0xFFFF);\n        break;\n      }\n      largestBlock = blockIndex;\n\n      blockCache = ArrayUtil.grow(blockCache, blockIndex+1); // No-op if large enough\n      blockCache[blockIndex] = (index << BLOCK_INDEX_SHIFT) | startFilePointer;\n      index += numValues;\n\n      if (numValues <= MAX_ARRAY_LENGTH) { // SPARSE\n        statBlockSPARSE.incrementAndGet();\n        slice.seek(slice.getFilePointer() + (numValues << 1));\n        continue;\n      }\n      if (numValues == 65536) { // ALL\n        statBlockALL.incrementAndGet();\n        // Already at next block offset\n        continue;\n      }\n\n      // The block is DENSE\n      statBlockDENSE.incrementAndGet();\n      long nextBlockOffset = slice.getFilePointer() + (1 << 13);\n      slice.seek(nextBlockOffset);\n    }\n\n    return largestBlock;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cfd70c9571310639a77f0123aea0db41077d9bb6","date":1544538617,"type":4,"author":"Karl Wright","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene70/IndexedDISICache#fillCache(IndexInput,AtomicInteger,AtomicInteger,AtomicInteger).mjava","sourceNew":null,"sourceOld":"  private int fillCache(\n      IndexInput slice, AtomicInteger statBlockALL, AtomicInteger statBlockDENSE, AtomicInteger statBlockSPARSE)\n      throws IOException {\n    char[] buildRank = new char[256];\n    int largestBlock = -1;\n    long index = 0;\n    int rankIndex = -1;\n    while (slice.getFilePointer() < slice.length()) {\n      final long startFilePointer = slice.getFilePointer();\n\n      final int blockIndex = Short.toUnsignedInt(slice.readShort());\n      final int numValues = 1 + Short.toUnsignedInt(slice.readShort());\n\n      assert blockIndex > largestBlock;\n      if (blockIndex == DocIdSetIterator.NO_MORE_DOCS >>> 16) { // End reached\n        assert Short.toUnsignedInt(slice.readShort()) == (DocIdSetIterator.NO_MORE_DOCS & 0xFFFF);\n        break;\n      }\n      largestBlock = blockIndex;\n\n      blockCache = ArrayUtil.grow(blockCache, blockIndex+1); // No-op if large enough\n      blockCache[blockIndex] = (index << BLOCK_INDEX_SHIFT) | startFilePointer;\n      index += numValues;\n\n      if (numValues <= MAX_ARRAY_LENGTH) { // SPARSE\n        statBlockSPARSE.incrementAndGet();\n        slice.seek(slice.getFilePointer() + (numValues << 1));\n        continue;\n      }\n      if (numValues == 65536) { // ALL\n        statBlockALL.incrementAndGet();\n        // Already at next block offset\n        continue;\n      }\n\n      // The block is DENSE\n      statBlockDENSE.incrementAndGet();\n      long nextBlockOffset = slice.getFilePointer() + (1 << 13);\n      int setBits = 0;\n      int rankOrigo = blockIndex << 16 >> 9; // Double shift for clarity: The compiler will simplify it\n      for (int rankDelta = 0 ; rankDelta < RANKS_PER_BLOCK ; rankDelta++) { // 128 rank-entries in a block\n        rankIndex = rankOrigo + rankDelta;\n        buildRank = ArrayUtil.grow(buildRank, rankIndex+1);\n        buildRank[rankIndex] = (char)setBits;\n        for (int i = 0 ; i < 512/64 ; i++) { // 8 longs for each rank-entry\n          setBits += Long.bitCount(slice.readLong());\n        }\n      }\n      assert slice.getFilePointer() == nextBlockOffset;\n    }\n    // Compress the buildRank as it is potentially very sparse\n    if (rankIndex < 0) {\n      rank = null;\n    } else {\n      PackedInts.Mutable ranks = PackedInts.getMutable(rankIndex, 16, PackedInts.DEFAULT); // Char = 16 bit\n      for (int i = 0 ; i < rankIndex ; i++) {\n        ranks.set(i, buildRank[i]);\n      }\n      rank = LongCompressor.compress(ranks);\n    }\n\n    return largestBlock;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"91afec3d1be3c4538a6f92102a22573087f69d68":["fb9d1512598fc72005b830d5e2b88e61a0f4b374"],"cfd70c9571310639a77f0123aea0db41077d9bb6":["91afec3d1be3c4538a6f92102a22573087f69d68","5c74cb19c6e988ccfef4286a1f3f0e5930f0863e"],"90c33633162a86e6323f4cf2b93e2bb168b1dc22":["91afec3d1be3c4538a6f92102a22573087f69d68"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fb9d1512598fc72005b830d5e2b88e61a0f4b374":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5c74cb19c6e988ccfef4286a1f3f0e5930f0863e":["90c33633162a86e6323f4cf2b93e2bb168b1dc22"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cfd70c9571310639a77f0123aea0db41077d9bb6"]},"commit2Childs":{"91afec3d1be3c4538a6f92102a22573087f69d68":["cfd70c9571310639a77f0123aea0db41077d9bb6","90c33633162a86e6323f4cf2b93e2bb168b1dc22"],"cfd70c9571310639a77f0123aea0db41077d9bb6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"90c33633162a86e6323f4cf2b93e2bb168b1dc22":["5c74cb19c6e988ccfef4286a1f3f0e5930f0863e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fb9d1512598fc72005b830d5e2b88e61a0f4b374"],"fb9d1512598fc72005b830d5e2b88e61a0f4b374":["91afec3d1be3c4538a6f92102a22573087f69d68"],"5c74cb19c6e988ccfef4286a1f3f0e5930f0863e":["cfd70c9571310639a77f0123aea0db41077d9bb6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}