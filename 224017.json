{"path":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testSimpleRestore().mjava","commits":[{"id":"7b13106276bb5ea342253dbf6aae7b675adb38d3","date":1428054414,"type":0,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testSimpleRestore().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testSimpleRestore() throws Exception {\n\n    int nDocs = TestReplicationHandlerBackup.indexDocs(masterClient);\n\n    String snapshotName;\n    String location;\n    String params = \"\";\n\n    //Use the default backup location or an externally provided location.\n    if (random().nextBoolean()) {\n      location = createTempDir().toFile().getAbsolutePath();\n      params += \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    }\n\n    //named snapshot vs default snapshot name\n    if (random().nextBoolean()) {\n      snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n      params += \"&name=\" + snapshotName;\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, null);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n    //Modify existing index before we call restore.\n\n    //Delete a few docs\n    int numDeletes = TestUtil.nextInt(random(), 1, nDocs);\n    for(int i=0; i<numDeletes; i++) {\n      masterClient.deleteByQuery(\"id:\" + i);\n    }\n    masterClient.commit();\n\n    //Add a few more\n    int moreAdds = TestUtil.nextInt(random(), 1, 100);\n    for (int i=0; i<moreAdds; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", i + nDocs);\n      doc.addField(\"name\", \"name = \" + (i + nDocs));\n      masterClient.add(doc);\n    }\n    //Purposely not calling commit once in a while. There can be some docs which are not committed\n    if (usually()) {\n      masterClient.commit();\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n    while (!fetchRestoreStatus()) {\n      Thread.sleep(1000);\n    }\n\n    //See if restore was successful by checking if all the docs are present again\n    verifyDocs(nDocs);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["0463d2997b25fd01c7d3f0f93e6a523e5a4b5f68"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","date":1428091986,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testSimpleRestore().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testSimpleRestore() throws Exception {\n\n    int nDocs = TestReplicationHandlerBackup.indexDocs(masterClient);\n\n    String snapshotName;\n    String location;\n    String params = \"\";\n\n    //Use the default backup location or an externally provided location.\n    if (random().nextBoolean()) {\n      location = createTempDir().toFile().getAbsolutePath();\n      params += \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    }\n\n    //named snapshot vs default snapshot name\n    if (random().nextBoolean()) {\n      snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n      params += \"&name=\" + snapshotName;\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, null);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n    //Modify existing index before we call restore.\n\n    //Delete a few docs\n    int numDeletes = TestUtil.nextInt(random(), 1, nDocs);\n    for(int i=0; i<numDeletes; i++) {\n      masterClient.deleteByQuery(\"id:\" + i);\n    }\n    masterClient.commit();\n\n    //Add a few more\n    int moreAdds = TestUtil.nextInt(random(), 1, 100);\n    for (int i=0; i<moreAdds; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", i + nDocs);\n      doc.addField(\"name\", \"name = \" + (i + nDocs));\n      masterClient.add(doc);\n    }\n    //Purposely not calling commit once in a while. There can be some docs which are not committed\n    if (usually()) {\n      masterClient.commit();\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n    while (!fetchRestoreStatus()) {\n      Thread.sleep(1000);\n    }\n\n    //See if restore was successful by checking if all the docs are present again\n    verifyDocs(nDocs);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0463d2997b25fd01c7d3f0f93e6a523e5a4b5f68","date":1457217731,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testSimpleRestore().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testSimpleRestore().mjava","sourceNew":"  @Test\n  public void testSimpleRestore() throws Exception {\n\n    int nDocs = TestReplicationHandlerBackup.indexDocs(masterClient);\n\n    String snapshotName;\n    String location;\n    String params = \"\";\n\n    //Use the default backup location or an externally provided location.\n    if (random().nextBoolean()) {\n      location = createTempDir().toFile().getAbsolutePath();\n      params += \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    }\n\n    //named snapshot vs default snapshot name\n    if (random().nextBoolean()) {\n      snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n      params += \"&name=\" + snapshotName;\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, null);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n\n\n    int numRestoreTests = TestUtil.nextInt(random(), 1, 5);\n\n    for (int attempts=0; attempts<numRestoreTests; attempts++) {\n      //Modify existing index before we call restore.\n\n      //Delete a few docs\n      int numDeletes = TestUtil.nextInt(random(), 1, nDocs);\n      for(int i=0; i<numDeletes; i++) {\n        masterClient.deleteByQuery(\"id:\" + i);\n      }\n      masterClient.commit();\n\n      //Add a few more\n      int moreAdds = TestUtil.nextInt(random(), 1, 100);\n      for (int i=0; i<moreAdds; i++) {\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.addField(\"id\", i + nDocs);\n        doc.addField(\"name\", \"name = \" + (i + nDocs));\n        masterClient.add(doc);\n      }\n      //Purposely not calling commit once in a while. There can be some docs which are not committed\n      if (usually()) {\n        masterClient.commit();\n      }\n\n      TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n      while (!fetchRestoreStatus()) {\n        Thread.sleep(1000);\n      }\n\n      //See if restore was successful by checking if all the docs are present again\n      verifyDocs(nDocs);\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSimpleRestore() throws Exception {\n\n    int nDocs = TestReplicationHandlerBackup.indexDocs(masterClient);\n\n    String snapshotName;\n    String location;\n    String params = \"\";\n\n    //Use the default backup location or an externally provided location.\n    if (random().nextBoolean()) {\n      location = createTempDir().toFile().getAbsolutePath();\n      params += \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    }\n\n    //named snapshot vs default snapshot name\n    if (random().nextBoolean()) {\n      snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n      params += \"&name=\" + snapshotName;\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, null);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n    //Modify existing index before we call restore.\n\n    //Delete a few docs\n    int numDeletes = TestUtil.nextInt(random(), 1, nDocs);\n    for(int i=0; i<numDeletes; i++) {\n      masterClient.deleteByQuery(\"id:\" + i);\n    }\n    masterClient.commit();\n\n    //Add a few more\n    int moreAdds = TestUtil.nextInt(random(), 1, 100);\n    for (int i=0; i<moreAdds; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", i + nDocs);\n      doc.addField(\"name\", \"name = \" + (i + nDocs));\n      masterClient.add(doc);\n    }\n    //Purposely not calling commit once in a while. There can be some docs which are not committed\n    if (usually()) {\n      masterClient.commit();\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n    while (!fetchRestoreStatus()) {\n      Thread.sleep(1000);\n    }\n\n    //See if restore was successful by checking if all the docs are present again\n    verifyDocs(nDocs);\n  }\n\n","bugFix":["7b13106276bb5ea342253dbf6aae7b675adb38d3"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5c99ad021f3da085fcb66220598a8f91dc5e453","date":1462242046,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testSimpleRestore().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testSimpleRestore().mjava","sourceNew":"  @Test\n  public void testSimpleRestore() throws Exception {\n\n    int nDocs = usually() ? TestReplicationHandlerBackup.indexDocs(masterClient) : 0;\n\n    String snapshotName;\n    String location;\n    String params = \"\";\n\n    //Use the default backup location or an externally provided location.\n    if (random().nextBoolean()) {\n      location = createTempDir().toFile().getAbsolutePath();\n      params += \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    }\n\n    //named snapshot vs default snapshot name\n    if (random().nextBoolean()) {\n      snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n      params += \"&name=\" + snapshotName;\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, null);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n\n\n    int numRestoreTests = nDocs > 0 ? TestUtil.nextInt(random(), 1, 5) : 1;\n\n    for (int attempts=0; attempts<numRestoreTests; attempts++) {\n      //Modify existing index before we call restore.\n\n      if (nDocs > 0) {\n        //Delete a few docs\n        int numDeletes = TestUtil.nextInt(random(), 1, nDocs);\n        for(int i=0; i<numDeletes; i++) {\n          masterClient.deleteByQuery(\"id:\" + i);\n        }\n        masterClient.commit();\n\n        //Add a few more\n        int moreAdds = TestUtil.nextInt(random(), 1, 100);\n        for (int i=0; i<moreAdds; i++) {\n          SolrInputDocument doc = new SolrInputDocument();\n          doc.addField(\"id\", i + nDocs);\n          doc.addField(\"name\", \"name = \" + (i + nDocs));\n          masterClient.add(doc);\n        }\n        //Purposely not calling commit once in a while. There can be some docs which are not committed\n        if (usually()) {\n          masterClient.commit();\n        }\n      }\n\n      TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n      while (!fetchRestoreStatus()) {\n        Thread.sleep(1000);\n      }\n\n      //See if restore was successful by checking if all the docs are present again\n      verifyDocs(nDocs);\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSimpleRestore() throws Exception {\n\n    int nDocs = TestReplicationHandlerBackup.indexDocs(masterClient);\n\n    String snapshotName;\n    String location;\n    String params = \"\";\n\n    //Use the default backup location or an externally provided location.\n    if (random().nextBoolean()) {\n      location = createTempDir().toFile().getAbsolutePath();\n      params += \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    }\n\n    //named snapshot vs default snapshot name\n    if (random().nextBoolean()) {\n      snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n      params += \"&name=\" + snapshotName;\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, null);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n\n\n    int numRestoreTests = TestUtil.nextInt(random(), 1, 5);\n\n    for (int attempts=0; attempts<numRestoreTests; attempts++) {\n      //Modify existing index before we call restore.\n\n      //Delete a few docs\n      int numDeletes = TestUtil.nextInt(random(), 1, nDocs);\n      for(int i=0; i<numDeletes; i++) {\n        masterClient.deleteByQuery(\"id:\" + i);\n      }\n      masterClient.commit();\n\n      //Add a few more\n      int moreAdds = TestUtil.nextInt(random(), 1, 100);\n      for (int i=0; i<moreAdds; i++) {\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.addField(\"id\", i + nDocs);\n        doc.addField(\"name\", \"name = \" + (i + nDocs));\n        masterClient.add(doc);\n      }\n      //Purposely not calling commit once in a while. There can be some docs which are not committed\n      if (usually()) {\n        masterClient.commit();\n      }\n\n      TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n      while (!fetchRestoreStatus()) {\n        Thread.sleep(1000);\n      }\n\n      //See if restore was successful by checking if all the docs are present again\n      verifyDocs(nDocs);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1c7a21395bae9e2f61aeb639f47aaca771c426ed","date":1462255690,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testSimpleRestore().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testSimpleRestore().mjava","sourceNew":"  @Test\n  public void testSimpleRestore() throws Exception {\n\n    int nDocs = usually() ? TestReplicationHandlerBackup.indexDocs(masterClient) : 0;\n\n    String snapshotName;\n    String location;\n    String params = \"\";\n\n    //Use the default backup location or an externally provided location.\n    if (random().nextBoolean()) {\n      location = createTempDir().toFile().getAbsolutePath();\n      params += \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    }\n\n    //named snapshot vs default snapshot name\n    if (random().nextBoolean()) {\n      snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n      params += \"&name=\" + snapshotName;\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, null);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n\n\n    int numRestoreTests = nDocs > 0 ? TestUtil.nextInt(random(), 1, 5) : 1;\n\n    for (int attempts=0; attempts<numRestoreTests; attempts++) {\n      //Modify existing index before we call restore.\n\n      if (nDocs > 0) {\n        //Delete a few docs\n        int numDeletes = TestUtil.nextInt(random(), 1, nDocs);\n        for(int i=0; i<numDeletes; i++) {\n          masterClient.deleteByQuery(\"id:\" + i);\n        }\n        masterClient.commit();\n\n        //Add a few more\n        int moreAdds = TestUtil.nextInt(random(), 1, 100);\n        for (int i=0; i<moreAdds; i++) {\n          SolrInputDocument doc = new SolrInputDocument();\n          doc.addField(\"id\", i + nDocs);\n          doc.addField(\"name\", \"name = \" + (i + nDocs));\n          masterClient.add(doc);\n        }\n        //Purposely not calling commit once in a while. There can be some docs which are not committed\n        if (usually()) {\n          masterClient.commit();\n        }\n      }\n\n      TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n      while (!fetchRestoreStatus()) {\n        Thread.sleep(1000);\n      }\n\n      //See if restore was successful by checking if all the docs are present again\n      verifyDocs(nDocs);\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSimpleRestore() throws Exception {\n\n    int nDocs = TestReplicationHandlerBackup.indexDocs(masterClient);\n\n    String snapshotName;\n    String location;\n    String params = \"\";\n\n    //Use the default backup location or an externally provided location.\n    if (random().nextBoolean()) {\n      location = createTempDir().toFile().getAbsolutePath();\n      params += \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    }\n\n    //named snapshot vs default snapshot name\n    if (random().nextBoolean()) {\n      snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n      params += \"&name=\" + snapshotName;\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, null);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n\n\n    int numRestoreTests = TestUtil.nextInt(random(), 1, 5);\n\n    for (int attempts=0; attempts<numRestoreTests; attempts++) {\n      //Modify existing index before we call restore.\n\n      //Delete a few docs\n      int numDeletes = TestUtil.nextInt(random(), 1, nDocs);\n      for(int i=0; i<numDeletes; i++) {\n        masterClient.deleteByQuery(\"id:\" + i);\n      }\n      masterClient.commit();\n\n      //Add a few more\n      int moreAdds = TestUtil.nextInt(random(), 1, 100);\n      for (int i=0; i<moreAdds; i++) {\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.addField(\"id\", i + nDocs);\n        doc.addField(\"name\", \"name = \" + (i + nDocs));\n        masterClient.add(doc);\n      }\n      //Purposely not calling commit once in a while. There can be some docs which are not committed\n      if (usually()) {\n        masterClient.commit();\n      }\n\n      TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n      while (!fetchRestoreStatus()) {\n        Thread.sleep(1000);\n      }\n\n      //See if restore was successful by checking if all the docs are present again\n      verifyDocs(nDocs);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55b50463286869f584cf849d1587a0fcd54d1dfa","date":1462378517,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testSimpleRestore().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testSimpleRestore().mjava","sourceNew":"  @Test\n  public void testSimpleRestore() throws Exception {\n\n    int nDocs = usually() ? TestReplicationHandlerBackup.indexDocs(masterClient) : 0;\n\n    String snapshotName;\n    String location;\n    String params = \"\";\n\n    //Use the default backup location or an externally provided location.\n    if (random().nextBoolean()) {\n      location = createTempDir().toFile().getAbsolutePath();\n      params += \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    }\n\n    //named snapshot vs default snapshot name\n    if (random().nextBoolean()) {\n      snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n      params += \"&name=\" + snapshotName;\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, null);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n\n\n    int numRestoreTests = nDocs > 0 ? TestUtil.nextInt(random(), 1, 5) : 1;\n\n    for (int attempts=0; attempts<numRestoreTests; attempts++) {\n      //Modify existing index before we call restore.\n\n      if (nDocs > 0) {\n        //Delete a few docs\n        int numDeletes = TestUtil.nextInt(random(), 1, nDocs);\n        for(int i=0; i<numDeletes; i++) {\n          masterClient.deleteByQuery(\"id:\" + i);\n        }\n        masterClient.commit();\n\n        //Add a few more\n        int moreAdds = TestUtil.nextInt(random(), 1, 100);\n        for (int i=0; i<moreAdds; i++) {\n          SolrInputDocument doc = new SolrInputDocument();\n          doc.addField(\"id\", i + nDocs);\n          doc.addField(\"name\", \"name = \" + (i + nDocs));\n          masterClient.add(doc);\n        }\n        //Purposely not calling commit once in a while. There can be some docs which are not committed\n        if (usually()) {\n          masterClient.commit();\n        }\n      }\n\n      TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n      while (!fetchRestoreStatus()) {\n        Thread.sleep(1000);\n      }\n\n      //See if restore was successful by checking if all the docs are present again\n      verifyDocs(nDocs);\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSimpleRestore() throws Exception {\n\n    int nDocs = TestReplicationHandlerBackup.indexDocs(masterClient);\n\n    String snapshotName;\n    String location;\n    String params = \"\";\n\n    //Use the default backup location or an externally provided location.\n    if (random().nextBoolean()) {\n      location = createTempDir().toFile().getAbsolutePath();\n      params += \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    }\n\n    //named snapshot vs default snapshot name\n    if (random().nextBoolean()) {\n      snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n      params += \"&name=\" + snapshotName;\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, null);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n\n\n    int numRestoreTests = TestUtil.nextInt(random(), 1, 5);\n\n    for (int attempts=0; attempts<numRestoreTests; attempts++) {\n      //Modify existing index before we call restore.\n\n      //Delete a few docs\n      int numDeletes = TestUtil.nextInt(random(), 1, nDocs);\n      for(int i=0; i<numDeletes; i++) {\n        masterClient.deleteByQuery(\"id:\" + i);\n      }\n      masterClient.commit();\n\n      //Add a few more\n      int moreAdds = TestUtil.nextInt(random(), 1, 100);\n      for (int i=0; i<moreAdds; i++) {\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.addField(\"id\", i + nDocs);\n        doc.addField(\"name\", \"name = \" + (i + nDocs));\n        masterClient.add(doc);\n      }\n      //Purposely not calling commit once in a while. There can be some docs which are not committed\n      if (usually()) {\n        masterClient.commit();\n      }\n\n      TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n      while (!fetchRestoreStatus()) {\n        Thread.sleep(1000);\n      }\n\n      //See if restore was successful by checking if all the docs are present again\n      verifyDocs(nDocs);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a51ab9b1f1b896f06b7ba61672f0fca2a4fce43b","date":1466705968,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testSimpleRestore().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testSimpleRestore().mjava","sourceNew":"  @Test\n  public void testSimpleRestore() throws Exception {\n\n    int nDocs = usually() ? BackupRestoreUtils.indexDocs(masterClient, \"collection1\", docsSeed) : 0;\n\n    String snapshotName;\n    String location;\n    String params = \"\";\n    String baseUrl = masterJetty.getBaseUrl().toString();\n\n    //Use the default backup location or an externally provided location.\n    if (random().nextBoolean()) {\n      location = createTempDir().toFile().getAbsolutePath();\n      params += \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    }\n\n    //named snapshot vs default snapshot name\n    if (random().nextBoolean()) {\n      snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n      params += \"&name=\" + snapshotName;\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, DEFAULT_TEST_CORENAME, null);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n\n\n    int numRestoreTests = nDocs > 0 ? TestUtil.nextInt(random(), 1, 5) : 1;\n\n    for (int attempts=0; attempts<numRestoreTests; attempts++) {\n      //Modify existing index before we call restore.\n\n      if (nDocs > 0) {\n        //Delete a few docs\n        int numDeletes = TestUtil.nextInt(random(), 1, nDocs);\n        for(int i=0; i<numDeletes; i++) {\n          masterClient.deleteByQuery(DEFAULT_TEST_CORENAME, \"id:\" + i);\n        }\n        masterClient.commit(DEFAULT_TEST_CORENAME);\n\n        //Add a few more\n        int moreAdds = TestUtil.nextInt(random(), 1, 100);\n        for (int i=0; i<moreAdds; i++) {\n          SolrInputDocument doc = new SolrInputDocument();\n          doc.addField(\"id\", i + nDocs);\n          doc.addField(\"name\", \"name = \" + (i + nDocs));\n          masterClient.add(DEFAULT_TEST_CORENAME, doc);\n        }\n        //Purposely not calling commit once in a while. There can be some docs which are not committed\n        if (usually()) {\n          masterClient.commit(DEFAULT_TEST_CORENAME);\n        }\n      }\n\n      TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n      while (!fetchRestoreStatus(baseUrl, DEFAULT_TEST_CORENAME)) {\n        Thread.sleep(1000);\n      }\n\n      //See if restore was successful by checking if all the docs are present again\n      BackupRestoreUtils.verifyDocs(nDocs, masterClient, DEFAULT_TEST_CORENAME);\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSimpleRestore() throws Exception {\n\n    int nDocs = usually() ? TestReplicationHandlerBackup.indexDocs(masterClient) : 0;\n\n    String snapshotName;\n    String location;\n    String params = \"\";\n\n    //Use the default backup location or an externally provided location.\n    if (random().nextBoolean()) {\n      location = createTempDir().toFile().getAbsolutePath();\n      params += \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    }\n\n    //named snapshot vs default snapshot name\n    if (random().nextBoolean()) {\n      snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n      params += \"&name=\" + snapshotName;\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, null);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n\n\n    int numRestoreTests = nDocs > 0 ? TestUtil.nextInt(random(), 1, 5) : 1;\n\n    for (int attempts=0; attempts<numRestoreTests; attempts++) {\n      //Modify existing index before we call restore.\n\n      if (nDocs > 0) {\n        //Delete a few docs\n        int numDeletes = TestUtil.nextInt(random(), 1, nDocs);\n        for(int i=0; i<numDeletes; i++) {\n          masterClient.deleteByQuery(\"id:\" + i);\n        }\n        masterClient.commit();\n\n        //Add a few more\n        int moreAdds = TestUtil.nextInt(random(), 1, 100);\n        for (int i=0; i<moreAdds; i++) {\n          SolrInputDocument doc = new SolrInputDocument();\n          doc.addField(\"id\", i + nDocs);\n          doc.addField(\"name\", \"name = \" + (i + nDocs));\n          masterClient.add(doc);\n        }\n        //Purposely not calling commit once in a while. There can be some docs which are not committed\n        if (usually()) {\n          masterClient.commit();\n        }\n      }\n\n      TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n      while (!fetchRestoreStatus()) {\n        Thread.sleep(1000);\n      }\n\n      //See if restore was successful by checking if all the docs are present again\n      verifyDocs(nDocs);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testSimpleRestore().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testSimpleRestore().mjava","sourceNew":"  @Test\n  public void testSimpleRestore() throws Exception {\n\n    int nDocs = usually() ? BackupRestoreUtils.indexDocs(masterClient, \"collection1\", docsSeed) : 0;\n\n    String snapshotName;\n    String location;\n    String params = \"\";\n    String baseUrl = masterJetty.getBaseUrl().toString();\n\n    //Use the default backup location or an externally provided location.\n    if (random().nextBoolean()) {\n      location = createTempDir().toFile().getAbsolutePath();\n      params += \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    }\n\n    //named snapshot vs default snapshot name\n    if (random().nextBoolean()) {\n      snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n      params += \"&name=\" + snapshotName;\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, DEFAULT_TEST_CORENAME, null);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n\n\n    int numRestoreTests = nDocs > 0 ? TestUtil.nextInt(random(), 1, 5) : 1;\n\n    for (int attempts=0; attempts<numRestoreTests; attempts++) {\n      //Modify existing index before we call restore.\n\n      if (nDocs > 0) {\n        //Delete a few docs\n        int numDeletes = TestUtil.nextInt(random(), 1, nDocs);\n        for(int i=0; i<numDeletes; i++) {\n          masterClient.deleteByQuery(DEFAULT_TEST_CORENAME, \"id:\" + i);\n        }\n        masterClient.commit(DEFAULT_TEST_CORENAME);\n\n        //Add a few more\n        int moreAdds = TestUtil.nextInt(random(), 1, 100);\n        for (int i=0; i<moreAdds; i++) {\n          SolrInputDocument doc = new SolrInputDocument();\n          doc.addField(\"id\", i + nDocs);\n          doc.addField(\"name\", \"name = \" + (i + nDocs));\n          masterClient.add(DEFAULT_TEST_CORENAME, doc);\n        }\n        //Purposely not calling commit once in a while. There can be some docs which are not committed\n        if (usually()) {\n          masterClient.commit(DEFAULT_TEST_CORENAME);\n        }\n      }\n\n      TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n      while (!fetchRestoreStatus(baseUrl, DEFAULT_TEST_CORENAME)) {\n        Thread.sleep(1000);\n      }\n\n      //See if restore was successful by checking if all the docs are present again\n      BackupRestoreUtils.verifyDocs(nDocs, masterClient, DEFAULT_TEST_CORENAME);\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSimpleRestore() throws Exception {\n\n    int nDocs = usually() ? TestReplicationHandlerBackup.indexDocs(masterClient) : 0;\n\n    String snapshotName;\n    String location;\n    String params = \"\";\n\n    //Use the default backup location or an externally provided location.\n    if (random().nextBoolean()) {\n      location = createTempDir().toFile().getAbsolutePath();\n      params += \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    }\n\n    //named snapshot vs default snapshot name\n    if (random().nextBoolean()) {\n      snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n      params += \"&name=\" + snapshotName;\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, null);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n\n\n    int numRestoreTests = nDocs > 0 ? TestUtil.nextInt(random(), 1, 5) : 1;\n\n    for (int attempts=0; attempts<numRestoreTests; attempts++) {\n      //Modify existing index before we call restore.\n\n      if (nDocs > 0) {\n        //Delete a few docs\n        int numDeletes = TestUtil.nextInt(random(), 1, nDocs);\n        for(int i=0; i<numDeletes; i++) {\n          masterClient.deleteByQuery(\"id:\" + i);\n        }\n        masterClient.commit();\n\n        //Add a few more\n        int moreAdds = TestUtil.nextInt(random(), 1, 100);\n        for (int i=0; i<moreAdds; i++) {\n          SolrInputDocument doc = new SolrInputDocument();\n          doc.addField(\"id\", i + nDocs);\n          doc.addField(\"name\", \"name = \" + (i + nDocs));\n          masterClient.add(doc);\n        }\n        //Purposely not calling commit once in a while. There can be some docs which are not committed\n        if (usually()) {\n          masterClient.commit();\n        }\n      }\n\n      TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n      while (!fetchRestoreStatus()) {\n        Thread.sleep(1000);\n      }\n\n      //See if restore was successful by checking if all the docs are present again\n      verifyDocs(nDocs);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d1a307447328c95a00248512b40d7a5ff12ecd6a","date":1564817449,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testSimpleRestore().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testSimpleRestore().mjava","sourceNew":"  @Test\n  public void testSimpleRestore() throws Exception {\n\n    int nDocs = usually() ? BackupRestoreUtils.indexDocs(masterClient, \"collection1\", docsSeed) : 0;\n\n    String snapshotName;\n    String location;\n    String params = \"\";\n    String baseUrl = masterJetty.getBaseUrl().toString();\n\n    //Use the default backup location or an externally provided location.\n    if (random().nextBoolean()) {\n      location = createTempDir().toFile().getAbsolutePath();\n      params += \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    }\n\n    //named snapshot vs default snapshot name\n    if (random().nextBoolean()) {\n      snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n      params += \"&name=\" + snapshotName;\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, DEFAULT_TEST_CORENAME, null);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n    int numRestoreTests = nDocs > 0 ? TestUtil.nextInt(random(), 1, 5) : 1;\n\n    for (int attempts=0; attempts<numRestoreTests; attempts++) {\n      //Modify existing index before we call restore.\n\n      if (nDocs > 0) {\n        //Delete a few docs\n        int numDeletes = TestUtil.nextInt(random(), 1, nDocs);\n        for(int i=0; i<numDeletes; i++) {\n          masterClient.deleteByQuery(DEFAULT_TEST_CORENAME, \"id:\" + i);\n        }\n        masterClient.commit(DEFAULT_TEST_CORENAME);\n\n        //Add a few more\n        int moreAdds = TestUtil.nextInt(random(), 1, 100);\n        for (int i=0; i<moreAdds; i++) {\n          SolrInputDocument doc = new SolrInputDocument();\n          doc.addField(\"id\", i + nDocs);\n          doc.addField(\"name\", \"name = \" + (i + nDocs));\n          masterClient.add(DEFAULT_TEST_CORENAME, doc);\n        }\n        //Purposely not calling commit once in a while. There can be some docs which are not committed\n        if (usually()) {\n          masterClient.commit(DEFAULT_TEST_CORENAME);\n        }\n      }\n\n      TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n      while (!fetchRestoreStatus(baseUrl, DEFAULT_TEST_CORENAME)) {\n        Thread.sleep(1000);\n      }\n\n      //See if restore was successful by checking if all the docs are present again\n      BackupRestoreUtils.verifyDocs(nDocs, masterClient, DEFAULT_TEST_CORENAME);\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSimpleRestore() throws Exception {\n\n    int nDocs = usually() ? BackupRestoreUtils.indexDocs(masterClient, \"collection1\", docsSeed) : 0;\n\n    String snapshotName;\n    String location;\n    String params = \"\";\n    String baseUrl = masterJetty.getBaseUrl().toString();\n\n    //Use the default backup location or an externally provided location.\n    if (random().nextBoolean()) {\n      location = createTempDir().toFile().getAbsolutePath();\n      params += \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    }\n\n    //named snapshot vs default snapshot name\n    if (random().nextBoolean()) {\n      snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n      params += \"&name=\" + snapshotName;\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, DEFAULT_TEST_CORENAME, null);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n\n\n    int numRestoreTests = nDocs > 0 ? TestUtil.nextInt(random(), 1, 5) : 1;\n\n    for (int attempts=0; attempts<numRestoreTests; attempts++) {\n      //Modify existing index before we call restore.\n\n      if (nDocs > 0) {\n        //Delete a few docs\n        int numDeletes = TestUtil.nextInt(random(), 1, nDocs);\n        for(int i=0; i<numDeletes; i++) {\n          masterClient.deleteByQuery(DEFAULT_TEST_CORENAME, \"id:\" + i);\n        }\n        masterClient.commit(DEFAULT_TEST_CORENAME);\n\n        //Add a few more\n        int moreAdds = TestUtil.nextInt(random(), 1, 100);\n        for (int i=0; i<moreAdds; i++) {\n          SolrInputDocument doc = new SolrInputDocument();\n          doc.addField(\"id\", i + nDocs);\n          doc.addField(\"name\", \"name = \" + (i + nDocs));\n          masterClient.add(DEFAULT_TEST_CORENAME, doc);\n        }\n        //Purposely not calling commit once in a while. There can be some docs which are not committed\n        if (usually()) {\n          masterClient.commit(DEFAULT_TEST_CORENAME);\n        }\n      }\n\n      TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n      while (!fetchRestoreStatus(baseUrl, DEFAULT_TEST_CORENAME)) {\n        Thread.sleep(1000);\n      }\n\n      //See if restore was successful by checking if all the docs are present again\n      BackupRestoreUtils.verifyDocs(nDocs, masterClient, DEFAULT_TEST_CORENAME);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8061ddd97f3352007d927dae445884a6f3d857b","date":1564988276,"type":3,"author":"Atri Sharma","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testSimpleRestore().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testSimpleRestore().mjava","sourceNew":"  @Test\n  public void testSimpleRestore() throws Exception {\n\n    int nDocs = usually() ? BackupRestoreUtils.indexDocs(masterClient, \"collection1\", docsSeed) : 0;\n\n    String snapshotName;\n    String location;\n    String params = \"\";\n    String baseUrl = masterJetty.getBaseUrl().toString();\n\n    //Use the default backup location or an externally provided location.\n    if (random().nextBoolean()) {\n      location = createTempDir().toFile().getAbsolutePath();\n      params += \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    }\n\n    //named snapshot vs default snapshot name\n    if (random().nextBoolean()) {\n      snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n      params += \"&name=\" + snapshotName;\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, DEFAULT_TEST_CORENAME, null);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n    int numRestoreTests = nDocs > 0 ? TestUtil.nextInt(random(), 1, 5) : 1;\n\n    for (int attempts=0; attempts<numRestoreTests; attempts++) {\n      //Modify existing index before we call restore.\n\n      if (nDocs > 0) {\n        //Delete a few docs\n        int numDeletes = TestUtil.nextInt(random(), 1, nDocs);\n        for(int i=0; i<numDeletes; i++) {\n          masterClient.deleteByQuery(DEFAULT_TEST_CORENAME, \"id:\" + i);\n        }\n        masterClient.commit(DEFAULT_TEST_CORENAME);\n\n        //Add a few more\n        int moreAdds = TestUtil.nextInt(random(), 1, 100);\n        for (int i=0; i<moreAdds; i++) {\n          SolrInputDocument doc = new SolrInputDocument();\n          doc.addField(\"id\", i + nDocs);\n          doc.addField(\"name\", \"name = \" + (i + nDocs));\n          masterClient.add(DEFAULT_TEST_CORENAME, doc);\n        }\n        //Purposely not calling commit once in a while. There can be some docs which are not committed\n        if (usually()) {\n          masterClient.commit(DEFAULT_TEST_CORENAME);\n        }\n      }\n\n      TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n      while (!fetchRestoreStatus(baseUrl, DEFAULT_TEST_CORENAME)) {\n        Thread.sleep(1000);\n      }\n\n      //See if restore was successful by checking if all the docs are present again\n      BackupRestoreUtils.verifyDocs(nDocs, masterClient, DEFAULT_TEST_CORENAME);\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSimpleRestore() throws Exception {\n\n    int nDocs = usually() ? BackupRestoreUtils.indexDocs(masterClient, \"collection1\", docsSeed) : 0;\n\n    String snapshotName;\n    String location;\n    String params = \"\";\n    String baseUrl = masterJetty.getBaseUrl().toString();\n\n    //Use the default backup location or an externally provided location.\n    if (random().nextBoolean()) {\n      location = createTempDir().toFile().getAbsolutePath();\n      params += \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    }\n\n    //named snapshot vs default snapshot name\n    if (random().nextBoolean()) {\n      snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n      params += \"&name=\" + snapshotName;\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, DEFAULT_TEST_CORENAME, null);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n\n\n    int numRestoreTests = nDocs > 0 ? TestUtil.nextInt(random(), 1, 5) : 1;\n\n    for (int attempts=0; attempts<numRestoreTests; attempts++) {\n      //Modify existing index before we call restore.\n\n      if (nDocs > 0) {\n        //Delete a few docs\n        int numDeletes = TestUtil.nextInt(random(), 1, nDocs);\n        for(int i=0; i<numDeletes; i++) {\n          masterClient.deleteByQuery(DEFAULT_TEST_CORENAME, \"id:\" + i);\n        }\n        masterClient.commit(DEFAULT_TEST_CORENAME);\n\n        //Add a few more\n        int moreAdds = TestUtil.nextInt(random(), 1, 100);\n        for (int i=0; i<moreAdds; i++) {\n          SolrInputDocument doc = new SolrInputDocument();\n          doc.addField(\"id\", i + nDocs);\n          doc.addField(\"name\", \"name = \" + (i + nDocs));\n          masterClient.add(DEFAULT_TEST_CORENAME, doc);\n        }\n        //Purposely not calling commit once in a while. There can be some docs which are not committed\n        if (usually()) {\n          masterClient.commit(DEFAULT_TEST_CORENAME);\n        }\n      }\n\n      TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n      while (!fetchRestoreStatus(baseUrl, DEFAULT_TEST_CORENAME)) {\n        Thread.sleep(1000);\n      }\n\n      //See if restore was successful by checking if all the docs are present again\n      BackupRestoreUtils.verifyDocs(nDocs, masterClient, DEFAULT_TEST_CORENAME);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693","date":1565097295,"type":3,"author":"Jan HÃ¸ydahl","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testSimpleRestore().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testSimpleRestore().mjava","sourceNew":"  @Test\n  public void testSimpleRestore() throws Exception {\n\n    int nDocs = usually() ? BackupRestoreUtils.indexDocs(masterClient, \"collection1\", docsSeed) : 0;\n\n    String snapshotName;\n    String location;\n    String params = \"\";\n    String baseUrl = masterJetty.getBaseUrl().toString();\n\n    //Use the default backup location or an externally provided location.\n    if (random().nextBoolean()) {\n      location = createTempDir().toFile().getAbsolutePath();\n      params += \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    }\n\n    //named snapshot vs default snapshot name\n    if (random().nextBoolean()) {\n      snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n      params += \"&name=\" + snapshotName;\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, DEFAULT_TEST_CORENAME, null);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n    int numRestoreTests = nDocs > 0 ? TestUtil.nextInt(random(), 1, 5) : 1;\n\n    for (int attempts=0; attempts<numRestoreTests; attempts++) {\n      //Modify existing index before we call restore.\n\n      if (nDocs > 0) {\n        //Delete a few docs\n        int numDeletes = TestUtil.nextInt(random(), 1, nDocs);\n        for(int i=0; i<numDeletes; i++) {\n          masterClient.deleteByQuery(DEFAULT_TEST_CORENAME, \"id:\" + i);\n        }\n        masterClient.commit(DEFAULT_TEST_CORENAME);\n\n        //Add a few more\n        int moreAdds = TestUtil.nextInt(random(), 1, 100);\n        for (int i=0; i<moreAdds; i++) {\n          SolrInputDocument doc = new SolrInputDocument();\n          doc.addField(\"id\", i + nDocs);\n          doc.addField(\"name\", \"name = \" + (i + nDocs));\n          masterClient.add(DEFAULT_TEST_CORENAME, doc);\n        }\n        //Purposely not calling commit once in a while. There can be some docs which are not committed\n        if (usually()) {\n          masterClient.commit(DEFAULT_TEST_CORENAME);\n        }\n      }\n\n      TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n      while (!fetchRestoreStatus(baseUrl, DEFAULT_TEST_CORENAME)) {\n        Thread.sleep(1000);\n      }\n\n      //See if restore was successful by checking if all the docs are present again\n      BackupRestoreUtils.verifyDocs(nDocs, masterClient, DEFAULT_TEST_CORENAME);\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSimpleRestore() throws Exception {\n\n    int nDocs = usually() ? BackupRestoreUtils.indexDocs(masterClient, \"collection1\", docsSeed) : 0;\n\n    String snapshotName;\n    String location;\n    String params = \"\";\n    String baseUrl = masterJetty.getBaseUrl().toString();\n\n    //Use the default backup location or an externally provided location.\n    if (random().nextBoolean()) {\n      location = createTempDir().toFile().getAbsolutePath();\n      params += \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    }\n\n    //named snapshot vs default snapshot name\n    if (random().nextBoolean()) {\n      snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n      params += \"&name=\" + snapshotName;\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, DEFAULT_TEST_CORENAME, null);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n\n\n    int numRestoreTests = nDocs > 0 ? TestUtil.nextInt(random(), 1, 5) : 1;\n\n    for (int attempts=0; attempts<numRestoreTests; attempts++) {\n      //Modify existing index before we call restore.\n\n      if (nDocs > 0) {\n        //Delete a few docs\n        int numDeletes = TestUtil.nextInt(random(), 1, nDocs);\n        for(int i=0; i<numDeletes; i++) {\n          masterClient.deleteByQuery(DEFAULT_TEST_CORENAME, \"id:\" + i);\n        }\n        masterClient.commit(DEFAULT_TEST_CORENAME);\n\n        //Add a few more\n        int moreAdds = TestUtil.nextInt(random(), 1, 100);\n        for (int i=0; i<moreAdds; i++) {\n          SolrInputDocument doc = new SolrInputDocument();\n          doc.addField(\"id\", i + nDocs);\n          doc.addField(\"name\", \"name = \" + (i + nDocs));\n          masterClient.add(DEFAULT_TEST_CORENAME, doc);\n        }\n        //Purposely not calling commit once in a while. There can be some docs which are not committed\n        if (usually()) {\n          masterClient.commit(DEFAULT_TEST_CORENAME);\n        }\n      }\n\n      TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n      while (!fetchRestoreStatus(baseUrl, DEFAULT_TEST_CORENAME)) {\n        Thread.sleep(1000);\n      }\n\n      //See if restore was successful by checking if all the docs are present again\n      BackupRestoreUtils.verifyDocs(nDocs, masterClient, DEFAULT_TEST_CORENAME);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec54bd926c45854b5a1599685b0f7d2bfbfe177f","date":1573838246,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testSimpleRestore().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testSimpleRestore().mjava","sourceNew":"  @Test\n  public void testSimpleRestore() throws Exception {\n\n    int nDocs = usually() ? BackupRestoreUtils.indexDocs(masterClient, \"collection1\", docsSeed) : 0;\n\n    final BackupStatusChecker backupStatus\n      = new BackupStatusChecker(masterClient, \"/\" + DEFAULT_TEST_CORENAME + \"/replication\");\n    final String oldBackupDir = backupStatus.checkBackupSuccess();\n    String snapshotName = null;\n    String location;\n    String params = \"\";\n    String baseUrl = masterJetty.getBaseUrl().toString();\n\n    //Use the default backup location or an externally provided location.\n    if (random().nextBoolean()) {\n      location = createTempDir().toFile().getAbsolutePath();\n      params += \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    }\n\n    //named snapshot vs default snapshot name\n    if (random().nextBoolean()) {\n      snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n      params += \"&name=\" + snapshotName;\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    if (null == snapshotName) {\n      backupStatus.waitForDifferentBackupDir(oldBackupDir, 30);\n    } else {\n      backupStatus.waitForBackupSuccess(snapshotName, 30);\n    }\n\n    int numRestoreTests = nDocs > 0 ? TestUtil.nextInt(random(), 1, 5) : 1;\n\n    for (int attempts=0; attempts<numRestoreTests; attempts++) {\n      //Modify existing index before we call restore.\n\n      if (nDocs > 0) {\n        //Delete a few docs\n        int numDeletes = TestUtil.nextInt(random(), 1, nDocs);\n        for(int i=0; i<numDeletes; i++) {\n          masterClient.deleteByQuery(DEFAULT_TEST_CORENAME, \"id:\" + i);\n        }\n        masterClient.commit(DEFAULT_TEST_CORENAME);\n\n        //Add a few more\n        int moreAdds = TestUtil.nextInt(random(), 1, 100);\n        for (int i=0; i<moreAdds; i++) {\n          SolrInputDocument doc = new SolrInputDocument();\n          doc.addField(\"id\", i + nDocs);\n          doc.addField(\"name\", \"name = \" + (i + nDocs));\n          masterClient.add(DEFAULT_TEST_CORENAME, doc);\n        }\n        //Purposely not calling commit once in a while. There can be some docs which are not committed\n        if (usually()) {\n          masterClient.commit(DEFAULT_TEST_CORENAME);\n        }\n      }\n\n      TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n      while (!fetchRestoreStatus(baseUrl, DEFAULT_TEST_CORENAME)) {\n        Thread.sleep(1000);\n      }\n\n      //See if restore was successful by checking if all the docs are present again\n      BackupRestoreUtils.verifyDocs(nDocs, masterClient, DEFAULT_TEST_CORENAME);\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSimpleRestore() throws Exception {\n\n    int nDocs = usually() ? BackupRestoreUtils.indexDocs(masterClient, \"collection1\", docsSeed) : 0;\n\n    String snapshotName;\n    String location;\n    String params = \"\";\n    String baseUrl = masterJetty.getBaseUrl().toString();\n\n    //Use the default backup location or an externally provided location.\n    if (random().nextBoolean()) {\n      location = createTempDir().toFile().getAbsolutePath();\n      params += \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    }\n\n    //named snapshot vs default snapshot name\n    if (random().nextBoolean()) {\n      snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n      params += \"&name=\" + snapshotName;\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    CheckBackupStatus checkBackupStatus = new CheckBackupStatus((HttpSolrClient) masterClient, DEFAULT_TEST_CORENAME, null);\n    while (!checkBackupStatus.success) {\n      checkBackupStatus.fetchStatus();\n      Thread.sleep(1000);\n    }\n\n    int numRestoreTests = nDocs > 0 ? TestUtil.nextInt(random(), 1, 5) : 1;\n\n    for (int attempts=0; attempts<numRestoreTests; attempts++) {\n      //Modify existing index before we call restore.\n\n      if (nDocs > 0) {\n        //Delete a few docs\n        int numDeletes = TestUtil.nextInt(random(), 1, nDocs);\n        for(int i=0; i<numDeletes; i++) {\n          masterClient.deleteByQuery(DEFAULT_TEST_CORENAME, \"id:\" + i);\n        }\n        masterClient.commit(DEFAULT_TEST_CORENAME);\n\n        //Add a few more\n        int moreAdds = TestUtil.nextInt(random(), 1, 100);\n        for (int i=0; i<moreAdds; i++) {\n          SolrInputDocument doc = new SolrInputDocument();\n          doc.addField(\"id\", i + nDocs);\n          doc.addField(\"name\", \"name = \" + (i + nDocs));\n          masterClient.add(DEFAULT_TEST_CORENAME, doc);\n        }\n        //Purposely not calling commit once in a while. There can be some docs which are not committed\n        if (usually()) {\n          masterClient.commit(DEFAULT_TEST_CORENAME);\n        }\n      }\n\n      TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n      while (!fetchRestoreStatus(baseUrl, DEFAULT_TEST_CORENAME)) {\n        Thread.sleep(1000);\n      }\n\n      //See if restore was successful by checking if all the docs are present again\n      BackupRestoreUtils.verifyDocs(nDocs, masterClient, DEFAULT_TEST_CORENAME);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6b17e67903ace8abb1d4d602bfc40d1994692ff","date":1593429504,"type":3,"author":"Jan HÃ¸ydahl","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testSimpleRestore().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testSimpleRestore().mjava","sourceNew":"  @Test\n  public void testSimpleRestore() throws Exception {\n\n    int nDocs = usually() ? BackupRestoreUtils.indexDocs(masterClient, \"collection1\", docsSeed) : 0;\n\n    final BackupStatusChecker backupStatus\n      = new BackupStatusChecker(masterClient, \"/\" + DEFAULT_TEST_CORENAME + \"/replication\");\n    final String oldBackupDir = backupStatus.checkBackupSuccess();\n    String snapshotName = null;\n    String location;\n    String params = \"\";\n    String baseUrl = masterJetty.getBaseUrl().toString();\n\n    //Use the default backup location or an externally provided location.\n    if (random().nextBoolean()) {\n      location = createTempDir().toFile().getAbsolutePath();\n      masterJetty.getCoreContainer().getAllowPaths().add(Path.of(location)); // Allow core to be created outside SOLR_HOME\n      params += \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    }\n\n    //named snapshot vs default snapshot name\n    if (random().nextBoolean()) {\n      snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n      params += \"&name=\" + snapshotName;\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    if (null == snapshotName) {\n      backupStatus.waitForDifferentBackupDir(oldBackupDir, 30);\n    } else {\n      backupStatus.waitForBackupSuccess(snapshotName, 30);\n    }\n\n    int numRestoreTests = nDocs > 0 ? TestUtil.nextInt(random(), 1, 5) : 1;\n\n    for (int attempts=0; attempts<numRestoreTests; attempts++) {\n      //Modify existing index before we call restore.\n\n      if (nDocs > 0) {\n        //Delete a few docs\n        int numDeletes = TestUtil.nextInt(random(), 1, nDocs);\n        for(int i=0; i<numDeletes; i++) {\n          masterClient.deleteByQuery(DEFAULT_TEST_CORENAME, \"id:\" + i);\n        }\n        masterClient.commit(DEFAULT_TEST_CORENAME);\n\n        //Add a few more\n        int moreAdds = TestUtil.nextInt(random(), 1, 100);\n        for (int i=0; i<moreAdds; i++) {\n          SolrInputDocument doc = new SolrInputDocument();\n          doc.addField(\"id\", i + nDocs);\n          doc.addField(\"name\", \"name = \" + (i + nDocs));\n          masterClient.add(DEFAULT_TEST_CORENAME, doc);\n        }\n        //Purposely not calling commit once in a while. There can be some docs which are not committed\n        if (usually()) {\n          masterClient.commit(DEFAULT_TEST_CORENAME);\n        }\n      }\n\n      TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n      while (!fetchRestoreStatus(baseUrl, DEFAULT_TEST_CORENAME)) {\n        Thread.sleep(1000);\n      }\n\n      //See if restore was successful by checking if all the docs are present again\n      BackupRestoreUtils.verifyDocs(nDocs, masterClient, DEFAULT_TEST_CORENAME);\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSimpleRestore() throws Exception {\n\n    int nDocs = usually() ? BackupRestoreUtils.indexDocs(masterClient, \"collection1\", docsSeed) : 0;\n\n    final BackupStatusChecker backupStatus\n      = new BackupStatusChecker(masterClient, \"/\" + DEFAULT_TEST_CORENAME + \"/replication\");\n    final String oldBackupDir = backupStatus.checkBackupSuccess();\n    String snapshotName = null;\n    String location;\n    String params = \"\";\n    String baseUrl = masterJetty.getBaseUrl().toString();\n\n    //Use the default backup location or an externally provided location.\n    if (random().nextBoolean()) {\n      location = createTempDir().toFile().getAbsolutePath();\n      params += \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    }\n\n    //named snapshot vs default snapshot name\n    if (random().nextBoolean()) {\n      snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n      params += \"&name=\" + snapshotName;\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    if (null == snapshotName) {\n      backupStatus.waitForDifferentBackupDir(oldBackupDir, 30);\n    } else {\n      backupStatus.waitForBackupSuccess(snapshotName, 30);\n    }\n\n    int numRestoreTests = nDocs > 0 ? TestUtil.nextInt(random(), 1, 5) : 1;\n\n    for (int attempts=0; attempts<numRestoreTests; attempts++) {\n      //Modify existing index before we call restore.\n\n      if (nDocs > 0) {\n        //Delete a few docs\n        int numDeletes = TestUtil.nextInt(random(), 1, nDocs);\n        for(int i=0; i<numDeletes; i++) {\n          masterClient.deleteByQuery(DEFAULT_TEST_CORENAME, \"id:\" + i);\n        }\n        masterClient.commit(DEFAULT_TEST_CORENAME);\n\n        //Add a few more\n        int moreAdds = TestUtil.nextInt(random(), 1, 100);\n        for (int i=0; i<moreAdds; i++) {\n          SolrInputDocument doc = new SolrInputDocument();\n          doc.addField(\"id\", i + nDocs);\n          doc.addField(\"name\", \"name = \" + (i + nDocs));\n          masterClient.add(DEFAULT_TEST_CORENAME, doc);\n        }\n        //Purposely not calling commit once in a while. There can be some docs which are not committed\n        if (usually()) {\n          masterClient.commit(DEFAULT_TEST_CORENAME);\n        }\n      }\n\n      TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n      while (!fetchRestoreStatus(baseUrl, DEFAULT_TEST_CORENAME)) {\n        Thread.sleep(1000);\n      }\n\n      //See if restore was successful by checking if all the docs are present again\n      BackupRestoreUtils.verifyDocs(nDocs, masterClient, DEFAULT_TEST_CORENAME);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"65a5d87a40f9143cd55be76eb1dde1b32a8dae5e","date":1596664368,"type":3,"author":"Marcus","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testSimpleRestore().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestRestoreCore#testSimpleRestore().mjava","sourceNew":"  @Test\n  public void testSimpleRestore() throws Exception {\n\n    int nDocs = usually() ? BackupRestoreUtils.indexDocs(leaderClient, \"collection1\", docsSeed) : 0;\n\n    final BackupStatusChecker backupStatus\n      = new BackupStatusChecker(leaderClient, \"/\" + DEFAULT_TEST_CORENAME + \"/replication\");\n    final String oldBackupDir = backupStatus.checkBackupSuccess();\n    String snapshotName = null;\n    String location;\n    String params = \"\";\n    String baseUrl = leaderJetty.getBaseUrl().toString();\n\n    //Use the default backup location or an externally provided location.\n    if (random().nextBoolean()) {\n      location = createTempDir().toFile().getAbsolutePath();\n      leaderJetty.getCoreContainer().getAllowPaths().add(Path.of(location)); // Allow core to be created outside SOLR_HOME\n      params += \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    }\n\n    //named snapshot vs default snapshot name\n    if (random().nextBoolean()) {\n      snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n      params += \"&name=\" + snapshotName;\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(leaderJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    if (null == snapshotName) {\n      backupStatus.waitForDifferentBackupDir(oldBackupDir, 30);\n    } else {\n      backupStatus.waitForBackupSuccess(snapshotName, 30);\n    }\n\n    int numRestoreTests = nDocs > 0 ? TestUtil.nextInt(random(), 1, 5) : 1;\n\n    for (int attempts=0; attempts<numRestoreTests; attempts++) {\n      //Modify existing index before we call restore.\n\n      if (nDocs > 0) {\n        //Delete a few docs\n        int numDeletes = TestUtil.nextInt(random(), 1, nDocs);\n        for(int i=0; i<numDeletes; i++) {\n          leaderClient.deleteByQuery(DEFAULT_TEST_CORENAME, \"id:\" + i);\n        }\n        leaderClient.commit(DEFAULT_TEST_CORENAME);\n\n        //Add a few more\n        int moreAdds = TestUtil.nextInt(random(), 1, 100);\n        for (int i=0; i<moreAdds; i++) {\n          SolrInputDocument doc = new SolrInputDocument();\n          doc.addField(\"id\", i + nDocs);\n          doc.addField(\"name\", \"name = \" + (i + nDocs));\n          leaderClient.add(DEFAULT_TEST_CORENAME, doc);\n        }\n        //Purposely not calling commit once in a while. There can be some docs which are not committed\n        if (usually()) {\n          leaderClient.commit(DEFAULT_TEST_CORENAME);\n        }\n      }\n\n      TestReplicationHandlerBackup.runBackupCommand(leaderJetty, ReplicationHandler.CMD_RESTORE, params);\n\n      while (!fetchRestoreStatus(baseUrl, DEFAULT_TEST_CORENAME)) {\n        Thread.sleep(1000);\n      }\n\n      //See if restore was successful by checking if all the docs are present again\n      BackupRestoreUtils.verifyDocs(nDocs, leaderClient, DEFAULT_TEST_CORENAME);\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSimpleRestore() throws Exception {\n\n    int nDocs = usually() ? BackupRestoreUtils.indexDocs(masterClient, \"collection1\", docsSeed) : 0;\n\n    final BackupStatusChecker backupStatus\n      = new BackupStatusChecker(masterClient, \"/\" + DEFAULT_TEST_CORENAME + \"/replication\");\n    final String oldBackupDir = backupStatus.checkBackupSuccess();\n    String snapshotName = null;\n    String location;\n    String params = \"\";\n    String baseUrl = masterJetty.getBaseUrl().toString();\n\n    //Use the default backup location or an externally provided location.\n    if (random().nextBoolean()) {\n      location = createTempDir().toFile().getAbsolutePath();\n      masterJetty.getCoreContainer().getAllowPaths().add(Path.of(location)); // Allow core to be created outside SOLR_HOME\n      params += \"&location=\" + URLEncoder.encode(location, \"UTF-8\");\n    }\n\n    //named snapshot vs default snapshot name\n    if (random().nextBoolean()) {\n      snapshotName = TestUtil.randomSimpleString(random(), 1, 5);\n      params += \"&name=\" + snapshotName;\n    }\n\n    TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_BACKUP, params);\n\n    if (null == snapshotName) {\n      backupStatus.waitForDifferentBackupDir(oldBackupDir, 30);\n    } else {\n      backupStatus.waitForBackupSuccess(snapshotName, 30);\n    }\n\n    int numRestoreTests = nDocs > 0 ? TestUtil.nextInt(random(), 1, 5) : 1;\n\n    for (int attempts=0; attempts<numRestoreTests; attempts++) {\n      //Modify existing index before we call restore.\n\n      if (nDocs > 0) {\n        //Delete a few docs\n        int numDeletes = TestUtil.nextInt(random(), 1, nDocs);\n        for(int i=0; i<numDeletes; i++) {\n          masterClient.deleteByQuery(DEFAULT_TEST_CORENAME, \"id:\" + i);\n        }\n        masterClient.commit(DEFAULT_TEST_CORENAME);\n\n        //Add a few more\n        int moreAdds = TestUtil.nextInt(random(), 1, 100);\n        for (int i=0; i<moreAdds; i++) {\n          SolrInputDocument doc = new SolrInputDocument();\n          doc.addField(\"id\", i + nDocs);\n          doc.addField(\"name\", \"name = \" + (i + nDocs));\n          masterClient.add(DEFAULT_TEST_CORENAME, doc);\n        }\n        //Purposely not calling commit once in a while. There can be some docs which are not committed\n        if (usually()) {\n          masterClient.commit(DEFAULT_TEST_CORENAME);\n        }\n      }\n\n      TestReplicationHandlerBackup.runBackupCommand(masterJetty, ReplicationHandler.CMD_RESTORE, params);\n\n      while (!fetchRestoreStatus(baseUrl, DEFAULT_TEST_CORENAME)) {\n        Thread.sleep(1000);\n      }\n\n      //See if restore was successful by checking if all the docs are present again\n      BackupRestoreUtils.verifyDocs(nDocs, masterClient, DEFAULT_TEST_CORENAME);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c5c99ad021f3da085fcb66220598a8f91dc5e453":["0463d2997b25fd01c7d3f0f93e6a523e5a4b5f68"],"65a5d87a40f9143cd55be76eb1dde1b32a8dae5e":["a6b17e67903ace8abb1d4d602bfc40d1994692ff"],"f8061ddd97f3352007d927dae445884a6f3d857b":["a51ab9b1f1b896f06b7ba61672f0fca2a4fce43b","d1a307447328c95a00248512b40d7a5ff12ecd6a"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["55b50463286869f584cf849d1587a0fcd54d1dfa","a51ab9b1f1b896f06b7ba61672f0fca2a4fce43b"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["0463d2997b25fd01c7d3f0f93e6a523e5a4b5f68","1c7a21395bae9e2f61aeb639f47aaca771c426ed"],"a6b17e67903ace8abb1d4d602bfc40d1994692ff":["ec54bd926c45854b5a1599685b0f7d2bfbfe177f"],"ec54bd926c45854b5a1599685b0f7d2bfbfe177f":["d1a307447328c95a00248512b40d7a5ff12ecd6a"],"a51ab9b1f1b896f06b7ba61672f0fca2a4fce43b":["1c7a21395bae9e2f61aeb639f47aaca771c426ed"],"1c7a21395bae9e2f61aeb639f47aaca771c426ed":["0463d2997b25fd01c7d3f0f93e6a523e5a4b5f68","c5c99ad021f3da085fcb66220598a8f91dc5e453"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0463d2997b25fd01c7d3f0f93e6a523e5a4b5f68":["7b13106276bb5ea342253dbf6aae7b675adb38d3"],"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7b13106276bb5ea342253dbf6aae7b675adb38d3"],"d1a307447328c95a00248512b40d7a5ff12ecd6a":["a51ab9b1f1b896f06b7ba61672f0fca2a4fce43b"],"d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693":["a51ab9b1f1b896f06b7ba61672f0fca2a4fce43b","d1a307447328c95a00248512b40d7a5ff12ecd6a"],"7b13106276bb5ea342253dbf6aae7b675adb38d3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["65a5d87a40f9143cd55be76eb1dde1b32a8dae5e"]},"commit2Childs":{"c5c99ad021f3da085fcb66220598a8f91dc5e453":["1c7a21395bae9e2f61aeb639f47aaca771c426ed"],"65a5d87a40f9143cd55be76eb1dde1b32a8dae5e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f8061ddd97f3352007d927dae445884a6f3d857b":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"55b50463286869f584cf849d1587a0fcd54d1dfa":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a6b17e67903ace8abb1d4d602bfc40d1994692ff":["65a5d87a40f9143cd55be76eb1dde1b32a8dae5e"],"ec54bd926c45854b5a1599685b0f7d2bfbfe177f":["a6b17e67903ace8abb1d4d602bfc40d1994692ff"],"a51ab9b1f1b896f06b7ba61672f0fca2a4fce43b":["f8061ddd97f3352007d927dae445884a6f3d857b","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d1a307447328c95a00248512b40d7a5ff12ecd6a","d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693"],"1c7a21395bae9e2f61aeb639f47aaca771c426ed":["55b50463286869f584cf849d1587a0fcd54d1dfa","a51ab9b1f1b896f06b7ba61672f0fca2a4fce43b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","7b13106276bb5ea342253dbf6aae7b675adb38d3"],"0463d2997b25fd01c7d3f0f93e6a523e5a4b5f68":["c5c99ad021f3da085fcb66220598a8f91dc5e453","55b50463286869f584cf849d1587a0fcd54d1dfa","1c7a21395bae9e2f61aeb639f47aaca771c426ed"],"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c":[],"d1a307447328c95a00248512b40d7a5ff12ecd6a":["f8061ddd97f3352007d927dae445884a6f3d857b","ec54bd926c45854b5a1599685b0f7d2bfbfe177f","d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693"],"d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693":[],"7b13106276bb5ea342253dbf6aae7b675adb38d3":["0463d2997b25fd01c7d3f0f93e6a523e5a4b5f68","6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["f8061ddd97f3352007d927dae445884a6f3d857b","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}