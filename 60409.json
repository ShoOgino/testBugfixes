{"path":"modules/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","commits":[{"id":"89f15687f60bd49cd3d9de427e85c17fd9397d61","date":1309381327,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"modules/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * This test is to address a bug (Tracker #146354) in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n      @Override\n      protected int fixedPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    // Commit Changes\n    writers[0].indexWriter.commit();\n    writers[0].taxWriter.commit();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      writers[0].taxWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    writers[0].taxWriter.commit();\n    readers[0].taxReader.refresh();\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(\n        readers[0].indexReader, readers[0].taxReader, iParams, null);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    outputFile.delete();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a4df66e06e0c3b520d7d5941e1c043076f06f17","date":1309454196,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"modules/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","pathOld":"modules/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","sourceNew":"  /**\n   * This test is to address a bug (Tracker #146354) in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n      @Override\n      protected int fixedPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    // Commit Changes\n    writers[0].indexWriter.commit();\n    writers[0].taxWriter.commit();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      writers[0].taxWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    writers[0].taxWriter.commit();\n    readers[0].taxReader.refresh();\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(\n        readers[0].indexReader, readers[0].taxReader, iParams, null);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    outputFile.delete();\n    writers[0].close();\n    readers[0].close();\n    IOUtils.closeSafely(false, dirs[0]);\n  }\n\n","sourceOld":"  /**\n   * This test is to address a bug (Tracker #146354) in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n      @Override\n      protected int fixedPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    // Commit Changes\n    writers[0].indexWriter.commit();\n    writers[0].taxWriter.commit();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      writers[0].taxWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    writers[0].taxWriter.commit();\n    readers[0].taxReader.refresh();\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(\n        readers[0].indexReader, readers[0].taxReader, iParams, null);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    outputFile.delete();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ccc019b3619afcedec96f9b28ac60c90e87d06c","date":1309679398,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"modules/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","pathOld":"modules/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","sourceNew":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n      @Override\n      protected int fixedPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    // Commit Changes\n    writers[0].indexWriter.commit();\n    writers[0].taxWriter.commit();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      writers[0].taxWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    writers[0].taxWriter.commit();\n    readers[0].taxReader.refresh();\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(\n        readers[0].indexReader, readers[0].taxReader, iParams, null);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    outputFile.delete();\n    writers[0].close();\n    readers[0].close();\n    IOUtils.closeSafely(false, dirs[0]);\n  }\n\n","sourceOld":"  /**\n   * This test is to address a bug (Tracker #146354) in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n      @Override\n      protected int fixedPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    // Commit Changes\n    writers[0].indexWriter.commit();\n    writers[0].taxWriter.commit();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      writers[0].taxWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    writers[0].taxWriter.commit();\n    readers[0].taxReader.refresh();\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(\n        readers[0].indexReader, readers[0].taxReader, iParams, null);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    outputFile.delete();\n    writers[0].close();\n    readers[0].close();\n    IOUtils.closeSafely(false, dirs[0]);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"817d8435e9135b756f08ce6710ab0baac51bdf88","date":1309986993,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"modules/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n      @Override\n      protected int fixedPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    // Commit Changes\n    writers[0].indexWriter.commit();\n    writers[0].taxWriter.commit();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      writers[0].taxWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    writers[0].taxWriter.commit();\n    readers[0].taxReader.refresh();\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(\n        readers[0].indexReader, readers[0].taxReader, iParams, null);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    outputFile.delete();\n    writers[0].close();\n    readers[0].close();\n    IOUtils.closeSafely(false, dirs[0]);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"modules/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n      @Override\n      protected int fixedPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    // Commit Changes\n    writers[0].indexWriter.commit();\n    writers[0].taxWriter.commit();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      writers[0].taxWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    writers[0].taxWriter.commit();\n    readers[0].taxReader.refresh();\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(\n        readers[0].indexReader, readers[0].taxReader, iParams, null);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    outputFile.delete();\n    writers[0].close();\n    readers[0].close();\n    IOUtils.closeSafely(false, dirs[0]);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"24230fe54121f9be9d85f2c2067536296785e421","date":1314462346,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","pathOld":"modules/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","sourceNew":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n      @Override\n      protected int fixedPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    // Commit Changes\n    writers[0].indexWriter.commit();\n    writers[0].taxWriter.commit();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      writers[0].taxWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    writers[0].taxWriter.commit();\n    readers[0].taxReader.refresh();\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(\n        readers[0].indexReader, readers[0].taxReader, iParams, null);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    outputFile.delete();\n    writers[0].close();\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n  }\n\n","sourceOld":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n      @Override\n      protected int fixedPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    // Commit Changes\n    writers[0].indexWriter.commit();\n    writers[0].taxWriter.commit();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      writers[0].taxWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    writers[0].taxWriter.commit();\n    readers[0].taxReader.refresh();\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(\n        readers[0].indexReader, readers[0].taxReader, iParams, null);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    outputFile.delete();\n    writers[0].close();\n    readers[0].close();\n    IOUtils.closeSafely(false, dirs[0]);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","pathOld":"modules/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","sourceNew":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n      @Override\n      protected int fixedPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    // Commit Changes\n    writers[0].indexWriter.commit();\n    writers[0].taxWriter.commit();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      writers[0].taxWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    writers[0].taxWriter.commit();\n    readers[0].taxReader.refresh();\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(\n        readers[0].indexReader, readers[0].taxReader, iParams, null);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    outputFile.delete();\n    writers[0].close();\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n  }\n\n","sourceOld":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n      @Override\n      protected int fixedPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    // Commit Changes\n    writers[0].indexWriter.commit();\n    writers[0].taxWriter.commit();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      writers[0].taxWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    writers[0].taxWriter.commit();\n    readers[0].taxReader.refresh();\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(\n        readers[0].indexReader, readers[0].taxReader, iParams, null);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    outputFile.delete();\n    writers[0].close();\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"24230fe54121f9be9d85f2c2067536296785e421":["5ccc019b3619afcedec96f9b28ac60c90e87d06c"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["24230fe54121f9be9d85f2c2067536296785e421"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7a4df66e06e0c3b520d7d5941e1c043076f06f17":["89f15687f60bd49cd3d9de427e85c17fd9397d61"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5ccc019b3619afcedec96f9b28ac60c90e87d06c"],"89f15687f60bd49cd3d9de427e85c17fd9397d61":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5ccc019b3619afcedec96f9b28ac60c90e87d06c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"5ccc019b3619afcedec96f9b28ac60c90e87d06c":["7a4df66e06e0c3b520d7d5941e1c043076f06f17"]},"commit2Childs":{"24230fe54121f9be9d85f2c2067536296785e421":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d083e83f225b11e5fdd900e83d26ddb385b6955c","89f15687f60bd49cd3d9de427e85c17fd9397d61","817d8435e9135b756f08ce6710ab0baac51bdf88"],"7a4df66e06e0c3b520d7d5941e1c043076f06f17":["5ccc019b3619afcedec96f9b28ac60c90e87d06c"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"89f15687f60bd49cd3d9de427e85c17fd9397d61":["7a4df66e06e0c3b520d7d5941e1c043076f06f17"],"817d8435e9135b756f08ce6710ab0baac51bdf88":[],"5ccc019b3619afcedec96f9b28ac60c90e87d06c":["24230fe54121f9be9d85f2c2067536296785e421","d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}