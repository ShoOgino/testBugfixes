{"path":"solr/core/src/java/org/apache/solr/spelling/SolrSpellChecker#mergeSuggestions(SpellCheckMergeData,int,int,boolean).mjava","commits":[{"id":"51338b5fe0f5d865f3d3ce9ed83d94ae4733a8c5","date":1320922486,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/SolrSpellChecker#mergeSuggestions(SpellCheckMergeData,int,int,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Integrate spelling suggestions from the various shards in a distributed environment.\n   * \n   * @param mergeData\n   * @param numSug\n   * @param count\n   * @param extendedResults\n   * @return\n   */\n  public SpellingResult mergeSuggestions(SpellCheckMergeData mergeData, int numSug, int count, boolean extendedResults) {\n    float min = 0.5f;\n    try {\n      min = getAccuracy();\n    } catch(UnsupportedOperationException uoe) {\n      //just use .5 as a default\n    }\n    \n    StringDistance sd = getStringDistance() == null ? new LevensteinDistance() : getStringDistance();    \n    \n    SpellingResult result = new SpellingResult();\n    for (Map.Entry<String, HashSet<String>> entry : mergeData.origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = mergeData.origVsShards.get(original);\n      if(numShards<mergeData.totalNumberShardResponses) {\n        continue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = mergeData.suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = mergeData.origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = mergeData.origVsFreq.get(original);\n        if (o != null) result.addFrequency(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["8e65acce892eede973379cb2fb3b90ea49a4a5ed","e5669b3a04027da8d07171c431fae44c3c96e075"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e5669b3a04027da8d07171c431fae44c3c96e075","date":1320938299,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/SolrSpellChecker#mergeSuggestions(SpellCheckMergeData,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/SolrSpellChecker#mergeSuggestions(SpellCheckMergeData,int,int,boolean).mjava","sourceNew":"  /**\n   * Integrate spelling suggestions from the various shards in a distributed environment.\n   * \n   * @param mergeData\n   * @param numSug\n   * @param count\n   * @param extendedResults\n   */\n  public SpellingResult mergeSuggestions(SpellCheckMergeData mergeData, int numSug, int count, boolean extendedResults) {\n    float min = 0.5f;\n    try {\n      min = getAccuracy();\n    } catch(UnsupportedOperationException uoe) {\n      //just use .5 as a default\n    }\n    \n    StringDistance sd = getStringDistance() == null ? new LevensteinDistance() : getStringDistance();    \n    \n    SpellingResult result = new SpellingResult();\n    for (Map.Entry<String, HashSet<String>> entry : mergeData.origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = mergeData.origVsShards.get(original);\n      if(numShards<mergeData.totalNumberShardResponses) {\n        continue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = mergeData.suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = mergeData.origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = mergeData.origVsFreq.get(original);\n        if (o != null) result.addFrequency(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Integrate spelling suggestions from the various shards in a distributed environment.\n   * \n   * @param mergeData\n   * @param numSug\n   * @param count\n   * @param extendedResults\n   * @return\n   */\n  public SpellingResult mergeSuggestions(SpellCheckMergeData mergeData, int numSug, int count, boolean extendedResults) {\n    float min = 0.5f;\n    try {\n      min = getAccuracy();\n    } catch(UnsupportedOperationException uoe) {\n      //just use .5 as a default\n    }\n    \n    StringDistance sd = getStringDistance() == null ? new LevensteinDistance() : getStringDistance();    \n    \n    SpellingResult result = new SpellingResult();\n    for (Map.Entry<String, HashSet<String>> entry : mergeData.origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = mergeData.origVsShards.get(original);\n      if(numShards<mergeData.totalNumberShardResponses) {\n        continue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = mergeData.suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = mergeData.origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = mergeData.origVsFreq.get(original);\n        if (o != null) result.addFrequency(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    return result;\n  }\n\n","bugFix":["51338b5fe0f5d865f3d3ce9ed83d94ae4733a8c5"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ad9ec888e587ca9a3279368245cdf00aabdc108","date":1338832525,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/SolrSpellChecker#mergeSuggestions(SpellCheckMergeData,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/SolrSpellChecker#mergeSuggestions(SpellCheckMergeData,int,int,boolean).mjava","sourceNew":"  /**\n   * Integrate spelling suggestions from the various shards in a distributed environment.\n   * \n   * @param mergeData\n   * @param numSug\n   * @param count\n   * @param extendedResults\n   */\n  public SpellingResult mergeSuggestions(SpellCheckMergeData mergeData, int numSug, int count, boolean extendedResults) {\n    float min = 0.5f;\n    try {\n      min = getAccuracy();\n    } catch(UnsupportedOperationException uoe) {\n      //just use .5 as a default\n    }\n    \n    StringDistance sd = null;\n    try {\n      sd = getStringDistance() == null ? new LevensteinDistance() : getStringDistance();    \n    } catch(UnsupportedOperationException uoe) {\n      sd = new LevensteinDistance();\n    }\n    \n    SpellingResult result = new SpellingResult();\n    for (Map.Entry<String, HashSet<String>> entry : mergeData.origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = mergeData.origVsShards.get(original);\n      if(numShards<mergeData.totalNumberShardResponses) {\n        continue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = mergeData.suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = mergeData.origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = mergeData.origVsFreq.get(original);\n        if (o != null) result.addFrequency(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Integrate spelling suggestions from the various shards in a distributed environment.\n   * \n   * @param mergeData\n   * @param numSug\n   * @param count\n   * @param extendedResults\n   */\n  public SpellingResult mergeSuggestions(SpellCheckMergeData mergeData, int numSug, int count, boolean extendedResults) {\n    float min = 0.5f;\n    try {\n      min = getAccuracy();\n    } catch(UnsupportedOperationException uoe) {\n      //just use .5 as a default\n    }\n    \n    StringDistance sd = getStringDistance() == null ? new LevensteinDistance() : getStringDistance();    \n    \n    SpellingResult result = new SpellingResult();\n    for (Map.Entry<String, HashSet<String>> entry : mergeData.origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = mergeData.origVsShards.get(original);\n      if(numShards<mergeData.totalNumberShardResponses) {\n        continue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = mergeData.suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = mergeData.origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = mergeData.origVsFreq.get(original);\n        if (o != null) result.addFrequency(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":["d042843368f0d289e28164525546259d89d6dbb6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069","date":1348430063,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/SolrSpellChecker#mergeSuggestions(SpellCheckMergeData,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/SolrSpellChecker#mergeSuggestions(SpellCheckMergeData,int,int,boolean).mjava","sourceNew":"  /**\n   * Integrate spelling suggestions from the various shards in a distributed environment.\n   */\n  public SpellingResult mergeSuggestions(SpellCheckMergeData mergeData, int numSug, int count, boolean extendedResults) {\n    float min = 0.5f;\n    try {\n      min = getAccuracy();\n    } catch(UnsupportedOperationException uoe) {\n      //just use .5 as a default\n    }\n    \n    StringDistance sd = null;\n    try {\n      sd = getStringDistance() == null ? new LevensteinDistance() : getStringDistance();    \n    } catch(UnsupportedOperationException uoe) {\n      sd = new LevensteinDistance();\n    }\n    \n    SpellingResult result = new SpellingResult();\n    for (Map.Entry<String, HashSet<String>> entry : mergeData.origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = mergeData.origVsShards.get(original);\n      if(numShards<mergeData.totalNumberShardResponses) {\n        continue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = mergeData.suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = mergeData.origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = mergeData.origVsFreq.get(original);\n        if (o != null) result.addFrequency(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Integrate spelling suggestions from the various shards in a distributed environment.\n   * \n   * @param mergeData\n   * @param numSug\n   * @param count\n   * @param extendedResults\n   */\n  public SpellingResult mergeSuggestions(SpellCheckMergeData mergeData, int numSug, int count, boolean extendedResults) {\n    float min = 0.5f;\n    try {\n      min = getAccuracy();\n    } catch(UnsupportedOperationException uoe) {\n      //just use .5 as a default\n    }\n    \n    StringDistance sd = null;\n    try {\n      sd = getStringDistance() == null ? new LevensteinDistance() : getStringDistance();    \n    } catch(UnsupportedOperationException uoe) {\n      sd = new LevensteinDistance();\n    }\n    \n    SpellingResult result = new SpellingResult();\n    for (Map.Entry<String, HashSet<String>> entry : mergeData.origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = mergeData.origVsShards.get(original);\n      if(numShards<mergeData.totalNumberShardResponses) {\n        continue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = mergeData.suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = mergeData.origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = mergeData.origVsFreq.get(original);\n        if (o != null) result.addFrequency(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/SolrSpellChecker#mergeSuggestions(SpellCheckMergeData,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/SolrSpellChecker#mergeSuggestions(SpellCheckMergeData,int,int,boolean).mjava","sourceNew":"  /**\n   * Integrate spelling suggestions from the various shards in a distributed environment.\n   */\n  public SpellingResult mergeSuggestions(SpellCheckMergeData mergeData, int numSug, int count, boolean extendedResults) {\n    float min = 0.5f;\n    try {\n      min = getAccuracy();\n    } catch(UnsupportedOperationException uoe) {\n      //just use .5 as a default\n    }\n    \n    StringDistance sd = null;\n    try {\n      sd = getStringDistance() == null ? new LevensteinDistance() : getStringDistance();    \n    } catch(UnsupportedOperationException uoe) {\n      sd = new LevensteinDistance();\n    }\n    \n    SpellingResult result = new SpellingResult();\n    for (Map.Entry<String, HashSet<String>> entry : mergeData.origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = mergeData.origVsShards.get(original);\n      if(numShards<mergeData.totalNumberShardResponses) {\n        continue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = mergeData.suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = mergeData.origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = mergeData.origVsFreq.get(original);\n        if (o != null) result.addFrequency(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Integrate spelling suggestions from the various shards in a distributed environment.\n   */\n  public SpellingResult mergeSuggestions(SpellCheckMergeData mergeData, int numSug, int count, boolean extendedResults) {\n    float min = 0.5f;\n    try {\n      min = getAccuracy();\n    } catch(UnsupportedOperationException uoe) {\n      //just use .5 as a default\n    }\n    \n    StringDistance sd = null;\n    try {\n      sd = getStringDistance() == null ? new LevensteinDistance() : getStringDistance();    \n    } catch(UnsupportedOperationException uoe) {\n      sd = new LevensteinDistance();\n    }\n    \n    SpellingResult result = new SpellingResult();\n    for (Map.Entry<String, HashSet<String>> entry : mergeData.origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = mergeData.origVsShards.get(original);\n      if(numShards<mergeData.totalNumberShardResponses) {\n        continue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = mergeData.suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = mergeData.origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = mergeData.origVsFreq.get(original);\n        if (o != null) result.addFrequency(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8e65acce892eede973379cb2fb3b90ea49a4a5ed","date":1409839025,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/SolrSpellChecker#mergeSuggestions(SpellCheckMergeData,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/SolrSpellChecker#mergeSuggestions(SpellCheckMergeData,int,int,boolean).mjava","sourceNew":"  /**\n   * Integrate spelling suggestions from the various shards in a distributed environment.\n   */\n  public SpellingResult mergeSuggestions(SpellCheckMergeData mergeData, int numSug, int count, boolean extendedResults) {\n    float min = 0.5f;\n    try {\n      min = getAccuracy();\n    } catch(UnsupportedOperationException uoe) {\n      //just use .5 as a default\n    }\n    \n    StringDistance sd = null;\n    try {\n      sd = getStringDistance() == null ? new LevensteinDistance() : getStringDistance();    \n    } catch(UnsupportedOperationException uoe) {\n      sd = new LevensteinDistance();\n    }\n    \n    SpellingResult result = new SpellingResult();\n    for (Map.Entry<String, HashSet<String>> entry : mergeData.origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled, \n      //unless it was not a term original to the user's query\n      //(WordBreakSolrSpellChecker can add new terms to the response, and we want to keep these)\n      Integer numShards = mergeData.origVsShards.get(original);\n      if(numShards<mergeData.totalNumberShardResponses && mergeData.isOriginalToQuery(original)) {\n        continue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = mergeData.suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = mergeData.origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = mergeData.origVsFreq.get(original);\n        if (o != null) result.addFrequency(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Integrate spelling suggestions from the various shards in a distributed environment.\n   */\n  public SpellingResult mergeSuggestions(SpellCheckMergeData mergeData, int numSug, int count, boolean extendedResults) {\n    float min = 0.5f;\n    try {\n      min = getAccuracy();\n    } catch(UnsupportedOperationException uoe) {\n      //just use .5 as a default\n    }\n    \n    StringDistance sd = null;\n    try {\n      sd = getStringDistance() == null ? new LevensteinDistance() : getStringDistance();    \n    } catch(UnsupportedOperationException uoe) {\n      sd = new LevensteinDistance();\n    }\n    \n    SpellingResult result = new SpellingResult();\n    for (Map.Entry<String, HashSet<String>> entry : mergeData.origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = mergeData.origVsShards.get(original);\n      if(numShards<mergeData.totalNumberShardResponses) {\n        continue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = mergeData.suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = mergeData.origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = mergeData.origVsFreq.get(original);\n        if (o != null) result.addFrequency(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    return result;\n  }\n\n","bugFix":["51338b5fe0f5d865f3d3ce9ed83d94ae4733a8c5"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d042843368f0d289e28164525546259d89d6dbb6","date":1512577756,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/SolrSpellChecker#mergeSuggestions(SpellCheckMergeData,int,int,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/SolrSpellChecker#mergeSuggestions(SpellCheckMergeData,int,int,boolean).mjava","sourceNew":"  /**\n   * Integrate spelling suggestions from the various shards in a distributed environment.\n   */\n  public SpellingResult mergeSuggestions(SpellCheckMergeData mergeData, int numSug, int count, boolean extendedResults) {\n    float min = 0.5f;\n    try {\n      min = getAccuracy();\n    } catch(UnsupportedOperationException uoe) {\n      //just use .5 as a default\n    }\n    \n    StringDistance sd = null;\n    try {\n      sd = getStringDistance() == null ? new LevenshteinDistance() : getStringDistance();    \n    } catch(UnsupportedOperationException uoe) {\n      sd = new LevenshteinDistance();\n    }\n    \n    SpellingResult result = new SpellingResult();\n    for (Map.Entry<String, HashSet<String>> entry : mergeData.origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled, \n      //unless it was not a term original to the user's query\n      //(WordBreakSolrSpellChecker can add new terms to the response, and we want to keep these)\n      Integer numShards = mergeData.origVsShards.get(original);\n      if(numShards<mergeData.totalNumberShardResponses && mergeData.isOriginalToQuery(original)) {\n        continue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = mergeData.suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = mergeData.origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = mergeData.origVsFreq.get(original);\n        if (o != null) result.addFrequency(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Integrate spelling suggestions from the various shards in a distributed environment.\n   */\n  public SpellingResult mergeSuggestions(SpellCheckMergeData mergeData, int numSug, int count, boolean extendedResults) {\n    float min = 0.5f;\n    try {\n      min = getAccuracy();\n    } catch(UnsupportedOperationException uoe) {\n      //just use .5 as a default\n    }\n    \n    StringDistance sd = null;\n    try {\n      sd = getStringDistance() == null ? new LevensteinDistance() : getStringDistance();    \n    } catch(UnsupportedOperationException uoe) {\n      sd = new LevensteinDistance();\n    }\n    \n    SpellingResult result = new SpellingResult();\n    for (Map.Entry<String, HashSet<String>> entry : mergeData.origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled, \n      //unless it was not a term original to the user's query\n      //(WordBreakSolrSpellChecker can add new terms to the response, and we want to keep these)\n      Integer numShards = mergeData.origVsShards.get(original);\n      if(numShards<mergeData.totalNumberShardResponses && mergeData.isOriginalToQuery(original)) {\n        continue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = mergeData.suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = mergeData.origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = mergeData.origVsFreq.get(original);\n        if (o != null) result.addFrequency(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    return result;\n  }\n\n","bugFix":["0ad9ec888e587ca9a3279368245cdf00aabdc108"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["0ad9ec888e587ca9a3279368245cdf00aabdc108"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069"],"0ad9ec888e587ca9a3279368245cdf00aabdc108":["e5669b3a04027da8d07171c431fae44c3c96e075"],"8e65acce892eede973379cb2fb3b90ea49a4a5ed":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"e5669b3a04027da8d07171c431fae44c3c96e075":["51338b5fe0f5d865f3d3ce9ed83d94ae4733a8c5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"51338b5fe0f5d865f3d3ce9ed83d94ae4733a8c5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d042843368f0d289e28164525546259d89d6dbb6":["8e65acce892eede973379cb2fb3b90ea49a4a5ed"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d042843368f0d289e28164525546259d89d6dbb6"]},"commit2Childs":{"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["8e65acce892eede973379cb2fb3b90ea49a4a5ed"],"0ad9ec888e587ca9a3279368245cdf00aabdc108":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069"],"8e65acce892eede973379cb2fb3b90ea49a4a5ed":["d042843368f0d289e28164525546259d89d6dbb6"],"e5669b3a04027da8d07171c431fae44c3c96e075":["0ad9ec888e587ca9a3279368245cdf00aabdc108"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["51338b5fe0f5d865f3d3ce9ed83d94ae4733a8c5"],"51338b5fe0f5d865f3d3ce9ed83d94ae4733a8c5":["e5669b3a04027da8d07171c431fae44c3c96e075"],"d042843368f0d289e28164525546259d89d6dbb6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}