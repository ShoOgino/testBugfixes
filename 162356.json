{"path":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","sourceNew":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    Searcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new Collector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n\n        @Override\n        public void setNextReader(IndexReader reader, int docBase) { }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","sourceOld":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    Searcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new Collector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n\n        @Override\n        public void setNextReader(IndexReader reader, int docBase) { }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b241ea5e635d896cc0af83cd96ffd0322e0aba7","date":1294226200,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","pathOld":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","sourceNew":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new Collector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n\n        @Override\n        public void setNextReader(IndexReader reader, int docBase) { }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","sourceOld":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    Searcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new Collector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n\n        @Override\n        public void setNextReader(IndexReader reader, int docBase) { }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"70ad682703b8585f5d0a637efec044d57ec05efb","date":1294259117,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","pathOld":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","sourceNew":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new Collector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n\n        @Override\n        public void setNextReader(IndexReader reader, int docBase) { }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","sourceOld":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    Searcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new Collector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n\n        @Override\n        public void setNextReader(IndexReader reader, int docBase) { }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"323f871ffe96b871d8c534a614be60751bb023c2","date":1294820532,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","pathOld":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","sourceNew":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new Collector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n\n        @Override\n        public void setNextReader(AtomicReaderContext context) { }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","sourceOld":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new Collector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n\n        @Override\n        public void setNextReader(IndexReader reader, int docBase) { }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","pathOld":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","sourceNew":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new Collector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n\n        @Override\n        public void setNextReader(AtomicReaderContext context) { }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","sourceOld":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    Searcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new Collector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n\n        @Override\n        public void setNextReader(IndexReader reader, int docBase) { }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","pathOld":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","sourceNew":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new Collector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n\n        @Override\n        public void setNextReader(AtomicReaderContext context) { }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","sourceOld":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new Collector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n\n        @Override\n        public void setNextReader(IndexReader reader, int docBase) { }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","pathOld":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#search(Query).mjava","sourceNew":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new Collector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n\n        @Override\n        public void setNextReader(AtomicReaderContext context) { }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","sourceOld":"  /**\n   * Convenience method that efficiently returns the relevance score by\n   * matching this index against the given Lucene query expression.\n   * \n   * @param query\n   *            an arbitrary Lucene query to run against this index\n   * @return the relevance score of the matchmaking; A number in the range\n   *         [0.0 .. 1.0], with 0.0 indicating no match. The higher the number\n   *         the better the match.\n   *\n   */\n  public float search(Query query) {\n    if (query == null) \n      throw new IllegalArgumentException(\"query must not be null\");\n    \n    IndexSearcher searcher = createSearcher();\n    try {\n      final float[] scores = new float[1]; // inits to 0.0f (no match)\n      searcher.search(query, new Collector() {\n        private Scorer scorer;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          scores[0] = scorer.score();\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) throws IOException {\n          this.scorer = scorer;\n        }\n\n        @Override\n        public boolean acceptsDocsOutOfOrder() {\n          return true;\n        }\n\n        @Override\n        public void setNextReader(AtomicReaderContext context) { }\n      });\n      float score = scores[0];\n      return score;\n    } catch (IOException e) { // can never happen (RAMDirectory)\n      throw new RuntimeException(e);\n    } finally {\n      // searcher.close();\n      /*\n       * Note that it is harmless and important for good performance to\n       * NOT close the index reader!!! This avoids all sorts of\n       * unnecessary baggage and locking in the Lucene IndexReader\n       * superclass, all of which is completely unnecessary for this main\n       * memory index data structure without thread-safety claims.\n       * \n       * Wishing IndexReader would be an interface...\n       * \n       * Actually with the new tight createSearcher() API auto-closing is now\n       * made impossible, hence searcher.close() would be harmless and also \n       * would not degrade performance...\n       */\n    }   \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"70ad682703b8585f5d0a637efec044d57ec05efb":["9454a6510e2db155fb01faa5c049b06ece95fab9","8b241ea5e635d896cc0af83cd96ffd0322e0aba7"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["323f871ffe96b871d8c534a614be60751bb023c2"],"323f871ffe96b871d8c534a614be60751bb023c2":["8b241ea5e635d896cc0af83cd96ffd0322e0aba7"],"8b241ea5e635d896cc0af83cd96ffd0322e0aba7":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["70ad682703b8585f5d0a637efec044d57ec05efb","323f871ffe96b871d8c534a614be60751bb023c2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"868da859b43505d9d2a023bfeae6dd0c795f5295":["9454a6510e2db155fb01faa5c049b06ece95fab9","323f871ffe96b871d8c534a614be60751bb023c2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"70ad682703b8585f5d0a637efec044d57ec05efb":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"323f871ffe96b871d8c534a614be60751bb023c2":["b89678825b68eccaf09e6ab71675fc0b0af1e099","29ef99d61cda9641b6250bf9567329a6e65f901d","868da859b43505d9d2a023bfeae6dd0c795f5295"],"8b241ea5e635d896cc0af83cd96ffd0322e0aba7":["70ad682703b8585f5d0a637efec044d57ec05efb","323f871ffe96b871d8c534a614be60751bb023c2"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"868da859b43505d9d2a023bfeae6dd0c795f5295":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["70ad682703b8585f5d0a637efec044d57ec05efb","8b241ea5e635d896cc0af83cd96ffd0322e0aba7","868da859b43505d9d2a023bfeae6dd0c795f5295"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["29ef99d61cda9641b6250bf9567329a6e65f901d","868da859b43505d9d2a023bfeae6dd0c795f5295","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}