{"path":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","commits":[{"id":"8ec805ca8fedc0166461148c7182f1bcbbd18ee1","date":1489767223,"type":0,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"num_d\", \"num_d\");\n    String cat_s = p.get(\"cat_s\");\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", cat_s, \"A\", num_d, -1) ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", cat_s, \"B\", num_d, 3) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", cat_s, \"B\", num_d, -5) ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", cat_s, \"B\", num_d, -11) );\n    clients.get(1).add( sdoc(\"id\", \"13\", cat_s, \"A\", num_d, 7) );\n\n    clients.get(2).add( sdoc(\"id\", \"21\", cat_s, \"A\", num_d, 17) ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", cat_s, \"A\", num_d, -19) );\n    clients.get(2).add( sdoc(\"id\", \"23\", cat_s, \"B\", num_d, 11) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shar w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["15b321aed72eecb043f237c490b9afd4e52c25be"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"58b93c361b4f6fe193e84bfd27ea523366eada52","date":1490100167,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","sourceNew":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"num_d\", \"num_d\");\n    String cat_s = p.get(\"cat_s\");\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", num_d, -1) ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", num_d, 3) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", num_d, -5) ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", num_d, -11) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", num_d, 7) );\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", num_d, 17) ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", num_d, -19) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", num_d, 11) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{type:terms, field:all_s,  facet:{  cat3:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n\n  }\n\n","sourceOld":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"num_d\", \"num_d\");\n    String cat_s = p.get(\"cat_s\");\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", cat_s, \"A\", num_d, -1) ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", cat_s, \"B\", num_d, 3) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", cat_s, \"B\", num_d, -5) ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", cat_s, \"B\", num_d, -11) );\n    clients.get(1).add( sdoc(\"id\", \"13\", cat_s, \"A\", num_d, 7) );\n\n    clients.get(2).add( sdoc(\"id\", \"21\", cat_s, \"A\", num_d, 17) ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", cat_s, \"A\", num_d, -19) );\n    clients.get(2).add( sdoc(\"id\", \"23\", cat_s, \"B\", num_d, 11) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shar w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"11ab475c994c79138885cc8a30b2641d929cdc43","date":1490280010,"type":0,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"num_d\", \"num_d\");\n    String cat_s = p.get(\"cat_s\");\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", cat_s, \"A\", num_d, -1) ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", cat_s, \"B\", num_d, 3) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", cat_s, \"B\", num_d, -5) ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", cat_s, \"B\", num_d, -11) );\n    clients.get(1).add( sdoc(\"id\", \"13\", cat_s, \"A\", num_d, 7) );\n\n    clients.get(2).add( sdoc(\"id\", \"21\", cat_s, \"A\", num_d, 17) ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", cat_s, \"A\", num_d, -19) );\n    clients.get(2).add( sdoc(\"id\", \"23\", cat_s, \"B\", num_d, 11) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shar w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8908009aaa8e9318b455c1c22b83e0e87738228a","date":1490280013,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","sourceNew":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"num_d\", \"num_d\");\n    String cat_s = p.get(\"cat_s\");\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", num_d, -1) ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", num_d, 3) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", num_d, -5) ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", num_d, -11) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", num_d, 7) );\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", num_d, 17) ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", num_d, -19) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", num_d, 11) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{type:terms, field:all_s,  facet:{  cat3:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n\n  }\n\n","sourceOld":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"num_d\", \"num_d\");\n    String cat_s = p.get(\"cat_s\");\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", cat_s, \"A\", num_d, -1) ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", cat_s, \"B\", num_d, 3) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", cat_s, \"B\", num_d, -5) ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", cat_s, \"B\", num_d, -11) );\n    clients.get(1).add( sdoc(\"id\", \"13\", cat_s, \"A\", num_d, 7) );\n\n    clients.get(2).add( sdoc(\"id\", \"21\", cat_s, \"A\", num_d, 17) ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", cat_s, \"A\", num_d, -19) );\n    clients.get(2).add( sdoc(\"id\", \"23\", cat_s, \"B\", num_d, 11) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shar w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cb287e8b4595ddf413c318d5631789c8c8e8719","date":1490402624,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","sourceNew":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\");\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1) ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5) ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7) );\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17) ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{type:terms, field:all_s,  facet:{  cat3:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test missing buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _m buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _m buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _m buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n  }\n\n","sourceOld":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"num_d\", \"num_d\");\n    String cat_s = p.get(\"cat_s\");\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", num_d, -1) ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", num_d, 3) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", num_d, -5) ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", num_d, -11) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", num_d, 7) );\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", num_d, 17) ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", num_d, -19) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", num_d, 11) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{type:terms, field:all_s,  facet:{  cat3:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"52dc05802ffecefaecf5879a40a61539b5c985f0","date":1490594650,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","sourceNew":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\");\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1) ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5) ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7) );\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17) ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{type:terms, field:all_s,  facet:{  cat3:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test missing buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _m buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _m buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _m buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n  }\n\n","sourceOld":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"num_d\", \"num_d\");\n    String cat_s = p.get(\"cat_s\");\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", num_d, -1) ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", num_d, 3) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", num_d, -5) ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", num_d, -11) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", num_d, 7) );\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", num_d, 17) ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", num_d, -19) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", num_d, 11) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{type:terms, field:all_s,  facet:{  cat3:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85d473096f870b9bf3e231200a07e8eefa30eef8","date":1490745171,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","sourceNew":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\");\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1) ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5) ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7) );\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17) ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{type:terms, field:all_s,  facet:{  cat3:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test missing buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n  }\n\n","sourceOld":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\");\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1) ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5) ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7) );\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17) ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{type:terms, field:all_s,  facet:{  cat3:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test missing buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _m buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _m buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _m buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c2dbdcf79d0d3310dcd4ddf2f628d415ec2e4be5","date":1490873946,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","sourceNew":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\");\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1) ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5) ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7) );\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17) ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{type:terms, field:all_s,  facet:{  cat3:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test missing buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n  }\n\n","sourceOld":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\");\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1) ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5) ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7) );\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17) ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{type:terms, field:all_s,  facet:{  cat3:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test missing buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _m buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _m buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _m buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09b2046a929f8ee073bf5b75cbbf2b60e413a6bd","date":1490979270,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","sourceNew":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\");\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1) ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5) ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7) );\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17) ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{type:terms, field:all_s,  facet:{  cat3:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n\n\n  }\n\n","sourceOld":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\");\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1) ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5) ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7) );\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17) ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{type:terms, field:all_s,  facet:{  cat3:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test missing buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7682bc2094c8206c9527a8d3833b5c553581b943","date":1490979315,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","sourceNew":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\", \"qw_s\", \"qw_s\");\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1,  qw_s, \"Q\") ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3             ) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5            ) ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11, qw_s, \"W\") );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7             ) );\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17,  qw_s, \"W\") ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19           ) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11            ) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{type:terms, field:all_s,  facet:{  cat3:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            // test all values missing in sub-facet\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n            // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n            \", cd :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n            \", cd2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n            \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n            \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n            \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n            \"}\"\n    );\n\n\n\n  }\n\n","sourceOld":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\");\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1) ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5) ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7) );\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17) ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{type:terms, field:all_s,  facet:{  cat3:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"14abccfea62dff435ac0457e128ca6bc703087d6","date":1491045405,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","sourceNew":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\");\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1) ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5) ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7) );\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17) ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{type:terms, field:all_s,  facet:{  cat3:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n\n\n  }\n\n","sourceOld":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\");\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1) ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5) ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7) );\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17) ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{type:terms, field:all_s,  facet:{  cat3:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test missing buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"49d73292e024d8ee1883fc327099adde4bcffd7a","date":1491045405,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","sourceNew":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\", \"qw_s\", \"qw_s\");\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1,  qw_s, \"Q\") ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3             ) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5            ) ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11, qw_s, \"W\") );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7             ) );\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17,  qw_s, \"W\") ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19           ) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11            ) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{type:terms, field:all_s,  facet:{  cat3:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            // test all values missing in sub-facet\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n            // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n            \", cd :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n            \", cd2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n            \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n            \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n            \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n            \"}\"\n    );\n\n\n\n  }\n\n","sourceOld":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\");\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1) ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5) ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7) );\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17) ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{type:terms, field:all_s,  facet:{  cat3:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"10c711bb8c3aac052fb8e0e9d417517c94166d5d","date":1491485369,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","sourceNew":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\", \"qw_s\", \"qw_s\");\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1,  qw_s, \"Q\") ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3             ) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5            ) ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11, qw_s, \"W\") );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7             ) );\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17,  qw_s, \"W\") ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19           ) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11            ) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{type:terms, field:all_s,  facet:{  cat3:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            // test all values missing in sub-facet\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n            // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n            \", cd :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n            \", cd2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n            \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n            \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n            \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing \"allBuckets\"\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n            \", cat2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n            \", cat3:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n            \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n            \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n            \"}\"\n    );\n  }\n\n","sourceOld":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\", \"qw_s\", \"qw_s\");\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1,  qw_s, \"Q\") ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3             ) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5            ) ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11, qw_s, \"W\") );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7             ) );\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17,  qw_s, \"W\") ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19           ) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11            ) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{type:terms, field:all_s,  facet:{  cat3:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            // test all values missing in sub-facet\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n            // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n            \", cd :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n            \", cd2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n            \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n            \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n            \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n            \"}\"\n    );\n\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","sourceNew":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\", \"qw_s\", \"qw_s\");\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1,  qw_s, \"Q\") ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3             ) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5            ) ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11, qw_s, \"W\") );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7             ) );\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17,  qw_s, \"W\") ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19           ) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11            ) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{type:terms, field:all_s,  facet:{  cat3:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            // test all values missing in sub-facet\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n            // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n            \", cd :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n            \", cd2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n            \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n            \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n            \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing \"allBuckets\"\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n            \", cat2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n            \", cat3:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n            \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n            \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n            \"}\"\n    );\n  }\n\n","sourceOld":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\", \"qw_s\", \"qw_s\");\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1,  qw_s, \"Q\") ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3             ) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5            ) ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11, qw_s, \"W\") );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7             ) );\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17,  qw_s, \"W\") ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19           ) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11            ) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{type:terms, field:all_s,  facet:{  cat3:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            // test all values missing in sub-facet\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n            // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n            \", cd :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n            \", cd2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n            \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n            \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n            \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n            \"}\"\n    );\n\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"84e83c6774414730d58276083becadc66f4e4aca","date":1493132430,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","sourceNew":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\", \"qw_s\", \"qw_s\", \"er_s\",\"er_s\");\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1,  qw_s, \"Q\", er_s,\"E\") ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3                       ) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5            , er_s,\"E\") ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11, qw_s, \"W\"          ) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7             , er_s,\"R\") );       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17,  qw_s, \"W\", er_s,\"E\") ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19                     ) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11                      ) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{type:terms, field:all_s,  facet:{  cat3:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            // test all values missing in sub-facet\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n            // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n            \", cd :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n            \", cd2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n            \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n            \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n            \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing \"allBuckets\"\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n            \", cat2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n            \", cat3:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n            \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n            \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing numBuckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n            \", cat2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n            \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n            \"}\"\n    );\n\n\n  }\n\n","sourceOld":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\", \"qw_s\", \"qw_s\");\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1,  qw_s, \"Q\") ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3             ) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5            ) ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11, qw_s, \"W\") );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7             ) );\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17,  qw_s, \"W\") ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19           ) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11            ) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{type:terms, field:all_s,  facet:{  cat3:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            // test all values missing in sub-facet\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n            // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n            \", cd :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n            \", cd2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n            \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n            \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n            \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing \"allBuckets\"\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n            \", cat2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n            \", cat3:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n            \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n            \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n            \"}\"\n    );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b1b26212116cd764dfc34c7f93ecaa718ec27ef3","date":1493832602,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","sourceNew":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\", \"qw_s\", \"qw_s\", \"er_s\",\"er_s\");\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1,  qw_s, \"Q\", er_s,\"E\") ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3                       ) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5            , er_s,\"E\") ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11, qw_s, \"W\"          ) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7             , er_s,\"R\") );       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17,  qw_s, \"W\", er_s,\"E\") ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19                     ) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11                      ) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{type:terms, field:all_s,  facet:{  cat3:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            // test all values missing in sub-facet\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n            // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n            \", cd :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n            \", cd2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n            \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n            \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n            \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing \"allBuckets\"\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n            \", cat2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n            \", cat3:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n            \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n            \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing numBuckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n            \", cat2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n            \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n            \"}\"\n    );\n\n    final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n    // simplistic join domain testing: no refinement == low count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\"+\n                         \"  cat0:{type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:false,\"+\n                         // self join on all_s ensures every doc on every shard included in facets\n                         \"        domain: { join: { from:all_s, to:all_s } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3, \" +\n                  // w/o overrequest and refinement, count for 'A' is lower than it should be\n                  // (we don't see the A from the middle shard)\n                  \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n    // simplistic join domain testing: refinement == correct count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\" +\n                         \"  cat0:{type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:true,\"+\n                         // self join on all_s ensures every doc on every shard included in facets\n                         \"        domain: { join: { from:all_s, to:all_s } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3,\" +\n                  // w/o overrequest, we need refining to get the correct count for 'A'.\n                  \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n    // contrived join domain + refinement (at second level) + testing\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\" +\n                         // top level facet has a single term\n                         \"  all:{type:terms, field:all_s, \"+sort_limit_over+\" refine:true, \" +\n                         \"       facet:{  \"+\n                         // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n                         \"         cat0:{type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:true,\"+\n                         \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3,\" +\n                  // all 3 docs matching base query have same 'all' value in top facet\n                  \"          all:{ buckets:[ { val:all, count:3, \" +\n                  // sub facet has refinement, so count for 'A' should be correct\n                  \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n  }\n\n","sourceOld":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\", \"qw_s\", \"qw_s\", \"er_s\",\"er_s\");\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1,  qw_s, \"Q\", er_s,\"E\") ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3                       ) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5            , er_s,\"E\") ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11, qw_s, \"W\"          ) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7             , er_s,\"R\") );       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17,  qw_s, \"W\", er_s,\"E\") ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19                     ) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11                      ) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{type:terms, field:all_s,  facet:{  cat3:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            // test all values missing in sub-facet\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n            // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n            \", cd :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n            \", cd2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n            \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n            \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n            \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing \"allBuckets\"\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n            \", cat2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n            \", cat3:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n            \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n            \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing numBuckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n            \", cat2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n            \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n            \"}\"\n    );\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a8c2926456ed45f9af75820d2e85859aed94afe6","date":1496417770,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","sourceNew":"  @Test\n  public void testBasicRefinement() throws Exception {\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\", \"qw_s\", \"qw_s\", \"er_s\",\"er_s\");\n    doBasicRefinement( p );\n\n    p.set(\"terms\",\"method:dv,\");\n    doBasicRefinement( p );\n\n    // multi-valued strings\n    p = params(\"cat_s\", \"cat_ss\", \"xy_s\", \"xy_ss\", \"num_d\", \"num_d\", \"qw_s\", \"qw_ss\", \"er_s\",\"er_ss\");\n    doBasicRefinement( p );\n\n    // single valued docvalues\n    p = params(\"cat_s\", \"cat_sd\", \"xy_s\", \"xy_sd\", \"num_d\", \"num_dd\", \"qw_s\", \"qw_sd\", \"er_s\",\"er_sd\");\n    doBasicRefinement( p );\n  }\n\n","sourceOld":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\", \"qw_s\", \"qw_s\", \"er_s\",\"er_s\");\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1,  qw_s, \"Q\", er_s,\"E\") ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3                       ) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5            , er_s,\"E\") ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11, qw_s, \"W\"          ) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7             , er_s,\"R\") );       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17,  qw_s, \"W\", er_s,\"E\") ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19                     ) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11                      ) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{type:terms, field:all_s,  facet:{  cat3:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            // test all values missing in sub-facet\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n            // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n            \", cd :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n            \", cd2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n            \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n            \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n            \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing \"allBuckets\"\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n            \", cat2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n            \", cat3:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n            \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n            \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing numBuckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n            \", cat2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n            \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n            \"}\"\n    );\n\n    final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n    // simplistic join domain testing: no refinement == low count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\"+\n                         \"  cat0:{type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:false,\"+\n                         // self join on all_s ensures every doc on every shard included in facets\n                         \"        domain: { join: { from:all_s, to:all_s } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3, \" +\n                  // w/o overrequest and refinement, count for 'A' is lower than it should be\n                  // (we don't see the A from the middle shard)\n                  \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n    // simplistic join domain testing: refinement == correct count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\" +\n                         \"  cat0:{type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:true,\"+\n                         // self join on all_s ensures every doc on every shard included in facets\n                         \"        domain: { join: { from:all_s, to:all_s } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3,\" +\n                  // w/o overrequest, we need refining to get the correct count for 'A'.\n                  \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n    // contrived join domain + refinement (at second level) + testing\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\" +\n                         // top level facet has a single term\n                         \"  all:{type:terms, field:all_s, \"+sort_limit_over+\" refine:true, \" +\n                         \"       facet:{  \"+\n                         // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n                         \"         cat0:{type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:true,\"+\n                         \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3,\" +\n                  // all 3 docs matching base query have same 'all' value in top facet\n                  \"          all:{ buckets:[ { val:all, count:3, \" +\n                  // sub facet has refinement, so count for 'A' should be correct\n                  \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5831ab7ea325668b9202bd682fac80e97cd4330c","date":1496621613,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","sourceNew":"  @Test\n  public void testBasicRefinement() throws Exception {\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\", \"qw_s\", \"qw_s\", \"er_s\",\"er_s\");\n    doBasicRefinement( p );\n\n    p.set(\"terms\",\"method:dvhash,\");\n    doBasicRefinement( p );\n\n    // multi-valued strings\n    p = params(\"cat_s\", \"cat_ss\", \"xy_s\", \"xy_ss\", \"num_d\", \"num_d\", \"qw_s\", \"qw_ss\", \"er_s\",\"er_ss\");\n    doBasicRefinement( p );\n\n    // single valued docvalues\n    p = params(\"cat_s\", \"cat_sd\", \"xy_s\", \"xy_sd\", \"num_d\", \"num_dd\", \"qw_s\", \"qw_sd\", \"er_s\",\"er_sd\");\n    doBasicRefinement( p );\n  }\n\n","sourceOld":"  @Test\n  public void testBasicRefinement() throws Exception {\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\", \"qw_s\", \"qw_s\", \"er_s\",\"er_s\");\n    doBasicRefinement( p );\n\n    p.set(\"terms\",\"method:dv,\");\n    doBasicRefinement( p );\n\n    // multi-valued strings\n    p = params(\"cat_s\", \"cat_ss\", \"xy_s\", \"xy_ss\", \"num_d\", \"num_d\", \"qw_s\", \"qw_ss\", \"er_s\",\"er_ss\");\n    doBasicRefinement( p );\n\n    // single valued docvalues\n    p = params(\"cat_s\", \"cat_sd\", \"xy_s\", \"xy_sd\", \"num_d\", \"num_dd\", \"qw_s\", \"qw_sd\", \"er_s\",\"er_sd\");\n    doBasicRefinement( p );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","sourceNew":"  @Test\n  public void testBasicRefinement() throws Exception {\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\", \"qw_s\", \"qw_s\", \"er_s\",\"er_s\");\n    doBasicRefinement( p );\n\n    p.set(\"terms\",\"method:dvhash,\");\n    doBasicRefinement( p );\n\n    // multi-valued strings\n    p = params(\"cat_s\", \"cat_ss\", \"xy_s\", \"xy_ss\", \"num_d\", \"num_d\", \"qw_s\", \"qw_ss\", \"er_s\",\"er_ss\");\n    doBasicRefinement( p );\n\n    // single valued docvalues\n    p = params(\"cat_s\", \"cat_sd\", \"xy_s\", \"xy_sd\", \"num_d\", \"num_dd\", \"qw_s\", \"qw_sd\", \"er_s\",\"er_sd\");\n    doBasicRefinement( p );\n  }\n\n","sourceOld":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\", \"qw_s\", \"qw_s\");\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1,  qw_s, \"Q\") ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3             ) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5            ) ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11, qw_s, \"W\") );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7             ) );\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17,  qw_s, \"W\") ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19           ) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11            ) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{type:terms, field:all_s,  facet:{  cat3:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            // test all values missing in sub-facet\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n            // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n            \", cd :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n            \", cd2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n            \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n            \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n            \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing \"allBuckets\"\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n            \", cat2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n            \", cat3:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n            \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n            \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n            \"}\"\n    );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"39fdbc59d893f5a211736e861fe145798a40b9ff","date":1498161919,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","sourceNew":"  @Test\n  public void testBasicRefinement() throws Exception {\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"cat_i\", \"cat_i\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\", \"qw_s\", \"qw_s\", \"er_s\", \"er_s\");\n    doBasicRefinement(p);\n\n    p.set(\"terms\", \"method:dvhash,\");\n    doBasicRefinement(p);\n\n    // multi-valued\n    p = params(\"cat_s\", \"cat_ss\", \"cat_i\", \"cat_is\", \"xy_s\", \"xy_ss\", \"num_d\", \"num_d\", \"qw_s\", \"qw_ss\", \"er_s\", \"er_ss\");\n    doBasicRefinement(p);\n\n    // single valued docvalues\n    p = params(\"cat_s\", \"cat_sd\", \"cat_i\", \"cat_id\", \"xy_s\", \"xy_sd\", \"num_d\", \"num_dd\", \"qw_s\", \"qw_sd\", \"er_s\", \"er_sd\");\n    doBasicRefinement(p);\n  }\n\n","sourceOld":"  @Test\n  public void testBasicRefinement() throws Exception {\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"cat_i\", \"cat_i\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\", \"qw_s\", \"qw_s\", \"er_s\",\"er_s\");\n    doBasicRefinement( p );\n\n    p.set(\"terms\",\"method:dvhash,\");\n    doBasicRefinement( p );\n\n    // multi-valued\n    p = params(\"cat_s\", \"cat_ss\", \"cat_i\", \"cat_is\", \"xy_s\", \"xy_ss\", \"num_d\", \"num_d\", \"qw_s\", \"qw_ss\", \"er_s\",\"er_ss\");\n    doBasicRefinement( p );\n\n    // single valued docvalues\n    p = params(\"cat_s\", \"cat_sd\", \"cat_i\", \"cat_id\", \"xy_s\", \"xy_sd\", \"num_d\", \"num_dd\", \"qw_s\", \"qw_sd\", \"er_s\",\"er_sd\");\n    doBasicRefinement( p );\n  }\n\n","bugFix":null,"bugIntro":["15b321aed72eecb043f237c490b9afd4e52c25be"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a6b4e21f270c812affb9d34da7e81113045b05e0","date":1497389490,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","sourceNew":"  @Test\n  public void testBasicRefinement() throws Exception {\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"cat_i\", \"cat_i\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\", \"qw_s\", \"qw_s\", \"er_s\",\"er_s\");\n    doBasicRefinement( p );\n\n    p.set(\"terms\",\"method:dvhash,\");\n    doBasicRefinement( p );\n\n    // multi-valued\n    p = params(\"cat_s\", \"cat_ss\", \"cat_i\", \"cat_is\", \"xy_s\", \"xy_ss\", \"num_d\", \"num_d\", \"qw_s\", \"qw_ss\", \"er_s\",\"er_ss\");\n    doBasicRefinement( p );\n\n    // single valued docvalues\n    p = params(\"cat_s\", \"cat_sd\", \"cat_i\", \"cat_id\", \"xy_s\", \"xy_sd\", \"num_d\", \"num_dd\", \"qw_s\", \"qw_sd\", \"er_s\",\"er_sd\");\n    doBasicRefinement( p );\n  }\n\n","sourceOld":"  @Test\n  public void testBasicRefinement() throws Exception {\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\", \"qw_s\", \"qw_s\", \"er_s\",\"er_s\");\n    doBasicRefinement( p );\n\n    p.set(\"terms\",\"method:dvhash,\");\n    doBasicRefinement( p );\n\n    // multi-valued strings\n    p = params(\"cat_s\", \"cat_ss\", \"xy_s\", \"xy_ss\", \"num_d\", \"num_d\", \"qw_s\", \"qw_ss\", \"er_s\",\"er_ss\");\n    doBasicRefinement( p );\n\n    // single valued docvalues\n    p = params(\"cat_s\", \"cat_sd\", \"xy_s\", \"xy_sd\", \"num_d\", \"num_dd\", \"qw_s\", \"qw_sd\", \"er_s\",\"er_sd\");\n    doBasicRefinement( p );\n  }\n\n","bugFix":null,"bugIntro":["15b321aed72eecb043f237c490b9afd4e52c25be"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","sourceNew":"  @Test\n  public void testBasicRefinement() throws Exception {\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"cat_i\", \"cat_i\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\", \"qw_s\", \"qw_s\", \"er_s\",\"er_s\");\n    doBasicRefinement( p );\n\n    p.set(\"terms\",\"method:dvhash,\");\n    doBasicRefinement( p );\n\n    // multi-valued\n    p = params(\"cat_s\", \"cat_ss\", \"cat_i\", \"cat_is\", \"xy_s\", \"xy_ss\", \"num_d\", \"num_d\", \"qw_s\", \"qw_ss\", \"er_s\",\"er_ss\");\n    doBasicRefinement( p );\n\n    // single valued docvalues\n    p = params(\"cat_s\", \"cat_sd\", \"cat_i\", \"cat_id\", \"xy_s\", \"xy_sd\", \"num_d\", \"num_dd\", \"qw_s\", \"qw_sd\", \"er_s\",\"er_sd\");\n    doBasicRefinement( p );\n  }\n\n","sourceOld":"  @Test\n  public void testBasicRefinement() throws Exception {\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\", \"qw_s\", \"qw_s\", \"er_s\",\"er_s\");\n    doBasicRefinement( p );\n\n    p.set(\"terms\",\"method:dvhash,\");\n    doBasicRefinement( p );\n\n    // multi-valued strings\n    p = params(\"cat_s\", \"cat_ss\", \"xy_s\", \"xy_ss\", \"num_d\", \"num_d\", \"qw_s\", \"qw_ss\", \"er_s\",\"er_ss\");\n    doBasicRefinement( p );\n\n    // single valued docvalues\n    p = params(\"cat_s\", \"cat_sd\", \"xy_s\", \"xy_sd\", \"num_d\", \"num_dd\", \"qw_s\", \"qw_sd\", \"er_s\",\"er_sd\");\n    doBasicRefinement( p );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","sourceNew":"  @Test\n  public void testBasicRefinement() throws Exception {\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"cat_i\", \"cat_i\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\", \"qw_s\", \"qw_s\", \"er_s\", \"er_s\");\n    doBasicRefinement(p);\n\n    p.set(\"terms\", \"method:dvhash,\");\n    doBasicRefinement(p);\n\n    // multi-valued\n    p = params(\"cat_s\", \"cat_ss\", \"cat_i\", \"cat_is\", \"xy_s\", \"xy_ss\", \"num_d\", \"num_d\", \"qw_s\", \"qw_ss\", \"er_s\", \"er_ss\");\n    doBasicRefinement(p);\n\n    // single valued docvalues\n    p = params(\"cat_s\", \"cat_sd\", \"cat_i\", \"cat_id\", \"xy_s\", \"xy_sd\", \"num_d\", \"num_dd\", \"qw_s\", \"qw_sd\", \"er_s\", \"er_sd\");\n    doBasicRefinement(p);\n  }\n\n","sourceOld":"  @Test\n  public void testBasicRefinement() throws Exception {\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"cat_i\", \"cat_i\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\", \"qw_s\", \"qw_s\", \"er_s\",\"er_s\");\n    doBasicRefinement( p );\n\n    p.set(\"terms\",\"method:dvhash,\");\n    doBasicRefinement( p );\n\n    // multi-valued\n    p = params(\"cat_s\", \"cat_ss\", \"cat_i\", \"cat_is\", \"xy_s\", \"xy_ss\", \"num_d\", \"num_d\", \"qw_s\", \"qw_ss\", \"er_s\",\"er_ss\");\n    doBasicRefinement( p );\n\n    // single valued docvalues\n    p = params(\"cat_s\", \"cat_sd\", \"cat_i\", \"cat_id\", \"xy_s\", \"xy_sd\", \"num_d\", \"num_dd\", \"qw_s\", \"qw_sd\", \"er_s\",\"er_sd\");\n    doBasicRefinement( p );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","sourceNew":"  @Test\n  public void testBasicRefinement() throws Exception {\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"cat_i\", \"cat_i\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\", \"qw_s\", \"qw_s\", \"er_s\", \"er_s\");\n    doBasicRefinement(p);\n\n    p.set(\"terms\", \"method:dvhash,\");\n    doBasicRefinement(p);\n\n    // multi-valued\n    p = params(\"cat_s\", \"cat_ss\", \"cat_i\", \"cat_is\", \"xy_s\", \"xy_ss\", \"num_d\", \"num_d\", \"qw_s\", \"qw_ss\", \"er_s\", \"er_ss\");\n    doBasicRefinement(p);\n\n    // single valued docvalues\n    p = params(\"cat_s\", \"cat_sd\", \"cat_i\", \"cat_id\", \"xy_s\", \"xy_sd\", \"num_d\", \"num_dd\", \"qw_s\", \"qw_sd\", \"er_s\", \"er_sd\");\n    doBasicRefinement(p);\n  }\n\n","sourceOld":"  @Test\n  public void testBasicRefinement() throws Exception {\n    initServers();\n    Client client = servers.getClient(random().nextInt());\n    client.queryDefaults().set( \"shards\", servers.getShards(), \"debugQuery\", Boolean.toString(random().nextBoolean()) );\n\n    List<SolrClient> clients = client.getClientProvider().all();\n    assertTrue(clients.size() >= 3);\n\n    client.deleteByQuery(\"*:*\", null);\n\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\", \"qw_s\", \"qw_s\", \"er_s\",\"er_s\");\n    String cat_s = p.get(\"cat_s\");\n    String xy_s = p.get(\"xy_s\");\n    String qw_s = p.get(\"qw_s\");\n    String er_s = p.get(\"er_s\");  // this field is designed to test numBuckets refinement... the first phase will only have a single bucket returned for the top count bucket of cat_s\n    String num_d = p.get(\"num_d\");\n\n    clients.get(0).add( sdoc(\"id\", \"01\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\" ,num_d, -1,  qw_s, \"Q\", er_s,\"E\") ); // A wins count tie\n    clients.get(0).add( sdoc(\"id\", \"02\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, 3                       ) );\n\n    clients.get(1).add( sdoc(\"id\", \"11\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, -5            , er_s,\"E\") ); // B highest count\n    clients.get(1).add( sdoc(\"id\", \"12\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"Y\", num_d, -11, qw_s, \"W\"          ) );\n    clients.get(1).add( sdoc(\"id\", \"13\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 7             , er_s,\"R\") );       // \"R\" will only be picked up via refinement when parent facet is cat_s\n\n    clients.get(2).add( sdoc(\"id\", \"21\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"X\", num_d, 17,  qw_s, \"W\", er_s,\"E\") ); // A highest count\n    clients.get(2).add( sdoc(\"id\", \"22\", \"all_s\",\"all\", cat_s, \"A\", xy_s, \"Y\", num_d, -19                     ) );\n    clients.get(2).add( sdoc(\"id\", \"23\", \"all_s\",\"all\", cat_s, \"B\", xy_s, \"X\", num_d, 11                      ) );\n\n    client.commit();\n\n    // Shard responses should be A=1, B=2, A=2, merged should be \"A=3, B=2\"\n    // One shard will have _facet_={\"refine\":{\"cat0\":{\"_l\":[\"A\"]}}} on the second phase\n\n    /****\n    // fake a refinement request... good for development/debugging\n    assertJQ(clients.get(1),\n        params(p, \"q\", \"*:*\",     \"_facet_\",\"{refine:{cat0:{_l:[A]}}}\", \"isShard\",\"true\", \"distrib\",\"false\", \"shards.purpose\",\"2097216\", \"ids\",\"11,12,13\",\n            \"json.facet\", \"{\" +\n                \"cat0:{type:terms, field:cat_s, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n                \"}\"\n        )\n        , \"facets=={foo:555}\"\n    );\n    ****/\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:false}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3} ] }\" +  // w/o overrequest and refinement, count is lower than it should be (we don't see the A from the middle shard)\n            \"}\"\n    );\n\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4} ] }\" +  // w/o overrequest, we need refining to get the correct count.\n            \"}\"\n    );\n\n    // test that basic stats work for refinement\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"cat0:{type:terms, field:${cat_s}, sort:'count desc', limit:1, overrequest:0, refine:true, facet:{ stat1:'sum(${num_d})'}   }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:4, stat1:4.0} ] }\" +\n            \"}\"\n    );\n\n    // test sorting buckets by a different stat\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" cat0:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:false, facet:{ min1:'min(${num_d})'}   }\" +\n            \",cat1:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }\" +\n            \",qfacet:{type:query, q:'*:*', facet:{  cat2:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through a query facet\n            \",allf:{type:terms, field:all_s,  facet:{  cat3:{type:terms, field:${cat_s}, sort:'min1 asc', limit:1, overrequest:0, refine:true,  facet:{ min1:'min(${num_d})'}   }  }}\" +  // refinement needed through field facet\n            \",sum1:'sum(num_d)'\" +  // make sure that root bucket stats aren't affected by refinement\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat0:{ buckets:[ {val:A,count:3, min1:-19.0} ] }\" +  // B wins in shard2, so we're missing the \"A\" count for that shard w/o refinement.\n            \", cat1:{ buckets:[ {val:A,count:4, min1:-19.0} ] }\" +  // with refinement, we get the right count\n            \", qfacet:{ count:8,  cat2:{ buckets:[ {val:A,count:4, min1:-19.0} ] }    }\" +  // just like the previous response, just nested under a query facet\n            \", allf:{ buckets:[  {cat3:{ buckets:[ {val:A,count:4, min1:-19.0} ] }  ,count:8,val:all   }]  }\" +  // just like the previous response, just nested under a field facet\n            \", sum1:2.0\" +\n            \"}\"\n    );\n\n    // test partial buckets (field facet within field facet)\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"ab:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}  }]  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test that sibling facets and stats are included for _p buckets, but skipped for _s buckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true,  facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \",allf :{type:terms, field:all_s, limit:1, overrequest:0, refine:true,  facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" +\n            \",allf2:{type:terms, field:all_s, limit:1, overrequest:0, refine:false, facet:{cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true}, qq:{query:'*:*'},ww:'sum(${num_d})'  }}\" + // top level refine=false shouldn't matter\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \", ab2:{ buckets:[  {val:A, count:4, xy:{buckets:[ {val:X,count:3}]}    ,qq:{count:4}, ww:4.0 }]  }\" +  // make sure qq and ww are included for _p buckets\n            \", allf2:{ buckets:[ {count:8, val:all, cat:{buckets:[{val:A,count:4}]} ,qq:{count:8}, ww:2.0 }]  }\" +  // make sure qq and ww are excluded (not calculated again in another phase) for _s buckets\n            \"}\"\n    );\n\n    // test refining under the special \"missing\" bucket of a field facet\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"f:{type:terms, field:missing_s, limit:1, overrequest:0, missing:true, refine:true,  facet:{  cat:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true   }  }}\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", f:{ buckets:[], missing:{count:8, cat:{buckets:[{val:A,count:4}]}  }  }\" +  // just like the previous response, just nested under a field facet\n            \"}\"\n    );\n\n    // test filling in \"missing\" bucket for partially refined facets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            // test all values missing in sub-facet\n            \" ab :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  zz:{type:terms, field:missing_s, limit:1, overrequest:0, refine:false, missing:true}  }}\" +\n            \",ab2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  zz:{type:terms, field:missing_s, limit:1, overrequest:0, refine:true , missing:true}  }}\" +\n            // test some values missing in sub-facet (and test that this works with normal partial bucket refinement)\n            \", cd :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false,  facet:{  qw:{type:terms, field:${qw_s}, limit:1, overrequest:0, refine:false, missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n            \", cd2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true ,  facet:{  qw:{type:terms, field:${qw_s}, limit:1, overrequest:0, refine:true , missing:true,   facet:{qq:{query:'*:*'}}   }  }}\" +\n\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", ab:{ buckets:[  {val:A, count:3, zz:{buckets:[], missing:{count:3}}}]  }\" +\n            \",ab2:{ buckets:[  {val:A, count:4, zz:{buckets:[], missing:{count:4}}}]  }\" +\n            \", cd:{ buckets:[  {val:A, count:3,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:1,qq:{count:1}}}}]  }\" +\n            \",cd2:{ buckets:[  {val:A, count:4,  qw:{buckets:[{val:Q, count:1, qq:{count:1}}], missing:{count:2,qq:{count:2}}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing \"allBuckets\"\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, allBuckets:true, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:false}  }  }\" +\n            \", cat2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true }  }  }\" +\n            \", cat3:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , allBuckets:true, facet:{  xy:{type:terms, field:${xy_s}, limit:1, overrequest:0, allBuckets:true, refine:true , facet:{f:'sum(${num_d})'}   }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ allBuckets:{count:8}, buckets:[  {val:A, count:3, xy:{buckets:[{count:2, val:X}], allBuckets:{count:3}}}]  }\" +\n            \",cat2:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X}], allBuckets:{count:4}}}]  }\" +\n            \",cat3:{ allBuckets:{count:8}, buckets:[  {val:A, count:4, xy:{buckets:[{count:3, val:X, f:23.0}], allBuckets:{count:4, f:4.0}}}]  }\" +\n            \"}\"\n    );\n\n    // test filling in missing numBuckets\n    client.testJQ(params(p, \"q\", \"*:*\",\n        \"json.facet\", \"{\" +\n            \"  cat :{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:false, numBuckets:true, facet:{  er:{type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:false}  }  }\" +\n            \", cat2:{type:terms, field:${cat_s}, limit:1, overrequest:0, refine:true , numBuckets:true, facet:{  er:{type:terms, field:${er_s}, limit:1, overrequest:0, numBuckets:true, refine:true }  }  }\" +\n            \"}\"\n        )\n        , \"facets=={ count:8\" +\n            \", cat:{ numBuckets:2, buckets:[  {val:A, count:3, er:{numBuckets:1,buckets:[{count:2, val:E}]  }}]  }\" +  // the \"R\" bucket will not be seen w/o refinement\n            \",cat2:{ numBuckets:2, buckets:[  {val:A, count:4, er:{numBuckets:2,buckets:[{count:2, val:E}]  }}]  }\" +\n            \"}\"\n    );\n\n    final String sort_limit_over = \"sort:'count desc', limit:1, overrequest:0, \";\n    // simplistic join domain testing: no refinement == low count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\"+\n                         \"  cat0:{type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:false,\"+\n                         // self join on all_s ensures every doc on every shard included in facets\n                         \"        domain: { join: { from:all_s, to:all_s } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3, \" +\n                  // w/o overrequest and refinement, count for 'A' is lower than it should be\n                  // (we don't see the A from the middle shard)\n                  \"          cat0:{ buckets:[ {val:A,count:3} ] } }\");\n    // simplistic join domain testing: refinement == correct count\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\" +\n                         \"  cat0:{type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:true,\"+\n                         // self join on all_s ensures every doc on every shard included in facets\n                         \"        domain: { join: { from:all_s, to:all_s } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3,\" +\n                  // w/o overrequest, we need refining to get the correct count for 'A'.\n                  \"          cat0:{ buckets:[ {val:A,count:4} ] } }\");\n\n    // contrived join domain + refinement (at second level) + testing\n    client.testJQ(params(p, \"q\", \"${xy_s}:Y\", // query only matches one doc per shard\n                         \"json.facet\", \"{\" +\n                         // top level facet has a single term\n                         \"  all:{type:terms, field:all_s, \"+sort_limit_over+\" refine:true, \" +\n                         \"       facet:{  \"+\n                         // subfacet will facet on cat after joining on all (so all docs should be included in subfacet)\n                         \"         cat0:{type:terms, field:${cat_s}, \"+sort_limit_over+\" refine:true,\"+\n                         \"               domain: { join: { from:all_s, to:all_s } } } } }\" +\n                         \"}\"\n                         )\n                  ,\n                  \"/response/numFound==3\",\n                  \"facets=={ count:3,\" +\n                  // all 3 docs matching base query have same 'all' value in top facet\n                  \"          all:{ buckets:[ { val:all, count:3, \" +\n                  // sub facet has refinement, so count for 'A' should be correct\n                  \"                            cat0:{ buckets: [{val:A,count:4}] } } ] } }\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15b321aed72eecb043f237c490b9afd4e52c25be","date":1525894978,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/TestJsonFacetRefinement#testBasicRefinement().mjava","sourceNew":"  @Test\n  public void testBasicRefinement() throws Exception {\n    ModifiableSolrParams p;\n    p = params(\"cat_s\", \"cat_s\", \"cat_i\", \"cat_i\", \"date\",\"cat_dt\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\", \"qw_s\", \"qw_s\", \"er_s\", \"er_s\");\n    doBasicRefinement(p);\n\n    // multi-valued (except num_d)\n    p = params(\"cat_s\", \"cat_ss\", \"cat_i\", \"cat_is\", \"date\",\"cat_dts\", \"xy_s\", \"xy_ss\", \"num_d\", \"num_d\", \"qw_s\", \"qw_ss\", \"er_s\", \"er_ss\");\n    doBasicRefinement(p);\n\n    // single valued docvalues\n    p = params(\"cat_s\", \"cat_sd\", \"cat_i\", \"cat_id\", \"date\",\"cat_dtd\", \"xy_s\", \"xy_sd\", \"num_d\", \"num_dd\", \"qw_s\", \"qw_sd\", \"er_s\", \"er_sd\");\n    doBasicRefinement(p);\n\n    // multi valued docvalues (except num_d)\n    p = params(\"cat_s\", \"cat_sds\", \"cat_i\", \"cat_ids\", \"date\",\"cat_dtds\", \"xy_s\", \"xy_sds\", \"num_d\", \"num_dd\", \"qw_s\", \"qw_sds\", \"er_s\", \"er_sds\");\n    doBasicRefinement(p);\n  }\n\n","sourceOld":"  @Test\n  public void testBasicRefinement() throws Exception {\n    ModifiableSolrParams p = params(\"cat_s\", \"cat_s\", \"cat_i\", \"cat_i\", \"xy_s\", \"xy_s\", \"num_d\", \"num_d\", \"qw_s\", \"qw_s\", \"er_s\", \"er_s\");\n    doBasicRefinement(p);\n\n    p.set(\"terms\", \"method:dvhash,\");\n    doBasicRefinement(p);\n\n    // multi-valued\n    p = params(\"cat_s\", \"cat_ss\", \"cat_i\", \"cat_is\", \"xy_s\", \"xy_ss\", \"num_d\", \"num_d\", \"qw_s\", \"qw_ss\", \"er_s\", \"er_ss\");\n    doBasicRefinement(p);\n\n    // single valued docvalues\n    p = params(\"cat_s\", \"cat_sd\", \"cat_i\", \"cat_id\", \"xy_s\", \"xy_sd\", \"num_d\", \"num_dd\", \"qw_s\", \"qw_sd\", \"er_s\", \"er_sd\");\n    doBasicRefinement(p);\n  }\n\n","bugFix":["39fdbc59d893f5a211736e861fe145798a40b9ff","a6b4e21f270c812affb9d34da7e81113045b05e0","8ec805ca8fedc0166461148c7182f1bcbbd18ee1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b1b26212116cd764dfc34c7f93ecaa718ec27ef3":["84e83c6774414730d58276083becadc66f4e4aca"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["49d73292e024d8ee1883fc327099adde4bcffd7a"],"14abccfea62dff435ac0457e128ca6bc703087d6":["c2dbdcf79d0d3310dcd4ddf2f628d415ec2e4be5"],"39fdbc59d893f5a211736e861fe145798a40b9ff":["a6b4e21f270c812affb9d34da7e81113045b05e0"],"84e83c6774414730d58276083becadc66f4e4aca":["10c711bb8c3aac052fb8e0e9d417517c94166d5d"],"09b2046a929f8ee073bf5b75cbbf2b60e413a6bd":["85d473096f870b9bf3e231200a07e8eefa30eef8"],"8ec805ca8fedc0166461148c7182f1bcbbd18ee1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"85d473096f870b9bf3e231200a07e8eefa30eef8":["4cb287e8b4595ddf413c318d5631789c8c8e8719"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","5831ab7ea325668b9202bd682fac80e97cd4330c"],"11ab475c994c79138885cc8a30b2641d929cdc43":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"52dc05802ffecefaecf5879a40a61539b5c985f0":["8908009aaa8e9318b455c1c22b83e0e87738228a"],"5831ab7ea325668b9202bd682fac80e97cd4330c":["a8c2926456ed45f9af75820d2e85859aed94afe6"],"58b93c361b4f6fe193e84bfd27ea523366eada52":["8ec805ca8fedc0166461148c7182f1bcbbd18ee1"],"a8c2926456ed45f9af75820d2e85859aed94afe6":["b1b26212116cd764dfc34c7f93ecaa718ec27ef3"],"7682bc2094c8206c9527a8d3833b5c553581b943":["09b2046a929f8ee073bf5b75cbbf2b60e413a6bd"],"a6b4e21f270c812affb9d34da7e81113045b05e0":["5831ab7ea325668b9202bd682fac80e97cd4330c"],"10c711bb8c3aac052fb8e0e9d417517c94166d5d":["7682bc2094c8206c9527a8d3833b5c553581b943"],"8908009aaa8e9318b455c1c22b83e0e87738228a":["11ab475c994c79138885cc8a30b2641d929cdc43"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","39fdbc59d893f5a211736e861fe145798a40b9ff"],"15b321aed72eecb043f237c490b9afd4e52c25be":["28288370235ed02234a64753cdbf0c6ec096304a"],"28288370235ed02234a64753cdbf0c6ec096304a":["b1b26212116cd764dfc34c7f93ecaa718ec27ef3","39fdbc59d893f5a211736e861fe145798a40b9ff"],"49d73292e024d8ee1883fc327099adde4bcffd7a":["14abccfea62dff435ac0457e128ca6bc703087d6"],"4cb287e8b4595ddf413c318d5631789c8c8e8719":["58b93c361b4f6fe193e84bfd27ea523366eada52"],"c2dbdcf79d0d3310dcd4ddf2f628d415ec2e4be5":["52dc05802ffecefaecf5879a40a61539b5c985f0"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["e9017cf144952056066919f1ebc7897ff9bd71b1","a6b4e21f270c812affb9d34da7e81113045b05e0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["15b321aed72eecb043f237c490b9afd4e52c25be"]},"commit2Childs":{"b1b26212116cd764dfc34c7f93ecaa718ec27ef3":["a8c2926456ed45f9af75820d2e85859aed94afe6","28288370235ed02234a64753cdbf0c6ec096304a"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"14abccfea62dff435ac0457e128ca6bc703087d6":["49d73292e024d8ee1883fc327099adde4bcffd7a"],"39fdbc59d893f5a211736e861fe145798a40b9ff":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"84e83c6774414730d58276083becadc66f4e4aca":["b1b26212116cd764dfc34c7f93ecaa718ec27ef3"],"09b2046a929f8ee073bf5b75cbbf2b60e413a6bd":["7682bc2094c8206c9527a8d3833b5c553581b943"],"8ec805ca8fedc0166461148c7182f1bcbbd18ee1":["58b93c361b4f6fe193e84bfd27ea523366eada52"],"85d473096f870b9bf3e231200a07e8eefa30eef8":["09b2046a929f8ee073bf5b75cbbf2b60e413a6bd"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"11ab475c994c79138885cc8a30b2641d929cdc43":["8908009aaa8e9318b455c1c22b83e0e87738228a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8ec805ca8fedc0166461148c7182f1bcbbd18ee1","11ab475c994c79138885cc8a30b2641d929cdc43"],"52dc05802ffecefaecf5879a40a61539b5c985f0":["c2dbdcf79d0d3310dcd4ddf2f628d415ec2e4be5"],"5831ab7ea325668b9202bd682fac80e97cd4330c":["e9017cf144952056066919f1ebc7897ff9bd71b1","a6b4e21f270c812affb9d34da7e81113045b05e0"],"58b93c361b4f6fe193e84bfd27ea523366eada52":["4cb287e8b4595ddf413c318d5631789c8c8e8719"],"a8c2926456ed45f9af75820d2e85859aed94afe6":["5831ab7ea325668b9202bd682fac80e97cd4330c"],"7682bc2094c8206c9527a8d3833b5c553581b943":["10c711bb8c3aac052fb8e0e9d417517c94166d5d"],"a6b4e21f270c812affb9d34da7e81113045b05e0":["39fdbc59d893f5a211736e861fe145798a40b9ff","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"10c711bb8c3aac052fb8e0e9d417517c94166d5d":["84e83c6774414730d58276083becadc66f4e4aca"],"8908009aaa8e9318b455c1c22b83e0e87738228a":["52dc05802ffecefaecf5879a40a61539b5c985f0"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"49d73292e024d8ee1883fc327099adde4bcffd7a":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb"],"15b321aed72eecb043f237c490b9afd4e52c25be":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"28288370235ed02234a64753cdbf0c6ec096304a":["15b321aed72eecb043f237c490b9afd4e52c25be"],"4cb287e8b4595ddf413c318d5631789c8c8e8719":["85d473096f870b9bf3e231200a07e8eefa30eef8"],"c2dbdcf79d0d3310dcd4ddf2f628d415ec2e4be5":["14abccfea62dff435ac0457e128ca6bc703087d6"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}