{"path":"lucene/src/java/org/apache/lucene/index/DirectoryReader#DirectoryReader(IndexWriter,SegmentInfos,int,CodecProvider).mjava","commits":[{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DirectoryReader#DirectoryReader(IndexWriter,SegmentInfos,int,CodecProvider).mjava","pathOld":"/dev/null","sourceNew":"  // Used by near real-time search\n  DirectoryReader(IndexWriter writer, SegmentInfos infos, int termInfosIndexDivisor, CodecProvider codecs) throws IOException {\n    this.directory = writer.getDirectory();\n    this.readOnly = true;\n    segmentInfos = infos;\n    this.termInfosIndexDivisor = termInfosIndexDivisor;\n    if (codecs == null) {\n      this.codecs = CodecProvider.getDefault();\n    } else {\n      this.codecs = codecs;\n    }\n\n    // IndexWriter synchronizes externally before calling\n    // us, which ensures infos will not change; so there's\n    // no need to process segments in reverse order\n    final int numSegments = infos.size();\n    SegmentReader[] readers = new SegmentReader[numSegments];\n    final Directory dir = writer.getDirectory();\n    int upto = 0;\n\n    for (int i=0;i<numSegments;i++) {\n      boolean success = false;\n      try {\n        final SegmentInfo info = infos.info(upto);\n        if (info.dir == dir) {\n          readers[upto++] = writer.readerPool.getReadOnlyClone(info, true, termInfosIndexDivisor);\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          // Close all readers we had opened:\n          for(upto--;upto>=0;upto--) {\n            try {\n              readers[upto].close();\n            } catch (Throwable ignore) {\n              // keep going - we want to clean up as much as possible\n            }\n          }\n        }\n      }\n    }\n\n    this.writer = writer;\n\n    if (upto < readers.length) {\n      // This means some segments were in a foreign Directory\n      SegmentReader[] newReaders = new SegmentReader[upto];\n      System.arraycopy(readers, 0, newReaders, 0, upto);\n      readers = newReaders;\n    }\n\n    initialize(readers);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["b102459ba40f8bc6d609b2058019db7485f7ed67"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"db610e9e698f94982d7a1af15a21d6a30ef96b9d","date":1270586294,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DirectoryReader#DirectoryReader(IndexWriter,SegmentInfos,int,CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DirectoryReader#DirectoryReader(IndexWriter,SegmentInfos,int,CodecProvider).mjava","sourceNew":"  // Used by near real-time search\n  DirectoryReader(IndexWriter writer, SegmentInfos infos, int termInfosIndexDivisor, CodecProvider codecs) throws IOException {\n    this.directory = writer.getDirectory();\n    this.readOnly = true;\n    segmentInfos = infos;\n    segmentInfosStart = (SegmentInfos) infos.clone();\n    this.termInfosIndexDivisor = termInfosIndexDivisor;\n    if (codecs == null) {\n      this.codecs = CodecProvider.getDefault();\n    } else {\n      this.codecs = codecs;\n    }\n\n    // IndexWriter synchronizes externally before calling\n    // us, which ensures infos will not change; so there's\n    // no need to process segments in reverse order\n    final int numSegments = infos.size();\n    SegmentReader[] readers = new SegmentReader[numSegments];\n    final Directory dir = writer.getDirectory();\n    int upto = 0;\n\n    for (int i=0;i<numSegments;i++) {\n      boolean success = false;\n      try {\n        final SegmentInfo info = infos.info(upto);\n        if (info.dir == dir) {\n          readers[upto++] = writer.readerPool.getReadOnlyClone(info, true, termInfosIndexDivisor);\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          // Close all readers we had opened:\n          for(upto--;upto>=0;upto--) {\n            try {\n              readers[upto].close();\n            } catch (Throwable ignore) {\n              // keep going - we want to clean up as much as possible\n            }\n          }\n        }\n      }\n    }\n\n    this.writer = writer;\n\n    if (upto < readers.length) {\n      // This means some segments were in a foreign Directory\n      SegmentReader[] newReaders = new SegmentReader[upto];\n      System.arraycopy(readers, 0, newReaders, 0, upto);\n      readers = newReaders;\n    }\n\n    initialize(readers);\n  }\n\n","sourceOld":"  // Used by near real-time search\n  DirectoryReader(IndexWriter writer, SegmentInfos infos, int termInfosIndexDivisor, CodecProvider codecs) throws IOException {\n    this.directory = writer.getDirectory();\n    this.readOnly = true;\n    segmentInfos = infos;\n    this.termInfosIndexDivisor = termInfosIndexDivisor;\n    if (codecs == null) {\n      this.codecs = CodecProvider.getDefault();\n    } else {\n      this.codecs = codecs;\n    }\n\n    // IndexWriter synchronizes externally before calling\n    // us, which ensures infos will not change; so there's\n    // no need to process segments in reverse order\n    final int numSegments = infos.size();\n    SegmentReader[] readers = new SegmentReader[numSegments];\n    final Directory dir = writer.getDirectory();\n    int upto = 0;\n\n    for (int i=0;i<numSegments;i++) {\n      boolean success = false;\n      try {\n        final SegmentInfo info = infos.info(upto);\n        if (info.dir == dir) {\n          readers[upto++] = writer.readerPool.getReadOnlyClone(info, true, termInfosIndexDivisor);\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          // Close all readers we had opened:\n          for(upto--;upto>=0;upto--) {\n            try {\n              readers[upto].close();\n            } catch (Throwable ignore) {\n              // keep going - we want to clean up as much as possible\n            }\n          }\n        }\n      }\n    }\n\n    this.writer = writer;\n\n    if (upto < readers.length) {\n      // This means some segments were in a foreign Directory\n      SegmentReader[] newReaders = new SegmentReader[upto];\n      System.arraycopy(readers, 0, newReaders, 0, upto);\n      readers = newReaders;\n    }\n\n    initialize(readers);\n  }\n\n","bugFix":null,"bugIntro":["b102459ba40f8bc6d609b2058019db7485f7ed67"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6ba032266b3d8d7a0a98dda5ee81cc0fb195b887","date":1275385142,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DirectoryReader#DirectoryReader(IndexWriter,SegmentInfos,int,CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DirectoryReader#DirectoryReader(IndexWriter,SegmentInfos,int,CodecProvider).mjava","sourceNew":"  // Used by near real-time search\n  DirectoryReader(IndexWriter writer, SegmentInfos infos, int termInfosIndexDivisor, CodecProvider codecs) throws IOException {\n    this.directory = writer.getDirectory();\n    this.readOnly = true;\n    segmentInfos = infos;\n    segmentInfosStart = (SegmentInfos) infos.clone();\n    this.termInfosIndexDivisor = termInfosIndexDivisor;\n    if (codecs == null) {\n      this.codecs = CodecProvider.getDefault();\n    } else {\n      this.codecs = codecs;\n    }\n\n    // IndexWriter synchronizes externally before calling\n    // us, which ensures infos will not change; so there's\n    // no need to process segments in reverse order\n    final int numSegments = infos.size();\n    SegmentReader[] readers = new SegmentReader[numSegments];\n    final Directory dir = writer.getDirectory();\n\n    for (int i=0;i<numSegments;i++) {\n      boolean success = false;\n      try {\n        final SegmentInfo info = infos.info(i);\n        assert info.dir == dir;\n        readers[i] = writer.readerPool.getReadOnlyClone(info, true, termInfosIndexDivisor);\n        success = true;\n      } finally {\n        if (!success) {\n          // Close all readers we had opened:\n          for(i--;i>=0;i--) {\n            try {\n              readers[i].close();\n            } catch (Throwable ignore) {\n              // keep going - we want to clean up as much as possible\n            }\n          }\n        }\n      }\n    }\n\n    this.writer = writer;\n\n    initialize(readers);\n  }\n\n","sourceOld":"  // Used by near real-time search\n  DirectoryReader(IndexWriter writer, SegmentInfos infos, int termInfosIndexDivisor, CodecProvider codecs) throws IOException {\n    this.directory = writer.getDirectory();\n    this.readOnly = true;\n    segmentInfos = infos;\n    segmentInfosStart = (SegmentInfos) infos.clone();\n    this.termInfosIndexDivisor = termInfosIndexDivisor;\n    if (codecs == null) {\n      this.codecs = CodecProvider.getDefault();\n    } else {\n      this.codecs = codecs;\n    }\n\n    // IndexWriter synchronizes externally before calling\n    // us, which ensures infos will not change; so there's\n    // no need to process segments in reverse order\n    final int numSegments = infos.size();\n    SegmentReader[] readers = new SegmentReader[numSegments];\n    final Directory dir = writer.getDirectory();\n    int upto = 0;\n\n    for (int i=0;i<numSegments;i++) {\n      boolean success = false;\n      try {\n        final SegmentInfo info = infos.info(upto);\n        if (info.dir == dir) {\n          readers[upto++] = writer.readerPool.getReadOnlyClone(info, true, termInfosIndexDivisor);\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          // Close all readers we had opened:\n          for(upto--;upto>=0;upto--) {\n            try {\n              readers[upto].close();\n            } catch (Throwable ignore) {\n              // keep going - we want to clean up as much as possible\n            }\n          }\n        }\n      }\n    }\n\n    this.writer = writer;\n\n    if (upto < readers.length) {\n      // This means some segments were in a foreign Directory\n      SegmentReader[] newReaders = new SegmentReader[upto];\n      System.arraycopy(readers, 0, newReaders, 0, upto);\n      readers = newReaders;\n    }\n\n    initialize(readers);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b102459ba40f8bc6d609b2058019db7485f7ed67","date":1291773722,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DirectoryReader#DirectoryReader(IndexWriter,SegmentInfos,int,CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DirectoryReader#DirectoryReader(IndexWriter,SegmentInfos,int,CodecProvider).mjava","sourceNew":"  // Used by near real-time search\n  DirectoryReader(IndexWriter writer, SegmentInfos infos, int termInfosIndexDivisor, CodecProvider codecs) throws IOException {\n    this.directory = writer.getDirectory();\n    this.readOnly = true;\n    segmentInfos = (SegmentInfos) infos.clone();// make sure we clone otherwise we share mutable state with IW\n    this.termInfosIndexDivisor = termInfosIndexDivisor;\n    if (codecs == null) {\n      this.codecs = CodecProvider.getDefault();\n    } else {\n      this.codecs = codecs;\n    }\n\n    // IndexWriter synchronizes externally before calling\n    // us, which ensures infos will not change; so there's\n    // no need to process segments in reverse order\n    final int numSegments = infos.size();\n    SegmentReader[] readers = new SegmentReader[numSegments];\n    final Directory dir = writer.getDirectory();\n\n    for (int i=0;i<numSegments;i++) {\n      boolean success = false;\n      try {\n        final SegmentInfo info = infos.info(i);\n        assert info.dir == dir;\n        readers[i] = writer.readerPool.getReadOnlyClone(info, true, termInfosIndexDivisor);\n        success = true;\n      } finally {\n        if (!success) {\n          // Close all readers we had opened:\n          for(i--;i>=0;i--) {\n            try {\n              readers[i].close();\n            } catch (Throwable ignore) {\n              // keep going - we want to clean up as much as possible\n            }\n          }\n        }\n      }\n    }\n\n    this.writer = writer;\n\n    initialize(readers);\n  }\n\n","sourceOld":"  // Used by near real-time search\n  DirectoryReader(IndexWriter writer, SegmentInfos infos, int termInfosIndexDivisor, CodecProvider codecs) throws IOException {\n    this.directory = writer.getDirectory();\n    this.readOnly = true;\n    segmentInfos = infos;\n    segmentInfosStart = (SegmentInfos) infos.clone();\n    this.termInfosIndexDivisor = termInfosIndexDivisor;\n    if (codecs == null) {\n      this.codecs = CodecProvider.getDefault();\n    } else {\n      this.codecs = codecs;\n    }\n\n    // IndexWriter synchronizes externally before calling\n    // us, which ensures infos will not change; so there's\n    // no need to process segments in reverse order\n    final int numSegments = infos.size();\n    SegmentReader[] readers = new SegmentReader[numSegments];\n    final Directory dir = writer.getDirectory();\n\n    for (int i=0;i<numSegments;i++) {\n      boolean success = false;\n      try {\n        final SegmentInfo info = infos.info(i);\n        assert info.dir == dir;\n        readers[i] = writer.readerPool.getReadOnlyClone(info, true, termInfosIndexDivisor);\n        success = true;\n      } finally {\n        if (!success) {\n          // Close all readers we had opened:\n          for(i--;i>=0;i--) {\n            try {\n              readers[i].close();\n            } catch (Throwable ignore) {\n              // keep going - we want to clean up as much as possible\n            }\n          }\n        }\n      }\n    }\n\n    this.writer = writer;\n\n    initialize(readers);\n  }\n\n","bugFix":["db610e9e698f94982d7a1af15a21d6a30ef96b9d","955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4bd5d0a5ac72666f0bcbd50b535d2cc70dbf584b","date":1291778725,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DirectoryReader#DirectoryReader(IndexWriter,SegmentInfos,int,CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DirectoryReader#DirectoryReader(IndexWriter,SegmentInfos,int,CodecProvider).mjava","sourceNew":"  // Used by near real-time search\n  DirectoryReader(IndexWriter writer, SegmentInfos infos, int termInfosIndexDivisor, CodecProvider codecs) throws IOException {\n    this.directory = writer.getDirectory();\n    this.readOnly = true;\n    segmentInfos = (SegmentInfos) infos.clone();// make sure we clone otherwise we share mutable state with IW\n    this.termInfosIndexDivisor = termInfosIndexDivisor;\n    if (codecs == null) {\n      this.codecs = CodecProvider.getDefault();\n    } else {\n      this.codecs = codecs;\n    }\n\n    // IndexWriter synchronizes externally before calling\n    // us, which ensures infos will not change; so there's\n    // no need to process segments in reverse order\n    final int numSegments = infos.size();\n    SegmentReader[] readers = new SegmentReader[numSegments];\n    final Directory dir = writer.getDirectory();\n\n    for (int i=0;i<numSegments;i++) {\n      boolean success = false;\n      try {\n        final SegmentInfo info = infos.info(i);\n        assert info.dir == dir;\n        readers[i] = writer.readerPool.getReadOnlyClone(info, true, termInfosIndexDivisor);\n        success = true;\n      } finally {\n        if (!success) {\n          // Close all readers we had opened:\n          for(i--;i>=0;i--) {\n            try {\n              readers[i].close();\n            } catch (Throwable ignore) {\n              // keep going - we want to clean up as much as possible\n            }\n          }\n        }\n      }\n    }\n\n    this.writer = writer;\n\n    initialize(readers);\n  }\n\n","sourceOld":"  // Used by near real-time search\n  DirectoryReader(IndexWriter writer, SegmentInfos infos, int termInfosIndexDivisor, CodecProvider codecs) throws IOException {\n    this.directory = writer.getDirectory();\n    this.readOnly = true;\n    segmentInfos = infos;\n    segmentInfosStart = (SegmentInfos) infos.clone();\n    this.termInfosIndexDivisor = termInfosIndexDivisor;\n    if (codecs == null) {\n      this.codecs = CodecProvider.getDefault();\n    } else {\n      this.codecs = codecs;\n    }\n\n    // IndexWriter synchronizes externally before calling\n    // us, which ensures infos will not change; so there's\n    // no need to process segments in reverse order\n    final int numSegments = infos.size();\n    SegmentReader[] readers = new SegmentReader[numSegments];\n    final Directory dir = writer.getDirectory();\n\n    for (int i=0;i<numSegments;i++) {\n      boolean success = false;\n      try {\n        final SegmentInfo info = infos.info(i);\n        assert info.dir == dir;\n        readers[i] = writer.readerPool.getReadOnlyClone(info, true, termInfosIndexDivisor);\n        success = true;\n      } finally {\n        if (!success) {\n          // Close all readers we had opened:\n          for(i--;i>=0;i--) {\n            try {\n              readers[i].close();\n            } catch (Throwable ignore) {\n              // keep going - we want to clean up as much as possible\n            }\n          }\n        }\n      }\n    }\n\n    this.writer = writer;\n\n    initialize(readers);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DirectoryReader#DirectoryReader(IndexWriter,SegmentInfos,int,CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DirectoryReader#DirectoryReader(IndexWriter,SegmentInfos,int,CodecProvider).mjava","sourceNew":"  // Used by near real-time search\n  DirectoryReader(IndexWriter writer, SegmentInfos infos, int termInfosIndexDivisor, CodecProvider codecs) throws IOException {\n    this.directory = writer.getDirectory();\n    this.readOnly = true;\n    segmentInfos = (SegmentInfos) infos.clone();// make sure we clone otherwise we share mutable state with IW\n    this.termInfosIndexDivisor = termInfosIndexDivisor;\n    if (codecs == null) {\n      this.codecs = CodecProvider.getDefault();\n    } else {\n      this.codecs = codecs;\n    }\n\n    // IndexWriter synchronizes externally before calling\n    // us, which ensures infos will not change; so there's\n    // no need to process segments in reverse order\n    final int numSegments = infos.size();\n    SegmentReader[] readers = new SegmentReader[numSegments];\n    final Directory dir = writer.getDirectory();\n\n    for (int i=0;i<numSegments;i++) {\n      boolean success = false;\n      try {\n        final SegmentInfo info = infos.info(i);\n        assert info.dir == dir;\n        readers[i] = writer.readerPool.getReadOnlyClone(info, true, termInfosIndexDivisor);\n        success = true;\n      } finally {\n        if (!success) {\n          // Close all readers we had opened:\n          for(i--;i>=0;i--) {\n            try {\n              readers[i].close();\n            } catch (Throwable ignore) {\n              // keep going - we want to clean up as much as possible\n            }\n          }\n        }\n      }\n    }\n\n    this.writer = writer;\n\n    initialize(readers);\n  }\n\n","sourceOld":"  // Used by near real-time search\n  DirectoryReader(IndexWriter writer, SegmentInfos infos, int termInfosIndexDivisor, CodecProvider codecs) throws IOException {\n    this.directory = writer.getDirectory();\n    this.readOnly = true;\n    segmentInfos = infos;\n    segmentInfosStart = (SegmentInfos) infos.clone();\n    this.termInfosIndexDivisor = termInfosIndexDivisor;\n    if (codecs == null) {\n      this.codecs = CodecProvider.getDefault();\n    } else {\n      this.codecs = codecs;\n    }\n\n    // IndexWriter synchronizes externally before calling\n    // us, which ensures infos will not change; so there's\n    // no need to process segments in reverse order\n    final int numSegments = infos.size();\n    SegmentReader[] readers = new SegmentReader[numSegments];\n    final Directory dir = writer.getDirectory();\n\n    for (int i=0;i<numSegments;i++) {\n      boolean success = false;\n      try {\n        final SegmentInfo info = infos.info(i);\n        assert info.dir == dir;\n        readers[i] = writer.readerPool.getReadOnlyClone(info, true, termInfosIndexDivisor);\n        success = true;\n      } finally {\n        if (!success) {\n          // Close all readers we had opened:\n          for(i--;i>=0;i--) {\n            try {\n              readers[i].close();\n            } catch (Throwable ignore) {\n              // keep going - we want to clean up as much as possible\n            }\n          }\n        }\n      }\n    }\n\n    this.writer = writer;\n\n    initialize(readers);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cdd3a20c3f7b8db3ed0313a58cb6304f9b5bc340","date":1295995357,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DirectoryReader#DirectoryReader(IndexWriter,SegmentInfos,int,CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DirectoryReader#DirectoryReader(IndexWriter,SegmentInfos,int,CodecProvider).mjava","sourceNew":"  // Used by near real-time search\n  DirectoryReader(IndexWriter writer, SegmentInfos infos, int termInfosIndexDivisor, CodecProvider codecs) throws IOException {\n    this.directory = writer.getDirectory();\n    this.readOnly = true;\n    segmentInfos = (SegmentInfos) infos.clone();// make sure we clone otherwise we share mutable state with IW\n    this.termInfosIndexDivisor = termInfosIndexDivisor;\n    if (codecs == null) {\n      this.codecs = CodecProvider.getDefault();\n    } else {\n      this.codecs = codecs;\n    }\n    readerFinishedListeners = writer.getReaderFinishedListeners();\n\n    // IndexWriter synchronizes externally before calling\n    // us, which ensures infos will not change; so there's\n    // no need to process segments in reverse order\n    final int numSegments = infos.size();\n    SegmentReader[] readers = new SegmentReader[numSegments];\n    final Directory dir = writer.getDirectory();\n\n    for (int i=0;i<numSegments;i++) {\n      boolean success = false;\n      try {\n        final SegmentInfo info = infos.info(i);\n        assert info.dir == dir;\n        readers[i] = writer.readerPool.getReadOnlyClone(info, true, termInfosIndexDivisor);\n        readers[i].readerFinishedListeners = readerFinishedListeners;\n        success = true;\n      } finally {\n        if (!success) {\n          // Close all readers we had opened:\n          for(i--;i>=0;i--) {\n            try {\n              readers[i].close();\n            } catch (Throwable ignore) {\n              // keep going - we want to clean up as much as possible\n            }\n          }\n        }\n      }\n    }\n\n    this.writer = writer;\n\n    initialize(readers);\n  }\n\n","sourceOld":"  // Used by near real-time search\n  DirectoryReader(IndexWriter writer, SegmentInfos infos, int termInfosIndexDivisor, CodecProvider codecs) throws IOException {\n    this.directory = writer.getDirectory();\n    this.readOnly = true;\n    segmentInfos = (SegmentInfos) infos.clone();// make sure we clone otherwise we share mutable state with IW\n    this.termInfosIndexDivisor = termInfosIndexDivisor;\n    if (codecs == null) {\n      this.codecs = CodecProvider.getDefault();\n    } else {\n      this.codecs = codecs;\n    }\n\n    // IndexWriter synchronizes externally before calling\n    // us, which ensures infos will not change; so there's\n    // no need to process segments in reverse order\n    final int numSegments = infos.size();\n    SegmentReader[] readers = new SegmentReader[numSegments];\n    final Directory dir = writer.getDirectory();\n\n    for (int i=0;i<numSegments;i++) {\n      boolean success = false;\n      try {\n        final SegmentInfo info = infos.info(i);\n        assert info.dir == dir;\n        readers[i] = writer.readerPool.getReadOnlyClone(info, true, termInfosIndexDivisor);\n        success = true;\n      } finally {\n        if (!success) {\n          // Close all readers we had opened:\n          for(i--;i>=0;i--) {\n            try {\n              readers[i].close();\n            } catch (Throwable ignore) {\n              // keep going - we want to clean up as much as possible\n            }\n          }\n        }\n      }\n    }\n\n    this.writer = writer;\n\n    initialize(readers);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eb378f8bdee16a26810e086303a4a86b4930ea12","date":1296410797,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DirectoryReader#DirectoryReader(IndexWriter,SegmentInfos,int,CodecProvider,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DirectoryReader#DirectoryReader(IndexWriter,SegmentInfos,int,CodecProvider).mjava","sourceNew":"  // Used by near real-time search\n  DirectoryReader(IndexWriter writer, SegmentInfos infos, int termInfosIndexDivisor, CodecProvider codecs, boolean applyAllDeletes) throws IOException {\n    this.directory = writer.getDirectory();\n    this.readOnly = true;\n    this.applyAllDeletes = applyAllDeletes;       // saved for reopen\n\n    segmentInfos = (SegmentInfos) infos.clone();// make sure we clone otherwise we share mutable state with IW\n    this.termInfosIndexDivisor = termInfosIndexDivisor;\n    if (codecs == null) {\n      this.codecs = CodecProvider.getDefault();\n    } else {\n      this.codecs = codecs;\n    }\n    readerFinishedListeners = writer.getReaderFinishedListeners();\n\n    // IndexWriter synchronizes externally before calling\n    // us, which ensures infos will not change; so there's\n    // no need to process segments in reverse order\n    final int numSegments = infos.size();\n    SegmentReader[] readers = new SegmentReader[numSegments];\n    final Directory dir = writer.getDirectory();\n\n    for (int i=0;i<numSegments;i++) {\n      boolean success = false;\n      try {\n        final SegmentInfo info = infos.info(i);\n        assert info.dir == dir;\n        readers[i] = writer.readerPool.getReadOnlyClone(info, true, termInfosIndexDivisor);\n        readers[i].readerFinishedListeners = readerFinishedListeners;\n        success = true;\n      } finally {\n        if (!success) {\n          // Close all readers we had opened:\n          for(i--;i>=0;i--) {\n            try {\n              readers[i].close();\n            } catch (Throwable ignore) {\n              // keep going - we want to clean up as much as possible\n            }\n          }\n        }\n      }\n    }\n\n    this.writer = writer;\n\n    initialize(readers);\n  }\n\n","sourceOld":"  // Used by near real-time search\n  DirectoryReader(IndexWriter writer, SegmentInfos infos, int termInfosIndexDivisor, CodecProvider codecs) throws IOException {\n    this.directory = writer.getDirectory();\n    this.readOnly = true;\n    segmentInfos = (SegmentInfos) infos.clone();// make sure we clone otherwise we share mutable state with IW\n    this.termInfosIndexDivisor = termInfosIndexDivisor;\n    if (codecs == null) {\n      this.codecs = CodecProvider.getDefault();\n    } else {\n      this.codecs = codecs;\n    }\n    readerFinishedListeners = writer.getReaderFinishedListeners();\n\n    // IndexWriter synchronizes externally before calling\n    // us, which ensures infos will not change; so there's\n    // no need to process segments in reverse order\n    final int numSegments = infos.size();\n    SegmentReader[] readers = new SegmentReader[numSegments];\n    final Directory dir = writer.getDirectory();\n\n    for (int i=0;i<numSegments;i++) {\n      boolean success = false;\n      try {\n        final SegmentInfo info = infos.info(i);\n        assert info.dir == dir;\n        readers[i] = writer.readerPool.getReadOnlyClone(info, true, termInfosIndexDivisor);\n        readers[i].readerFinishedListeners = readerFinishedListeners;\n        success = true;\n      } finally {\n        if (!success) {\n          // Close all readers we had opened:\n          for(i--;i>=0;i--) {\n            try {\n              readers[i].close();\n            } catch (Throwable ignore) {\n              // keep going - we want to clean up as much as possible\n            }\n          }\n        }\n      }\n    }\n\n    this.writer = writer;\n\n    initialize(readers);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":4,"author":"Simon Willnauer","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/DirectoryReader#DirectoryReader(IndexWriter,SegmentInfos,int,CodecProvider).mjava","sourceNew":null,"sourceOld":"  // Used by near real-time search\n  DirectoryReader(IndexWriter writer, SegmentInfos infos, int termInfosIndexDivisor, CodecProvider codecs) throws IOException {\n    this.directory = writer.getDirectory();\n    this.readOnly = true;\n    segmentInfos = (SegmentInfos) infos.clone();// make sure we clone otherwise we share mutable state with IW\n    this.termInfosIndexDivisor = termInfosIndexDivisor;\n    if (codecs == null) {\n      this.codecs = CodecProvider.getDefault();\n    } else {\n      this.codecs = codecs;\n    }\n\n    // IndexWriter synchronizes externally before calling\n    // us, which ensures infos will not change; so there's\n    // no need to process segments in reverse order\n    final int numSegments = infos.size();\n    SegmentReader[] readers = new SegmentReader[numSegments];\n    final Directory dir = writer.getDirectory();\n\n    for (int i=0;i<numSegments;i++) {\n      boolean success = false;\n      try {\n        final SegmentInfo info = infos.info(i);\n        assert info.dir == dir;\n        readers[i] = writer.readerPool.getReadOnlyClone(info, true, termInfosIndexDivisor);\n        success = true;\n      } finally {\n        if (!success) {\n          // Close all readers we had opened:\n          for(i--;i>=0;i--) {\n            try {\n              readers[i].close();\n            } catch (Throwable ignore) {\n              // keep going - we want to clean up as much as possible\n            }\n          }\n        }\n      }\n    }\n\n    this.writer = writer;\n\n    initialize(readers);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":5,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DirectoryReader#DirectoryReader(IndexWriter,SegmentInfos,int,CodecProvider,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DirectoryReader#DirectoryReader(IndexWriter,SegmentInfos,int,CodecProvider).mjava","sourceNew":"  // Used by near real-time search\n  DirectoryReader(IndexWriter writer, SegmentInfos infos, int termInfosIndexDivisor, CodecProvider codecs, boolean applyAllDeletes) throws IOException {\n    this.directory = writer.getDirectory();\n    this.readOnly = true;\n    this.applyAllDeletes = applyAllDeletes;       // saved for reopen\n\n    this.termInfosIndexDivisor = termInfosIndexDivisor;\n    if (codecs == null) {\n      this.codecs = CodecProvider.getDefault();\n    } else {\n      this.codecs = codecs;\n    }\n    readerFinishedListeners = writer.getReaderFinishedListeners();\n\n    // IndexWriter synchronizes externally before calling\n    // us, which ensures infos will not change; so there's\n    // no need to process segments in reverse order\n    final int numSegments = infos.size();\n\n    List<SegmentReader> readers = new ArrayList<SegmentReader>();\n    final Directory dir = writer.getDirectory();\n\n    segmentInfos = (SegmentInfos) infos.clone();\n    int infosUpto = 0;\n    for (int i=0;i<numSegments;i++) {\n      boolean success = false;\n      try {\n        final SegmentInfo info = infos.info(i);\n        assert info.dir == dir;\n        final SegmentReader reader = writer.readerPool.getReadOnlyClone(info, true, termInfosIndexDivisor);\n        if (reader.numDocs() > 0 || writer.getKeepFullyDeletedSegments()) {\n          reader.readerFinishedListeners = readerFinishedListeners;\n          readers.add(reader);\n          infosUpto++;\n        } else {\n          reader.close();\n          segmentInfos.remove(infosUpto);\n        }\n        success = true;\n      } finally {\n        if (!success) {\n          // Close all readers we had opened:\n          for(SegmentReader reader : readers) {\n            try {\n              reader.close();\n            } catch (Throwable ignore) {\n              // keep going - we want to clean up as much as possible\n            }\n          }\n        }\n      }\n    }\n\n    this.writer = writer;\n\n    initialize(readers.toArray(new SegmentReader[readers.size()]));\n  }\n\n","sourceOld":"  // Used by near real-time search\n  DirectoryReader(IndexWriter writer, SegmentInfos infos, int termInfosIndexDivisor, CodecProvider codecs) throws IOException {\n    this.directory = writer.getDirectory();\n    this.readOnly = true;\n    segmentInfos = (SegmentInfos) infos.clone();// make sure we clone otherwise we share mutable state with IW\n    this.termInfosIndexDivisor = termInfosIndexDivisor;\n    if (codecs == null) {\n      this.codecs = CodecProvider.getDefault();\n    } else {\n      this.codecs = codecs;\n    }\n\n    // IndexWriter synchronizes externally before calling\n    // us, which ensures infos will not change; so there's\n    // no need to process segments in reverse order\n    final int numSegments = infos.size();\n    SegmentReader[] readers = new SegmentReader[numSegments];\n    final Directory dir = writer.getDirectory();\n\n    for (int i=0;i<numSegments;i++) {\n      boolean success = false;\n      try {\n        final SegmentInfo info = infos.info(i);\n        assert info.dir == dir;\n        readers[i] = writer.readerPool.getReadOnlyClone(info, true, termInfosIndexDivisor);\n        success = true;\n      } finally {\n        if (!success) {\n          // Close all readers we had opened:\n          for(i--;i>=0;i--) {\n            try {\n              readers[i].close();\n            } catch (Throwable ignore) {\n              // keep going - we want to clean up as much as possible\n            }\n          }\n        }\n      }\n    }\n\n    this.writer = writer;\n\n    initialize(readers);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"cdd3a20c3f7b8db3ed0313a58cb6304f9b5bc340":["b102459ba40f8bc6d609b2058019db7485f7ed67"],"b102459ba40f8bc6d609b2058019db7485f7ed67":["6ba032266b3d8d7a0a98dda5ee81cc0fb195b887"],"4bd5d0a5ac72666f0bcbd50b535d2cc70dbf584b":["6ba032266b3d8d7a0a98dda5ee81cc0fb195b887"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["4bd5d0a5ac72666f0bcbd50b535d2cc70dbf584b","eb378f8bdee16a26810e086303a4a86b4930ea12"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6ba032266b3d8d7a0a98dda5ee81cc0fb195b887":["db610e9e698f94982d7a1af15a21d6a30ef96b9d"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["6ba032266b3d8d7a0a98dda5ee81cc0fb195b887","b102459ba40f8bc6d609b2058019db7485f7ed67"],"eb378f8bdee16a26810e086303a4a86b4930ea12":["cdd3a20c3f7b8db3ed0313a58cb6304f9b5bc340"],"db610e9e698f94982d7a1af15a21d6a30ef96b9d":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","eb378f8bdee16a26810e086303a4a86b4930ea12"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["eb378f8bdee16a26810e086303a4a86b4930ea12"]},"commit2Childs":{"cdd3a20c3f7b8db3ed0313a58cb6304f9b5bc340":["eb378f8bdee16a26810e086303a4a86b4930ea12"],"b102459ba40f8bc6d609b2058019db7485f7ed67":["cdd3a20c3f7b8db3ed0313a58cb6304f9b5bc340","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"4bd5d0a5ac72666f0bcbd50b535d2cc70dbf584b":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"6ba032266b3d8d7a0a98dda5ee81cc0fb195b887":["b102459ba40f8bc6d609b2058019db7485f7ed67","4bd5d0a5ac72666f0bcbd50b535d2cc70dbf584b","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["db610e9e698f94982d7a1af15a21d6a30ef96b9d"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"eb378f8bdee16a26810e086303a4a86b4930ea12":["29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"db610e9e698f94982d7a1af15a21d6a30ef96b9d":["6ba032266b3d8d7a0a98dda5ee81cc0fb195b887"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}