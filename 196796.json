{"path":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/JaroWinklerDistance#matches(String,String).mjava","commits":[{"id":"6000179efff4c320dafa76c7f0f088e44c4df0d0","date":1213765317,"type":0,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/JaroWinklerDistance#matches(String,String).mjava","pathOld":"/dev/null","sourceNew":"  private int[] matches(String s1, String s2) {\n    String max, min;\n    if (s1.length() > s2.length()) {\n      max = s1;\n      min = s2;\n    } else {\n      max = s2;\n      min = s1;\n    }\n    int range = Math.max(max.length() / 2 - 1, 0);\n    int[] matchIndexes = new int[min.length()];\n    Arrays.fill(matchIndexes, -1);\n    boolean[] matchFlags = new boolean[max.length()];\n    int matches = 0;\n    for (int mi = 0; mi < min.length(); mi++) {\n      char c1 = min.charAt(mi);\n      for (int xi = Math.max(mi - range, 0), xn = Math.min(mi + range + 1, max\n          .length()); xi < xn; xi++) {\n        if (!matchFlags[xi] && c1 == max.charAt(xi)) {\n          matchIndexes[mi] = xi;\n          matchFlags[xi] = true;\n          matches++;\n          break;\n        }\n      }\n    }\n    char[] ms1 = new char[matches];\n    char[] ms2 = new char[matches];\n    for (int i = 0, si = 0; i < min.length(); i++) {\n      if (matchIndexes[i] != -1) {\n        ms1[si] = min.charAt(i);\n        si++;\n      }\n    }\n    for (int i = 0, si = 0; i < max.length(); i++) {\n      if (matchFlags[i]) {\n        ms2[si] = max.charAt(i);\n        si++;\n      }\n    }\n    int transpositions = 0;\n    for (int mi = 0; mi < ms1.length; mi++) {\n      if (ms1[mi] != ms2[mi]) {\n        transpositions++;\n      }\n    }\n    int prefix = 0;\n    for (int mi = 0; mi < min.length(); mi++) {\n      if (s1.charAt(mi) == s2.charAt(mi)) {\n        prefix++;\n      } else {\n        break;\n      }\n    }\n    return new int[] { matches, transpositions / 2, prefix, max.length() };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/JaroWinklerDistance#matches(String,String).mjava","pathOld":"contrib/spellchecker/src/java/org/apache/lucene/search/spell/JaroWinklerDistance#matches(String,String).mjava","sourceNew":"  private int[] matches(String s1, String s2) {\n    String max, min;\n    if (s1.length() > s2.length()) {\n      max = s1;\n      min = s2;\n    } else {\n      max = s2;\n      min = s1;\n    }\n    int range = Math.max(max.length() / 2 - 1, 0);\n    int[] matchIndexes = new int[min.length()];\n    Arrays.fill(matchIndexes, -1);\n    boolean[] matchFlags = new boolean[max.length()];\n    int matches = 0;\n    for (int mi = 0; mi < min.length(); mi++) {\n      char c1 = min.charAt(mi);\n      for (int xi = Math.max(mi - range, 0), xn = Math.min(mi + range + 1, max\n          .length()); xi < xn; xi++) {\n        if (!matchFlags[xi] && c1 == max.charAt(xi)) {\n          matchIndexes[mi] = xi;\n          matchFlags[xi] = true;\n          matches++;\n          break;\n        }\n      }\n    }\n    char[] ms1 = new char[matches];\n    char[] ms2 = new char[matches];\n    for (int i = 0, si = 0; i < min.length(); i++) {\n      if (matchIndexes[i] != -1) {\n        ms1[si] = min.charAt(i);\n        si++;\n      }\n    }\n    for (int i = 0, si = 0; i < max.length(); i++) {\n      if (matchFlags[i]) {\n        ms2[si] = max.charAt(i);\n        si++;\n      }\n    }\n    int transpositions = 0;\n    for (int mi = 0; mi < ms1.length; mi++) {\n      if (ms1[mi] != ms2[mi]) {\n        transpositions++;\n      }\n    }\n    int prefix = 0;\n    for (int mi = 0; mi < min.length(); mi++) {\n      if (s1.charAt(mi) == s2.charAt(mi)) {\n        prefix++;\n      } else {\n        break;\n      }\n    }\n    return new int[] { matches, transpositions / 2, prefix, max.length() };\n  }\n\n","sourceOld":"  private int[] matches(String s1, String s2) {\n    String max, min;\n    if (s1.length() > s2.length()) {\n      max = s1;\n      min = s2;\n    } else {\n      max = s2;\n      min = s1;\n    }\n    int range = Math.max(max.length() / 2 - 1, 0);\n    int[] matchIndexes = new int[min.length()];\n    Arrays.fill(matchIndexes, -1);\n    boolean[] matchFlags = new boolean[max.length()];\n    int matches = 0;\n    for (int mi = 0; mi < min.length(); mi++) {\n      char c1 = min.charAt(mi);\n      for (int xi = Math.max(mi - range, 0), xn = Math.min(mi + range + 1, max\n          .length()); xi < xn; xi++) {\n        if (!matchFlags[xi] && c1 == max.charAt(xi)) {\n          matchIndexes[mi] = xi;\n          matchFlags[xi] = true;\n          matches++;\n          break;\n        }\n      }\n    }\n    char[] ms1 = new char[matches];\n    char[] ms2 = new char[matches];\n    for (int i = 0, si = 0; i < min.length(); i++) {\n      if (matchIndexes[i] != -1) {\n        ms1[si] = min.charAt(i);\n        si++;\n      }\n    }\n    for (int i = 0, si = 0; i < max.length(); i++) {\n      if (matchFlags[i]) {\n        ms2[si] = max.charAt(i);\n        si++;\n      }\n    }\n    int transpositions = 0;\n    for (int mi = 0; mi < ms1.length; mi++) {\n      if (ms1[mi] != ms2[mi]) {\n        transpositions++;\n      }\n    }\n    int prefix = 0;\n    for (int mi = 0; mi < min.length(); mi++) {\n      if (s1.charAt(mi) == s2.charAt(mi)) {\n        prefix++;\n      } else {\n        break;\n      }\n    }\n    return new int[] { matches, transpositions / 2, prefix, max.length() };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6000179efff4c320dafa76c7f0f088e44c4df0d0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["6000179efff4c320dafa76c7f0f088e44c4df0d0"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6000179efff4c320dafa76c7f0f088e44c4df0d0"],"6000179efff4c320dafa76c7f0f088e44c4df0d0":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}