{"path":"solr/core/src/java/org/apache/solr/util/SolrCLI#atPath(String,Map[String,Object]).mjava","commits":[{"id":"709714c6ee47950678dd2d2ef4e0473886909226","date":1407339661,"type":0,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI#atPath(String,Map[String,Object]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Helper function for reading an Object of unknown type from a JSON Object tree. \n   */\n  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n  public static Object atPath(String jsonPath, Map<String,Object> json) {\n    if (\"/\".equals(jsonPath))\n      return json;\n    \n    if (!jsonPath.startsWith(\"/\"))\n      throw new IllegalArgumentException(\"Invalid JSON path: \"+\n        jsonPath+\"! Must start with a /\");\n    \n    Map<String,Object> parent = json;      \n    Object result = null;\n    String[] path = jsonPath.split(\"/\");\n    for (int p=1; p < path.length; p++) {\n      Object child = parent.get(path[p]);      \n      if (child == null)\n        break;\n      \n      if (p == path.length-1) {\n        // success - found the node at the desired path\n        result = child;\n      } else {\n        if (child instanceof Map) {\n          // keep walking the path down to the desired node\n          parent = (Map)child;\n        } else {\n          // early termination - hit a leaf before the requested node\n          break;\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["ee8fbffa595c312bc0437f2c9bb6376a29c1b427"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"44ecc6a862721de62c141ce8b174b5c9b4d83b6e","date":1493758727,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI#atPath(String,Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI#atPath(String,Map[String,Object]).mjava","sourceNew":"  /**\n   * Helper function for reading an Object of unknown type from a JSON Object tree.\n   * \n   * To find a path to a child that starts with a slash (e.g. queryHandler named /query)\n   * you must escape the slash. For instance /config/requestHandler/\\/query/defaults/echoParams\n   * would get the echoParams value for the \"/query\" request handler.\n   */\n  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n  public static Object atPath(String jsonPath, Map<String,Object> json) {\n    if (\"/\".equals(jsonPath))\n      return json;\n    \n    if (!jsonPath.startsWith(\"/\"))\n      throw new IllegalArgumentException(\"Invalid JSON path: \"+\n        jsonPath+\"! Must start with a /\");\n    \n    Map<String,Object> parent = json;      \n    Object result = null;\n    String[] path = jsonPath.split(\"(?<![\\\\\\\\])/\"); // Break on all slashes _not_ preceeded by a backslash\n    for (int p=1; p < path.length; p++) {\n      String part = path[p];\n      \n      if (part.startsWith(\"\\\\\")) {\n        part = part.substring(1);\n      }\n\n      Object child = parent.get(part);      \n      if (child == null)\n        break;\n      \n      if (p == path.length-1) {\n        // success - found the node at the desired path\n        result = child;\n      } else {\n        if (child instanceof Map) {\n          // keep walking the path down to the desired node\n          parent = (Map)child;\n        } else {\n          // early termination - hit a leaf before the requested node\n          break;\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Helper function for reading an Object of unknown type from a JSON Object tree. \n   */\n  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n  public static Object atPath(String jsonPath, Map<String,Object> json) {\n    if (\"/\".equals(jsonPath))\n      return json;\n    \n    if (!jsonPath.startsWith(\"/\"))\n      throw new IllegalArgumentException(\"Invalid JSON path: \"+\n        jsonPath+\"! Must start with a /\");\n    \n    Map<String,Object> parent = json;      \n    Object result = null;\n    String[] path = jsonPath.split(\"/\");\n    for (int p=1; p < path.length; p++) {\n      Object child = parent.get(path[p]);      \n      if (child == null)\n        break;\n      \n      if (p == path.length-1) {\n        // success - found the node at the desired path\n        result = child;\n      } else {\n        if (child instanceof Map) {\n          // keep walking the path down to the desired node\n          parent = (Map)child;\n        } else {\n          // early termination - hit a leaf before the requested node\n          break;\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI#atPath(String,Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI#atPath(String,Map[String,Object]).mjava","sourceNew":"  /**\n   * Helper function for reading an Object of unknown type from a JSON Object tree.\n   * \n   * To find a path to a child that starts with a slash (e.g. queryHandler named /query)\n   * you must escape the slash. For instance /config/requestHandler/\\/query/defaults/echoParams\n   * would get the echoParams value for the \"/query\" request handler.\n   */\n  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n  public static Object atPath(String jsonPath, Map<String,Object> json) {\n    if (\"/\".equals(jsonPath))\n      return json;\n    \n    if (!jsonPath.startsWith(\"/\"))\n      throw new IllegalArgumentException(\"Invalid JSON path: \"+\n        jsonPath+\"! Must start with a /\");\n    \n    Map<String,Object> parent = json;      \n    Object result = null;\n    String[] path = jsonPath.split(\"(?<![\\\\\\\\])/\"); // Break on all slashes _not_ preceeded by a backslash\n    for (int p=1; p < path.length; p++) {\n      String part = path[p];\n      \n      if (part.startsWith(\"\\\\\")) {\n        part = part.substring(1);\n      }\n\n      Object child = parent.get(part);      \n      if (child == null)\n        break;\n      \n      if (p == path.length-1) {\n        // success - found the node at the desired path\n        result = child;\n      } else {\n        if (child instanceof Map) {\n          // keep walking the path down to the desired node\n          parent = (Map)child;\n        } else {\n          // early termination - hit a leaf before the requested node\n          break;\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Helper function for reading an Object of unknown type from a JSON Object tree. \n   */\n  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n  public static Object atPath(String jsonPath, Map<String,Object> json) {\n    if (\"/\".equals(jsonPath))\n      return json;\n    \n    if (!jsonPath.startsWith(\"/\"))\n      throw new IllegalArgumentException(\"Invalid JSON path: \"+\n        jsonPath+\"! Must start with a /\");\n    \n    Map<String,Object> parent = json;      \n    Object result = null;\n    String[] path = jsonPath.split(\"/\");\n    for (int p=1; p < path.length; p++) {\n      Object child = parent.get(path[p]);      \n      if (child == null)\n        break;\n      \n      if (p == path.length-1) {\n        // success - found the node at the desired path\n        result = child;\n      } else {\n        if (child instanceof Map) {\n          // keep walking the path down to the desired node\n          parent = (Map)child;\n        } else {\n          // early termination - hit a leaf before the requested node\n          break;\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b79a5db147a1c6f95d1625ddbc3561ef56955225","date":1528848080,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI#atPath(String,Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI#atPath(String,Map[String,Object]).mjava","sourceNew":"  /**\n   * Helper function for reading an Object of unknown type from a JSON Object tree.\n   * \n   * To find a path to a child that starts with a slash (e.g. queryHandler named /query)\n   * you must escape the slash. For instance /config/requestHandler/\\/query/defaults/echoParams\n   * would get the echoParams value for the \"/query\" request handler.\n   */\n  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n  public static Object atPath(String jsonPath, Map<String,Object> json) {\n    if (\"/\".equals(jsonPath))\n      return json;\n    \n    if (!jsonPath.startsWith(\"/\"))\n      throw new IllegalArgumentException(\"Invalid JSON path: \"+\n        jsonPath+\"! Must start with a /\");\n    \n    Map<String,Object> parent = json;      \n    Object result = null;\n    String[] path = jsonPath.split(\"(?<![\\\\\\\\])/\"); // Break on all slashes _not_ preceeded by a backslash\n    for (int p=1; p < path.length; p++) {\n      String part = path[p];\n      \n      if (part.startsWith(\"\\\\\")) {\n        part = part.substring(1);\n      }\n\n      Object child = parent.get(part);      \n      if (child == null)\n        break;\n      \n      if (p == path.length-1) {\n        // success - found the node at the desired path\n        result = child;\n      } else {\n        if (child instanceof Map) {\n          // keep walking the path down to the desired node\n          parent = (Map)child;\n        } else {\n          // early termination - hit a leaf before the requested node\n          break;\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Helper function for reading an Object of unknown type from a JSON Object tree.\n   * \n   * To find a path to a child that starts with a slash (e.g. queryHandler named /query)\n   * you must escape the slash. For instance /config/requestHandler/\\/query/defaults/echoParams\n   * would get the echoParams value for the \"/query\" request handler.\n   */\n  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n  public static Object atPath(String jsonPath, Map<String,Object> json) {\n    if (\"/\".equals(jsonPath))\n      return json;\n    \n    if (!jsonPath.startsWith(\"/\"))\n      throw new IllegalArgumentException(\"Invalid JSON path: \"+\n        jsonPath+\"! Must start with a /\");\n    \n    Map<String,Object> parent = json;      \n    Object result = null;\n    String[] path = jsonPath.split(\"(?<![\\\\\\\\])/\"); // Break on all slashes _not_ preceeded by a backslash\n    for (int p=1; p < path.length; p++) {\n      String part = path[p];\n      \n      if (part.startsWith(\"\\\\\")) {\n        part = part.substring(1);\n      }\n\n      Object child = parent.get(part);      \n      if (child == null)\n        break;\n      \n      if (p == path.length-1) {\n        // success - found the node at the desired path\n        result = child;\n      } else {\n        if (child instanceof Map) {\n          // keep walking the path down to the desired node\n          parent = (Map)child;\n        } else {\n          // early termination - hit a leaf before the requested node\n          break;\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI#atPath(String,Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI#atPath(String,Map[String,Object]).mjava","sourceNew":"  /**\n   * Helper function for reading an Object of unknown type from a JSON Object tree.\n   * \n   * To find a path to a child that starts with a slash (e.g. queryHandler named /query)\n   * you must escape the slash. For instance /config/requestHandler/\\/query/defaults/echoParams\n   * would get the echoParams value for the \"/query\" request handler.\n   */\n  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n  public static Object atPath(String jsonPath, Map<String,Object> json) {\n    if (\"/\".equals(jsonPath))\n      return json;\n    \n    if (!jsonPath.startsWith(\"/\"))\n      throw new IllegalArgumentException(\"Invalid JSON path: \"+\n        jsonPath+\"! Must start with a /\");\n    \n    Map<String,Object> parent = json;      \n    Object result = null;\n    String[] path = jsonPath.split(\"(?<![\\\\\\\\])/\"); // Break on all slashes _not_ preceeded by a backslash\n    for (int p=1; p < path.length; p++) {\n      String part = path[p];\n      \n      if (part.startsWith(\"\\\\\")) {\n        part = part.substring(1);\n      }\n\n      Object child = parent.get(part);      \n      if (child == null)\n        break;\n      \n      if (p == path.length-1) {\n        // success - found the node at the desired path\n        result = child;\n      } else {\n        if (child instanceof Map) {\n          // keep walking the path down to the desired node\n          parent = (Map)child;\n        } else {\n          // early termination - hit a leaf before the requested node\n          break;\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Helper function for reading an Object of unknown type from a JSON Object tree.\n   * \n   * To find a path to a child that starts with a slash (e.g. queryHandler named /query)\n   * you must escape the slash. For instance /config/requestHandler/\\/query/defaults/echoParams\n   * would get the echoParams value for the \"/query\" request handler.\n   */\n  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n  public static Object atPath(String jsonPath, Map<String,Object> json) {\n    if (\"/\".equals(jsonPath))\n      return json;\n    \n    if (!jsonPath.startsWith(\"/\"))\n      throw new IllegalArgumentException(\"Invalid JSON path: \"+\n        jsonPath+\"! Must start with a /\");\n    \n    Map<String,Object> parent = json;      \n    Object result = null;\n    String[] path = jsonPath.split(\"(?<![\\\\\\\\])/\"); // Break on all slashes _not_ preceeded by a backslash\n    for (int p=1; p < path.length; p++) {\n      String part = path[p];\n      \n      if (part.startsWith(\"\\\\\")) {\n        part = part.substring(1);\n      }\n\n      Object child = parent.get(part);      \n      if (child == null)\n        break;\n      \n      if (p == path.length-1) {\n        // success - found the node at the desired path\n        result = child;\n      } else {\n        if (child instanceof Map) {\n          // keep walking the path down to the desired node\n          parent = (Map)child;\n        } else {\n          // early termination - hit a leaf before the requested node\n          break;\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI#atPath(String,Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI#atPath(String,Map[String,Object]).mjava","sourceNew":"  /**\n   * Helper function for reading an Object of unknown type from a JSON Object tree.\n   * \n   * To find a path to a child that starts with a slash (e.g. queryHandler named /query)\n   * you must escape the slash. For instance /config/requestHandler/\\/query/defaults/echoParams\n   * would get the echoParams value for the \"/query\" request handler.\n   */\n  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n  public static Object atPath(String jsonPath, Map<String,Object> json) {\n    if (\"/\".equals(jsonPath))\n      return json;\n    \n    if (!jsonPath.startsWith(\"/\"))\n      throw new IllegalArgumentException(\"Invalid JSON path: \"+\n        jsonPath+\"! Must start with a /\");\n    \n    Map<String,Object> parent = json;      \n    Object result = null;\n    String[] path = jsonPath.split(\"(?<![\\\\\\\\])/\"); // Break on all slashes _not_ preceeded by a backslash\n    for (int p=1; p < path.length; p++) {\n      String part = path[p];\n      \n      if (part.startsWith(\"\\\\\")) {\n        part = part.substring(1);\n      }\n\n      Object child = parent.get(part);      \n      if (child == null)\n        break;\n      \n      if (p == path.length-1) {\n        // success - found the node at the desired path\n        result = child;\n      } else {\n        if (child instanceof Map) {\n          // keep walking the path down to the desired node\n          parent = (Map)child;\n        } else {\n          // early termination - hit a leaf before the requested node\n          break;\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Helper function for reading an Object of unknown type from a JSON Object tree.\n   * \n   * To find a path to a child that starts with a slash (e.g. queryHandler named /query)\n   * you must escape the slash. For instance /config/requestHandler/\\/query/defaults/echoParams\n   * would get the echoParams value for the \"/query\" request handler.\n   */\n  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n  public static Object atPath(String jsonPath, Map<String,Object> json) {\n    if (\"/\".equals(jsonPath))\n      return json;\n    \n    if (!jsonPath.startsWith(\"/\"))\n      throw new IllegalArgumentException(\"Invalid JSON path: \"+\n        jsonPath+\"! Must start with a /\");\n    \n    Map<String,Object> parent = json;      \n    Object result = null;\n    String[] path = jsonPath.split(\"(?<![\\\\\\\\])/\"); // Break on all slashes _not_ preceeded by a backslash\n    for (int p=1; p < path.length; p++) {\n      String part = path[p];\n      \n      if (part.startsWith(\"\\\\\")) {\n        part = part.substring(1);\n      }\n\n      Object child = parent.get(part);      \n      if (child == null)\n        break;\n      \n      if (p == path.length-1) {\n        // success - found the node at the desired path\n        result = child;\n      } else {\n        if (child instanceof Map) {\n          // keep walking the path down to the desired node\n          parent = (Map)child;\n        } else {\n          // early termination - hit a leaf before the requested node\n          break;\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15","date":1554259533,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI#atPath(String,Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI#atPath(String,Map[String,Object]).mjava","sourceNew":"  /**\n   * Helper function for reading an Object of unknown type from a JSON Object tree.\n   *\n   * To find a path to a child that starts with a slash (e.g. queryHandler named /query)\n   * you must escape the slash. For instance /config/requestHandler/\\/query/defaults/echoParams\n   * would get the echoParams value for the \"/query\" request handler.\n   */\n  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n  public static Object atPath(String jsonPath, Map<String,Object> json) {\n    if (\"/\".equals(jsonPath))\n      return json;\n\n    if (!jsonPath.startsWith(\"/\"))\n      throw new IllegalArgumentException(\"Invalid JSON path: \"+\n        jsonPath+\"! Must start with a /\");\n\n    Map<String,Object> parent = json;\n    Object result = null;\n    String[] path = jsonPath.split(\"(?<![\\\\\\\\])/\"); // Break on all slashes _not_ preceeded by a backslash\n    for (int p=1; p < path.length; p++) {\n      String part = path[p];\n\n      if (part.startsWith(\"\\\\\")) {\n        part = part.substring(1);\n      }\n\n      Object child = parent.get(part);\n      if (child == null)\n        break;\n\n      if (p == path.length-1) {\n        // success - found the node at the desired path\n        result = child;\n      } else {\n        if (child instanceof Map) {\n          // keep walking the path down to the desired node\n          parent = (Map)child;\n        } else {\n          // early termination - hit a leaf before the requested node\n          break;\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Helper function for reading an Object of unknown type from a JSON Object tree.\n   * \n   * To find a path to a child that starts with a slash (e.g. queryHandler named /query)\n   * you must escape the slash. For instance /config/requestHandler/\\/query/defaults/echoParams\n   * would get the echoParams value for the \"/query\" request handler.\n   */\n  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n  public static Object atPath(String jsonPath, Map<String,Object> json) {\n    if (\"/\".equals(jsonPath))\n      return json;\n    \n    if (!jsonPath.startsWith(\"/\"))\n      throw new IllegalArgumentException(\"Invalid JSON path: \"+\n        jsonPath+\"! Must start with a /\");\n    \n    Map<String,Object> parent = json;      \n    Object result = null;\n    String[] path = jsonPath.split(\"(?<![\\\\\\\\])/\"); // Break on all slashes _not_ preceeded by a backslash\n    for (int p=1; p < path.length; p++) {\n      String part = path[p];\n      \n      if (part.startsWith(\"\\\\\")) {\n        part = part.substring(1);\n      }\n\n      Object child = parent.get(part);      \n      if (child == null)\n        break;\n      \n      if (p == path.length-1) {\n        // success - found the node at the desired path\n        result = child;\n      } else {\n        if (child instanceof Map) {\n          // keep walking the path down to the desired node\n          parent = (Map)child;\n        } else {\n          // early termination - hit a leaf before the requested node\n          break;\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ee8fbffa595c312bc0437f2c9bb6376a29c1b427","date":1589412657,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/SolrCLI#atPath(String,Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/SolrCLI#atPath(String,Map[String,Object]).mjava","sourceNew":"  /**\n   * Helper function for reading an Object of unknown type from a JSON Object tree.\n   *\n   * To find a path to a child that starts with a slash (e.g. queryHandler named /query)\n   * you must escape the slash. For instance /config/requestHandler/\\/query/defaults/echoParams\n   * would get the echoParams value for the \"/query\" request handler.\n   */\n  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n  public static Object atPath(String jsonPath, Map<String,Object> json) {\n    if (\"/\".equals(jsonPath))\n      return json;\n\n    if (!jsonPath.startsWith(\"/\"))\n      throw new IllegalArgumentException(\"Invalid JSON path: \"+\n          jsonPath+\"! Must start with a /\");\n\n    Map<String,Object> parent = json;\n    Object result = null;\n    String[] path = jsonPath.split(\"(?<![\\\\\\\\])/\"); // Break on all slashes _not_ preceeded by a backslash\n    for (int p=1; p < path.length; p++) {\n      String part = path[p];\n\n      if (part.startsWith(\"\\\\\")) {\n        part = part.substring(1);\n      }\n\n      Object child = parent.get(part);\n      if (child == null)\n        break;\n\n      if (p == path.length-1) {\n        // success - found the node at the desired path\n        result = child;\n      } else {\n        if (child instanceof Map) {\n          // keep walking the path down to the desired node\n          parent = (Map)child;\n        } else {\n          // early termination - hit a leaf before the requested node\n          break;\n        }\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  /**\n   * Helper function for reading an Object of unknown type from a JSON Object tree.\n   *\n   * To find a path to a child that starts with a slash (e.g. queryHandler named /query)\n   * you must escape the slash. For instance /config/requestHandler/\\/query/defaults/echoParams\n   * would get the echoParams value for the \"/query\" request handler.\n   */\n  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n  public static Object atPath(String jsonPath, Map<String,Object> json) {\n    if (\"/\".equals(jsonPath))\n      return json;\n\n    if (!jsonPath.startsWith(\"/\"))\n      throw new IllegalArgumentException(\"Invalid JSON path: \"+\n        jsonPath+\"! Must start with a /\");\n\n    Map<String,Object> parent = json;\n    Object result = null;\n    String[] path = jsonPath.split(\"(?<![\\\\\\\\])/\"); // Break on all slashes _not_ preceeded by a backslash\n    for (int p=1; p < path.length; p++) {\n      String part = path[p];\n\n      if (part.startsWith(\"\\\\\")) {\n        part = part.substring(1);\n      }\n\n      Object child = parent.get(part);\n      if (child == null)\n        break;\n\n      if (p == path.length-1) {\n        // success - found the node at the desired path\n        result = child;\n      } else {\n        if (child instanceof Map) {\n          // keep walking the path down to the desired node\n          parent = (Map)child;\n        } else {\n          // early termination - hit a leaf before the requested node\n          break;\n        }\n      }\n    }\n    return result;\n  }\n\n","bugFix":["709714c6ee47950678dd2d2ef4e0473886909226"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e9017cf144952056066919f1ebc7897ff9bd71b1":["709714c6ee47950678dd2d2ef4e0473886909226","44ecc6a862721de62c141ce8b174b5c9b4d83b6e"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["44ecc6a862721de62c141ce8b174b5c9b4d83b6e","b79a5db147a1c6f95d1625ddbc3561ef56955225"],"709714c6ee47950678dd2d2ef4e0473886909226":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ee8fbffa595c312bc0437f2c9bb6376a29c1b427":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15"],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["b79a5db147a1c6f95d1625ddbc3561ef56955225"],"44ecc6a862721de62c141ce8b174b5c9b4d83b6e":["709714c6ee47950678dd2d2ef4e0473886909226"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ee8fbffa595c312bc0437f2c9bb6376a29c1b427"],"b79a5db147a1c6f95d1625ddbc3561ef56955225":["44ecc6a862721de62c141ce8b174b5c9b4d83b6e"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["44ecc6a862721de62c141ce8b174b5c9b4d83b6e","b79a5db147a1c6f95d1625ddbc3561ef56955225"]},"commit2Childs":{"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"709714c6ee47950678dd2d2ef4e0473886909226":["e9017cf144952056066919f1ebc7897ff9bd71b1","44ecc6a862721de62c141ce8b174b5c9b4d83b6e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["709714c6ee47950678dd2d2ef4e0473886909226"],"ee8fbffa595c312bc0437f2c9bb6376a29c1b427":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["ee8fbffa595c312bc0437f2c9bb6376a29c1b427"],"44ecc6a862721de62c141ce8b174b5c9b4d83b6e":["e9017cf144952056066919f1ebc7897ff9bd71b1","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","b79a5db147a1c6f95d1625ddbc3561ef56955225","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"b79a5db147a1c6f95d1625ddbc3561ef56955225":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}