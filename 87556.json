{"path":"solr/core/src/test/org/apache/solr/search/TestSolrCoreParser#testCustomQueryWrapping().mjava","commits":[{"id":"8adbe9599e1f40415314d303714aa799ccedcbfa","date":1485884320,"type":0,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolrCoreParser#testCustomQueryWrapping().mjava","pathOld":"/dev/null","sourceNew":"  // test custom queries being wrapped in a Query or SpanQuery\n  public void testCustomQueryWrapping() throws IOException, ParserException {\n    final boolean span = random().nextBoolean();\n    // the custom queries\n    final String fieldName = \"contents\";\n    final String[] randomTerms = new String[] {\"bumble\", \"honey\", \"solitary\"};\n    final String randomQuery = composeChooseOneWordQueryXml(fieldName, randomTerms);\n    final String apacheLuceneSolr = \"<ApacheLuceneSolr fieldName='\"+fieldName+\"'/>\";\n    // the wrapping query\n    final String parentQuery = (span ? \"SpanOr\" : \"BooleanQuery\");\n    final String subQueryPrefix = (span ? \"\" : \"<Clause occurs='must'>\");\n    final String subQuerySuffix = (span ? \"\" : \"</Clause>\");\n    final String xml = \"<\"+parentQuery+\">\"\n        + subQueryPrefix+randomQuery+subQuerySuffix\n        + subQueryPrefix+apacheLuceneSolr+subQuerySuffix\n        + \"</\"+parentQuery+\">\";\n    // the test\n    final Query query = parseXmlString(xml);\n    if (span) {\n      assertTrue(unwrapSpanBoostQuery(query) instanceof SpanOrQuery);\n      final SpanOrQuery soq = (SpanOrQuery)unwrapSpanBoostQuery(query);\n      assertEquals(2, soq.getClauses().length);\n      checkChooseOneWordQuery(span, soq.getClauses()[0], fieldName, randomTerms);\n      checkApacheLuceneSolr(soq.getClauses()[1], fieldName);\n    } else {\n      assertTrue(query instanceof BooleanQuery);\n      final BooleanQuery bq = (BooleanQuery)query;\n      assertEquals(2, bq.clauses().size());\n      checkChooseOneWordQuery(span, bq.clauses().get(0).getQuery(), fieldName, randomTerms);\n      checkApacheLuceneSolr(bq.clauses().get(1).getQuery(), fieldName);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c3523a0ab04c3002eee3896c75ea5f10f388bcc","date":1485968422,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSolrCoreParser#testCustomQueryWrapping().mjava","pathOld":"/dev/null","sourceNew":"  // test custom queries being wrapped in a Query or SpanQuery\n  public void testCustomQueryWrapping() throws IOException, ParserException {\n    final boolean span = random().nextBoolean();\n    // the custom queries\n    final String fieldName = \"contents\";\n    final String[] randomTerms = new String[] {\"bumble\", \"honey\", \"solitary\"};\n    final String randomQuery = composeChooseOneWordQueryXml(fieldName, randomTerms);\n    final String apacheLuceneSolr = \"<ApacheLuceneSolr fieldName='\"+fieldName+\"'/>\";\n    // the wrapping query\n    final String parentQuery = (span ? \"SpanOr\" : \"BooleanQuery\");\n    final String subQueryPrefix = (span ? \"\" : \"<Clause occurs='must'>\");\n    final String subQuerySuffix = (span ? \"\" : \"</Clause>\");\n    final String xml = \"<\"+parentQuery+\">\"\n        + subQueryPrefix+randomQuery+subQuerySuffix\n        + subQueryPrefix+apacheLuceneSolr+subQuerySuffix\n        + \"</\"+parentQuery+\">\";\n    // the test\n    final Query query = parseXmlString(xml);\n    if (span) {\n      assertTrue(unwrapSpanBoostQuery(query) instanceof SpanOrQuery);\n      final SpanOrQuery soq = (SpanOrQuery)unwrapSpanBoostQuery(query);\n      assertEquals(2, soq.getClauses().length);\n      checkChooseOneWordQuery(span, soq.getClauses()[0], fieldName, randomTerms);\n      checkApacheLuceneSolr(soq.getClauses()[1], fieldName);\n    } else {\n      assertTrue(query instanceof BooleanQuery);\n      final BooleanQuery bq = (BooleanQuery)query;\n      assertEquals(2, bq.clauses().size());\n      checkChooseOneWordQuery(span, bq.clauses().get(0).getQuery(), fieldName, randomTerms);\n      checkApacheLuceneSolr(bq.clauses().get(1).getQuery(), fieldName);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8adbe9599e1f40415314d303714aa799ccedcbfa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","8adbe9599e1f40415314d303714aa799ccedcbfa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8adbe9599e1f40415314d303714aa799ccedcbfa"]},"commit2Childs":{"8adbe9599e1f40415314d303714aa799ccedcbfa":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8adbe9599e1f40415314d303714aa799ccedcbfa","7c3523a0ab04c3002eee3896c75ea5f10f388bcc"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}