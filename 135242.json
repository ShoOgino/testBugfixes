{"path":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/IntersectsPrefixTreeQuery#getDocIdSet(LeafReaderContext).mjava","commits":[{"id":"112d77ac8d3e10a362516ad834c9a11d35c94234","date":1456784319,"type":1,"author":"nknize","isMerge":false,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/IntersectsPrefixTreeQuery#getDocIdSet(LeafReaderContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/IntersectsPrefixTreeQuery#getDocIdSet(LeafReaderContext).mjava","sourceNew":"  @Override\n  protected DocIdSet getDocIdSet(LeafReaderContext context) throws IOException {\n    /* Possible optimizations (in IN ADDITION TO THOSE LISTED IN VISITORTEMPLATE):\n\n    * If docFreq is 1 (or < than some small threshold), then check to see if we've already\n      collected it; if so short-circuit. Don't do this just for point data, as there is\n      no benefit, or only marginal benefit when multi-valued.\n\n    * Point query shape optimization when the only indexed data is a point (no leaves).  Result is a term query.\n\n     */\n    return new VisitorTemplate(context) {\n      private FixedBitSet results;\n\n      @Override\n      protected void start() {\n        results = new FixedBitSet(maxDoc);\n      }\n\n      @Override\n      protected DocIdSet finish() {\n        return new BitDocIdSet(results);\n      }\n\n      @Override\n      protected boolean visitPrefix(Cell cell) throws IOException {\n        if (cell.getShapeRel() == SpatialRelation.WITHIN || cell.getLevel() == detailLevel) {\n          collectDocs(results);\n          return false;\n        }\n        return true;\n      }\n\n      @Override\n      protected void visitLeaf(Cell cell) throws IOException {\n        collectDocs(results);\n      }\n\n    }.getDocIdSet();\n  }\n\n","sourceOld":"  @Override\n  protected DocIdSet getDocIdSet(LeafReaderContext context) throws IOException {\n    /* Possible optimizations (in IN ADDITION TO THOSE LISTED IN VISITORTEMPLATE):\n\n    * If docFreq is 1 (or < than some small threshold), then check to see if we've already\n      collected it; if so short-circuit. Don't do this just for point data, as there is\n      no benefit, or only marginal benefit when multi-valued.\n\n    * Point query shape optimization when the only indexed data is a point (no leaves).  Result is a term query.\n\n     */\n    return new VisitorTemplate(context) {\n      private FixedBitSet results;\n\n      @Override\n      protected void start() {\n        results = new FixedBitSet(maxDoc);\n      }\n\n      @Override\n      protected DocIdSet finish() {\n        return new BitDocIdSet(results);\n      }\n\n      @Override\n      protected boolean visitPrefix(Cell cell) throws IOException {\n        if (cell.getShapeRel() == SpatialRelation.WITHIN || cell.getLevel() == detailLevel) {\n          collectDocs(results);\n          return false;\n        }\n        return true;\n      }\n\n      @Override\n      protected void visitLeaf(Cell cell) throws IOException {\n        collectDocs(results);\n      }\n\n    }.getDocIdSet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":1,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/IntersectsPrefixTreeQuery#getDocIdSet(LeafReaderContext).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/IntersectsPrefixTreeQuery#getDocIdSet(LeafReaderContext).mjava","sourceNew":"  @Override\n  protected DocIdSet getDocIdSet(LeafReaderContext context) throws IOException {\n    /* Possible optimizations (in IN ADDITION TO THOSE LISTED IN VISITORTEMPLATE):\n\n    * If docFreq is 1 (or < than some small threshold), then check to see if we've already\n      collected it; if so short-circuit. Don't do this just for point data, as there is\n      no benefit, or only marginal benefit when multi-valued.\n\n    * Point query shape optimization when the only indexed data is a point (no leaves).  Result is a term query.\n\n     */\n    return new VisitorTemplate(context) {\n      private FixedBitSet results;\n\n      @Override\n      protected void start() {\n        results = new FixedBitSet(maxDoc);\n      }\n\n      @Override\n      protected DocIdSet finish() {\n        return new BitDocIdSet(results);\n      }\n\n      @Override\n      protected boolean visitPrefix(Cell cell) throws IOException {\n        if (cell.getShapeRel() == SpatialRelation.WITHIN || cell.getLevel() == detailLevel) {\n          collectDocs(results);\n          return false;\n        }\n        return true;\n      }\n\n      @Override\n      protected void visitLeaf(Cell cell) throws IOException {\n        collectDocs(results);\n      }\n\n    }.getDocIdSet();\n  }\n\n","sourceOld":"  @Override\n  protected DocIdSet getDocIdSet(LeafReaderContext context) throws IOException {\n    /* Possible optimizations (in IN ADDITION TO THOSE LISTED IN VISITORTEMPLATE):\n\n    * If docFreq is 1 (or < than some small threshold), then check to see if we've already\n      collected it; if so short-circuit. Don't do this just for point data, as there is\n      no benefit, or only marginal benefit when multi-valued.\n\n    * Point query shape optimization when the only indexed data is a point (no leaves).  Result is a term query.\n\n     */\n    return new VisitorTemplate(context) {\n      private FixedBitSet results;\n\n      @Override\n      protected void start() {\n        results = new FixedBitSet(maxDoc);\n      }\n\n      @Override\n      protected DocIdSet finish() {\n        return new BitDocIdSet(results);\n      }\n\n      @Override\n      protected boolean visitPrefix(Cell cell) throws IOException {\n        if (cell.getShapeRel() == SpatialRelation.WITHIN || cell.getLevel() == detailLevel) {\n          collectDocs(results);\n          return false;\n        }\n        return true;\n      }\n\n      @Override\n      protected void visitLeaf(Cell cell) throws IOException {\n        collectDocs(results);\n      }\n\n    }.getDocIdSet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ebe63dbc2ae3f506a79b831dee10fb781a7599fb","date":1460558349,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/IntersectsPrefixTreeQuery#getDocIdSet(LeafReaderContext).mjava","pathOld":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/IntersectsPrefixTreeQuery#getDocIdSet(LeafReaderContext).mjava","sourceNew":"  @Override\n  protected DocIdSet getDocIdSet(LeafReaderContext context) throws IOException {\n    /* Possible optimizations (in IN ADDITION TO THOSE LISTED IN VISITORTEMPLATE):\n\n    * If docFreq is 1 (or < than some small threshold), then check to see if we've already\n      collected it; if so short-circuit. Don't do this just for point data, as there is\n      no benefit, or only marginal benefit when multi-valued.\n\n    * Point query shape optimization when the only indexed data is a point (no leaves).  Result is a term query.\n\n     */\n    return new VisitorTemplate(context) {\n      private DocIdSetBuilder results;\n\n      @Override\n      protected void start() {\n        results = new DocIdSetBuilder(maxDoc);\n      }\n\n      @Override\n      protected DocIdSet finish() {\n        return results.build();\n      }\n\n      @Override\n      protected boolean visitPrefix(Cell cell) throws IOException {\n        if (cell.getShapeRel() == SpatialRelation.WITHIN || cell.getLevel() == detailLevel) {\n          collectDocs(results);\n          return false;\n        }\n        return true;\n      }\n\n      @Override\n      protected void visitLeaf(Cell cell) throws IOException {\n        collectDocs(results);\n      }\n\n    }.getDocIdSet();\n  }\n\n","sourceOld":"  @Override\n  protected DocIdSet getDocIdSet(LeafReaderContext context) throws IOException {\n    /* Possible optimizations (in IN ADDITION TO THOSE LISTED IN VISITORTEMPLATE):\n\n    * If docFreq is 1 (or < than some small threshold), then check to see if we've already\n      collected it; if so short-circuit. Don't do this just for point data, as there is\n      no benefit, or only marginal benefit when multi-valued.\n\n    * Point query shape optimization when the only indexed data is a point (no leaves).  Result is a term query.\n\n     */\n    return new VisitorTemplate(context) {\n      private FixedBitSet results;\n\n      @Override\n      protected void start() {\n        results = new FixedBitSet(maxDoc);\n      }\n\n      @Override\n      protected DocIdSet finish() {\n        return new BitDocIdSet(results);\n      }\n\n      @Override\n      protected boolean visitPrefix(Cell cell) throws IOException {\n        if (cell.getShapeRel() == SpatialRelation.WITHIN || cell.getLevel() == detailLevel) {\n          collectDocs(results);\n          return false;\n        }\n        return true;\n      }\n\n      @Override\n      protected void visitLeaf(Cell cell) throws IOException {\n        collectDocs(results);\n      }\n\n    }.getDocIdSet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ea9249ab9a9f76eb4132ceb4631d15315721f6a","date":1460578553,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/IntersectsPrefixTreeQuery#getDocIdSet(LeafReaderContext).mjava","pathOld":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/IntersectsPrefixTreeQuery#getDocIdSet(LeafReaderContext).mjava","sourceNew":"  @Override\n  protected DocIdSet getDocIdSet(LeafReaderContext context) throws IOException {\n    /* Possible optimizations (in IN ADDITION TO THOSE LISTED IN VISITORTEMPLATE):\n\n    * If docFreq is 1 (or < than some small threshold), then check to see if we've already\n      collected it; if so short-circuit. Don't do this just for point data, as there is\n      no benefit, or only marginal benefit when multi-valued.\n\n    * Point query shape optimization when the only indexed data is a point (no leaves).  Result is a term query.\n\n     */\n    return new VisitorTemplate(context) {\n      private DocIdSetBuilder results;\n\n      @Override\n      protected void start() {\n        results = new DocIdSetBuilder(maxDoc);\n      }\n\n      @Override\n      protected DocIdSet finish() {\n        return results.build();\n      }\n\n      @Override\n      protected boolean visitPrefix(Cell cell) throws IOException {\n        if (cell.getShapeRel() == SpatialRelation.WITHIN || cell.getLevel() == detailLevel) {\n          collectDocs(results);\n          return false;\n        }\n        return true;\n      }\n\n      @Override\n      protected void visitLeaf(Cell cell) throws IOException {\n        collectDocs(results);\n      }\n\n    }.getDocIdSet();\n  }\n\n","sourceOld":"  @Override\n  protected DocIdSet getDocIdSet(LeafReaderContext context) throws IOException {\n    /* Possible optimizations (in IN ADDITION TO THOSE LISTED IN VISITORTEMPLATE):\n\n    * If docFreq is 1 (or < than some small threshold), then check to see if we've already\n      collected it; if so short-circuit. Don't do this just for point data, as there is\n      no benefit, or only marginal benefit when multi-valued.\n\n    * Point query shape optimization when the only indexed data is a point (no leaves).  Result is a term query.\n\n     */\n    return new VisitorTemplate(context) {\n      private FixedBitSet results;\n\n      @Override\n      protected void start() {\n        results = new FixedBitSet(maxDoc);\n      }\n\n      @Override\n      protected DocIdSet finish() {\n        return new BitDocIdSet(results);\n      }\n\n      @Override\n      protected boolean visitPrefix(Cell cell) throws IOException {\n        if (cell.getShapeRel() == SpatialRelation.WITHIN || cell.getLevel() == detailLevel) {\n          collectDocs(results);\n          return false;\n        }\n        return true;\n      }\n\n      @Override\n      protected void visitLeaf(Cell cell) throws IOException {\n        collectDocs(results);\n      }\n\n    }.getDocIdSet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9ee4c03e3ee986704eeeb45c571d001905a6430","date":1462194267,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/IntersectsPrefixTreeQuery#getDocIdSet(LeafReaderContext).mjava","pathOld":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/IntersectsPrefixTreeQuery#getDocIdSet(LeafReaderContext).mjava","sourceNew":"  @Override\n  protected DocIdSet getDocIdSet(LeafReaderContext context) throws IOException {\n    /* Possible optimizations (in IN ADDITION TO THOSE LISTED IN VISITORTEMPLATE):\n\n    * If docFreq is 1 (or < than some small threshold), then check to see if we've already\n      collected it; if so short-circuit. Don't do this just for point data, as there is\n      no benefit, or only marginal benefit when multi-valued.\n\n    * Point query shape optimization when the only indexed data is a point (no leaves).  Result is a term query.\n\n     */\n    return new VisitorTemplate(context) {\n      private DocIdSetBuilder results;\n\n      @Override\n      protected void start() throws IOException {\n        results = new DocIdSetBuilder(maxDoc, terms);\n      }\n\n      @Override\n      protected DocIdSet finish() {\n        return results.build();\n      }\n\n      @Override\n      protected boolean visitPrefix(Cell cell) throws IOException {\n        if (cell.getShapeRel() == SpatialRelation.WITHIN || cell.getLevel() == detailLevel) {\n          collectDocs(results);\n          return false;\n        }\n        return true;\n      }\n\n      @Override\n      protected void visitLeaf(Cell cell) throws IOException {\n        collectDocs(results);\n      }\n\n    }.getDocIdSet();\n  }\n\n","sourceOld":"  @Override\n  protected DocIdSet getDocIdSet(LeafReaderContext context) throws IOException {\n    /* Possible optimizations (in IN ADDITION TO THOSE LISTED IN VISITORTEMPLATE):\n\n    * If docFreq is 1 (or < than some small threshold), then check to see if we've already\n      collected it; if so short-circuit. Don't do this just for point data, as there is\n      no benefit, or only marginal benefit when multi-valued.\n\n    * Point query shape optimization when the only indexed data is a point (no leaves).  Result is a term query.\n\n     */\n    return new VisitorTemplate(context) {\n      private DocIdSetBuilder results;\n\n      @Override\n      protected void start() {\n        results = new DocIdSetBuilder(maxDoc);\n      }\n\n      @Override\n      protected DocIdSet finish() {\n        return results.build();\n      }\n\n      @Override\n      protected boolean visitPrefix(Cell cell) throws IOException {\n        if (cell.getShapeRel() == SpatialRelation.WITHIN || cell.getLevel() == detailLevel) {\n          collectDocs(results);\n          return false;\n        }\n        return true;\n      }\n\n      @Override\n      protected void visitLeaf(Cell cell) throws IOException {\n        collectDocs(results);\n      }\n\n    }.getDocIdSet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30540ec27130887a9372c159e8fe971200f37727","date":1462223109,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/IntersectsPrefixTreeQuery#getDocIdSet(LeafReaderContext).mjava","pathOld":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/IntersectsPrefixTreeQuery#getDocIdSet(LeafReaderContext).mjava","sourceNew":"  @Override\n  protected DocIdSet getDocIdSet(LeafReaderContext context) throws IOException {\n    /* Possible optimizations (in IN ADDITION TO THOSE LISTED IN VISITORTEMPLATE):\n\n    * If docFreq is 1 (or < than some small threshold), then check to see if we've already\n      collected it; if so short-circuit. Don't do this just for point data, as there is\n      no benefit, or only marginal benefit when multi-valued.\n\n    * Point query shape optimization when the only indexed data is a point (no leaves).  Result is a term query.\n\n     */\n    return new VisitorTemplate(context) {\n      private DocIdSetBuilder results;\n\n      @Override\n      protected void start() throws IOException {\n        results = new DocIdSetBuilder(maxDoc, terms);\n      }\n\n      @Override\n      protected DocIdSet finish() {\n        return results.build();\n      }\n\n      @Override\n      protected boolean visitPrefix(Cell cell) throws IOException {\n        if (cell.getShapeRel() == SpatialRelation.WITHIN || cell.getLevel() == detailLevel) {\n          collectDocs(results);\n          return false;\n        }\n        return true;\n      }\n\n      @Override\n      protected void visitLeaf(Cell cell) throws IOException {\n        collectDocs(results);\n      }\n\n    }.getDocIdSet();\n  }\n\n","sourceOld":"  @Override\n  protected DocIdSet getDocIdSet(LeafReaderContext context) throws IOException {\n    /* Possible optimizations (in IN ADDITION TO THOSE LISTED IN VISITORTEMPLATE):\n\n    * If docFreq is 1 (or < than some small threshold), then check to see if we've already\n      collected it; if so short-circuit. Don't do this just for point data, as there is\n      no benefit, or only marginal benefit when multi-valued.\n\n    * Point query shape optimization when the only indexed data is a point (no leaves).  Result is a term query.\n\n     */\n    return new VisitorTemplate(context) {\n      private DocIdSetBuilder results;\n\n      @Override\n      protected void start() {\n        results = new DocIdSetBuilder(maxDoc);\n      }\n\n      @Override\n      protected DocIdSet finish() {\n        return results.build();\n      }\n\n      @Override\n      protected boolean visitPrefix(Cell cell) throws IOException {\n        if (cell.getShapeRel() == SpatialRelation.WITHIN || cell.getLevel() == detailLevel) {\n          collectDocs(results);\n          return false;\n        }\n        return true;\n      }\n\n      @Override\n      protected void visitLeaf(Cell cell) throws IOException {\n        collectDocs(results);\n      }\n\n    }.getDocIdSet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55b50463286869f584cf849d1587a0fcd54d1dfa","date":1462378517,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/IntersectsPrefixTreeQuery#getDocIdSet(LeafReaderContext).mjava","pathOld":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/IntersectsPrefixTreeQuery#getDocIdSet(LeafReaderContext).mjava","sourceNew":"  @Override\n  protected DocIdSet getDocIdSet(LeafReaderContext context) throws IOException {\n    /* Possible optimizations (in IN ADDITION TO THOSE LISTED IN VISITORTEMPLATE):\n\n    * If docFreq is 1 (or < than some small threshold), then check to see if we've already\n      collected it; if so short-circuit. Don't do this just for point data, as there is\n      no benefit, or only marginal benefit when multi-valued.\n\n    * Point query shape optimization when the only indexed data is a point (no leaves).  Result is a term query.\n\n     */\n    return new VisitorTemplate(context) {\n      private DocIdSetBuilder results;\n\n      @Override\n      protected void start() throws IOException {\n        results = new DocIdSetBuilder(maxDoc, terms);\n      }\n\n      @Override\n      protected DocIdSet finish() {\n        return results.build();\n      }\n\n      @Override\n      protected boolean visitPrefix(Cell cell) throws IOException {\n        if (cell.getShapeRel() == SpatialRelation.WITHIN || cell.getLevel() == detailLevel) {\n          collectDocs(results);\n          return false;\n        }\n        return true;\n      }\n\n      @Override\n      protected void visitLeaf(Cell cell) throws IOException {\n        collectDocs(results);\n      }\n\n    }.getDocIdSet();\n  }\n\n","sourceOld":"  @Override\n  protected DocIdSet getDocIdSet(LeafReaderContext context) throws IOException {\n    /* Possible optimizations (in IN ADDITION TO THOSE LISTED IN VISITORTEMPLATE):\n\n    * If docFreq is 1 (or < than some small threshold), then check to see if we've already\n      collected it; if so short-circuit. Don't do this just for point data, as there is\n      no benefit, or only marginal benefit when multi-valued.\n\n    * Point query shape optimization when the only indexed data is a point (no leaves).  Result is a term query.\n\n     */\n    return new VisitorTemplate(context) {\n      private DocIdSetBuilder results;\n\n      @Override\n      protected void start() {\n        results = new DocIdSetBuilder(maxDoc);\n      }\n\n      @Override\n      protected DocIdSet finish() {\n        return results.build();\n      }\n\n      @Override\n      protected boolean visitPrefix(Cell cell) throws IOException {\n        if (cell.getShapeRel() == SpatialRelation.WITHIN || cell.getLevel() == detailLevel) {\n          collectDocs(results);\n          return false;\n        }\n        return true;\n      }\n\n      @Override\n      protected void visitLeaf(Cell cell) throws IOException {\n        collectDocs(results);\n      }\n\n    }.getDocIdSet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"af2638813028b254a88b418ebeafb541afb49653":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","112d77ac8d3e10a362516ad834c9a11d35c94234"],"c9ee4c03e3ee986704eeeb45c571d001905a6430":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a"],"9ea9249ab9a9f76eb4132ceb4631d15315721f6a":["af2638813028b254a88b418ebeafb541afb49653","ebe63dbc2ae3f506a79b831dee10fb781a7599fb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ebe63dbc2ae3f506a79b831dee10fb781a7599fb":["af2638813028b254a88b418ebeafb541afb49653"],"112d77ac8d3e10a362516ad834c9a11d35c94234":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"30540ec27130887a9372c159e8fe971200f37727":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a","c9ee4c03e3ee986704eeeb45c571d001905a6430"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["30540ec27130887a9372c159e8fe971200f37727"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a","30540ec27130887a9372c159e8fe971200f37727"]},"commit2Childs":{"af2638813028b254a88b418ebeafb541afb49653":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a","ebe63dbc2ae3f506a79b831dee10fb781a7599fb"],"c9ee4c03e3ee986704eeeb45c571d001905a6430":["30540ec27130887a9372c159e8fe971200f37727"],"9ea9249ab9a9f76eb4132ceb4631d15315721f6a":["c9ee4c03e3ee986704eeeb45c571d001905a6430","30540ec27130887a9372c159e8fe971200f37727","55b50463286869f584cf849d1587a0fcd54d1dfa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["af2638813028b254a88b418ebeafb541afb49653","112d77ac8d3e10a362516ad834c9a11d35c94234"],"ebe63dbc2ae3f506a79b831dee10fb781a7599fb":["9ea9249ab9a9f76eb4132ceb4631d15315721f6a"],"112d77ac8d3e10a362516ad834c9a11d35c94234":["af2638813028b254a88b418ebeafb541afb49653"],"30540ec27130887a9372c159e8fe971200f37727":["cd5edd1f2b162a5cfa08efd17851a07373a96817","55b50463286869f584cf849d1587a0fcd54d1dfa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"55b50463286869f584cf849d1587a0fcd54d1dfa":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","55b50463286869f584cf849d1587a0fcd54d1dfa"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}