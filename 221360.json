{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Vector#Vector(Vector,double,double,double).mjava","commits":[{"id":"7fe41964e49958f662028ea7ed8c224e0955edae","date":1462534610,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Vector#Vector(Vector,double,double,double).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Construct a vector that is perpendicular to\n   * two other (non-zero) vectors.  If the vectors are parallel,\n   * IllegalArgumentException will be thrown.\n   * Produces a normalized final vector.\n   *\n   * @param A is the first vector\n   * @param BX is the X value of the second \n   * @param BY is the Y value of the second\n   * @param BZ is the Z value of the second\n   */\n  public Vector(final Vector A, final double BX, final double BY, final double BZ) {\n    // x = u2v3 - u3v2\n    // y = u3v1 - u1v3\n    // z = u1v2 - u2v1\n    final double thisX = A.y * BZ - A.z * BY;\n    final double thisY = A.z * BX - A.x * BZ;\n    final double thisZ = A.x * BY - A.y * BX;\n    final double magnitude = magnitude(thisX, thisY, thisZ);\n    if (Math.abs(magnitude) < MINIMUM_RESOLUTION) {\n      throw new IllegalArgumentException(\"Degenerate/parallel vector constructed\");\n    }\n    final double inverseMagnitude = 1.0 / magnitude;\n    this.x = thisX * inverseMagnitude;\n    this.y = thisY * inverseMagnitude;\n    this.z = thisZ * inverseMagnitude;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["9ebbc012fa3cc9cea1b6563bc2d2c57552fb92ff"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","date":1462576651,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Vector#Vector(Vector,double,double,double).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Construct a vector that is perpendicular to\n   * two other (non-zero) vectors.  If the vectors are parallel,\n   * IllegalArgumentException will be thrown.\n   * Produces a normalized final vector.\n   *\n   * @param A is the first vector\n   * @param BX is the X value of the second \n   * @param BY is the Y value of the second\n   * @param BZ is the Z value of the second\n   */\n  public Vector(final Vector A, final double BX, final double BY, final double BZ) {\n    // x = u2v3 - u3v2\n    // y = u3v1 - u1v3\n    // z = u1v2 - u2v1\n    final double thisX = A.y * BZ - A.z * BY;\n    final double thisY = A.z * BX - A.x * BZ;\n    final double thisZ = A.x * BY - A.y * BX;\n    final double magnitude = magnitude(thisX, thisY, thisZ);\n    if (Math.abs(magnitude) < MINIMUM_RESOLUTION) {\n      throw new IllegalArgumentException(\"Degenerate/parallel vector constructed\");\n    }\n    final double inverseMagnitude = 1.0 / magnitude;\n    this.x = thisX * inverseMagnitude;\n    this.y = thisY * inverseMagnitude;\n    this.z = thisZ * inverseMagnitude;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Vector#Vector(Vector,double,double,double).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Construct a vector that is perpendicular to\n   * two other (non-zero) vectors.  If the vectors are parallel,\n   * IllegalArgumentException will be thrown.\n   * Produces a normalized final vector.\n   *\n   * @param A is the first vector\n   * @param BX is the X value of the second \n   * @param BY is the Y value of the second\n   * @param BZ is the Z value of the second\n   */\n  public Vector(final Vector A, final double BX, final double BY, final double BZ) {\n    // x = u2v3 - u3v2\n    // y = u3v1 - u1v3\n    // z = u1v2 - u2v1\n    final double thisX = A.y * BZ - A.z * BY;\n    final double thisY = A.z * BX - A.x * BZ;\n    final double thisZ = A.x * BY - A.y * BX;\n    final double magnitude = magnitude(thisX, thisY, thisZ);\n    if (Math.abs(magnitude) < MINIMUM_RESOLUTION) {\n      throw new IllegalArgumentException(\"Degenerate/parallel vector constructed\");\n    }\n    final double inverseMagnitude = 1.0 / magnitude;\n    this.x = thisX * inverseMagnitude;\n    this.y = thisY * inverseMagnitude;\n    this.z = thisZ * inverseMagnitude;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ebbc012fa3cc9cea1b6563bc2d2c57552fb92ff","date":1516881825,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Vector#Vector(Vector,double,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Vector#Vector(Vector,double,double,double).mjava","sourceNew":"  /**\n   * Construct a vector that is perpendicular to\n   * two other (non-zero) vectors.  If the vectors are parallel,\n   * IllegalArgumentException will be thrown.\n   * Produces a normalized final vector.\n   *\n   * @param A is the first vector\n   * @param BX is the X value of the second \n   * @param BY is the Y value of the second\n   * @param BZ is the Z value of the second\n   */\n  public Vector(final Vector A, final double BX, final double BY, final double BZ) {\n    // We're really looking at two vectors and computing a perpendicular one from that.\n    // We can think of this as having three points -- the origin, and two points that aren't the origin.\n    // Normally, we can compute the perpendicular vector this way:\n    // x = u2v3 - u3v2\n    // y = u3v1 - u1v3\n    // z = u1v2 - u2v1\n    // Sometimes that produces a plane that does not contain the original three points, however, due to\n    // numerical precision issues.  Then we continue making the answer more precise using the\n    // Gram-Schmidt process: https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process\n    \n    // Compute the naive perpendicular\n    final double thisX = A.y * BZ - A.z * BY;\n    final double thisY = A.z * BX - A.x * BZ;\n    final double thisZ = A.x * BY - A.y * BX;\n    \n    final double magnitude = magnitude(thisX, thisY, thisZ);\n    if (magnitude < MINIMUM_RESOLUTION) {\n      throw new IllegalArgumentException(\"Degenerate/parallel vector constructed\");\n    }\n    \n    final double inverseMagnitude = 1.0/magnitude;\n    \n    double normalizeX = thisX * inverseMagnitude;\n    double normalizeY = thisY * inverseMagnitude;\n    double normalizeZ = thisZ * inverseMagnitude;\n    // For a plane to work, the dot product between the normal vector\n    // and the points needs to be less than the minimum resolution.\n    // This is sometimes not true for points that are very close. Therefore\n    // we need to adjust\n    int i = 0;\n    while (true) {\n      final double currentDotProdA = A.x * normalizeX + A.y * normalizeY + A.z * normalizeZ;\n      final double currentDotProdB = BX * normalizeX + BY * normalizeY + BZ * normalizeZ;\n      if (Math.abs(currentDotProdA) < MINIMUM_RESOLUTION && Math.abs(currentDotProdB) < MINIMUM_RESOLUTION) {\n        break;\n      }\n      // Converge on the one that has largest dot product\n      final double currentVectorX;\n      final double currentVectorY;\n      final double currentVectorZ;\n      final double currentDotProd;\n      if (Math.abs(currentDotProdA) > Math.abs(currentDotProdB)) {\n        currentVectorX = A.x;\n        currentVectorY = A.y;\n        currentVectorZ = A.z;\n        currentDotProd = currentDotProdA;\n      } else {\n        currentVectorX = BX;\n        currentVectorY = BY;\n        currentVectorZ = BZ;\n        currentDotProd = currentDotProdB;\n      }\n\n      // Adjust\n      normalizeX = normalizeX - currentDotProd * currentVectorX;\n      normalizeY = normalizeY - currentDotProd * currentVectorY;\n      normalizeZ = normalizeZ - currentDotProd * currentVectorZ;\n      // Normalize\n      final double correctedMagnitude = magnitude(normalizeX, normalizeY, normalizeZ);\n      final double inverseCorrectedMagnitude = 1.0 / correctedMagnitude;\n      normalizeX = normalizeX * inverseCorrectedMagnitude;\n      normalizeY = normalizeY * inverseCorrectedMagnitude;\n      normalizeZ = normalizeZ * inverseCorrectedMagnitude;\n      //This is  probably not needed as the method seems to converge\n      //quite quickly. But it is safer to have a way out.\n      if (i++ > 10) {\n        throw new IllegalArgumentException(\"Plane could not be constructed! Could not find a normal vector.\");\n      }\n    }\n    this.x = normalizeX;\n    this.y = normalizeY;\n    this.z = normalizeZ;\n  }\n\n","sourceOld":"  /**\n   * Construct a vector that is perpendicular to\n   * two other (non-zero) vectors.  If the vectors are parallel,\n   * IllegalArgumentException will be thrown.\n   * Produces a normalized final vector.\n   *\n   * @param A is the first vector\n   * @param BX is the X value of the second \n   * @param BY is the Y value of the second\n   * @param BZ is the Z value of the second\n   */\n  public Vector(final Vector A, final double BX, final double BY, final double BZ) {\n    // x = u2v3 - u3v2\n    // y = u3v1 - u1v3\n    // z = u1v2 - u2v1\n    final double thisX = A.y * BZ - A.z * BY;\n    final double thisY = A.z * BX - A.x * BZ;\n    final double thisZ = A.x * BY - A.y * BX;\n    final double magnitude = magnitude(thisX, thisY, thisZ);\n    if (Math.abs(magnitude) < MINIMUM_RESOLUTION) {\n      throw new IllegalArgumentException(\"Degenerate/parallel vector constructed\");\n    }\n    final double inverseMagnitude = 1.0 / magnitude;\n    this.x = thisX * inverseMagnitude;\n    this.y = thisY * inverseMagnitude;\n    this.z = thisZ * inverseMagnitude;\n  }\n\n","bugFix":["7fe41964e49958f662028ea7ed8c224e0955edae"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6a9e1ce6eb275343c2baab9cbd238d6c3b8068a1","date":1518533584,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Vector#Vector(Vector,double,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Vector#Vector(Vector,double,double,double).mjava","sourceNew":"  /**\n   * Construct a vector that is perpendicular to\n   * two other (non-zero) vectors.  If the vectors are parallel,\n   * IllegalArgumentException will be thrown.\n   * Produces a normalized final vector.\n   *\n   * @param A is the first vector\n   * @param BX is the X value of the second \n   * @param BY is the Y value of the second\n   * @param BZ is the Z value of the second\n   */\n  public Vector(final Vector A, final double BX, final double BY, final double BZ) {\n    // We're really looking at two vectors and computing a perpendicular one from that.\n    this(A.x, A.y, A.z, BX, BY, BZ);\n  }\n\n","sourceOld":"  /**\n   * Construct a vector that is perpendicular to\n   * two other (non-zero) vectors.  If the vectors are parallel,\n   * IllegalArgumentException will be thrown.\n   * Produces a normalized final vector.\n   *\n   * @param A is the first vector\n   * @param BX is the X value of the second \n   * @param BY is the Y value of the second\n   * @param BZ is the Z value of the second\n   */\n  public Vector(final Vector A, final double BX, final double BY, final double BZ) {\n    // We're really looking at two vectors and computing a perpendicular one from that.\n    // We can think of this as having three points -- the origin, and two points that aren't the origin.\n    // Normally, we can compute the perpendicular vector this way:\n    // x = u2v3 - u3v2\n    // y = u3v1 - u1v3\n    // z = u1v2 - u2v1\n    // Sometimes that produces a plane that does not contain the original three points, however, due to\n    // numerical precision issues.  Then we continue making the answer more precise using the\n    // Gram-Schmidt process: https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process\n    \n    // Compute the naive perpendicular\n    final double thisX = A.y * BZ - A.z * BY;\n    final double thisY = A.z * BX - A.x * BZ;\n    final double thisZ = A.x * BY - A.y * BX;\n    \n    final double magnitude = magnitude(thisX, thisY, thisZ);\n    if (magnitude < MINIMUM_RESOLUTION) {\n      throw new IllegalArgumentException(\"Degenerate/parallel vector constructed\");\n    }\n    \n    final double inverseMagnitude = 1.0/magnitude;\n    \n    double normalizeX = thisX * inverseMagnitude;\n    double normalizeY = thisY * inverseMagnitude;\n    double normalizeZ = thisZ * inverseMagnitude;\n    // For a plane to work, the dot product between the normal vector\n    // and the points needs to be less than the minimum resolution.\n    // This is sometimes not true for points that are very close. Therefore\n    // we need to adjust\n    int i = 0;\n    while (true) {\n      final double currentDotProdA = A.x * normalizeX + A.y * normalizeY + A.z * normalizeZ;\n      final double currentDotProdB = BX * normalizeX + BY * normalizeY + BZ * normalizeZ;\n      if (Math.abs(currentDotProdA) < MINIMUM_RESOLUTION && Math.abs(currentDotProdB) < MINIMUM_RESOLUTION) {\n        break;\n      }\n      // Converge on the one that has largest dot product\n      final double currentVectorX;\n      final double currentVectorY;\n      final double currentVectorZ;\n      final double currentDotProd;\n      if (Math.abs(currentDotProdA) > Math.abs(currentDotProdB)) {\n        currentVectorX = A.x;\n        currentVectorY = A.y;\n        currentVectorZ = A.z;\n        currentDotProd = currentDotProdA;\n      } else {\n        currentVectorX = BX;\n        currentVectorY = BY;\n        currentVectorZ = BZ;\n        currentDotProd = currentDotProdB;\n      }\n\n      // Adjust\n      normalizeX = normalizeX - currentDotProd * currentVectorX;\n      normalizeY = normalizeY - currentDotProd * currentVectorY;\n      normalizeZ = normalizeZ - currentDotProd * currentVectorZ;\n      // Normalize\n      final double correctedMagnitude = magnitude(normalizeX, normalizeY, normalizeZ);\n      final double inverseCorrectedMagnitude = 1.0 / correctedMagnitude;\n      normalizeX = normalizeX * inverseCorrectedMagnitude;\n      normalizeY = normalizeY * inverseCorrectedMagnitude;\n      normalizeZ = normalizeZ * inverseCorrectedMagnitude;\n      //This is  probably not needed as the method seems to converge\n      //quite quickly. But it is safer to have a way out.\n      if (i++ > 10) {\n        throw new IllegalArgumentException(\"Plane could not be constructed! Could not find a normal vector.\");\n      }\n    }\n    this.x = normalizeX;\n    this.y = normalizeY;\n    this.z = normalizeZ;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9ebbc012fa3cc9cea1b6563bc2d2c57552fb92ff":["7fe41964e49958f662028ea7ed8c224e0955edae"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7fe41964e49958f662028ea7ed8c224e0955edae"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6a9e1ce6eb275343c2baab9cbd238d6c3b8068a1":["9ebbc012fa3cc9cea1b6563bc2d2c57552fb92ff"],"7fe41964e49958f662028ea7ed8c224e0955edae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7fe41964e49958f662028ea7ed8c224e0955edae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6a9e1ce6eb275343c2baab9cbd238d6c3b8068a1"]},"commit2Childs":{"9ebbc012fa3cc9cea1b6563bc2d2c57552fb92ff":["6a9e1ce6eb275343c2baab9cbd238d6c3b8068a1"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","7fe41964e49958f662028ea7ed8c224e0955edae","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"6a9e1ce6eb275343c2baab9cbd238d6c3b8068a1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7fe41964e49958f662028ea7ed8c224e0955edae":["9ebbc012fa3cc9cea1b6563bc2d2c57552fb92ff","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}