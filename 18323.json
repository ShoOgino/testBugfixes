{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = !suppressExceptions;\n    \n    for (int i = 0; i < numSegments; i++) {\n      if (merge.readers.get(i) != null) {\n        try {\n          readerPool.release(merge.readers.get(i), drop);\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n    \n    // If any error occured, throw it.\n    if (!suppressExceptions && th != null) {\n      if (th instanceof IOException) throw (IOException) th;\n      if (th instanceof RuntimeException) throw (RuntimeException) th;\n      if (th instanceof Error) throw (Error) th;\n      throw new RuntimeException(th);\n    }\n  }\n\n","sourceOld":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = !suppressExceptions;\n    \n    for (int i = 0; i < numSegments; i++) {\n      if (merge.readers.get(i) != null) {\n        try {\n          readerPool.release(merge.readers.get(i), drop);\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n    \n    // If any error occured, throw it.\n    if (!suppressExceptions && th != null) {\n      if (th instanceof IOException) throw (IOException) th;\n      if (th instanceof RuntimeException) throw (RuntimeException) th;\n      if (th instanceof Error) throw (Error) th;\n      throw new RuntimeException(th);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae695f21c50b03702b5d0fa2543d5af844bb7cd3","date":1331554994,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = !suppressExceptions;\n    \n    for (int i = 0; i < numSegments; i++) {\n      final SegmentReader sr = merge.readers.get(i);\n      if (sr != null) {\n        try {\n          final ReadersAndLiveDocs rld = readerPool.get(sr.getSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          }\n          rld.release(sr);\n          readerPool.release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n    \n    // If any error occured, throw it.\n    if (!suppressExceptions && th != null) {\n      if (th instanceof IOException) throw (IOException) th;\n      if (th instanceof RuntimeException) throw (RuntimeException) th;\n      if (th instanceof Error) throw (Error) th;\n      throw new RuntimeException(th);\n    }\n  }\n\n","sourceOld":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = !suppressExceptions;\n    \n    for (int i = 0; i < numSegments; i++) {\n      if (merge.readers.get(i) != null) {\n        try {\n          readerPool.release(merge.readers.get(i), drop);\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n    \n    // If any error occured, throw it.\n    if (!suppressExceptions && th != null) {\n      if (th instanceof IOException) throw (IOException) th;\n      if (th instanceof RuntimeException) throw (RuntimeException) th;\n      if (th instanceof Error) throw (Error) th;\n      throw new RuntimeException(th);\n    }\n  }\n\n","bugFix":["9ce667c6d3400b22523701c549c0d35e26da8b46","e98b72bcae3162dc10643ec8f09ce31fc3fb902b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = !suppressExceptions;\n    \n    for (int i = 0; i < numSegments; i++) {\n      final SegmentReader sr = merge.readers.get(i);\n      if (sr != null) {\n        try {\n          final ReadersAndLiveDocs rld = readerPool.get(sr.getSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          }\n          rld.release(sr);\n          readerPool.release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n    \n    // If any error occured, throw it.\n    if (!suppressExceptions && th != null) {\n      if (th instanceof IOException) throw (IOException) th;\n      if (th instanceof RuntimeException) throw (RuntimeException) th;\n      if (th instanceof Error) throw (Error) th;\n      throw new RuntimeException(th);\n    }\n  }\n\n","sourceOld":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = !suppressExceptions;\n    \n    for (int i = 0; i < numSegments; i++) {\n      if (merge.readers.get(i) != null) {\n        try {\n          readerPool.release(merge.readers.get(i), drop);\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n    \n    // If any error occured, throw it.\n    if (!suppressExceptions && th != null) {\n      if (th instanceof IOException) throw (IOException) th;\n      if (th instanceof RuntimeException) throw (RuntimeException) th;\n      if (th instanceof Error) throw (Error) th;\n      throw new RuntimeException(th);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e072d0b1fc19e0533d8ce432eed245196bca6fde","date":1379265112,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = !suppressExceptions;\n    \n    for (int i = 0; i < numSegments; i++) {\n      final SegmentReader sr = merge.readers.get(i);\n      if (sr != null) {\n        try {\n          final ReadersAndLiveDocs rld = readerPool.get(sr.getSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          }\n          rld.setMerging(false);\n          rld.release(sr);\n          readerPool.release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n    \n    // If any error occured, throw it.\n    if (!suppressExceptions && th != null) {\n      if (th instanceof IOException) throw (IOException) th;\n      if (th instanceof RuntimeException) throw (RuntimeException) th;\n      if (th instanceof Error) throw (Error) th;\n      throw new RuntimeException(th);\n    }\n  }\n\n","sourceOld":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = !suppressExceptions;\n    \n    for (int i = 0; i < numSegments; i++) {\n      final SegmentReader sr = merge.readers.get(i);\n      if (sr != null) {\n        try {\n          final ReadersAndLiveDocs rld = readerPool.get(sr.getSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          }\n          rld.release(sr);\n          readerPool.release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n    \n    // If any error occured, throw it.\n    if (!suppressExceptions && th != null) {\n      if (th instanceof IOException) throw (IOException) th;\n      if (th instanceof RuntimeException) throw (RuntimeException) th;\n      if (th instanceof Error) throw (Error) th;\n      throw new RuntimeException(th);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"75e4e08ceec867127dcd9913a5ebbc46cf85a28d","date":1379651991,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = !suppressExceptions;\n    \n    for (int i = 0; i < numSegments; i++) {\n      final SegmentReader sr = merge.readers.get(i);\n      if (sr != null) {\n        try {\n          final ReadersAndLiveDocs rld = readerPool.get(sr.getSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          } else {\n            rld.dropMergingUpdates();\n          }\n          rld.release(sr);\n          readerPool.release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n    \n    // If any error occured, throw it.\n    if (!suppressExceptions && th != null) {\n      if (th instanceof IOException) throw (IOException) th;\n      if (th instanceof RuntimeException) throw (RuntimeException) th;\n      if (th instanceof Error) throw (Error) th;\n      throw new RuntimeException(th);\n    }\n  }\n\n","sourceOld":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = !suppressExceptions;\n    \n    for (int i = 0; i < numSegments; i++) {\n      final SegmentReader sr = merge.readers.get(i);\n      if (sr != null) {\n        try {\n          final ReadersAndLiveDocs rld = readerPool.get(sr.getSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          }\n          rld.setMerging(false);\n          rld.release(sr);\n          readerPool.release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n    \n    // If any error occured, throw it.\n    if (!suppressExceptions && th != null) {\n      if (th instanceof IOException) throw (IOException) th;\n      if (th instanceof RuntimeException) throw (RuntimeException) th;\n      if (th instanceof Error) throw (Error) th;\n      throw new RuntimeException(th);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8da3c22a3b1a00ae6e2664f3ac0d82cfa3a8f666","date":1381263930,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = !suppressExceptions;\n    \n    for (int i = 0; i < numSegments; i++) {\n      final SegmentReader sr = merge.readers.get(i);\n      if (sr != null) {\n        try {\n          final ReadersAndLiveDocs rld = readerPool.get(sr.getSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          } else {\n            rld.dropMergingUpdates();\n          }\n          rld.release(sr);\n          readerPool.release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n    \n    // If any error occured, throw it.\n    if (!suppressExceptions) {\n      IOUtils.reThrow(th);\n    }\n  }\n\n","sourceOld":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = !suppressExceptions;\n    \n    for (int i = 0; i < numSegments; i++) {\n      final SegmentReader sr = merge.readers.get(i);\n      if (sr != null) {\n        try {\n          final ReadersAndLiveDocs rld = readerPool.get(sr.getSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          } else {\n            rld.dropMergingUpdates();\n          }\n          rld.release(sr);\n          readerPool.release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n    \n    // If any error occured, throw it.\n    if (!suppressExceptions && th != null) {\n      if (th instanceof IOException) throw (IOException) th;\n      if (th instanceof RuntimeException) throw (RuntimeException) th;\n      if (th instanceof Error) throw (Error) th;\n      throw new RuntimeException(th);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","date":1383367127,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = !suppressExceptions;\n    \n    for (int i = 0; i < numSegments; i++) {\n      final SegmentReader sr = merge.readers.get(i);\n      if (sr != null) {\n        try {\n          final ReadersAndUpdates rld = readerPool.get(sr.getSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          } else {\n            rld.dropMergingUpdates();\n          }\n          rld.release(sr);\n          readerPool.release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n    \n    // If any error occured, throw it.\n    if (!suppressExceptions) {\n      IOUtils.reThrow(th);\n    }\n  }\n\n","sourceOld":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = !suppressExceptions;\n    \n    for (int i = 0; i < numSegments; i++) {\n      final SegmentReader sr = merge.readers.get(i);\n      if (sr != null) {\n        try {\n          final ReadersAndLiveDocs rld = readerPool.get(sr.getSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          } else {\n            rld.dropMergingUpdates();\n          }\n          rld.release(sr);\n          readerPool.release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n    \n    // If any error occured, throw it.\n    if (!suppressExceptions) {\n      IOUtils.reThrow(th);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d9aa91d3fdd25528bac3b2e6115d54fc2f28753","date":1416999434,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = !suppressExceptions;\n    \n    for (int i = 0; i < numSegments; i++) {\n      final SegmentReader sr = merge.readers.get(i);\n      if (sr != null) {\n        try {\n          final ReadersAndUpdates rld = readerPool.get(sr.getSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          } else {\n            rld.dropMergingUpdates();\n          }\n          rld.release(sr);\n          readerPool.release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n\n    try {\n      merge.mergeFinished();\n    } catch (Throwable t) {\n      if (th == null) {\n        th = t;\n      }\n    }\n    \n    // If any error occured, throw it.\n    if (!suppressExceptions) {\n      IOUtils.reThrow(th);\n    }\n  }\n\n","sourceOld":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = !suppressExceptions;\n    \n    for (int i = 0; i < numSegments; i++) {\n      final SegmentReader sr = merge.readers.get(i);\n      if (sr != null) {\n        try {\n          final ReadersAndUpdates rld = readerPool.get(sr.getSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          } else {\n            rld.dropMergingUpdates();\n          }\n          rld.release(sr);\n          readerPool.release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n    \n    // If any error occured, throw it.\n    if (!suppressExceptions) {\n      IOUtils.reThrow(th);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"320afd0985635623cf748b68038f69c6063e3069","date":1490437289,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = !suppressExceptions;\n    \n    for (int i = 0; i < numSegments; i++) {\n      final SegmentReader sr = merge.readers.get(i);\n      if (sr != null) {\n        try {\n          final ReadersAndUpdates rld = readerPool.get(sr.getSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          } else {\n            rld.dropMergingUpdates();\n          }\n          rld.release(sr);\n          readerPool.release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n\n    try {\n      merge.mergeFinished();\n    } catch (Throwable t) {\n      if (th == null) {\n        th = t;\n      }\n    }\n    \n    // If any error occurred, throw it.\n    if (!suppressExceptions) {\n      IOUtils.reThrow(th);\n    }\n  }\n\n","sourceOld":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = !suppressExceptions;\n    \n    for (int i = 0; i < numSegments; i++) {\n      final SegmentReader sr = merge.readers.get(i);\n      if (sr != null) {\n        try {\n          final ReadersAndUpdates rld = readerPool.get(sr.getSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          } else {\n            rld.dropMergingUpdates();\n          }\n          rld.release(sr);\n          readerPool.release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n\n    try {\n      merge.mergeFinished();\n    } catch (Throwable t) {\n      if (th == null) {\n        th = t;\n      }\n    }\n    \n    // If any error occured, throw it.\n    if (!suppressExceptions) {\n      IOUtils.reThrow(th);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"48dad0bd6c76bd5f434a61222f7bf3e256cd2c2e","date":1490594651,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = !suppressExceptions;\n    \n    for (int i = 0; i < numSegments; i++) {\n      final SegmentReader sr = merge.readers.get(i);\n      if (sr != null) {\n        try {\n          final ReadersAndUpdates rld = readerPool.get(sr.getSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          } else {\n            rld.dropMergingUpdates();\n          }\n          rld.release(sr);\n          readerPool.release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n\n    try {\n      merge.mergeFinished();\n    } catch (Throwable t) {\n      if (th == null) {\n        th = t;\n      }\n    }\n    \n    // If any error occurred, throw it.\n    if (!suppressExceptions) {\n      IOUtils.reThrow(th);\n    }\n  }\n\n","sourceOld":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = !suppressExceptions;\n    \n    for (int i = 0; i < numSegments; i++) {\n      final SegmentReader sr = merge.readers.get(i);\n      if (sr != null) {\n        try {\n          final ReadersAndUpdates rld = readerPool.get(sr.getSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          } else {\n            rld.dropMergingUpdates();\n          }\n          rld.release(sr);\n          readerPool.release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n\n    try {\n      merge.mergeFinished();\n    } catch (Throwable t) {\n      if (th == null) {\n        th = t;\n      }\n    }\n    \n    // If any error occured, throw it.\n    if (!suppressExceptions) {\n      IOUtils.reThrow(th);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"97fc96e6cc460e0ec1fb904a9c7ecd80680780c2","date":1493374641,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = !suppressExceptions;\n    \n    for (int i = 0; i < numSegments; i++) {\n      final SegmentReader sr = merge.readers.get(i);\n      if (sr != null) {\n        try {\n          final ReadersAndUpdates rld = readerPool.get(sr.getSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          } else {\n            rld.dropMergingUpdates();\n          }\n          rld.release(sr);\n          readerPool.release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n\n    try {\n      merge.mergeFinished();\n    } catch (Throwable t) {\n      if (th == null) {\n        th = t;\n      }\n    }\n    \n    // If any error occurred, throw it.\n    if (!suppressExceptions && th != null) {\n      throw IOUtils.rethrowAlways(th);\n    }\n  }\n\n","sourceOld":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = !suppressExceptions;\n    \n    for (int i = 0; i < numSegments; i++) {\n      final SegmentReader sr = merge.readers.get(i);\n      if (sr != null) {\n        try {\n          final ReadersAndUpdates rld = readerPool.get(sr.getSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          } else {\n            rld.dropMergingUpdates();\n          }\n          rld.release(sr);\n          readerPool.release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n\n    try {\n      merge.mergeFinished();\n    } catch (Throwable t) {\n      if (th == null) {\n        th = t;\n      }\n    }\n    \n    // If any error occurred, throw it.\n    if (!suppressExceptions) {\n      IOUtils.reThrow(th);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = !suppressExceptions;\n    \n    for (int i = 0; i < numSegments; i++) {\n      final SegmentReader sr = merge.readers.get(i);\n      if (sr != null) {\n        try {\n          final ReadersAndUpdates rld = readerPool.get(sr.getSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          } else {\n            rld.dropMergingUpdates();\n          }\n          rld.release(sr);\n          readerPool.release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n\n    try {\n      merge.mergeFinished();\n    } catch (Throwable t) {\n      if (th == null) {\n        th = t;\n      }\n    }\n    \n    // If any error occurred, throw it.\n    if (!suppressExceptions && th != null) {\n      throw IOUtils.rethrowAlways(th);\n    }\n  }\n\n","sourceOld":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = !suppressExceptions;\n    \n    for (int i = 0; i < numSegments; i++) {\n      final SegmentReader sr = merge.readers.get(i);\n      if (sr != null) {\n        try {\n          final ReadersAndUpdates rld = readerPool.get(sr.getSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          } else {\n            rld.dropMergingUpdates();\n          }\n          rld.release(sr);\n          readerPool.release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n\n    try {\n      merge.mergeFinished();\n    } catch (Throwable t) {\n      if (th == null) {\n        th = t;\n      }\n    }\n    \n    // If any error occurred, throw it.\n    if (!suppressExceptions) {\n      IOUtils.reThrow(th);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4363cd33f6eff7fb4753574a441e2d18c1022a4","date":1498067235,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = suppressExceptions == false;\n    \n    for (int i = 0; i < numSegments; i++) {\n      final SegmentReader sr = merge.readers.get(i);\n      if (sr != null) {\n        try {\n          final ReadersAndUpdates rld = readerPool.get(sr.getSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          } else {\n            rld.dropMergingUpdates();\n          }\n          rld.release(sr);\n          readerPool.release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n\n    try {\n      merge.mergeFinished();\n    } catch (Throwable t) {\n      if (th == null) {\n        th = t;\n      }\n    }\n    \n    // If any error occurred, throw it.\n    if (!suppressExceptions && th != null) {\n      throw IOUtils.rethrowAlways(th);\n    }\n  }\n\n","sourceOld":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = !suppressExceptions;\n    \n    for (int i = 0; i < numSegments; i++) {\n      final SegmentReader sr = merge.readers.get(i);\n      if (sr != null) {\n        try {\n          final ReadersAndUpdates rld = readerPool.get(sr.getSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          } else {\n            rld.dropMergingUpdates();\n          }\n          rld.release(sr);\n          readerPool.release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n\n    try {\n      merge.mergeFinished();\n    } catch (Throwable t) {\n      if (th == null) {\n        th = t;\n      }\n    }\n    \n    // If any error occurred, throw it.\n    if (!suppressExceptions && th != null) {\n      throw IOUtils.rethrowAlways(th);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = suppressExceptions == false;\n    \n    for (int i = 0; i < numSegments; i++) {\n      final SegmentReader sr = merge.readers.get(i);\n      if (sr != null) {\n        try {\n          final ReadersAndUpdates rld = readerPool.get(sr.getSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          } else {\n            rld.dropMergingUpdates();\n          }\n          rld.release(sr);\n          readerPool.release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n\n    try {\n      merge.mergeFinished();\n    } catch (Throwable t) {\n      if (th == null) {\n        th = t;\n      }\n    }\n    \n    // If any error occurred, throw it.\n    if (!suppressExceptions && th != null) {\n      throw IOUtils.rethrowAlways(th);\n    }\n  }\n\n","sourceOld":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = !suppressExceptions;\n    \n    for (int i = 0; i < numSegments; i++) {\n      final SegmentReader sr = merge.readers.get(i);\n      if (sr != null) {\n        try {\n          final ReadersAndUpdates rld = readerPool.get(sr.getSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          } else {\n            rld.dropMergingUpdates();\n          }\n          rld.release(sr);\n          readerPool.release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n\n    try {\n      merge.mergeFinished();\n    } catch (Throwable t) {\n      if (th == null) {\n        th = t;\n      }\n    }\n    \n    // If any error occurred, throw it.\n    if (!suppressExceptions && th != null) {\n      throw IOUtils.rethrowAlways(th);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = suppressExceptions == false;\n    \n    for (int i = 0; i < numSegments; i++) {\n      final SegmentReader sr = merge.readers.get(i);\n      if (sr != null) {\n        try {\n          final ReadersAndUpdates rld = readerPool.get(sr.getSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          } else {\n            rld.dropMergingUpdates();\n          }\n          rld.release(sr);\n          readerPool.release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n\n    try {\n      merge.mergeFinished();\n    } catch (Throwable t) {\n      if (th == null) {\n        th = t;\n      }\n    }\n    \n    // If any error occurred, throw it.\n    if (!suppressExceptions && th != null) {\n      throw IOUtils.rethrowAlways(th);\n    }\n  }\n\n","sourceOld":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = !suppressExceptions;\n    \n    for (int i = 0; i < numSegments; i++) {\n      final SegmentReader sr = merge.readers.get(i);\n      if (sr != null) {\n        try {\n          final ReadersAndUpdates rld = readerPool.get(sr.getSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          } else {\n            rld.dropMergingUpdates();\n          }\n          rld.release(sr);\n          readerPool.release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n\n    try {\n      merge.mergeFinished();\n    } catch (Throwable t) {\n      if (th == null) {\n        th = t;\n      }\n    }\n    \n    // If any error occurred, throw it.\n    if (!suppressExceptions && th != null) {\n      throw IOUtils.rethrowAlways(th);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af02a5a3ff2c1e52a02c0f07ff02c7197e43e59c","date":1521393811,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = suppressExceptions == false;\n    \n    for (int i = 0; i < numSegments; i++) {\n      final SegmentReader sr = merge.readers.get(i);\n      if (sr != null) {\n        try {\n          final ReadersAndUpdates rld = readerPool.get(sr.getSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          } else {\n            rld.dropMergingUpdates();\n          }\n          rld.release(sr);\n          readerPool.release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        } catch (Throwable t) {\n          th = IOUtils.useOrSuppress(th, t);\n        }\n        merge.readers.set(i, null);\n      }\n    }\n\n    try {\n      merge.mergeFinished();\n    } catch (Throwable t) {\n      th = IOUtils.useOrSuppress(th, t);\n    }\n    \n    // If any error occurred, throw it.\n    if (!suppressExceptions && th != null) {\n      throw IOUtils.rethrowAlways(th);\n    }\n  }\n\n","sourceOld":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = suppressExceptions == false;\n    \n    for (int i = 0; i < numSegments; i++) {\n      final SegmentReader sr = merge.readers.get(i);\n      if (sr != null) {\n        try {\n          final ReadersAndUpdates rld = readerPool.get(sr.getSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          } else {\n            rld.dropMergingUpdates();\n          }\n          rld.release(sr);\n          readerPool.release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n\n    try {\n      merge.mergeFinished();\n    } catch (Throwable t) {\n      if (th == null) {\n        th = t;\n      }\n    }\n    \n    // If any error occurred, throw it.\n    if (!suppressExceptions && th != null) {\n      throw IOUtils.rethrowAlways(th);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"203e3fcf513c02ee2c07015f2ce277e26dc60907","date":1521404157,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = suppressExceptions == false;\n    \n    for (int i = 0; i < numSegments; i++) {\n      final SegmentReader sr = merge.readers.get(i);\n      if (sr != null) {\n        try {\n          final ReadersAndUpdates rld = readerPool.get(sr.getSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          } else {\n            rld.dropMergingUpdates();\n          }\n          rld.release(sr);\n          readerPool.release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        } catch (Throwable t) {\n          th = IOUtils.useOrSuppress(th, t);\n        }\n        merge.readers.set(i, null);\n      }\n    }\n\n    try {\n      merge.mergeFinished();\n    } catch (Throwable t) {\n      th = IOUtils.useOrSuppress(th, t);\n    }\n    \n    // If any error occurred, throw it.\n    if (!suppressExceptions && th != null) {\n      throw IOUtils.rethrowAlways(th);\n    }\n  }\n\n","sourceOld":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = suppressExceptions == false;\n    \n    for (int i = 0; i < numSegments; i++) {\n      final SegmentReader sr = merge.readers.get(i);\n      if (sr != null) {\n        try {\n          final ReadersAndUpdates rld = readerPool.get(sr.getSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          } else {\n            rld.dropMergingUpdates();\n          }\n          rld.release(sr);\n          readerPool.release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        } catch (Throwable t) {\n          if (th == null) {\n            th = t;\n          }\n        }\n        merge.readers.set(i, null);\n      }\n    }\n\n    try {\n      merge.mergeFinished();\n    } catch (Throwable t) {\n      if (th == null) {\n        th = t;\n      }\n    }\n    \n    // If any error occurred, throw it.\n    if (!suppressExceptions && th != null) {\n      throw IOUtils.rethrowAlways(th);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14d66d86a8b184a86bcaebcf6e15fcef486e0876","date":1521539412,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  @SuppressWarnings(\"try\")\n  private synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final boolean drop = suppressExceptions == false;\n    try (Closeable finalizer = merge::mergeFinished) {\n      IOUtils.applyToAll(merge.readers, sr -> {\n        final ReadersAndUpdates rld = readerPool.get(sr.getSegmentInfo(), false);\n        // We still hold a ref so it should not have been removed:\n        assert rld != null;\n        if (drop) {\n          rld.dropChanges();\n        } else {\n          rld.dropMergingUpdates();\n        }\n        rld.release(sr);\n        readerPool.release(rld);\n        if (drop) {\n          readerPool.drop(rld.info);\n        }\n      });\n    } finally {\n      Collections.fill(merge.readers, null);\n    }\n  }\n\n","sourceOld":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = suppressExceptions == false;\n    \n    for (int i = 0; i < numSegments; i++) {\n      final SegmentReader sr = merge.readers.get(i);\n      if (sr != null) {\n        try {\n          final ReadersAndUpdates rld = readerPool.get(sr.getSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          } else {\n            rld.dropMergingUpdates();\n          }\n          rld.release(sr);\n          readerPool.release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        } catch (Throwable t) {\n          th = IOUtils.useOrSuppress(th, t);\n        }\n        merge.readers.set(i, null);\n      }\n    }\n\n    try {\n      merge.mergeFinished();\n    } catch (Throwable t) {\n      th = IOUtils.useOrSuppress(th, t);\n    }\n    \n    // If any error occurred, throw it.\n    if (!suppressExceptions && th != null) {\n      throw IOUtils.rethrowAlways(th);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43","date":1521731438,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  @SuppressWarnings(\"try\")\n  private synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final boolean drop = suppressExceptions == false;\n    try (Closeable finalizer = merge::mergeFinished) {\n      IOUtils.applyToAll(merge.readers, sr -> {\n        final ReadersAndUpdates rld = readerPool.get(sr.getSegmentInfo(), false);\n        // We still hold a ref so it should not have been removed:\n        assert rld != null;\n        if (drop) {\n          rld.dropChanges();\n        } else {\n          rld.dropMergingUpdates();\n        }\n        rld.release(sr);\n        readerPool.release(rld);\n        if (drop) {\n          readerPool.drop(rld.info);\n        }\n      });\n    } finally {\n      Collections.fill(merge.readers, null);\n    }\n  }\n\n","sourceOld":"  private final synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final int numSegments = merge.readers.size();\n    Throwable th = null;\n\n    boolean drop = suppressExceptions == false;\n    \n    for (int i = 0; i < numSegments; i++) {\n      final SegmentReader sr = merge.readers.get(i);\n      if (sr != null) {\n        try {\n          final ReadersAndUpdates rld = readerPool.get(sr.getSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          } else {\n            rld.dropMergingUpdates();\n          }\n          rld.release(sr);\n          readerPool.release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        } catch (Throwable t) {\n          th = IOUtils.useOrSuppress(th, t);\n        }\n        merge.readers.set(i, null);\n      }\n    }\n\n    try {\n      merge.mergeFinished();\n    } catch (Throwable t) {\n      th = IOUtils.useOrSuppress(th, t);\n    }\n    \n    // If any error occurred, throw it.\n    if (!suppressExceptions && th != null) {\n      throw IOUtils.rethrowAlways(th);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1926100d9b67becc9701c54266fee3ba7878a5f0","date":1524472150,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  @SuppressWarnings(\"try\")\n  private synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final boolean drop = suppressExceptions == false;\n    try (Closeable finalizer = merge::mergeFinished) {\n      IOUtils.applyToAll(merge.readers, sr -> {\n        final ReadersAndUpdates rld = getPooledInstance(sr.getSegmentInfo(), false);\n        // We still hold a ref so it should not have been removed:\n        assert rld != null;\n        if (drop) {\n          rld.dropChanges();\n        } else {\n          rld.dropMergingUpdates();\n        }\n        rld.release(sr);\n        release(rld);\n        if (drop) {\n          readerPool.drop(rld.info);\n        }\n      });\n    } finally {\n      Collections.fill(merge.readers, null);\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"try\")\n  private synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final boolean drop = suppressExceptions == false;\n    try (Closeable finalizer = merge::mergeFinished) {\n      IOUtils.applyToAll(merge.readers, sr -> {\n        final ReadersAndUpdates rld = readerPool.get(sr.getSegmentInfo(), false);\n        // We still hold a ref so it should not have been removed:\n        assert rld != null;\n        if (drop) {\n          rld.dropChanges();\n        } else {\n          rld.dropMergingUpdates();\n        }\n        rld.release(sr);\n        readerPool.release(rld);\n        if (drop) {\n          readerPool.drop(rld.info);\n        }\n      });\n    } finally {\n      Collections.fill(merge.readers, null);\n    }\n  }\n\n","bugFix":null,"bugIntro":["4987206dabc9f3576bb1df72e987094a7dad6e4f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4987206dabc9f3576bb1df72e987094a7dad6e4f","date":1527510516,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  @SuppressWarnings(\"try\")\n  private synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final boolean drop = suppressExceptions == false;\n    try (Closeable finalizer = merge::mergeFinished) {\n      IOUtils.applyToAll(merge.readers, sr -> {\n        final ReadersAndUpdates rld = getPooledInstance(sr.getOriginalSegmentInfo(), false);\n        // We still hold a ref so it should not have been removed:\n        assert rld != null;\n        if (drop) {\n          rld.dropChanges();\n        } else {\n          rld.dropMergingUpdates();\n        }\n        rld.release(sr);\n        release(rld);\n        if (drop) {\n          readerPool.drop(rld.info);\n        }\n      });\n    } finally {\n      Collections.fill(merge.readers, null);\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"try\")\n  private synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final boolean drop = suppressExceptions == false;\n    try (Closeable finalizer = merge::mergeFinished) {\n      IOUtils.applyToAll(merge.readers, sr -> {\n        final ReadersAndUpdates rld = getPooledInstance(sr.getSegmentInfo(), false);\n        // We still hold a ref so it should not have been removed:\n        assert rld != null;\n        if (drop) {\n          rld.dropChanges();\n        } else {\n          rld.dropMergingUpdates();\n        }\n        rld.release(sr);\n        release(rld);\n        if (drop) {\n          readerPool.drop(rld.info);\n        }\n      });\n    } finally {\n      Collections.fill(merge.readers, null);\n    }\n  }\n\n","bugFix":["1926100d9b67becc9701c54266fee3ba7878a5f0"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af4f318fc7955d8e4e40cdf4a8a93931004fe7c0","date":1592426892,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  @SuppressWarnings(\"try\")\n  private synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final boolean drop = suppressExceptions == false;\n    try (Closeable finalizer = () -> merge.mergeFinished(suppressExceptions == false)) {\n      IOUtils.applyToAll(merge.readers, sr -> {\n        final ReadersAndUpdates rld = getPooledInstance(sr.getOriginalSegmentInfo(), false);\n        // We still hold a ref so it should not have been removed:\n        assert rld != null;\n        if (drop) {\n          rld.dropChanges();\n        } else {\n          rld.dropMergingUpdates();\n        }\n        rld.release(sr);\n        release(rld);\n        if (drop) {\n          readerPool.drop(rld.info);\n        }\n      });\n    } finally {\n      Collections.fill(merge.readers, null);\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"try\")\n  private synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final boolean drop = suppressExceptions == false;\n    try (Closeable finalizer = merge::mergeFinished) {\n      IOUtils.applyToAll(merge.readers, sr -> {\n        final ReadersAndUpdates rld = getPooledInstance(sr.getOriginalSegmentInfo(), false);\n        // We still hold a ref so it should not have been removed:\n        assert rld != null;\n        if (drop) {\n          rld.dropChanges();\n        } else {\n          rld.dropMergingUpdates();\n        }\n        rld.release(sr);\n        release(rld);\n        if (drop) {\n          readerPool.drop(rld.info);\n        }\n      });\n    } finally {\n      Collections.fill(merge.readers, null);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a7869a97a6b91c66a9bd3519cd50583afb8cd6f","date":1593026929,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":"  @SuppressWarnings(\"try\")\n  private synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    if (merge.hasFinished() == false) {\n      final boolean drop = suppressExceptions == false;\n      try (Closeable finalizer = () -> merge.mergeFinished(suppressExceptions == false)) {\n        IOUtils.applyToAll(merge.readers, sr -> {\n          final ReadersAndUpdates rld = getPooledInstance(sr.getOriginalSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          } else {\n            rld.dropMergingUpdates();\n          }\n          rld.release(sr);\n          release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        });\n      } finally {\n        Collections.fill(merge.readers, null);\n      }\n    } else {\n      assert merge.readers.stream().filter(Objects::nonNull).count() == 0 : \"we are done but still have readers: \" + merge.readers;\n      assert suppressExceptions : \"can't be done and not suppressing exceptions\";\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"try\")\n  private synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    final boolean drop = suppressExceptions == false;\n    try (Closeable finalizer = () -> merge.mergeFinished(suppressExceptions == false)) {\n      IOUtils.applyToAll(merge.readers, sr -> {\n        final ReadersAndUpdates rld = getPooledInstance(sr.getOriginalSegmentInfo(), false);\n        // We still hold a ref so it should not have been removed:\n        assert rld != null;\n        if (drop) {\n          rld.dropChanges();\n        } else {\n          rld.dropMergingUpdates();\n        }\n        rld.release(sr);\n        release(rld);\n        if (drop) {\n          readerPool.drop(rld.info);\n        }\n      });\n    } finally {\n      Collections.fill(merge.readers, null);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c2a23476693f2bd9a4b44cc3187c429a2e21dac2","date":1593289545,"type":4,"author":"Simon Willnauer","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#closeMergeReaders(MergePolicy.OneMerge,boolean).mjava","sourceNew":null,"sourceOld":"  @SuppressWarnings(\"try\")\n  private synchronized void closeMergeReaders(MergePolicy.OneMerge merge, boolean suppressExceptions) throws IOException {\n    if (merge.hasFinished() == false) {\n      final boolean drop = suppressExceptions == false;\n      try (Closeable finalizer = () -> merge.mergeFinished(suppressExceptions == false)) {\n        IOUtils.applyToAll(merge.readers, sr -> {\n          final ReadersAndUpdates rld = getPooledInstance(sr.getOriginalSegmentInfo(), false);\n          // We still hold a ref so it should not have been removed:\n          assert rld != null;\n          if (drop) {\n            rld.dropChanges();\n          } else {\n            rld.dropMergingUpdates();\n          }\n          rld.release(sr);\n          release(rld);\n          if (drop) {\n            readerPool.drop(rld.info);\n          }\n        });\n      } finally {\n        Collections.fill(merge.readers, null);\n      }\n    } else {\n      assert merge.readers.stream().filter(Objects::nonNull).count() == 0 : \"we are done but still have readers: \" + merge.readers;\n      assert suppressExceptions : \"can't be done and not suppressing exceptions\";\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43":["203e3fcf513c02ee2c07015f2ce277e26dc60907","14d66d86a8b184a86bcaebcf6e15fcef486e0876"],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["8da3c22a3b1a00ae6e2664f3ac0d82cfa3a8f666"],"97fc96e6cc460e0ec1fb904a9c7ecd80680780c2":["320afd0985635623cf748b68038f69c6063e3069"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["97fc96e6cc460e0ec1fb904a9c7ecd80680780c2"],"ae695f21c50b03702b5d0fa2543d5af844bb7cd3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"af02a5a3ff2c1e52a02c0f07ff02c7197e43e59c":["28288370235ed02234a64753cdbf0c6ec096304a"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["48dad0bd6c76bd5f434a61222f7bf3e256cd2c2e","97fc96e6cc460e0ec1fb904a9c7ecd80680780c2"],"4d9aa91d3fdd25528bac3b2e6115d54fc2f28753":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"2a7869a97a6b91c66a9bd3519cd50583afb8cd6f":["af4f318fc7955d8e4e40cdf4a8a93931004fe7c0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"14d66d86a8b184a86bcaebcf6e15fcef486e0876":["203e3fcf513c02ee2c07015f2ce277e26dc60907"],"8da3c22a3b1a00ae6e2664f3ac0d82cfa3a8f666":["75e4e08ceec867127dcd9913a5ebbc46cf85a28d"],"e072d0b1fc19e0533d8ce432eed245196bca6fde":["ae695f21c50b03702b5d0fa2543d5af844bb7cd3"],"38e3b736c7ca086d61b7dbb841c905ee115490da":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","ae695f21c50b03702b5d0fa2543d5af844bb7cd3"],"75e4e08ceec867127dcd9913a5ebbc46cf85a28d":["e072d0b1fc19e0533d8ce432eed245196bca6fde"],"203e3fcf513c02ee2c07015f2ce277e26dc60907":["28288370235ed02234a64753cdbf0c6ec096304a","af02a5a3ff2c1e52a02c0f07ff02c7197e43e59c"],"1926100d9b67becc9701c54266fee3ba7878a5f0":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43"],"4987206dabc9f3576bb1df72e987094a7dad6e4f":["1926100d9b67becc9701c54266fee3ba7878a5f0"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["e9017cf144952056066919f1ebc7897ff9bd71b1","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"28288370235ed02234a64753cdbf0c6ec096304a":["97fc96e6cc460e0ec1fb904a9c7ecd80680780c2","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"48dad0bd6c76bd5f434a61222f7bf3e256cd2c2e":["4d9aa91d3fdd25528bac3b2e6115d54fc2f28753"],"af4f318fc7955d8e4e40cdf4a8a93931004fe7c0":["4987206dabc9f3576bb1df72e987094a7dad6e4f"],"c2a23476693f2bd9a4b44cc3187c429a2e21dac2":["2a7869a97a6b91c66a9bd3519cd50583afb8cd6f"],"320afd0985635623cf748b68038f69c6063e3069":["4d9aa91d3fdd25528bac3b2e6115d54fc2f28753"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c2a23476693f2bd9a4b44cc3187c429a2e21dac2"]},"commit2Childs":{"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43":["1926100d9b67becc9701c54266fee3ba7878a5f0"],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["4d9aa91d3fdd25528bac3b2e6115d54fc2f28753"],"97fc96e6cc460e0ec1fb904a9c7ecd80680780c2":["f4363cd33f6eff7fb4753574a441e2d18c1022a4","e9017cf144952056066919f1ebc7897ff9bd71b1","28288370235ed02234a64753cdbf0c6ec096304a"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["ae695f21c50b03702b5d0fa2543d5af844bb7cd3","38e3b736c7ca086d61b7dbb841c905ee115490da"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"ae695f21c50b03702b5d0fa2543d5af844bb7cd3":["e072d0b1fc19e0533d8ce432eed245196bca6fde","38e3b736c7ca086d61b7dbb841c905ee115490da"],"af02a5a3ff2c1e52a02c0f07ff02c7197e43e59c":["203e3fcf513c02ee2c07015f2ce277e26dc60907"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1"],"4d9aa91d3fdd25528bac3b2e6115d54fc2f28753":["48dad0bd6c76bd5f434a61222f7bf3e256cd2c2e","320afd0985635623cf748b68038f69c6063e3069"],"2a7869a97a6b91c66a9bd3519cd50583afb8cd6f":["c2a23476693f2bd9a4b44cc3187c429a2e21dac2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"14d66d86a8b184a86bcaebcf6e15fcef486e0876":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43"],"8da3c22a3b1a00ae6e2664f3ac0d82cfa3a8f666":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"e072d0b1fc19e0533d8ce432eed245196bca6fde":["75e4e08ceec867127dcd9913a5ebbc46cf85a28d"],"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"75e4e08ceec867127dcd9913a5ebbc46cf85a28d":["8da3c22a3b1a00ae6e2664f3ac0d82cfa3a8f666"],"203e3fcf513c02ee2c07015f2ce277e26dc60907":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43","14d66d86a8b184a86bcaebcf6e15fcef486e0876"],"1926100d9b67becc9701c54266fee3ba7878a5f0":["4987206dabc9f3576bb1df72e987094a7dad6e4f"],"4987206dabc9f3576bb1df72e987094a7dad6e4f":["af4f318fc7955d8e4e40cdf4a8a93931004fe7c0"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["af02a5a3ff2c1e52a02c0f07ff02c7197e43e59c","203e3fcf513c02ee2c07015f2ce277e26dc60907"],"48dad0bd6c76bd5f434a61222f7bf3e256cd2c2e":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"af4f318fc7955d8e4e40cdf4a8a93931004fe7c0":["2a7869a97a6b91c66a9bd3519cd50583afb8cd6f"],"320afd0985635623cf748b68038f69c6063e3069":["97fc96e6cc460e0ec1fb904a9c7ecd80680780c2"],"c2a23476693f2bd9a4b44cc3187c429a2e21dac2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["38e3b736c7ca086d61b7dbb841c905ee115490da","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}