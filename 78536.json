{"path":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#Dictionary(Directory,String,InputStream,List[InputStream],boolean).mjava","commits":[{"id":"867e3d9153fb761456b54a9dcce566e1545c5ef6","date":1444903098,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#Dictionary(Directory,String,InputStream,List[InputStream],boolean).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#Dictionary(InputStream,List[InputStream],boolean).mjava","sourceNew":"  /**\n   * Creates a new Dictionary containing the information read from the provided InputStreams to hunspell affix\n   * and dictionary files.\n   * You have to close the provided InputStreams yourself.\n   *\n   * @param tempDir Directory to use for offline sorting\n   * @param tempFileNamePrefix prefix to use to generate temp file names\n   * @param affix InputStream for reading the hunspell affix file (won't be closed).\n   * @param dictionaries InputStream for reading the hunspell dictionary files (won't be closed).\n   * @throws IOException Can be thrown while reading from the InputStreams\n   * @throws ParseException Can be thrown if the content of the files does not meet expected formats\n   */\n  public Dictionary(Directory tempDir, String tempFileNamePrefix, InputStream affix, List<InputStream> dictionaries, boolean ignoreCase) throws IOException, ParseException {\n    this.ignoreCase = ignoreCase;\n    this.needsInputCleaning = ignoreCase;\n    this.needsOutputCleaning = false; // set if we have an OCONV\n    flagLookup.add(new BytesRef()); // no flags -> ord 0\n\n    Path aff = Files.createTempFile(tempPath, \"affix\", \"aff\");\n    OutputStream out = new BufferedOutputStream(Files.newOutputStream(aff));\n    InputStream aff1 = null;\n    InputStream aff2 = null;\n    boolean success = false;\n    try {\n      // copy contents of affix stream to temp file\n      final byte [] buffer = new byte [1024 * 8];\n      int len;\n      while ((len = affix.read(buffer)) > 0) {\n        out.write(buffer, 0, len);\n      }\n      out.close();\n      \n      // pass 1: get encoding\n      aff1 = new BufferedInputStream(Files.newInputStream(aff));\n      String encoding = getDictionaryEncoding(aff1);\n      \n      // pass 2: parse affixes\n      CharsetDecoder decoder = getJavaEncoding(encoding);\n      aff2 = new BufferedInputStream(Files.newInputStream(aff));\n      readAffixFile(aff2, decoder);\n      \n      // read dictionary entries\n      IntSequenceOutputs o = IntSequenceOutputs.getSingleton();\n      Builder<IntsRef> b = new Builder<>(FST.INPUT_TYPE.BYTE4, o);\n      readDictionaryFiles(tempDir, tempFileNamePrefix, dictionaries, decoder, b);\n      words = b.finish();\n      aliases = null; // no longer needed\n      morphAliases = null; // no longer needed\n      success = true;\n    } finally {\n      IOUtils.closeWhileHandlingException(out, aff1, aff2);\n      if (success) {\n        Files.delete(aff);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(aff);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new Dictionary containing the information read from the provided InputStreams to hunspell affix\n   * and dictionary files.\n   * You have to close the provided InputStreams yourself.\n   *\n   * @param affix InputStream for reading the hunspell affix file (won't be closed).\n   * @param dictionaries InputStream for reading the hunspell dictionary files (won't be closed).\n   * @throws IOException Can be thrown while reading from the InputStreams\n   * @throws ParseException Can be thrown if the content of the files does not meet expected formats\n   */\n  public Dictionary(InputStream affix, List<InputStream> dictionaries, boolean ignoreCase) throws IOException, ParseException {\n    this.ignoreCase = ignoreCase;\n    this.needsInputCleaning = ignoreCase;\n    this.needsOutputCleaning = false; // set if we have an OCONV\n    flagLookup.add(new BytesRef()); // no flags -> ord 0\n\n    Path aff = Files.createTempFile(tempDir, \"affix\", \"aff\");\n    OutputStream out = new BufferedOutputStream(Files.newOutputStream(aff));\n    InputStream aff1 = null;\n    InputStream aff2 = null;\n    boolean success = false;\n    try {\n      // copy contents of affix stream to temp file\n      final byte [] buffer = new byte [1024 * 8];\n      int len;\n      while ((len = affix.read(buffer)) > 0) {\n        out.write(buffer, 0, len);\n      }\n      out.close();\n      \n      // pass 1: get encoding\n      aff1 = new BufferedInputStream(Files.newInputStream(aff));\n      String encoding = getDictionaryEncoding(aff1);\n      \n      // pass 2: parse affixes\n      CharsetDecoder decoder = getJavaEncoding(encoding);\n      aff2 = new BufferedInputStream(Files.newInputStream(aff));\n      readAffixFile(aff2, decoder);\n      \n      // read dictionary entries\n      IntSequenceOutputs o = IntSequenceOutputs.getSingleton();\n      Builder<IntsRef> b = new Builder<>(FST.INPUT_TYPE.BYTE4, o);\n      readDictionaryFiles(dictionaries, decoder, b);\n      words = b.finish();\n      aliases = null; // no longer needed\n      morphAliases = null; // no longer needed\n      success = true;\n    } finally {\n      IOUtils.closeWhileHandlingException(out, aff1, aff2);\n      if (success) {\n        Files.delete(aff);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(aff);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f5661e6a04d3172e262ad741b717924f2f1b6a5","date":1576244274,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#Dictionary(Directory,String,InputStream,List[InputStream],boolean).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#Dictionary(Directory,String,InputStream,List[InputStream],boolean).mjava","sourceNew":"  /**\n   * Creates a new Dictionary containing the information read from the provided InputStreams to hunspell affix\n   * and dictionary files.\n   * You have to close the provided InputStreams yourself.\n   *\n   * @param tempDir Directory to use for offline sorting\n   * @param tempFileNamePrefix prefix to use to generate temp file names\n   * @param affix InputStream for reading the hunspell affix file (won't be closed).\n   * @param dictionaries InputStream for reading the hunspell dictionary files (won't be closed).\n   * @throws IOException Can be thrown while reading from the InputStreams\n   * @throws ParseException Can be thrown if the content of the files does not meet expected formats\n   */\n  public Dictionary(Directory tempDir, String tempFileNamePrefix, InputStream affix, List<InputStream> dictionaries, boolean ignoreCase) throws IOException, ParseException {\n    this.ignoreCase = ignoreCase;\n    this.needsInputCleaning = ignoreCase;\n    this.needsOutputCleaning = false; // set if we have an OCONV\n    flagLookup.add(new BytesRef()); // no flags -> ord 0\n\n    Path aff = Files.createTempFile(tempPath, \"affix\", \"aff\");\n    OutputStream out = new BufferedOutputStream(Files.newOutputStream(aff));\n    InputStream aff1 = null;\n    InputStream aff2 = null;\n    boolean success = false;\n    try {\n      // copy contents of affix stream to temp file\n      final byte [] buffer = new byte [1024 * 8];\n      int len;\n      while ((len = affix.read(buffer)) > 0) {\n        out.write(buffer, 0, len);\n      }\n      out.close();\n      \n      // pass 1: get encoding\n      aff1 = new BufferedInputStream(Files.newInputStream(aff));\n      String encoding = getDictionaryEncoding(aff1);\n      \n      // pass 2: parse affixes\n      CharsetDecoder decoder = getJavaEncoding(encoding);\n      aff2 = new BufferedInputStream(Files.newInputStream(aff));\n      readAffixFile(aff2, decoder);\n      \n      // read dictionary entries\n      IntSequenceOutputs o = IntSequenceOutputs.getSingleton();\n      FSTCompiler<IntsRef> fstCompiler = new FSTCompiler<>(FST.INPUT_TYPE.BYTE4, o);\n      readDictionaryFiles(tempDir, tempFileNamePrefix, dictionaries, decoder, fstCompiler);\n      words = fstCompiler.compile();\n      aliases = null; // no longer needed\n      morphAliases = null; // no longer needed\n      success = true;\n    } finally {\n      IOUtils.closeWhileHandlingException(out, aff1, aff2);\n      if (success) {\n        Files.delete(aff);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(aff);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new Dictionary containing the information read from the provided InputStreams to hunspell affix\n   * and dictionary files.\n   * You have to close the provided InputStreams yourself.\n   *\n   * @param tempDir Directory to use for offline sorting\n   * @param tempFileNamePrefix prefix to use to generate temp file names\n   * @param affix InputStream for reading the hunspell affix file (won't be closed).\n   * @param dictionaries InputStream for reading the hunspell dictionary files (won't be closed).\n   * @throws IOException Can be thrown while reading from the InputStreams\n   * @throws ParseException Can be thrown if the content of the files does not meet expected formats\n   */\n  public Dictionary(Directory tempDir, String tempFileNamePrefix, InputStream affix, List<InputStream> dictionaries, boolean ignoreCase) throws IOException, ParseException {\n    this.ignoreCase = ignoreCase;\n    this.needsInputCleaning = ignoreCase;\n    this.needsOutputCleaning = false; // set if we have an OCONV\n    flagLookup.add(new BytesRef()); // no flags -> ord 0\n\n    Path aff = Files.createTempFile(tempPath, \"affix\", \"aff\");\n    OutputStream out = new BufferedOutputStream(Files.newOutputStream(aff));\n    InputStream aff1 = null;\n    InputStream aff2 = null;\n    boolean success = false;\n    try {\n      // copy contents of affix stream to temp file\n      final byte [] buffer = new byte [1024 * 8];\n      int len;\n      while ((len = affix.read(buffer)) > 0) {\n        out.write(buffer, 0, len);\n      }\n      out.close();\n      \n      // pass 1: get encoding\n      aff1 = new BufferedInputStream(Files.newInputStream(aff));\n      String encoding = getDictionaryEncoding(aff1);\n      \n      // pass 2: parse affixes\n      CharsetDecoder decoder = getJavaEncoding(encoding);\n      aff2 = new BufferedInputStream(Files.newInputStream(aff));\n      readAffixFile(aff2, decoder);\n      \n      // read dictionary entries\n      IntSequenceOutputs o = IntSequenceOutputs.getSingleton();\n      Builder<IntsRef> b = new Builder<>(FST.INPUT_TYPE.BYTE4, o);\n      readDictionaryFiles(tempDir, tempFileNamePrefix, dictionaries, decoder, b);\n      words = b.finish();\n      aliases = null; // no longer needed\n      morphAliases = null; // no longer needed\n      success = true;\n    } finally {\n      IOUtils.closeWhileHandlingException(out, aff1, aff2);\n      if (success) {\n        Files.delete(aff);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(aff);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","date":1576247714,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#Dictionary(Directory,String,InputStream,List[InputStream],boolean).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#Dictionary(Directory,String,InputStream,List[InputStream],boolean).mjava","sourceNew":"  /**\n   * Creates a new Dictionary containing the information read from the provided InputStreams to hunspell affix\n   * and dictionary files.\n   * You have to close the provided InputStreams yourself.\n   *\n   * @param tempDir Directory to use for offline sorting\n   * @param tempFileNamePrefix prefix to use to generate temp file names\n   * @param affix InputStream for reading the hunspell affix file (won't be closed).\n   * @param dictionaries InputStream for reading the hunspell dictionary files (won't be closed).\n   * @throws IOException Can be thrown while reading from the InputStreams\n   * @throws ParseException Can be thrown if the content of the files does not meet expected formats\n   */\n  public Dictionary(Directory tempDir, String tempFileNamePrefix, InputStream affix, List<InputStream> dictionaries, boolean ignoreCase) throws IOException, ParseException {\n    this.ignoreCase = ignoreCase;\n    this.needsInputCleaning = ignoreCase;\n    this.needsOutputCleaning = false; // set if we have an OCONV\n    flagLookup.add(new BytesRef()); // no flags -> ord 0\n\n    Path aff = Files.createTempFile(tempPath, \"affix\", \"aff\");\n    OutputStream out = new BufferedOutputStream(Files.newOutputStream(aff));\n    InputStream aff1 = null;\n    InputStream aff2 = null;\n    boolean success = false;\n    try {\n      // copy contents of affix stream to temp file\n      final byte [] buffer = new byte [1024 * 8];\n      int len;\n      while ((len = affix.read(buffer)) > 0) {\n        out.write(buffer, 0, len);\n      }\n      out.close();\n      \n      // pass 1: get encoding\n      aff1 = new BufferedInputStream(Files.newInputStream(aff));\n      String encoding = getDictionaryEncoding(aff1);\n      \n      // pass 2: parse affixes\n      CharsetDecoder decoder = getJavaEncoding(encoding);\n      aff2 = new BufferedInputStream(Files.newInputStream(aff));\n      readAffixFile(aff2, decoder);\n      \n      // read dictionary entries\n      IntSequenceOutputs o = IntSequenceOutputs.getSingleton();\n      FSTCompiler<IntsRef> fstCompiler = new FSTCompiler<>(FST.INPUT_TYPE.BYTE4, o);\n      readDictionaryFiles(tempDir, tempFileNamePrefix, dictionaries, decoder, fstCompiler);\n      words = fstCompiler.compile();\n      aliases = null; // no longer needed\n      morphAliases = null; // no longer needed\n      success = true;\n    } finally {\n      IOUtils.closeWhileHandlingException(out, aff1, aff2);\n      if (success) {\n        Files.delete(aff);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(aff);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Creates a new Dictionary containing the information read from the provided InputStreams to hunspell affix\n   * and dictionary files.\n   * You have to close the provided InputStreams yourself.\n   *\n   * @param tempDir Directory to use for offline sorting\n   * @param tempFileNamePrefix prefix to use to generate temp file names\n   * @param affix InputStream for reading the hunspell affix file (won't be closed).\n   * @param dictionaries InputStream for reading the hunspell dictionary files (won't be closed).\n   * @throws IOException Can be thrown while reading from the InputStreams\n   * @throws ParseException Can be thrown if the content of the files does not meet expected formats\n   */\n  public Dictionary(Directory tempDir, String tempFileNamePrefix, InputStream affix, List<InputStream> dictionaries, boolean ignoreCase) throws IOException, ParseException {\n    this.ignoreCase = ignoreCase;\n    this.needsInputCleaning = ignoreCase;\n    this.needsOutputCleaning = false; // set if we have an OCONV\n    flagLookup.add(new BytesRef()); // no flags -> ord 0\n\n    Path aff = Files.createTempFile(tempPath, \"affix\", \"aff\");\n    OutputStream out = new BufferedOutputStream(Files.newOutputStream(aff));\n    InputStream aff1 = null;\n    InputStream aff2 = null;\n    boolean success = false;\n    try {\n      // copy contents of affix stream to temp file\n      final byte [] buffer = new byte [1024 * 8];\n      int len;\n      while ((len = affix.read(buffer)) > 0) {\n        out.write(buffer, 0, len);\n      }\n      out.close();\n      \n      // pass 1: get encoding\n      aff1 = new BufferedInputStream(Files.newInputStream(aff));\n      String encoding = getDictionaryEncoding(aff1);\n      \n      // pass 2: parse affixes\n      CharsetDecoder decoder = getJavaEncoding(encoding);\n      aff2 = new BufferedInputStream(Files.newInputStream(aff));\n      readAffixFile(aff2, decoder);\n      \n      // read dictionary entries\n      IntSequenceOutputs o = IntSequenceOutputs.getSingleton();\n      Builder<IntsRef> b = new Builder<>(FST.INPUT_TYPE.BYTE4, o);\n      readDictionaryFiles(tempDir, tempFileNamePrefix, dictionaries, decoder, b);\n      words = b.finish();\n      aliases = null; // no longer needed\n      morphAliases = null; // no longer needed\n      success = true;\n    } finally {\n      IOUtils.closeWhileHandlingException(out, aff1, aff2);\n      if (success) {\n        Files.delete(aff);\n      } else {\n        IOUtils.deleteFilesIgnoringExceptions(aff);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":["867e3d9153fb761456b54a9dcce566e1545c5ef6","0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["867e3d9153fb761456b54a9dcce566e1545c5ef6"],"867e3d9153fb761456b54a9dcce566e1545c5ef6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f5661e6a04d3172e262ad741b717924f2f1b6a5"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["867e3d9153fb761456b54a9dcce566e1545c5ef6"],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":[],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"867e3d9153fb761456b54a9dcce566e1545c5ef6":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}