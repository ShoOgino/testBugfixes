{"path":"solr/core/src/java/org/apache/solr/util/hll/NumberUtil#fromHex(String,int,int).mjava","commits":[{"id":"6d8714f9ceaaff94f0968d1c2d037978c3fde569","date":1437042727,"type":0,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/hll/NumberUtil#fromHex(String,int,int).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Converts the specified array of hex characters into an array of <code>byte</code>s\n     * (low <code>byte</code> first).\n     *\n     * @param  string the string of hex characters to be converted into <code>byte</code>s.\n     *         This cannot be <code>null</code> though it may be blank.\n     * @param  offset the offset in the string at which the characters will be\n     *         taken.  This cannot be negative and must be less than <code>string.length() - 1</code>.\n     * @param  count the number of characters to be retrieved from the specified\n     *         string.  This cannot be negative and must be divisible by two\n     *         (since there are two characters per <code>byte</code>).\n     * @return the array of <code>byte</code>s that were converted from the\n     *         specified string (in the specified range).  This will never be\n     *         <code>null</code> though it may be empty if <code>string</code>\n     *         is empty or <code>count</code> is zero.\n     * @throws IllegalArgumentException if <code>offset</code> is greater than\n     *         or equal to <code>string.length()</code> or if <code>count</code>\n     *         is not divisible by two.\n     * @see #toHex(byte[], int, int)\n     */\n    public static byte[] fromHex(final String string, final int offset, final int count) {\n        if(offset >= string.length()) throw new IllegalArgumentException(\"Offset is greater than the length (\" + offset + \" >= \" + string.length() + \").\")/*by contract*/;\n        if( (count & 0x01) != 0) throw new IllegalArgumentException(\"Count is not divisible by two (\" + count + \").\")/*by contract*/;\n        final int charCount = Math.min((string.length() - offset), count);\n        final int upperBound = offset + charCount;\n\n        final byte[] bytes = new byte[charCount >>> 1/*aka /2*/];\n        int byteIndex = 0/*beginning*/;\n        for(int i=offset; i<upperBound; i+=2) {\n            bytes[byteIndex++] = (byte)(( (digit(string.charAt(i)) << 4)\n                                         | digit(string.charAt(i + 1))) & 0xFF);\n        }\n\n        return bytes;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b5ee4c66244bdfcc4796a114519d47701b2c026","date":1437132013,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/hll/NumberUtil#fromHex(String,int,int).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Converts the specified array of hex characters into an array of <code>byte</code>s\n     * (low <code>byte</code> first).\n     *\n     * @param  string the string of hex characters to be converted into <code>byte</code>s.\n     *         This cannot be <code>null</code> though it may be blank.\n     * @param  offset the offset in the string at which the characters will be\n     *         taken.  This cannot be negative and must be less than <code>string.length() - 1</code>.\n     * @param  count the number of characters to be retrieved from the specified\n     *         string.  This cannot be negative and must be divisible by two\n     *         (since there are two characters per <code>byte</code>).\n     * @return the array of <code>byte</code>s that were converted from the\n     *         specified string (in the specified range).  This will never be\n     *         <code>null</code> though it may be empty if <code>string</code>\n     *         is empty or <code>count</code> is zero.\n     * @throws IllegalArgumentException if <code>offset</code> is greater than\n     *         or equal to <code>string.length()</code> or if <code>count</code>\n     *         is not divisible by two.\n     * @see #toHex(byte[], int, int)\n     */\n    public static byte[] fromHex(final String string, final int offset, final int count) {\n        if(offset >= string.length()) throw new IllegalArgumentException(\"Offset is greater than the length (\" + offset + \" >= \" + string.length() + \").\")/*by contract*/;\n        if( (count & 0x01) != 0) throw new IllegalArgumentException(\"Count is not divisible by two (\" + count + \").\")/*by contract*/;\n        final int charCount = Math.min((string.length() - offset), count);\n        final int upperBound = offset + charCount;\n\n        final byte[] bytes = new byte[charCount >>> 1/*aka /2*/];\n        int byteIndex = 0/*beginning*/;\n        for(int i=offset; i<upperBound; i+=2) {\n            bytes[byteIndex++] = (byte)(( (digit(string.charAt(i)) << 4)\n                                         | digit(string.charAt(i + 1))) & 0xFF);\n        }\n\n        return bytes;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3b5ee4c66244bdfcc4796a114519d47701b2c026":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6d8714f9ceaaff94f0968d1c2d037978c3fde569"],"6d8714f9ceaaff94f0968d1c2d037978c3fde569":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3b5ee4c66244bdfcc4796a114519d47701b2c026"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3b5ee4c66244bdfcc4796a114519d47701b2c026","6d8714f9ceaaff94f0968d1c2d037978c3fde569"],"3b5ee4c66244bdfcc4796a114519d47701b2c026":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6d8714f9ceaaff94f0968d1c2d037978c3fde569":["3b5ee4c66244bdfcc4796a114519d47701b2c026"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}