{"path":"lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/JapaneseTokenizer#incrementToken().mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/JapaneseTokenizer#incrementToken().mjava","pathOld":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/JapaneseTokenizer#incrementToken().mjava","sourceNew":"  @Override\n  public boolean incrementToken() throws IOException {\n\n    // parse() is able to return w/o producing any new\n    // tokens, when the tokens it had produced were entirely\n    // punctuation.  So we loop here until we get a real\n    // token or we end:\n    while (pending.size() == 0) {\n      if (end) {\n        return false;\n      }\n\n      // Push Viterbi forward some more:\n      parse();\n    }\n\n    final Token token = pending.remove(pending.size()-1);\n\n    int position = token.getPosition();\n    int length = token.getLength();\n    clearAttributes();\n    assert length > 0;\n    //System.out.println(\"off=\" + token.getOffset() + \" len=\" + length + \" vs \" + token.getSurfaceForm().length);\n    termAtt.copyBuffer(token.getSurfaceForm(), token.getOffset(), length);\n    offsetAtt.setOffset(correctOffset(position), correctOffset(position+length));\n    basicFormAtt.setToken(token);\n    posAtt.setToken(token);\n    readingAtt.setToken(token);\n    inflectionAtt.setToken(token);\n    if (token.getPosition() == lastTokenPos) {\n      posIncAtt.setPositionIncrement(0);\n      posLengthAtt.setPositionLength(token.getPositionLength());\n    } else {\n      assert token.getPosition() > lastTokenPos;\n      posIncAtt.setPositionIncrement(1);\n      posLengthAtt.setPositionLength(1);\n    }\n    if (VERBOSE) {\n      System.out.println(Thread.currentThread().getName() + \":    incToken: return token=\" + token);\n    }\n    lastTokenPos = token.getPosition();\n    return true;\n  }\n\n","sourceOld":"  @Override\n  public boolean incrementToken() throws IOException {\n\n    // parse() is able to return w/o producing any new\n    // tokens, when the tokens it had produced were entirely\n    // punctuation.  So we loop here until we get a real\n    // token or we end:\n    while (pending.size() == 0) {\n      if (end) {\n        return false;\n      }\n\n      // Push Viterbi forward some more:\n      parse();\n    }\n\n    final Token token = pending.remove(pending.size()-1);\n\n    int position = token.getPosition();\n    int length = token.getLength();\n    clearAttributes();\n    assert length > 0;\n    //System.out.println(\"off=\" + token.getOffset() + \" len=\" + length + \" vs \" + token.getSurfaceForm().length);\n    termAtt.copyBuffer(token.getSurfaceForm(), token.getOffset(), length);\n    offsetAtt.setOffset(correctOffset(position), correctOffset(position+length));\n    basicFormAtt.setToken(token);\n    posAtt.setToken(token);\n    readingAtt.setToken(token);\n    inflectionAtt.setToken(token);\n    if (token.getPosition() == lastTokenPos) {\n      posIncAtt.setPositionIncrement(0);\n      posLengthAtt.setPositionLength(token.getPositionLength());\n    } else {\n      assert token.getPosition() > lastTokenPos;\n      posIncAtt.setPositionIncrement(1);\n      posLengthAtt.setPositionLength(1);\n    }\n    if (VERBOSE) {\n      System.out.println(Thread.currentThread().getName() + \":    incToken: return token=\" + token);\n    }\n    lastTokenPos = token.getPosition();\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f2b45d6769cfaeb4456b4b66cdd5e25c8940f2a4","date":1449124064,"type":3,"author":"Christian Moen","isMerge":false,"pathNew":"lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/JapaneseTokenizer#incrementToken().mjava","pathOld":"lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/JapaneseTokenizer#incrementToken().mjava","sourceNew":"  @Override\n  public boolean incrementToken() throws IOException {\n\n    // parse() is able to return w/o producing any new\n    // tokens, when the tokens it had produced were entirely\n    // punctuation.  So we loop here until we get a real\n    // token or we end:\n    while (pending.size() == 0) {\n      if (end) {\n        return false;\n      }\n\n      // Push Viterbi forward some more:\n      parse();\n    }\n\n    final Token token = pending.remove(pending.size()-1);\n\n    int position = token.getPosition();\n    int length = token.getLength();\n    clearAttributes();\n    assert length > 0;\n    //System.out.println(\"off=\" + token.getOffset() + \" len=\" + length + \" vs \" + token.getSurfaceForm().length);\n    termAtt.copyBuffer(token.getSurfaceForm(), token.getOffset(), length);\n    offsetAtt.setOffset(correctOffset(position), correctOffset(position+length));\n    basicFormAtt.setToken(token);\n    posAtt.setToken(token);\n    readingAtt.setToken(token);\n    inflectionAtt.setToken(token);\n    if (token.getPosition() == lastTokenPos) {\n      posIncAtt.setPositionIncrement(0);\n      posLengthAtt.setPositionLength(token.getPositionLength());\n    } else if (outputNBest) {\n      // The position length is always calculated if outputNBest is true.\n      assert token.getPosition() > lastTokenPos;\n      posIncAtt.setPositionIncrement(1);\n      posLengthAtt.setPositionLength(token.getPositionLength());\n    } else {\n      assert token.getPosition() > lastTokenPos;\n      posIncAtt.setPositionIncrement(1);\n      posLengthAtt.setPositionLength(1);\n    }\n    if (VERBOSE) {\n      System.out.println(Thread.currentThread().getName() + \":    incToken: return token=\" + token);\n    }\n    lastTokenPos = token.getPosition();\n    return true;\n  }\n\n","sourceOld":"  @Override\n  public boolean incrementToken() throws IOException {\n\n    // parse() is able to return w/o producing any new\n    // tokens, when the tokens it had produced were entirely\n    // punctuation.  So we loop here until we get a real\n    // token or we end:\n    while (pending.size() == 0) {\n      if (end) {\n        return false;\n      }\n\n      // Push Viterbi forward some more:\n      parse();\n    }\n\n    final Token token = pending.remove(pending.size()-1);\n\n    int position = token.getPosition();\n    int length = token.getLength();\n    clearAttributes();\n    assert length > 0;\n    //System.out.println(\"off=\" + token.getOffset() + \" len=\" + length + \" vs \" + token.getSurfaceForm().length);\n    termAtt.copyBuffer(token.getSurfaceForm(), token.getOffset(), length);\n    offsetAtt.setOffset(correctOffset(position), correctOffset(position+length));\n    basicFormAtt.setToken(token);\n    posAtt.setToken(token);\n    readingAtt.setToken(token);\n    inflectionAtt.setToken(token);\n    if (token.getPosition() == lastTokenPos) {\n      posIncAtt.setPositionIncrement(0);\n      posLengthAtt.setPositionLength(token.getPositionLength());\n    } else {\n      assert token.getPosition() > lastTokenPos;\n      posIncAtt.setPositionIncrement(1);\n      posLengthAtt.setPositionLength(1);\n    }\n    if (VERBOSE) {\n      System.out.println(Thread.currentThread().getName() + \":    incToken: return token=\" + token);\n    }\n    lastTokenPos = token.getPosition();\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f2b45d6769cfaeb4456b4b66cdd5e25c8940f2a4":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f2b45d6769cfaeb4456b4b66cdd5e25c8940f2a4"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["f2b45d6769cfaeb4456b4b66cdd5e25c8940f2a4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"f2b45d6769cfaeb4456b4b66cdd5e25c8940f2a4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}