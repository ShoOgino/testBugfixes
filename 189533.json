{"path":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#addIntersectingChildren().mjava","commits":[{"id":"c659c37800c0dfd82fa025b5834f4ab065903d11","date":1361851047,"type":0,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#addIntersectingChildren().mjava","pathOld":"/dev/null","sourceNew":"    /** Called initially, and whenever {@link #visit(org.apache.lucene.spatial.prefix.tree.Node)}\n     * returns true. */\n    private void addIntersectingChildren() throws IOException {\n      assert thisTerm != null;\n      Node cell = curVNode.cell;\n      if (cell.getLevel() >= detailLevel)\n        throw new IllegalStateException(\"Spatial logic error\");\n\n      //Check for adjacent leaf (happens for indexed non-point shapes)\n      assert !cell.isLeaf();\n      if (hasIndexedLeaves && cell.getLevel() != 0) {\n        //If the next indexed term just adds a leaf marker ('+') to cell,\n        // then add all of those docs\n        assert StringHelper.startsWith(thisTerm, curVNodeTerm);\n        scanCell = grid.getNode(thisTerm.bytes, thisTerm.offset, thisTerm.length, scanCell);\n        if (scanCell.getLevel() == cell.getLevel() && scanCell.isLeaf()) {\n          visitLeaf(scanCell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            return; // all done\n        }\n      }\n\n      //Decide whether to continue to divide & conquer, or whether it's time to\n      // scan through terms beneath this cell.\n      // Scanning is a performance optimization trade-off.\n\n      //TODO use termsEnum.docFreq() as heuristic\n      boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n      if (!scan) {\n        //Divide & conquer (ultimately termsEnum.seek())\n\n        Iterator<Node> subCellsIter = findSubCellsToVisit(cell);\n        if (!subCellsIter.hasNext())//not expected\n          return;\n        curVNode.children = new VNodeCellIterator(subCellsIter, new VNode(curVNode));\n\n      } else {\n        //Scan (loop of termsEnum.next())\n\n        scan(detailLevel);\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5aeecf64d57563b4636e7f4222e7ddcde7f8df7b","date":1364392557,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#addIntersectingChildren().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#addIntersectingChildren().mjava","sourceNew":"    /** Called initially, and whenever {@link #visit(org.apache.lucene.spatial.prefix.tree.Node)}\n     * returns true. */\n    private void addIntersectingChildren() throws IOException {\n      assert thisTerm != null;\n      Node cell = curVNode.cell;\n      if (cell.getLevel() >= detailLevel)\n        throw new IllegalStateException(\"Spatial logic error\");\n\n      //Check for adjacent leaf (happens for indexed non-point shapes)\n      if (hasIndexedLeaves && cell.getLevel() != 0) {\n        //If the next indexed term just adds a leaf marker ('+') to cell,\n        // then add all of those docs\n        assert StringHelper.startsWith(thisTerm, curVNodeTerm);\n        scanCell = grid.getNode(thisTerm.bytes, thisTerm.offset, thisTerm.length, scanCell);\n        if (scanCell.getLevel() == cell.getLevel() && scanCell.isLeaf()) {\n          visitLeaf(scanCell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            return; // all done\n        }\n      }\n\n      //Decide whether to continue to divide & conquer, or whether it's time to\n      // scan through terms beneath this cell.\n      // Scanning is a performance optimization trade-off.\n\n      //TODO use termsEnum.docFreq() as heuristic\n      boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n      if (!scan) {\n        //Divide & conquer (ultimately termsEnum.seek())\n\n        Iterator<Node> subCellsIter = findSubCellsToVisit(cell);\n        if (!subCellsIter.hasNext())//not expected\n          return;\n        curVNode.children = new VNodeCellIterator(subCellsIter, new VNode(curVNode));\n\n      } else {\n        //Scan (loop of termsEnum.next())\n\n        scan(detailLevel);\n      }\n    }\n\n","sourceOld":"    /** Called initially, and whenever {@link #visit(org.apache.lucene.spatial.prefix.tree.Node)}\n     * returns true. */\n    private void addIntersectingChildren() throws IOException {\n      assert thisTerm != null;\n      Node cell = curVNode.cell;\n      if (cell.getLevel() >= detailLevel)\n        throw new IllegalStateException(\"Spatial logic error\");\n\n      //Check for adjacent leaf (happens for indexed non-point shapes)\n      assert !cell.isLeaf();\n      if (hasIndexedLeaves && cell.getLevel() != 0) {\n        //If the next indexed term just adds a leaf marker ('+') to cell,\n        // then add all of those docs\n        assert StringHelper.startsWith(thisTerm, curVNodeTerm);\n        scanCell = grid.getNode(thisTerm.bytes, thisTerm.offset, thisTerm.length, scanCell);\n        if (scanCell.getLevel() == cell.getLevel() && scanCell.isLeaf()) {\n          visitLeaf(scanCell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            return; // all done\n        }\n      }\n\n      //Decide whether to continue to divide & conquer, or whether it's time to\n      // scan through terms beneath this cell.\n      // Scanning is a performance optimization trade-off.\n\n      //TODO use termsEnum.docFreq() as heuristic\n      boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n      if (!scan) {\n        //Divide & conquer (ultimately termsEnum.seek())\n\n        Iterator<Node> subCellsIter = findSubCellsToVisit(cell);\n        if (!subCellsIter.hasNext())//not expected\n          return;\n        curVNode.children = new VNodeCellIterator(subCellsIter, new VNode(curVNode));\n\n      } else {\n        //Scan (loop of termsEnum.next())\n\n        scan(detailLevel);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8259c159da2de2e8528524fb76b244b46cbded59","date":1364478249,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#addIntersectingChildren().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#addIntersectingChildren().mjava","sourceNew":"    /** Called initially, and whenever {@link #visit(org.apache.lucene.spatial.prefix.tree.Cell)}\n     * returns true. */\n    private void addIntersectingChildren() throws IOException {\n      assert thisTerm != null;\n      Cell cell = curVNode.cell;\n      if (cell.getLevel() >= detailLevel)\n        throw new IllegalStateException(\"Spatial logic error\");\n\n      //Check for adjacent leaf (happens for indexed non-point shapes)\n      if (hasIndexedLeaves && cell.getLevel() != 0) {\n        //If the next indexed term just adds a leaf marker ('+') to cell,\n        // then add all of those docs\n        assert StringHelper.startsWith(thisTerm, curVNodeTerm);\n        scanCell = grid.getCell(thisTerm.bytes, thisTerm.offset, thisTerm.length, scanCell);\n        if (scanCell.getLevel() == cell.getLevel() && scanCell.isLeaf()) {\n          visitLeaf(scanCell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            return; // all done\n        }\n      }\n\n      //Decide whether to continue to divide & conquer, or whether it's time to\n      // scan through terms beneath this cell.\n      // Scanning is a performance optimization trade-off.\n\n      //TODO use termsEnum.docFreq() as heuristic\n      boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n      if (!scan) {\n        //Divide & conquer (ultimately termsEnum.seek())\n\n        Iterator<Cell> subCellsIter = findSubCellsToVisit(cell);\n        if (!subCellsIter.hasNext())//not expected\n          return;\n        curVNode.children = new VNodeCellIterator(subCellsIter, new VNode(curVNode));\n\n      } else {\n        //Scan (loop of termsEnum.next())\n\n        scan(detailLevel);\n      }\n    }\n\n","sourceOld":"    /** Called initially, and whenever {@link #visit(org.apache.lucene.spatial.prefix.tree.Node)}\n     * returns true. */\n    private void addIntersectingChildren() throws IOException {\n      assert thisTerm != null;\n      Node cell = curVNode.cell;\n      if (cell.getLevel() >= detailLevel)\n        throw new IllegalStateException(\"Spatial logic error\");\n\n      //Check for adjacent leaf (happens for indexed non-point shapes)\n      if (hasIndexedLeaves && cell.getLevel() != 0) {\n        //If the next indexed term just adds a leaf marker ('+') to cell,\n        // then add all of those docs\n        assert StringHelper.startsWith(thisTerm, curVNodeTerm);\n        scanCell = grid.getNode(thisTerm.bytes, thisTerm.offset, thisTerm.length, scanCell);\n        if (scanCell.getLevel() == cell.getLevel() && scanCell.isLeaf()) {\n          visitLeaf(scanCell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            return; // all done\n        }\n      }\n\n      //Decide whether to continue to divide & conquer, or whether it's time to\n      // scan through terms beneath this cell.\n      // Scanning is a performance optimization trade-off.\n\n      //TODO use termsEnum.docFreq() as heuristic\n      boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n      if (!scan) {\n        //Divide & conquer (ultimately termsEnum.seek())\n\n        Iterator<Node> subCellsIter = findSubCellsToVisit(cell);\n        if (!subCellsIter.hasNext())//not expected\n          return;\n        curVNode.children = new VNodeCellIterator(subCellsIter, new VNode(curVNode));\n\n      } else {\n        //Scan (loop of termsEnum.next())\n\n        scan(detailLevel);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"efc64259f3c8f43dfc6841ffad77df3b9446e3a5","date":1395149462,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#addIntersectingChildren().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#addIntersectingChildren().mjava","sourceNew":"    /** Called initially, and whenever {@link #visit(org.apache.lucene.spatial.prefix.tree.Cell)}\n     * returns true. */\n    private void addIntersectingChildren() throws IOException {\n      assert thisTerm != null;\n      Cell cell = curVNode.cell;\n      if (cell.getLevel() >= detailLevel)\n        throw new IllegalStateException(\"Spatial logic error\");\n\n      //Check for adjacent leaf (happens for indexed non-point shapes)\n      if (hasIndexedLeaves && cell.getLevel() != 0) {\n        //If the next indexed term just adds a leaf marker ('+') to cell,\n        // then add all of those docs\n        assert StringHelper.startsWith(thisTerm, curVNodeTerm);//TODO refactor to use method on curVNode.cell\n        scanCell = grid.getCell(thisTerm.bytes, thisTerm.offset, thisTerm.length, scanCell);\n        if (scanCell.getLevel() == cell.getLevel() && scanCell.isLeaf()) {\n          visitLeaf(scanCell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            return; // all done\n        }\n      }\n\n      //Decide whether to continue to divide & conquer, or whether it's time to\n      // scan through terms beneath this cell.\n      // Scanning is a performance optimization trade-off.\n\n      //TODO use termsEnum.docFreq() as heuristic\n      boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n      if (!scan) {\n        //Divide & conquer (ultimately termsEnum.seek())\n\n        Iterator<Cell> subCellsIter = findSubCellsToVisit(cell);\n        if (!subCellsIter.hasNext())//not expected\n          return;\n        curVNode.children = new VNodeCellIterator(subCellsIter, new VNode(curVNode));\n\n      } else {\n        //Scan (loop of termsEnum.next())\n\n        scan(detailLevel);\n      }\n    }\n\n","sourceOld":"    /** Called initially, and whenever {@link #visit(org.apache.lucene.spatial.prefix.tree.Cell)}\n     * returns true. */\n    private void addIntersectingChildren() throws IOException {\n      assert thisTerm != null;\n      Cell cell = curVNode.cell;\n      if (cell.getLevel() >= detailLevel)\n        throw new IllegalStateException(\"Spatial logic error\");\n\n      //Check for adjacent leaf (happens for indexed non-point shapes)\n      if (hasIndexedLeaves && cell.getLevel() != 0) {\n        //If the next indexed term just adds a leaf marker ('+') to cell,\n        // then add all of those docs\n        assert StringHelper.startsWith(thisTerm, curVNodeTerm);\n        scanCell = grid.getCell(thisTerm.bytes, thisTerm.offset, thisTerm.length, scanCell);\n        if (scanCell.getLevel() == cell.getLevel() && scanCell.isLeaf()) {\n          visitLeaf(scanCell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            return; // all done\n        }\n      }\n\n      //Decide whether to continue to divide & conquer, or whether it's time to\n      // scan through terms beneath this cell.\n      // Scanning is a performance optimization trade-off.\n\n      //TODO use termsEnum.docFreq() as heuristic\n      boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n      if (!scan) {\n        //Divide & conquer (ultimately termsEnum.seek())\n\n        Iterator<Cell> subCellsIter = findSubCellsToVisit(cell);\n        if (!subCellsIter.hasNext())//not expected\n          return;\n        curVNode.children = new VNodeCellIterator(subCellsIter, new VNode(curVNode));\n\n      } else {\n        //Scan (loop of termsEnum.next())\n\n        scan(detailLevel);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4de14be4bd1b857ba37ca138b61c4661c6d1bed3","date":1396628861,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#addIntersectingChildren().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#addIntersectingChildren().mjava","sourceNew":"    /** Called initially, and whenever {@link #visit(org.apache.lucene.spatial.prefix.tree.Cell)}\n     * returns true. */\n    private void addIntersectingChildren() throws IOException {\n      assert thisTerm != null;\n      Cell cell = curVNode.cell;\n      if (cell.getLevel() >= detailLevel)\n        throw new IllegalStateException(\"Spatial logic error\");\n\n      //Check for adjacent leaf (happens for indexed non-point shapes)\n      if (hasIndexedLeaves && cell.getLevel() != 0) {\n        //If the next indexed term just adds a leaf marker ('+') to cell,\n        // then add all of those docs\n        assert curVNode.cell.isWithin(curVNodeTerm, thisTerm);\n        scanCell = grid.getCell(thisTerm.bytes, thisTerm.offset, thisTerm.length, scanCell);\n        if (scanCell.getLevel() == cell.getLevel() && scanCell.isLeaf()) {\n          visitLeaf(scanCell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            return; // all done\n        }\n      }\n\n      //Decide whether to continue to divide & conquer, or whether it's time to\n      // scan through terms beneath this cell.\n      // Scanning is a performance optimization trade-off.\n\n      //TODO use termsEnum.docFreq() as heuristic\n      boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n      if (!scan) {\n        //Divide & conquer (ultimately termsEnum.seek())\n\n        Iterator<Cell> subCellsIter = findSubCellsToVisit(cell);\n        if (!subCellsIter.hasNext())//not expected\n          return;\n        curVNode.children = new VNodeCellIterator(subCellsIter, new VNode(curVNode));\n\n      } else {\n        //Scan (loop of termsEnum.next())\n\n        scan(detailLevel);\n      }\n    }\n\n","sourceOld":"    /** Called initially, and whenever {@link #visit(org.apache.lucene.spatial.prefix.tree.Cell)}\n     * returns true. */\n    private void addIntersectingChildren() throws IOException {\n      assert thisTerm != null;\n      Cell cell = curVNode.cell;\n      if (cell.getLevel() >= detailLevel)\n        throw new IllegalStateException(\"Spatial logic error\");\n\n      //Check for adjacent leaf (happens for indexed non-point shapes)\n      if (hasIndexedLeaves && cell.getLevel() != 0) {\n        //If the next indexed term just adds a leaf marker ('+') to cell,\n        // then add all of those docs\n        assert StringHelper.startsWith(thisTerm, curVNodeTerm);//TODO refactor to use method on curVNode.cell\n        scanCell = grid.getCell(thisTerm.bytes, thisTerm.offset, thisTerm.length, scanCell);\n        if (scanCell.getLevel() == cell.getLevel() && scanCell.isLeaf()) {\n          visitLeaf(scanCell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            return; // all done\n        }\n      }\n\n      //Decide whether to continue to divide & conquer, or whether it's time to\n      // scan through terms beneath this cell.\n      // Scanning is a performance optimization trade-off.\n\n      //TODO use termsEnum.docFreq() as heuristic\n      boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n      if (!scan) {\n        //Divide & conquer (ultimately termsEnum.seek())\n\n        Iterator<Cell> subCellsIter = findSubCellsToVisit(cell);\n        if (!subCellsIter.hasNext())//not expected\n          return;\n        curVNode.children = new VNodeCellIterator(subCellsIter, new VNode(curVNode));\n\n      } else {\n        //Scan (loop of termsEnum.next())\n\n        scan(detailLevel);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15e323346eac5e4685c0a9f2df85eb96b4239bbb","date":1396688577,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#addIntersectingChildren().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#addIntersectingChildren().mjava","sourceNew":"    /** Called initially, and whenever {@link #visit(org.apache.lucene.spatial.prefix.tree.Cell)}\n     * returns true. */\n    private void addIntersectingChildren() throws IOException {\n      assert thisTerm != null;\n      Cell cell = curVNode.cell;\n      if (cell.getLevel() >= detailLevel)\n        throw new IllegalStateException(\"Spatial logic error\");\n\n      //Check for adjacent leaf (happens for indexed non-point shapes)\n      if (hasIndexedLeaves && cell.getLevel() != 0) {\n        //If the next indexed term just adds a leaf marker ('+') to cell,\n        // then add all of those docs\n        assert curVNode.cell.isWithin(curVNodeTerm, thisTerm);\n        scanCell = grid.getCell(thisTerm.bytes, thisTerm.offset, thisTerm.length, scanCell);\n        if (scanCell.getLevel() == cell.getLevel() && scanCell.isLeaf()) {\n          visitLeaf(scanCell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            return; // all done\n        }\n      }\n\n      //Decide whether to continue to divide & conquer, or whether it's time to\n      // scan through terms beneath this cell.\n      // Scanning is a performance optimization trade-off.\n\n      //TODO use termsEnum.docFreq() as heuristic\n      boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n      if (!scan) {\n        //Divide & conquer (ultimately termsEnum.seek())\n\n        Iterator<Cell> subCellsIter = findSubCellsToVisit(cell);\n        if (!subCellsIter.hasNext())//not expected\n          return;\n        curVNode.children = new VNodeCellIterator(subCellsIter, new VNode(curVNode));\n\n      } else {\n        //Scan (loop of termsEnum.next())\n\n        scan(detailLevel);\n      }\n    }\n\n","sourceOld":"    /** Called initially, and whenever {@link #visit(org.apache.lucene.spatial.prefix.tree.Cell)}\n     * returns true. */\n    private void addIntersectingChildren() throws IOException {\n      assert thisTerm != null;\n      Cell cell = curVNode.cell;\n      if (cell.getLevel() >= detailLevel)\n        throw new IllegalStateException(\"Spatial logic error\");\n\n      //Check for adjacent leaf (happens for indexed non-point shapes)\n      if (hasIndexedLeaves && cell.getLevel() != 0) {\n        //If the next indexed term just adds a leaf marker ('+') to cell,\n        // then add all of those docs\n        assert StringHelper.startsWith(thisTerm, curVNodeTerm);//TODO refactor to use method on curVNode.cell\n        scanCell = grid.getCell(thisTerm.bytes, thisTerm.offset, thisTerm.length, scanCell);\n        if (scanCell.getLevel() == cell.getLevel() && scanCell.isLeaf()) {\n          visitLeaf(scanCell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            return; // all done\n        }\n      }\n\n      //Decide whether to continue to divide & conquer, or whether it's time to\n      // scan through terms beneath this cell.\n      // Scanning is a performance optimization trade-off.\n\n      //TODO use termsEnum.docFreq() as heuristic\n      boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n      if (!scan) {\n        //Divide & conquer (ultimately termsEnum.seek())\n\n        Iterator<Cell> subCellsIter = findSubCellsToVisit(cell);\n        if (!subCellsIter.hasNext())//not expected\n          return;\n        curVNode.children = new VNodeCellIterator(subCellsIter, new VNode(curVNode));\n\n      } else {\n        //Scan (loop of termsEnum.next())\n\n        scan(detailLevel);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6","date":1397789149,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#addIntersectingChildren().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#addIntersectingChildren().mjava","sourceNew":"    /** Called initially, and whenever {@link #visit(org.apache.lucene.spatial.prefix.tree.Cell)}\n     * returns true. */\n    private void addIntersectingChildren() throws IOException {\n      assert thisTerm != null;\n      Cell cell = curVNode.cell;\n      if (cell.getLevel() >= detailLevel)\n        throw new IllegalStateException(\"Spatial logic error\");\n\n      //Check for adjacent leaf (happens for indexed non-point shapes)\n      if (hasIndexedLeaves && cell.getLevel() != 0) {\n        //If the next indexed term just adds a leaf marker ('+') to cell,\n        // then add all of those docs\n        scanCell.readCell(thisTerm);\n        assert curVNode.cell.isPrefixOf(scanCell);\n        if (scanCell.getLevel() == cell.getLevel() && scanCell.isLeaf()) {\n          visitLeaf(scanCell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            return; // all done\n        }\n      }\n\n      //Decide whether to continue to divide & conquer, or whether it's time to\n      // scan through terms beneath this cell.\n      // Scanning is a performance optimization trade-off.\n\n      //TODO use termsEnum.docFreq() as heuristic\n      boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n      if (!scan) {\n        //Divide & conquer (ultimately termsEnum.seek())\n\n        Iterator<Cell> subCellsIter = findSubCellsToVisit(cell);\n        if (!subCellsIter.hasNext())//not expected\n          return;\n        curVNode.children = new VNodeCellIterator(subCellsIter, new VNode(curVNode));\n\n      } else {\n        //Scan (loop of termsEnum.next())\n\n        scan(detailLevel);\n      }\n    }\n\n","sourceOld":"    /** Called initially, and whenever {@link #visit(org.apache.lucene.spatial.prefix.tree.Cell)}\n     * returns true. */\n    private void addIntersectingChildren() throws IOException {\n      assert thisTerm != null;\n      Cell cell = curVNode.cell;\n      if (cell.getLevel() >= detailLevel)\n        throw new IllegalStateException(\"Spatial logic error\");\n\n      //Check for adjacent leaf (happens for indexed non-point shapes)\n      if (hasIndexedLeaves && cell.getLevel() != 0) {\n        //If the next indexed term just adds a leaf marker ('+') to cell,\n        // then add all of those docs\n        assert curVNode.cell.isWithin(curVNodeTerm, thisTerm);\n        scanCell = grid.getCell(thisTerm.bytes, thisTerm.offset, thisTerm.length, scanCell);\n        if (scanCell.getLevel() == cell.getLevel() && scanCell.isLeaf()) {\n          visitLeaf(scanCell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            return; // all done\n        }\n      }\n\n      //Decide whether to continue to divide & conquer, or whether it's time to\n      // scan through terms beneath this cell.\n      // Scanning is a performance optimization trade-off.\n\n      //TODO use termsEnum.docFreq() as heuristic\n      boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n      if (!scan) {\n        //Divide & conquer (ultimately termsEnum.seek())\n\n        Iterator<Cell> subCellsIter = findSubCellsToVisit(cell);\n        if (!subCellsIter.hasNext())//not expected\n          return;\n        curVNode.children = new VNodeCellIterator(subCellsIter, new VNode(curVNode));\n\n      } else {\n        //Scan (loop of termsEnum.next())\n\n        scan(detailLevel);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c6c7011603e29f861f395fd2799b2ac2aa6e46da","date":1399596428,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#addIntersectingChildren().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#addIntersectingChildren().mjava","sourceNew":"    /** Called initially, and whenever {@link #visit(org.apache.lucene.spatial.prefix.tree.Cell)}\n     * returns true. */\n    private void addIntersectingChildren() throws IOException {\n      assert thisTerm != null;\n      Cell cell = curVNode.cell;\n      if (cell.getLevel() >= detailLevel)\n        throw new IllegalStateException(\"Spatial logic error\");\n\n      //Check for adjacent leaf (happens for indexed non-point shapes)\n      if (hasIndexedLeaves && cell.getLevel() != 0) {\n        //If the next indexed term just adds a leaf marker ('+') to cell,\n        // then add all of those docs\n        scanCell = grid.readCell(thisTerm, scanCell);\n        assert curVNode.cell.isPrefixOf(scanCell);\n        if (scanCell.getLevel() == cell.getLevel() && scanCell.isLeaf()) {\n          visitLeaf(scanCell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            return; // all done\n        }\n      }\n\n      //Decide whether to continue to divide & conquer, or whether it's time to\n      // scan through terms beneath this cell.\n      // Scanning is a performance optimization trade-off.\n\n      //TODO use termsEnum.docFreq() as heuristic\n      boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n      if (!scan) {\n        //Divide & conquer (ultimately termsEnum.seek())\n\n        Iterator<Cell> subCellsIter = findSubCellsToVisit(cell);\n        if (!subCellsIter.hasNext())//not expected\n          return;\n        curVNode.children = new VNodeCellIterator(subCellsIter, new VNode(curVNode));\n\n      } else {\n        //Scan (loop of termsEnum.next())\n\n        scan(detailLevel);\n      }\n    }\n\n","sourceOld":"    /** Called initially, and whenever {@link #visit(org.apache.lucene.spatial.prefix.tree.Cell)}\n     * returns true. */\n    private void addIntersectingChildren() throws IOException {\n      assert thisTerm != null;\n      Cell cell = curVNode.cell;\n      if (cell.getLevel() >= detailLevel)\n        throw new IllegalStateException(\"Spatial logic error\");\n\n      //Check for adjacent leaf (happens for indexed non-point shapes)\n      if (hasIndexedLeaves && cell.getLevel() != 0) {\n        //If the next indexed term just adds a leaf marker ('+') to cell,\n        // then add all of those docs\n        scanCell.readCell(thisTerm);\n        assert curVNode.cell.isPrefixOf(scanCell);\n        if (scanCell.getLevel() == cell.getLevel() && scanCell.isLeaf()) {\n          visitLeaf(scanCell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            return; // all done\n        }\n      }\n\n      //Decide whether to continue to divide & conquer, or whether it's time to\n      // scan through terms beneath this cell.\n      // Scanning is a performance optimization trade-off.\n\n      //TODO use termsEnum.docFreq() as heuristic\n      boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n      if (!scan) {\n        //Divide & conquer (ultimately termsEnum.seek())\n\n        Iterator<Cell> subCellsIter = findSubCellsToVisit(cell);\n        if (!subCellsIter.hasNext())//not expected\n          return;\n        curVNode.children = new VNodeCellIterator(subCellsIter, new VNode(curVNode));\n\n      } else {\n        //Scan (loop of termsEnum.next())\n\n        scan(detailLevel);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"34b3795e235066cdfe382d88a214eb4bb559f4af","date":1400016324,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#addIntersectingChildren().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#addIntersectingChildren().mjava","sourceNew":"    /** Called initially, and whenever {@link #visit(org.apache.lucene.spatial.prefix.tree.Cell)}\n     * returns true. */\n    private void addIntersectingChildren() throws IOException {\n      assert thisTerm != null;\n      Cell cell = curVNode.cell;\n      if (cell.getLevel() >= detailLevel)\n        throw new IllegalStateException(\"Spatial logic error\");\n\n      //Check for adjacent leaf (happens for indexed non-point shapes)\n      if (hasIndexedLeaves && cell.getLevel() != 0) {\n        //If the next indexed term just adds a leaf marker to cell,\n        // then add all of those docs\n        scanCell = grid.readCell(thisTerm, scanCell);\n        assert curVNode.cell.isPrefixOf(scanCell) : \"missing leaf or descendants\";\n        if (scanCell.getLevel() == cell.getLevel() && scanCell.isLeaf()) {\n          visitLeaf(scanCell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            return; // all done\n        }\n      }\n\n      //Decide whether to continue to divide & conquer, or whether it's time to\n      // scan through terms beneath this cell.\n      // Scanning is a performance optimization trade-off.\n\n      //TODO use termsEnum.docFreq() as heuristic\n      boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n      if (!scan) {\n        //Divide & conquer (ultimately termsEnum.seek())\n\n        Iterator<Cell> subCellsIter = findSubCellsToVisit(cell);\n        if (!subCellsIter.hasNext())//not expected\n          return;\n        curVNode.children = new VNodeCellIterator(subCellsIter, new VNode(curVNode));\n\n      } else {\n        //Scan (loop of termsEnum.next())\n\n        scan(detailLevel);\n      }\n    }\n\n","sourceOld":"    /** Called initially, and whenever {@link #visit(org.apache.lucene.spatial.prefix.tree.Cell)}\n     * returns true. */\n    private void addIntersectingChildren() throws IOException {\n      assert thisTerm != null;\n      Cell cell = curVNode.cell;\n      if (cell.getLevel() >= detailLevel)\n        throw new IllegalStateException(\"Spatial logic error\");\n\n      //Check for adjacent leaf (happens for indexed non-point shapes)\n      if (hasIndexedLeaves && cell.getLevel() != 0) {\n        //If the next indexed term just adds a leaf marker ('+') to cell,\n        // then add all of those docs\n        scanCell = grid.readCell(thisTerm, scanCell);\n        assert curVNode.cell.isPrefixOf(scanCell);\n        if (scanCell.getLevel() == cell.getLevel() && scanCell.isLeaf()) {\n          visitLeaf(scanCell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            return; // all done\n        }\n      }\n\n      //Decide whether to continue to divide & conquer, or whether it's time to\n      // scan through terms beneath this cell.\n      // Scanning is a performance optimization trade-off.\n\n      //TODO use termsEnum.docFreq() as heuristic\n      boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n      if (!scan) {\n        //Divide & conquer (ultimately termsEnum.seek())\n\n        Iterator<Cell> subCellsIter = findSubCellsToVisit(cell);\n        if (!subCellsIter.hasNext())//not expected\n          return;\n        curVNode.children = new VNodeCellIterator(subCellsIter, new VNode(curVNode));\n\n      } else {\n        //Scan (loop of termsEnum.next())\n\n        scan(detailLevel);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a957bf27202eab1c9ddabc5aa30c7a0db04bbf36","date":1400053604,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#addIntersectingChildren().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#addIntersectingChildren().mjava","sourceNew":"    /** Called initially, and whenever {@link #visit(org.apache.lucene.spatial.prefix.tree.Cell)}\n     * returns true. */\n    private void addIntersectingChildren() throws IOException {\n      assert thisTerm != null;\n      Cell cell = curVNode.cell;\n      if (cell.getLevel() >= detailLevel)\n        throw new IllegalStateException(\"Spatial logic error\");\n\n      //Check for adjacent leaf (happens for indexed non-point shapes)\n      if (hasIndexedLeaves && cell.getLevel() != 0) {\n        //If the next indexed term just adds a leaf marker to cell,\n        // then add all of those docs\n        scanCell = grid.readCell(thisTerm, scanCell);\n        assert curVNode.cell.isPrefixOf(scanCell) : \"missing leaf or descendants\";\n        if (scanCell.getLevel() == cell.getLevel() && scanCell.isLeaf()) {\n          visitLeaf(scanCell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            return; // all done\n        }\n      }\n\n      //Decide whether to continue to divide & conquer, or whether it's time to\n      // scan through terms beneath this cell.\n      // Scanning is a performance optimization trade-off.\n\n      //TODO use termsEnum.docFreq() as heuristic\n      boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n      if (!scan) {\n        //Divide & conquer (ultimately termsEnum.seek())\n\n        Iterator<Cell> subCellsIter = findSubCellsToVisit(cell);\n        if (!subCellsIter.hasNext())//not expected\n          return;\n        curVNode.children = new VNodeCellIterator(subCellsIter, new VNode(curVNode));\n\n      } else {\n        //Scan (loop of termsEnum.next())\n\n        scan(detailLevel);\n      }\n    }\n\n","sourceOld":"    /** Called initially, and whenever {@link #visit(org.apache.lucene.spatial.prefix.tree.Cell)}\n     * returns true. */\n    private void addIntersectingChildren() throws IOException {\n      assert thisTerm != null;\n      Cell cell = curVNode.cell;\n      if (cell.getLevel() >= detailLevel)\n        throw new IllegalStateException(\"Spatial logic error\");\n\n      //Check for adjacent leaf (happens for indexed non-point shapes)\n      if (hasIndexedLeaves && cell.getLevel() != 0) {\n        //If the next indexed term just adds a leaf marker ('+') to cell,\n        // then add all of those docs\n        scanCell = grid.readCell(thisTerm, scanCell);\n        assert curVNode.cell.isPrefixOf(scanCell);\n        if (scanCell.getLevel() == cell.getLevel() && scanCell.isLeaf()) {\n          visitLeaf(scanCell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            return; // all done\n        }\n      }\n\n      //Decide whether to continue to divide & conquer, or whether it's time to\n      // scan through terms beneath this cell.\n      // Scanning is a performance optimization trade-off.\n\n      //TODO use termsEnum.docFreq() as heuristic\n      boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n      if (!scan) {\n        //Divide & conquer (ultimately termsEnum.seek())\n\n        Iterator<Cell> subCellsIter = findSubCellsToVisit(cell);\n        if (!subCellsIter.hasNext())//not expected\n          return;\n        curVNode.children = new VNodeCellIterator(subCellsIter, new VNode(curVNode));\n\n      } else {\n        //Scan (loop of termsEnum.next())\n\n        scan(detailLevel);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0","date":1426015524,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#addIntersectingChildren().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#addIntersectingChildren().mjava","sourceNew":"    /** Called initially, and whenever {@link #visitPrefix(org.apache.lucene.spatial.prefix.tree.Cell)}\n     * returns true. */\n    private void addIntersectingChildren() throws IOException {\n      assert thisTerm != null;\n      Cell cell = curVNode.cell;\n      if (cell.getLevel() >= detailLevel)\n        throw new IllegalStateException(\"Spatial logic error\");\n\n      //Decide whether to continue to divide & conquer, or whether it's time to\n      // scan through terms beneath this cell.\n      // Scanning is a performance optimization trade-off.\n\n      //TODO use termsEnum.docFreq() as heuristic\n      boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n      if (!scan) {\n        //Divide & conquer (ultimately termsEnum.seek())\n\n        Iterator<Cell> subCellsIter = findSubCellsToVisit(cell);\n        if (!subCellsIter.hasNext())//not expected\n          return;\n        curVNode.children = new VNodeCellIterator(subCellsIter, new VNode(curVNode));\n\n      } else {\n        //Scan (loop of termsEnum.next())\n\n        scan(detailLevel);\n      }\n    }\n\n","sourceOld":"    /** Called initially, and whenever {@link #visit(org.apache.lucene.spatial.prefix.tree.Cell)}\n     * returns true. */\n    private void addIntersectingChildren() throws IOException {\n      assert thisTerm != null;\n      Cell cell = curVNode.cell;\n      if (cell.getLevel() >= detailLevel)\n        throw new IllegalStateException(\"Spatial logic error\");\n\n      //Check for adjacent leaf (happens for indexed non-point shapes)\n      if (hasIndexedLeaves && cell.getLevel() != 0) {\n        //If the next indexed term just adds a leaf marker to cell,\n        // then add all of those docs\n        scanCell = grid.readCell(thisTerm, scanCell);\n        assert curVNode.cell.isPrefixOf(scanCell) : \"missing leaf or descendants\";\n        if (scanCell.getLevel() == cell.getLevel() && scanCell.isLeaf()) {\n          visitLeaf(scanCell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            return; // all done\n        }\n      }\n\n      //Decide whether to continue to divide & conquer, or whether it's time to\n      // scan through terms beneath this cell.\n      // Scanning is a performance optimization trade-off.\n\n      //TODO use termsEnum.docFreq() as heuristic\n      boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n      if (!scan) {\n        //Divide & conquer (ultimately termsEnum.seek())\n\n        Iterator<Cell> subCellsIter = findSubCellsToVisit(cell);\n        if (!subCellsIter.hasNext())//not expected\n          return;\n        curVNode.children = new VNodeCellIterator(subCellsIter, new VNode(curVNode));\n\n      } else {\n        //Scan (loop of termsEnum.next())\n\n        scan(detailLevel);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#addIntersectingChildren().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#addIntersectingChildren().mjava","sourceNew":"    /** Called initially, and whenever {@link #visitPrefix(org.apache.lucene.spatial.prefix.tree.Cell)}\n     * returns true. */\n    private void addIntersectingChildren() throws IOException {\n      assert thisTerm != null;\n      Cell cell = curVNode.cell;\n      if (cell.getLevel() >= detailLevel)\n        throw new IllegalStateException(\"Spatial logic error\");\n\n      //Decide whether to continue to divide & conquer, or whether it's time to\n      // scan through terms beneath this cell.\n      // Scanning is a performance optimization trade-off.\n\n      //TODO use termsEnum.docFreq() as heuristic\n      boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n      if (!scan) {\n        //Divide & conquer (ultimately termsEnum.seek())\n\n        Iterator<Cell> subCellsIter = findSubCellsToVisit(cell);\n        if (!subCellsIter.hasNext())//not expected\n          return;\n        curVNode.children = new VNodeCellIterator(subCellsIter, new VNode(curVNode));\n\n      } else {\n        //Scan (loop of termsEnum.next())\n\n        scan(detailLevel);\n      }\n    }\n\n","sourceOld":"    /** Called initially, and whenever {@link #visit(org.apache.lucene.spatial.prefix.tree.Cell)}\n     * returns true. */\n    private void addIntersectingChildren() throws IOException {\n      assert thisTerm != null;\n      Cell cell = curVNode.cell;\n      if (cell.getLevel() >= detailLevel)\n        throw new IllegalStateException(\"Spatial logic error\");\n\n      //Check for adjacent leaf (happens for indexed non-point shapes)\n      if (hasIndexedLeaves && cell.getLevel() != 0) {\n        //If the next indexed term just adds a leaf marker to cell,\n        // then add all of those docs\n        scanCell = grid.readCell(thisTerm, scanCell);\n        assert curVNode.cell.isPrefixOf(scanCell) : \"missing leaf or descendants\";\n        if (scanCell.getLevel() == cell.getLevel() && scanCell.isLeaf()) {\n          visitLeaf(scanCell);\n          //advance\n          if ((thisTerm = termsEnum.next()) == null)\n            return; // all done\n        }\n      }\n\n      //Decide whether to continue to divide & conquer, or whether it's time to\n      // scan through terms beneath this cell.\n      // Scanning is a performance optimization trade-off.\n\n      //TODO use termsEnum.docFreq() as heuristic\n      boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n      if (!scan) {\n        //Divide & conquer (ultimately termsEnum.seek())\n\n        Iterator<Cell> subCellsIter = findSubCellsToVisit(cell);\n        if (!subCellsIter.hasNext())//not expected\n          return;\n        curVNode.children = new VNodeCellIterator(subCellsIter, new VNode(curVNode));\n\n      } else {\n        //Scan (loop of termsEnum.next())\n\n        scan(detailLevel);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"672b198fc3dce868916c727917cae58c2906763d","date":1443669960,"type":5,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeQuery.VisitorTemplate#addIntersectingChildren().mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.VisitorTemplate#addIntersectingChildren().mjava","sourceNew":"    /** Called initially, and whenever {@link #visitPrefix(org.apache.lucene.spatial.prefix.tree.Cell)}\n     * returns true. */\n    private void addIntersectingChildren() throws IOException {\n      assert thisTerm != null;\n      Cell cell = curVNode.cell;\n      if (cell.getLevel() >= detailLevel)\n        throw new IllegalStateException(\"Spatial logic error\");\n\n      //Decide whether to continue to divide & conquer, or whether it's time to\n      // scan through terms beneath this cell.\n      // Scanning is a performance optimization trade-off.\n\n      //TODO use termsEnum.docFreq() as heuristic\n      boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n      if (!scan) {\n        //Divide & conquer (ultimately termsEnum.seek())\n\n        Iterator<Cell> subCellsIter = findSubCellsToVisit(cell);\n        if (!subCellsIter.hasNext())//not expected\n          return;\n        curVNode.children = new VNodeCellIterator(subCellsIter, new VNode(curVNode));\n\n      } else {\n        //Scan (loop of termsEnum.next())\n\n        scan(detailLevel);\n      }\n    }\n\n","sourceOld":"    /** Called initially, and whenever {@link #visitPrefix(org.apache.lucene.spatial.prefix.tree.Cell)}\n     * returns true. */\n    private void addIntersectingChildren() throws IOException {\n      assert thisTerm != null;\n      Cell cell = curVNode.cell;\n      if (cell.getLevel() >= detailLevel)\n        throw new IllegalStateException(\"Spatial logic error\");\n\n      //Decide whether to continue to divide & conquer, or whether it's time to\n      // scan through terms beneath this cell.\n      // Scanning is a performance optimization trade-off.\n\n      //TODO use termsEnum.docFreq() as heuristic\n      boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic\n\n      if (!scan) {\n        //Divide & conquer (ultimately termsEnum.seek())\n\n        Iterator<Cell> subCellsIter = findSubCellsToVisit(cell);\n        if (!subCellsIter.hasNext())//not expected\n          return;\n        curVNode.children = new VNodeCellIterator(subCellsIter, new VNode(curVNode));\n\n      } else {\n        //Scan (loop of termsEnum.next())\n\n        scan(detailLevel);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"efc64259f3c8f43dfc6841ffad77df3b9446e3a5":["8259c159da2de2e8528524fb76b244b46cbded59"],"c6c7011603e29f861f395fd2799b2ac2aa6e46da":["8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6"],"8259c159da2de2e8528524fb76b244b46cbded59":["5aeecf64d57563b4636e7f4222e7ddcde7f8df7b"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["34b3795e235066cdfe382d88a214eb4bb559f4af","11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0"],"672b198fc3dce868916c727917cae58c2906763d":["11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":["efc64259f3c8f43dfc6841ffad77df3b9446e3a5","4de14be4bd1b857ba37ca138b61c4661c6d1bed3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"34b3795e235066cdfe382d88a214eb4bb559f4af":["c6c7011603e29f861f395fd2799b2ac2aa6e46da"],"4de14be4bd1b857ba37ca138b61c4661c6d1bed3":["efc64259f3c8f43dfc6841ffad77df3b9446e3a5"],"8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6":["4de14be4bd1b857ba37ca138b61c4661c6d1bed3"],"a957bf27202eab1c9ddabc5aa30c7a0db04bbf36":["c6c7011603e29f861f395fd2799b2ac2aa6e46da","34b3795e235066cdfe382d88a214eb4bb559f4af"],"11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0":["34b3795e235066cdfe382d88a214eb4bb559f4af"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["672b198fc3dce868916c727917cae58c2906763d"],"5aeecf64d57563b4636e7f4222e7ddcde7f8df7b":["c659c37800c0dfd82fa025b5834f4ab065903d11"],"c659c37800c0dfd82fa025b5834f4ab065903d11":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"efc64259f3c8f43dfc6841ffad77df3b9446e3a5":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","4de14be4bd1b857ba37ca138b61c4661c6d1bed3"],"c6c7011603e29f861f395fd2799b2ac2aa6e46da":["34b3795e235066cdfe382d88a214eb4bb559f4af","a957bf27202eab1c9ddabc5aa30c7a0db04bbf36"],"8259c159da2de2e8528524fb76b244b46cbded59":["efc64259f3c8f43dfc6841ffad77df3b9446e3a5"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"672b198fc3dce868916c727917cae58c2906763d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c659c37800c0dfd82fa025b5834f4ab065903d11"],"34b3795e235066cdfe382d88a214eb4bb559f4af":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","a957bf27202eab1c9ddabc5aa30c7a0db04bbf36","11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0"],"4de14be4bd1b857ba37ca138b61c4661c6d1bed3":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6"],"8cbeee6a8b7dcd5efc02f4d24cef933a45e065e6":["c6c7011603e29f861f395fd2799b2ac2aa6e46da"],"a957bf27202eab1c9ddabc5aa30c7a0db04bbf36":[],"11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","672b198fc3dce868916c727917cae58c2906763d"],"5aeecf64d57563b4636e7f4222e7ddcde7f8df7b":["8259c159da2de2e8528524fb76b244b46cbded59"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"c659c37800c0dfd82fa025b5834f4ab065903d11":["5aeecf64d57563b4636e7f4222e7ddcde7f8df7b"]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","15e323346eac5e4685c0a9f2df85eb96b4239bbb","a957bf27202eab1c9ddabc5aa30c7a0db04bbf36","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}