{"path":"backwards/src/test/org/apache/lucene/index/TestIndexInput#testSkipChars().mjava","commits":[{"id":"480d01e5b0ef8efb136d51670fec297ae5ae2c9c","date":1268821447,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"backwards/src/test/org/apache/lucene/index/TestIndexInput#testSkipChars().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Expert\n   *\n   * @throws IOException\n   */\n  public void testSkipChars() throws IOException {\n    byte[] bytes = new byte[]{(byte) 0x80, 0x01,\n            (byte) 0xFF, 0x7F,\n            (byte) 0x80, (byte) 0x80, 0x01,\n            (byte) 0x81, (byte) 0x80, 0x01,\n            0x06, 'L', 'u', 'c', 'e', 'n', 'e',\n    };\n    String utf8Str = \"\\u0634\\u1ea1\";\n    byte [] utf8Bytes = utf8Str.getBytes(\"UTF-8\");\n    byte [] theBytes = new byte[bytes.length + 1 + utf8Bytes.length];\n    System.arraycopy(bytes, 0, theBytes, 0, bytes.length);\n    theBytes[bytes.length] = (byte)utf8Str.length();//Add in the number of chars we are storing, which should fit in a byte for this test \n    System.arraycopy(utf8Bytes, 0, theBytes, bytes.length + 1, utf8Bytes.length);\n    IndexInput is = new MockIndexInput(theBytes);\n    assertEquals(128, is.readVInt());\n    assertEquals(16383, is.readVInt());\n    assertEquals(16384, is.readVInt());\n    assertEquals(16385, is.readVInt());\n    int charsToRead = is.readVInt();//number of chars in the Lucene string\n    assertTrue(0x06 + \" does not equal: \" + charsToRead, 0x06 == charsToRead);\n    is.skipChars(3);\n    char [] chars = new char[3];//there should be 6 chars remaining\n    is.readChars(chars, 0, 3);\n    String tmpStr = new String(chars);\n    assertTrue(tmpStr + \" is not equal to \" + \"ene\", tmpStr.equals(\"ene\" ) == true);\n    //Now read the UTF8 stuff\n    charsToRead = is.readVInt() - 1;//since we are skipping one\n    is.skipChars(1);\n    assertTrue(utf8Str.length() - 1 + \" does not equal: \" + charsToRead, utf8Str.length() - 1 == charsToRead);\n    chars = new char[charsToRead];\n    is.readChars(chars, 0, charsToRead);\n    tmpStr = new String(chars);\n    assertTrue(tmpStr + \" is not equal to \" + utf8Str.substring(1), tmpStr.equals(utf8Str.substring(1)) == true);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/backwards/src/test/org/apache/lucene/index/TestIndexInput#testSkipChars().mjava","pathOld":"backwards/src/test/org/apache/lucene/index/TestIndexInput#testSkipChars().mjava","sourceNew":"  /**\n   * Expert\n   *\n   * @throws IOException\n   */\n  public void testSkipChars() throws IOException {\n    byte[] bytes = new byte[]{(byte) 0x80, 0x01,\n            (byte) 0xFF, 0x7F,\n            (byte) 0x80, (byte) 0x80, 0x01,\n            (byte) 0x81, (byte) 0x80, 0x01,\n            0x06, 'L', 'u', 'c', 'e', 'n', 'e',\n    };\n    String utf8Str = \"\\u0634\\u1ea1\";\n    byte [] utf8Bytes = utf8Str.getBytes(\"UTF-8\");\n    byte [] theBytes = new byte[bytes.length + 1 + utf8Bytes.length];\n    System.arraycopy(bytes, 0, theBytes, 0, bytes.length);\n    theBytes[bytes.length] = (byte)utf8Str.length();//Add in the number of chars we are storing, which should fit in a byte for this test \n    System.arraycopy(utf8Bytes, 0, theBytes, bytes.length + 1, utf8Bytes.length);\n    IndexInput is = new MockIndexInput(theBytes);\n    assertEquals(128, is.readVInt());\n    assertEquals(16383, is.readVInt());\n    assertEquals(16384, is.readVInt());\n    assertEquals(16385, is.readVInt());\n    int charsToRead = is.readVInt();//number of chars in the Lucene string\n    assertTrue(0x06 + \" does not equal: \" + charsToRead, 0x06 == charsToRead);\n    is.skipChars(3);\n    char [] chars = new char[3];//there should be 6 chars remaining\n    is.readChars(chars, 0, 3);\n    String tmpStr = new String(chars);\n    assertTrue(tmpStr + \" is not equal to \" + \"ene\", tmpStr.equals(\"ene\" ) == true);\n    //Now read the UTF8 stuff\n    charsToRead = is.readVInt() - 1;//since we are skipping one\n    is.skipChars(1);\n    assertTrue(utf8Str.length() - 1 + \" does not equal: \" + charsToRead, utf8Str.length() - 1 == charsToRead);\n    chars = new char[charsToRead];\n    is.readChars(chars, 0, charsToRead);\n    tmpStr = new String(chars);\n    assertTrue(tmpStr + \" is not equal to \" + utf8Str.substring(1), tmpStr.equals(utf8Str.substring(1)) == true);\n  }\n\n","sourceOld":"  /**\n   * Expert\n   *\n   * @throws IOException\n   */\n  public void testSkipChars() throws IOException {\n    byte[] bytes = new byte[]{(byte) 0x80, 0x01,\n            (byte) 0xFF, 0x7F,\n            (byte) 0x80, (byte) 0x80, 0x01,\n            (byte) 0x81, (byte) 0x80, 0x01,\n            0x06, 'L', 'u', 'c', 'e', 'n', 'e',\n    };\n    String utf8Str = \"\\u0634\\u1ea1\";\n    byte [] utf8Bytes = utf8Str.getBytes(\"UTF-8\");\n    byte [] theBytes = new byte[bytes.length + 1 + utf8Bytes.length];\n    System.arraycopy(bytes, 0, theBytes, 0, bytes.length);\n    theBytes[bytes.length] = (byte)utf8Str.length();//Add in the number of chars we are storing, which should fit in a byte for this test \n    System.arraycopy(utf8Bytes, 0, theBytes, bytes.length + 1, utf8Bytes.length);\n    IndexInput is = new MockIndexInput(theBytes);\n    assertEquals(128, is.readVInt());\n    assertEquals(16383, is.readVInt());\n    assertEquals(16384, is.readVInt());\n    assertEquals(16385, is.readVInt());\n    int charsToRead = is.readVInt();//number of chars in the Lucene string\n    assertTrue(0x06 + \" does not equal: \" + charsToRead, 0x06 == charsToRead);\n    is.skipChars(3);\n    char [] chars = new char[3];//there should be 6 chars remaining\n    is.readChars(chars, 0, 3);\n    String tmpStr = new String(chars);\n    assertTrue(tmpStr + \" is not equal to \" + \"ene\", tmpStr.equals(\"ene\" ) == true);\n    //Now read the UTF8 stuff\n    charsToRead = is.readVInt() - 1;//since we are skipping one\n    is.skipChars(1);\n    assertTrue(utf8Str.length() - 1 + \" does not equal: \" + charsToRead, utf8Str.length() - 1 == charsToRead);\n    chars = new char[charsToRead];\n    is.readChars(chars, 0, charsToRead);\n    tmpStr = new String(chars);\n    assertTrue(tmpStr + \" is not equal to \" + utf8Str.substring(1), tmpStr.equals(utf8Str.substring(1)) == true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"480d01e5b0ef8efb136d51670fec297ae5ae2c9c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["480d01e5b0ef8efb136d51670fec297ae5ae2c9c"]},"commit2Childs":{"480d01e5b0ef8efb136d51670fec297ae5ae2c9c":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["480d01e5b0ef8efb136d51670fec297ae5ae2c9c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}