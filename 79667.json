{"path":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.Info#prepareDocValuesAndPointValues().mjava","commits":[{"id":"74d5d70ec9df9b59ea6d0dbdb5f7af1991ba7275","date":1458043999,"type":0,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.Info#prepareDocValuesAndPointValues().mjava","pathOld":"/dev/null","sourceNew":"    void prepareDocValuesAndPointValues() {\n      if (preparedDocValuesAndPointValues == false) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.NUMERIC || dvType == DocValuesType.SORTED_NUMERIC) {\n          numericProducer.prepareForUsage();\n        }\n        if (dvType == DocValuesType.BINARY || dvType == DocValuesType.SORTED || dvType == DocValuesType.SORTED_SET) {\n          binaryProducer.prepareForUsage();\n        }\n        if (pointValues != null) {\n          assert pointValues[0].bytes.length == pointValues[0].length : \"BytesRef should wrap a precise byte[], BytesRef.deepCopyOf() should take care of this\";\n\n          final int numDimensions = fieldInfo.getPointDimensionCount();\n          final int numBytesPerDimension = fieldInfo.getPointNumBytes();\n          minPackedValue = pointValues[0].bytes.clone();\n          maxPackedValue = pointValues[0].bytes.clone();\n\n          for (int i = 0; i < pointValuesCount; i++) {\n            BytesRef pointValue = pointValues[i];\n            assert pointValue.bytes.length == pointValue.length : \"BytesRef should wrap a precise byte[], BytesRef.deepCopyOf() should take care of this\";\n\n            for (int dim = 0; dim < numDimensions; ++dim) {\n              int offset = dim * numBytesPerDimension;\n              if (StringHelper.compare(numBytesPerDimension, pointValue.bytes, offset, minPackedValue, offset) < 0) {\n                System.arraycopy(pointValue.bytes, offset, minPackedValue, offset, numBytesPerDimension);\n              }\n              if (StringHelper.compare(numBytesPerDimension, pointValue.bytes, offset, maxPackedValue, offset) > 0) {\n                System.arraycopy(pointValue.bytes, offset, maxPackedValue, offset, numBytesPerDimension);\n              }\n            }\n          }\n        }\n        preparedDocValuesAndPointValues = true;\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["aecfbeab5c1d13c4260cefe5efbd6e48a47bda5d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aecfbeab5c1d13c4260cefe5efbd6e48a47bda5d","date":1496915544,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.Info#prepareDocValuesAndPointValues().mjava","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.Info#prepareDocValuesAndPointValues().mjava","sourceNew":"    void prepareDocValuesAndPointValues() {\n      if (preparedDocValuesAndPointValues == false) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.NUMERIC || dvType == DocValuesType.SORTED_NUMERIC) {\n          numericProducer.prepareForUsage();\n        }\n        if (dvType == DocValuesType.BINARY || dvType == DocValuesType.SORTED || dvType == DocValuesType.SORTED_SET) {\n          binaryProducer.prepareForUsage();\n        }\n        if (pointValues != null) {\n          assert pointValues[0].bytes.length == pointValues[0].length : \"BytesRef should wrap a precise byte[], BytesRef.deepCopyOf() should take care of this\";\n\n          final int numDimensions = fieldInfo.getPointDimensionCount();\n          final int numBytesPerDimension = fieldInfo.getPointNumBytes();\n          if (numDimensions == 1) {\n            // PointInSetQuery.MergePointVisitor expects values to be visited in increasing order,\n            // this is a 1d optimization which has to be done here too. Otherwise we emit values\n            // out of order which causes mismatches.\n            Arrays.sort(pointValues, 0, pointValuesCount);\n            minPackedValue = pointValues[0].bytes.clone();\n            maxPackedValue = pointValues[pointValuesCount - 1].bytes.clone();\n          } else {\n            minPackedValue = pointValues[0].bytes.clone();\n            maxPackedValue = pointValues[0].bytes.clone();\n            for (int i = 0; i < pointValuesCount; i++) {\n              BytesRef pointValue = pointValues[i];\n              assert pointValue.bytes.length == pointValue.length : \"BytesRef should wrap a precise byte[], BytesRef.deepCopyOf() should take care of this\";\n              for (int dim = 0; dim < numDimensions; ++dim) {\n                int offset = dim * numBytesPerDimension;\n                if (StringHelper.compare(numBytesPerDimension, pointValue.bytes, offset, minPackedValue, offset) < 0) {\n                  System.arraycopy(pointValue.bytes, offset, minPackedValue, offset, numBytesPerDimension);\n                }\n                if (StringHelper.compare(numBytesPerDimension, pointValue.bytes, offset, maxPackedValue, offset) > 0) {\n                  System.arraycopy(pointValue.bytes, offset, maxPackedValue, offset, numBytesPerDimension);\n                }\n              }\n            }\n          }\n        }\n        preparedDocValuesAndPointValues = true;\n      }\n    }\n\n","sourceOld":"    void prepareDocValuesAndPointValues() {\n      if (preparedDocValuesAndPointValues == false) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.NUMERIC || dvType == DocValuesType.SORTED_NUMERIC) {\n          numericProducer.prepareForUsage();\n        }\n        if (dvType == DocValuesType.BINARY || dvType == DocValuesType.SORTED || dvType == DocValuesType.SORTED_SET) {\n          binaryProducer.prepareForUsage();\n        }\n        if (pointValues != null) {\n          assert pointValues[0].bytes.length == pointValues[0].length : \"BytesRef should wrap a precise byte[], BytesRef.deepCopyOf() should take care of this\";\n\n          final int numDimensions = fieldInfo.getPointDimensionCount();\n          final int numBytesPerDimension = fieldInfo.getPointNumBytes();\n          minPackedValue = pointValues[0].bytes.clone();\n          maxPackedValue = pointValues[0].bytes.clone();\n\n          for (int i = 0; i < pointValuesCount; i++) {\n            BytesRef pointValue = pointValues[i];\n            assert pointValue.bytes.length == pointValue.length : \"BytesRef should wrap a precise byte[], BytesRef.deepCopyOf() should take care of this\";\n\n            for (int dim = 0; dim < numDimensions; ++dim) {\n              int offset = dim * numBytesPerDimension;\n              if (StringHelper.compare(numBytesPerDimension, pointValue.bytes, offset, minPackedValue, offset) < 0) {\n                System.arraycopy(pointValue.bytes, offset, minPackedValue, offset, numBytesPerDimension);\n              }\n              if (StringHelper.compare(numBytesPerDimension, pointValue.bytes, offset, maxPackedValue, offset) > 0) {\n                System.arraycopy(pointValue.bytes, offset, maxPackedValue, offset, numBytesPerDimension);\n              }\n            }\n          }\n        }\n        preparedDocValuesAndPointValues = true;\n      }\n    }\n\n","bugFix":["74d5d70ec9df9b59ea6d0dbdb5f7af1991ba7275"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.Info#prepareDocValuesAndPointValues().mjava","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.Info#prepareDocValuesAndPointValues().mjava","sourceNew":"    void prepareDocValuesAndPointValues() {\n      if (preparedDocValuesAndPointValues == false) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.NUMERIC || dvType == DocValuesType.SORTED_NUMERIC) {\n          numericProducer.prepareForUsage();\n        }\n        if (dvType == DocValuesType.BINARY || dvType == DocValuesType.SORTED || dvType == DocValuesType.SORTED_SET) {\n          binaryProducer.prepareForUsage();\n        }\n        if (pointValues != null) {\n          assert pointValues[0].bytes.length == pointValues[0].length : \"BytesRef should wrap a precise byte[], BytesRef.deepCopyOf() should take care of this\";\n\n          final int numDimensions = fieldInfo.getPointDimensionCount();\n          final int numBytesPerDimension = fieldInfo.getPointNumBytes();\n          if (numDimensions == 1) {\n            // PointInSetQuery.MergePointVisitor expects values to be visited in increasing order,\n            // this is a 1d optimization which has to be done here too. Otherwise we emit values\n            // out of order which causes mismatches.\n            Arrays.sort(pointValues, 0, pointValuesCount);\n            minPackedValue = pointValues[0].bytes.clone();\n            maxPackedValue = pointValues[pointValuesCount - 1].bytes.clone();\n          } else {\n            minPackedValue = pointValues[0].bytes.clone();\n            maxPackedValue = pointValues[0].bytes.clone();\n            for (int i = 0; i < pointValuesCount; i++) {\n              BytesRef pointValue = pointValues[i];\n              assert pointValue.bytes.length == pointValue.length : \"BytesRef should wrap a precise byte[], BytesRef.deepCopyOf() should take care of this\";\n              for (int dim = 0; dim < numDimensions; ++dim) {\n                int offset = dim * numBytesPerDimension;\n                if (StringHelper.compare(numBytesPerDimension, pointValue.bytes, offset, minPackedValue, offset) < 0) {\n                  System.arraycopy(pointValue.bytes, offset, minPackedValue, offset, numBytesPerDimension);\n                }\n                if (StringHelper.compare(numBytesPerDimension, pointValue.bytes, offset, maxPackedValue, offset) > 0) {\n                  System.arraycopy(pointValue.bytes, offset, maxPackedValue, offset, numBytesPerDimension);\n                }\n              }\n            }\n          }\n        }\n        preparedDocValuesAndPointValues = true;\n      }\n    }\n\n","sourceOld":"    void prepareDocValuesAndPointValues() {\n      if (preparedDocValuesAndPointValues == false) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.NUMERIC || dvType == DocValuesType.SORTED_NUMERIC) {\n          numericProducer.prepareForUsage();\n        }\n        if (dvType == DocValuesType.BINARY || dvType == DocValuesType.SORTED || dvType == DocValuesType.SORTED_SET) {\n          binaryProducer.prepareForUsage();\n        }\n        if (pointValues != null) {\n          assert pointValues[0].bytes.length == pointValues[0].length : \"BytesRef should wrap a precise byte[], BytesRef.deepCopyOf() should take care of this\";\n\n          final int numDimensions = fieldInfo.getPointDimensionCount();\n          final int numBytesPerDimension = fieldInfo.getPointNumBytes();\n          minPackedValue = pointValues[0].bytes.clone();\n          maxPackedValue = pointValues[0].bytes.clone();\n\n          for (int i = 0; i < pointValuesCount; i++) {\n            BytesRef pointValue = pointValues[i];\n            assert pointValue.bytes.length == pointValue.length : \"BytesRef should wrap a precise byte[], BytesRef.deepCopyOf() should take care of this\";\n\n            for (int dim = 0; dim < numDimensions; ++dim) {\n              int offset = dim * numBytesPerDimension;\n              if (StringHelper.compare(numBytesPerDimension, pointValue.bytes, offset, minPackedValue, offset) < 0) {\n                System.arraycopy(pointValue.bytes, offset, minPackedValue, offset, numBytesPerDimension);\n              }\n              if (StringHelper.compare(numBytesPerDimension, pointValue.bytes, offset, maxPackedValue, offset) > 0) {\n                System.arraycopy(pointValue.bytes, offset, maxPackedValue, offset, numBytesPerDimension);\n              }\n            }\n          }\n        }\n        preparedDocValuesAndPointValues = true;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.Info#prepareDocValuesAndPointValues().mjava","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.Info#prepareDocValuesAndPointValues().mjava","sourceNew":"    void prepareDocValuesAndPointValues() {\n      if (preparedDocValuesAndPointValues == false) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.NUMERIC || dvType == DocValuesType.SORTED_NUMERIC) {\n          numericProducer.prepareForUsage();\n        }\n        if (dvType == DocValuesType.BINARY || dvType == DocValuesType.SORTED || dvType == DocValuesType.SORTED_SET) {\n          binaryProducer.prepareForUsage();\n        }\n        if (pointValues != null) {\n          assert pointValues[0].bytes.length == pointValues[0].length : \"BytesRef should wrap a precise byte[], BytesRef.deepCopyOf() should take care of this\";\n\n          final int numDimensions = fieldInfo.getPointDimensionCount();\n          final int numBytesPerDimension = fieldInfo.getPointNumBytes();\n          if (numDimensions == 1) {\n            // PointInSetQuery.MergePointVisitor expects values to be visited in increasing order,\n            // this is a 1d optimization which has to be done here too. Otherwise we emit values\n            // out of order which causes mismatches.\n            Arrays.sort(pointValues, 0, pointValuesCount);\n            minPackedValue = pointValues[0].bytes.clone();\n            maxPackedValue = pointValues[pointValuesCount - 1].bytes.clone();\n          } else {\n            minPackedValue = pointValues[0].bytes.clone();\n            maxPackedValue = pointValues[0].bytes.clone();\n            for (int i = 0; i < pointValuesCount; i++) {\n              BytesRef pointValue = pointValues[i];\n              assert pointValue.bytes.length == pointValue.length : \"BytesRef should wrap a precise byte[], BytesRef.deepCopyOf() should take care of this\";\n              for (int dim = 0; dim < numDimensions; ++dim) {\n                int offset = dim * numBytesPerDimension;\n                if (StringHelper.compare(numBytesPerDimension, pointValue.bytes, offset, minPackedValue, offset) < 0) {\n                  System.arraycopy(pointValue.bytes, offset, minPackedValue, offset, numBytesPerDimension);\n                }\n                if (StringHelper.compare(numBytesPerDimension, pointValue.bytes, offset, maxPackedValue, offset) > 0) {\n                  System.arraycopy(pointValue.bytes, offset, maxPackedValue, offset, numBytesPerDimension);\n                }\n              }\n            }\n          }\n        }\n        preparedDocValuesAndPointValues = true;\n      }\n    }\n\n","sourceOld":"    void prepareDocValuesAndPointValues() {\n      if (preparedDocValuesAndPointValues == false) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.NUMERIC || dvType == DocValuesType.SORTED_NUMERIC) {\n          numericProducer.prepareForUsage();\n        }\n        if (dvType == DocValuesType.BINARY || dvType == DocValuesType.SORTED || dvType == DocValuesType.SORTED_SET) {\n          binaryProducer.prepareForUsage();\n        }\n        if (pointValues != null) {\n          assert pointValues[0].bytes.length == pointValues[0].length : \"BytesRef should wrap a precise byte[], BytesRef.deepCopyOf() should take care of this\";\n\n          final int numDimensions = fieldInfo.getPointDimensionCount();\n          final int numBytesPerDimension = fieldInfo.getPointNumBytes();\n          minPackedValue = pointValues[0].bytes.clone();\n          maxPackedValue = pointValues[0].bytes.clone();\n\n          for (int i = 0; i < pointValuesCount; i++) {\n            BytesRef pointValue = pointValues[i];\n            assert pointValue.bytes.length == pointValue.length : \"BytesRef should wrap a precise byte[], BytesRef.deepCopyOf() should take care of this\";\n\n            for (int dim = 0; dim < numDimensions; ++dim) {\n              int offset = dim * numBytesPerDimension;\n              if (StringHelper.compare(numBytesPerDimension, pointValue.bytes, offset, minPackedValue, offset) < 0) {\n                System.arraycopy(pointValue.bytes, offset, minPackedValue, offset, numBytesPerDimension);\n              }\n              if (StringHelper.compare(numBytesPerDimension, pointValue.bytes, offset, maxPackedValue, offset) > 0) {\n                System.arraycopy(pointValue.bytes, offset, maxPackedValue, offset, numBytesPerDimension);\n              }\n            }\n          }\n        }\n        preparedDocValuesAndPointValues = true;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"41f60ea1802fda42d3c91d023406066d00ddb5f8","date":1535615991,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.Info#prepareDocValuesAndPointValues().mjava","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.Info#prepareDocValuesAndPointValues().mjava","sourceNew":"    void prepareDocValuesAndPointValues() {\n      if (preparedDocValuesAndPointValues == false) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.NUMERIC || dvType == DocValuesType.SORTED_NUMERIC) {\n          numericProducer.prepareForUsage();\n        }\n        if (dvType == DocValuesType.BINARY || dvType == DocValuesType.SORTED || dvType == DocValuesType.SORTED_SET) {\n          binaryProducer.prepareForUsage();\n        }\n        if (pointValues != null) {\n          assert pointValues[0].bytes.length == pointValues[0].length : \"BytesRef should wrap a precise byte[], BytesRef.deepCopyOf() should take care of this\";\n\n          final int numDimensions = fieldInfo.getPointDimensionCount();\n          final int numBytesPerDimension = fieldInfo.getPointNumBytes();\n          if (numDimensions == 1) {\n            // PointInSetQuery.MergePointVisitor expects values to be visited in increasing order,\n            // this is a 1d optimization which has to be done here too. Otherwise we emit values\n            // out of order which causes mismatches.\n            Arrays.sort(pointValues, 0, pointValuesCount);\n            minPackedValue = pointValues[0].bytes.clone();\n            maxPackedValue = pointValues[pointValuesCount - 1].bytes.clone();\n          } else {\n            minPackedValue = pointValues[0].bytes.clone();\n            maxPackedValue = pointValues[0].bytes.clone();\n            for (int i = 0; i < pointValuesCount; i++) {\n              BytesRef pointValue = pointValues[i];\n              assert pointValue.bytes.length == pointValue.length : \"BytesRef should wrap a precise byte[], BytesRef.deepCopyOf() should take care of this\";\n              for (int dim = 0; dim < numDimensions; ++dim) {\n                int offset = dim * numBytesPerDimension;\n                if (FutureArrays.compareUnsigned(pointValue.bytes, offset, offset + numBytesPerDimension, minPackedValue, offset, offset + numBytesPerDimension) < 0) {\n                  System.arraycopy(pointValue.bytes, offset, minPackedValue, offset, numBytesPerDimension);\n                }\n                if (FutureArrays.compareUnsigned(pointValue.bytes, offset, offset + numBytesPerDimension, maxPackedValue, offset, offset + numBytesPerDimension) > 0) {\n                  System.arraycopy(pointValue.bytes, offset, maxPackedValue, offset, numBytesPerDimension);\n                }\n              }\n            }\n          }\n        }\n        preparedDocValuesAndPointValues = true;\n      }\n    }\n\n","sourceOld":"    void prepareDocValuesAndPointValues() {\n      if (preparedDocValuesAndPointValues == false) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.NUMERIC || dvType == DocValuesType.SORTED_NUMERIC) {\n          numericProducer.prepareForUsage();\n        }\n        if (dvType == DocValuesType.BINARY || dvType == DocValuesType.SORTED || dvType == DocValuesType.SORTED_SET) {\n          binaryProducer.prepareForUsage();\n        }\n        if (pointValues != null) {\n          assert pointValues[0].bytes.length == pointValues[0].length : \"BytesRef should wrap a precise byte[], BytesRef.deepCopyOf() should take care of this\";\n\n          final int numDimensions = fieldInfo.getPointDimensionCount();\n          final int numBytesPerDimension = fieldInfo.getPointNumBytes();\n          if (numDimensions == 1) {\n            // PointInSetQuery.MergePointVisitor expects values to be visited in increasing order,\n            // this is a 1d optimization which has to be done here too. Otherwise we emit values\n            // out of order which causes mismatches.\n            Arrays.sort(pointValues, 0, pointValuesCount);\n            minPackedValue = pointValues[0].bytes.clone();\n            maxPackedValue = pointValues[pointValuesCount - 1].bytes.clone();\n          } else {\n            minPackedValue = pointValues[0].bytes.clone();\n            maxPackedValue = pointValues[0].bytes.clone();\n            for (int i = 0; i < pointValuesCount; i++) {\n              BytesRef pointValue = pointValues[i];\n              assert pointValue.bytes.length == pointValue.length : \"BytesRef should wrap a precise byte[], BytesRef.deepCopyOf() should take care of this\";\n              for (int dim = 0; dim < numDimensions; ++dim) {\n                int offset = dim * numBytesPerDimension;\n                if (StringHelper.compare(numBytesPerDimension, pointValue.bytes, offset, minPackedValue, offset) < 0) {\n                  System.arraycopy(pointValue.bytes, offset, minPackedValue, offset, numBytesPerDimension);\n                }\n                if (StringHelper.compare(numBytesPerDimension, pointValue.bytes, offset, maxPackedValue, offset) > 0) {\n                  System.arraycopy(pointValue.bytes, offset, maxPackedValue, offset, numBytesPerDimension);\n                }\n              }\n            }\n          }\n        }\n        preparedDocValuesAndPointValues = true;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6652c943595e92c187ee904c382863013eae28f","date":1539042663,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.Info#prepareDocValuesAndPointValues().mjava","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.Info#prepareDocValuesAndPointValues().mjava","sourceNew":"    void prepareDocValuesAndPointValues() {\n      if (preparedDocValuesAndPointValues == false) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.NUMERIC || dvType == DocValuesType.SORTED_NUMERIC) {\n          numericProducer.prepareForUsage();\n        }\n        if (dvType == DocValuesType.BINARY || dvType == DocValuesType.SORTED || dvType == DocValuesType.SORTED_SET) {\n          binaryProducer.prepareForUsage();\n        }\n        if (pointValues != null) {\n          assert pointValues[0].bytes.length == pointValues[0].length : \"BytesRef should wrap a precise byte[], BytesRef.deepCopyOf() should take care of this\";\n\n          final int numDimensions = fieldInfo.getPointDataDimensionCount();\n          final int numBytesPerDimension = fieldInfo.getPointNumBytes();\n          if (numDimensions == 1) {\n            // PointInSetQuery.MergePointVisitor expects values to be visited in increasing order,\n            // this is a 1d optimization which has to be done here too. Otherwise we emit values\n            // out of order which causes mismatches.\n            Arrays.sort(pointValues, 0, pointValuesCount);\n            minPackedValue = pointValues[0].bytes.clone();\n            maxPackedValue = pointValues[pointValuesCount - 1].bytes.clone();\n          } else {\n            minPackedValue = pointValues[0].bytes.clone();\n            maxPackedValue = pointValues[0].bytes.clone();\n            for (int i = 0; i < pointValuesCount; i++) {\n              BytesRef pointValue = pointValues[i];\n              assert pointValue.bytes.length == pointValue.length : \"BytesRef should wrap a precise byte[], BytesRef.deepCopyOf() should take care of this\";\n              for (int dim = 0; dim < numDimensions; ++dim) {\n                int offset = dim * numBytesPerDimension;\n                if (FutureArrays.compareUnsigned(pointValue.bytes, offset, offset + numBytesPerDimension, minPackedValue, offset, offset + numBytesPerDimension) < 0) {\n                  System.arraycopy(pointValue.bytes, offset, minPackedValue, offset, numBytesPerDimension);\n                }\n                if (FutureArrays.compareUnsigned(pointValue.bytes, offset, offset + numBytesPerDimension, maxPackedValue, offset, offset + numBytesPerDimension) > 0) {\n                  System.arraycopy(pointValue.bytes, offset, maxPackedValue, offset, numBytesPerDimension);\n                }\n              }\n            }\n          }\n        }\n        preparedDocValuesAndPointValues = true;\n      }\n    }\n\n","sourceOld":"    void prepareDocValuesAndPointValues() {\n      if (preparedDocValuesAndPointValues == false) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.NUMERIC || dvType == DocValuesType.SORTED_NUMERIC) {\n          numericProducer.prepareForUsage();\n        }\n        if (dvType == DocValuesType.BINARY || dvType == DocValuesType.SORTED || dvType == DocValuesType.SORTED_SET) {\n          binaryProducer.prepareForUsage();\n        }\n        if (pointValues != null) {\n          assert pointValues[0].bytes.length == pointValues[0].length : \"BytesRef should wrap a precise byte[], BytesRef.deepCopyOf() should take care of this\";\n\n          final int numDimensions = fieldInfo.getPointDimensionCount();\n          final int numBytesPerDimension = fieldInfo.getPointNumBytes();\n          if (numDimensions == 1) {\n            // PointInSetQuery.MergePointVisitor expects values to be visited in increasing order,\n            // this is a 1d optimization which has to be done here too. Otherwise we emit values\n            // out of order which causes mismatches.\n            Arrays.sort(pointValues, 0, pointValuesCount);\n            minPackedValue = pointValues[0].bytes.clone();\n            maxPackedValue = pointValues[pointValuesCount - 1].bytes.clone();\n          } else {\n            minPackedValue = pointValues[0].bytes.clone();\n            maxPackedValue = pointValues[0].bytes.clone();\n            for (int i = 0; i < pointValuesCount; i++) {\n              BytesRef pointValue = pointValues[i];\n              assert pointValue.bytes.length == pointValue.length : \"BytesRef should wrap a precise byte[], BytesRef.deepCopyOf() should take care of this\";\n              for (int dim = 0; dim < numDimensions; ++dim) {\n                int offset = dim * numBytesPerDimension;\n                if (FutureArrays.compareUnsigned(pointValue.bytes, offset, offset + numBytesPerDimension, minPackedValue, offset, offset + numBytesPerDimension) < 0) {\n                  System.arraycopy(pointValue.bytes, offset, minPackedValue, offset, numBytesPerDimension);\n                }\n                if (FutureArrays.compareUnsigned(pointValue.bytes, offset, offset + numBytesPerDimension, maxPackedValue, offset, offset + numBytesPerDimension) > 0) {\n                  System.arraycopy(pointValue.bytes, offset, maxPackedValue, offset, numBytesPerDimension);\n                }\n              }\n            }\n          }\n        }\n        preparedDocValuesAndPointValues = true;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b88a121b875f9ae2ac50f85cf46dcb680f126357","date":1555416009,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.Info#prepareDocValuesAndPointValues().mjava","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.Info#prepareDocValuesAndPointValues().mjava","sourceNew":"    void prepareDocValuesAndPointValues() {\n      if (preparedDocValuesAndPointValues == false) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.NUMERIC || dvType == DocValuesType.SORTED_NUMERIC) {\n          numericProducer.prepareForUsage();\n        }\n        if (dvType == DocValuesType.BINARY || dvType == DocValuesType.SORTED || dvType == DocValuesType.SORTED_SET) {\n          binaryProducer.prepareForUsage();\n        }\n        if (pointValues != null) {\n          assert pointValues[0].bytes.length == pointValues[0].length : \"BytesRef should wrap a precise byte[], BytesRef.deepCopyOf() should take care of this\";\n\n          final int numDimensions = fieldInfo.getPointDataDimensionCount();\n          final int numBytesPerDimension = fieldInfo.getPointNumBytes();\n          if (numDimensions == 1) {\n            // PointInSetQuery.MergePointVisitor expects values to be visited in increasing order,\n            // this is a 1d optimization which has to be done here too. Otherwise we emit values\n            // out of order which causes mismatches.\n            Arrays.sort(pointValues, 0, pointValuesCount);\n            minPackedValue = pointValues[0].bytes.clone();\n            maxPackedValue = pointValues[pointValuesCount - 1].bytes.clone();\n          } else {\n            minPackedValue = pointValues[0].bytes.clone();\n            maxPackedValue = pointValues[0].bytes.clone();\n            for (int i = 0; i < pointValuesCount; i++) {\n              BytesRef pointValue = pointValues[i];\n              assert pointValue.bytes.length == pointValue.length : \"BytesRef should wrap a precise byte[], BytesRef.deepCopyOf() should take care of this\";\n              for (int dim = 0; dim < numDimensions; ++dim) {\n                int offset = dim * numBytesPerDimension;\n                if (Arrays.compareUnsigned(pointValue.bytes, offset, offset + numBytesPerDimension, minPackedValue, offset, offset + numBytesPerDimension) < 0) {\n                  System.arraycopy(pointValue.bytes, offset, minPackedValue, offset, numBytesPerDimension);\n                }\n                if (Arrays.compareUnsigned(pointValue.bytes, offset, offset + numBytesPerDimension, maxPackedValue, offset, offset + numBytesPerDimension) > 0) {\n                  System.arraycopy(pointValue.bytes, offset, maxPackedValue, offset, numBytesPerDimension);\n                }\n              }\n            }\n          }\n        }\n        preparedDocValuesAndPointValues = true;\n      }\n    }\n\n","sourceOld":"    void prepareDocValuesAndPointValues() {\n      if (preparedDocValuesAndPointValues == false) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.NUMERIC || dvType == DocValuesType.SORTED_NUMERIC) {\n          numericProducer.prepareForUsage();\n        }\n        if (dvType == DocValuesType.BINARY || dvType == DocValuesType.SORTED || dvType == DocValuesType.SORTED_SET) {\n          binaryProducer.prepareForUsage();\n        }\n        if (pointValues != null) {\n          assert pointValues[0].bytes.length == pointValues[0].length : \"BytesRef should wrap a precise byte[], BytesRef.deepCopyOf() should take care of this\";\n\n          final int numDimensions = fieldInfo.getPointDataDimensionCount();\n          final int numBytesPerDimension = fieldInfo.getPointNumBytes();\n          if (numDimensions == 1) {\n            // PointInSetQuery.MergePointVisitor expects values to be visited in increasing order,\n            // this is a 1d optimization which has to be done here too. Otherwise we emit values\n            // out of order which causes mismatches.\n            Arrays.sort(pointValues, 0, pointValuesCount);\n            minPackedValue = pointValues[0].bytes.clone();\n            maxPackedValue = pointValues[pointValuesCount - 1].bytes.clone();\n          } else {\n            minPackedValue = pointValues[0].bytes.clone();\n            maxPackedValue = pointValues[0].bytes.clone();\n            for (int i = 0; i < pointValuesCount; i++) {\n              BytesRef pointValue = pointValues[i];\n              assert pointValue.bytes.length == pointValue.length : \"BytesRef should wrap a precise byte[], BytesRef.deepCopyOf() should take care of this\";\n              for (int dim = 0; dim < numDimensions; ++dim) {\n                int offset = dim * numBytesPerDimension;\n                if (FutureArrays.compareUnsigned(pointValue.bytes, offset, offset + numBytesPerDimension, minPackedValue, offset, offset + numBytesPerDimension) < 0) {\n                  System.arraycopy(pointValue.bytes, offset, minPackedValue, offset, numBytesPerDimension);\n                }\n                if (FutureArrays.compareUnsigned(pointValue.bytes, offset, offset + numBytesPerDimension, maxPackedValue, offset, offset + numBytesPerDimension) > 0) {\n                  System.arraycopy(pointValue.bytes, offset, maxPackedValue, offset, numBytesPerDimension);\n                }\n              }\n            }\n          }\n        }\n        preparedDocValuesAndPointValues = true;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59ed8c026ba85e3c42fb89605b2032dc6f9cc241","date":1581113294,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.Info#prepareDocValuesAndPointValues().mjava","pathOld":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.Info#prepareDocValuesAndPointValues().mjava","sourceNew":"    void prepareDocValuesAndPointValues() {\n      if (preparedDocValuesAndPointValues == false) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.NUMERIC || dvType == DocValuesType.SORTED_NUMERIC) {\n          numericProducer.prepareForUsage();\n        }\n        if (dvType == DocValuesType.BINARY || dvType == DocValuesType.SORTED || dvType == DocValuesType.SORTED_SET) {\n          binaryProducer.prepareForUsage();\n        }\n        if (pointValues != null) {\n          assert pointValues[0].bytes.length == pointValues[0].length : \"BytesRef should wrap a precise byte[], BytesRef.deepCopyOf() should take care of this\";\n\n          final int numDimensions = fieldInfo.getPointDimensionCount();\n          final int numBytesPerDimension = fieldInfo.getPointNumBytes();\n          if (numDimensions == 1) {\n            // PointInSetQuery.MergePointVisitor expects values to be visited in increasing order,\n            // this is a 1d optimization which has to be done here too. Otherwise we emit values\n            // out of order which causes mismatches.\n            Arrays.sort(pointValues, 0, pointValuesCount);\n            minPackedValue = pointValues[0].bytes.clone();\n            maxPackedValue = pointValues[pointValuesCount - 1].bytes.clone();\n          } else {\n            minPackedValue = pointValues[0].bytes.clone();\n            maxPackedValue = pointValues[0].bytes.clone();\n            for (int i = 0; i < pointValuesCount; i++) {\n              BytesRef pointValue = pointValues[i];\n              assert pointValue.bytes.length == pointValue.length : \"BytesRef should wrap a precise byte[], BytesRef.deepCopyOf() should take care of this\";\n              for (int dim = 0; dim < numDimensions; ++dim) {\n                int offset = dim * numBytesPerDimension;\n                if (Arrays.compareUnsigned(pointValue.bytes, offset, offset + numBytesPerDimension, minPackedValue, offset, offset + numBytesPerDimension) < 0) {\n                  System.arraycopy(pointValue.bytes, offset, minPackedValue, offset, numBytesPerDimension);\n                }\n                if (Arrays.compareUnsigned(pointValue.bytes, offset, offset + numBytesPerDimension, maxPackedValue, offset, offset + numBytesPerDimension) > 0) {\n                  System.arraycopy(pointValue.bytes, offset, maxPackedValue, offset, numBytesPerDimension);\n                }\n              }\n            }\n          }\n        }\n        preparedDocValuesAndPointValues = true;\n      }\n    }\n\n","sourceOld":"    void prepareDocValuesAndPointValues() {\n      if (preparedDocValuesAndPointValues == false) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.NUMERIC || dvType == DocValuesType.SORTED_NUMERIC) {\n          numericProducer.prepareForUsage();\n        }\n        if (dvType == DocValuesType.BINARY || dvType == DocValuesType.SORTED || dvType == DocValuesType.SORTED_SET) {\n          binaryProducer.prepareForUsage();\n        }\n        if (pointValues != null) {\n          assert pointValues[0].bytes.length == pointValues[0].length : \"BytesRef should wrap a precise byte[], BytesRef.deepCopyOf() should take care of this\";\n\n          final int numDimensions = fieldInfo.getPointDataDimensionCount();\n          final int numBytesPerDimension = fieldInfo.getPointNumBytes();\n          if (numDimensions == 1) {\n            // PointInSetQuery.MergePointVisitor expects values to be visited in increasing order,\n            // this is a 1d optimization which has to be done here too. Otherwise we emit values\n            // out of order which causes mismatches.\n            Arrays.sort(pointValues, 0, pointValuesCount);\n            minPackedValue = pointValues[0].bytes.clone();\n            maxPackedValue = pointValues[pointValuesCount - 1].bytes.clone();\n          } else {\n            minPackedValue = pointValues[0].bytes.clone();\n            maxPackedValue = pointValues[0].bytes.clone();\n            for (int i = 0; i < pointValuesCount; i++) {\n              BytesRef pointValue = pointValues[i];\n              assert pointValue.bytes.length == pointValue.length : \"BytesRef should wrap a precise byte[], BytesRef.deepCopyOf() should take care of this\";\n              for (int dim = 0; dim < numDimensions; ++dim) {\n                int offset = dim * numBytesPerDimension;\n                if (Arrays.compareUnsigned(pointValue.bytes, offset, offset + numBytesPerDimension, minPackedValue, offset, offset + numBytesPerDimension) < 0) {\n                  System.arraycopy(pointValue.bytes, offset, minPackedValue, offset, numBytesPerDimension);\n                }\n                if (Arrays.compareUnsigned(pointValue.bytes, offset, offset + numBytesPerDimension, maxPackedValue, offset, offset + numBytesPerDimension) > 0) {\n                  System.arraycopy(pointValue.bytes, offset, maxPackedValue, offset, numBytesPerDimension);\n                }\n              }\n            }\n          }\n        }\n        preparedDocValuesAndPointValues = true;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"74d5d70ec9df9b59ea6d0dbdb5f7af1991ba7275":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"aecfbeab5c1d13c4260cefe5efbd6e48a47bda5d":["74d5d70ec9df9b59ea6d0dbdb5f7af1991ba7275"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["f6652c943595e92c187ee904c382863013eae28f"],"59ed8c026ba85e3c42fb89605b2032dc6f9cc241":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"f6652c943595e92c187ee904c382863013eae28f":["41f60ea1802fda42d3c91d023406066d00ddb5f8"],"41f60ea1802fda42d3c91d023406066d00ddb5f8":["28288370235ed02234a64753cdbf0c6ec096304a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"28288370235ed02234a64753cdbf0c6ec096304a":["74d5d70ec9df9b59ea6d0dbdb5f7af1991ba7275","aecfbeab5c1d13c4260cefe5efbd6e48a47bda5d"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["74d5d70ec9df9b59ea6d0dbdb5f7af1991ba7275","aecfbeab5c1d13c4260cefe5efbd6e48a47bda5d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["59ed8c026ba85e3c42fb89605b2032dc6f9cc241"]},"commit2Childs":{"74d5d70ec9df9b59ea6d0dbdb5f7af1991ba7275":["aecfbeab5c1d13c4260cefe5efbd6e48a47bda5d","28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"aecfbeab5c1d13c4260cefe5efbd6e48a47bda5d":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["59ed8c026ba85e3c42fb89605b2032dc6f9cc241"],"f6652c943595e92c187ee904c382863013eae28f":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"59ed8c026ba85e3c42fb89605b2032dc6f9cc241":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"41f60ea1802fda42d3c91d023406066d00ddb5f8":["f6652c943595e92c187ee904c382863013eae28f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["74d5d70ec9df9b59ea6d0dbdb5f7af1991ba7275"],"28288370235ed02234a64753cdbf0c6ec096304a":["41f60ea1802fda42d3c91d023406066d00ddb5f8"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}