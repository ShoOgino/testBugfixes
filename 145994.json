{"path":"src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(Query,DocSet).mjava","commits":[{"id":"0c3e228bf650e96f3002a8fb73dd0c13d55af077","date":1138253849,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(Query,DocSet).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Returns the set of document ids matching both the query and the filter.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   *\n   * @param query\n   * @param filter may be null\n   */\n  public DocSet getDocSet(Query query, DocSet filter) throws IOException {\n    if (filter==null) return getDocSet(query);\n\n    DocSet first;\n    if (filterCache != null) {\n      first = (DocSet)filterCache.get(query);\n      if (first==null) {\n        first = getDocSetNC(query,null);\n        filterCache.put(query,first);\n      }\n      return first.intersection(filter);\n    }\n\n\n    // If there isn't a cache, then do a single filtered query.\n    return getDocSetNC(query,filter);\n\n\n    /******* OLD VERSION that did a filtered query instead of\n     * an intersection if the query docset wasn't found in the cache.\n     * It made misses != inserts (even if no evictions)\n    DocSet first=null;\n    if (filterCache != null) {\n      first = (DocSet)filterCache.get(query);\n      if (first != null) {\n        return first.intersection(filter);\n      }\n    }\n\n    DocSet answer = getDocSetNC(query, filter);\n    // nothing is inserted into the cache, because we don't cache materialized filters.\n    // Hmmm, we *could* make a hitcollector that made a DocSet out of the query at the\n    // same time it was running the filter though...\n\n    // Q: we could call getDocSet(query) and then take the intersection instead of running\n    // the query as a filter.  Then it could be cached.\n    return answer;\n    ****************/\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e96fd8a5ecee99fb518c16ceb03a6a11c01b5468","date":1148693744,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(Query,DocSet).mjava","pathOld":"src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(Query,DocSet).mjava","sourceNew":"  /**\n   * Returns the set of document ids matching both the query and the filter.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * <p>\n   *\n   * @param query\n   * @param filter may be null\n   * @return DocSet meeting the specified criteria, should <b>not</b> be modified by the caller.\n   */\n  public DocSet getDocSet(Query query, DocSet filter) throws IOException {\n    if (filter==null) return getDocSet(query);\n\n    DocSet first;\n    if (filterCache != null) {\n      first = (DocSet)filterCache.get(query);\n      if (first==null) {\n        first = getDocSetNC(query,null);\n        filterCache.put(query,first);\n      }\n      return first.intersection(filter);\n    }\n\n\n    // If there isn't a cache, then do a single filtered query.\n    return getDocSetNC(query,filter);\n\n\n    /******* OLD VERSION that did a filtered query instead of\n     * an intersection if the query docset wasn't found in the cache.\n     * It made misses != inserts (even if no evictions)\n    DocSet first=null;\n    if (filterCache != null) {\n      first = (DocSet)filterCache.get(query);\n      if (first != null) {\n        return first.intersection(filter);\n      }\n    }\n\n    DocSet answer = getDocSetNC(query, filter);\n    // nothing is inserted into the cache, because we don't cache materialized filters.\n    // Hmmm, we *could* make a hitcollector that made a DocSet out of the query at the\n    // same time it was running the filter though...\n\n    // Q: we could call getDocSet(query) and then take the intersection instead of running\n    // the query as a filter.  Then it could be cached.\n    return answer;\n    ****************/\n  }\n\n","sourceOld":"  /**\n   * Returns the set of document ids matching both the query and the filter.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   *\n   * @param query\n   * @param filter may be null\n   */\n  public DocSet getDocSet(Query query, DocSet filter) throws IOException {\n    if (filter==null) return getDocSet(query);\n\n    DocSet first;\n    if (filterCache != null) {\n      first = (DocSet)filterCache.get(query);\n      if (first==null) {\n        first = getDocSetNC(query,null);\n        filterCache.put(query,first);\n      }\n      return first.intersection(filter);\n    }\n\n\n    // If there isn't a cache, then do a single filtered query.\n    return getDocSetNC(query,filter);\n\n\n    /******* OLD VERSION that did a filtered query instead of\n     * an intersection if the query docset wasn't found in the cache.\n     * It made misses != inserts (even if no evictions)\n    DocSet first=null;\n    if (filterCache != null) {\n      first = (DocSet)filterCache.get(query);\n      if (first != null) {\n        return first.intersection(filter);\n      }\n    }\n\n    DocSet answer = getDocSetNC(query, filter);\n    // nothing is inserted into the cache, because we don't cache materialized filters.\n    // Hmmm, we *could* make a hitcollector that made a DocSet out of the query at the\n    // same time it was running the filter though...\n\n    // Q: we could call getDocSet(query) and then take the intersection instead of running\n    // the query as a filter.  Then it could be cached.\n    return answer;\n    ****************/\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b1940b60224897131cf61bb615e02af1b26558c8","date":1169501002,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(Query,DocSet).mjava","pathOld":"src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(Query,DocSet).mjava","sourceNew":"  /**\n   * Returns the set of document ids matching both the query and the filter.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * <p>\n   *\n   * @param query\n   * @param filter may be null\n   * @return DocSet meeting the specified criteria, should <b>not</b> be modified by the caller.\n   */\n  public DocSet getDocSet(Query query, DocSet filter) throws IOException {\n    if (filter==null) return getDocSet(query);\n\n    // Negative query if absolute value different from original\n    Query absQ = QueryUtils.getAbs(query);\n    boolean positive = absQ==query;\n\n    DocSet first;\n    if (filterCache != null) {\n      first = (DocSet)filterCache.get(absQ);\n      if (first==null) {\n        first = getDocSetNC(absQ,null);\n        filterCache.put(absQ,first);\n      }\n      return positive ? first.intersection(filter) : filter.andNot(first);\n    }\n\n    // If there isn't a cache, then do a single filtered query if positive.\n    return positive ? getDocSetNC(absQ,filter) : filter.andNot(getPositiveDocSet(absQ));\n  }\n\n","sourceOld":"  /**\n   * Returns the set of document ids matching both the query and the filter.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * <p>\n   *\n   * @param query\n   * @param filter may be null\n   * @return DocSet meeting the specified criteria, should <b>not</b> be modified by the caller.\n   */\n  public DocSet getDocSet(Query query, DocSet filter) throws IOException {\n    if (filter==null) return getDocSet(query);\n\n    DocSet first;\n    if (filterCache != null) {\n      first = (DocSet)filterCache.get(query);\n      if (first==null) {\n        first = getDocSetNC(query,null);\n        filterCache.put(query,first);\n      }\n      return first.intersection(filter);\n    }\n\n\n    // If there isn't a cache, then do a single filtered query.\n    return getDocSetNC(query,filter);\n\n\n    /******* OLD VERSION that did a filtered query instead of\n     * an intersection if the query docset wasn't found in the cache.\n     * It made misses != inserts (even if no evictions)\n    DocSet first=null;\n    if (filterCache != null) {\n      first = (DocSet)filterCache.get(query);\n      if (first != null) {\n        return first.intersection(filter);\n      }\n    }\n\n    DocSet answer = getDocSetNC(query, filter);\n    // nothing is inserted into the cache, because we don't cache materialized filters.\n    // Hmmm, we *could* make a hitcollector that made a DocSet out of the query at the\n    // same time it was running the filter though...\n\n    // Q: we could call getDocSet(query) and then take the intersection instead of running\n    // the query as a filter.  Then it could be cached.\n    return answer;\n    ****************/\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(Query,DocSet).mjava","pathOld":"src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(Query,DocSet).mjava","sourceNew":"  /**\n   * Returns the set of document ids matching both the query and the filter.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * <p>\n   *\n   * @param query\n   * @param filter may be null\n   * @return DocSet meeting the specified criteria, should <b>not</b> be modified by the caller.\n   */\n  public DocSet getDocSet(Query query, DocSet filter) throws IOException {\n    if (filter==null) return getDocSet(query);\n\n    // Negative query if absolute value different from original\n    Query absQ = QueryUtils.getAbs(query);\n    boolean positive = absQ==query;\n\n    DocSet first;\n    if (filterCache != null) {\n      first = (DocSet)filterCache.get(absQ);\n      if (first==null) {\n        first = getDocSetNC(absQ,null);\n        filterCache.put(absQ,first);\n      }\n      return positive ? first.intersection(filter) : filter.andNot(first);\n    }\n\n    // If there isn't a cache, then do a single filtered query if positive.\n    return positive ? getDocSetNC(absQ,filter) : filter.andNot(getPositiveDocSet(absQ));\n  }\n\n","sourceOld":"  /**\n   * Returns the set of document ids matching both the query and the filter.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * <p>\n   *\n   * @param query\n   * @param filter may be null\n   * @return DocSet meeting the specified criteria, should <b>not</b> be modified by the caller.\n   */\n  public DocSet getDocSet(Query query, DocSet filter) throws IOException {\n    if (filter==null) return getDocSet(query);\n\n    // Negative query if absolute value different from original\n    Query absQ = QueryUtils.getAbs(query);\n    boolean positive = absQ==query;\n\n    DocSet first;\n    if (filterCache != null) {\n      first = (DocSet)filterCache.get(absQ);\n      if (first==null) {\n        first = getDocSetNC(absQ,null);\n        filterCache.put(absQ,first);\n      }\n      return positive ? first.intersection(filter) : filter.andNot(first);\n    }\n\n    // If there isn't a cache, then do a single filtered query if positive.\n    return positive ? getDocSetNC(absQ,filter) : filter.andNot(getPositiveDocSet(absQ));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0c3e228bf650e96f3002a8fb73dd0c13d55af077":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b1940b60224897131cf61bb615e02af1b26558c8":["e96fd8a5ecee99fb518c16ceb03a6a11c01b5468"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"ad94625fb8d088209f46650c8097196fec67f00c":["b1940b60224897131cf61bb615e02af1b26558c8"],"e96fd8a5ecee99fb518c16ceb03a6a11c01b5468":["0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"0c3e228bf650e96f3002a8fb73dd0c13d55af077":["e96fd8a5ecee99fb518c16ceb03a6a11c01b5468"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b1940b60224897131cf61bb615e02af1b26558c8":["ad94625fb8d088209f46650c8097196fec67f00c"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"e96fd8a5ecee99fb518c16ceb03a6a11c01b5468":["b1940b60224897131cf61bb615e02af1b26558c8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}