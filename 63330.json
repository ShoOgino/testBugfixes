{"path":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#collectionCmd(ClusterState,ZkNodeProps,ModifiableSolrParams).mjava","commits":[{"id":"3f767f8c99eaedb984df754fe61f21c5de260f94","date":1344105153,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#collectionCmd(ClusterState,ZkNodeProps,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#collectionCmd(CloudState,ZkNodeProps,ModifiableSolrParams).mjava","sourceNew":"  private boolean collectionCmd(ClusterState clusterState, ZkNodeProps message, ModifiableSolrParams params) {\n    log.info(\"Executing Collection Cmd : \" + params);\n    String name = message.get(\"name\");\n    \n    Map<String,Slice> slices = clusterState.getCollectionStates().get(name);\n    \n    if (slices == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Could not find collection:\" + name);\n    }\n    \n    for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n      Slice slice = entry.getValue();\n      Map<String,ZkNodeProps> shards = slice.getShards();\n      Set<Map.Entry<String,ZkNodeProps>> shardEntries = shards.entrySet();\n      for (Map.Entry<String,ZkNodeProps> shardEntry : shardEntries) {\n        final ZkNodeProps node = shardEntry.getValue();\n        if (clusterState.liveNodesContain(node.get(ZkStateReader.NODE_NAME_PROP))) {\n          params.set(CoreAdminParams.CORE, node.get(ZkStateReader.CORE_NAME_PROP));\n\n          String replica = node.get(ZkStateReader.BASE_URL_PROP);\n          ShardRequest sreq = new ShardRequest();\n          // yes, they must use same admin handler path everywhere...\n          params.set(\"qt\", adminPath);\n\n          sreq.purpose = 1;\n          // TODO: this sucks\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = params;\n          \n          shardHandler.submit(sreq, replica, sreq.params);\n        }\n      }\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean collectionCmd(CloudState cloudState, ZkNodeProps message, ModifiableSolrParams params) {\n    log.info(\"Executing Collection Cmd : \" + params);\n    String name = message.get(\"name\");\n    \n    Map<String,Slice> slices = cloudState.getCollectionStates().get(name);\n    \n    if (slices == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Could not find collection:\" + name);\n    }\n    \n    for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n      Slice slice = entry.getValue();\n      Map<String,ZkNodeProps> shards = slice.getShards();\n      Set<Map.Entry<String,ZkNodeProps>> shardEntries = shards.entrySet();\n      for (Map.Entry<String,ZkNodeProps> shardEntry : shardEntries) {\n        final ZkNodeProps node = shardEntry.getValue();\n        if (cloudState.liveNodesContain(node.get(ZkStateReader.NODE_NAME_PROP))) {\n          params.set(CoreAdminParams.CORE, node.get(ZkStateReader.CORE_NAME_PROP));\n\n          String replica = node.get(ZkStateReader.BASE_URL_PROP);\n          ShardRequest sreq = new ShardRequest();\n          // yes, they must use same admin handler path everywhere...\n          params.set(\"qt\", adminPath);\n\n          sreq.purpose = 1;\n          // TODO: this sucks\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = params;\n          \n          shardHandler.submit(sreq, replica, sreq.params);\n        }\n      }\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8fd5be977c105554c6a7b68afcdbc511439723ab","date":1344115570,"type":1,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#collectionCmd(ClusterState,ZkNodeProps,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#collectionCmd(CloudState,ZkNodeProps,ModifiableSolrParams).mjava","sourceNew":"  private boolean collectionCmd(ClusterState clusterState, ZkNodeProps message, ModifiableSolrParams params) {\n    log.info(\"Executing Collection Cmd : \" + params);\n    String name = message.get(\"name\");\n    \n    Map<String,Slice> slices = clusterState.getCollectionStates().get(name);\n    \n    if (slices == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Could not find collection:\" + name);\n    }\n    \n    for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n      Slice slice = entry.getValue();\n      Map<String,ZkNodeProps> shards = slice.getShards();\n      Set<Map.Entry<String,ZkNodeProps>> shardEntries = shards.entrySet();\n      for (Map.Entry<String,ZkNodeProps> shardEntry : shardEntries) {\n        final ZkNodeProps node = shardEntry.getValue();\n        if (clusterState.liveNodesContain(node.get(ZkStateReader.NODE_NAME_PROP))) {\n          params.set(CoreAdminParams.CORE, node.get(ZkStateReader.CORE_NAME_PROP));\n\n          String replica = node.get(ZkStateReader.BASE_URL_PROP);\n          ShardRequest sreq = new ShardRequest();\n          // yes, they must use same admin handler path everywhere...\n          params.set(\"qt\", adminPath);\n\n          sreq.purpose = 1;\n          // TODO: this sucks\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = params;\n          \n          shardHandler.submit(sreq, replica, sreq.params);\n        }\n      }\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean collectionCmd(CloudState cloudState, ZkNodeProps message, ModifiableSolrParams params) {\n    log.info(\"Executing Collection Cmd : \" + params);\n    String name = message.get(\"name\");\n    \n    Map<String,Slice> slices = cloudState.getCollectionStates().get(name);\n    \n    if (slices == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Could not find collection:\" + name);\n    }\n    \n    for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n      Slice slice = entry.getValue();\n      Map<String,ZkNodeProps> shards = slice.getShards();\n      Set<Map.Entry<String,ZkNodeProps>> shardEntries = shards.entrySet();\n      for (Map.Entry<String,ZkNodeProps> shardEntry : shardEntries) {\n        final ZkNodeProps node = shardEntry.getValue();\n        if (cloudState.liveNodesContain(node.get(ZkStateReader.NODE_NAME_PROP))) {\n          params.set(CoreAdminParams.CORE, node.get(ZkStateReader.CORE_NAME_PROP));\n\n          String replica = node.get(ZkStateReader.BASE_URL_PROP);\n          ShardRequest sreq = new ShardRequest();\n          // yes, they must use same admin handler path everywhere...\n          params.set(\"qt\", adminPath);\n\n          sreq.purpose = 1;\n          // TODO: this sucks\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = params;\n          \n          shardHandler.submit(sreq, replica, sreq.params);\n        }\n      }\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#collectionCmd(ClusterState,ZkNodeProps,ModifiableSolrParams).mjava","pathOld":"/dev/null","sourceNew":"  private boolean collectionCmd(ClusterState clusterState, ZkNodeProps message, ModifiableSolrParams params) {\n    log.info(\"Executing Collection Cmd : \" + params);\n    String name = message.get(\"name\");\n    \n    Map<String,Slice> slices = clusterState.getCollectionStates().get(name);\n    \n    if (slices == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Could not find collection:\" + name);\n    }\n    \n    for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n      Slice slice = entry.getValue();\n      Map<String,ZkNodeProps> shards = slice.getShards();\n      Set<Map.Entry<String,ZkNodeProps>> shardEntries = shards.entrySet();\n      for (Map.Entry<String,ZkNodeProps> shardEntry : shardEntries) {\n        final ZkNodeProps node = shardEntry.getValue();\n        if (clusterState.liveNodesContain(node.get(ZkStateReader.NODE_NAME_PROP))) {\n          params.set(CoreAdminParams.CORE, node.get(ZkStateReader.CORE_NAME_PROP));\n\n          String replica = node.get(ZkStateReader.BASE_URL_PROP);\n          ShardRequest sreq = new ShardRequest();\n          // yes, they must use same admin handler path everywhere...\n          params.set(\"qt\", adminPath);\n\n          sreq.purpose = 1;\n          // TODO: this sucks\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = params;\n          \n          shardHandler.submit(sreq, replica, sreq.params);\n        }\n      }\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa64435b5902ce266c23755a4a00691a3285dab8","date":1347243290,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#collectionCmd(ClusterState,ZkNodeProps,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#collectionCmd(ClusterState,ZkNodeProps,ModifiableSolrParams).mjava","sourceNew":"  private boolean collectionCmd(ClusterState clusterState, ZkNodeProps message, ModifiableSolrParams params) {\n    log.info(\"Executing Collection Cmd : \" + params);\n    String name = message.getStr(\"name\");\n    \n    Map<String,Slice> slices = clusterState.getCollectionStates().get(name);\n    \n    if (slices == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Could not find collection:\" + name);\n    }\n    \n    for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n      Slice slice = entry.getValue();\n      Map<String,Replica> shards = slice.getReplicasMap();\n      Set<Map.Entry<String,Replica>> shardEntries = shards.entrySet();\n      for (Map.Entry<String,Replica> shardEntry : shardEntries) {\n        final ZkNodeProps node = shardEntry.getValue();\n        if (clusterState.liveNodesContain(node.getStr(ZkStateReader.NODE_NAME_PROP))) {\n          params.set(CoreAdminParams.CORE, node.getStr(ZkStateReader.CORE_NAME_PROP));\n\n          String replica = node.getStr(ZkStateReader.BASE_URL_PROP);\n          ShardRequest sreq = new ShardRequest();\n          // yes, they must use same admin handler path everywhere...\n          params.set(\"qt\", adminPath);\n\n          sreq.purpose = 1;\n          // TODO: this sucks\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = params;\n          \n          shardHandler.submit(sreq, replica, sreq.params);\n        }\n      }\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean collectionCmd(ClusterState clusterState, ZkNodeProps message, ModifiableSolrParams params) {\n    log.info(\"Executing Collection Cmd : \" + params);\n    String name = message.get(\"name\");\n    \n    Map<String,Slice> slices = clusterState.getCollectionStates().get(name);\n    \n    if (slices == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Could not find collection:\" + name);\n    }\n    \n    for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n      Slice slice = entry.getValue();\n      Map<String,ZkNodeProps> shards = slice.getShards();\n      Set<Map.Entry<String,ZkNodeProps>> shardEntries = shards.entrySet();\n      for (Map.Entry<String,ZkNodeProps> shardEntry : shardEntries) {\n        final ZkNodeProps node = shardEntry.getValue();\n        if (clusterState.liveNodesContain(node.get(ZkStateReader.NODE_NAME_PROP))) {\n          params.set(CoreAdminParams.CORE, node.get(ZkStateReader.CORE_NAME_PROP));\n\n          String replica = node.get(ZkStateReader.BASE_URL_PROP);\n          ShardRequest sreq = new ShardRequest();\n          // yes, they must use same admin handler path everywhere...\n          params.set(\"qt\", adminPath);\n\n          sreq.purpose = 1;\n          // TODO: this sucks\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = params;\n          \n          shardHandler.submit(sreq, replica, sreq.params);\n        }\n      }\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e19067e820b148e8dc0b240da4f2771cf7b68252","date":1347730768,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#collectionCmd(ClusterState,ZkNodeProps,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#collectionCmd(ClusterState,ZkNodeProps,ModifiableSolrParams).mjava","sourceNew":"  private boolean collectionCmd(ClusterState clusterState, ZkNodeProps message, ModifiableSolrParams params) {\n    log.info(\"Executing Collection Cmd : \" + params);\n    String name = message.getStr(\"name\");\n    \n    Map<String,Slice> slices = clusterState.getCollectionStates().get(name);\n    \n    if (slices == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Could not find collection:\" + name);\n    }\n    \n    for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n      Slice slice = entry.getValue();\n      Map<String,Replica> shards = slice.getReplicasMap();\n      Set<Map.Entry<String,Replica>> shardEntries = shards.entrySet();\n      for (Map.Entry<String,Replica> shardEntry : shardEntries) {\n        final ZkNodeProps node = shardEntry.getValue();\n        if (clusterState.liveNodesContain(node.getStr(ZkStateReader.NODE_NAME_PROP))) {\n          params.set(CoreAdminParams.CORE, node.getStr(ZkStateReader.CORE_NAME_PROP));\n\n          String replica = node.getStr(ZkStateReader.BASE_URL_PROP);\n          ShardRequest sreq = new ShardRequest();\n          // yes, they must use same admin handler path everywhere...\n          params.set(\"qt\", adminPath);\n\n          sreq.purpose = 1;\n          // TODO: this sucks\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = params;\n          log.info(\"Collection Admin sending CoreAdmin cmd to \" + replica);\n          shardHandler.submit(sreq, replica, sreq.params);\n        }\n      }\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean collectionCmd(ClusterState clusterState, ZkNodeProps message, ModifiableSolrParams params) {\n    log.info(\"Executing Collection Cmd : \" + params);\n    String name = message.getStr(\"name\");\n    \n    Map<String,Slice> slices = clusterState.getCollectionStates().get(name);\n    \n    if (slices == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Could not find collection:\" + name);\n    }\n    \n    for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n      Slice slice = entry.getValue();\n      Map<String,Replica> shards = slice.getReplicasMap();\n      Set<Map.Entry<String,Replica>> shardEntries = shards.entrySet();\n      for (Map.Entry<String,Replica> shardEntry : shardEntries) {\n        final ZkNodeProps node = shardEntry.getValue();\n        if (clusterState.liveNodesContain(node.getStr(ZkStateReader.NODE_NAME_PROP))) {\n          params.set(CoreAdminParams.CORE, node.getStr(ZkStateReader.CORE_NAME_PROP));\n\n          String replica = node.getStr(ZkStateReader.BASE_URL_PROP);\n          ShardRequest sreq = new ShardRequest();\n          // yes, they must use same admin handler path everywhere...\n          params.set(\"qt\", adminPath);\n\n          sreq.purpose = 1;\n          // TODO: this sucks\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = params;\n          \n          shardHandler.submit(sreq, replica, sreq.params);\n        }\n      }\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":["33d0ed80b7b47e34ad3ff033a77544563aba3085"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bec8465870bfd544220e7010319276524015c4d3","date":1352670844,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#collectionCmd(ClusterState,ZkNodeProps,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#collectionCmd(ClusterState,ZkNodeProps,ModifiableSolrParams).mjava","sourceNew":"  private boolean collectionCmd(ClusterState clusterState, ZkNodeProps message, ModifiableSolrParams params) {\n    log.info(\"Executing Collection Cmd : \" + params);\n    String name = message.getStr(\"name\");\n    \n    Map<String,Slice> slices = clusterState.getCollectionStates().get(name);\n    \n    if (slices == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Could not find collection:\" + name);\n    }\n    \n    for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n      Slice slice = entry.getValue();\n      Map<String,Replica> shards = slice.getReplicasMap();\n      Set<Map.Entry<String,Replica>> shardEntries = shards.entrySet();\n      for (Map.Entry<String,Replica> shardEntry : shardEntries) {\n        final ZkNodeProps node = shardEntry.getValue();\n        if (clusterState.liveNodesContain(node.getStr(ZkStateReader.NODE_NAME_PROP))) {\n        \t//For thread safety, only  simple clone the ModifiableSolrParams\n            ModifiableSolrParams cloneParams = new ModifiableSolrParams();\n            cloneParams.add(params);\n            cloneParams.set(CoreAdminParams.CORE, node.getStr(ZkStateReader.CORE_NAME_PROP));\n            \n            String replica = node.getStr(ZkStateReader.BASE_URL_PROP);\n            ShardRequest sreq = new ShardRequest();\n            \n            // yes, they must use same admin handler path everywhere...\n            cloneParams.set(\"qt\", adminPath);\n            sreq.purpose = 1;\n            // TODO: this sucks\n            if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n            sreq.shards = new String[] {replica};\n            sreq.actualShards = sreq.shards;\n            sreq.params = cloneParams;\n            log.info(\"Collection Admin sending CoreAdmin cmd to \" + replica + \" params:\" + sreq.params);\n            shardHandler.submit(sreq, replica, sreq.params);\n        }\n      }\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean collectionCmd(ClusterState clusterState, ZkNodeProps message, ModifiableSolrParams params) {\n    log.info(\"Executing Collection Cmd : \" + params);\n    String name = message.getStr(\"name\");\n    \n    Map<String,Slice> slices = clusterState.getCollectionStates().get(name);\n    \n    if (slices == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Could not find collection:\" + name);\n    }\n    \n    for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n      Slice slice = entry.getValue();\n      Map<String,Replica> shards = slice.getReplicasMap();\n      Set<Map.Entry<String,Replica>> shardEntries = shards.entrySet();\n      for (Map.Entry<String,Replica> shardEntry : shardEntries) {\n        final ZkNodeProps node = shardEntry.getValue();\n        if (clusterState.liveNodesContain(node.getStr(ZkStateReader.NODE_NAME_PROP))) {\n          params.set(CoreAdminParams.CORE, node.getStr(ZkStateReader.CORE_NAME_PROP));\n\n          String replica = node.getStr(ZkStateReader.BASE_URL_PROP);\n          ShardRequest sreq = new ShardRequest();\n          // yes, they must use same admin handler path everywhere...\n          params.set(\"qt\", adminPath);\n\n          sreq.purpose = 1;\n          // TODO: this sucks\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = params;\n          log.info(\"Collection Admin sending CoreAdmin cmd to \" + replica);\n          shardHandler.submit(sreq, replica, sreq.params);\n        }\n      }\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a827f86f5916051edbda4eefdfcbbc2d33858bf3","date":1352672981,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#collectionCmd(ClusterState,ZkNodeProps,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#collectionCmd(ClusterState,ZkNodeProps,ModifiableSolrParams).mjava","sourceNew":"  private boolean collectionCmd(ClusterState clusterState, ZkNodeProps message, ModifiableSolrParams params) {\n    log.info(\"Executing Collection Cmd : \" + params);\n    String name = message.getStr(\"name\");\n    \n    Map<String,Slice> slices = clusterState.getCollectionStates().get(name);\n    \n    if (slices == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Could not find collection:\" + name);\n    }\n    \n    for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n      Slice slice = entry.getValue();\n      Map<String,Replica> shards = slice.getReplicasMap();\n      Set<Map.Entry<String,Replica>> shardEntries = shards.entrySet();\n      for (Map.Entry<String,Replica> shardEntry : shardEntries) {\n        final ZkNodeProps node = shardEntry.getValue();\n        if (clusterState.liveNodesContain(node.getStr(ZkStateReader.NODE_NAME_PROP))) {\n          // For thread safety, only simple clone the ModifiableSolrParams\n          ModifiableSolrParams cloneParams = new ModifiableSolrParams();\n          cloneParams.add(params);\n          cloneParams.set(CoreAdminParams.CORE,\n              node.getStr(ZkStateReader.CORE_NAME_PROP));\n          \n          String replica = node.getStr(ZkStateReader.BASE_URL_PROP);\n          ShardRequest sreq = new ShardRequest();\n          \n          // yes, they must use same admin handler path everywhere...\n          cloneParams.set(\"qt\", adminPath);\n          sreq.purpose = 1;\n          // TODO: this sucks\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = cloneParams;\n          log.info(\"Collection Admin sending CoreAdmin cmd to \" + replica\n              + \" params:\" + sreq.params);\n          shardHandler.submit(sreq, replica, sreq.params);\n        }\n      }\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean collectionCmd(ClusterState clusterState, ZkNodeProps message, ModifiableSolrParams params) {\n    log.info(\"Executing Collection Cmd : \" + params);\n    String name = message.getStr(\"name\");\n    \n    Map<String,Slice> slices = clusterState.getCollectionStates().get(name);\n    \n    if (slices == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Could not find collection:\" + name);\n    }\n    \n    for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n      Slice slice = entry.getValue();\n      Map<String,Replica> shards = slice.getReplicasMap();\n      Set<Map.Entry<String,Replica>> shardEntries = shards.entrySet();\n      for (Map.Entry<String,Replica> shardEntry : shardEntries) {\n        final ZkNodeProps node = shardEntry.getValue();\n        if (clusterState.liveNodesContain(node.getStr(ZkStateReader.NODE_NAME_PROP))) {\n        \t//For thread safety, only  simple clone the ModifiableSolrParams\n            ModifiableSolrParams cloneParams = new ModifiableSolrParams();\n            cloneParams.add(params);\n            cloneParams.set(CoreAdminParams.CORE, node.getStr(ZkStateReader.CORE_NAME_PROP));\n            \n            String replica = node.getStr(ZkStateReader.BASE_URL_PROP);\n            ShardRequest sreq = new ShardRequest();\n            \n            // yes, they must use same admin handler path everywhere...\n            cloneParams.set(\"qt\", adminPath);\n            sreq.purpose = 1;\n            // TODO: this sucks\n            if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n            sreq.shards = new String[] {replica};\n            sreq.actualShards = sreq.shards;\n            sreq.params = cloneParams;\n            log.info(\"Collection Admin sending CoreAdmin cmd to \" + replica + \" params:\" + sreq.params);\n            shardHandler.submit(sreq, replica, sreq.params);\n        }\n      }\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5a558d54519c651068ddb202f03befefb1514a7","date":1354382006,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#collectionCmd(ClusterState,ZkNodeProps,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#collectionCmd(ClusterState,ZkNodeProps,ModifiableSolrParams).mjava","sourceNew":"  private boolean collectionCmd(ClusterState clusterState, ZkNodeProps message, ModifiableSolrParams params) {\n    log.info(\"Executing Collection Cmd : \" + params);\n    String name = message.getStr(\"name\");\n    \n    DocCollection coll = clusterState.getCollection(name);\n\n    for (Map.Entry<String,Slice> entry : coll.getSlicesMap().entrySet()) {\n      Slice slice = entry.getValue();\n      Map<String,Replica> shards = slice.getReplicasMap();\n      Set<Map.Entry<String,Replica>> shardEntries = shards.entrySet();\n      for (Map.Entry<String,Replica> shardEntry : shardEntries) {\n        final ZkNodeProps node = shardEntry.getValue();\n        if (clusterState.liveNodesContain(node.getStr(ZkStateReader.NODE_NAME_PROP))) {\n          // For thread safety, only simple clone the ModifiableSolrParams\n          ModifiableSolrParams cloneParams = new ModifiableSolrParams();\n          cloneParams.add(params);\n          cloneParams.set(CoreAdminParams.CORE,\n              node.getStr(ZkStateReader.CORE_NAME_PROP));\n          \n          String replica = node.getStr(ZkStateReader.BASE_URL_PROP);\n          ShardRequest sreq = new ShardRequest();\n          \n          // yes, they must use same admin handler path everywhere...\n          cloneParams.set(\"qt\", adminPath);\n          sreq.purpose = 1;\n          // TODO: this sucks\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = cloneParams;\n          log.info(\"Collection Admin sending CoreAdmin cmd to \" + replica\n              + \" params:\" + sreq.params);\n          shardHandler.submit(sreq, replica, sreq.params);\n        }\n      }\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean collectionCmd(ClusterState clusterState, ZkNodeProps message, ModifiableSolrParams params) {\n    log.info(\"Executing Collection Cmd : \" + params);\n    String name = message.getStr(\"name\");\n    \n    Map<String,Slice> slices = clusterState.getCollectionStates().get(name);\n    \n    if (slices == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Could not find collection:\" + name);\n    }\n    \n    for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n      Slice slice = entry.getValue();\n      Map<String,Replica> shards = slice.getReplicasMap();\n      Set<Map.Entry<String,Replica>> shardEntries = shards.entrySet();\n      for (Map.Entry<String,Replica> shardEntry : shardEntries) {\n        final ZkNodeProps node = shardEntry.getValue();\n        if (clusterState.liveNodesContain(node.getStr(ZkStateReader.NODE_NAME_PROP))) {\n          // For thread safety, only simple clone the ModifiableSolrParams\n          ModifiableSolrParams cloneParams = new ModifiableSolrParams();\n          cloneParams.add(params);\n          cloneParams.set(CoreAdminParams.CORE,\n              node.getStr(ZkStateReader.CORE_NAME_PROP));\n          \n          String replica = node.getStr(ZkStateReader.BASE_URL_PROP);\n          ShardRequest sreq = new ShardRequest();\n          \n          // yes, they must use same admin handler path everywhere...\n          cloneParams.set(\"qt\", adminPath);\n          sreq.purpose = 1;\n          // TODO: this sucks\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = cloneParams;\n          log.info(\"Collection Admin sending CoreAdmin cmd to \" + replica\n              + \" params:\" + sreq.params);\n          shardHandler.submit(sreq, replica, sreq.params);\n        }\n      }\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c215736a9e29403edd2132d9f0829a287b428df4","date":1354641965,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#collectionCmd(ClusterState,ZkNodeProps,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#collectionCmd(ClusterState,ZkNodeProps,ModifiableSolrParams).mjava","sourceNew":"  private boolean collectionCmd(ClusterState clusterState, ZkNodeProps message, ModifiableSolrParams params) {\n    log.info(\"Executing Collection Cmd : \" + params);\n    String collectionName = message.getStr(\"name\");\n    \n    DocCollection coll = clusterState.getCollection(collectionName);\n    \n    if (coll == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Could not find collection:\" + collectionName);\n    }\n    \n    for (Map.Entry<String,Slice> entry : coll.getSlicesMap().entrySet()) {\n      Slice slice = entry.getValue();\n      Map<String,Replica> shards = slice.getReplicasMap();\n      Set<Map.Entry<String,Replica>> shardEntries = shards.entrySet();\n      for (Map.Entry<String,Replica> shardEntry : shardEntries) {\n        final ZkNodeProps node = shardEntry.getValue();\n        if (clusterState.liveNodesContain(node.getStr(ZkStateReader.NODE_NAME_PROP))) {\n          // For thread safety, only simple clone the ModifiableSolrParams\n          ModifiableSolrParams cloneParams = new ModifiableSolrParams();\n          cloneParams.add(params);\n          cloneParams.set(CoreAdminParams.CORE,\n              node.getStr(ZkStateReader.CORE_NAME_PROP));\n          \n          String replica = node.getStr(ZkStateReader.BASE_URL_PROP);\n          ShardRequest sreq = new ShardRequest();\n          \n          // yes, they must use same admin handler path everywhere...\n          cloneParams.set(\"qt\", adminPath);\n          sreq.purpose = 1;\n          // TODO: this sucks\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = cloneParams;\n          log.info(\"Collection Admin sending CoreAdmin cmd to \" + replica\n              + \" params:\" + sreq.params);\n          shardHandler.submit(sreq, replica, sreq.params);\n        }\n      }\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean collectionCmd(ClusterState clusterState, ZkNodeProps message, ModifiableSolrParams params) {\n    log.info(\"Executing Collection Cmd : \" + params);\n    String name = message.getStr(\"name\");\n    \n    DocCollection coll = clusterState.getCollection(name);\n\n    for (Map.Entry<String,Slice> entry : coll.getSlicesMap().entrySet()) {\n      Slice slice = entry.getValue();\n      Map<String,Replica> shards = slice.getReplicasMap();\n      Set<Map.Entry<String,Replica>> shardEntries = shards.entrySet();\n      for (Map.Entry<String,Replica> shardEntry : shardEntries) {\n        final ZkNodeProps node = shardEntry.getValue();\n        if (clusterState.liveNodesContain(node.getStr(ZkStateReader.NODE_NAME_PROP))) {\n          // For thread safety, only simple clone the ModifiableSolrParams\n          ModifiableSolrParams cloneParams = new ModifiableSolrParams();\n          cloneParams.add(params);\n          cloneParams.set(CoreAdminParams.CORE,\n              node.getStr(ZkStateReader.CORE_NAME_PROP));\n          \n          String replica = node.getStr(ZkStateReader.BASE_URL_PROP);\n          ShardRequest sreq = new ShardRequest();\n          \n          // yes, they must use same admin handler path everywhere...\n          cloneParams.set(\"qt\", adminPath);\n          sreq.purpose = 1;\n          // TODO: this sucks\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = cloneParams;\n          log.info(\"Collection Admin sending CoreAdmin cmd to \" + replica\n              + \" params:\" + sreq.params);\n          shardHandler.submit(sreq, replica, sreq.params);\n        }\n      }\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":["993d0b0d77c623d30cb24cdadbff9bb3b5f516bb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#collectionCmd(ClusterState,ZkNodeProps,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#collectionCmd(ClusterState,ZkNodeProps,ModifiableSolrParams).mjava","sourceNew":"  private boolean collectionCmd(ClusterState clusterState, ZkNodeProps message, ModifiableSolrParams params) {\n    log.info(\"Executing Collection Cmd : \" + params);\n    String collectionName = message.getStr(\"name\");\n    \n    DocCollection coll = clusterState.getCollection(collectionName);\n    \n    if (coll == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Could not find collection:\" + collectionName);\n    }\n    \n    for (Map.Entry<String,Slice> entry : coll.getSlicesMap().entrySet()) {\n      Slice slice = entry.getValue();\n      Map<String,Replica> shards = slice.getReplicasMap();\n      Set<Map.Entry<String,Replica>> shardEntries = shards.entrySet();\n      for (Map.Entry<String,Replica> shardEntry : shardEntries) {\n        final ZkNodeProps node = shardEntry.getValue();\n        if (clusterState.liveNodesContain(node.getStr(ZkStateReader.NODE_NAME_PROP))) {\n          // For thread safety, only simple clone the ModifiableSolrParams\n          ModifiableSolrParams cloneParams = new ModifiableSolrParams();\n          cloneParams.add(params);\n          cloneParams.set(CoreAdminParams.CORE,\n              node.getStr(ZkStateReader.CORE_NAME_PROP));\n          \n          String replica = node.getStr(ZkStateReader.BASE_URL_PROP);\n          ShardRequest sreq = new ShardRequest();\n          \n          // yes, they must use same admin handler path everywhere...\n          cloneParams.set(\"qt\", adminPath);\n          sreq.purpose = 1;\n          // TODO: this sucks\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = cloneParams;\n          log.info(\"Collection Admin sending CoreAdmin cmd to \" + replica\n              + \" params:\" + sreq.params);\n          shardHandler.submit(sreq, replica, sreq.params);\n        }\n      }\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean collectionCmd(ClusterState clusterState, ZkNodeProps message, ModifiableSolrParams params) {\n    log.info(\"Executing Collection Cmd : \" + params);\n    String name = message.getStr(\"name\");\n    \n    Map<String,Slice> slices = clusterState.getCollectionStates().get(name);\n    \n    if (slices == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Could not find collection:\" + name);\n    }\n    \n    for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n      Slice slice = entry.getValue();\n      Map<String,Replica> shards = slice.getReplicasMap();\n      Set<Map.Entry<String,Replica>> shardEntries = shards.entrySet();\n      for (Map.Entry<String,Replica> shardEntry : shardEntries) {\n        final ZkNodeProps node = shardEntry.getValue();\n        if (clusterState.liveNodesContain(node.getStr(ZkStateReader.NODE_NAME_PROP))) {\n          params.set(CoreAdminParams.CORE, node.getStr(ZkStateReader.CORE_NAME_PROP));\n\n          String replica = node.getStr(ZkStateReader.BASE_URL_PROP);\n          ShardRequest sreq = new ShardRequest();\n          // yes, they must use same admin handler path everywhere...\n          params.set(\"qt\", adminPath);\n\n          sreq.purpose = 1;\n          // TODO: this sucks\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = params;\n          log.info(\"Collection Admin sending CoreAdmin cmd to \" + replica);\n          shardHandler.submit(sreq, replica, sreq.params);\n        }\n      }\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe999fc2d95d6fea71f960bf9556858387ba21f5","date":1363294860,"type":5,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#collectionCmd(ClusterState,ZkNodeProps,ModifiableSolrParams,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#collectionCmd(ClusterState,ZkNodeProps,ModifiableSolrParams).mjava","sourceNew":"  private boolean collectionCmd(ClusterState clusterState, ZkNodeProps message, ModifiableSolrParams params, NamedList results) {\n    log.info(\"Executing Collection Cmd : \" + params);\n    String collectionName = message.getStr(\"name\");\n    \n    DocCollection coll = clusterState.getCollection(collectionName);\n    \n    if (coll == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Could not find collection:\" + collectionName);\n    }\n    \n    for (Map.Entry<String,Slice> entry : coll.getSlicesMap().entrySet()) {\n      Slice slice = entry.getValue();\n      Map<String,Replica> shards = slice.getReplicasMap();\n      Set<Map.Entry<String,Replica>> shardEntries = shards.entrySet();\n      for (Map.Entry<String,Replica> shardEntry : shardEntries) {\n        final ZkNodeProps node = shardEntry.getValue();\n        if (clusterState.liveNodesContain(node.getStr(ZkStateReader.NODE_NAME_PROP))) {\n          // For thread safety, only simple clone the ModifiableSolrParams\n          ModifiableSolrParams cloneParams = new ModifiableSolrParams();\n          cloneParams.add(params);\n          cloneParams.set(CoreAdminParams.CORE,\n              node.getStr(ZkStateReader.CORE_NAME_PROP));\n          \n          String replica = node.getStr(ZkStateReader.BASE_URL_PROP);\n          ShardRequest sreq = new ShardRequest();\n          sreq.nodeName = node.getStr(ZkStateReader.NODE_NAME_PROP);\n          // yes, they must use same admin handler path everywhere...\n          cloneParams.set(\"qt\", adminPath);\n          sreq.purpose = 1;\n          // TODO: this sucks\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = cloneParams;\n          log.info(\"Collection Admin sending CoreAdmin cmd to \" + replica\n              + \" params:\" + sreq.params);\n          shardHandler.submit(sreq, replica, sreq.params);\n        }\n      }\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        processResponse(results, srsp);\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  private boolean collectionCmd(ClusterState clusterState, ZkNodeProps message, ModifiableSolrParams params) {\n    log.info(\"Executing Collection Cmd : \" + params);\n    String collectionName = message.getStr(\"name\");\n    \n    DocCollection coll = clusterState.getCollection(collectionName);\n    \n    if (coll == null) {\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Could not find collection:\" + collectionName);\n    }\n    \n    for (Map.Entry<String,Slice> entry : coll.getSlicesMap().entrySet()) {\n      Slice slice = entry.getValue();\n      Map<String,Replica> shards = slice.getReplicasMap();\n      Set<Map.Entry<String,Replica>> shardEntries = shards.entrySet();\n      for (Map.Entry<String,Replica> shardEntry : shardEntries) {\n        final ZkNodeProps node = shardEntry.getValue();\n        if (clusterState.liveNodesContain(node.getStr(ZkStateReader.NODE_NAME_PROP))) {\n          // For thread safety, only simple clone the ModifiableSolrParams\n          ModifiableSolrParams cloneParams = new ModifiableSolrParams();\n          cloneParams.add(params);\n          cloneParams.set(CoreAdminParams.CORE,\n              node.getStr(ZkStateReader.CORE_NAME_PROP));\n          \n          String replica = node.getStr(ZkStateReader.BASE_URL_PROP);\n          ShardRequest sreq = new ShardRequest();\n          \n          // yes, they must use same admin handler path everywhere...\n          cloneParams.set(\"qt\", adminPath);\n          sreq.purpose = 1;\n          // TODO: this sucks\n          if (replica.startsWith(\"http://\")) replica = replica.substring(7);\n          sreq.shards = new String[] {replica};\n          sreq.actualShards = sreq.shards;\n          sreq.params = cloneParams;\n          log.info(\"Collection Admin sending CoreAdmin cmd to \" + replica\n              + \" params:\" + sreq.params);\n          shardHandler.submit(sreq, replica, sreq.params);\n        }\n      }\n    }\n    \n    int failed = 0;\n    ShardResponse srsp;\n    do {\n      srsp = shardHandler.takeCompletedOrError();\n      if (srsp != null) {\n        Throwable e = srsp.getException();\n        if (e != null) {\n          // should we retry?\n          // TODO: we should return errors to the client\n          // TODO: what if one fails and others succeed?\n          failed++;\n          log.error(\"Error talking to shard: \" + srsp.getShard(), e);\n        }\n      }\n    } while (srsp != null);\n\n    \n    // if all calls succeeded, return true\n    if (failed > 0) {\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"fa64435b5902ce266c23755a4a00691a3285dab8":["3f767f8c99eaedb984df754fe61f21c5de260f94"],"407687e67faf6e1f02a211ca078d8e3eed631027":["e19067e820b148e8dc0b240da4f2771cf7b68252","c215736a9e29403edd2132d9f0829a287b428df4"],"e19067e820b148e8dc0b240da4f2771cf7b68252":["fa64435b5902ce266c23755a4a00691a3285dab8"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3f767f8c99eaedb984df754fe61f21c5de260f94"],"3f767f8c99eaedb984df754fe61f21c5de260f94":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fe999fc2d95d6fea71f960bf9556858387ba21f5":["c215736a9e29403edd2132d9f0829a287b428df4"],"a827f86f5916051edbda4eefdfcbbc2d33858bf3":["bec8465870bfd544220e7010319276524015c4d3"],"c215736a9e29403edd2132d9f0829a287b428df4":["c5a558d54519c651068ddb202f03befefb1514a7"],"c5a558d54519c651068ddb202f03befefb1514a7":["a827f86f5916051edbda4eefdfcbbc2d33858bf3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3f767f8c99eaedb984df754fe61f21c5de260f94"],"bec8465870bfd544220e7010319276524015c4d3":["e19067e820b148e8dc0b240da4f2771cf7b68252"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fe999fc2d95d6fea71f960bf9556858387ba21f5"]},"commit2Childs":{"fa64435b5902ce266c23755a4a00691a3285dab8":["e19067e820b148e8dc0b240da4f2771cf7b68252"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"e19067e820b148e8dc0b240da4f2771cf7b68252":["407687e67faf6e1f02a211ca078d8e3eed631027","bec8465870bfd544220e7010319276524015c4d3"],"8fd5be977c105554c6a7b68afcdbc511439723ab":[],"3f767f8c99eaedb984df754fe61f21c5de260f94":["fa64435b5902ce266c23755a4a00691a3285dab8","8fd5be977c105554c6a7b68afcdbc511439723ab","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"fe999fc2d95d6fea71f960bf9556858387ba21f5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a827f86f5916051edbda4eefdfcbbc2d33858bf3":["c5a558d54519c651068ddb202f03befefb1514a7"],"c215736a9e29403edd2132d9f0829a287b428df4":["407687e67faf6e1f02a211ca078d8e3eed631027","fe999fc2d95d6fea71f960bf9556858387ba21f5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8fd5be977c105554c6a7b68afcdbc511439723ab","3f767f8c99eaedb984df754fe61f21c5de260f94","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"c5a558d54519c651068ddb202f03befefb1514a7":["c215736a9e29403edd2132d9f0829a287b428df4"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"bec8465870bfd544220e7010319276524015c4d3":["a827f86f5916051edbda4eefdfcbbc2d33858bf3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["407687e67faf6e1f02a211ca078d8e3eed631027","8fd5be977c105554c6a7b68afcdbc511439723ab","d6f074e73200c07d54f242d3880a8da5a35ff97b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}