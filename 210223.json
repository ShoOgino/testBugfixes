{"path":"lucene/src/test/org/apache/lucene/util/_TestUtil#unzip(File,File).mjava","commits":[{"id":"3cdad2c6b6234338031bcc1f24c001a5ad66f714","date":1296866109,"type":0,"author":"Doron Cohen","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/_TestUtil#unzip(File,File).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Convenience method: Unzip zipName + \".zip\" under destDir, removing destDir first \n   */\n  public static void unzip(File zipName, File destDir) throws IOException {\n    \n    ZipFile zipFile = new ZipFile(zipName);\n    \n    Enumeration<? extends ZipEntry> entries = zipFile.entries();\n    \n    rmDir(destDir);\n    \n    destDir.mkdir();\n    \n    while (entries.hasMoreElements()) {\n      ZipEntry entry = entries.nextElement();\n      \n      InputStream in = zipFile.getInputStream(entry);\n      File targetFile = new File(destDir, entry.getName());\n      if (entry.isDirectory()) {\n        // allow unzipping with directory structure\n        targetFile.mkdirs();\n      } else {\n        if (targetFile.getParentFile()!=null) {\n          // be on the safe side: do not rely on that directories are always extracted\n          // before their children (although this makes sense, but is it guaranteed?)\n          targetFile.getParentFile().mkdirs();   \n        }\n        OutputStream out = new BufferedOutputStream(new FileOutputStream(targetFile));\n        \n        byte[] buffer = new byte[8192];\n        int len;\n        while((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n        \n        in.close();\n        out.close();\n      }\n    }\n    \n    zipFile.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce","date":1297021734,"type":5,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/_TestUtil#unzip(File,File).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/_TestUtil#unzip(File,File).mjava","sourceNew":"  /** \n   * Convenience method: Unzip zipName + \".zip\" under destDir, removing destDir first \n   */\n  public static void unzip(File zipName, File destDir) throws IOException {\n    \n    ZipFile zipFile = new ZipFile(zipName);\n    \n    Enumeration<? extends ZipEntry> entries = zipFile.entries();\n    \n    rmDir(destDir);\n    \n    destDir.mkdir();\n    \n    while (entries.hasMoreElements()) {\n      ZipEntry entry = entries.nextElement();\n      \n      InputStream in = zipFile.getInputStream(entry);\n      File targetFile = new File(destDir, entry.getName());\n      if (entry.isDirectory()) {\n        // allow unzipping with directory structure\n        targetFile.mkdirs();\n      } else {\n        if (targetFile.getParentFile()!=null) {\n          // be on the safe side: do not rely on that directories are always extracted\n          // before their children (although this makes sense, but is it guaranteed?)\n          targetFile.getParentFile().mkdirs();   \n        }\n        OutputStream out = new BufferedOutputStream(new FileOutputStream(targetFile));\n        \n        byte[] buffer = new byte[8192];\n        int len;\n        while((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n        \n        in.close();\n        out.close();\n      }\n    }\n    \n    zipFile.close();\n  }\n\n","sourceOld":"  /** \n   * Convenience method: Unzip zipName + \".zip\" under destDir, removing destDir first \n   */\n  public static void unzip(File zipName, File destDir) throws IOException {\n    \n    ZipFile zipFile = new ZipFile(zipName);\n    \n    Enumeration<? extends ZipEntry> entries = zipFile.entries();\n    \n    rmDir(destDir);\n    \n    destDir.mkdir();\n    \n    while (entries.hasMoreElements()) {\n      ZipEntry entry = entries.nextElement();\n      \n      InputStream in = zipFile.getInputStream(entry);\n      File targetFile = new File(destDir, entry.getName());\n      if (entry.isDirectory()) {\n        // allow unzipping with directory structure\n        targetFile.mkdirs();\n      } else {\n        if (targetFile.getParentFile()!=null) {\n          // be on the safe side: do not rely on that directories are always extracted\n          // before their children (although this makes sense, but is it guaranteed?)\n          targetFile.getParentFile().mkdirs();   \n        }\n        OutputStream out = new BufferedOutputStream(new FileOutputStream(targetFile));\n        \n        byte[] buffer = new byte[8192];\n        int len;\n        while((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n        \n        in.close();\n        out.close();\n      }\n    }\n    \n    zipFile.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdad2c6b6234338031bcc1f24c001a5ad66f714":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce"],"f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce":["3cdad2c6b6234338031bcc1f24c001a5ad66f714"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3cdad2c6b6234338031bcc1f24c001a5ad66f714"],"3cdad2c6b6234338031bcc1f24c001a5ad66f714":["f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}