{"path":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long,TransactionLog).mjava","commits":[{"id":"1455c941cc4ce652efc776fc23471b0e499246f6","date":1528086751,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long,TransactionLog).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   */\n  public void copyOverOldUpdates(long commitVersion, TransactionLog oldTlog) {\n    copyOverOldUpdatesMeter.mark();\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":0,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long,TransactionLog).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   */\n  public void copyOverOldUpdates(long commitVersion, TransactionLog oldTlog) {\n    copyOverOldUpdatesMeter.mark();\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":0,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long,TransactionLog).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   */\n  public void copyOverOldUpdates(long commitVersion, TransactionLog oldTlog) {\n    copyOverOldUpdatesMeter.mark();\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"740d649f013f07efbeb73ca854f106c60166e7c0","date":1587431295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long,TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long,TransactionLog).mjava","sourceNew":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   */\n  public void copyOverOldUpdates(long commitVersion, TransactionLog oldTlog) {\n    copyOverOldUpdatesMeter.mark();\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry={}\", o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","sourceOld":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   */\n  public void copyOverOldUpdates(long commitVersion, TransactionLog oldTlog) {\n    copyOverOldUpdatesMeter.mark();\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"018a36ff4088cb91ab12cbe44f696d81d1fadd77","date":1591657414,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long,TransactionLog).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long,TransactionLog).mjava","sourceNew":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   */\n  public void copyOverOldUpdates(long commitVersion, TransactionLog oldTlog) {\n    copyOverOldUpdatesMeter.mark();\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          @SuppressWarnings({\"rawtypes\"})\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry={}\", o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","sourceOld":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   */\n  public void copyOverOldUpdates(long commitVersion, TransactionLog oldTlog) {\n    copyOverOldUpdatesMeter.mark();\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry={}\", o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"018a36ff4088cb91ab12cbe44f696d81d1fadd77":["740d649f013f07efbeb73ca854f106c60166e7c0"],"740d649f013f07efbeb73ca854f106c60166e7c0":["1455c941cc4ce652efc776fc23471b0e499246f6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1455c941cc4ce652efc776fc23471b0e499246f6"],"f592209545c71895260367152601e9200399776d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1455c941cc4ce652efc776fc23471b0e499246f6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["018a36ff4088cb91ab12cbe44f696d81d1fadd77"],"1455c941cc4ce652efc776fc23471b0e499246f6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"018a36ff4088cb91ab12cbe44f696d81d1fadd77":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"740d649f013f07efbeb73ca854f106c60166e7c0":["018a36ff4088cb91ab12cbe44f696d81d1fadd77"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","1455c941cc4ce652efc776fc23471b0e499246f6"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"f592209545c71895260367152601e9200399776d":[],"1455c941cc4ce652efc776fc23471b0e499246f6":["740d649f013f07efbeb73ca854f106c60166e7c0","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}