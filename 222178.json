{"path":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#handleBinaryDVUpdates(FieldInfos,Map[String,BinaryDocValuesFieldUpdates],TrackingDirectoryWrapper,DocValuesFormat,SegmentReader,Map[Integer,Set[String]]).mjava","commits":[{"id":"0567bdc5c86c94ced64201187cfcef2417d76dda","date":1400678298,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#handleBinaryDVUpdates(FieldInfos,Map[String,BinaryDocValuesFieldUpdates],TrackingDirectoryWrapper,DocValuesFormat,SegmentReader,Map[Integer,Set[String]]).mjava","pathOld":"/dev/null","sourceNew":"  @SuppressWarnings(\"synthetic-access\")\n  private void handleBinaryDVUpdates(FieldInfos infos, Map<String,BinaryDocValuesFieldUpdates> updates, \n      TrackingDirectoryWrapper dir, DocValuesFormat dvFormat, final SegmentReader reader, Map<Integer,Set<String>> fieldFiles) throws IOException {\n    for (Entry<String,BinaryDocValuesFieldUpdates> e : updates.entrySet()) {\n      final String field = e.getKey();\n      final BinaryDocValuesFieldUpdates fieldUpdates = e.getValue();\n\n      final long nextDocValuesGen = info.getNextDocValuesGen();\n      final String segmentSuffix = Long.toString(nextDocValuesGen, Character.MAX_RADIX);\n      final long estUpdatesSize = fieldUpdates.ramBytesPerDoc() * info.info.getDocCount();\n      final IOContext updatesContext = new IOContext(new FlushInfo(info.info.getDocCount(), estUpdatesSize));\n      final FieldInfo fieldInfo = infos.fieldInfo(field);\n      assert fieldInfo != null;\n      fieldInfo.setDocValuesGen(nextDocValuesGen);\n      final FieldInfos fieldInfos = new FieldInfos(new FieldInfo[] { fieldInfo });\n      // separately also track which files were created for this gen\n      final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n      final SegmentWriteState state = new SegmentWriteState(null, trackingDir, info.info, fieldInfos, null, updatesContext, segmentSuffix);\n      try (final DocValuesConsumer fieldsConsumer = dvFormat.fieldsConsumer(state)) {\n        // write the binary updates to a new gen'd docvalues file\n        fieldsConsumer.addBinaryField(fieldInfo, new Iterable<BytesRef>() {\n          final BinaryDocValues currentValues = reader.getBinaryDocValues(field);\n          final Bits docsWithField = reader.getDocsWithField(field);\n          final int maxDoc = reader.maxDoc();\n          final BinaryDocValuesFieldUpdates.Iterator updatesIter = fieldUpdates.iterator();\n          @Override\n          public Iterator<BytesRef> iterator() {\n            updatesIter.reset();\n            return new Iterator<BytesRef>() {\n              \n              int curDoc = -1;\n              int updateDoc = updatesIter.nextDoc();\n              BytesRef scratch = new BytesRef();\n              \n              @Override\n              public boolean hasNext() {\n                return curDoc < maxDoc - 1;\n              }\n              \n              @Override\n              public BytesRef next() {\n                if (++curDoc >= maxDoc) {\n                  throw new NoSuchElementException(\"no more documents to return values for\");\n                }\n                if (curDoc == updateDoc) { // this document has an updated value\n                  BytesRef value = updatesIter.value(); // either null (unset value) or updated value\n                  updateDoc = updatesIter.nextDoc(); // prepare for next round\n                  return value;\n                } else {\n                  // no update for this document\n                  assert curDoc < updateDoc;\n                  if (currentValues != null && docsWithField.get(curDoc)) {\n                    // only read the current value if the document had a value before\n                    currentValues.get(curDoc, scratch);\n                    return scratch;\n                  } else {\n                    return null;\n                  }\n                }\n              }\n              \n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException(\"this iterator does not support removing elements\");\n              }\n            };\n          }\n        });\n      }\n      info.advanceDocValuesGen();\n      assert !fieldFiles.containsKey(fieldInfo.number);\n      fieldFiles.put(fieldInfo.number, trackingDir.getCreatedFiles());\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a656b32c3aa151037a8c52e9b134acc3cbf482bc","date":1400688195,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#handleBinaryDVUpdates(FieldInfos,Map[String,BinaryDocValuesFieldUpdates],TrackingDirectoryWrapper,DocValuesFormat,SegmentReader,Map[Integer,Set[String]]).mjava","pathOld":"/dev/null","sourceNew":"  @SuppressWarnings(\"synthetic-access\")\n  private void handleBinaryDVUpdates(FieldInfos infos, Map<String,BinaryDocValuesFieldUpdates> updates, \n      TrackingDirectoryWrapper dir, DocValuesFormat dvFormat, final SegmentReader reader, Map<Integer,Set<String>> fieldFiles) throws IOException {\n    for (Entry<String,BinaryDocValuesFieldUpdates> e : updates.entrySet()) {\n      final String field = e.getKey();\n      final BinaryDocValuesFieldUpdates fieldUpdates = e.getValue();\n\n      final long nextDocValuesGen = info.getNextDocValuesGen();\n      final String segmentSuffix = Long.toString(nextDocValuesGen, Character.MAX_RADIX);\n      final long estUpdatesSize = fieldUpdates.ramBytesPerDoc() * info.info.getDocCount();\n      final IOContext updatesContext = new IOContext(new FlushInfo(info.info.getDocCount(), estUpdatesSize));\n      final FieldInfo fieldInfo = infos.fieldInfo(field);\n      assert fieldInfo != null;\n      fieldInfo.setDocValuesGen(nextDocValuesGen);\n      final FieldInfos fieldInfos = new FieldInfos(new FieldInfo[] { fieldInfo });\n      // separately also track which files were created for this gen\n      final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n      final SegmentWriteState state = new SegmentWriteState(null, trackingDir, info.info, fieldInfos, null, updatesContext, segmentSuffix);\n      try (final DocValuesConsumer fieldsConsumer = dvFormat.fieldsConsumer(state)) {\n        // write the binary updates to a new gen'd docvalues file\n        fieldsConsumer.addBinaryField(fieldInfo, new Iterable<BytesRef>() {\n          final BinaryDocValues currentValues = reader.getBinaryDocValues(field);\n          final Bits docsWithField = reader.getDocsWithField(field);\n          final int maxDoc = reader.maxDoc();\n          final BinaryDocValuesFieldUpdates.Iterator updatesIter = fieldUpdates.iterator();\n          @Override\n          public Iterator<BytesRef> iterator() {\n            updatesIter.reset();\n            return new Iterator<BytesRef>() {\n              \n              int curDoc = -1;\n              int updateDoc = updatesIter.nextDoc();\n              BytesRef scratch = new BytesRef();\n              \n              @Override\n              public boolean hasNext() {\n                return curDoc < maxDoc - 1;\n              }\n              \n              @Override\n              public BytesRef next() {\n                if (++curDoc >= maxDoc) {\n                  throw new NoSuchElementException(\"no more documents to return values for\");\n                }\n                if (curDoc == updateDoc) { // this document has an updated value\n                  BytesRef value = updatesIter.value(); // either null (unset value) or updated value\n                  updateDoc = updatesIter.nextDoc(); // prepare for next round\n                  return value;\n                } else {\n                  // no update for this document\n                  assert curDoc < updateDoc;\n                  if (currentValues != null && docsWithField.get(curDoc)) {\n                    // only read the current value if the document had a value before\n                    currentValues.get(curDoc, scratch);\n                    return scratch;\n                  } else {\n                    return null;\n                  }\n                }\n              }\n              \n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException(\"this iterator does not support removing elements\");\n              }\n            };\n          }\n        });\n      }\n      info.advanceDocValuesGen();\n      assert !fieldFiles.containsKey(fieldInfo.number);\n      fieldFiles.put(fieldInfo.number, trackingDir.getCreatedFiles());\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7605579001505896d48b07160075a5c8b8e128e","date":1400758727,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#handleBinaryDVUpdates(FieldInfos,Map[String,BinaryDocValuesFieldUpdates],TrackingDirectoryWrapper,DocValuesFormat,SegmentReader,Map[Integer,Set[String]]).mjava","pathOld":"/dev/null","sourceNew":"  @SuppressWarnings(\"synthetic-access\")\n  private void handleBinaryDVUpdates(FieldInfos infos, Map<String,BinaryDocValuesFieldUpdates> updates, \n      TrackingDirectoryWrapper dir, DocValuesFormat dvFormat, final SegmentReader reader, Map<Integer,Set<String>> fieldFiles) throws IOException {\n    for (Entry<String,BinaryDocValuesFieldUpdates> e : updates.entrySet()) {\n      final String field = e.getKey();\n      final BinaryDocValuesFieldUpdates fieldUpdates = e.getValue();\n\n      final long nextDocValuesGen = info.getNextDocValuesGen();\n      final String segmentSuffix = Long.toString(nextDocValuesGen, Character.MAX_RADIX);\n      final long estUpdatesSize = fieldUpdates.ramBytesPerDoc() * info.info.getDocCount();\n      final IOContext updatesContext = new IOContext(new FlushInfo(info.info.getDocCount(), estUpdatesSize));\n      final FieldInfo fieldInfo = infos.fieldInfo(field);\n      assert fieldInfo != null;\n      fieldInfo.setDocValuesGen(nextDocValuesGen);\n      final FieldInfos fieldInfos = new FieldInfos(new FieldInfo[] { fieldInfo });\n      // separately also track which files were created for this gen\n      final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n      final SegmentWriteState state = new SegmentWriteState(null, trackingDir, info.info, fieldInfos, null, updatesContext, segmentSuffix);\n      try (final DocValuesConsumer fieldsConsumer = dvFormat.fieldsConsumer(state)) {\n        // write the binary updates to a new gen'd docvalues file\n        fieldsConsumer.addBinaryField(fieldInfo, new Iterable<BytesRef>() {\n          final BinaryDocValues currentValues = reader.getBinaryDocValues(field);\n          final Bits docsWithField = reader.getDocsWithField(field);\n          final int maxDoc = reader.maxDoc();\n          final BinaryDocValuesFieldUpdates.Iterator updatesIter = fieldUpdates.iterator();\n          @Override\n          public Iterator<BytesRef> iterator() {\n            updatesIter.reset();\n            return new Iterator<BytesRef>() {\n              \n              int curDoc = -1;\n              int updateDoc = updatesIter.nextDoc();\n              BytesRef scratch = new BytesRef();\n              \n              @Override\n              public boolean hasNext() {\n                return curDoc < maxDoc - 1;\n              }\n              \n              @Override\n              public BytesRef next() {\n                if (++curDoc >= maxDoc) {\n                  throw new NoSuchElementException(\"no more documents to return values for\");\n                }\n                if (curDoc == updateDoc) { // this document has an updated value\n                  BytesRef value = updatesIter.value(); // either null (unset value) or updated value\n                  updateDoc = updatesIter.nextDoc(); // prepare for next round\n                  return value;\n                } else {\n                  // no update for this document\n                  assert curDoc < updateDoc;\n                  if (currentValues != null && docsWithField.get(curDoc)) {\n                    // only read the current value if the document had a value before\n                    currentValues.get(curDoc, scratch);\n                    return scratch;\n                  } else {\n                    return null;\n                  }\n                }\n              }\n              \n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException(\"this iterator does not support removing elements\");\n              }\n            };\n          }\n        });\n      }\n      info.advanceDocValuesGen();\n      assert !fieldFiles.containsKey(fieldInfo.number);\n      fieldFiles.put(fieldInfo.number, trackingDir.getCreatedFiles());\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf","date":1401983689,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#handleBinaryDVUpdates(FieldInfos,Map[String,BinaryDocValuesFieldUpdates],TrackingDirectoryWrapper,DocValuesFormat,SegmentReader,Map[Integer,Set[String]]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#handleBinaryDVUpdates(FieldInfos,Map[String,BinaryDocValuesFieldUpdates],TrackingDirectoryWrapper,DocValuesFormat,SegmentReader,Map[Integer,Set[String]]).mjava","sourceNew":"  @SuppressWarnings(\"synthetic-access\")\n  private void handleBinaryDVUpdates(FieldInfos infos, Map<String,BinaryDocValuesFieldUpdates> updates, \n      TrackingDirectoryWrapper dir, DocValuesFormat dvFormat, final SegmentReader reader, Map<Integer,Set<String>> fieldFiles) throws IOException {\n    for (Entry<String,BinaryDocValuesFieldUpdates> e : updates.entrySet()) {\n      final String field = e.getKey();\n      final BinaryDocValuesFieldUpdates fieldUpdates = e.getValue();\n\n      final long nextDocValuesGen = info.getNextDocValuesGen();\n      final String segmentSuffix = Long.toString(nextDocValuesGen, Character.MAX_RADIX);\n      final long estUpdatesSize = fieldUpdates.ramBytesPerDoc() * info.info.getDocCount();\n      final IOContext updatesContext = new IOContext(new FlushInfo(info.info.getDocCount(), estUpdatesSize));\n      final FieldInfo fieldInfo = infos.fieldInfo(field);\n      assert fieldInfo != null;\n      fieldInfo.setDocValuesGen(nextDocValuesGen);\n      final FieldInfos fieldInfos = new FieldInfos(new FieldInfo[] { fieldInfo });\n      // separately also track which files were created for this gen\n      final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n      final SegmentWriteState state = new SegmentWriteState(null, trackingDir, info.info, fieldInfos, null, updatesContext, segmentSuffix);\n      try (final DocValuesConsumer fieldsConsumer = dvFormat.fieldsConsumer(state)) {\n        // write the binary updates to a new gen'd docvalues file\n        fieldsConsumer.addBinaryField(fieldInfo, new Iterable<BytesRef>() {\n          final BinaryDocValues currentValues = reader.getBinaryDocValues(field);\n          final Bits docsWithField = reader.getDocsWithField(field);\n          final int maxDoc = reader.maxDoc();\n          final BinaryDocValuesFieldUpdates.Iterator updatesIter = fieldUpdates.iterator();\n          @Override\n          public Iterator<BytesRef> iterator() {\n            updatesIter.reset();\n            return new Iterator<BytesRef>() {\n              \n              int curDoc = -1;\n              int updateDoc = updatesIter.nextDoc();\n              \n              @Override\n              public boolean hasNext() {\n                return curDoc < maxDoc - 1;\n              }\n              \n              @Override\n              public BytesRef next() {\n                if (++curDoc >= maxDoc) {\n                  throw new NoSuchElementException(\"no more documents to return values for\");\n                }\n                if (curDoc == updateDoc) { // this document has an updated value\n                  BytesRef value = updatesIter.value(); // either null (unset value) or updated value\n                  updateDoc = updatesIter.nextDoc(); // prepare for next round\n                  return value;\n                } else {\n                  // no update for this document\n                  assert curDoc < updateDoc;\n                  if (currentValues != null && docsWithField.get(curDoc)) {\n                    // only read the current value if the document had a value before\n                    return currentValues.get(curDoc);\n                  } else {\n                    return null;\n                  }\n                }\n              }\n              \n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException(\"this iterator does not support removing elements\");\n              }\n            };\n          }\n        });\n      }\n      info.advanceDocValuesGen();\n      assert !fieldFiles.containsKey(fieldInfo.number);\n      fieldFiles.put(fieldInfo.number, trackingDir.getCreatedFiles());\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"synthetic-access\")\n  private void handleBinaryDVUpdates(FieldInfos infos, Map<String,BinaryDocValuesFieldUpdates> updates, \n      TrackingDirectoryWrapper dir, DocValuesFormat dvFormat, final SegmentReader reader, Map<Integer,Set<String>> fieldFiles) throws IOException {\n    for (Entry<String,BinaryDocValuesFieldUpdates> e : updates.entrySet()) {\n      final String field = e.getKey();\n      final BinaryDocValuesFieldUpdates fieldUpdates = e.getValue();\n\n      final long nextDocValuesGen = info.getNextDocValuesGen();\n      final String segmentSuffix = Long.toString(nextDocValuesGen, Character.MAX_RADIX);\n      final long estUpdatesSize = fieldUpdates.ramBytesPerDoc() * info.info.getDocCount();\n      final IOContext updatesContext = new IOContext(new FlushInfo(info.info.getDocCount(), estUpdatesSize));\n      final FieldInfo fieldInfo = infos.fieldInfo(field);\n      assert fieldInfo != null;\n      fieldInfo.setDocValuesGen(nextDocValuesGen);\n      final FieldInfos fieldInfos = new FieldInfos(new FieldInfo[] { fieldInfo });\n      // separately also track which files were created for this gen\n      final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n      final SegmentWriteState state = new SegmentWriteState(null, trackingDir, info.info, fieldInfos, null, updatesContext, segmentSuffix);\n      try (final DocValuesConsumer fieldsConsumer = dvFormat.fieldsConsumer(state)) {\n        // write the binary updates to a new gen'd docvalues file\n        fieldsConsumer.addBinaryField(fieldInfo, new Iterable<BytesRef>() {\n          final BinaryDocValues currentValues = reader.getBinaryDocValues(field);\n          final Bits docsWithField = reader.getDocsWithField(field);\n          final int maxDoc = reader.maxDoc();\n          final BinaryDocValuesFieldUpdates.Iterator updatesIter = fieldUpdates.iterator();\n          @Override\n          public Iterator<BytesRef> iterator() {\n            updatesIter.reset();\n            return new Iterator<BytesRef>() {\n              \n              int curDoc = -1;\n              int updateDoc = updatesIter.nextDoc();\n              BytesRef scratch = new BytesRef();\n              \n              @Override\n              public boolean hasNext() {\n                return curDoc < maxDoc - 1;\n              }\n              \n              @Override\n              public BytesRef next() {\n                if (++curDoc >= maxDoc) {\n                  throw new NoSuchElementException(\"no more documents to return values for\");\n                }\n                if (curDoc == updateDoc) { // this document has an updated value\n                  BytesRef value = updatesIter.value(); // either null (unset value) or updated value\n                  updateDoc = updatesIter.nextDoc(); // prepare for next round\n                  return value;\n                } else {\n                  // no update for this document\n                  assert curDoc < updateDoc;\n                  if (currentValues != null && docsWithField.get(curDoc)) {\n                    // only read the current value if the document had a value before\n                    currentValues.get(curDoc, scratch);\n                    return scratch;\n                  } else {\n                    return null;\n                  }\n                }\n              }\n              \n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException(\"this iterator does not support removing elements\");\n              }\n            };\n          }\n        });\n      }\n      info.advanceDocValuesGen();\n      assert !fieldFiles.containsKey(fieldInfo.number);\n      fieldFiles.put(fieldInfo.number, trackingDir.getCreatedFiles());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0267c69e2456a3477a1ad785723f2135da3117e","date":1425317087,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#handleBinaryDVUpdates(FieldInfos,Map[String,BinaryDocValuesFieldUpdates],TrackingDirectoryWrapper,DocValuesFormat,SegmentReader,Map[Integer,Set[String]]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#handleBinaryDVUpdates(FieldInfos,Map[String,BinaryDocValuesFieldUpdates],TrackingDirectoryWrapper,DocValuesFormat,SegmentReader,Map[Integer,Set[String]]).mjava","sourceNew":"  @SuppressWarnings(\"synthetic-access\")\n  private void handleBinaryDVUpdates(FieldInfos infos, Map<String,BinaryDocValuesFieldUpdates> updates, \n      TrackingDirectoryWrapper dir, DocValuesFormat dvFormat, final SegmentReader reader, Map<Integer,Set<String>> fieldFiles) throws IOException {\n    for (Entry<String,BinaryDocValuesFieldUpdates> e : updates.entrySet()) {\n      final String field = e.getKey();\n      final BinaryDocValuesFieldUpdates fieldUpdates = e.getValue();\n\n      final long nextDocValuesGen = info.getNextDocValuesGen();\n      final String segmentSuffix = Long.toString(nextDocValuesGen, Character.MAX_RADIX);\n      final long estUpdatesSize = fieldUpdates.ramBytesPerDoc() * info.info.maxDoc();\n      final IOContext updatesContext = new IOContext(new FlushInfo(info.info.maxDoc(), estUpdatesSize));\n      final FieldInfo fieldInfo = infos.fieldInfo(field);\n      assert fieldInfo != null;\n      fieldInfo.setDocValuesGen(nextDocValuesGen);\n      final FieldInfos fieldInfos = new FieldInfos(new FieldInfo[] { fieldInfo });\n      // separately also track which files were created for this gen\n      final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n      final SegmentWriteState state = new SegmentWriteState(null, trackingDir, info.info, fieldInfos, null, updatesContext, segmentSuffix);\n      try (final DocValuesConsumer fieldsConsumer = dvFormat.fieldsConsumer(state)) {\n        // write the binary updates to a new gen'd docvalues file\n        fieldsConsumer.addBinaryField(fieldInfo, new Iterable<BytesRef>() {\n          final BinaryDocValues currentValues = reader.getBinaryDocValues(field);\n          final Bits docsWithField = reader.getDocsWithField(field);\n          final int maxDoc = reader.maxDoc();\n          final BinaryDocValuesFieldUpdates.Iterator updatesIter = fieldUpdates.iterator();\n          @Override\n          public Iterator<BytesRef> iterator() {\n            updatesIter.reset();\n            return new Iterator<BytesRef>() {\n              \n              int curDoc = -1;\n              int updateDoc = updatesIter.nextDoc();\n              \n              @Override\n              public boolean hasNext() {\n                return curDoc < maxDoc - 1;\n              }\n              \n              @Override\n              public BytesRef next() {\n                if (++curDoc >= maxDoc) {\n                  throw new NoSuchElementException(\"no more documents to return values for\");\n                }\n                if (curDoc == updateDoc) { // this document has an updated value\n                  BytesRef value = updatesIter.value(); // either null (unset value) or updated value\n                  updateDoc = updatesIter.nextDoc(); // prepare for next round\n                  return value;\n                } else {\n                  // no update for this document\n                  assert curDoc < updateDoc;\n                  if (currentValues != null && docsWithField.get(curDoc)) {\n                    // only read the current value if the document had a value before\n                    return currentValues.get(curDoc);\n                  } else {\n                    return null;\n                  }\n                }\n              }\n              \n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException(\"this iterator does not support removing elements\");\n              }\n            };\n          }\n        });\n      }\n      info.advanceDocValuesGen();\n      assert !fieldFiles.containsKey(fieldInfo.number);\n      fieldFiles.put(fieldInfo.number, trackingDir.getCreatedFiles());\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"synthetic-access\")\n  private void handleBinaryDVUpdates(FieldInfos infos, Map<String,BinaryDocValuesFieldUpdates> updates, \n      TrackingDirectoryWrapper dir, DocValuesFormat dvFormat, final SegmentReader reader, Map<Integer,Set<String>> fieldFiles) throws IOException {\n    for (Entry<String,BinaryDocValuesFieldUpdates> e : updates.entrySet()) {\n      final String field = e.getKey();\n      final BinaryDocValuesFieldUpdates fieldUpdates = e.getValue();\n\n      final long nextDocValuesGen = info.getNextDocValuesGen();\n      final String segmentSuffix = Long.toString(nextDocValuesGen, Character.MAX_RADIX);\n      final long estUpdatesSize = fieldUpdates.ramBytesPerDoc() * info.info.getDocCount();\n      final IOContext updatesContext = new IOContext(new FlushInfo(info.info.getDocCount(), estUpdatesSize));\n      final FieldInfo fieldInfo = infos.fieldInfo(field);\n      assert fieldInfo != null;\n      fieldInfo.setDocValuesGen(nextDocValuesGen);\n      final FieldInfos fieldInfos = new FieldInfos(new FieldInfo[] { fieldInfo });\n      // separately also track which files were created for this gen\n      final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n      final SegmentWriteState state = new SegmentWriteState(null, trackingDir, info.info, fieldInfos, null, updatesContext, segmentSuffix);\n      try (final DocValuesConsumer fieldsConsumer = dvFormat.fieldsConsumer(state)) {\n        // write the binary updates to a new gen'd docvalues file\n        fieldsConsumer.addBinaryField(fieldInfo, new Iterable<BytesRef>() {\n          final BinaryDocValues currentValues = reader.getBinaryDocValues(field);\n          final Bits docsWithField = reader.getDocsWithField(field);\n          final int maxDoc = reader.maxDoc();\n          final BinaryDocValuesFieldUpdates.Iterator updatesIter = fieldUpdates.iterator();\n          @Override\n          public Iterator<BytesRef> iterator() {\n            updatesIter.reset();\n            return new Iterator<BytesRef>() {\n              \n              int curDoc = -1;\n              int updateDoc = updatesIter.nextDoc();\n              \n              @Override\n              public boolean hasNext() {\n                return curDoc < maxDoc - 1;\n              }\n              \n              @Override\n              public BytesRef next() {\n                if (++curDoc >= maxDoc) {\n                  throw new NoSuchElementException(\"no more documents to return values for\");\n                }\n                if (curDoc == updateDoc) { // this document has an updated value\n                  BytesRef value = updatesIter.value(); // either null (unset value) or updated value\n                  updateDoc = updatesIter.nextDoc(); // prepare for next round\n                  return value;\n                } else {\n                  // no update for this document\n                  assert curDoc < updateDoc;\n                  if (currentValues != null && docsWithField.get(curDoc)) {\n                    // only read the current value if the document had a value before\n                    return currentValues.get(curDoc);\n                  } else {\n                    return null;\n                  }\n                }\n              }\n              \n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException(\"this iterator does not support removing elements\");\n              }\n            };\n          }\n        });\n      }\n      info.advanceDocValuesGen();\n      assert !fieldFiles.containsKey(fieldInfo.number);\n      fieldFiles.put(fieldInfo.number, trackingDir.getCreatedFiles());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b06445ae1731e049327712db0454e5643ca9b7fe","date":1425329139,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#handleBinaryDVUpdates(FieldInfos,Map[String,BinaryDocValuesFieldUpdates],TrackingDirectoryWrapper,DocValuesFormat,SegmentReader,Map[Integer,Set[String]]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#handleBinaryDVUpdates(FieldInfos,Map[String,BinaryDocValuesFieldUpdates],TrackingDirectoryWrapper,DocValuesFormat,SegmentReader,Map[Integer,Set[String]]).mjava","sourceNew":"  @SuppressWarnings(\"synthetic-access\")\n  private void handleBinaryDVUpdates(FieldInfos infos, Map<String,BinaryDocValuesFieldUpdates> updates, \n      TrackingDirectoryWrapper dir, DocValuesFormat dvFormat, final SegmentReader reader, Map<Integer,Set<String>> fieldFiles) throws IOException {\n    for (Entry<String,BinaryDocValuesFieldUpdates> e : updates.entrySet()) {\n      final String field = e.getKey();\n      final BinaryDocValuesFieldUpdates fieldUpdates = e.getValue();\n\n      final long nextDocValuesGen = info.getNextDocValuesGen();\n      final String segmentSuffix = Long.toString(nextDocValuesGen, Character.MAX_RADIX);\n      final long estUpdatesSize = fieldUpdates.ramBytesPerDoc() * info.info.maxDoc();\n      final IOContext updatesContext = new IOContext(new FlushInfo(info.info.maxDoc(), estUpdatesSize));\n      final FieldInfo fieldInfo = infos.fieldInfo(field);\n      assert fieldInfo != null;\n      fieldInfo.setDocValuesGen(nextDocValuesGen);\n      final FieldInfos fieldInfos = new FieldInfos(new FieldInfo[] { fieldInfo });\n      // separately also track which files were created for this gen\n      final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n      final SegmentWriteState state = new SegmentWriteState(null, trackingDir, info.info, fieldInfos, null, updatesContext, segmentSuffix);\n      try (final DocValuesConsumer fieldsConsumer = dvFormat.fieldsConsumer(state)) {\n        // write the binary updates to a new gen'd docvalues file\n        fieldsConsumer.addBinaryField(fieldInfo, new Iterable<BytesRef>() {\n          final BinaryDocValues currentValues = reader.getBinaryDocValues(field);\n          final Bits docsWithField = reader.getDocsWithField(field);\n          final int maxDoc = reader.maxDoc();\n          final BinaryDocValuesFieldUpdates.Iterator updatesIter = fieldUpdates.iterator();\n          @Override\n          public Iterator<BytesRef> iterator() {\n            updatesIter.reset();\n            return new Iterator<BytesRef>() {\n              \n              int curDoc = -1;\n              int updateDoc = updatesIter.nextDoc();\n              \n              @Override\n              public boolean hasNext() {\n                return curDoc < maxDoc - 1;\n              }\n              \n              @Override\n              public BytesRef next() {\n                if (++curDoc >= maxDoc) {\n                  throw new NoSuchElementException(\"no more documents to return values for\");\n                }\n                if (curDoc == updateDoc) { // this document has an updated value\n                  BytesRef value = updatesIter.value(); // either null (unset value) or updated value\n                  updateDoc = updatesIter.nextDoc(); // prepare for next round\n                  return value;\n                } else {\n                  // no update for this document\n                  assert curDoc < updateDoc;\n                  if (currentValues != null && docsWithField.get(curDoc)) {\n                    // only read the current value if the document had a value before\n                    return currentValues.get(curDoc);\n                  } else {\n                    return null;\n                  }\n                }\n              }\n              \n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException(\"this iterator does not support removing elements\");\n              }\n            };\n          }\n        });\n      }\n      info.advanceDocValuesGen();\n      assert !fieldFiles.containsKey(fieldInfo.number);\n      fieldFiles.put(fieldInfo.number, trackingDir.getCreatedFiles());\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"synthetic-access\")\n  private void handleBinaryDVUpdates(FieldInfos infos, Map<String,BinaryDocValuesFieldUpdates> updates, \n      TrackingDirectoryWrapper dir, DocValuesFormat dvFormat, final SegmentReader reader, Map<Integer,Set<String>> fieldFiles) throws IOException {\n    for (Entry<String,BinaryDocValuesFieldUpdates> e : updates.entrySet()) {\n      final String field = e.getKey();\n      final BinaryDocValuesFieldUpdates fieldUpdates = e.getValue();\n\n      final long nextDocValuesGen = info.getNextDocValuesGen();\n      final String segmentSuffix = Long.toString(nextDocValuesGen, Character.MAX_RADIX);\n      final long estUpdatesSize = fieldUpdates.ramBytesPerDoc() * info.info.getDocCount();\n      final IOContext updatesContext = new IOContext(new FlushInfo(info.info.getDocCount(), estUpdatesSize));\n      final FieldInfo fieldInfo = infos.fieldInfo(field);\n      assert fieldInfo != null;\n      fieldInfo.setDocValuesGen(nextDocValuesGen);\n      final FieldInfos fieldInfos = new FieldInfos(new FieldInfo[] { fieldInfo });\n      // separately also track which files were created for this gen\n      final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n      final SegmentWriteState state = new SegmentWriteState(null, trackingDir, info.info, fieldInfos, null, updatesContext, segmentSuffix);\n      try (final DocValuesConsumer fieldsConsumer = dvFormat.fieldsConsumer(state)) {\n        // write the binary updates to a new gen'd docvalues file\n        fieldsConsumer.addBinaryField(fieldInfo, new Iterable<BytesRef>() {\n          final BinaryDocValues currentValues = reader.getBinaryDocValues(field);\n          final Bits docsWithField = reader.getDocsWithField(field);\n          final int maxDoc = reader.maxDoc();\n          final BinaryDocValuesFieldUpdates.Iterator updatesIter = fieldUpdates.iterator();\n          @Override\n          public Iterator<BytesRef> iterator() {\n            updatesIter.reset();\n            return new Iterator<BytesRef>() {\n              \n              int curDoc = -1;\n              int updateDoc = updatesIter.nextDoc();\n              \n              @Override\n              public boolean hasNext() {\n                return curDoc < maxDoc - 1;\n              }\n              \n              @Override\n              public BytesRef next() {\n                if (++curDoc >= maxDoc) {\n                  throw new NoSuchElementException(\"no more documents to return values for\");\n                }\n                if (curDoc == updateDoc) { // this document has an updated value\n                  BytesRef value = updatesIter.value(); // either null (unset value) or updated value\n                  updateDoc = updatesIter.nextDoc(); // prepare for next round\n                  return value;\n                } else {\n                  // no update for this document\n                  assert curDoc < updateDoc;\n                  if (currentValues != null && docsWithField.get(curDoc)) {\n                    // only read the current value if the document had a value before\n                    return currentValues.get(curDoc);\n                  } else {\n                    return null;\n                  }\n                }\n              }\n              \n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException(\"this iterator does not support removing elements\");\n              }\n            };\n          }\n        });\n      }\n      info.advanceDocValuesGen();\n      assert !fieldFiles.containsKey(fieldInfo.number);\n      fieldFiles.put(fieldInfo.number, trackingDir.getCreatedFiles());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#handleBinaryDVUpdates(FieldInfos,Map[String,BinaryDocValuesFieldUpdates],TrackingDirectoryWrapper,DocValuesFormat,SegmentReader,Map[Integer,Set[String]]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#handleBinaryDVUpdates(FieldInfos,Map[String,BinaryDocValuesFieldUpdates],TrackingDirectoryWrapper,DocValuesFormat,SegmentReader,Map[Integer,Set[String]]).mjava","sourceNew":"  @SuppressWarnings(\"synthetic-access\")\n  private void handleBinaryDVUpdates(FieldInfos infos, Map<String,BinaryDocValuesFieldUpdates> updates, \n      TrackingDirectoryWrapper dir, DocValuesFormat dvFormat, final SegmentReader reader, Map<Integer,Set<String>> fieldFiles) throws IOException {\n    for (Entry<String,BinaryDocValuesFieldUpdates> e : updates.entrySet()) {\n      final String field = e.getKey();\n      final BinaryDocValuesFieldUpdates fieldUpdates = e.getValue();\n\n      final long nextDocValuesGen = info.getNextDocValuesGen();\n      final String segmentSuffix = Long.toString(nextDocValuesGen, Character.MAX_RADIX);\n      final long estUpdatesSize = fieldUpdates.ramBytesPerDoc() * info.info.maxDoc();\n      final IOContext updatesContext = new IOContext(new FlushInfo(info.info.maxDoc(), estUpdatesSize));\n      final FieldInfo fieldInfo = infos.fieldInfo(field);\n      assert fieldInfo != null;\n      fieldInfo.setDocValuesGen(nextDocValuesGen);\n      final FieldInfos fieldInfos = new FieldInfos(new FieldInfo[] { fieldInfo });\n      // separately also track which files were created for this gen\n      final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n      final SegmentWriteState state = new SegmentWriteState(null, trackingDir, info.info, fieldInfos, null, updatesContext, segmentSuffix);\n      try (final DocValuesConsumer fieldsConsumer = dvFormat.fieldsConsumer(state)) {\n        // write the binary updates to a new gen'd docvalues file\n        fieldsConsumer.addBinaryField(fieldInfo, new Iterable<BytesRef>() {\n          final BinaryDocValues currentValues = reader.getBinaryDocValues(field);\n          final Bits docsWithField = reader.getDocsWithField(field);\n          final int maxDoc = reader.maxDoc();\n          final BinaryDocValuesFieldUpdates.Iterator updatesIter = fieldUpdates.iterator();\n          @Override\n          public Iterator<BytesRef> iterator() {\n            updatesIter.reset();\n            return new Iterator<BytesRef>() {\n              \n              int curDoc = -1;\n              int updateDoc = updatesIter.nextDoc();\n              \n              @Override\n              public boolean hasNext() {\n                return curDoc < maxDoc - 1;\n              }\n              \n              @Override\n              public BytesRef next() {\n                if (++curDoc >= maxDoc) {\n                  throw new NoSuchElementException(\"no more documents to return values for\");\n                }\n                if (curDoc == updateDoc) { // this document has an updated value\n                  BytesRef value = updatesIter.value(); // either null (unset value) or updated value\n                  updateDoc = updatesIter.nextDoc(); // prepare for next round\n                  return value;\n                } else {\n                  // no update for this document\n                  assert curDoc < updateDoc;\n                  if (currentValues != null && docsWithField.get(curDoc)) {\n                    // only read the current value if the document had a value before\n                    return currentValues.get(curDoc);\n                  } else {\n                    return null;\n                  }\n                }\n              }\n              \n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException(\"this iterator does not support removing elements\");\n              }\n            };\n          }\n        });\n      }\n      info.advanceDocValuesGen();\n      assert !fieldFiles.containsKey(fieldInfo.number);\n      fieldFiles.put(fieldInfo.number, trackingDir.getCreatedFiles());\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"synthetic-access\")\n  private void handleBinaryDVUpdates(FieldInfos infos, Map<String,BinaryDocValuesFieldUpdates> updates, \n      TrackingDirectoryWrapper dir, DocValuesFormat dvFormat, final SegmentReader reader, Map<Integer,Set<String>> fieldFiles) throws IOException {\n    for (Entry<String,BinaryDocValuesFieldUpdates> e : updates.entrySet()) {\n      final String field = e.getKey();\n      final BinaryDocValuesFieldUpdates fieldUpdates = e.getValue();\n\n      final long nextDocValuesGen = info.getNextDocValuesGen();\n      final String segmentSuffix = Long.toString(nextDocValuesGen, Character.MAX_RADIX);\n      final long estUpdatesSize = fieldUpdates.ramBytesPerDoc() * info.info.getDocCount();\n      final IOContext updatesContext = new IOContext(new FlushInfo(info.info.getDocCount(), estUpdatesSize));\n      final FieldInfo fieldInfo = infos.fieldInfo(field);\n      assert fieldInfo != null;\n      fieldInfo.setDocValuesGen(nextDocValuesGen);\n      final FieldInfos fieldInfos = new FieldInfos(new FieldInfo[] { fieldInfo });\n      // separately also track which files were created for this gen\n      final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n      final SegmentWriteState state = new SegmentWriteState(null, trackingDir, info.info, fieldInfos, null, updatesContext, segmentSuffix);\n      try (final DocValuesConsumer fieldsConsumer = dvFormat.fieldsConsumer(state)) {\n        // write the binary updates to a new gen'd docvalues file\n        fieldsConsumer.addBinaryField(fieldInfo, new Iterable<BytesRef>() {\n          final BinaryDocValues currentValues = reader.getBinaryDocValues(field);\n          final Bits docsWithField = reader.getDocsWithField(field);\n          final int maxDoc = reader.maxDoc();\n          final BinaryDocValuesFieldUpdates.Iterator updatesIter = fieldUpdates.iterator();\n          @Override\n          public Iterator<BytesRef> iterator() {\n            updatesIter.reset();\n            return new Iterator<BytesRef>() {\n              \n              int curDoc = -1;\n              int updateDoc = updatesIter.nextDoc();\n              \n              @Override\n              public boolean hasNext() {\n                return curDoc < maxDoc - 1;\n              }\n              \n              @Override\n              public BytesRef next() {\n                if (++curDoc >= maxDoc) {\n                  throw new NoSuchElementException(\"no more documents to return values for\");\n                }\n                if (curDoc == updateDoc) { // this document has an updated value\n                  BytesRef value = updatesIter.value(); // either null (unset value) or updated value\n                  updateDoc = updatesIter.nextDoc(); // prepare for next round\n                  return value;\n                } else {\n                  // no update for this document\n                  assert curDoc < updateDoc;\n                  if (currentValues != null && docsWithField.get(curDoc)) {\n                    // only read the current value if the document had a value before\n                    return currentValues.get(curDoc);\n                  } else {\n                    return null;\n                  }\n                }\n              }\n              \n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException(\"this iterator does not support removing elements\");\n              }\n            };\n          }\n        });\n      }\n      info.advanceDocValuesGen();\n      assert !fieldFiles.containsKey(fieldInfo.number);\n      fieldFiles.put(fieldInfo.number, trackingDir.getCreatedFiles());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6652c74b2358a0b13223817a6a793bf1c9d0749d","date":1474465301,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#handleBinaryDVUpdates(FieldInfos,Map[String,BinaryDocValuesFieldUpdates],TrackingDirectoryWrapper,DocValuesFormat,SegmentReader,Map[Integer,Set[String]]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#handleBinaryDVUpdates(FieldInfos,Map[String,BinaryDocValuesFieldUpdates],TrackingDirectoryWrapper,DocValuesFormat,SegmentReader,Map[Integer,Set[String]]).mjava","sourceNew":"  @SuppressWarnings(\"synthetic-access\")\n  private void handleBinaryDVUpdates(FieldInfos infos, Map<String,BinaryDocValuesFieldUpdates> updates, \n      TrackingDirectoryWrapper dir, DocValuesFormat dvFormat, final SegmentReader reader, Map<Integer,Set<String>> fieldFiles) throws IOException {\n    for (Entry<String,BinaryDocValuesFieldUpdates> e : updates.entrySet()) {\n      final String field = e.getKey();\n      final BinaryDocValuesFieldUpdates fieldUpdates = e.getValue();\n\n      final long nextDocValuesGen = info.getNextDocValuesGen();\n      final String segmentSuffix = Long.toString(nextDocValuesGen, Character.MAX_RADIX);\n      final long estUpdatesSize = fieldUpdates.ramBytesPerDoc() * info.info.maxDoc();\n      final IOContext updatesContext = new IOContext(new FlushInfo(info.info.maxDoc(), estUpdatesSize));\n      final FieldInfo fieldInfo = infos.fieldInfo(field);\n      assert fieldInfo != null;\n      fieldInfo.setDocValuesGen(nextDocValuesGen);\n      final FieldInfos fieldInfos = new FieldInfos(new FieldInfo[] { fieldInfo });\n      // separately also track which files were created for this gen\n      final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n      final SegmentWriteState state = new SegmentWriteState(null, trackingDir, info.info, fieldInfos, null, updatesContext, segmentSuffix);\n      try (final DocValuesConsumer fieldsConsumer = dvFormat.fieldsConsumer(state)) {\n        // write the binary updates to a new gen'd docvalues file\n\n        fieldsConsumer.addBinaryField(fieldInfo, new EmptyDocValuesProducer() {\n            @Override\n            public BinaryDocValues getBinary(FieldInfo fieldInfoIn) throws IOException {\n              if (fieldInfoIn != fieldInfo) {\n                throw new IllegalArgumentException(\"wrong fieldInfo\");\n              }\n              final int maxDoc = reader.maxDoc();\n\n              final BinaryDocValuesFieldUpdates.Iterator updatesIter = fieldUpdates.iterator();\n              updatesIter.reset();\n\n              final BinaryDocValues currentValues = reader.getBinaryDocValues(field);\n\n              // Merge sort of the original doc values with updated doc values:\n              return new BinaryDocValues() {\n                // merged docID\n                private int docIDOut = -1;\n\n                // docID from our original doc values\n                private int docIDIn = -1;\n\n                // docID from our updates\n                private int updateDocID = -1;\n\n                private BytesRef value;\n\n                @Override\n                public int docID() {\n                  return docIDOut;\n                }\n\n                @Override\n                public int advance(int target) {\n                  throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public long cost() {\n                  return currentValues.cost();\n                }\n\n                @Override\n                public BytesRef binaryValue() {\n                  return value;\n                }\n\n                @Override\n                public int nextDoc() throws IOException {\n                  if (docIDIn == docIDOut) {\n                    if (currentValues == null) {\n                      docIDIn = NO_MORE_DOCS;\n                    } else {\n                      docIDIn = currentValues.nextDoc();\n                    }\n                  }\n                  if (updateDocID == docIDOut) {\n                    updateDocID = updatesIter.nextDoc();\n                  }\n                  if (docIDIn < updateDocID) {\n                    // no update to this doc\n                    docIDOut = docIDIn;\n                    value = currentValues.binaryValue();\n                  } else {\n                    docIDOut = updateDocID;\n                    if (docIDOut != NO_MORE_DOCS) {\n                      value = updatesIter.value();\n                    }\n                  }\n                  return docIDOut;\n                }\n              };\n            }\n          });\n      }\n      info.advanceDocValuesGen();\n      assert !fieldFiles.containsKey(fieldInfo.number);\n      fieldFiles.put(fieldInfo.number, trackingDir.getCreatedFiles());\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"synthetic-access\")\n  private void handleBinaryDVUpdates(FieldInfos infos, Map<String,BinaryDocValuesFieldUpdates> updates, \n      TrackingDirectoryWrapper dir, DocValuesFormat dvFormat, final SegmentReader reader, Map<Integer,Set<String>> fieldFiles) throws IOException {\n    for (Entry<String,BinaryDocValuesFieldUpdates> e : updates.entrySet()) {\n      final String field = e.getKey();\n      final BinaryDocValuesFieldUpdates fieldUpdates = e.getValue();\n\n      final long nextDocValuesGen = info.getNextDocValuesGen();\n      final String segmentSuffix = Long.toString(nextDocValuesGen, Character.MAX_RADIX);\n      final long estUpdatesSize = fieldUpdates.ramBytesPerDoc() * info.info.maxDoc();\n      final IOContext updatesContext = new IOContext(new FlushInfo(info.info.maxDoc(), estUpdatesSize));\n      final FieldInfo fieldInfo = infos.fieldInfo(field);\n      assert fieldInfo != null;\n      fieldInfo.setDocValuesGen(nextDocValuesGen);\n      final FieldInfos fieldInfos = new FieldInfos(new FieldInfo[] { fieldInfo });\n      // separately also track which files were created for this gen\n      final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n      final SegmentWriteState state = new SegmentWriteState(null, trackingDir, info.info, fieldInfos, null, updatesContext, segmentSuffix);\n      try (final DocValuesConsumer fieldsConsumer = dvFormat.fieldsConsumer(state)) {\n        // write the binary updates to a new gen'd docvalues file\n        fieldsConsumer.addBinaryField(fieldInfo, new Iterable<BytesRef>() {\n          final BinaryDocValues currentValues = reader.getBinaryDocValues(field);\n          final Bits docsWithField = reader.getDocsWithField(field);\n          final int maxDoc = reader.maxDoc();\n          final BinaryDocValuesFieldUpdates.Iterator updatesIter = fieldUpdates.iterator();\n          @Override\n          public Iterator<BytesRef> iterator() {\n            updatesIter.reset();\n            return new Iterator<BytesRef>() {\n              \n              int curDoc = -1;\n              int updateDoc = updatesIter.nextDoc();\n              \n              @Override\n              public boolean hasNext() {\n                return curDoc < maxDoc - 1;\n              }\n              \n              @Override\n              public BytesRef next() {\n                if (++curDoc >= maxDoc) {\n                  throw new NoSuchElementException(\"no more documents to return values for\");\n                }\n                if (curDoc == updateDoc) { // this document has an updated value\n                  BytesRef value = updatesIter.value(); // either null (unset value) or updated value\n                  updateDoc = updatesIter.nextDoc(); // prepare for next round\n                  return value;\n                } else {\n                  // no update for this document\n                  assert curDoc < updateDoc;\n                  if (currentValues != null && docsWithField.get(curDoc)) {\n                    // only read the current value if the document had a value before\n                    return currentValues.get(curDoc);\n                  } else {\n                    return null;\n                  }\n                }\n              }\n              \n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException(\"this iterator does not support removing elements\");\n              }\n            };\n          }\n        });\n      }\n      info.advanceDocValuesGen();\n      assert !fieldFiles.containsKey(fieldInfo.number);\n      fieldFiles.put(fieldInfo.number, trackingDir.getCreatedFiles());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#handleBinaryDVUpdates(FieldInfos,Map[String,BinaryDocValuesFieldUpdates],TrackingDirectoryWrapper,DocValuesFormat,SegmentReader,Map[Integer,Set[String]]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#handleBinaryDVUpdates(FieldInfos,Map[String,BinaryDocValuesFieldUpdates],TrackingDirectoryWrapper,DocValuesFormat,SegmentReader,Map[Integer,Set[String]]).mjava","sourceNew":"  @SuppressWarnings(\"synthetic-access\")\n  private void handleBinaryDVUpdates(FieldInfos infos, Map<String,BinaryDocValuesFieldUpdates> updates, \n      TrackingDirectoryWrapper dir, DocValuesFormat dvFormat, final SegmentReader reader, Map<Integer,Set<String>> fieldFiles) throws IOException {\n    for (Entry<String,BinaryDocValuesFieldUpdates> e : updates.entrySet()) {\n      final String field = e.getKey();\n      final BinaryDocValuesFieldUpdates fieldUpdates = e.getValue();\n\n      final long nextDocValuesGen = info.getNextDocValuesGen();\n      final String segmentSuffix = Long.toString(nextDocValuesGen, Character.MAX_RADIX);\n      final long estUpdatesSize = fieldUpdates.ramBytesPerDoc() * info.info.maxDoc();\n      final IOContext updatesContext = new IOContext(new FlushInfo(info.info.maxDoc(), estUpdatesSize));\n      final FieldInfo fieldInfo = infos.fieldInfo(field);\n      assert fieldInfo != null;\n      fieldInfo.setDocValuesGen(nextDocValuesGen);\n      final FieldInfos fieldInfos = new FieldInfos(new FieldInfo[] { fieldInfo });\n      // separately also track which files were created for this gen\n      final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n      final SegmentWriteState state = new SegmentWriteState(null, trackingDir, info.info, fieldInfos, null, updatesContext, segmentSuffix);\n      try (final DocValuesConsumer fieldsConsumer = dvFormat.fieldsConsumer(state)) {\n        // write the binary updates to a new gen'd docvalues file\n\n        fieldsConsumer.addBinaryField(fieldInfo, new EmptyDocValuesProducer() {\n            @Override\n            public BinaryDocValues getBinary(FieldInfo fieldInfoIn) throws IOException {\n              if (fieldInfoIn != fieldInfo) {\n                throw new IllegalArgumentException(\"wrong fieldInfo\");\n              }\n              final int maxDoc = reader.maxDoc();\n\n              final BinaryDocValuesFieldUpdates.Iterator updatesIter = fieldUpdates.iterator();\n              updatesIter.reset();\n\n              final BinaryDocValues currentValues = reader.getBinaryDocValues(field);\n\n              // Merge sort of the original doc values with updated doc values:\n              return new BinaryDocValues() {\n                // merged docID\n                private int docIDOut = -1;\n\n                // docID from our original doc values\n                private int docIDIn = -1;\n\n                // docID from our updates\n                private int updateDocID = -1;\n\n                private BytesRef value;\n\n                @Override\n                public int docID() {\n                  return docIDOut;\n                }\n\n                @Override\n                public int advance(int target) {\n                  throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public long cost() {\n                  return currentValues.cost();\n                }\n\n                @Override\n                public BytesRef binaryValue() {\n                  return value;\n                }\n\n                @Override\n                public int nextDoc() throws IOException {\n                  if (docIDIn == docIDOut) {\n                    if (currentValues == null) {\n                      docIDIn = NO_MORE_DOCS;\n                    } else {\n                      docIDIn = currentValues.nextDoc();\n                    }\n                  }\n                  if (updateDocID == docIDOut) {\n                    updateDocID = updatesIter.nextDoc();\n                  }\n                  if (docIDIn < updateDocID) {\n                    // no update to this doc\n                    docIDOut = docIDIn;\n                    value = currentValues.binaryValue();\n                  } else {\n                    docIDOut = updateDocID;\n                    if (docIDOut != NO_MORE_DOCS) {\n                      value = updatesIter.value();\n                    }\n                  }\n                  return docIDOut;\n                }\n              };\n            }\n          });\n      }\n      info.advanceDocValuesGen();\n      assert !fieldFiles.containsKey(fieldInfo.number);\n      fieldFiles.put(fieldInfo.number, trackingDir.getCreatedFiles());\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"synthetic-access\")\n  private void handleBinaryDVUpdates(FieldInfos infos, Map<String,BinaryDocValuesFieldUpdates> updates, \n      TrackingDirectoryWrapper dir, DocValuesFormat dvFormat, final SegmentReader reader, Map<Integer,Set<String>> fieldFiles) throws IOException {\n    for (Entry<String,BinaryDocValuesFieldUpdates> e : updates.entrySet()) {\n      final String field = e.getKey();\n      final BinaryDocValuesFieldUpdates fieldUpdates = e.getValue();\n\n      final long nextDocValuesGen = info.getNextDocValuesGen();\n      final String segmentSuffix = Long.toString(nextDocValuesGen, Character.MAX_RADIX);\n      final long estUpdatesSize = fieldUpdates.ramBytesPerDoc() * info.info.maxDoc();\n      final IOContext updatesContext = new IOContext(new FlushInfo(info.info.maxDoc(), estUpdatesSize));\n      final FieldInfo fieldInfo = infos.fieldInfo(field);\n      assert fieldInfo != null;\n      fieldInfo.setDocValuesGen(nextDocValuesGen);\n      final FieldInfos fieldInfos = new FieldInfos(new FieldInfo[] { fieldInfo });\n      // separately also track which files were created for this gen\n      final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n      final SegmentWriteState state = new SegmentWriteState(null, trackingDir, info.info, fieldInfos, null, updatesContext, segmentSuffix);\n      try (final DocValuesConsumer fieldsConsumer = dvFormat.fieldsConsumer(state)) {\n        // write the binary updates to a new gen'd docvalues file\n        fieldsConsumer.addBinaryField(fieldInfo, new Iterable<BytesRef>() {\n          final BinaryDocValues currentValues = reader.getBinaryDocValues(field);\n          final Bits docsWithField = reader.getDocsWithField(field);\n          final int maxDoc = reader.maxDoc();\n          final BinaryDocValuesFieldUpdates.Iterator updatesIter = fieldUpdates.iterator();\n          @Override\n          public Iterator<BytesRef> iterator() {\n            updatesIter.reset();\n            return new Iterator<BytesRef>() {\n              \n              int curDoc = -1;\n              int updateDoc = updatesIter.nextDoc();\n              \n              @Override\n              public boolean hasNext() {\n                return curDoc < maxDoc - 1;\n              }\n              \n              @Override\n              public BytesRef next() {\n                if (++curDoc >= maxDoc) {\n                  throw new NoSuchElementException(\"no more documents to return values for\");\n                }\n                if (curDoc == updateDoc) { // this document has an updated value\n                  BytesRef value = updatesIter.value(); // either null (unset value) or updated value\n                  updateDoc = updatesIter.nextDoc(); // prepare for next round\n                  return value;\n                } else {\n                  // no update for this document\n                  assert curDoc < updateDoc;\n                  if (currentValues != null && docsWithField.get(curDoc)) {\n                    // only read the current value if the document had a value before\n                    return currentValues.get(curDoc);\n                  } else {\n                    return null;\n                  }\n                }\n              }\n              \n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException(\"this iterator does not support removing elements\");\n              }\n            };\n          }\n        });\n      }\n      info.advanceDocValuesGen();\n      assert !fieldFiles.containsKey(fieldInfo.number);\n      fieldFiles.put(fieldInfo.number, trackingDir.getCreatedFiles());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#handleBinaryDVUpdates(FieldInfos,Map[String,BinaryDocValuesFieldUpdates],TrackingDirectoryWrapper,DocValuesFormat,SegmentReader,Map[Integer,Set[String]]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#handleBinaryDVUpdates(FieldInfos,Map[String,BinaryDocValuesFieldUpdates],TrackingDirectoryWrapper,DocValuesFormat,SegmentReader,Map[Integer,Set[String]]).mjava","sourceNew":"  @SuppressWarnings(\"synthetic-access\")\n  private void handleBinaryDVUpdates(FieldInfos infos, Map<String,BinaryDocValuesFieldUpdates> updates, \n      TrackingDirectoryWrapper dir, DocValuesFormat dvFormat, final SegmentReader reader, Map<Integer,Set<String>> fieldFiles) throws IOException {\n    for (Entry<String,BinaryDocValuesFieldUpdates> e : updates.entrySet()) {\n      final String field = e.getKey();\n      final BinaryDocValuesFieldUpdates fieldUpdates = e.getValue();\n\n      final long nextDocValuesGen = info.getNextDocValuesGen();\n      final String segmentSuffix = Long.toString(nextDocValuesGen, Character.MAX_RADIX);\n      final long estUpdatesSize = fieldUpdates.ramBytesPerDoc() * info.info.maxDoc();\n      final IOContext updatesContext = new IOContext(new FlushInfo(info.info.maxDoc(), estUpdatesSize));\n      final FieldInfo fieldInfo = infos.fieldInfo(field);\n      assert fieldInfo != null;\n      fieldInfo.setDocValuesGen(nextDocValuesGen);\n      final FieldInfos fieldInfos = new FieldInfos(new FieldInfo[] { fieldInfo });\n      // separately also track which files were created for this gen\n      final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n      final SegmentWriteState state = new SegmentWriteState(null, trackingDir, info.info, fieldInfos, null, updatesContext, segmentSuffix);\n      try (final DocValuesConsumer fieldsConsumer = dvFormat.fieldsConsumer(state)) {\n        // write the binary updates to a new gen'd docvalues file\n\n        fieldsConsumer.addBinaryField(fieldInfo, new EmptyDocValuesProducer() {\n            @Override\n            public BinaryDocValues getBinary(FieldInfo fieldInfoIn) throws IOException {\n              if (fieldInfoIn != fieldInfo) {\n                throw new IllegalArgumentException(\"wrong fieldInfo\");\n              }\n              final int maxDoc = reader.maxDoc();\n\n              final BinaryDocValuesFieldUpdates.Iterator updatesIter = fieldUpdates.iterator();\n              updatesIter.reset();\n\n              final BinaryDocValues currentValues = reader.getBinaryDocValues(field);\n\n              // Merge sort of the original doc values with updated doc values:\n              return new BinaryDocValues() {\n                // merged docID\n                private int docIDOut = -1;\n\n                // docID from our original doc values\n                private int docIDIn = -1;\n\n                // docID from our updates\n                private int updateDocID = -1;\n\n                private BytesRef value;\n\n                @Override\n                public int docID() {\n                  return docIDOut;\n                }\n\n                @Override\n                public int advance(int target) {\n                  throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public long cost() {\n                  return currentValues.cost();\n                }\n\n                @Override\n                public BytesRef binaryValue() {\n                  return value;\n                }\n\n                @Override\n                public int nextDoc() throws IOException {\n                  if (docIDIn == docIDOut) {\n                    if (currentValues == null) {\n                      docIDIn = NO_MORE_DOCS;\n                    } else {\n                      docIDIn = currentValues.nextDoc();\n                    }\n                  }\n                  if (updateDocID == docIDOut) {\n                    updateDocID = updatesIter.nextDoc();\n                  }\n                  if (docIDIn < updateDocID) {\n                    // no update to this doc\n                    docIDOut = docIDIn;\n                    value = currentValues.binaryValue();\n                  } else {\n                    docIDOut = updateDocID;\n                    if (docIDOut != NO_MORE_DOCS) {\n                      value = updatesIter.value();\n                    }\n                  }\n                  return docIDOut;\n                }\n              };\n            }\n          });\n      }\n      info.advanceDocValuesGen();\n      assert !fieldFiles.containsKey(fieldInfo.number);\n      fieldFiles.put(fieldInfo.number, trackingDir.getCreatedFiles());\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"synthetic-access\")\n  private void handleBinaryDVUpdates(FieldInfos infos, Map<String,BinaryDocValuesFieldUpdates> updates, \n      TrackingDirectoryWrapper dir, DocValuesFormat dvFormat, final SegmentReader reader, Map<Integer,Set<String>> fieldFiles) throws IOException {\n    for (Entry<String,BinaryDocValuesFieldUpdates> e : updates.entrySet()) {\n      final String field = e.getKey();\n      final BinaryDocValuesFieldUpdates fieldUpdates = e.getValue();\n\n      final long nextDocValuesGen = info.getNextDocValuesGen();\n      final String segmentSuffix = Long.toString(nextDocValuesGen, Character.MAX_RADIX);\n      final long estUpdatesSize = fieldUpdates.ramBytesPerDoc() * info.info.maxDoc();\n      final IOContext updatesContext = new IOContext(new FlushInfo(info.info.maxDoc(), estUpdatesSize));\n      final FieldInfo fieldInfo = infos.fieldInfo(field);\n      assert fieldInfo != null;\n      fieldInfo.setDocValuesGen(nextDocValuesGen);\n      final FieldInfos fieldInfos = new FieldInfos(new FieldInfo[] { fieldInfo });\n      // separately also track which files were created for this gen\n      final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n      final SegmentWriteState state = new SegmentWriteState(null, trackingDir, info.info, fieldInfos, null, updatesContext, segmentSuffix);\n      try (final DocValuesConsumer fieldsConsumer = dvFormat.fieldsConsumer(state)) {\n        // write the binary updates to a new gen'd docvalues file\n        fieldsConsumer.addBinaryField(fieldInfo, new Iterable<BytesRef>() {\n          final BinaryDocValues currentValues = reader.getBinaryDocValues(field);\n          final Bits docsWithField = reader.getDocsWithField(field);\n          final int maxDoc = reader.maxDoc();\n          final BinaryDocValuesFieldUpdates.Iterator updatesIter = fieldUpdates.iterator();\n          @Override\n          public Iterator<BytesRef> iterator() {\n            updatesIter.reset();\n            return new Iterator<BytesRef>() {\n              \n              int curDoc = -1;\n              int updateDoc = updatesIter.nextDoc();\n              \n              @Override\n              public boolean hasNext() {\n                return curDoc < maxDoc - 1;\n              }\n              \n              @Override\n              public BytesRef next() {\n                if (++curDoc >= maxDoc) {\n                  throw new NoSuchElementException(\"no more documents to return values for\");\n                }\n                if (curDoc == updateDoc) { // this document has an updated value\n                  BytesRef value = updatesIter.value(); // either null (unset value) or updated value\n                  updateDoc = updatesIter.nextDoc(); // prepare for next round\n                  return value;\n                } else {\n                  // no update for this document\n                  assert curDoc < updateDoc;\n                  if (currentValues != null && docsWithField.get(curDoc)) {\n                    // only read the current value if the document had a value before\n                    return currentValues.get(curDoc);\n                  } else {\n                    return null;\n                  }\n                }\n              }\n              \n              @Override\n              public void remove() {\n                throw new UnsupportedOperationException(\"this iterator does not support removing elements\");\n              }\n            };\n          }\n        });\n      }\n      info.advanceDocValuesGen();\n      assert !fieldFiles.containsKey(fieldInfo.number);\n      fieldFiles.put(fieldInfo.number, trackingDir.getCreatedFiles());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"11134e449dabe11d6d0ff6a564d84b82cbe93722","date":1477299083,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#handleBinaryDVUpdates(FieldInfos,Map[String,BinaryDocValuesFieldUpdates],TrackingDirectoryWrapper,DocValuesFormat,SegmentReader,Map[Integer,Set[String]]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#handleBinaryDVUpdates(FieldInfos,Map[String,BinaryDocValuesFieldUpdates],TrackingDirectoryWrapper,DocValuesFormat,SegmentReader,Map[Integer,Set[String]]).mjava","sourceNew":"  @SuppressWarnings(\"synthetic-access\")\n  private void handleBinaryDVUpdates(FieldInfos infos, Map<String,BinaryDocValuesFieldUpdates> updates, \n      TrackingDirectoryWrapper dir, DocValuesFormat dvFormat, final SegmentReader reader, Map<Integer,Set<String>> fieldFiles) throws IOException {\n    for (Entry<String,BinaryDocValuesFieldUpdates> e : updates.entrySet()) {\n      final String field = e.getKey();\n      final BinaryDocValuesFieldUpdates fieldUpdates = e.getValue();\n\n      final long nextDocValuesGen = info.getNextDocValuesGen();\n      final String segmentSuffix = Long.toString(nextDocValuesGen, Character.MAX_RADIX);\n      final long estUpdatesSize = fieldUpdates.ramBytesPerDoc() * info.info.maxDoc();\n      final IOContext updatesContext = new IOContext(new FlushInfo(info.info.maxDoc(), estUpdatesSize));\n      final FieldInfo fieldInfo = infos.fieldInfo(field);\n      assert fieldInfo != null;\n      fieldInfo.setDocValuesGen(nextDocValuesGen);\n      final FieldInfos fieldInfos = new FieldInfos(new FieldInfo[] { fieldInfo });\n      // separately also track which files were created for this gen\n      final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n      final SegmentWriteState state = new SegmentWriteState(null, trackingDir, info.info, fieldInfos, null, updatesContext, segmentSuffix);\n      try (final DocValuesConsumer fieldsConsumer = dvFormat.fieldsConsumer(state)) {\n        // write the binary updates to a new gen'd docvalues file\n\n        fieldsConsumer.addBinaryField(fieldInfo, new EmptyDocValuesProducer() {\n            @Override\n            public BinaryDocValues getBinary(FieldInfo fieldInfoIn) throws IOException {\n              if (fieldInfoIn != fieldInfo) {\n                throw new IllegalArgumentException(\"wrong fieldInfo\");\n              }\n              final int maxDoc = reader.maxDoc();\n\n              final BinaryDocValuesFieldUpdates.Iterator updatesIter = fieldUpdates.iterator();\n              updatesIter.reset();\n\n              final BinaryDocValues currentValues = reader.getBinaryDocValues(field);\n\n              // Merge sort of the original doc values with updated doc values:\n              return new BinaryDocValues() {\n                // merged docID\n                private int docIDOut = -1;\n\n                // docID from our original doc values\n                private int docIDIn = -1;\n\n                // docID from our updates\n                private int updateDocID = -1;\n\n                private BytesRef value;\n\n                @Override\n                public int docID() {\n                  return docIDOut;\n                }\n\n                @Override\n                public int advance(int target) {\n                  throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public boolean advanceExact(int target) throws IOException {\n                  throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public long cost() {\n                  return currentValues.cost();\n                }\n\n                @Override\n                public BytesRef binaryValue() {\n                  return value;\n                }\n\n                @Override\n                public int nextDoc() throws IOException {\n                  if (docIDIn == docIDOut) {\n                    if (currentValues == null) {\n                      docIDIn = NO_MORE_DOCS;\n                    } else {\n                      docIDIn = currentValues.nextDoc();\n                    }\n                  }\n                  if (updateDocID == docIDOut) {\n                    updateDocID = updatesIter.nextDoc();\n                  }\n                  if (docIDIn < updateDocID) {\n                    // no update to this doc\n                    docIDOut = docIDIn;\n                    value = currentValues.binaryValue();\n                  } else {\n                    docIDOut = updateDocID;\n                    if (docIDOut != NO_MORE_DOCS) {\n                      value = updatesIter.value();\n                    }\n                  }\n                  return docIDOut;\n                }\n              };\n            }\n          });\n      }\n      info.advanceDocValuesGen();\n      assert !fieldFiles.containsKey(fieldInfo.number);\n      fieldFiles.put(fieldInfo.number, trackingDir.getCreatedFiles());\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"synthetic-access\")\n  private void handleBinaryDVUpdates(FieldInfos infos, Map<String,BinaryDocValuesFieldUpdates> updates, \n      TrackingDirectoryWrapper dir, DocValuesFormat dvFormat, final SegmentReader reader, Map<Integer,Set<String>> fieldFiles) throws IOException {\n    for (Entry<String,BinaryDocValuesFieldUpdates> e : updates.entrySet()) {\n      final String field = e.getKey();\n      final BinaryDocValuesFieldUpdates fieldUpdates = e.getValue();\n\n      final long nextDocValuesGen = info.getNextDocValuesGen();\n      final String segmentSuffix = Long.toString(nextDocValuesGen, Character.MAX_RADIX);\n      final long estUpdatesSize = fieldUpdates.ramBytesPerDoc() * info.info.maxDoc();\n      final IOContext updatesContext = new IOContext(new FlushInfo(info.info.maxDoc(), estUpdatesSize));\n      final FieldInfo fieldInfo = infos.fieldInfo(field);\n      assert fieldInfo != null;\n      fieldInfo.setDocValuesGen(nextDocValuesGen);\n      final FieldInfos fieldInfos = new FieldInfos(new FieldInfo[] { fieldInfo });\n      // separately also track which files were created for this gen\n      final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n      final SegmentWriteState state = new SegmentWriteState(null, trackingDir, info.info, fieldInfos, null, updatesContext, segmentSuffix);\n      try (final DocValuesConsumer fieldsConsumer = dvFormat.fieldsConsumer(state)) {\n        // write the binary updates to a new gen'd docvalues file\n\n        fieldsConsumer.addBinaryField(fieldInfo, new EmptyDocValuesProducer() {\n            @Override\n            public BinaryDocValues getBinary(FieldInfo fieldInfoIn) throws IOException {\n              if (fieldInfoIn != fieldInfo) {\n                throw new IllegalArgumentException(\"wrong fieldInfo\");\n              }\n              final int maxDoc = reader.maxDoc();\n\n              final BinaryDocValuesFieldUpdates.Iterator updatesIter = fieldUpdates.iterator();\n              updatesIter.reset();\n\n              final BinaryDocValues currentValues = reader.getBinaryDocValues(field);\n\n              // Merge sort of the original doc values with updated doc values:\n              return new BinaryDocValues() {\n                // merged docID\n                private int docIDOut = -1;\n\n                // docID from our original doc values\n                private int docIDIn = -1;\n\n                // docID from our updates\n                private int updateDocID = -1;\n\n                private BytesRef value;\n\n                @Override\n                public int docID() {\n                  return docIDOut;\n                }\n\n                @Override\n                public int advance(int target) {\n                  throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public long cost() {\n                  return currentValues.cost();\n                }\n\n                @Override\n                public BytesRef binaryValue() {\n                  return value;\n                }\n\n                @Override\n                public int nextDoc() throws IOException {\n                  if (docIDIn == docIDOut) {\n                    if (currentValues == null) {\n                      docIDIn = NO_MORE_DOCS;\n                    } else {\n                      docIDIn = currentValues.nextDoc();\n                    }\n                  }\n                  if (updateDocID == docIDOut) {\n                    updateDocID = updatesIter.nextDoc();\n                  }\n                  if (docIDIn < updateDocID) {\n                    // no update to this doc\n                    docIDOut = docIDIn;\n                    value = currentValues.binaryValue();\n                  } else {\n                    docIDOut = updateDocID;\n                    if (docIDOut != NO_MORE_DOCS) {\n                      value = updatesIter.value();\n                    }\n                  }\n                  return docIDOut;\n                }\n              };\n            }\n          });\n      }\n      info.advanceDocValuesGen();\n      assert !fieldFiles.containsKey(fieldInfo.number);\n      fieldFiles.put(fieldInfo.number, trackingDir.getCreatedFiles());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2714c85633b642b29871cf5ff8d17d3ba7bfd76","date":1477307753,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#handleBinaryDVUpdates(FieldInfos,Map[String,BinaryDocValuesFieldUpdates],TrackingDirectoryWrapper,DocValuesFormat,SegmentReader,Map[Integer,Set[String]]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#handleBinaryDVUpdates(FieldInfos,Map[String,BinaryDocValuesFieldUpdates],TrackingDirectoryWrapper,DocValuesFormat,SegmentReader,Map[Integer,Set[String]]).mjava","sourceNew":"  @SuppressWarnings(\"synthetic-access\")\n  private void handleBinaryDVUpdates(FieldInfos infos, Map<String,BinaryDocValuesFieldUpdates> updates, \n      TrackingDirectoryWrapper dir, DocValuesFormat dvFormat, final SegmentReader reader, Map<Integer,Set<String>> fieldFiles) throws IOException {\n    for (Entry<String,BinaryDocValuesFieldUpdates> e : updates.entrySet()) {\n      final String field = e.getKey();\n      final BinaryDocValuesFieldUpdates fieldUpdates = e.getValue();\n\n      final long nextDocValuesGen = info.getNextDocValuesGen();\n      final String segmentSuffix = Long.toString(nextDocValuesGen, Character.MAX_RADIX);\n      final long estUpdatesSize = fieldUpdates.ramBytesPerDoc() * info.info.maxDoc();\n      final IOContext updatesContext = new IOContext(new FlushInfo(info.info.maxDoc(), estUpdatesSize));\n      final FieldInfo fieldInfo = infos.fieldInfo(field);\n      assert fieldInfo != null;\n      fieldInfo.setDocValuesGen(nextDocValuesGen);\n      final FieldInfos fieldInfos = new FieldInfos(new FieldInfo[] { fieldInfo });\n      // separately also track which files were created for this gen\n      final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n      final SegmentWriteState state = new SegmentWriteState(null, trackingDir, info.info, fieldInfos, null, updatesContext, segmentSuffix);\n      try (final DocValuesConsumer fieldsConsumer = dvFormat.fieldsConsumer(state)) {\n        // write the binary updates to a new gen'd docvalues file\n\n        fieldsConsumer.addBinaryField(fieldInfo, new EmptyDocValuesProducer() {\n            @Override\n            public BinaryDocValues getBinary(FieldInfo fieldInfoIn) throws IOException {\n              if (fieldInfoIn != fieldInfo) {\n                throw new IllegalArgumentException(\"wrong fieldInfo\");\n              }\n              final int maxDoc = reader.maxDoc();\n\n              final BinaryDocValuesFieldUpdates.Iterator updatesIter = fieldUpdates.iterator();\n              updatesIter.reset();\n\n              final BinaryDocValues currentValues = reader.getBinaryDocValues(field);\n\n              // Merge sort of the original doc values with updated doc values:\n              return new BinaryDocValues() {\n                // merged docID\n                private int docIDOut = -1;\n\n                // docID from our original doc values\n                private int docIDIn = -1;\n\n                // docID from our updates\n                private int updateDocID = -1;\n\n                private BytesRef value;\n\n                @Override\n                public int docID() {\n                  return docIDOut;\n                }\n\n                @Override\n                public int advance(int target) {\n                  throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public boolean advanceExact(int target) throws IOException {\n                  throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public long cost() {\n                  return currentValues.cost();\n                }\n\n                @Override\n                public BytesRef binaryValue() {\n                  return value;\n                }\n\n                @Override\n                public int nextDoc() throws IOException {\n                  if (docIDIn == docIDOut) {\n                    if (currentValues == null) {\n                      docIDIn = NO_MORE_DOCS;\n                    } else {\n                      docIDIn = currentValues.nextDoc();\n                    }\n                  }\n                  if (updateDocID == docIDOut) {\n                    updateDocID = updatesIter.nextDoc();\n                  }\n                  if (docIDIn < updateDocID) {\n                    // no update to this doc\n                    docIDOut = docIDIn;\n                    value = currentValues.binaryValue();\n                  } else {\n                    docIDOut = updateDocID;\n                    if (docIDOut != NO_MORE_DOCS) {\n                      value = updatesIter.value();\n                    }\n                  }\n                  return docIDOut;\n                }\n              };\n            }\n          });\n      }\n      info.advanceDocValuesGen();\n      assert !fieldFiles.containsKey(fieldInfo.number);\n      fieldFiles.put(fieldInfo.number, trackingDir.getCreatedFiles());\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"synthetic-access\")\n  private void handleBinaryDVUpdates(FieldInfos infos, Map<String,BinaryDocValuesFieldUpdates> updates, \n      TrackingDirectoryWrapper dir, DocValuesFormat dvFormat, final SegmentReader reader, Map<Integer,Set<String>> fieldFiles) throws IOException {\n    for (Entry<String,BinaryDocValuesFieldUpdates> e : updates.entrySet()) {\n      final String field = e.getKey();\n      final BinaryDocValuesFieldUpdates fieldUpdates = e.getValue();\n\n      final long nextDocValuesGen = info.getNextDocValuesGen();\n      final String segmentSuffix = Long.toString(nextDocValuesGen, Character.MAX_RADIX);\n      final long estUpdatesSize = fieldUpdates.ramBytesPerDoc() * info.info.maxDoc();\n      final IOContext updatesContext = new IOContext(new FlushInfo(info.info.maxDoc(), estUpdatesSize));\n      final FieldInfo fieldInfo = infos.fieldInfo(field);\n      assert fieldInfo != null;\n      fieldInfo.setDocValuesGen(nextDocValuesGen);\n      final FieldInfos fieldInfos = new FieldInfos(new FieldInfo[] { fieldInfo });\n      // separately also track which files were created for this gen\n      final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n      final SegmentWriteState state = new SegmentWriteState(null, trackingDir, info.info, fieldInfos, null, updatesContext, segmentSuffix);\n      try (final DocValuesConsumer fieldsConsumer = dvFormat.fieldsConsumer(state)) {\n        // write the binary updates to a new gen'd docvalues file\n\n        fieldsConsumer.addBinaryField(fieldInfo, new EmptyDocValuesProducer() {\n            @Override\n            public BinaryDocValues getBinary(FieldInfo fieldInfoIn) throws IOException {\n              if (fieldInfoIn != fieldInfo) {\n                throw new IllegalArgumentException(\"wrong fieldInfo\");\n              }\n              final int maxDoc = reader.maxDoc();\n\n              final BinaryDocValuesFieldUpdates.Iterator updatesIter = fieldUpdates.iterator();\n              updatesIter.reset();\n\n              final BinaryDocValues currentValues = reader.getBinaryDocValues(field);\n\n              // Merge sort of the original doc values with updated doc values:\n              return new BinaryDocValues() {\n                // merged docID\n                private int docIDOut = -1;\n\n                // docID from our original doc values\n                private int docIDIn = -1;\n\n                // docID from our updates\n                private int updateDocID = -1;\n\n                private BytesRef value;\n\n                @Override\n                public int docID() {\n                  return docIDOut;\n                }\n\n                @Override\n                public int advance(int target) {\n                  throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public long cost() {\n                  return currentValues.cost();\n                }\n\n                @Override\n                public BytesRef binaryValue() {\n                  return value;\n                }\n\n                @Override\n                public int nextDoc() throws IOException {\n                  if (docIDIn == docIDOut) {\n                    if (currentValues == null) {\n                      docIDIn = NO_MORE_DOCS;\n                    } else {\n                      docIDIn = currentValues.nextDoc();\n                    }\n                  }\n                  if (updateDocID == docIDOut) {\n                    updateDocID = updatesIter.nextDoc();\n                  }\n                  if (docIDIn < updateDocID) {\n                    // no update to this doc\n                    docIDOut = docIDIn;\n                    value = currentValues.binaryValue();\n                  } else {\n                    docIDOut = updateDocID;\n                    if (docIDOut != NO_MORE_DOCS) {\n                      value = updatesIter.value();\n                    }\n                  }\n                  return docIDOut;\n                }\n              };\n            }\n          });\n      }\n      info.advanceDocValuesGen();\n      assert !fieldFiles.containsKey(fieldInfo.number);\n      fieldFiles.put(fieldInfo.number, trackingDir.getCreatedFiles());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"80d0e6d59ae23f4a6f30eaf40bfb40742300287f","date":1477598926,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#handleBinaryDVUpdates(FieldInfos,Map[String,BinaryDocValuesFieldUpdates],TrackingDirectoryWrapper,DocValuesFormat,SegmentReader,Map[Integer,Set[String]]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#handleBinaryDVUpdates(FieldInfos,Map[String,BinaryDocValuesFieldUpdates],TrackingDirectoryWrapper,DocValuesFormat,SegmentReader,Map[Integer,Set[String]]).mjava","sourceNew":"  @SuppressWarnings(\"synthetic-access\")\n  private void handleBinaryDVUpdates(FieldInfos infos, Map<String,BinaryDocValuesFieldUpdates> updates, \n      TrackingDirectoryWrapper dir, DocValuesFormat dvFormat, final SegmentReader reader, Map<Integer,Set<String>> fieldFiles) throws IOException {\n    for (Entry<String,BinaryDocValuesFieldUpdates> e : updates.entrySet()) {\n      final String field = e.getKey();\n      final BinaryDocValuesFieldUpdates fieldUpdates = e.getValue();\n\n      final long nextDocValuesGen = info.getNextDocValuesGen();\n      final String segmentSuffix = Long.toString(nextDocValuesGen, Character.MAX_RADIX);\n      final long estUpdatesSize = fieldUpdates.ramBytesPerDoc() * info.info.maxDoc();\n      final IOContext updatesContext = new IOContext(new FlushInfo(info.info.maxDoc(), estUpdatesSize));\n      final FieldInfo fieldInfo = infos.fieldInfo(field);\n      assert fieldInfo != null;\n      fieldInfo.setDocValuesGen(nextDocValuesGen);\n      final FieldInfos fieldInfos = new FieldInfos(new FieldInfo[] { fieldInfo });\n      // separately also track which files were created for this gen\n      final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n      final SegmentWriteState state = new SegmentWriteState(null, trackingDir, info.info, fieldInfos, null, updatesContext, segmentSuffix);\n      try (final DocValuesConsumer fieldsConsumer = dvFormat.fieldsConsumer(state)) {\n        // write the binary updates to a new gen'd docvalues file\n\n        fieldsConsumer.addBinaryField(fieldInfo, new EmptyDocValuesProducer() {\n            @Override\n            public BinaryDocValues getBinary(FieldInfo fieldInfoIn) throws IOException {\n              if (fieldInfoIn != fieldInfo) {\n                throw new IllegalArgumentException(\"wrong fieldInfo\");\n              }\n              final int maxDoc = reader.maxDoc();\n\n              final BinaryDocValuesFieldUpdates.Iterator updatesIter = fieldUpdates.iterator();\n              updatesIter.reset();\n\n              final BinaryDocValues currentValues = reader.getBinaryDocValues(field);\n\n              // Merge sort of the original doc values with updated doc values:\n              return new BinaryDocValues() {\n                // merged docID\n                private int docIDOut = -1;\n\n                // docID from our original doc values\n                private int docIDIn = -1;\n\n                // docID from our updates\n                private int updateDocID = -1;\n\n                private BytesRef value;\n\n                @Override\n                public int docID() {\n                  return docIDOut;\n                }\n\n                @Override\n                public int advance(int target) {\n                  throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public boolean advanceExact(int target) throws IOException {\n                  throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public long cost() {\n                  return currentValues.cost();\n                }\n\n                @Override\n                public BytesRef binaryValue() {\n                  return value;\n                }\n\n                @Override\n                public int nextDoc() throws IOException {\n                  if (docIDIn == docIDOut) {\n                    if (currentValues == null) {\n                      docIDIn = NO_MORE_DOCS;\n                    } else {\n                      docIDIn = currentValues.nextDoc();\n                    }\n                  }\n                  if (updateDocID == docIDOut) {\n                    updateDocID = updatesIter.nextDoc();\n                  }\n                  if (docIDIn < updateDocID) {\n                    // no update to this doc\n                    docIDOut = docIDIn;\n                    value = currentValues.binaryValue();\n                  } else {\n                    docIDOut = updateDocID;\n                    if (docIDOut != NO_MORE_DOCS) {\n                      value = updatesIter.value();\n                    }\n                  }\n                  return docIDOut;\n                }\n              };\n            }\n          });\n      }\n      info.advanceDocValuesGen();\n      assert !fieldFiles.containsKey(fieldInfo.number);\n      fieldFiles.put(fieldInfo.number, trackingDir.getCreatedFiles());\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"synthetic-access\")\n  private void handleBinaryDVUpdates(FieldInfos infos, Map<String,BinaryDocValuesFieldUpdates> updates, \n      TrackingDirectoryWrapper dir, DocValuesFormat dvFormat, final SegmentReader reader, Map<Integer,Set<String>> fieldFiles) throws IOException {\n    for (Entry<String,BinaryDocValuesFieldUpdates> e : updates.entrySet()) {\n      final String field = e.getKey();\n      final BinaryDocValuesFieldUpdates fieldUpdates = e.getValue();\n\n      final long nextDocValuesGen = info.getNextDocValuesGen();\n      final String segmentSuffix = Long.toString(nextDocValuesGen, Character.MAX_RADIX);\n      final long estUpdatesSize = fieldUpdates.ramBytesPerDoc() * info.info.maxDoc();\n      final IOContext updatesContext = new IOContext(new FlushInfo(info.info.maxDoc(), estUpdatesSize));\n      final FieldInfo fieldInfo = infos.fieldInfo(field);\n      assert fieldInfo != null;\n      fieldInfo.setDocValuesGen(nextDocValuesGen);\n      final FieldInfos fieldInfos = new FieldInfos(new FieldInfo[] { fieldInfo });\n      // separately also track which files were created for this gen\n      final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n      final SegmentWriteState state = new SegmentWriteState(null, trackingDir, info.info, fieldInfos, null, updatesContext, segmentSuffix);\n      try (final DocValuesConsumer fieldsConsumer = dvFormat.fieldsConsumer(state)) {\n        // write the binary updates to a new gen'd docvalues file\n\n        fieldsConsumer.addBinaryField(fieldInfo, new EmptyDocValuesProducer() {\n            @Override\n            public BinaryDocValues getBinary(FieldInfo fieldInfoIn) throws IOException {\n              if (fieldInfoIn != fieldInfo) {\n                throw new IllegalArgumentException(\"wrong fieldInfo\");\n              }\n              final int maxDoc = reader.maxDoc();\n\n              final BinaryDocValuesFieldUpdates.Iterator updatesIter = fieldUpdates.iterator();\n              updatesIter.reset();\n\n              final BinaryDocValues currentValues = reader.getBinaryDocValues(field);\n\n              // Merge sort of the original doc values with updated doc values:\n              return new BinaryDocValues() {\n                // merged docID\n                private int docIDOut = -1;\n\n                // docID from our original doc values\n                private int docIDIn = -1;\n\n                // docID from our updates\n                private int updateDocID = -1;\n\n                private BytesRef value;\n\n                @Override\n                public int docID() {\n                  return docIDOut;\n                }\n\n                @Override\n                public int advance(int target) {\n                  throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public long cost() {\n                  return currentValues.cost();\n                }\n\n                @Override\n                public BytesRef binaryValue() {\n                  return value;\n                }\n\n                @Override\n                public int nextDoc() throws IOException {\n                  if (docIDIn == docIDOut) {\n                    if (currentValues == null) {\n                      docIDIn = NO_MORE_DOCS;\n                    } else {\n                      docIDIn = currentValues.nextDoc();\n                    }\n                  }\n                  if (updateDocID == docIDOut) {\n                    updateDocID = updatesIter.nextDoc();\n                  }\n                  if (docIDIn < updateDocID) {\n                    // no update to this doc\n                    docIDOut = docIDIn;\n                    value = currentValues.binaryValue();\n                  } else {\n                    docIDOut = updateDocID;\n                    if (docIDOut != NO_MORE_DOCS) {\n                      value = updatesIter.value();\n                    }\n                  }\n                  return docIDOut;\n                }\n              };\n            }\n          });\n      }\n      info.advanceDocValuesGen();\n      assert !fieldFiles.containsKey(fieldInfo.number);\n      fieldFiles.put(fieldInfo.number, trackingDir.getCreatedFiles());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4363cd33f6eff7fb4753574a441e2d18c1022a4","date":1498067235,"type":5,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#handleBinaryDVUpdates(FieldInfos,TrackingDirectoryWrapper,DocValuesFormat,SegmentReader,Map[Integer,Set[String]],long,InfoStream).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#handleBinaryDVUpdates(FieldInfos,Map[String,BinaryDocValuesFieldUpdates],TrackingDirectoryWrapper,DocValuesFormat,SegmentReader,Map[Integer,Set[String]]).mjava","sourceNew":"  @SuppressWarnings(\"synthetic-access\")\n  private synchronized void handleBinaryDVUpdates(FieldInfos infos,\n                                                  TrackingDirectoryWrapper dir, DocValuesFormat dvFormat, final SegmentReader reader,\n                                                  Map<Integer,Set<String>> fieldFiles, long maxDelGen, InfoStream infoStream) throws IOException {\n    for (Entry<String,List<DocValuesFieldUpdates>> ent : pendingDVUpdates.entrySet()) {\n      final String field = ent.getKey();\n      final List<DocValuesFieldUpdates> updates = ent.getValue();\n      if (updates.get(0).type != DocValuesType.BINARY) {\n        continue;\n      }\n\n      final List<DocValuesFieldUpdates> updatesToApply = new ArrayList<>();\n      long bytes = 0;\n      for(DocValuesFieldUpdates update : updates) {\n        if (update.delGen <= maxDelGen) {\n          // safe to apply this one\n          bytes += update.ramBytesUsed();\n          updatesToApply.add(update);\n        }\n      }\n      if (updatesToApply.isEmpty()) {\n        // nothing to apply yet\n        continue;\n      }\n\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", String.format(Locale.ROOT,\n                                               \"now write %d pending binary DV updates for field=%s, seg=%s, bytes=%.3fMB\",\n                                               updatesToApply.size(),\n                                               field,\n                                               info,\n                                               bytes/1024./1024.));\n      }\n\n      final long nextDocValuesGen = info.getNextDocValuesGen();\n      final String segmentSuffix = Long.toString(nextDocValuesGen, Character.MAX_RADIX);\n      final IOContext updatesContext = new IOContext(new FlushInfo(info.info.maxDoc(), bytes));\n      final FieldInfo fieldInfo = infos.fieldInfo(field);\n      assert fieldInfo != null;\n      fieldInfo.setDocValuesGen(nextDocValuesGen);\n      final FieldInfos fieldInfos = new FieldInfos(new FieldInfo[] { fieldInfo });\n      // separately also track which files were created for this gen\n      final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n      final SegmentWriteState state = new SegmentWriteState(null, trackingDir, info.info, fieldInfos, null, updatesContext, segmentSuffix);\n      try (final DocValuesConsumer fieldsConsumer = dvFormat.fieldsConsumer(state)) {\n        // write the binary updates to a new gen'd docvalues file\n\n        fieldsConsumer.addBinaryField(fieldInfo, new EmptyDocValuesProducer() {\n            @Override\n            public BinaryDocValues getBinary(FieldInfo fieldInfoIn) throws IOException {\n              if (fieldInfoIn != fieldInfo) {\n                throw new IllegalArgumentException(\"wrong fieldInfo\");\n              }\n              final int maxDoc = reader.maxDoc();\n\n              DocValuesFieldUpdates.Iterator[] subs = new DocValuesFieldUpdates.Iterator[updatesToApply.size()];\n              for(int i=0;i<subs.length;i++) {\n                subs[i] = updatesToApply.get(i).iterator();\n              }\n\n              final DocValuesFieldUpdates.Iterator updatesIter = DocValuesFieldUpdates.mergedIterator(subs);\n\n              final BinaryDocValues currentValues = reader.getBinaryDocValues(field);\n\n              // Merge sort of the original doc values with updated doc values:\n              return new BinaryDocValues() {\n                // merged docID\n                private int docIDOut = -1;\n\n                // docID from our original doc values\n                private int docIDIn = -1;\n\n                // docID from our updates\n                private int updateDocID = -1;\n\n                private BytesRef value;\n\n                @Override\n                public int docID() {\n                  return docIDOut;\n                }\n\n                @Override\n                public int advance(int target) {\n                  throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public boolean advanceExact(int target) throws IOException {\n                  throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public long cost() {\n                  return currentValues.cost();\n                }\n\n                @Override\n                public BytesRef binaryValue() {\n                  return value;\n                }\n\n                @Override\n                public int nextDoc() throws IOException {\n                  if (docIDIn == docIDOut) {\n                    if (currentValues == null) {\n                      docIDIn = NO_MORE_DOCS;\n                    } else {\n                      docIDIn = currentValues.nextDoc();\n                    }\n                  }\n                  if (updateDocID == docIDOut) {\n                    updateDocID = updatesIter.nextDoc();\n                  }\n                  if (docIDIn < updateDocID) {\n                    // no update to this doc\n                    docIDOut = docIDIn;\n                    value = currentValues.binaryValue();\n                  } else {\n                    docIDOut = updateDocID;\n                    if (docIDOut != NO_MORE_DOCS) {\n                      value = (BytesRef) updatesIter.value();\n                    }\n                  }\n                  return docIDOut;\n                }\n              };\n            }\n          });\n      }\n      info.advanceDocValuesGen();\n      assert !fieldFiles.containsKey(fieldInfo.number);\n      fieldFiles.put(fieldInfo.number, trackingDir.getCreatedFiles());\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"synthetic-access\")\n  private void handleBinaryDVUpdates(FieldInfos infos, Map<String,BinaryDocValuesFieldUpdates> updates, \n      TrackingDirectoryWrapper dir, DocValuesFormat dvFormat, final SegmentReader reader, Map<Integer,Set<String>> fieldFiles) throws IOException {\n    for (Entry<String,BinaryDocValuesFieldUpdates> e : updates.entrySet()) {\n      final String field = e.getKey();\n      final BinaryDocValuesFieldUpdates fieldUpdates = e.getValue();\n\n      final long nextDocValuesGen = info.getNextDocValuesGen();\n      final String segmentSuffix = Long.toString(nextDocValuesGen, Character.MAX_RADIX);\n      final long estUpdatesSize = fieldUpdates.ramBytesPerDoc() * info.info.maxDoc();\n      final IOContext updatesContext = new IOContext(new FlushInfo(info.info.maxDoc(), estUpdatesSize));\n      final FieldInfo fieldInfo = infos.fieldInfo(field);\n      assert fieldInfo != null;\n      fieldInfo.setDocValuesGen(nextDocValuesGen);\n      final FieldInfos fieldInfos = new FieldInfos(new FieldInfo[] { fieldInfo });\n      // separately also track which files were created for this gen\n      final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n      final SegmentWriteState state = new SegmentWriteState(null, trackingDir, info.info, fieldInfos, null, updatesContext, segmentSuffix);\n      try (final DocValuesConsumer fieldsConsumer = dvFormat.fieldsConsumer(state)) {\n        // write the binary updates to a new gen'd docvalues file\n\n        fieldsConsumer.addBinaryField(fieldInfo, new EmptyDocValuesProducer() {\n            @Override\n            public BinaryDocValues getBinary(FieldInfo fieldInfoIn) throws IOException {\n              if (fieldInfoIn != fieldInfo) {\n                throw new IllegalArgumentException(\"wrong fieldInfo\");\n              }\n              final int maxDoc = reader.maxDoc();\n\n              final BinaryDocValuesFieldUpdates.Iterator updatesIter = fieldUpdates.iterator();\n              updatesIter.reset();\n\n              final BinaryDocValues currentValues = reader.getBinaryDocValues(field);\n\n              // Merge sort of the original doc values with updated doc values:\n              return new BinaryDocValues() {\n                // merged docID\n                private int docIDOut = -1;\n\n                // docID from our original doc values\n                private int docIDIn = -1;\n\n                // docID from our updates\n                private int updateDocID = -1;\n\n                private BytesRef value;\n\n                @Override\n                public int docID() {\n                  return docIDOut;\n                }\n\n                @Override\n                public int advance(int target) {\n                  throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public boolean advanceExact(int target) throws IOException {\n                  throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public long cost() {\n                  return currentValues.cost();\n                }\n\n                @Override\n                public BytesRef binaryValue() {\n                  return value;\n                }\n\n                @Override\n                public int nextDoc() throws IOException {\n                  if (docIDIn == docIDOut) {\n                    if (currentValues == null) {\n                      docIDIn = NO_MORE_DOCS;\n                    } else {\n                      docIDIn = currentValues.nextDoc();\n                    }\n                  }\n                  if (updateDocID == docIDOut) {\n                    updateDocID = updatesIter.nextDoc();\n                  }\n                  if (docIDIn < updateDocID) {\n                    // no update to this doc\n                    docIDOut = docIDIn;\n                    value = currentValues.binaryValue();\n                  } else {\n                    docIDOut = updateDocID;\n                    if (docIDOut != NO_MORE_DOCS) {\n                      value = updatesIter.value();\n                    }\n                  }\n                  return docIDOut;\n                }\n              };\n            }\n          });\n      }\n      info.advanceDocValuesGen();\n      assert !fieldFiles.containsKey(fieldInfo.number);\n      fieldFiles.put(fieldInfo.number, trackingDir.getCreatedFiles());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":5,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#handleBinaryDVUpdates(FieldInfos,TrackingDirectoryWrapper,DocValuesFormat,SegmentReader,Map[Integer,Set[String]],long,InfoStream).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#handleBinaryDVUpdates(FieldInfos,Map[String,BinaryDocValuesFieldUpdates],TrackingDirectoryWrapper,DocValuesFormat,SegmentReader,Map[Integer,Set[String]]).mjava","sourceNew":"  @SuppressWarnings(\"synthetic-access\")\n  private synchronized void handleBinaryDVUpdates(FieldInfos infos,\n                                                  TrackingDirectoryWrapper dir, DocValuesFormat dvFormat, final SegmentReader reader,\n                                                  Map<Integer,Set<String>> fieldFiles, long maxDelGen, InfoStream infoStream) throws IOException {\n    for (Entry<String,List<DocValuesFieldUpdates>> ent : pendingDVUpdates.entrySet()) {\n      final String field = ent.getKey();\n      final List<DocValuesFieldUpdates> updates = ent.getValue();\n      if (updates.get(0).type != DocValuesType.BINARY) {\n        continue;\n      }\n\n      final List<DocValuesFieldUpdates> updatesToApply = new ArrayList<>();\n      long bytes = 0;\n      for(DocValuesFieldUpdates update : updates) {\n        if (update.delGen <= maxDelGen) {\n          // safe to apply this one\n          bytes += update.ramBytesUsed();\n          updatesToApply.add(update);\n        }\n      }\n      if (updatesToApply.isEmpty()) {\n        // nothing to apply yet\n        continue;\n      }\n\n      if (infoStream.isEnabled(\"BD\")) {\n        infoStream.message(\"BD\", String.format(Locale.ROOT,\n                                               \"now write %d pending binary DV updates for field=%s, seg=%s, bytes=%.3fMB\",\n                                               updatesToApply.size(),\n                                               field,\n                                               info,\n                                               bytes/1024./1024.));\n      }\n\n      final long nextDocValuesGen = info.getNextDocValuesGen();\n      final String segmentSuffix = Long.toString(nextDocValuesGen, Character.MAX_RADIX);\n      final IOContext updatesContext = new IOContext(new FlushInfo(info.info.maxDoc(), bytes));\n      final FieldInfo fieldInfo = infos.fieldInfo(field);\n      assert fieldInfo != null;\n      fieldInfo.setDocValuesGen(nextDocValuesGen);\n      final FieldInfos fieldInfos = new FieldInfos(new FieldInfo[] { fieldInfo });\n      // separately also track which files were created for this gen\n      final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n      final SegmentWriteState state = new SegmentWriteState(null, trackingDir, info.info, fieldInfos, null, updatesContext, segmentSuffix);\n      try (final DocValuesConsumer fieldsConsumer = dvFormat.fieldsConsumer(state)) {\n        // write the binary updates to a new gen'd docvalues file\n\n        fieldsConsumer.addBinaryField(fieldInfo, new EmptyDocValuesProducer() {\n            @Override\n            public BinaryDocValues getBinary(FieldInfo fieldInfoIn) throws IOException {\n              if (fieldInfoIn != fieldInfo) {\n                throw new IllegalArgumentException(\"wrong fieldInfo\");\n              }\n              final int maxDoc = reader.maxDoc();\n\n              DocValuesFieldUpdates.Iterator[] subs = new DocValuesFieldUpdates.Iterator[updatesToApply.size()];\n              for(int i=0;i<subs.length;i++) {\n                subs[i] = updatesToApply.get(i).iterator();\n              }\n\n              final DocValuesFieldUpdates.Iterator updatesIter = DocValuesFieldUpdates.mergedIterator(subs);\n\n              final BinaryDocValues currentValues = reader.getBinaryDocValues(field);\n\n              // Merge sort of the original doc values with updated doc values:\n              return new BinaryDocValues() {\n                // merged docID\n                private int docIDOut = -1;\n\n                // docID from our original doc values\n                private int docIDIn = -1;\n\n                // docID from our updates\n                private int updateDocID = -1;\n\n                private BytesRef value;\n\n                @Override\n                public int docID() {\n                  return docIDOut;\n                }\n\n                @Override\n                public int advance(int target) {\n                  throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public boolean advanceExact(int target) throws IOException {\n                  throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public long cost() {\n                  return currentValues.cost();\n                }\n\n                @Override\n                public BytesRef binaryValue() {\n                  return value;\n                }\n\n                @Override\n                public int nextDoc() throws IOException {\n                  if (docIDIn == docIDOut) {\n                    if (currentValues == null) {\n                      docIDIn = NO_MORE_DOCS;\n                    } else {\n                      docIDIn = currentValues.nextDoc();\n                    }\n                  }\n                  if (updateDocID == docIDOut) {\n                    updateDocID = updatesIter.nextDoc();\n                  }\n                  if (docIDIn < updateDocID) {\n                    // no update to this doc\n                    docIDOut = docIDIn;\n                    value = currentValues.binaryValue();\n                  } else {\n                    docIDOut = updateDocID;\n                    if (docIDOut != NO_MORE_DOCS) {\n                      value = (BytesRef) updatesIter.value();\n                    }\n                  }\n                  return docIDOut;\n                }\n              };\n            }\n          });\n      }\n      info.advanceDocValuesGen();\n      assert !fieldFiles.containsKey(fieldInfo.number);\n      fieldFiles.put(fieldInfo.number, trackingDir.getCreatedFiles());\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"synthetic-access\")\n  private void handleBinaryDVUpdates(FieldInfos infos, Map<String,BinaryDocValuesFieldUpdates> updates, \n      TrackingDirectoryWrapper dir, DocValuesFormat dvFormat, final SegmentReader reader, Map<Integer,Set<String>> fieldFiles) throws IOException {\n    for (Entry<String,BinaryDocValuesFieldUpdates> e : updates.entrySet()) {\n      final String field = e.getKey();\n      final BinaryDocValuesFieldUpdates fieldUpdates = e.getValue();\n\n      final long nextDocValuesGen = info.getNextDocValuesGen();\n      final String segmentSuffix = Long.toString(nextDocValuesGen, Character.MAX_RADIX);\n      final long estUpdatesSize = fieldUpdates.ramBytesPerDoc() * info.info.maxDoc();\n      final IOContext updatesContext = new IOContext(new FlushInfo(info.info.maxDoc(), estUpdatesSize));\n      final FieldInfo fieldInfo = infos.fieldInfo(field);\n      assert fieldInfo != null;\n      fieldInfo.setDocValuesGen(nextDocValuesGen);\n      final FieldInfos fieldInfos = new FieldInfos(new FieldInfo[] { fieldInfo });\n      // separately also track which files were created for this gen\n      final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n      final SegmentWriteState state = new SegmentWriteState(null, trackingDir, info.info, fieldInfos, null, updatesContext, segmentSuffix);\n      try (final DocValuesConsumer fieldsConsumer = dvFormat.fieldsConsumer(state)) {\n        // write the binary updates to a new gen'd docvalues file\n\n        fieldsConsumer.addBinaryField(fieldInfo, new EmptyDocValuesProducer() {\n            @Override\n            public BinaryDocValues getBinary(FieldInfo fieldInfoIn) throws IOException {\n              if (fieldInfoIn != fieldInfo) {\n                throw new IllegalArgumentException(\"wrong fieldInfo\");\n              }\n              final int maxDoc = reader.maxDoc();\n\n              final BinaryDocValuesFieldUpdates.Iterator updatesIter = fieldUpdates.iterator();\n              updatesIter.reset();\n\n              final BinaryDocValues currentValues = reader.getBinaryDocValues(field);\n\n              // Merge sort of the original doc values with updated doc values:\n              return new BinaryDocValues() {\n                // merged docID\n                private int docIDOut = -1;\n\n                // docID from our original doc values\n                private int docIDIn = -1;\n\n                // docID from our updates\n                private int updateDocID = -1;\n\n                private BytesRef value;\n\n                @Override\n                public int docID() {\n                  return docIDOut;\n                }\n\n                @Override\n                public int advance(int target) {\n                  throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public boolean advanceExact(int target) throws IOException {\n                  throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public long cost() {\n                  return currentValues.cost();\n                }\n\n                @Override\n                public BytesRef binaryValue() {\n                  return value;\n                }\n\n                @Override\n                public int nextDoc() throws IOException {\n                  if (docIDIn == docIDOut) {\n                    if (currentValues == null) {\n                      docIDIn = NO_MORE_DOCS;\n                    } else {\n                      docIDIn = currentValues.nextDoc();\n                    }\n                  }\n                  if (updateDocID == docIDOut) {\n                    updateDocID = updatesIter.nextDoc();\n                  }\n                  if (docIDIn < updateDocID) {\n                    // no update to this doc\n                    docIDOut = docIDIn;\n                    value = currentValues.binaryValue();\n                  } else {\n                    docIDOut = updateDocID;\n                    if (docIDOut != NO_MORE_DOCS) {\n                      value = updatesIter.value();\n                    }\n                  }\n                  return docIDOut;\n                }\n              };\n            }\n          });\n      }\n      info.advanceDocValuesGen();\n      assert !fieldFiles.containsKey(fieldInfo.number);\n      fieldFiles.put(fieldInfo.number, trackingDir.getCreatedFiles());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":4,"author":"Karl Wright","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates#handleBinaryDVUpdates(FieldInfos,Map[String,BinaryDocValuesFieldUpdates],TrackingDirectoryWrapper,DocValuesFormat,SegmentReader,Map[Integer,Set[String]]).mjava","sourceNew":null,"sourceOld":"  @SuppressWarnings(\"synthetic-access\")\n  private void handleBinaryDVUpdates(FieldInfos infos, Map<String,BinaryDocValuesFieldUpdates> updates, \n      TrackingDirectoryWrapper dir, DocValuesFormat dvFormat, final SegmentReader reader, Map<Integer,Set<String>> fieldFiles) throws IOException {\n    for (Entry<String,BinaryDocValuesFieldUpdates> e : updates.entrySet()) {\n      final String field = e.getKey();\n      final BinaryDocValuesFieldUpdates fieldUpdates = e.getValue();\n\n      final long nextDocValuesGen = info.getNextDocValuesGen();\n      final String segmentSuffix = Long.toString(nextDocValuesGen, Character.MAX_RADIX);\n      final long estUpdatesSize = fieldUpdates.ramBytesPerDoc() * info.info.maxDoc();\n      final IOContext updatesContext = new IOContext(new FlushInfo(info.info.maxDoc(), estUpdatesSize));\n      final FieldInfo fieldInfo = infos.fieldInfo(field);\n      assert fieldInfo != null;\n      fieldInfo.setDocValuesGen(nextDocValuesGen);\n      final FieldInfos fieldInfos = new FieldInfos(new FieldInfo[] { fieldInfo });\n      // separately also track which files were created for this gen\n      final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);\n      final SegmentWriteState state = new SegmentWriteState(null, trackingDir, info.info, fieldInfos, null, updatesContext, segmentSuffix);\n      try (final DocValuesConsumer fieldsConsumer = dvFormat.fieldsConsumer(state)) {\n        // write the binary updates to a new gen'd docvalues file\n\n        fieldsConsumer.addBinaryField(fieldInfo, new EmptyDocValuesProducer() {\n            @Override\n            public BinaryDocValues getBinary(FieldInfo fieldInfoIn) throws IOException {\n              if (fieldInfoIn != fieldInfo) {\n                throw new IllegalArgumentException(\"wrong fieldInfo\");\n              }\n              final int maxDoc = reader.maxDoc();\n\n              final BinaryDocValuesFieldUpdates.Iterator updatesIter = fieldUpdates.iterator();\n              updatesIter.reset();\n\n              final BinaryDocValues currentValues = reader.getBinaryDocValues(field);\n\n              // Merge sort of the original doc values with updated doc values:\n              return new BinaryDocValues() {\n                // merged docID\n                private int docIDOut = -1;\n\n                // docID from our original doc values\n                private int docIDIn = -1;\n\n                // docID from our updates\n                private int updateDocID = -1;\n\n                private BytesRef value;\n\n                @Override\n                public int docID() {\n                  return docIDOut;\n                }\n\n                @Override\n                public int advance(int target) {\n                  throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public boolean advanceExact(int target) throws IOException {\n                  throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public long cost() {\n                  return currentValues.cost();\n                }\n\n                @Override\n                public BytesRef binaryValue() {\n                  return value;\n                }\n\n                @Override\n                public int nextDoc() throws IOException {\n                  if (docIDIn == docIDOut) {\n                    if (currentValues == null) {\n                      docIDIn = NO_MORE_DOCS;\n                    } else {\n                      docIDIn = currentValues.nextDoc();\n                    }\n                  }\n                  if (updateDocID == docIDOut) {\n                    updateDocID = updatesIter.nextDoc();\n                  }\n                  if (docIDIn < updateDocID) {\n                    // no update to this doc\n                    docIDOut = docIDIn;\n                    value = currentValues.binaryValue();\n                  } else {\n                    docIDOut = updateDocID;\n                    if (docIDOut != NO_MORE_DOCS) {\n                      value = updatesIter.value();\n                    }\n                  }\n                  return docIDOut;\n                }\n              };\n            }\n          });\n      }\n      info.advanceDocValuesGen();\n      assert !fieldFiles.containsKey(fieldInfo.number);\n      fieldFiles.put(fieldInfo.number, trackingDir.getCreatedFiles());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf":["0567bdc5c86c94ced64201187cfcef2417d76dda"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["d2714c85633b642b29871cf5ff8d17d3ba7bfd76"],"b0267c69e2456a3477a1ad785723f2135da3117e":["53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf"],"0567bdc5c86c94ced64201187cfcef2417d76dda":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b7605579001505896d48b07160075a5c8b8e128e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0567bdc5c86c94ced64201187cfcef2417d76dda"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["d2714c85633b642b29871cf5ff8d17d3ba7bfd76","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"28288370235ed02234a64753cdbf0c6ec096304a":["d2714c85633b642b29871cf5ff8d17d3ba7bfd76","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["b0267c69e2456a3477a1ad785723f2135da3117e","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf","b0267c69e2456a3477a1ad785723f2135da3117e"],"b06445ae1731e049327712db0454e5643ca9b7fe":["53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf","b0267c69e2456a3477a1ad785723f2135da3117e"],"11134e449dabe11d6d0ff6a564d84b82cbe93722":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["b0267c69e2456a3477a1ad785723f2135da3117e","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["b0267c69e2456a3477a1ad785723f2135da3117e"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d2714c85633b642b29871cf5ff8d17d3ba7bfd76"],"a656b32c3aa151037a8c52e9b134acc3cbf482bc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0567bdc5c86c94ced64201187cfcef2417d76dda"],"d2714c85633b642b29871cf5ff8d17d3ba7bfd76":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","11134e449dabe11d6d0ff6a564d84b82cbe93722"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["28288370235ed02234a64753cdbf0c6ec096304a"]},"commit2Childs":{"53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf":["b0267c69e2456a3477a1ad785723f2135da3117e","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"b0267c69e2456a3477a1ad785723f2135da3117e":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"0567bdc5c86c94ced64201187cfcef2417d76dda":["53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf","b7605579001505896d48b07160075a5c8b8e128e","a656b32c3aa151037a8c52e9b134acc3cbf482bc"],"b7605579001505896d48b07160075a5c8b8e128e":[],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"b06445ae1731e049327712db0454e5643ca9b7fe":[],"11134e449dabe11d6d0ff6a564d84b82cbe93722":["d2714c85633b642b29871cf5ff8d17d3ba7bfd76"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0567bdc5c86c94ced64201187cfcef2417d76dda","b7605579001505896d48b07160075a5c8b8e128e","a656b32c3aa151037a8c52e9b134acc3cbf482bc"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","11134e449dabe11d6d0ff6a564d84b82cbe93722","d2714c85633b642b29871cf5ff8d17d3ba7bfd76"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":[],"a656b32c3aa151037a8c52e9b134acc3cbf482bc":[],"d2714c85633b642b29871cf5ff8d17d3ba7bfd76":["f4363cd33f6eff7fb4753574a441e2d18c1022a4","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a","80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b7605579001505896d48b07160075a5c8b8e128e","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe","80d0e6d59ae23f4a6f30eaf40bfb40742300287f","a656b32c3aa151037a8c52e9b134acc3cbf482bc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}