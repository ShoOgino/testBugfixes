{"path":"lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery#getSpans(LeafReaderContext,Bits,Map[Term,TermContext]).mjava","commits":[{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":0,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery#getSpans(LeafReaderContext,Bits,Map[Term,TermContext]).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, final Map<Term,TermContext> termContexts) throws IOException {\n    return new Spans() {\n        private Spans includeSpans = include.getSpans(context, acceptDocs, termContexts);\n        private boolean moreInclude = true;\n\n        private Spans excludeSpans = exclude.getSpans(context, acceptDocs, termContexts);\n        private boolean moreExclude = excludeSpans.next();\n\n        @Override\n        public boolean next() throws IOException {\n          if (moreInclude)                        // move to next include\n            moreInclude = includeSpans.next();\n\n          while (moreInclude && moreExclude) {\n\n            if (includeSpans.doc() > excludeSpans.doc()) // skip exclude\n              moreExclude = excludeSpans.skipTo(includeSpans.doc());\n\n            while (moreExclude                    // while exclude is before\n                   && includeSpans.doc() == excludeSpans.doc()\n                   && excludeSpans.end() <= includeSpans.start() - pre) {\n              moreExclude = excludeSpans.next();  // increment exclude\n            }\n\n            if (!moreExclude                      // if no intersection\n                || includeSpans.doc() != excludeSpans.doc()\n                || includeSpans.end()+post <= excludeSpans.start())\n              break;                              // we found a match\n\n            moreInclude = includeSpans.next();    // intersected: keep scanning\n          }\n          return moreInclude;\n        }\n\n        @Override\n        public boolean skipTo(int target) throws IOException {\n          if (moreInclude)                        // skip include\n            moreInclude = includeSpans.skipTo(target);\n\n          if (!moreInclude)\n            return false;\n\n          if (moreExclude                         // skip exclude\n              && includeSpans.doc() > excludeSpans.doc())\n            moreExclude = excludeSpans.skipTo(includeSpans.doc());\n\n          while (moreExclude                      // while exclude is before\n                 && includeSpans.doc() == excludeSpans.doc()\n                 && excludeSpans.end() <= includeSpans.start()-pre) {\n            moreExclude = excludeSpans.next();    // increment exclude\n          }\n\n          if (!moreExclude                      // if no intersection\n                || includeSpans.doc() != excludeSpans.doc()\n                || includeSpans.end()+post <= excludeSpans.start())\n            return true;                          // we found a match\n\n          return next();                          // scan to next match\n        }\n\n        @Override\n        public int doc() { return includeSpans.doc(); }\n        @Override\n        public int start() { return includeSpans.start(); }\n        @Override\n        public int end() { return includeSpans.end(); }\n\n      // TODO: Remove warning after API has been finalized\n      @Override\n      public Collection<byte[]> getPayload() throws IOException {\n        ArrayList<byte[]> result = null;\n        if (includeSpans.isPayloadAvailable()) {\n          result = new ArrayList<>(includeSpans.getPayload());\n        }\n        return result;\n      }\n\n      // TODO: Remove warning after API has been finalized\n      @Override\n      public boolean isPayloadAvailable() throws IOException {\n        return includeSpans.isPayloadAvailable();\n      }\n\n      @Override\n      public long cost() {\n        return includeSpans.cost();\n      }\n\n      @Override\n      public String toString() {\n          return \"spans(\" + SpanNotQuery.this.toString() + \")\";\n        }\n\n      };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["fdd572df21b78bb2212d045bf26a2773a48b58e9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"30de45e50bdc1a79a6797f34dca6271c8866cb6e","date":1427790465,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery#getSpans(LeafReaderContext,Bits,Map[Term,TermContext]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery#getSpans(LeafReaderContext,Bits,Map[Term,TermContext]).mjava","sourceNew":"  @Override\n  public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, final Map<Term,TermContext> termContexts) throws IOException {\n    Spans includeSpans = include.getSpans(context, acceptDocs, termContexts);\n    if (includeSpans == null) {\n      return null;\n    }\n\n    Spans excludeSpans = exclude.getSpans(context, acceptDocs, termContexts);\n    if (excludeSpans == null) {\n      return includeSpans;\n    }\n\n    return new Spans() {\n      private boolean moreInclude = true;\n      private int includeStart = -1;\n      private int includeEnd = -1;\n      private boolean atFirstInCurrentDoc = false;\n\n      private boolean moreExclude = excludeSpans.nextDoc() != NO_MORE_DOCS;\n      private int excludeStart = moreExclude ? excludeSpans.nextStartPosition() : NO_MORE_POSITIONS;\n\n\n      @Override\n      public int nextDoc() throws IOException {\n        if (moreInclude) {\n          moreInclude = includeSpans.nextDoc() != NO_MORE_DOCS;\n          if (moreInclude) {\n            atFirstInCurrentDoc = true;\n            includeStart = includeSpans.nextStartPosition();\n            assert includeStart != NO_MORE_POSITIONS;\n          }\n        }\n        toNextIncluded();\n        int res = moreInclude ? includeSpans.docID() : NO_MORE_DOCS;\n        return res;\n      }\n\n      private void toNextIncluded() throws IOException {\n        while (moreInclude && moreExclude) {\n          if (includeSpans.docID() > excludeSpans.docID()) {\n            moreExclude = excludeSpans.advance(includeSpans.docID()) != NO_MORE_DOCS;\n            if (moreExclude) {\n              excludeStart = -1; // only use exclude positions at same doc\n            }\n          }\n          if (excludeForwardInCurrentDocAndAtMatch()) {\n            break; // at match.\n          }\n\n          // else intersected: keep scanning, to next doc if needed\n          includeStart = includeSpans.nextStartPosition();\n          if (includeStart == NO_MORE_POSITIONS) {\n            moreInclude = includeSpans.nextDoc() != NO_MORE_DOCS;\n            if (moreInclude) {\n              atFirstInCurrentDoc = true;\n              includeStart = includeSpans.nextStartPosition();\n              assert includeStart != NO_MORE_POSITIONS;\n            }\n          }\n        }\n      }\n\n      private boolean excludeForwardInCurrentDocAndAtMatch() throws IOException {\n        assert moreInclude;\n        assert includeStart != NO_MORE_POSITIONS;\n        if (! moreExclude) {\n          return true;\n        }\n        if (includeSpans.docID() != excludeSpans.docID()) {\n          return true;\n        }\n        // at same doc\n        if (excludeStart == -1) { // init exclude start position if needed\n          excludeStart = excludeSpans.nextStartPosition();\n          assert excludeStart != NO_MORE_POSITIONS;\n        }\n        while (excludeSpans.endPosition() <= includeStart - pre) {\n          // exclude end position is before a possible exclusion\n          excludeStart = excludeSpans.nextStartPosition();\n          if (excludeStart == NO_MORE_POSITIONS) {\n            return true; // no more exclude at current doc.\n          }\n        }\n        // exclude end position far enough in current doc, check start position:\n        boolean res = includeSpans.endPosition() + post <= excludeStart;\n        return res;\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n        if (moreInclude) {\n          assert target > includeSpans.docID() : \"target=\"+target+\", includeSpans.docID()=\"+includeSpans.docID();\n          moreInclude = includeSpans.advance(target) != NO_MORE_DOCS;\n          if (moreInclude) {\n            atFirstInCurrentDoc = true;\n            includeStart = includeSpans.nextStartPosition();\n            assert includeStart != NO_MORE_POSITIONS;\n          }\n        }\n        toNextIncluded();\n        int res = moreInclude ? includeSpans.docID() : NO_MORE_DOCS;\n        return res;\n      }\n\n      @Override\n      public int docID() {\n        int res = includeSpans.docID();\n        return res;\n      }\n\n      @Override\n      public int nextStartPosition() throws IOException {\n        assert moreInclude;\n\n        if (atFirstInCurrentDoc) {\n          atFirstInCurrentDoc = false;\n          assert includeStart != NO_MORE_POSITIONS;\n          return includeStart;\n        }\n\n        includeStart = includeSpans.nextStartPosition();\n        while ((includeStart != NO_MORE_POSITIONS)\n            && (! excludeForwardInCurrentDocAndAtMatch()))\n        {\n          includeStart = includeSpans.nextStartPosition();\n        }\n\n        return includeStart;\n      }\n\n      @Override\n      public int startPosition() {\n        assert includeStart == includeSpans.startPosition();\n        return atFirstInCurrentDoc ? -1 : includeStart;\n      }\n\n      @Override\n      public int endPosition() {\n        return atFirstInCurrentDoc ? -1 : includeSpans.endPosition();\n      }\n\n      @Override\n      public Collection<byte[]> getPayload() throws IOException {\n        ArrayList<byte[]> result = null;\n        if (includeSpans.isPayloadAvailable()) {\n          result = new ArrayList<>(includeSpans.getPayload());\n        }\n        return result;\n      }\n\n      @Override\n      public boolean isPayloadAvailable() throws IOException {\n        return includeSpans.isPayloadAvailable();\n      }\n\n      @Override\n      public long cost() {\n        return includeSpans.cost();\n      }\n\n      @Override\n      public String toString() {\n        return \"spans(\" + SpanNotQuery.this.toString() + \")\";\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, final Map<Term,TermContext> termContexts) throws IOException {\n    return new Spans() {\n        private Spans includeSpans = include.getSpans(context, acceptDocs, termContexts);\n        private boolean moreInclude = true;\n\n        private Spans excludeSpans = exclude.getSpans(context, acceptDocs, termContexts);\n        private boolean moreExclude = excludeSpans.next();\n\n        @Override\n        public boolean next() throws IOException {\n          if (moreInclude)                        // move to next include\n            moreInclude = includeSpans.next();\n\n          while (moreInclude && moreExclude) {\n\n            if (includeSpans.doc() > excludeSpans.doc()) // skip exclude\n              moreExclude = excludeSpans.skipTo(includeSpans.doc());\n\n            while (moreExclude                    // while exclude is before\n                   && includeSpans.doc() == excludeSpans.doc()\n                   && excludeSpans.end() <= includeSpans.start() - pre) {\n              moreExclude = excludeSpans.next();  // increment exclude\n            }\n\n            if (!moreExclude                      // if no intersection\n                || includeSpans.doc() != excludeSpans.doc()\n                || includeSpans.end()+post <= excludeSpans.start())\n              break;                              // we found a match\n\n            moreInclude = includeSpans.next();    // intersected: keep scanning\n          }\n          return moreInclude;\n        }\n\n        @Override\n        public boolean skipTo(int target) throws IOException {\n          if (moreInclude)                        // skip include\n            moreInclude = includeSpans.skipTo(target);\n\n          if (!moreInclude)\n            return false;\n\n          if (moreExclude                         // skip exclude\n              && includeSpans.doc() > excludeSpans.doc())\n            moreExclude = excludeSpans.skipTo(includeSpans.doc());\n\n          while (moreExclude                      // while exclude is before\n                 && includeSpans.doc() == excludeSpans.doc()\n                 && excludeSpans.end() <= includeSpans.start()-pre) {\n            moreExclude = excludeSpans.next();    // increment exclude\n          }\n\n          if (!moreExclude                      // if no intersection\n                || includeSpans.doc() != excludeSpans.doc()\n                || includeSpans.end()+post <= excludeSpans.start())\n            return true;                          // we found a match\n\n          return next();                          // scan to next match\n        }\n\n        @Override\n        public int doc() { return includeSpans.doc(); }\n        @Override\n        public int start() { return includeSpans.start(); }\n        @Override\n        public int end() { return includeSpans.end(); }\n\n      // TODO: Remove warning after API has been finalized\n      @Override\n      public Collection<byte[]> getPayload() throws IOException {\n        ArrayList<byte[]> result = null;\n        if (includeSpans.isPayloadAvailable()) {\n          result = new ArrayList<>(includeSpans.getPayload());\n        }\n        return result;\n      }\n\n      // TODO: Remove warning after API has been finalized\n      @Override\n      public boolean isPayloadAvailable() throws IOException {\n        return includeSpans.isPayloadAvailable();\n      }\n\n      @Override\n      public long cost() {\n        return includeSpans.cost();\n      }\n\n      @Override\n      public String toString() {\n          return \"spans(\" + SpanNotQuery.this.toString() + \")\";\n        }\n\n      };\n  }\n\n","bugFix":null,"bugIntro":["fdd572df21b78bb2212d045bf26a2773a48b58e9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fab172655716b96f7e42376116235017a922de3a","date":1427850611,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery#getSpans(LeafReaderContext,Bits,Map[Term,TermContext]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery#getSpans(LeafReaderContext,Bits,Map[Term,TermContext]).mjava","sourceNew":"  @Override\n  public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, final Map<Term,TermContext> termContexts) throws IOException {\n    Spans includeSpans = include.getSpans(context, acceptDocs, termContexts);\n    if (includeSpans == null) {\n      return null;\n    }\n\n    Spans excludeSpans = exclude.getSpans(context, acceptDocs, termContexts);\n    if (excludeSpans == null) {\n      return includeSpans;\n    }\n\n    return new Spans() {\n      private boolean moreInclude = true;\n      private int includeStart = -1;\n      private int includeEnd = -1;\n      private boolean atFirstInCurrentDoc = false;\n\n      private boolean moreExclude = excludeSpans.nextDoc() != NO_MORE_DOCS;\n      private int excludeStart = moreExclude ? excludeSpans.nextStartPosition() : NO_MORE_POSITIONS;\n\n\n      @Override\n      public int nextDoc() throws IOException {\n        if (moreInclude) {\n          moreInclude = includeSpans.nextDoc() != NO_MORE_DOCS;\n          if (moreInclude) {\n            atFirstInCurrentDoc = true;\n            includeStart = includeSpans.nextStartPosition();\n            assert includeStart != NO_MORE_POSITIONS;\n          }\n        }\n        toNextIncluded();\n        int res = moreInclude ? includeSpans.docID() : NO_MORE_DOCS;\n        return res;\n      }\n\n      private void toNextIncluded() throws IOException {\n        while (moreInclude && moreExclude) {\n          if (includeSpans.docID() > excludeSpans.docID()) {\n            moreExclude = excludeSpans.advance(includeSpans.docID()) != NO_MORE_DOCS;\n            if (moreExclude) {\n              excludeStart = -1; // only use exclude positions at same doc\n            }\n          }\n          if (excludeForwardInCurrentDocAndAtMatch()) {\n            break; // at match.\n          }\n\n          // else intersected: keep scanning, to next doc if needed\n          includeStart = includeSpans.nextStartPosition();\n          if (includeStart == NO_MORE_POSITIONS) {\n            moreInclude = includeSpans.nextDoc() != NO_MORE_DOCS;\n            if (moreInclude) {\n              atFirstInCurrentDoc = true;\n              includeStart = includeSpans.nextStartPosition();\n              assert includeStart != NO_MORE_POSITIONS;\n            }\n          }\n        }\n      }\n\n      private boolean excludeForwardInCurrentDocAndAtMatch() throws IOException {\n        assert moreInclude;\n        assert includeStart != NO_MORE_POSITIONS;\n        if (! moreExclude) {\n          return true;\n        }\n        if (includeSpans.docID() != excludeSpans.docID()) {\n          return true;\n        }\n        // at same doc\n        if (excludeStart == -1) { // init exclude start position if needed\n          excludeStart = excludeSpans.nextStartPosition();\n          assert excludeStart != NO_MORE_POSITIONS;\n        }\n        while (excludeSpans.endPosition() <= includeStart - pre) {\n          // exclude end position is before a possible exclusion\n          excludeStart = excludeSpans.nextStartPosition();\n          if (excludeStart == NO_MORE_POSITIONS) {\n            return true; // no more exclude at current doc.\n          }\n        }\n        // exclude end position far enough in current doc, check start position:\n        boolean res = includeSpans.endPosition() + post <= excludeStart;\n        return res;\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n        if (moreInclude) {\n          assert target > includeSpans.docID() : \"target=\"+target+\", includeSpans.docID()=\"+includeSpans.docID();\n          moreInclude = includeSpans.advance(target) != NO_MORE_DOCS;\n          if (moreInclude) {\n            atFirstInCurrentDoc = true;\n            includeStart = includeSpans.nextStartPosition();\n            assert includeStart != NO_MORE_POSITIONS;\n          }\n        }\n        toNextIncluded();\n        int res = moreInclude ? includeSpans.docID() : NO_MORE_DOCS;\n        return res;\n      }\n\n      @Override\n      public int docID() {\n        int res = includeSpans.docID();\n        return res;\n      }\n\n      @Override\n      public int nextStartPosition() throws IOException {\n        assert moreInclude;\n\n        if (atFirstInCurrentDoc) {\n          atFirstInCurrentDoc = false;\n          assert includeStart != NO_MORE_POSITIONS;\n          return includeStart;\n        }\n\n        includeStart = includeSpans.nextStartPosition();\n        while ((includeStart != NO_MORE_POSITIONS)\n            && (! excludeForwardInCurrentDocAndAtMatch()))\n        {\n          includeStart = includeSpans.nextStartPosition();\n        }\n\n        return includeStart;\n      }\n\n      @Override\n      public int startPosition() {\n        assert includeStart == includeSpans.startPosition();\n        return atFirstInCurrentDoc ? -1 : includeStart;\n      }\n\n      @Override\n      public int endPosition() {\n        return atFirstInCurrentDoc ? -1 : includeSpans.endPosition();\n      }\n\n      @Override\n      public Collection<byte[]> getPayload() throws IOException {\n        ArrayList<byte[]> result = null;\n        if (includeSpans.isPayloadAvailable()) {\n          result = new ArrayList<>(includeSpans.getPayload());\n        }\n        return result;\n      }\n\n      @Override\n      public boolean isPayloadAvailable() throws IOException {\n        return includeSpans.isPayloadAvailable();\n      }\n\n      @Override\n      public long cost() {\n        return includeSpans.cost();\n      }\n\n      @Override\n      public String toString() {\n        return \"spans(\" + SpanNotQuery.this.toString() + \")\";\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, final Map<Term,TermContext> termContexts) throws IOException {\n    return new Spans() {\n        private Spans includeSpans = include.getSpans(context, acceptDocs, termContexts);\n        private boolean moreInclude = true;\n\n        private Spans excludeSpans = exclude.getSpans(context, acceptDocs, termContexts);\n        private boolean moreExclude = excludeSpans.next();\n\n        @Override\n        public boolean next() throws IOException {\n          if (moreInclude)                        // move to next include\n            moreInclude = includeSpans.next();\n\n          while (moreInclude && moreExclude) {\n\n            if (includeSpans.doc() > excludeSpans.doc()) // skip exclude\n              moreExclude = excludeSpans.skipTo(includeSpans.doc());\n\n            while (moreExclude                    // while exclude is before\n                   && includeSpans.doc() == excludeSpans.doc()\n                   && excludeSpans.end() <= includeSpans.start() - pre) {\n              moreExclude = excludeSpans.next();  // increment exclude\n            }\n\n            if (!moreExclude                      // if no intersection\n                || includeSpans.doc() != excludeSpans.doc()\n                || includeSpans.end()+post <= excludeSpans.start())\n              break;                              // we found a match\n\n            moreInclude = includeSpans.next();    // intersected: keep scanning\n          }\n          return moreInclude;\n        }\n\n        @Override\n        public boolean skipTo(int target) throws IOException {\n          if (moreInclude)                        // skip include\n            moreInclude = includeSpans.skipTo(target);\n\n          if (!moreInclude)\n            return false;\n\n          if (moreExclude                         // skip exclude\n              && includeSpans.doc() > excludeSpans.doc())\n            moreExclude = excludeSpans.skipTo(includeSpans.doc());\n\n          while (moreExclude                      // while exclude is before\n                 && includeSpans.doc() == excludeSpans.doc()\n                 && excludeSpans.end() <= includeSpans.start()-pre) {\n            moreExclude = excludeSpans.next();    // increment exclude\n          }\n\n          if (!moreExclude                      // if no intersection\n                || includeSpans.doc() != excludeSpans.doc()\n                || includeSpans.end()+post <= excludeSpans.start())\n            return true;                          // we found a match\n\n          return next();                          // scan to next match\n        }\n\n        @Override\n        public int doc() { return includeSpans.doc(); }\n        @Override\n        public int start() { return includeSpans.start(); }\n        @Override\n        public int end() { return includeSpans.end(); }\n\n      // TODO: Remove warning after API has been finalized\n      @Override\n      public Collection<byte[]> getPayload() throws IOException {\n        ArrayList<byte[]> result = null;\n        if (includeSpans.isPayloadAvailable()) {\n          result = new ArrayList<>(includeSpans.getPayload());\n        }\n        return result;\n      }\n\n      // TODO: Remove warning after API has been finalized\n      @Override\n      public boolean isPayloadAvailable() throws IOException {\n        return includeSpans.isPayloadAvailable();\n      }\n\n      @Override\n      public long cost() {\n        return includeSpans.cost();\n      }\n\n      @Override\n      public String toString() {\n          return \"spans(\" + SpanNotQuery.this.toString() + \")\";\n        }\n\n      };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fdd572df21b78bb2212d045bf26a2773a48b58e9","date":1428851244,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery#getSpans(LeafReaderContext,Bits,Map[Term,TermContext]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery#getSpans(LeafReaderContext,Bits,Map[Term,TermContext]).mjava","sourceNew":"  @Override\n  public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, final Map<Term,TermContext> termContexts) throws IOException {\n    Spans includeSpans = include.getSpans(context, acceptDocs, termContexts);\n    if (includeSpans == null) {\n      return null;\n    }\n\n    Spans excludeSpans = exclude.getSpans(context, acceptDocs, termContexts);\n    if (excludeSpans == null) {\n      return includeSpans;\n    }\n    \n    TwoPhaseIterator excludeTwoPhase = excludeSpans.asTwoPhaseIterator();\n    DocIdSetIterator excludeApproximation = excludeTwoPhase == null ? null : excludeTwoPhase.approximation();\n    \n    return new FilterSpans(includeSpans) {\n      // last document we have checked matches() against for the exclusion, and failed\n      // when using approximations, so we don't call it again, and pass thru all inclusions.\n      int lastNonMatchingDoc = -1;\n      \n      @Override\n      protected AcceptStatus accept(Spans candidate) throws IOException {\n        int doc = candidate.docID();\n        if (doc > excludeSpans.docID()) {\n          // catch up 'exclude' to the current doc\n          if (excludeTwoPhase != null) {\n            if (excludeApproximation.advance(doc) == doc) {\n              if (!excludeTwoPhase.matches()) {\n                lastNonMatchingDoc = doc; // mark as non-match\n              }\n            }\n          } else {\n            excludeSpans.advance(doc);\n          }\n        }\n        \n        if (doc == lastNonMatchingDoc || doc != excludeSpans.docID()) {\n          return AcceptStatus.YES;\n        }\n        \n        if (excludeSpans.startPosition() == -1) { // init exclude start position if needed\n          excludeSpans.nextStartPosition();\n        }\n        \n        while (excludeSpans.endPosition() <= candidate.startPosition() - pre) {\n          // exclude end position is before a possible exclusion\n          if (excludeSpans.nextStartPosition() == NO_MORE_POSITIONS) {\n            return AcceptStatus.YES; // no more exclude at current doc.\n          }\n        }\n        \n        // exclude end position far enough in current doc, check start position:\n        if (candidate.endPosition() + post <= excludeSpans.startPosition()) {\n          return AcceptStatus.YES;\n        } else {\n          return AcceptStatus.NO;\n        }\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, final Map<Term,TermContext> termContexts) throws IOException {\n    Spans includeSpans = include.getSpans(context, acceptDocs, termContexts);\n    if (includeSpans == null) {\n      return null;\n    }\n\n    Spans excludeSpans = exclude.getSpans(context, acceptDocs, termContexts);\n    if (excludeSpans == null) {\n      return includeSpans;\n    }\n\n    return new Spans() {\n      private boolean moreInclude = true;\n      private int includeStart = -1;\n      private int includeEnd = -1;\n      private boolean atFirstInCurrentDoc = false;\n\n      private boolean moreExclude = excludeSpans.nextDoc() != NO_MORE_DOCS;\n      private int excludeStart = moreExclude ? excludeSpans.nextStartPosition() : NO_MORE_POSITIONS;\n\n\n      @Override\n      public int nextDoc() throws IOException {\n        if (moreInclude) {\n          moreInclude = includeSpans.nextDoc() != NO_MORE_DOCS;\n          if (moreInclude) {\n            atFirstInCurrentDoc = true;\n            includeStart = includeSpans.nextStartPosition();\n            assert includeStart != NO_MORE_POSITIONS;\n          }\n        }\n        toNextIncluded();\n        int res = moreInclude ? includeSpans.docID() : NO_MORE_DOCS;\n        return res;\n      }\n\n      private void toNextIncluded() throws IOException {\n        while (moreInclude && moreExclude) {\n          if (includeSpans.docID() > excludeSpans.docID()) {\n            moreExclude = excludeSpans.advance(includeSpans.docID()) != NO_MORE_DOCS;\n            if (moreExclude) {\n              excludeStart = -1; // only use exclude positions at same doc\n            }\n          }\n          if (excludeForwardInCurrentDocAndAtMatch()) {\n            break; // at match.\n          }\n\n          // else intersected: keep scanning, to next doc if needed\n          includeStart = includeSpans.nextStartPosition();\n          if (includeStart == NO_MORE_POSITIONS) {\n            moreInclude = includeSpans.nextDoc() != NO_MORE_DOCS;\n            if (moreInclude) {\n              atFirstInCurrentDoc = true;\n              includeStart = includeSpans.nextStartPosition();\n              assert includeStart != NO_MORE_POSITIONS;\n            }\n          }\n        }\n      }\n\n      private boolean excludeForwardInCurrentDocAndAtMatch() throws IOException {\n        assert moreInclude;\n        assert includeStart != NO_MORE_POSITIONS;\n        if (! moreExclude) {\n          return true;\n        }\n        if (includeSpans.docID() != excludeSpans.docID()) {\n          return true;\n        }\n        // at same doc\n        if (excludeStart == -1) { // init exclude start position if needed\n          excludeStart = excludeSpans.nextStartPosition();\n          assert excludeStart != NO_MORE_POSITIONS;\n        }\n        while (excludeSpans.endPosition() <= includeStart - pre) {\n          // exclude end position is before a possible exclusion\n          excludeStart = excludeSpans.nextStartPosition();\n          if (excludeStart == NO_MORE_POSITIONS) {\n            return true; // no more exclude at current doc.\n          }\n        }\n        // exclude end position far enough in current doc, check start position:\n        boolean res = includeSpans.endPosition() + post <= excludeStart;\n        return res;\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n        if (moreInclude) {\n          assert target > includeSpans.docID() : \"target=\"+target+\", includeSpans.docID()=\"+includeSpans.docID();\n          moreInclude = includeSpans.advance(target) != NO_MORE_DOCS;\n          if (moreInclude) {\n            atFirstInCurrentDoc = true;\n            includeStart = includeSpans.nextStartPosition();\n            assert includeStart != NO_MORE_POSITIONS;\n          }\n        }\n        toNextIncluded();\n        int res = moreInclude ? includeSpans.docID() : NO_MORE_DOCS;\n        return res;\n      }\n\n      @Override\n      public int docID() {\n        int res = includeSpans.docID();\n        return res;\n      }\n\n      @Override\n      public int nextStartPosition() throws IOException {\n        assert moreInclude;\n\n        if (atFirstInCurrentDoc) {\n          atFirstInCurrentDoc = false;\n          assert includeStart != NO_MORE_POSITIONS;\n          return includeStart;\n        }\n\n        includeStart = includeSpans.nextStartPosition();\n        while ((includeStart != NO_MORE_POSITIONS)\n            && (! excludeForwardInCurrentDocAndAtMatch()))\n        {\n          includeStart = includeSpans.nextStartPosition();\n        }\n\n        return includeStart;\n      }\n\n      @Override\n      public int startPosition() {\n        assert includeStart == includeSpans.startPosition();\n        return atFirstInCurrentDoc ? -1 : includeStart;\n      }\n\n      @Override\n      public int endPosition() {\n        return atFirstInCurrentDoc ? -1 : includeSpans.endPosition();\n      }\n\n      @Override\n      public Collection<byte[]> getPayload() throws IOException {\n        ArrayList<byte[]> result = null;\n        if (includeSpans.isPayloadAvailable()) {\n          result = new ArrayList<>(includeSpans.getPayload());\n        }\n        return result;\n      }\n\n      @Override\n      public boolean isPayloadAvailable() throws IOException {\n        return includeSpans.isPayloadAvailable();\n      }\n\n      @Override\n      public long cost() {\n        return includeSpans.cost();\n      }\n\n      @Override\n      public String toString() {\n        return \"spans(\" + SpanNotQuery.this.toString() + \")\";\n      }\n    };\n  }\n\n","bugFix":["c9fb5f46e264daf5ba3860defe623a89d202dd87","30de45e50bdc1a79a6797f34dca6271c8866cb6e"],"bugIntro":["28b61f1c9cf357a13efbb645d116d056feb80cf6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"28b61f1c9cf357a13efbb645d116d056feb80cf6","date":1428863054,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery#getSpans(LeafReaderContext,Bits,Map[Term,TermContext]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery#getSpans(LeafReaderContext,Bits,Map[Term,TermContext]).mjava","sourceNew":"  @Override\n  public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, final Map<Term,TermContext> termContexts) throws IOException {\n    Spans includeSpans = include.getSpans(context, acceptDocs, termContexts);\n    if (includeSpans == null) {\n      return null;\n    }\n\n    Spans excludeSpans = exclude.getSpans(context, acceptDocs, termContexts);\n    if (excludeSpans == null) {\n      return includeSpans;\n    }\n    \n    TwoPhaseIterator excludeTwoPhase = excludeSpans.asTwoPhaseIterator();\n    DocIdSetIterator excludeApproximation = excludeTwoPhase == null ? null : excludeTwoPhase.approximation();\n    \n    return new FilterSpans(includeSpans) {\n      // last document we have checked matches() against for the exclusion, and failed\n      // when using approximations, so we don't call it again, and pass thru all inclusions.\n      int lastApproxDoc = -1;\n      boolean lastApproxResult = false;\n      \n      @Override\n      protected AcceptStatus accept(Spans candidate) throws IOException {\n        // TODO: this logic is ugly and sneaky, can we clean it up?\n        int doc = candidate.docID();\n        if (doc > excludeSpans.docID()) {\n          // catch up 'exclude' to the current doc\n          if (excludeTwoPhase != null) {\n            if (excludeApproximation.advance(doc) == doc) {\n              lastApproxDoc = doc;\n              lastApproxResult = excludeTwoPhase.matches();\n            }\n          } else {\n            excludeSpans.advance(doc);\n          }\n        } else if (excludeTwoPhase != null && doc == excludeSpans.docID() && doc != lastApproxDoc) {\n          // excludeSpans already sitting on our candidate doc, but matches not called yet.\n          lastApproxDoc = doc;\n          lastApproxResult = excludeTwoPhase.matches();\n        }\n        \n        if (doc != excludeSpans.docID() || (doc == lastApproxDoc && lastApproxResult == false)) {\n          return AcceptStatus.YES;\n        }\n        \n        if (excludeSpans.startPosition() == -1) { // init exclude start position if needed\n          excludeSpans.nextStartPosition();\n        }\n        \n        while (excludeSpans.endPosition() <= candidate.startPosition() - pre) {\n          // exclude end position is before a possible exclusion\n          if (excludeSpans.nextStartPosition() == NO_MORE_POSITIONS) {\n            return AcceptStatus.YES; // no more exclude at current doc.\n          }\n        }\n        \n        // exclude end position far enough in current doc, check start position:\n        if (candidate.endPosition() + post <= excludeSpans.startPosition()) {\n          return AcceptStatus.YES;\n        } else {\n          return AcceptStatus.NO;\n        }\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, final Map<Term,TermContext> termContexts) throws IOException {\n    Spans includeSpans = include.getSpans(context, acceptDocs, termContexts);\n    if (includeSpans == null) {\n      return null;\n    }\n\n    Spans excludeSpans = exclude.getSpans(context, acceptDocs, termContexts);\n    if (excludeSpans == null) {\n      return includeSpans;\n    }\n    \n    TwoPhaseIterator excludeTwoPhase = excludeSpans.asTwoPhaseIterator();\n    DocIdSetIterator excludeApproximation = excludeTwoPhase == null ? null : excludeTwoPhase.approximation();\n    \n    return new FilterSpans(includeSpans) {\n      // last document we have checked matches() against for the exclusion, and failed\n      // when using approximations, so we don't call it again, and pass thru all inclusions.\n      int lastNonMatchingDoc = -1;\n      \n      @Override\n      protected AcceptStatus accept(Spans candidate) throws IOException {\n        int doc = candidate.docID();\n        if (doc > excludeSpans.docID()) {\n          // catch up 'exclude' to the current doc\n          if (excludeTwoPhase != null) {\n            if (excludeApproximation.advance(doc) == doc) {\n              if (!excludeTwoPhase.matches()) {\n                lastNonMatchingDoc = doc; // mark as non-match\n              }\n            }\n          } else {\n            excludeSpans.advance(doc);\n          }\n        }\n        \n        if (doc == lastNonMatchingDoc || doc != excludeSpans.docID()) {\n          return AcceptStatus.YES;\n        }\n        \n        if (excludeSpans.startPosition() == -1) { // init exclude start position if needed\n          excludeSpans.nextStartPosition();\n        }\n        \n        while (excludeSpans.endPosition() <= candidate.startPosition() - pre) {\n          // exclude end position is before a possible exclusion\n          if (excludeSpans.nextStartPosition() == NO_MORE_POSITIONS) {\n            return AcceptStatus.YES; // no more exclude at current doc.\n          }\n        }\n        \n        // exclude end position far enough in current doc, check start position:\n        if (candidate.endPosition() + post <= excludeSpans.startPosition()) {\n          return AcceptStatus.YES;\n        } else {\n          return AcceptStatus.NO;\n        }\n      }\n    };\n  }\n\n","bugFix":["fdd572df21b78bb2212d045bf26a2773a48b58e9"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2d530e71ed32ab23b34ca3fc72b080a554a40404","date":1432026158,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery#getSpans(LeafReaderContext,Bits,Map[Term,TermContext],SpanCollector).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery#getSpans(LeafReaderContext,Bits,Map[Term,TermContext]).mjava","sourceNew":"  @Override\n  public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, final Map<Term,TermContext> termContexts, SpanCollector collector) throws IOException {\n    Spans includeSpans = include.getSpans(context, acceptDocs, termContexts, collector);\n    if (includeSpans == null) {\n      return null;\n    }\n\n    Spans excludeSpans = exclude.getSpans(context, acceptDocs, termContexts, collector);\n    if (excludeSpans == null) {\n      return includeSpans;\n    }\n    \n    TwoPhaseIterator excludeTwoPhase = excludeSpans.asTwoPhaseIterator();\n    DocIdSetIterator excludeApproximation = excludeTwoPhase == null ? null : excludeTwoPhase.approximation();\n    \n    return new FilterSpans(includeSpans) {\n      // last document we have checked matches() against for the exclusion, and failed\n      // when using approximations, so we don't call it again, and pass thru all inclusions.\n      int lastApproxDoc = -1;\n      boolean lastApproxResult = false;\n      \n      @Override\n      protected AcceptStatus accept(Spans candidate) throws IOException {\n        // TODO: this logic is ugly and sneaky, can we clean it up?\n        int doc = candidate.docID();\n        if (doc > excludeSpans.docID()) {\n          // catch up 'exclude' to the current doc\n          if (excludeTwoPhase != null) {\n            if (excludeApproximation.advance(doc) == doc) {\n              lastApproxDoc = doc;\n              lastApproxResult = excludeTwoPhase.matches();\n            }\n          } else {\n            excludeSpans.advance(doc);\n          }\n        } else if (excludeTwoPhase != null && doc == excludeSpans.docID() && doc != lastApproxDoc) {\n          // excludeSpans already sitting on our candidate doc, but matches not called yet.\n          lastApproxDoc = doc;\n          lastApproxResult = excludeTwoPhase.matches();\n        }\n        \n        if (doc != excludeSpans.docID() || (doc == lastApproxDoc && lastApproxResult == false)) {\n          return AcceptStatus.YES;\n        }\n        \n        if (excludeSpans.startPosition() == -1) { // init exclude start position if needed\n          excludeSpans.nextStartPosition();\n        }\n        \n        while (excludeSpans.endPosition() <= candidate.startPosition() - pre) {\n          // exclude end position is before a possible exclusion\n          if (excludeSpans.nextStartPosition() == NO_MORE_POSITIONS) {\n            return AcceptStatus.YES; // no more exclude at current doc.\n          }\n        }\n        \n        // exclude end position far enough in current doc, check start position:\n        if (candidate.endPosition() + post <= excludeSpans.startPosition()) {\n          return AcceptStatus.YES;\n        } else {\n          return AcceptStatus.NO;\n        }\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, final Map<Term,TermContext> termContexts) throws IOException {\n    Spans includeSpans = include.getSpans(context, acceptDocs, termContexts);\n    if (includeSpans == null) {\n      return null;\n    }\n\n    Spans excludeSpans = exclude.getSpans(context, acceptDocs, termContexts);\n    if (excludeSpans == null) {\n      return includeSpans;\n    }\n    \n    TwoPhaseIterator excludeTwoPhase = excludeSpans.asTwoPhaseIterator();\n    DocIdSetIterator excludeApproximation = excludeTwoPhase == null ? null : excludeTwoPhase.approximation();\n    \n    return new FilterSpans(includeSpans) {\n      // last document we have checked matches() against for the exclusion, and failed\n      // when using approximations, so we don't call it again, and pass thru all inclusions.\n      int lastApproxDoc = -1;\n      boolean lastApproxResult = false;\n      \n      @Override\n      protected AcceptStatus accept(Spans candidate) throws IOException {\n        // TODO: this logic is ugly and sneaky, can we clean it up?\n        int doc = candidate.docID();\n        if (doc > excludeSpans.docID()) {\n          // catch up 'exclude' to the current doc\n          if (excludeTwoPhase != null) {\n            if (excludeApproximation.advance(doc) == doc) {\n              lastApproxDoc = doc;\n              lastApproxResult = excludeTwoPhase.matches();\n            }\n          } else {\n            excludeSpans.advance(doc);\n          }\n        } else if (excludeTwoPhase != null && doc == excludeSpans.docID() && doc != lastApproxDoc) {\n          // excludeSpans already sitting on our candidate doc, but matches not called yet.\n          lastApproxDoc = doc;\n          lastApproxResult = excludeTwoPhase.matches();\n        }\n        \n        if (doc != excludeSpans.docID() || (doc == lastApproxDoc && lastApproxResult == false)) {\n          return AcceptStatus.YES;\n        }\n        \n        if (excludeSpans.startPosition() == -1) { // init exclude start position if needed\n          excludeSpans.nextStartPosition();\n        }\n        \n        while (excludeSpans.endPosition() <= candidate.startPosition() - pre) {\n          // exclude end position is before a possible exclusion\n          if (excludeSpans.nextStartPosition() == NO_MORE_POSITIONS) {\n            return AcceptStatus.YES; // no more exclude at current doc.\n          }\n        }\n        \n        // exclude end position far enough in current doc, check start position:\n        if (candidate.endPosition() + post <= excludeSpans.startPosition()) {\n          return AcceptStatus.YES;\n        } else {\n          return AcceptStatus.NO;\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fdd572df21b78bb2212d045bf26a2773a48b58e9":["30de45e50bdc1a79a6797f34dca6271c8866cb6e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2d530e71ed32ab23b34ca3fc72b080a554a40404":["28b61f1c9cf357a13efbb645d116d056feb80cf6"],"28b61f1c9cf357a13efbb645d116d056feb80cf6":["fdd572df21b78bb2212d045bf26a2773a48b58e9"],"30de45e50bdc1a79a6797f34dca6271c8866cb6e":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"fab172655716b96f7e42376116235017a922de3a":["c9fb5f46e264daf5ba3860defe623a89d202dd87","30de45e50bdc1a79a6797f34dca6271c8866cb6e"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2d530e71ed32ab23b34ca3fc72b080a554a40404"]},"commit2Childs":{"fdd572df21b78bb2212d045bf26a2773a48b58e9":["28b61f1c9cf357a13efbb645d116d056feb80cf6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"2d530e71ed32ab23b34ca3fc72b080a554a40404":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"30de45e50bdc1a79a6797f34dca6271c8866cb6e":["fdd572df21b78bb2212d045bf26a2773a48b58e9","fab172655716b96f7e42376116235017a922de3a"],"28b61f1c9cf357a13efbb645d116d056feb80cf6":["2d530e71ed32ab23b34ca3fc72b080a554a40404"],"fab172655716b96f7e42376116235017a922de3a":[],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["30de45e50bdc1a79a6797f34dca6271c8866cb6e","fab172655716b96f7e42376116235017a922de3a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["fab172655716b96f7e42376116235017a922de3a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}