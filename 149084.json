{"path":"solr/src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","commits":[{"id":"893269407f5c988a4b2ee13c7ffc01ec43136c1d","date":1268598046,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n  public NamedList getFacetDateCounts()\n          throws IOException, ParseException {\n\n    final SolrParams required = new RequiredSolrParams(params);\n    final NamedList resOuter = new SimpleOrderedMap();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n    final Date NOW = new Date();\n    \n    if (null == fields || 0 == fields.length) return resOuter;\n    \n    final IndexSchema schema = searcher.getSchema();\n    for (String f : fields) {\n      parseParams(FacetParams.FACET_DATE, f);\n      f = facetValue;\n\n\n      final NamedList resInner = new SimpleOrderedMap();\n      resOuter.add(key, resInner);\n      final SchemaField sf = schema.getField(f);\n      if (! (sf.getType() instanceof DateField)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Can not date facet on a field which is not a DateField: \" + f);\n      }\n      final DateField ft = (DateField) sf.getType();\n      final String startS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_START);\n      final Date start;\n      try {\n        start = ft.parseMath(NOW, startS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'start' is not a valid Date string: \" + startS, e);\n      }\n      final String endS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_END);\n      Date end; // not final, hardend may change this\n      try {\n        end = ft.parseMath(NOW, endS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' is not a valid Date string: \" + endS, e);\n      }\n          \n      if (end.before(start)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' comes before 'start': \"+endS+\" < \"+startS);\n      }\n\n      final String gap = required.getFieldParam(f,FacetParams.FACET_DATE_GAP);\n      final DateMathParser dmp = new DateMathParser(ft.UTC, Locale.US);\n      dmp.setNow(NOW);\n\n      int minCount = params.getFieldInt(f,FacetParams.FACET_MINCOUNT, 0);\n\n      try {\n        \n        Date low = start;\n        while (low.before(end)) {\n          dmp.setNow(low);\n          String label = ft.toExternal(low);\n          \n          Date high = dmp.parseMath(gap);\n          if (end.before(high)) {\n            if (params.getFieldBool(f,FacetParams.FACET_DATE_HARD_END,false)) {\n              high = end;\n            } else {\n              end = high;\n            }\n          }\n          if (high.before(low)) {\n            throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n               \"date facet infinite loop (is gap negative?)\");\n          }\n          int count = rangeCount(sf,low,high,true,true);\n          if (count >= minCount) {\n            resInner.add(label, count);\n          }\n          low = high;\n        }\n      } catch (java.text.ParseException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'gap' is not a valid Date Math string: \" + gap, e);\n      }\n      \n      // explicitly return the gap and end so all the counts are meaningful\n      resInner.add(\"gap\", gap);\n      resInner.add(\"end\", end);\n\n      final String[] othersP =\n        params.getFieldParams(f,FacetParams.FACET_DATE_OTHER);\n      if (null != othersP && 0 < othersP.length ) {\n        Set<FacetDateOther> others = EnumSet.noneOf(FacetDateOther.class);\n\n        for (final String o : othersP) {\n          others.add(FacetDateOther.get(o));\n        }\n\n        // no matter what other values are listed, we don't do\n        // anything if \"none\" is specified.\n        if (! others.contains(FacetDateOther.NONE) ) {          \n          boolean all = others.contains(FacetDateOther.ALL);\n        \n          if (all || others.contains(FacetDateOther.BEFORE)) {\n            resInner.add(FacetDateOther.BEFORE.toString(),\n                         rangeCount(sf,null,start,false,false));\n          }\n          if (all || others.contains(FacetDateOther.AFTER)) {\n            resInner.add(FacetDateOther.AFTER.toString(),\n                         rangeCount(sf,end,null,false,false));\n          }\n          if (all || others.contains(FacetDateOther.BETWEEN)) {\n            resInner.add(FacetDateOther.BETWEEN.toString(),\n                         rangeCount(sf,start,end,true,true));\n          }\n        }\n      }\n    }\n    \n    return resOuter;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","date":1268599006,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","sourceNew":null,"sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n  public NamedList getFacetDateCounts()\n          throws IOException, ParseException {\n\n    final SolrParams required = new RequiredSolrParams(params);\n    final NamedList resOuter = new SimpleOrderedMap();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n    final Date NOW = new Date();\n    \n    if (null == fields || 0 == fields.length) return resOuter;\n    \n    final IndexSchema schema = searcher.getSchema();\n    for (String f : fields) {\n      parseParams(FacetParams.FACET_DATE, f);\n      f = facetValue;\n\n\n      final NamedList resInner = new SimpleOrderedMap();\n      resOuter.add(key, resInner);\n      final SchemaField sf = schema.getField(f);\n      if (! (sf.getType() instanceof DateField)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Can not date facet on a field which is not a DateField: \" + f);\n      }\n      final DateField ft = (DateField) sf.getType();\n      final String startS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_START);\n      final Date start;\n      try {\n        start = ft.parseMath(NOW, startS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'start' is not a valid Date string: \" + startS, e);\n      }\n      final String endS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_END);\n      Date end; // not final, hardend may change this\n      try {\n        end = ft.parseMath(NOW, endS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' is not a valid Date string: \" + endS, e);\n      }\n          \n      if (end.before(start)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' comes before 'start': \"+endS+\" < \"+startS);\n      }\n\n      final String gap = required.getFieldParam(f,FacetParams.FACET_DATE_GAP);\n      final DateMathParser dmp = new DateMathParser(ft.UTC, Locale.US);\n      dmp.setNow(NOW);\n\n      int minCount = params.getFieldInt(f,FacetParams.FACET_MINCOUNT, 0);\n\n      try {\n        \n        Date low = start;\n        while (low.before(end)) {\n          dmp.setNow(low);\n          String label = ft.toExternal(low);\n          \n          Date high = dmp.parseMath(gap);\n          if (end.before(high)) {\n            if (params.getFieldBool(f,FacetParams.FACET_DATE_HARD_END,false)) {\n              high = end;\n            } else {\n              end = high;\n            }\n          }\n          if (high.before(low)) {\n            throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n               \"date facet infinite loop (is gap negative?)\");\n          }\n          int count = rangeCount(sf,low,high,true,true);\n          if (count >= minCount) {\n            resInner.add(label, count);\n          }\n          low = high;\n        }\n      } catch (java.text.ParseException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'gap' is not a valid Date Math string: \" + gap, e);\n      }\n      \n      // explicitly return the gap and end so all the counts are meaningful\n      resInner.add(\"gap\", gap);\n      resInner.add(\"end\", end);\n\n      final String[] othersP =\n        params.getFieldParams(f,FacetParams.FACET_DATE_OTHER);\n      if (null != othersP && 0 < othersP.length ) {\n        Set<FacetDateOther> others = EnumSet.noneOf(FacetDateOther.class);\n\n        for (final String o : othersP) {\n          others.add(FacetDateOther.get(o));\n        }\n\n        // no matter what other values are listed, we don't do\n        // anything if \"none\" is specified.\n        if (! others.contains(FacetDateOther.NONE) ) {          \n          boolean all = others.contains(FacetDateOther.ALL);\n        \n          if (all || others.contains(FacetDateOther.BEFORE)) {\n            resInner.add(FacetDateOther.BEFORE.toString(),\n                         rangeCount(sf,null,start,false,false));\n          }\n          if (all || others.contains(FacetDateOther.AFTER)) {\n            resInner.add(FacetDateOther.AFTER.toString(),\n                         rangeCount(sf,end,null,false,false));\n          }\n          if (all || others.contains(FacetDateOther.BETWEEN)) {\n            resInner.add(FacetDateOther.BETWEEN.toString(),\n                         rangeCount(sf,start,end,true,true));\n          }\n        }\n      }\n    }\n    \n    return resOuter;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","pathOld":"src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n  public NamedList getFacetDateCounts()\n          throws IOException, ParseException {\n\n    final SolrParams required = new RequiredSolrParams(params);\n    final NamedList resOuter = new SimpleOrderedMap();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n    final Date NOW = new Date();\n    \n    if (null == fields || 0 == fields.length) return resOuter;\n    \n    final IndexSchema schema = searcher.getSchema();\n    for (String f : fields) {\n      parseParams(FacetParams.FACET_DATE, f);\n      f = facetValue;\n\n\n      final NamedList resInner = new SimpleOrderedMap();\n      resOuter.add(key, resInner);\n      final SchemaField sf = schema.getField(f);\n      if (! (sf.getType() instanceof DateField)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Can not date facet on a field which is not a DateField: \" + f);\n      }\n      final DateField ft = (DateField) sf.getType();\n      final String startS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_START);\n      final Date start;\n      try {\n        start = ft.parseMath(NOW, startS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'start' is not a valid Date string: \" + startS, e);\n      }\n      final String endS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_END);\n      Date end; // not final, hardend may change this\n      try {\n        end = ft.parseMath(NOW, endS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' is not a valid Date string: \" + endS, e);\n      }\n          \n      if (end.before(start)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' comes before 'start': \"+endS+\" < \"+startS);\n      }\n\n      final String gap = required.getFieldParam(f,FacetParams.FACET_DATE_GAP);\n      final DateMathParser dmp = new DateMathParser(ft.UTC, Locale.US);\n      dmp.setNow(NOW);\n\n      int minCount = params.getFieldInt(f,FacetParams.FACET_MINCOUNT, 0);\n\n      try {\n        \n        Date low = start;\n        while (low.before(end)) {\n          dmp.setNow(low);\n          String label = ft.toExternal(low);\n          \n          Date high = dmp.parseMath(gap);\n          if (end.before(high)) {\n            if (params.getFieldBool(f,FacetParams.FACET_DATE_HARD_END,false)) {\n              high = end;\n            } else {\n              end = high;\n            }\n          }\n          if (high.before(low)) {\n            throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n               \"date facet infinite loop (is gap negative?)\");\n          }\n          int count = rangeCount(sf,low,high,true,true);\n          if (count >= minCount) {\n            resInner.add(label, count);\n          }\n          low = high;\n        }\n      } catch (java.text.ParseException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'gap' is not a valid Date Math string: \" + gap, e);\n      }\n      \n      // explicitly return the gap and end so all the counts are meaningful\n      resInner.add(\"gap\", gap);\n      resInner.add(\"end\", end);\n\n      final String[] othersP =\n        params.getFieldParams(f,FacetParams.FACET_DATE_OTHER);\n      if (null != othersP && 0 < othersP.length ) {\n        Set<FacetDateOther> others = EnumSet.noneOf(FacetDateOther.class);\n\n        for (final String o : othersP) {\n          others.add(FacetDateOther.get(o));\n        }\n\n        // no matter what other values are listed, we don't do\n        // anything if \"none\" is specified.\n        if (! others.contains(FacetDateOther.NONE) ) {          \n          boolean all = others.contains(FacetDateOther.ALL);\n        \n          if (all || others.contains(FacetDateOther.BEFORE)) {\n            resInner.add(FacetDateOther.BEFORE.toString(),\n                         rangeCount(sf,null,start,false,false));\n          }\n          if (all || others.contains(FacetDateOther.AFTER)) {\n            resInner.add(FacetDateOther.AFTER.toString(),\n                         rangeCount(sf,end,null,false,false));\n          }\n          if (all || others.contains(FacetDateOther.BETWEEN)) {\n            resInner.add(FacetDateOther.BETWEEN.toString(),\n                         rangeCount(sf,start,end,true,true));\n          }\n        }\n      }\n    }\n    \n    return resOuter;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n  public NamedList getFacetDateCounts()\n          throws IOException, ParseException {\n\n    final SolrParams required = new RequiredSolrParams(params);\n    final NamedList resOuter = new SimpleOrderedMap();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n    final Date NOW = new Date();\n    \n    if (null == fields || 0 == fields.length) return resOuter;\n    \n    final IndexSchema schema = searcher.getSchema();\n    for (String f : fields) {\n      parseParams(FacetParams.FACET_DATE, f);\n      f = facetValue;\n\n\n      final NamedList resInner = new SimpleOrderedMap();\n      resOuter.add(key, resInner);\n      final SchemaField sf = schema.getField(f);\n      if (! (sf.getType() instanceof DateField)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Can not date facet on a field which is not a DateField: \" + f);\n      }\n      final DateField ft = (DateField) sf.getType();\n      final String startS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_START);\n      final Date start;\n      try {\n        start = ft.parseMath(NOW, startS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'start' is not a valid Date string: \" + startS, e);\n      }\n      final String endS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_END);\n      Date end; // not final, hardend may change this\n      try {\n        end = ft.parseMath(NOW, endS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' is not a valid Date string: \" + endS, e);\n      }\n          \n      if (end.before(start)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' comes before 'start': \"+endS+\" < \"+startS);\n      }\n\n      final String gap = required.getFieldParam(f,FacetParams.FACET_DATE_GAP);\n      final DateMathParser dmp = new DateMathParser(ft.UTC, Locale.US);\n      dmp.setNow(NOW);\n\n      int minCount = params.getFieldInt(f,FacetParams.FACET_MINCOUNT, 0);\n\n      try {\n        \n        Date low = start;\n        while (low.before(end)) {\n          dmp.setNow(low);\n          String label = ft.toExternal(low);\n          \n          Date high = dmp.parseMath(gap);\n          if (end.before(high)) {\n            if (params.getFieldBool(f,FacetParams.FACET_DATE_HARD_END,false)) {\n              high = end;\n            } else {\n              end = high;\n            }\n          }\n          if (high.before(low)) {\n            throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n               \"date facet infinite loop (is gap negative?)\");\n          }\n          int count = rangeCount(sf,low,high,true,true);\n          if (count >= minCount) {\n            resInner.add(label, count);\n          }\n          low = high;\n        }\n      } catch (java.text.ParseException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'gap' is not a valid Date Math string: \" + gap, e);\n      }\n      \n      // explicitly return the gap and end so all the counts are meaningful\n      resInner.add(\"gap\", gap);\n      resInner.add(\"end\", end);\n\n      final String[] othersP =\n        params.getFieldParams(f,FacetParams.FACET_DATE_OTHER);\n      if (null != othersP && 0 < othersP.length ) {\n        Set<FacetDateOther> others = EnumSet.noneOf(FacetDateOther.class);\n\n        for (final String o : othersP) {\n          others.add(FacetDateOther.get(o));\n        }\n\n        // no matter what other values are listed, we don't do\n        // anything if \"none\" is specified.\n        if (! others.contains(FacetDateOther.NONE) ) {          \n          boolean all = others.contains(FacetDateOther.ALL);\n        \n          if (all || others.contains(FacetDateOther.BEFORE)) {\n            resInner.add(FacetDateOther.BEFORE.toString(),\n                         rangeCount(sf,null,start,false,false));\n          }\n          if (all || others.contains(FacetDateOther.AFTER)) {\n            resInner.add(FacetDateOther.AFTER.toString(),\n                         rangeCount(sf,end,null,false,false));\n          }\n          if (all || others.contains(FacetDateOther.BETWEEN)) {\n            resInner.add(FacetDateOther.BETWEEN.toString(),\n                         rangeCount(sf,start,end,true,true));\n          }\n        }\n      }\n    }\n    \n    return resOuter;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da8d55113b689b06716246649de6f62430f15c0","date":1453508340,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n  public NamedList getFacetDateCounts()\n          throws IOException, ParseException {\n\n    final SolrParams required = new RequiredSolrParams(params);\n    final NamedList resOuter = new SimpleOrderedMap();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n    final Date NOW = new Date();\n    \n    if (null == fields || 0 == fields.length) return resOuter;\n    \n    final IndexSchema schema = searcher.getSchema();\n    for (String f : fields) {\n      parseParams(FacetParams.FACET_DATE, f);\n      f = facetValue;\n\n\n      final NamedList resInner = new SimpleOrderedMap();\n      resOuter.add(key, resInner);\n      final SchemaField sf = schema.getField(f);\n      if (! (sf.getType() instanceof DateField)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Can not date facet on a field which is not a DateField: \" + f);\n      }\n      final DateField ft = (DateField) sf.getType();\n      final String startS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_START);\n      final Date start;\n      try {\n        start = ft.parseMath(NOW, startS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'start' is not a valid Date string: \" + startS, e);\n      }\n      final String endS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_END);\n      Date end; // not final, hardend may change this\n      try {\n        end = ft.parseMath(NOW, endS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' is not a valid Date string: \" + endS, e);\n      }\n          \n      if (end.before(start)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' comes before 'start': \"+endS+\" < \"+startS);\n      }\n\n      final String gap = required.getFieldParam(f,FacetParams.FACET_DATE_GAP);\n      final DateMathParser dmp = new DateMathParser(ft.UTC, Locale.US);\n      dmp.setNow(NOW);\n\n      int minCount = params.getFieldInt(f,FacetParams.FACET_MINCOUNT, 0);\n\n      try {\n        \n        Date low = start;\n        while (low.before(end)) {\n          dmp.setNow(low);\n          String label = ft.toExternal(low);\n          \n          Date high = dmp.parseMath(gap);\n          if (end.before(high)) {\n            if (params.getFieldBool(f,FacetParams.FACET_DATE_HARD_END,false)) {\n              high = end;\n            } else {\n              end = high;\n            }\n          }\n          if (high.before(low)) {\n            throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n               \"date facet infinite loop (is gap negative?)\");\n          }\n          int count = rangeCount(sf,low,high,true,true);\n          if (count >= minCount) {\n            resInner.add(label, count);\n          }\n          low = high;\n        }\n      } catch (java.text.ParseException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'gap' is not a valid Date Math string: \" + gap, e);\n      }\n      \n      // explicitly return the gap and end so all the counts are meaningful\n      resInner.add(\"gap\", gap);\n      resInner.add(\"end\", end);\n\n      final String[] othersP =\n        params.getFieldParams(f,FacetParams.FACET_DATE_OTHER);\n      if (null != othersP && 0 < othersP.length ) {\n        Set<FacetDateOther> others = EnumSet.noneOf(FacetDateOther.class);\n\n        for (final String o : othersP) {\n          others.add(FacetDateOther.get(o));\n        }\n\n        // no matter what other values are listed, we don't do\n        // anything if \"none\" is specified.\n        if (! others.contains(FacetDateOther.NONE) ) {          \n          boolean all = others.contains(FacetDateOther.ALL);\n        \n          if (all || others.contains(FacetDateOther.BEFORE)) {\n            resInner.add(FacetDateOther.BEFORE.toString(),\n                         rangeCount(sf,null,start,false,false));\n          }\n          if (all || others.contains(FacetDateOther.AFTER)) {\n            resInner.add(FacetDateOther.AFTER.toString(),\n                         rangeCount(sf,end,null,false,false));\n          }\n          if (all || others.contains(FacetDateOther.BETWEEN)) {\n            resInner.add(FacetDateOther.BETWEEN.toString(),\n                         rangeCount(sf,start,end,true,true));\n          }\n        }\n      }\n    }\n    \n    return resOuter;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"870336f01c94cf29d0cc6d2824875c7c813b2aec","date":1272910885,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","pathOld":"solr/src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n  public NamedList getFacetDateCounts()\n          throws IOException, ParseException {\n\n    final SolrParams required = new RequiredSolrParams(params);\n    final NamedList resOuter = new SimpleOrderedMap();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n    final Date NOW = new Date();\n    \n    if (null == fields || 0 == fields.length) return resOuter;\n    \n    final IndexSchema schema = searcher.getSchema();\n    for (String f : fields) {\n      parseParams(FacetParams.FACET_DATE, f);\n      f = facetValue;\n\n\n      final NamedList resInner = new SimpleOrderedMap();\n      resOuter.add(key, resInner);\n      final SchemaField sf = schema.getField(f);\n      if (! (sf.getType() instanceof DateField)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Can not date facet on a field which is not a DateField: \" + f);\n      }\n      final DateField ft = (DateField) sf.getType();\n      final String startS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_START);\n      final Date start;\n      try {\n        start = ft.parseMath(NOW, startS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'start' is not a valid Date string: \" + startS, e);\n      }\n      final String endS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_END);\n      Date end; // not final, hardend may change this\n      try {\n        end = ft.parseMath(NOW, endS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' is not a valid Date string: \" + endS, e);\n      }\n          \n      if (end.before(start)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' comes before 'start': \"+endS+\" < \"+startS);\n      }\n\n      final String gap = required.getFieldParam(f,FacetParams.FACET_DATE_GAP);\n      final DateMathParser dmp = new DateMathParser(ft.UTC, Locale.US);\n      dmp.setNow(NOW);\n\n      int minCount = params.getFieldInt(f,FacetParams.FACET_MINCOUNT, 0);\n\n      final EnumSet<FacetDateInclude> include = FacetDateInclude.parseParam\n        (params.getFieldParams(f,FacetParams.FACET_DATE_INCLUDE));\n\n      try {\n        Date low = start;\n        while (low.before(end)) {\n          dmp.setNow(low);\n          String label = ft.toExternal(low);\n          \n          Date high = dmp.parseMath(gap);\n          if (end.before(high)) {\n            if (params.getFieldBool(f,FacetParams.FACET_DATE_HARD_END,false)) {\n              high = end;\n            } else {\n              end = high;\n            }\n          }\n          if (high.before(low)) {\n            throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n               \"date facet infinite loop (is gap negative?)\");\n          }\n          boolean includeLower = \n            (include.contains(FacetDateInclude.LOWER) ||\n             (include.contains(FacetDateInclude.EDGE) && low.equals(start)));\n          boolean includeUpper = \n            (include.contains(FacetDateInclude.UPPER) ||\n             (include.contains(FacetDateInclude.EDGE) && high.equals(end)));\n\n          int count = rangeCount(sf,low,high,includeLower,includeUpper);\n          if (count >= minCount) {\n            resInner.add(label, count);\n          }\n          low = high;\n        }\n      } catch (java.text.ParseException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'gap' is not a valid Date Math string: \" + gap, e);\n      }\n      \n      // explicitly return the gap and end so all the counts are meaningful\n      resInner.add(\"gap\", gap);\n      resInner.add(\"end\", end);\n\n      final String[] othersP =\n        params.getFieldParams(f,FacetParams.FACET_DATE_OTHER);\n      if (null != othersP && 0 < othersP.length ) {\n        Set<FacetDateOther> others = EnumSet.noneOf(FacetDateOther.class);\n\n        for (final String o : othersP) {\n          others.add(FacetDateOther.get(o));\n        }\n\n        // no matter what other values are listed, we don't do\n        // anything if \"none\" is specified.\n        if (! others.contains(FacetDateOther.NONE) ) {          \n          boolean all = others.contains(FacetDateOther.ALL);\n        \n          if (all || others.contains(FacetDateOther.BEFORE)) {\n            // include upper bound if \"outer\" or if first gap doesn't already include it\n            resInner.add(FacetDateOther.BEFORE.toString(),\n                         rangeCount(sf,null,start,\n                                    false,\n                                    (include.contains(FacetDateInclude.OUTER) ||\n                                     (! (include.contains(FacetDateInclude.LOWER) ||\n                                         include.contains(FacetDateInclude.EDGE))))));\n          }\n          if (all || others.contains(FacetDateOther.AFTER)) {\n            // include lower bound if \"outer\" or if last gap doesn't already include it\n            resInner.add(FacetDateOther.AFTER.toString(),\n                         rangeCount(sf,end,null,\n                                    (include.contains(FacetDateInclude.OUTER) ||\n                                     (! (include.contains(FacetDateInclude.UPPER) ||\n                                         include.contains(FacetDateInclude.EDGE)))),\n                                    false));\n          }\n          if (all || others.contains(FacetDateOther.BETWEEN)) {\n            resInner.add(FacetDateOther.BETWEEN.toString(),\n                         rangeCount(sf,start,end,\n                                    (include.contains(FacetDateInclude.LOWER) ||\n                                     include.contains(FacetDateInclude.EDGE)),\n                                    (include.contains(FacetDateInclude.UPPER) ||\n                                     include.contains(FacetDateInclude.EDGE))));\n          }\n        }\n      }\n    }\n    \n    return resOuter;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n  public NamedList getFacetDateCounts()\n          throws IOException, ParseException {\n\n    final SolrParams required = new RequiredSolrParams(params);\n    final NamedList resOuter = new SimpleOrderedMap();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n    final Date NOW = new Date();\n    \n    if (null == fields || 0 == fields.length) return resOuter;\n    \n    final IndexSchema schema = searcher.getSchema();\n    for (String f : fields) {\n      parseParams(FacetParams.FACET_DATE, f);\n      f = facetValue;\n\n\n      final NamedList resInner = new SimpleOrderedMap();\n      resOuter.add(key, resInner);\n      final SchemaField sf = schema.getField(f);\n      if (! (sf.getType() instanceof DateField)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Can not date facet on a field which is not a DateField: \" + f);\n      }\n      final DateField ft = (DateField) sf.getType();\n      final String startS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_START);\n      final Date start;\n      try {\n        start = ft.parseMath(NOW, startS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'start' is not a valid Date string: \" + startS, e);\n      }\n      final String endS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_END);\n      Date end; // not final, hardend may change this\n      try {\n        end = ft.parseMath(NOW, endS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' is not a valid Date string: \" + endS, e);\n      }\n          \n      if (end.before(start)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' comes before 'start': \"+endS+\" < \"+startS);\n      }\n\n      final String gap = required.getFieldParam(f,FacetParams.FACET_DATE_GAP);\n      final DateMathParser dmp = new DateMathParser(ft.UTC, Locale.US);\n      dmp.setNow(NOW);\n\n      int minCount = params.getFieldInt(f,FacetParams.FACET_MINCOUNT, 0);\n\n      try {\n        \n        Date low = start;\n        while (low.before(end)) {\n          dmp.setNow(low);\n          String label = ft.toExternal(low);\n          \n          Date high = dmp.parseMath(gap);\n          if (end.before(high)) {\n            if (params.getFieldBool(f,FacetParams.FACET_DATE_HARD_END,false)) {\n              high = end;\n            } else {\n              end = high;\n            }\n          }\n          if (high.before(low)) {\n            throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n               \"date facet infinite loop (is gap negative?)\");\n          }\n          int count = rangeCount(sf,low,high,true,true);\n          if (count >= minCount) {\n            resInner.add(label, count);\n          }\n          low = high;\n        }\n      } catch (java.text.ParseException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'gap' is not a valid Date Math string: \" + gap, e);\n      }\n      \n      // explicitly return the gap and end so all the counts are meaningful\n      resInner.add(\"gap\", gap);\n      resInner.add(\"end\", end);\n\n      final String[] othersP =\n        params.getFieldParams(f,FacetParams.FACET_DATE_OTHER);\n      if (null != othersP && 0 < othersP.length ) {\n        Set<FacetDateOther> others = EnumSet.noneOf(FacetDateOther.class);\n\n        for (final String o : othersP) {\n          others.add(FacetDateOther.get(o));\n        }\n\n        // no matter what other values are listed, we don't do\n        // anything if \"none\" is specified.\n        if (! others.contains(FacetDateOther.NONE) ) {          \n          boolean all = others.contains(FacetDateOther.ALL);\n        \n          if (all || others.contains(FacetDateOther.BEFORE)) {\n            resInner.add(FacetDateOther.BEFORE.toString(),\n                         rangeCount(sf,null,start,false,false));\n          }\n          if (all || others.contains(FacetDateOther.AFTER)) {\n            resInner.add(FacetDateOther.AFTER.toString(),\n                         rangeCount(sf,end,null,false,false));\n          }\n          if (all || others.contains(FacetDateOther.BETWEEN)) {\n            resInner.add(FacetDateOther.BETWEEN.toString(),\n                         rangeCount(sf,start,end,true,true));\n          }\n        }\n      }\n    }\n    \n    return resOuter;\n  }\n\n","bugFix":null,"bugIntro":["ef02613bb5b67b98ca5caf41e8d6e016a0158923"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"432127b09840b2b70209e404d242e7029421ef0a","date":1280433941,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","pathOld":"solr/src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n  public NamedList getFacetDateCounts()\n    throws IOException, ParseException {\n\n    final NamedList resOuter = new SimpleOrderedMap();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n    \n    if (null == fields || 0 == fields.length) return resOuter;\n    \n    final IndexSchema schema = searcher.getSchema();\n    for (String f : fields) {\n      parseParams(FacetParams.FACET_DATE, f);\n      f = facetValue;\n\n\n      final NamedList resInner = new SimpleOrderedMap();\n      resOuter.add(key, resInner);\n      final SchemaField sf = schema.getField(f);\n      if (! (sf.getType() instanceof DateField)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Can not date facet on a field which is not a DateField: \" + f);\n      }\n      final DateField ft = (DateField) sf.getType();\n      final String startS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_START);\n      final Date start;\n      try {\n        start = ft.parseMath(NOW, startS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'start' is not a valid Date string: \" + startS, e);\n      }\n      final String endS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_END);\n      Date end; // not final, hardend may change this\n      try {\n        end = ft.parseMath(NOW, endS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' is not a valid Date string: \" + endS, e);\n      }\n          \n      if (end.before(start)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' comes before 'start': \"+endS+\" < \"+startS);\n      }\n\n      final String gap = required.getFieldParam(f,FacetParams.FACET_DATE_GAP);\n      final DateMathParser dmp = new DateMathParser(ft.UTC, Locale.US);\n      dmp.setNow(NOW);\n\n      final int minCount = params.getFieldInt(f,FacetParams.FACET_MINCOUNT, 0);\n\n      final EnumSet<FacetRangeInclude> include = FacetRangeInclude.parseParam\n        (params.getFieldParams(f,FacetParams.FACET_DATE_INCLUDE));\n\n      try {\n        Date low = start;\n        while (low.before(end)) {\n          dmp.setNow(low);\n          String label = ft.toExternal(low);\n          \n          Date high = dmp.parseMath(gap);\n          if (end.before(high)) {\n            if (params.getFieldBool(f,FacetParams.FACET_DATE_HARD_END,false)) {\n              high = end;\n            } else {\n              end = high;\n            }\n          }\n          if (high.before(low)) {\n            throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n               \"date facet infinite loop (is gap negative?)\");\n          }\n          final boolean includeLower = \n            (include.contains(FacetRangeInclude.LOWER) ||\n             (include.contains(FacetRangeInclude.EDGE) && low.equals(start)));\n          final boolean includeUpper = \n            (include.contains(FacetRangeInclude.UPPER) ||\n             (include.contains(FacetRangeInclude.EDGE) && high.equals(end)));\n\n          final int count = rangeCount(sf,low,high,includeLower,includeUpper);\n          if (count >= minCount) {\n            resInner.add(label, count);\n          }\n          low = high;\n        }\n      } catch (java.text.ParseException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'gap' is not a valid Date Math string: \" + gap, e);\n      }\n      \n      // explicitly return the gap and end so all the counts \n      // (including before/after/between) are meaningful - even if mincount\n      // has removed the neighboring ranges\n      resInner.add(\"gap\", gap);\n      resInner.add(\"start\", start);\n      resInner.add(\"end\", end);\n\n      final String[] othersP =\n        params.getFieldParams(f,FacetParams.FACET_DATE_OTHER);\n      if (null != othersP && 0 < othersP.length ) {\n        final Set<FacetRangeOther> others = EnumSet.noneOf(FacetRangeOther.class);\n\n        for (final String o : othersP) {\n          others.add(FacetRangeOther.get(o));\n        }\n\n        // no matter what other values are listed, we don't do\n        // anything if \"none\" is specified.\n        if (! others.contains(FacetRangeOther.NONE) ) {          \n          boolean all = others.contains(FacetRangeOther.ALL);\n        \n          if (all || others.contains(FacetRangeOther.BEFORE)) {\n            // include upper bound if \"outer\" or if first gap doesn't already include it\n            resInner.add(FacetRangeOther.BEFORE.toString(),\n                         rangeCount(sf,null,start,\n                                    false,\n                                    (include.contains(FacetRangeInclude.OUTER) ||\n                                     (! (include.contains(FacetRangeInclude.LOWER) ||\n                                         include.contains(FacetRangeInclude.EDGE))))));\n          }\n          if (all || others.contains(FacetRangeOther.AFTER)) {\n            // include lower bound if \"outer\" or if last gap doesn't already include it\n            resInner.add(FacetRangeOther.AFTER.toString(),\n                         rangeCount(sf,end,null,\n                                    (include.contains(FacetRangeInclude.OUTER) ||\n                                     (! (include.contains(FacetRangeInclude.UPPER) ||\n                                         include.contains(FacetRangeInclude.EDGE)))),\n                                    false));\n          }\n          if (all || others.contains(FacetRangeOther.BETWEEN)) {\n            resInner.add(FacetRangeOther.BETWEEN.toString(),\n                         rangeCount(sf,start,end,\n                                    (include.contains(FacetRangeInclude.LOWER) ||\n                                     include.contains(FacetRangeInclude.EDGE)),\n                                    (include.contains(FacetRangeInclude.UPPER) ||\n                                     include.contains(FacetRangeInclude.EDGE))));\n          }\n        }\n      }\n    }\n    \n    return resOuter;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n  public NamedList getFacetDateCounts()\n          throws IOException, ParseException {\n\n    final SolrParams required = new RequiredSolrParams(params);\n    final NamedList resOuter = new SimpleOrderedMap();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n    final Date NOW = new Date();\n    \n    if (null == fields || 0 == fields.length) return resOuter;\n    \n    final IndexSchema schema = searcher.getSchema();\n    for (String f : fields) {\n      parseParams(FacetParams.FACET_DATE, f);\n      f = facetValue;\n\n\n      final NamedList resInner = new SimpleOrderedMap();\n      resOuter.add(key, resInner);\n      final SchemaField sf = schema.getField(f);\n      if (! (sf.getType() instanceof DateField)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Can not date facet on a field which is not a DateField: \" + f);\n      }\n      final DateField ft = (DateField) sf.getType();\n      final String startS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_START);\n      final Date start;\n      try {\n        start = ft.parseMath(NOW, startS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'start' is not a valid Date string: \" + startS, e);\n      }\n      final String endS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_END);\n      Date end; // not final, hardend may change this\n      try {\n        end = ft.parseMath(NOW, endS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' is not a valid Date string: \" + endS, e);\n      }\n          \n      if (end.before(start)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' comes before 'start': \"+endS+\" < \"+startS);\n      }\n\n      final String gap = required.getFieldParam(f,FacetParams.FACET_DATE_GAP);\n      final DateMathParser dmp = new DateMathParser(ft.UTC, Locale.US);\n      dmp.setNow(NOW);\n\n      int minCount = params.getFieldInt(f,FacetParams.FACET_MINCOUNT, 0);\n\n      final EnumSet<FacetDateInclude> include = FacetDateInclude.parseParam\n        (params.getFieldParams(f,FacetParams.FACET_DATE_INCLUDE));\n\n      try {\n        Date low = start;\n        while (low.before(end)) {\n          dmp.setNow(low);\n          String label = ft.toExternal(low);\n          \n          Date high = dmp.parseMath(gap);\n          if (end.before(high)) {\n            if (params.getFieldBool(f,FacetParams.FACET_DATE_HARD_END,false)) {\n              high = end;\n            } else {\n              end = high;\n            }\n          }\n          if (high.before(low)) {\n            throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n               \"date facet infinite loop (is gap negative?)\");\n          }\n          boolean includeLower = \n            (include.contains(FacetDateInclude.LOWER) ||\n             (include.contains(FacetDateInclude.EDGE) && low.equals(start)));\n          boolean includeUpper = \n            (include.contains(FacetDateInclude.UPPER) ||\n             (include.contains(FacetDateInclude.EDGE) && high.equals(end)));\n\n          int count = rangeCount(sf,low,high,includeLower,includeUpper);\n          if (count >= minCount) {\n            resInner.add(label, count);\n          }\n          low = high;\n        }\n      } catch (java.text.ParseException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'gap' is not a valid Date Math string: \" + gap, e);\n      }\n      \n      // explicitly return the gap and end so all the counts are meaningful\n      resInner.add(\"gap\", gap);\n      resInner.add(\"end\", end);\n\n      final String[] othersP =\n        params.getFieldParams(f,FacetParams.FACET_DATE_OTHER);\n      if (null != othersP && 0 < othersP.length ) {\n        Set<FacetDateOther> others = EnumSet.noneOf(FacetDateOther.class);\n\n        for (final String o : othersP) {\n          others.add(FacetDateOther.get(o));\n        }\n\n        // no matter what other values are listed, we don't do\n        // anything if \"none\" is specified.\n        if (! others.contains(FacetDateOther.NONE) ) {          \n          boolean all = others.contains(FacetDateOther.ALL);\n        \n          if (all || others.contains(FacetDateOther.BEFORE)) {\n            // include upper bound if \"outer\" or if first gap doesn't already include it\n            resInner.add(FacetDateOther.BEFORE.toString(),\n                         rangeCount(sf,null,start,\n                                    false,\n                                    (include.contains(FacetDateInclude.OUTER) ||\n                                     (! (include.contains(FacetDateInclude.LOWER) ||\n                                         include.contains(FacetDateInclude.EDGE))))));\n          }\n          if (all || others.contains(FacetDateOther.AFTER)) {\n            // include lower bound if \"outer\" or if last gap doesn't already include it\n            resInner.add(FacetDateOther.AFTER.toString(),\n                         rangeCount(sf,end,null,\n                                    (include.contains(FacetDateInclude.OUTER) ||\n                                     (! (include.contains(FacetDateInclude.UPPER) ||\n                                         include.contains(FacetDateInclude.EDGE)))),\n                                    false));\n          }\n          if (all || others.contains(FacetDateOther.BETWEEN)) {\n            resInner.add(FacetDateOther.BETWEEN.toString(),\n                         rangeCount(sf,start,end,\n                                    (include.contains(FacetDateInclude.LOWER) ||\n                                     include.contains(FacetDateInclude.EDGE)),\n                                    (include.contains(FacetDateInclude.UPPER) ||\n                                     include.contains(FacetDateInclude.EDGE))));\n          }\n        }\n      }\n    }\n    \n    return resOuter;\n  }\n\n","bugFix":null,"bugIntro":["ef02613bb5b67b98ca5caf41e8d6e016a0158923"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ef02613bb5b67b98ca5caf41e8d6e016a0158923","date":1283980033,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","pathOld":"solr/src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n\n  public NamedList getFacetDateCounts()\n    throws IOException, ParseException {\n\n    final NamedList resOuter = new SimpleOrderedMap();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n\n    if (null == fields || 0 == fields.length) return resOuter;\n\n    for (String f : fields) {\n      try {\n        getFacetDateCounts(f, resOuter);\n      } catch (Exception e) {\n        String msg = \"Exception during facet.date of \" + f;\n        SolrException.logOnce(SolrCore.log, msg, e);\n        addException(msg , e);\n      }\n    }\n\n    return resOuter;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n  public NamedList getFacetDateCounts()\n    throws IOException, ParseException {\n\n    final NamedList resOuter = new SimpleOrderedMap();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n    \n    if (null == fields || 0 == fields.length) return resOuter;\n    \n    final IndexSchema schema = searcher.getSchema();\n    for (String f : fields) {\n      parseParams(FacetParams.FACET_DATE, f);\n      f = facetValue;\n\n\n      final NamedList resInner = new SimpleOrderedMap();\n      resOuter.add(key, resInner);\n      final SchemaField sf = schema.getField(f);\n      if (! (sf.getType() instanceof DateField)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Can not date facet on a field which is not a DateField: \" + f);\n      }\n      final DateField ft = (DateField) sf.getType();\n      final String startS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_START);\n      final Date start;\n      try {\n        start = ft.parseMath(NOW, startS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'start' is not a valid Date string: \" + startS, e);\n      }\n      final String endS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_END);\n      Date end; // not final, hardend may change this\n      try {\n        end = ft.parseMath(NOW, endS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' is not a valid Date string: \" + endS, e);\n      }\n          \n      if (end.before(start)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' comes before 'start': \"+endS+\" < \"+startS);\n      }\n\n      final String gap = required.getFieldParam(f,FacetParams.FACET_DATE_GAP);\n      final DateMathParser dmp = new DateMathParser(ft.UTC, Locale.US);\n      dmp.setNow(NOW);\n\n      final int minCount = params.getFieldInt(f,FacetParams.FACET_MINCOUNT, 0);\n\n      final EnumSet<FacetRangeInclude> include = FacetRangeInclude.parseParam\n        (params.getFieldParams(f,FacetParams.FACET_DATE_INCLUDE));\n\n      try {\n        Date low = start;\n        while (low.before(end)) {\n          dmp.setNow(low);\n          String label = ft.toExternal(low);\n          \n          Date high = dmp.parseMath(gap);\n          if (end.before(high)) {\n            if (params.getFieldBool(f,FacetParams.FACET_DATE_HARD_END,false)) {\n              high = end;\n            } else {\n              end = high;\n            }\n          }\n          if (high.before(low)) {\n            throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n               \"date facet infinite loop (is gap negative?)\");\n          }\n          final boolean includeLower = \n            (include.contains(FacetRangeInclude.LOWER) ||\n             (include.contains(FacetRangeInclude.EDGE) && low.equals(start)));\n          final boolean includeUpper = \n            (include.contains(FacetRangeInclude.UPPER) ||\n             (include.contains(FacetRangeInclude.EDGE) && high.equals(end)));\n\n          final int count = rangeCount(sf,low,high,includeLower,includeUpper);\n          if (count >= minCount) {\n            resInner.add(label, count);\n          }\n          low = high;\n        }\n      } catch (java.text.ParseException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'gap' is not a valid Date Math string: \" + gap, e);\n      }\n      \n      // explicitly return the gap and end so all the counts \n      // (including before/after/between) are meaningful - even if mincount\n      // has removed the neighboring ranges\n      resInner.add(\"gap\", gap);\n      resInner.add(\"start\", start);\n      resInner.add(\"end\", end);\n\n      final String[] othersP =\n        params.getFieldParams(f,FacetParams.FACET_DATE_OTHER);\n      if (null != othersP && 0 < othersP.length ) {\n        final Set<FacetRangeOther> others = EnumSet.noneOf(FacetRangeOther.class);\n\n        for (final String o : othersP) {\n          others.add(FacetRangeOther.get(o));\n        }\n\n        // no matter what other values are listed, we don't do\n        // anything if \"none\" is specified.\n        if (! others.contains(FacetRangeOther.NONE) ) {          \n          boolean all = others.contains(FacetRangeOther.ALL);\n        \n          if (all || others.contains(FacetRangeOther.BEFORE)) {\n            // include upper bound if \"outer\" or if first gap doesn't already include it\n            resInner.add(FacetRangeOther.BEFORE.toString(),\n                         rangeCount(sf,null,start,\n                                    false,\n                                    (include.contains(FacetRangeInclude.OUTER) ||\n                                     (! (include.contains(FacetRangeInclude.LOWER) ||\n                                         include.contains(FacetRangeInclude.EDGE))))));\n          }\n          if (all || others.contains(FacetRangeOther.AFTER)) {\n            // include lower bound if \"outer\" or if last gap doesn't already include it\n            resInner.add(FacetRangeOther.AFTER.toString(),\n                         rangeCount(sf,end,null,\n                                    (include.contains(FacetRangeInclude.OUTER) ||\n                                     (! (include.contains(FacetRangeInclude.UPPER) ||\n                                         include.contains(FacetRangeInclude.EDGE)))),\n                                    false));\n          }\n          if (all || others.contains(FacetRangeOther.BETWEEN)) {\n            resInner.add(FacetRangeOther.BETWEEN.toString(),\n                         rangeCount(sf,start,end,\n                                    (include.contains(FacetRangeInclude.LOWER) ||\n                                     include.contains(FacetRangeInclude.EDGE)),\n                                    (include.contains(FacetRangeInclude.UPPER) ||\n                                     include.contains(FacetRangeInclude.EDGE))));\n          }\n        }\n      }\n    }\n    \n    return resOuter;\n  }\n\n","bugFix":["c4fe52b26cfcf59d6b3f30b128e9f5985f2fa4ef","dbc0ca7104fa6f1d7cc24b05ed50b39ddb7cfa8c","432127b09840b2b70209e404d242e7029421ef0a","74224d32ccff5e171a601105a0cf9ad0569f0e29","870336f01c94cf29d0cc6d2824875c7c813b2aec","487bcb36f5ba67741dd4dc6ebea3dc32420c4fb1","9cb179b2fab2183d2f6041e450ff8022c592ecf0"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","pathOld":"solr/src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n\n  public NamedList getFacetDateCounts()\n    throws IOException, ParseException {\n\n    final NamedList resOuter = new SimpleOrderedMap();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n\n    if (null == fields || 0 == fields.length) return resOuter;\n\n    for (String f : fields) {\n      try {\n        getFacetDateCounts(f, resOuter);\n      } catch (Exception e) {\n        String msg = \"Exception during facet.date of \" + f;\n        SolrException.logOnce(SolrCore.log, msg, e);\n        addException(msg , e);\n      }\n    }\n\n    return resOuter;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n  public NamedList getFacetDateCounts()\n          throws IOException, ParseException {\n\n    final SolrParams required = new RequiredSolrParams(params);\n    final NamedList resOuter = new SimpleOrderedMap();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n    final Date NOW = new Date();\n    \n    if (null == fields || 0 == fields.length) return resOuter;\n    \n    final IndexSchema schema = searcher.getSchema();\n    for (String f : fields) {\n      parseParams(FacetParams.FACET_DATE, f);\n      f = facetValue;\n\n\n      final NamedList resInner = new SimpleOrderedMap();\n      resOuter.add(key, resInner);\n      final SchemaField sf = schema.getField(f);\n      if (! (sf.getType() instanceof DateField)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"Can not date facet on a field which is not a DateField: \" + f);\n      }\n      final DateField ft = (DateField) sf.getType();\n      final String startS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_START);\n      final Date start;\n      try {\n        start = ft.parseMath(NOW, startS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'start' is not a valid Date string: \" + startS, e);\n      }\n      final String endS\n        = required.getFieldParam(f,FacetParams.FACET_DATE_END);\n      Date end; // not final, hardend may change this\n      try {\n        end = ft.parseMath(NOW, endS);\n      } catch (SolrException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' is not a valid Date string: \" + endS, e);\n      }\n          \n      if (end.before(start)) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'end' comes before 'start': \"+endS+\" < \"+startS);\n      }\n\n      final String gap = required.getFieldParam(f,FacetParams.FACET_DATE_GAP);\n      final DateMathParser dmp = new DateMathParser(ft.UTC, Locale.US);\n      dmp.setNow(NOW);\n\n      int minCount = params.getFieldInt(f,FacetParams.FACET_MINCOUNT, 0);\n\n      final EnumSet<FacetDateInclude> include = FacetDateInclude.parseParam\n        (params.getFieldParams(f,FacetParams.FACET_DATE_INCLUDE));\n\n      try {\n        Date low = start;\n        while (low.before(end)) {\n          dmp.setNow(low);\n          String label = ft.toExternal(low);\n          \n          Date high = dmp.parseMath(gap);\n          if (end.before(high)) {\n            if (params.getFieldBool(f,FacetParams.FACET_DATE_HARD_END,false)) {\n              high = end;\n            } else {\n              end = high;\n            }\n          }\n          if (high.before(low)) {\n            throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n               \"date facet infinite loop (is gap negative?)\");\n          }\n          boolean includeLower = \n            (include.contains(FacetDateInclude.LOWER) ||\n             (include.contains(FacetDateInclude.EDGE) && low.equals(start)));\n          boolean includeUpper = \n            (include.contains(FacetDateInclude.UPPER) ||\n             (include.contains(FacetDateInclude.EDGE) && high.equals(end)));\n\n          int count = rangeCount(sf,low,high,includeLower,includeUpper);\n          if (count >= minCount) {\n            resInner.add(label, count);\n          }\n          low = high;\n        }\n      } catch (java.text.ParseException e) {\n        throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n           \"date facet 'gap' is not a valid Date Math string: \" + gap, e);\n      }\n      \n      // explicitly return the gap and end so all the counts are meaningful\n      resInner.add(\"gap\", gap);\n      resInner.add(\"end\", end);\n\n      final String[] othersP =\n        params.getFieldParams(f,FacetParams.FACET_DATE_OTHER);\n      if (null != othersP && 0 < othersP.length ) {\n        Set<FacetDateOther> others = EnumSet.noneOf(FacetDateOther.class);\n\n        for (final String o : othersP) {\n          others.add(FacetDateOther.get(o));\n        }\n\n        // no matter what other values are listed, we don't do\n        // anything if \"none\" is specified.\n        if (! others.contains(FacetDateOther.NONE) ) {          \n          boolean all = others.contains(FacetDateOther.ALL);\n        \n          if (all || others.contains(FacetDateOther.BEFORE)) {\n            // include upper bound if \"outer\" or if first gap doesn't already include it\n            resInner.add(FacetDateOther.BEFORE.toString(),\n                         rangeCount(sf,null,start,\n                                    false,\n                                    (include.contains(FacetDateInclude.OUTER) ||\n                                     (! (include.contains(FacetDateInclude.LOWER) ||\n                                         include.contains(FacetDateInclude.EDGE))))));\n          }\n          if (all || others.contains(FacetDateOther.AFTER)) {\n            // include lower bound if \"outer\" or if last gap doesn't already include it\n            resInner.add(FacetDateOther.AFTER.toString(),\n                         rangeCount(sf,end,null,\n                                    (include.contains(FacetDateInclude.OUTER) ||\n                                     (! (include.contains(FacetDateInclude.UPPER) ||\n                                         include.contains(FacetDateInclude.EDGE)))),\n                                    false));\n          }\n          if (all || others.contains(FacetDateOther.BETWEEN)) {\n            resInner.add(FacetDateOther.BETWEEN.toString(),\n                         rangeCount(sf,start,end,\n                                    (include.contains(FacetDateInclude.LOWER) ||\n                                     include.contains(FacetDateInclude.EDGE)),\n                                    (include.contains(FacetDateInclude.UPPER) ||\n                                     include.contains(FacetDateInclude.EDGE))));\n          }\n        }\n      }\n    }\n    \n    return resOuter;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"755f2f419306d7297c8feee10d1897addf4b2dd0","date":1294442354,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","pathOld":"solr/src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n\n  public NamedList<Object> getFacetDateCounts()\n    throws IOException, ParseException {\n\n    final NamedList<Object> resOuter = new SimpleOrderedMap<Object>();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n\n    if (null == fields || 0 == fields.length) return resOuter;\n\n    for (String f : fields) {\n      try {\n        getFacetDateCounts(f, resOuter);\n      } catch (Exception e) {\n        String msg = \"Exception during facet.date of \" + f;\n        SolrException.logOnce(SolrCore.log, msg, e);\n        addException(msg , e);\n      }\n    }\n\n    return resOuter;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n\n  public NamedList getFacetDateCounts()\n    throws IOException, ParseException {\n\n    final NamedList resOuter = new SimpleOrderedMap();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n\n    if (null == fields || 0 == fields.length) return resOuter;\n\n    for (String f : fields) {\n      try {\n        getFacetDateCounts(f, resOuter);\n      } catch (Exception e) {\n        String msg = \"Exception during facet.date of \" + f;\n        SolrException.logOnce(SolrCore.log, msg, e);\n        addException(msg , e);\n      }\n    }\n\n    return resOuter;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","pathOld":"solr/src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n\n  public NamedList<Object> getFacetDateCounts()\n    throws IOException, ParseException {\n\n    final NamedList<Object> resOuter = new SimpleOrderedMap<Object>();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n\n    if (null == fields || 0 == fields.length) return resOuter;\n\n    for (String f : fields) {\n      try {\n        getFacetDateCounts(f, resOuter);\n      } catch (Exception e) {\n        String msg = \"Exception during facet.date of \" + f;\n        SolrException.logOnce(SolrCore.log, msg, e);\n        addException(msg , e);\n      }\n    }\n\n    return resOuter;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n\n  public NamedList getFacetDateCounts()\n    throws IOException, ParseException {\n\n    final NamedList resOuter = new SimpleOrderedMap();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n\n    if (null == fields || 0 == fields.length) return resOuter;\n\n    for (String f : fields) {\n      try {\n        getFacetDateCounts(f, resOuter);\n      } catch (Exception e) {\n        String msg = \"Exception during facet.date of \" + f;\n        SolrException.logOnce(SolrCore.log, msg, e);\n        addException(msg , e);\n      }\n    }\n\n    return resOuter;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","pathOld":"solr/src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n\n  public NamedList<Object> getFacetDateCounts()\n    throws IOException, ParseException {\n\n    final NamedList<Object> resOuter = new SimpleOrderedMap<Object>();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n\n    if (null == fields || 0 == fields.length) return resOuter;\n\n    for (String f : fields) {\n      try {\n        getFacetDateCounts(f, resOuter);\n      } catch (Exception e) {\n        String msg = \"Exception during facet.date of \" + f;\n        SolrException.logOnce(SolrCore.log, msg, e);\n        addException(msg , e);\n      }\n    }\n\n    return resOuter;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n\n  public NamedList getFacetDateCounts()\n    throws IOException, ParseException {\n\n    final NamedList resOuter = new SimpleOrderedMap();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n\n    if (null == fields || 0 == fields.length) return resOuter;\n\n    for (String f : fields) {\n      try {\n        getFacetDateCounts(f, resOuter);\n      } catch (Exception e) {\n        String msg = \"Exception during facet.date of \" + f;\n        SolrException.logOnce(SolrCore.log, msg, e);\n        addException(msg , e);\n      }\n    }\n\n    return resOuter;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7d7bb9535412b6c4e54c6b24d69b8be3c8a312d","date":1297988062,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","pathOld":"solr/src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   * @deprecated Use getFacetRangeCounts which is more generalized\n   */\n  @Deprecated\n  public NamedList<Object> getFacetDateCounts()\n    throws IOException, ParseException {\n\n    final NamedList<Object> resOuter = new SimpleOrderedMap<Object>();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n\n    if (null == fields || 0 == fields.length) return resOuter;\n\n    for (String f : fields) {\n      try {\n        getFacetDateCounts(f, resOuter);\n      } catch (Exception e) {\n        String msg = \"Exception during facet.date of \" + f;\n        SolrException.logOnce(SolrCore.log, msg, e);\n        addException(msg , e);\n      }\n    }\n\n    return resOuter;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n\n  public NamedList<Object> getFacetDateCounts()\n    throws IOException, ParseException {\n\n    final NamedList<Object> resOuter = new SimpleOrderedMap<Object>();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n\n    if (null == fields || 0 == fields.length) return resOuter;\n\n    for (String f : fields) {\n      try {\n        getFacetDateCounts(f, resOuter);\n      } catch (Exception e) {\n        String msg = \"Exception during facet.date of \" + f;\n        SolrException.logOnce(SolrCore.log, msg, e);\n        addException(msg , e);\n      }\n    }\n\n    return resOuter;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f1bdbf92da222965b46c0a942c3857ba56e5c638","date":1298297608,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","pathOld":"solr/src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   * @deprecated Use getFacetRangeCounts which is more generalized\n   */\n  @Deprecated\n  public NamedList<Object> getFacetDateCounts()\n    throws IOException, ParseException {\n\n    final NamedList<Object> resOuter = new SimpleOrderedMap<Object>();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n\n    if (null == fields || 0 == fields.length) return resOuter;\n\n    for (String f : fields) {\n      try {\n        getFacetDateCounts(f, resOuter);\n      } catch (Exception e) {\n        String msg = \"Exception during facet.date of \" + f;\n        SolrException.logOnce(SolrCore.log, msg, e);\n        addException(msg , e);\n      }\n    }\n\n    return resOuter;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n\n  public NamedList<Object> getFacetDateCounts()\n    throws IOException, ParseException {\n\n    final NamedList<Object> resOuter = new SimpleOrderedMap<Object>();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n\n    if (null == fields || 0 == fields.length) return resOuter;\n\n    for (String f : fields) {\n      try {\n        getFacetDateCounts(f, resOuter);\n      } catch (Exception e) {\n        String msg = \"Exception during facet.date of \" + f;\n        SolrException.logOnce(SolrCore.log, msg, e);\n        addException(msg , e);\n      }\n    }\n\n    return resOuter;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","pathOld":"solr/src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   * @deprecated Use getFacetRangeCounts which is more generalized\n   */\n  @Deprecated\n  public NamedList<Object> getFacetDateCounts()\n    throws IOException, ParseException {\n\n    final NamedList<Object> resOuter = new SimpleOrderedMap<Object>();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n\n    if (null == fields || 0 == fields.length) return resOuter;\n\n    for (String f : fields) {\n      try {\n        getFacetDateCounts(f, resOuter);\n      } catch (Exception e) {\n        String msg = \"Exception during facet.date of \" + f;\n        SolrException.logOnce(SolrCore.log, msg, e);\n        addException(msg , e);\n      }\n    }\n\n    return resOuter;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   */\n\n  public NamedList<Object> getFacetDateCounts()\n    throws IOException, ParseException {\n\n    final NamedList<Object> resOuter = new SimpleOrderedMap<Object>();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n\n    if (null == fields || 0 == fields.length) return resOuter;\n\n    for (String f : fields) {\n      try {\n        getFacetDateCounts(f, resOuter);\n      } catch (Exception e) {\n        String msg = \"Exception during facet.date of \" + f;\n        SolrException.logOnce(SolrCore.log, msg, e);\n        addException(msg , e);\n      }\n    }\n\n    return resOuter;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","pathOld":"solr/src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   * @deprecated Use getFacetRangeCounts which is more generalized\n   */\n  @Deprecated\n  public NamedList<Object> getFacetDateCounts()\n    throws IOException, ParseException {\n\n    final NamedList<Object> resOuter = new SimpleOrderedMap<Object>();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n\n    if (null == fields || 0 == fields.length) return resOuter;\n\n    for (String f : fields) {\n      try {\n        getFacetDateCounts(f, resOuter);\n      } catch (Exception e) {\n        String msg = \"Exception during facet.date of \" + f;\n        SolrException.logOnce(SolrCore.log, msg, e);\n        addException(msg , e);\n      }\n    }\n\n    return resOuter;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   * @deprecated Use getFacetRangeCounts which is more generalized\n   */\n  @Deprecated\n  public NamedList<Object> getFacetDateCounts()\n    throws IOException, ParseException {\n\n    final NamedList<Object> resOuter = new SimpleOrderedMap<Object>();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n\n    if (null == fields || 0 == fields.length) return resOuter;\n\n    for (String f : fields) {\n      try {\n        getFacetDateCounts(f, resOuter);\n      } catch (Exception e) {\n        String msg = \"Exception during facet.date of \" + f;\n        SolrException.logOnce(SolrCore.log, msg, e);\n        addException(msg , e);\n      }\n    }\n\n    return resOuter;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","pathOld":"solr/src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   * @deprecated Use getFacetRangeCounts which is more generalized\n   */\n  @Deprecated\n  public NamedList<Object> getFacetDateCounts()\n    throws IOException, ParseException {\n\n    final NamedList<Object> resOuter = new SimpleOrderedMap<Object>();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n\n    if (null == fields || 0 == fields.length) return resOuter;\n\n    for (String f : fields) {\n      try {\n        getFacetDateCounts(f, resOuter);\n      } catch (Exception e) {\n        String msg = \"Exception during facet.date of \" + f;\n        SolrException.logOnce(SolrCore.log, msg, e);\n        addException(msg , e);\n      }\n    }\n\n    return resOuter;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   * @deprecated Use getFacetRangeCounts which is more generalized\n   */\n  @Deprecated\n  public NamedList<Object> getFacetDateCounts()\n    throws IOException, ParseException {\n\n    final NamedList<Object> resOuter = new SimpleOrderedMap<Object>();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n\n    if (null == fields || 0 == fields.length) return resOuter;\n\n    for (String f : fields) {\n      try {\n        getFacetDateCounts(f, resOuter);\n      } catch (Exception e) {\n        String msg = \"Exception during facet.date of \" + f;\n        SolrException.logOnce(SolrCore.log, msg, e);\n        addException(msg , e);\n      }\n    }\n\n    return resOuter;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","pathOld":"solr/src/java/org/apache/solr/request/SimpleFacets#getFacetDateCounts().mjava","sourceNew":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   * @deprecated Use getFacetRangeCounts which is more generalized\n   */\n  @Deprecated\n  public NamedList<Object> getFacetDateCounts()\n    throws IOException, ParseException {\n\n    final NamedList<Object> resOuter = new SimpleOrderedMap<Object>();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n\n    if (null == fields || 0 == fields.length) return resOuter;\n\n    for (String f : fields) {\n      try {\n        getFacetDateCounts(f, resOuter);\n      } catch (Exception e) {\n        String msg = \"Exception during facet.date of \" + f;\n        SolrException.logOnce(SolrCore.log, msg, e);\n        addException(msg , e);\n      }\n    }\n\n    return resOuter;\n  }\n\n","sourceOld":"  /**\n   * Returns a list of value constraints and the associated facet counts \n   * for each facet date field, range, and interval specified in the\n   * SolrParams\n   *\n   * @see FacetParams#FACET_DATE\n   * @deprecated Use getFacetRangeCounts which is more generalized\n   */\n  @Deprecated\n  public NamedList<Object> getFacetDateCounts()\n    throws IOException, ParseException {\n\n    final NamedList<Object> resOuter = new SimpleOrderedMap<Object>();\n    final String[] fields = params.getParams(FacetParams.FACET_DATE);\n\n    if (null == fields || 0 == fields.length) return resOuter;\n\n    for (String f : fields) {\n      try {\n        getFacetDateCounts(f, resOuter);\n      } catch (Exception e) {\n        String msg = \"Exception during facet.date of \" + f;\n        SolrException.logOnce(SolrCore.log, msg, e);\n        addException(msg , e);\n      }\n    }\n\n    return resOuter;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ef02613bb5b67b98ca5caf41e8d6e016a0158923":["432127b09840b2b70209e404d242e7029421ef0a"],"f1bdbf92da222965b46c0a942c3857ba56e5c638":["29ef99d61cda9641b6250bf9567329a6e65f901d","e7d7bb9535412b6c4e54c6b24d69b8be3c8a312d"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"c26f00b574427b55127e869b935845554afde1fa":["e7d7bb9535412b6c4e54c6b24d69b8be3c8a312d","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"432127b09840b2b70209e404d242e7029421ef0a":["870336f01c94cf29d0cc6d2824875c7c813b2aec"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["870336f01c94cf29d0cc6d2824875c7c813b2aec","ef02613bb5b67b98ca5caf41e8d6e016a0158923"],"1da8d55113b689b06716246649de6f62430f15c0":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","ad94625fb8d088209f46650c8097196fec67f00c"],"870336f01c94cf29d0cc6d2824875c7c813b2aec":["1da8d55113b689b06716246649de6f62430f15c0"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["e7d7bb9535412b6c4e54c6b24d69b8be3c8a312d"],"e7d7bb9535412b6c4e54c6b24d69b8be3c8a312d":["755f2f419306d7297c8feee10d1897addf4b2dd0"],"755f2f419306d7297c8feee10d1897addf4b2dd0":["ef02613bb5b67b98ca5caf41e8d6e016a0158923"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["ef02613bb5b67b98ca5caf41e8d6e016a0158923","755f2f419306d7297c8feee10d1897addf4b2dd0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":["e7d7bb9535412b6c4e54c6b24d69b8be3c8a312d"],"ad94625fb8d088209f46650c8097196fec67f00c":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","755f2f419306d7297c8feee10d1897addf4b2dd0"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["868da859b43505d9d2a023bfeae6dd0c795f5295","e7d7bb9535412b6c4e54c6b24d69b8be3c8a312d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"]},"commit2Childs":{"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"],"ef02613bb5b67b98ca5caf41e8d6e016a0158923":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","755f2f419306d7297c8feee10d1897addf4b2dd0","29ef99d61cda9641b6250bf9567329a6e65f901d"],"f1bdbf92da222965b46c0a942c3857ba56e5c638":[],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["1da8d55113b689b06716246649de6f62430f15c0"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["ad94625fb8d088209f46650c8097196fec67f00c"],"432127b09840b2b70209e404d242e7029421ef0a":["ef02613bb5b67b98ca5caf41e8d6e016a0158923"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["868da859b43505d9d2a023bfeae6dd0c795f5295"],"1da8d55113b689b06716246649de6f62430f15c0":["870336f01c94cf29d0cc6d2824875c7c813b2aec"],"870336f01c94cf29d0cc6d2824875c7c813b2aec":["432127b09840b2b70209e404d242e7029421ef0a","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["f1bdbf92da222965b46c0a942c3857ba56e5c638"],"e7d7bb9535412b6c4e54c6b24d69b8be3c8a312d":["f1bdbf92da222965b46c0a942c3857ba56e5c638","c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"755f2f419306d7297c8feee10d1897addf4b2dd0":["e7d7bb9535412b6c4e54c6b24d69b8be3c8a312d","29ef99d61cda9641b6250bf9567329a6e65f901d","868da859b43505d9d2a023bfeae6dd0c795f5295"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"ad94625fb8d088209f46650c8097196fec67f00c":["1da8d55113b689b06716246649de6f62430f15c0"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["f1bdbf92da222965b46c0a942c3857ba56e5c638","a258fbb26824fd104ed795e5d9033d2d040049ee","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}