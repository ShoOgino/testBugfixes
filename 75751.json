{"path":"lucene/facet/src/test/org/apache/lucene/facet/simple/TestSimpleDrillSideways#testRandom().mjava","commits":[{"id":"19f5022544a8fc895776356d1b35a4b46d05945c","date":1385063323,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/simple/TestSimpleDrillSideways#testRandom().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    // nocommit\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s = _TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomSimpleString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n    DocumentBuilder builder = new DocumentBuilder(tw, config);\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(builder.build(doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      SimpleDrillDownQuery ddq = new SimpleDrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new SimpleDrillSideways(s, config, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new SimpleDrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      SimpleTestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      // nocommit subclass & override to use FacetsTestCase.getFacetCounts\n      SimpleDrillSideways ds;\n      if (doUseDV) {\n        ds = new SimpleDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new SimpleDrillSideways(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      SimpleDrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    IOUtils.close(r, tr, w, tw, d, td);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["402ad3ddc9da7b70da1b167667a60ece6a1381fb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ce7aff7772c162c15d520e31af46c555f60d5c3b","date":1385135519,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/simple/TestSimpleDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/simple/TestSimpleDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s = _TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomSimpleString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n    DocumentBuilder builder = new DocumentBuilder(tw, config);\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(builder.build(doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      SimpleDrillDownQuery ddq = new SimpleDrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new SimpleDrillSideways(s, config, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new SimpleDrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      SimpleTestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      // nocommit subclass & override to use FacetsTestCase.getFacetCounts\n      SimpleDrillSideways ds;\n      if (doUseDV) {\n        ds = new SimpleDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new SimpleDrillSideways(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      SimpleDrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    IOUtils.close(r, tr, w, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    // nocommit\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s = _TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomSimpleString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n    DocumentBuilder builder = new DocumentBuilder(tw, config);\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(builder.build(doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      SimpleDrillDownQuery ddq = new SimpleDrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new SimpleDrillSideways(s, config, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new SimpleDrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      SimpleTestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      // nocommit subclass & override to use FacetsTestCase.getFacetCounts\n      SimpleDrillSideways ds;\n      if (doUseDV) {\n        ds = new SimpleDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new SimpleDrillSideways(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      SimpleDrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    IOUtils.close(r, tr, w, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae75def1e2525383b6e1397ed97c44387da9941c","date":1385249238,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/simple/TestSimpleDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/simple/TestSimpleDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s = _TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomSimpleString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig(tw);\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      SimpleDrillDownQuery ddq = new SimpleDrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new SimpleDrillSideways(s, config, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new SimpleDrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      SimpleTestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      // nocommit subclass & override to use FacetsTestCase.getFacetCounts\n      SimpleDrillSideways ds;\n      if (doUseDV) {\n        ds = new SimpleDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new SimpleDrillSideways(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      SimpleDrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    IOUtils.close(r, tr, w, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s = _TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomSimpleString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig();\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n    DocumentBuilder builder = new DocumentBuilder(tw, config);\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(builder.build(doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      SimpleDrillDownQuery ddq = new SimpleDrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new SimpleDrillSideways(s, config, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new SimpleDrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      SimpleTestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      // nocommit subclass & override to use FacetsTestCase.getFacetCounts\n      SimpleDrillSideways ds;\n      if (doUseDV) {\n        ds = new SimpleDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new SimpleDrillSideways(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      SimpleDrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    IOUtils.close(r, tr, w, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"21d36d0db865f7b84026b447bec653469a6e66df","date":1385495602,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways#testRandom().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/simple/TestSimpleDrillSideways#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s = _TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig(tw);\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      DrillDownQuery ddq = new DrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new DrillSideways(s, config, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new DrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      TestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      // nocommit subclass & override to use FacetsTestCase.getFacetCounts\n      DrillSideways ds;\n      if (doUseDV) {\n        ds = new DrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new DrillSideways(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    IOUtils.close(r, tr, w, tw, d, td);\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n\n    boolean canUseDV = defaultCodecSupportsSortedSet();\n\n    while (aChance == 0.0) {\n      aChance = random().nextDouble();\n    }\n    while (bChance == 0.0) {\n      bChance = random().nextDouble();\n    }\n    while (cChance == 0.0) {\n      cChance = random().nextDouble();\n    }\n    //aChance = .01;\n    //bChance = 0.5;\n    //cChance = 1.0;\n    double sum = aChance + bChance + cChance;\n    aChance /= sum;\n    bChance /= sum;\n    cChance /= sum;\n\n    int numDims = _TestUtil.nextInt(random(), 2, 5);\n    //int numDims = 3;\n    int numDocs = atLeast(3000);\n    //int numDocs = 20;\n    if (VERBOSE) {\n      System.out.println(\"numDims=\" + numDims + \" numDocs=\" + numDocs + \" aChance=\" + aChance + \" bChance=\" + bChance + \" cChance=\" + cChance);\n    }\n    String[][] dimValues = new String[numDims][];\n    int valueCount = 2;\n\n    for(int dim=0;dim<numDims;dim++) {\n      Set<String> values = new HashSet<String>();\n      while (values.size() < valueCount) {\n        String s = _TestUtil.randomRealisticUnicodeString(random());\n        //String s = _TestUtil.randomSimpleString(random());\n        if (s.length() > 0) {\n          values.add(s);\n        }\n      } \n      dimValues[dim] = values.toArray(new String[values.size()]);\n      valueCount *= 2;\n    }\n\n    List<Doc> docs = new ArrayList<Doc>();\n    for(int i=0;i<numDocs;i++) {\n      Doc doc = new Doc();\n      doc.id = \"\"+i;\n      doc.contentToken = randomContentToken(false);\n      doc.dims = new int[numDims];\n      doc.dims2 = new int[numDims];\n      for(int dim=0;dim<numDims;dim++) {\n        if (random().nextInt(5) == 3) {\n          // This doc is missing this dim:\n          doc.dims[dim] = -1;\n        } else if (dimValues[dim].length <= 4) {\n          int dimUpto = 0;\n          doc.dims[dim] = dimValues[dim].length-1;\n          while (dimUpto < dimValues[dim].length) {\n            if (random().nextBoolean()) {\n              doc.dims[dim] = dimUpto;\n              break;\n            }\n            dimUpto++;\n          }\n        } else {\n          doc.dims[dim] = random().nextInt(dimValues[dim].length);\n        }\n\n        if (random().nextInt(5) == 3) {\n          // 2nd value:\n          doc.dims2[dim] = random().nextInt(dimValues[dim].length);\n        } else {\n          doc.dims2[dim] = -1;\n        }\n      }\n      docs.add(doc);\n    }\n\n    Directory d = newDirectory();\n    Directory td = newDirectory();\n\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    iwc.setInfoStream(InfoStream.NO_OUTPUT);\n    RandomIndexWriter w = new RandomIndexWriter(random(), d, iwc);\n    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(td, IndexWriterConfig.OpenMode.CREATE);\n    FacetsConfig config = new FacetsConfig(tw);\n    for(int i=0;i<numDims;i++) {\n      config.setMultiValued(\"dim\"+i, true);\n    }\n\n    boolean doUseDV = canUseDV && random().nextBoolean();\n\n    for(Doc rawDoc : docs) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", rawDoc.id, Field.Store.YES));\n      doc.add(newStringField(\"content\", rawDoc.contentToken, Field.Store.NO));\n\n      if (VERBOSE) {\n        System.out.println(\"  doc id=\" + rawDoc.id + \" token=\" + rawDoc.contentToken);\n      }\n      for(int dim=0;dim<numDims;dim++) {\n        int dimValue = rawDoc.dims[dim];\n        if (dimValue != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"    dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue]));\n          }\n        }\n        int dimValue2 = rawDoc.dims2[dim];\n        if (dimValue2 != -1) {\n          if (doUseDV) {\n            doc.add(new SortedSetDocValuesFacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          } else {\n            doc.add(new FacetField(\"dim\" + dim, dimValues[dim][dimValue2]));\n          }\n          doc.add(new StringField(\"dim\" + dim, dimValues[dim][dimValue2], Field.Store.YES));\n          if (VERBOSE) {\n            System.out.println(\"      dim\" + dim + \"=\" + new BytesRef(dimValues[dim][dimValue2]));\n          }\n        }\n      }\n\n      w.addDocument(config.build(doc));\n    }\n\n    if (random().nextBoolean()) {\n      // Randomly delete a few docs:\n      int numDel = _TestUtil.nextInt(random(), 1, (int) (numDocs*0.05));\n      if (VERBOSE) {\n        System.out.println(\"delete \" + numDel);\n      }\n      int delCount = 0;\n      while (delCount < numDel) {\n        Doc doc = docs.get(random().nextInt(docs.size()));\n        if (!doc.deleted) {\n          if (VERBOSE) {\n            System.out.println(\"  delete id=\" + doc.id);\n          }\n          doc.deleted = true;\n          w.deleteDocuments(new Term(\"id\", doc.id));\n          delCount++;\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: forceMerge(1)...\");\n      }\n      w.forceMerge(1);\n    }\n    IndexReader r = w.getReader();\n\n    final SortedSetDocValuesReaderState sortedSetDVState;\n    IndexSearcher s = newSearcher(r);\n    \n    if (doUseDV) {\n      sortedSetDVState = new SortedSetDocValuesReaderState(s.getIndexReader());\n    } else {\n      sortedSetDVState = null;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"r.numDocs() = \" + r.numDocs());\n    }\n\n    // NRT open\n    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);\n\n    int numIters = atLeast(10);\n\n    for(int iter=0;iter<numIters;iter++) {\n\n      String contentToken = random().nextInt(30) == 17 ? null : randomContentToken(true);\n      int numDrillDown = _TestUtil.nextInt(random(), 1, Math.min(4, numDims));\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" baseQuery=\" + contentToken + \" numDrillDown=\" + numDrillDown + \" useSortedSetDV=\" + doUseDV);\n      }\n\n      String[][] drillDowns = new String[numDims][];\n\n      int count = 0;\n      boolean anyMultiValuedDrillDowns = false;\n      while (count < numDrillDown) {\n        int dim = random().nextInt(numDims);\n        if (drillDowns[dim] == null) {\n          if (random().nextBoolean()) {\n            // Drill down on one value:\n            drillDowns[dim] = new String[] {dimValues[dim][random().nextInt(dimValues[dim].length)]};\n          } else {\n            int orCount = _TestUtil.nextInt(random(), 1, Math.min(5, dimValues[dim].length));\n            drillDowns[dim] = new String[orCount];\n            anyMultiValuedDrillDowns |= orCount > 1;\n            for(int i=0;i<orCount;i++) {\n              while (true) {\n                String value = dimValues[dim][random().nextInt(dimValues[dim].length)];\n                for(int j=0;j<i;j++) {\n                  if (value.equals(drillDowns[dim][j])) {\n                    value = null;\n                    break;\n                  }\n                }\n                if (value != null) {\n                  drillDowns[dim][i] = value;\n                  break;\n                }\n              }\n            }\n          }\n          if (VERBOSE) {\n            BytesRef[] values = new BytesRef[drillDowns[dim].length];\n            for(int i=0;i<values.length;i++) {\n              values[i] = new BytesRef(drillDowns[dim][i]);\n            }\n            System.out.println(\"  dim\" + dim + \"=\" + Arrays.toString(values));\n          }\n          count++;\n        }\n      }\n\n      Query baseQuery;\n      if (contentToken == null) {\n        baseQuery = new MatchAllDocsQuery();\n      } else {\n        baseQuery = new TermQuery(new Term(\"content\", contentToken));\n      }\n\n      SimpleDrillDownQuery ddq = new SimpleDrillDownQuery(config, baseQuery);\n\n      for(int dim=0;dim<numDims;dim++) {\n        if (drillDowns[dim] != null) {\n          int upto = 0;\n          for(String value : drillDowns[dim]) {\n            ddq.add(\"dim\" + dim, value);\n          }\n        }\n      }\n\n      Filter filter;\n      if (random().nextInt(7) == 6) {\n        if (VERBOSE) {\n          System.out.println(\"  only-even filter\");\n        }\n        filter = new Filter() {\n            @Override\n            public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {\n              int maxDoc = context.reader().maxDoc();\n              final FixedBitSet bits = new FixedBitSet(maxDoc);\n              for(int docID=0;docID < maxDoc;docID++) {\n                // Keeps only the even ids:\n                if ((acceptDocs == null || acceptDocs.get(docID)) && ((Integer.parseInt(context.reader().document(docID).get(\"id\")) & 1) == 0)) {\n                  bits.set(docID);\n                }\n              }\n              return bits;\n            }\n          };\n      } else {\n        filter = null;\n      }\n\n      // Verify docs are always collected in order.  If we\n      // had an AssertingScorer it could catch it when\n      // Weight.scoresDocsOutOfOrder lies!:\n      new SimpleDrillSideways(s, config, tr).search(ddq,\n                           new Collector() {\n                             int lastDocID;\n\n                             @Override\n                             public void setScorer(Scorer s) {\n                             }\n\n                             @Override\n                             public void collect(int doc) {\n                               assert doc > lastDocID;\n                               lastDocID = doc;\n                             }\n\n                             @Override\n                             public void setNextReader(AtomicReaderContext context) {\n                               lastDocID = -1;\n                             }\n\n                             @Override\n                             public boolean acceptsDocsOutOfOrder() {\n                               return false;\n                             }\n                           });\n\n      // Also separately verify that DS respects the\n      // scoreSubDocsAtOnce method, to ensure that all\n      // subScorers are on the same docID:\n      if (!anyMultiValuedDrillDowns) {\n        // Can only do this test when there are no OR'd\n        // drill-down values, beacuse in that case it's\n        // easily possible for one of the DD terms to be on\n        // a future docID:\n        new SimpleDrillSideways(s, config, tr) {\n          @Override\n          protected boolean scoreSubDocsAtOnce() {\n            return true;\n          }\n        }.search(ddq, new AssertingSubDocsAtOnceCollector());\n      }\n\n      SimpleTestFacetResult expected = slowDrillSidewaysSearch(s, docs, contentToken, drillDowns, dimValues, filter);\n\n      Sort sort = new Sort(new SortField(\"id\", SortField.Type.STRING));\n      // nocommit subclass & override to use FacetsTestCase.getFacetCounts\n      SimpleDrillSideways ds;\n      if (doUseDV) {\n        ds = new SimpleDrillSideways(s, config, sortedSetDVState);\n      } else {\n        ds = new SimpleDrillSideways(s, config, tr);\n      }\n\n      // Retrieve all facets:\n      SimpleDrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);\n\n      TopDocs hits = s.search(baseQuery, numDocs);\n      Map<String,Float> scores = new HashMap<String,Float>();\n      for(ScoreDoc sd : hits.scoreDocs) {\n        scores.put(s.doc(sd.doc).get(\"id\"), sd.score);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  verify all facets\");\n      }\n      verifyEquals(dimValues, s, expected, actual, scores, doUseDV);\n\n      // Make sure drill down doesn't change score:\n      TopDocs ddqHits = s.search(ddq, filter, numDocs);\n      assertEquals(expected.hits.size(), ddqHits.totalHits);\n      for(int i=0;i<expected.hits.size();i++) {\n        // Score should be IDENTICAL:\n        assertEquals(scores.get(expected.hits.get(i).id), ddqHits.scoreDocs[i].score, 0.0f);\n      }\n    }\n\n    IOUtils.close(r, tr, w, tw, d, td);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"19f5022544a8fc895776356d1b35a4b46d05945c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"21d36d0db865f7b84026b447bec653469a6e66df":["ae75def1e2525383b6e1397ed97c44387da9941c"],"ce7aff7772c162c15d520e31af46c555f60d5c3b":["19f5022544a8fc895776356d1b35a4b46d05945c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ae75def1e2525383b6e1397ed97c44387da9941c":["ce7aff7772c162c15d520e31af46c555f60d5c3b"]},"commit2Childs":{"19f5022544a8fc895776356d1b35a4b46d05945c":["ce7aff7772c162c15d520e31af46c555f60d5c3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["19f5022544a8fc895776356d1b35a4b46d05945c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"21d36d0db865f7b84026b447bec653469a6e66df":[],"ce7aff7772c162c15d520e31af46c555f60d5c3b":["ae75def1e2525383b6e1397ed97c44387da9941c"],"ae75def1e2525383b6e1397ed97c44387da9941c":["21d36d0db865f7b84026b447bec653469a6e66df"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["21d36d0db865f7b84026b447bec653469a6e66df","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}