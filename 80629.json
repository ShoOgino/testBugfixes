{"path":"solr/core/src/java/org/apache/solr/schema/JsonPreAnalyzedParser#parse(Reader,AttributeSource).mjava","commits":[{"id":"232d48b2fd10ac5189a0ac4480ace7421be9de93","date":1334848212,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/JsonPreAnalyzedParser#parse(Reader,AttributeSource).mjava","pathOld":"/dev/null","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  @Override\n  public ParseResult parse(Reader reader, AttributeSource parent)\n      throws IOException {\n    ParseResult res = new ParseResult();\n    StringBuilder sb = new StringBuilder();\n    char[] buf = new char[128];\n    int cnt;\n    while ((cnt = reader.read(buf)) > 0) {\n      sb.append(buf, 0, cnt);\n    }\n    String val = sb.toString();\n    // empty string - accept even without version number\n    if (val.length() == 0) {\n      return res;\n    }\n    Object o = ObjectBuilder.fromJSON(val);\n    if (!(o instanceof Map)) {\n      throw new IOException(\"Invalid JSON type \" + o.getClass().getName() + \", expected Map\");\n    }\n    Map<String,Object> map = (Map<String,Object>)o;\n    // check version\n    String version = (String)map.get(VERSION_KEY);\n    if (version == null) {\n      throw new IOException(\"Missing VERSION key\");\n    }\n    if (!VERSION.equals(version)) {\n      throw new IOException(\"Unknown VERSION '\" + version + \"', expected \" + VERSION);\n    }\n    if (map.containsKey(STRING_KEY) && map.containsKey(BINARY_KEY)) {\n      throw new IOException(\"Field cannot have both stringValue and binaryValue\");\n    }\n    res.str = (String)map.get(STRING_KEY);\n    String bin = (String)map.get(BINARY_KEY);\n    if (bin != null) {\n      byte[] data = Base64.base64ToByteArray(bin);\n      res.bin = data;\n    }\n    List<Object> tokens = (List<Object>)map.get(TOKENS_KEY);\n    if (tokens == null) {\n      return res;\n    }\n    int tokenStart = 0;\n    int tokenEnd = 0;\n    parent.clearAttributes();\n    for (Object ot : tokens) {\n      tokenStart = tokenEnd + 1; // automatic increment by 1 separator\n      Map<String,Object> tok = (Map<String,Object>)ot;\n      boolean hasOffsetStart = false;\n      boolean hasOffsetEnd = false;\n      int len = -1;\n      for (Entry<String,Object> e : tok.entrySet()) {\n        String key = e.getKey();\n        if (key.equals(TOKEN_KEY)) {\n          CharTermAttribute catt = parent.addAttribute(CharTermAttribute.class);\n          String str = String.valueOf(e.getValue());\n          catt.append(str);\n          len = str.length();\n        } else if (key.equals(OFFSET_START_KEY)) {\n          Object obj = e.getValue();\n          hasOffsetStart = true;\n          if (obj instanceof Number) {\n            tokenStart = ((Number)obj).intValue();\n          } else {\n            try {\n              tokenStart = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              LOG.warn(\"Invalid \" + OFFSET_START_KEY + \" attribute, skipped: '\" + obj + \"'\");\n              hasOffsetStart = false;\n            }\n          }\n        } else if (key.equals(OFFSET_END_KEY)) {\n          hasOffsetEnd = true;\n          Object obj = e.getValue();\n          if (obj instanceof Number) {\n            tokenEnd = ((Number)obj).intValue();\n          } else {\n            try {\n              tokenEnd = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              LOG.warn(\"Invalid \" + OFFSET_END_KEY + \" attribute, skipped: '\" + obj + \"'\");\n              hasOffsetEnd = false;\n            }\n          }\n        } else if (key.equals(POSINCR_KEY)) {\n          Object obj = e.getValue();\n          int posIncr = 1;\n          if (obj instanceof Number) {\n            posIncr = ((Number)obj).intValue();\n          } else {\n            try {\n              posIncr = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              LOG.warn(\"Invalid \" + POSINCR_KEY + \" attribute, skipped: '\" + obj + \"'\");\n            }\n          }\n          PositionIncrementAttribute patt = parent.addAttribute(PositionIncrementAttribute.class);\n          patt.setPositionIncrement(posIncr);\n        } else if (key.equals(PAYLOAD_KEY)) {\n          String str = String.valueOf(e.getValue());\n          if (str.length() > 0) {\n            byte[] data = Base64.base64ToByteArray(str);\n            PayloadAttribute p = parent.addAttribute(PayloadAttribute.class);\n            if (data != null && data.length > 0) {\n              p.setPayload(new Payload(data));\n            }\n          }\n        } else if (key.equals(FLAGS_KEY)) {\n          try {\n            int f = Integer.parseInt(String.valueOf(e.getValue()), 16);\n            FlagsAttribute flags = parent.addAttribute(FlagsAttribute.class);\n            flags.setFlags(f);\n          } catch (NumberFormatException nfe) {\n            LOG.warn(\"Invalid \" + FLAGS_KEY + \" attribute, skipped: '\" + e.getValue() + \"'\");            \n          }\n        } else if (key.equals(TYPE_KEY)) {\n          TypeAttribute tattr = parent.addAttribute(TypeAttribute.class);\n          tattr.setType(String.valueOf(e.getValue()));\n        } else {\n          LOG.warn(\"Unknown attribute, skipped: \" + e.getKey() + \"=\" + e.getValue());\n        }\n      }\n      // handle offset attr\n      OffsetAttribute offset = parent.addAttribute(OffsetAttribute.class);\n      if (!hasOffsetEnd && len > -1) {\n        tokenEnd = tokenStart + len;\n      }\n      offset.setOffset(tokenStart, tokenEnd);\n      if (!hasOffsetStart) {\n        tokenStart = tokenEnd + 1;\n      }\n      // capture state and add to result\n      State state = parent.captureState();\n      res.states.add(state.clone());\n      // reset for reuse\n      parent.clearAttributes();\n    }\n    return res;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"76fa9933adb0556e752e8af9734c4d0ae14622ff","date":1339178321,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/JsonPreAnalyzedParser#parse(Reader,AttributeSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/JsonPreAnalyzedParser#parse(Reader,AttributeSource).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  @Override\n  public ParseResult parse(Reader reader, AttributeSource parent)\n      throws IOException {\n    ParseResult res = new ParseResult();\n    StringBuilder sb = new StringBuilder();\n    char[] buf = new char[128];\n    int cnt;\n    while ((cnt = reader.read(buf)) > 0) {\n      sb.append(buf, 0, cnt);\n    }\n    String val = sb.toString();\n    // empty string - accept even without version number\n    if (val.length() == 0) {\n      return res;\n    }\n    Object o = ObjectBuilder.fromJSON(val);\n    if (!(o instanceof Map)) {\n      throw new IOException(\"Invalid JSON type \" + o.getClass().getName() + \", expected Map\");\n    }\n    Map<String,Object> map = (Map<String,Object>)o;\n    // check version\n    String version = (String)map.get(VERSION_KEY);\n    if (version == null) {\n      throw new IOException(\"Missing VERSION key\");\n    }\n    if (!VERSION.equals(version)) {\n      throw new IOException(\"Unknown VERSION '\" + version + \"', expected \" + VERSION);\n    }\n    if (map.containsKey(STRING_KEY) && map.containsKey(BINARY_KEY)) {\n      throw new IOException(\"Field cannot have both stringValue and binaryValue\");\n    }\n    res.str = (String)map.get(STRING_KEY);\n    String bin = (String)map.get(BINARY_KEY);\n    if (bin != null) {\n      byte[] data = Base64.base64ToByteArray(bin);\n      res.bin = data;\n    }\n    List<Object> tokens = (List<Object>)map.get(TOKENS_KEY);\n    if (tokens == null) {\n      return res;\n    }\n    int tokenStart = 0;\n    int tokenEnd = 0;\n    parent.clearAttributes();\n    for (Object ot : tokens) {\n      tokenStart = tokenEnd + 1; // automatic increment by 1 separator\n      Map<String,Object> tok = (Map<String,Object>)ot;\n      boolean hasOffsetStart = false;\n      boolean hasOffsetEnd = false;\n      int len = -1;\n      for (Entry<String,Object> e : tok.entrySet()) {\n        String key = e.getKey();\n        if (key.equals(TOKEN_KEY)) {\n          CharTermAttribute catt = parent.addAttribute(CharTermAttribute.class);\n          String str = String.valueOf(e.getValue());\n          catt.append(str);\n          len = str.length();\n        } else if (key.equals(OFFSET_START_KEY)) {\n          Object obj = e.getValue();\n          hasOffsetStart = true;\n          if (obj instanceof Number) {\n            tokenStart = ((Number)obj).intValue();\n          } else {\n            try {\n              tokenStart = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              LOG.warn(\"Invalid \" + OFFSET_START_KEY + \" attribute, skipped: '\" + obj + \"'\");\n              hasOffsetStart = false;\n            }\n          }\n        } else if (key.equals(OFFSET_END_KEY)) {\n          hasOffsetEnd = true;\n          Object obj = e.getValue();\n          if (obj instanceof Number) {\n            tokenEnd = ((Number)obj).intValue();\n          } else {\n            try {\n              tokenEnd = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              LOG.warn(\"Invalid \" + OFFSET_END_KEY + \" attribute, skipped: '\" + obj + \"'\");\n              hasOffsetEnd = false;\n            }\n          }\n        } else if (key.equals(POSINCR_KEY)) {\n          Object obj = e.getValue();\n          int posIncr = 1;\n          if (obj instanceof Number) {\n            posIncr = ((Number)obj).intValue();\n          } else {\n            try {\n              posIncr = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              LOG.warn(\"Invalid \" + POSINCR_KEY + \" attribute, skipped: '\" + obj + \"'\");\n            }\n          }\n          PositionIncrementAttribute patt = parent.addAttribute(PositionIncrementAttribute.class);\n          patt.setPositionIncrement(posIncr);\n        } else if (key.equals(PAYLOAD_KEY)) {\n          String str = String.valueOf(e.getValue());\n          if (str.length() > 0) {\n            byte[] data = Base64.base64ToByteArray(str);\n            PayloadAttribute p = parent.addAttribute(PayloadAttribute.class);\n            if (data != null && data.length > 0) {\n              p.setPayload(new BytesRef(data));\n            }\n          }\n        } else if (key.equals(FLAGS_KEY)) {\n          try {\n            int f = Integer.parseInt(String.valueOf(e.getValue()), 16);\n            FlagsAttribute flags = parent.addAttribute(FlagsAttribute.class);\n            flags.setFlags(f);\n          } catch (NumberFormatException nfe) {\n            LOG.warn(\"Invalid \" + FLAGS_KEY + \" attribute, skipped: '\" + e.getValue() + \"'\");            \n          }\n        } else if (key.equals(TYPE_KEY)) {\n          TypeAttribute tattr = parent.addAttribute(TypeAttribute.class);\n          tattr.setType(String.valueOf(e.getValue()));\n        } else {\n          LOG.warn(\"Unknown attribute, skipped: \" + e.getKey() + \"=\" + e.getValue());\n        }\n      }\n      // handle offset attr\n      OffsetAttribute offset = parent.addAttribute(OffsetAttribute.class);\n      if (!hasOffsetEnd && len > -1) {\n        tokenEnd = tokenStart + len;\n      }\n      offset.setOffset(tokenStart, tokenEnd);\n      if (!hasOffsetStart) {\n        tokenStart = tokenEnd + 1;\n      }\n      // capture state and add to result\n      State state = parent.captureState();\n      res.states.add(state.clone());\n      // reset for reuse\n      parent.clearAttributes();\n    }\n    return res;\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  @Override\n  public ParseResult parse(Reader reader, AttributeSource parent)\n      throws IOException {\n    ParseResult res = new ParseResult();\n    StringBuilder sb = new StringBuilder();\n    char[] buf = new char[128];\n    int cnt;\n    while ((cnt = reader.read(buf)) > 0) {\n      sb.append(buf, 0, cnt);\n    }\n    String val = sb.toString();\n    // empty string - accept even without version number\n    if (val.length() == 0) {\n      return res;\n    }\n    Object o = ObjectBuilder.fromJSON(val);\n    if (!(o instanceof Map)) {\n      throw new IOException(\"Invalid JSON type \" + o.getClass().getName() + \", expected Map\");\n    }\n    Map<String,Object> map = (Map<String,Object>)o;\n    // check version\n    String version = (String)map.get(VERSION_KEY);\n    if (version == null) {\n      throw new IOException(\"Missing VERSION key\");\n    }\n    if (!VERSION.equals(version)) {\n      throw new IOException(\"Unknown VERSION '\" + version + \"', expected \" + VERSION);\n    }\n    if (map.containsKey(STRING_KEY) && map.containsKey(BINARY_KEY)) {\n      throw new IOException(\"Field cannot have both stringValue and binaryValue\");\n    }\n    res.str = (String)map.get(STRING_KEY);\n    String bin = (String)map.get(BINARY_KEY);\n    if (bin != null) {\n      byte[] data = Base64.base64ToByteArray(bin);\n      res.bin = data;\n    }\n    List<Object> tokens = (List<Object>)map.get(TOKENS_KEY);\n    if (tokens == null) {\n      return res;\n    }\n    int tokenStart = 0;\n    int tokenEnd = 0;\n    parent.clearAttributes();\n    for (Object ot : tokens) {\n      tokenStart = tokenEnd + 1; // automatic increment by 1 separator\n      Map<String,Object> tok = (Map<String,Object>)ot;\n      boolean hasOffsetStart = false;\n      boolean hasOffsetEnd = false;\n      int len = -1;\n      for (Entry<String,Object> e : tok.entrySet()) {\n        String key = e.getKey();\n        if (key.equals(TOKEN_KEY)) {\n          CharTermAttribute catt = parent.addAttribute(CharTermAttribute.class);\n          String str = String.valueOf(e.getValue());\n          catt.append(str);\n          len = str.length();\n        } else if (key.equals(OFFSET_START_KEY)) {\n          Object obj = e.getValue();\n          hasOffsetStart = true;\n          if (obj instanceof Number) {\n            tokenStart = ((Number)obj).intValue();\n          } else {\n            try {\n              tokenStart = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              LOG.warn(\"Invalid \" + OFFSET_START_KEY + \" attribute, skipped: '\" + obj + \"'\");\n              hasOffsetStart = false;\n            }\n          }\n        } else if (key.equals(OFFSET_END_KEY)) {\n          hasOffsetEnd = true;\n          Object obj = e.getValue();\n          if (obj instanceof Number) {\n            tokenEnd = ((Number)obj).intValue();\n          } else {\n            try {\n              tokenEnd = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              LOG.warn(\"Invalid \" + OFFSET_END_KEY + \" attribute, skipped: '\" + obj + \"'\");\n              hasOffsetEnd = false;\n            }\n          }\n        } else if (key.equals(POSINCR_KEY)) {\n          Object obj = e.getValue();\n          int posIncr = 1;\n          if (obj instanceof Number) {\n            posIncr = ((Number)obj).intValue();\n          } else {\n            try {\n              posIncr = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              LOG.warn(\"Invalid \" + POSINCR_KEY + \" attribute, skipped: '\" + obj + \"'\");\n            }\n          }\n          PositionIncrementAttribute patt = parent.addAttribute(PositionIncrementAttribute.class);\n          patt.setPositionIncrement(posIncr);\n        } else if (key.equals(PAYLOAD_KEY)) {\n          String str = String.valueOf(e.getValue());\n          if (str.length() > 0) {\n            byte[] data = Base64.base64ToByteArray(str);\n            PayloadAttribute p = parent.addAttribute(PayloadAttribute.class);\n            if (data != null && data.length > 0) {\n              p.setPayload(new Payload(data));\n            }\n          }\n        } else if (key.equals(FLAGS_KEY)) {\n          try {\n            int f = Integer.parseInt(String.valueOf(e.getValue()), 16);\n            FlagsAttribute flags = parent.addAttribute(FlagsAttribute.class);\n            flags.setFlags(f);\n          } catch (NumberFormatException nfe) {\n            LOG.warn(\"Invalid \" + FLAGS_KEY + \" attribute, skipped: '\" + e.getValue() + \"'\");            \n          }\n        } else if (key.equals(TYPE_KEY)) {\n          TypeAttribute tattr = parent.addAttribute(TypeAttribute.class);\n          tattr.setType(String.valueOf(e.getValue()));\n        } else {\n          LOG.warn(\"Unknown attribute, skipped: \" + e.getKey() + \"=\" + e.getValue());\n        }\n      }\n      // handle offset attr\n      OffsetAttribute offset = parent.addAttribute(OffsetAttribute.class);\n      if (!hasOffsetEnd && len > -1) {\n        tokenEnd = tokenStart + len;\n      }\n      offset.setOffset(tokenStart, tokenEnd);\n      if (!hasOffsetStart) {\n        tokenStart = tokenEnd + 1;\n      }\n      // capture state and add to result\n      State state = parent.captureState();\n      res.states.add(state.clone());\n      // reset for reuse\n      parent.clearAttributes();\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/JsonPreAnalyzedParser#parse(Reader,AttributeSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/JsonPreAnalyzedParser#parse(Reader,AttributeSource).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  @Override\n  public ParseResult parse(Reader reader, AttributeSource parent)\n      throws IOException {\n    ParseResult res = new ParseResult();\n    StringBuilder sb = new StringBuilder();\n    char[] buf = new char[128];\n    int cnt;\n    while ((cnt = reader.read(buf)) > 0) {\n      sb.append(buf, 0, cnt);\n    }\n    String val = sb.toString();\n    // empty string - accept even without version number\n    if (val.length() == 0) {\n      return res;\n    }\n    Object o = ObjectBuilder.fromJSON(val);\n    if (!(o instanceof Map)) {\n      throw new IOException(\"Invalid JSON type \" + o.getClass().getName() + \", expected Map\");\n    }\n    Map<String,Object> map = (Map<String,Object>)o;\n    // check version\n    String version = (String)map.get(VERSION_KEY);\n    if (version == null) {\n      throw new IOException(\"Missing VERSION key\");\n    }\n    if (!VERSION.equals(version)) {\n      throw new IOException(\"Unknown VERSION '\" + version + \"', expected \" + VERSION);\n    }\n    if (map.containsKey(STRING_KEY) && map.containsKey(BINARY_KEY)) {\n      throw new IOException(\"Field cannot have both stringValue and binaryValue\");\n    }\n    res.str = (String)map.get(STRING_KEY);\n    String bin = (String)map.get(BINARY_KEY);\n    if (bin != null) {\n      byte[] data = Base64.base64ToByteArray(bin);\n      res.bin = data;\n    }\n    List<Object> tokens = (List<Object>)map.get(TOKENS_KEY);\n    if (tokens == null) {\n      return res;\n    }\n    int tokenStart = 0;\n    int tokenEnd = 0;\n    parent.clearAttributes();\n    for (Object ot : tokens) {\n      tokenStart = tokenEnd + 1; // automatic increment by 1 separator\n      Map<String,Object> tok = (Map<String,Object>)ot;\n      boolean hasOffsetStart = false;\n      boolean hasOffsetEnd = false;\n      int len = -1;\n      for (Entry<String,Object> e : tok.entrySet()) {\n        String key = e.getKey();\n        if (key.equals(TOKEN_KEY)) {\n          CharTermAttribute catt = parent.addAttribute(CharTermAttribute.class);\n          String str = String.valueOf(e.getValue());\n          catt.append(str);\n          len = str.length();\n        } else if (key.equals(OFFSET_START_KEY)) {\n          Object obj = e.getValue();\n          hasOffsetStart = true;\n          if (obj instanceof Number) {\n            tokenStart = ((Number)obj).intValue();\n          } else {\n            try {\n              tokenStart = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              log.warn(\"Invalid \" + OFFSET_START_KEY + \" attribute, skipped: '\" + obj + \"'\");\n              hasOffsetStart = false;\n            }\n          }\n        } else if (key.equals(OFFSET_END_KEY)) {\n          hasOffsetEnd = true;\n          Object obj = e.getValue();\n          if (obj instanceof Number) {\n            tokenEnd = ((Number)obj).intValue();\n          } else {\n            try {\n              tokenEnd = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              log.warn(\"Invalid \" + OFFSET_END_KEY + \" attribute, skipped: '\" + obj + \"'\");\n              hasOffsetEnd = false;\n            }\n          }\n        } else if (key.equals(POSINCR_KEY)) {\n          Object obj = e.getValue();\n          int posIncr = 1;\n          if (obj instanceof Number) {\n            posIncr = ((Number)obj).intValue();\n          } else {\n            try {\n              posIncr = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              log.warn(\"Invalid \" + POSINCR_KEY + \" attribute, skipped: '\" + obj + \"'\");\n            }\n          }\n          PositionIncrementAttribute patt = parent.addAttribute(PositionIncrementAttribute.class);\n          patt.setPositionIncrement(posIncr);\n        } else if (key.equals(PAYLOAD_KEY)) {\n          String str = String.valueOf(e.getValue());\n          if (str.length() > 0) {\n            byte[] data = Base64.base64ToByteArray(str);\n            PayloadAttribute p = parent.addAttribute(PayloadAttribute.class);\n            if (data != null && data.length > 0) {\n              p.setPayload(new BytesRef(data));\n            }\n          }\n        } else if (key.equals(FLAGS_KEY)) {\n          try {\n            int f = Integer.parseInt(String.valueOf(e.getValue()), 16);\n            FlagsAttribute flags = parent.addAttribute(FlagsAttribute.class);\n            flags.setFlags(f);\n          } catch (NumberFormatException nfe) {\n            log.warn(\"Invalid \" + FLAGS_KEY + \" attribute, skipped: '\" + e.getValue() + \"'\");\n          }\n        } else if (key.equals(TYPE_KEY)) {\n          TypeAttribute tattr = parent.addAttribute(TypeAttribute.class);\n          tattr.setType(String.valueOf(e.getValue()));\n        } else {\n          log.warn(\"Unknown attribute, skipped: \" + e.getKey() + \"=\" + e.getValue());\n        }\n      }\n      // handle offset attr\n      OffsetAttribute offset = parent.addAttribute(OffsetAttribute.class);\n      if (!hasOffsetEnd && len > -1) {\n        tokenEnd = tokenStart + len;\n      }\n      offset.setOffset(tokenStart, tokenEnd);\n      if (!hasOffsetStart) {\n        tokenStart = tokenEnd + 1;\n      }\n      // capture state and add to result\n      State state = parent.captureState();\n      res.states.add(state.clone());\n      // reset for reuse\n      parent.clearAttributes();\n    }\n    return res;\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  @Override\n  public ParseResult parse(Reader reader, AttributeSource parent)\n      throws IOException {\n    ParseResult res = new ParseResult();\n    StringBuilder sb = new StringBuilder();\n    char[] buf = new char[128];\n    int cnt;\n    while ((cnt = reader.read(buf)) > 0) {\n      sb.append(buf, 0, cnt);\n    }\n    String val = sb.toString();\n    // empty string - accept even without version number\n    if (val.length() == 0) {\n      return res;\n    }\n    Object o = ObjectBuilder.fromJSON(val);\n    if (!(o instanceof Map)) {\n      throw new IOException(\"Invalid JSON type \" + o.getClass().getName() + \", expected Map\");\n    }\n    Map<String,Object> map = (Map<String,Object>)o;\n    // check version\n    String version = (String)map.get(VERSION_KEY);\n    if (version == null) {\n      throw new IOException(\"Missing VERSION key\");\n    }\n    if (!VERSION.equals(version)) {\n      throw new IOException(\"Unknown VERSION '\" + version + \"', expected \" + VERSION);\n    }\n    if (map.containsKey(STRING_KEY) && map.containsKey(BINARY_KEY)) {\n      throw new IOException(\"Field cannot have both stringValue and binaryValue\");\n    }\n    res.str = (String)map.get(STRING_KEY);\n    String bin = (String)map.get(BINARY_KEY);\n    if (bin != null) {\n      byte[] data = Base64.base64ToByteArray(bin);\n      res.bin = data;\n    }\n    List<Object> tokens = (List<Object>)map.get(TOKENS_KEY);\n    if (tokens == null) {\n      return res;\n    }\n    int tokenStart = 0;\n    int tokenEnd = 0;\n    parent.clearAttributes();\n    for (Object ot : tokens) {\n      tokenStart = tokenEnd + 1; // automatic increment by 1 separator\n      Map<String,Object> tok = (Map<String,Object>)ot;\n      boolean hasOffsetStart = false;\n      boolean hasOffsetEnd = false;\n      int len = -1;\n      for (Entry<String,Object> e : tok.entrySet()) {\n        String key = e.getKey();\n        if (key.equals(TOKEN_KEY)) {\n          CharTermAttribute catt = parent.addAttribute(CharTermAttribute.class);\n          String str = String.valueOf(e.getValue());\n          catt.append(str);\n          len = str.length();\n        } else if (key.equals(OFFSET_START_KEY)) {\n          Object obj = e.getValue();\n          hasOffsetStart = true;\n          if (obj instanceof Number) {\n            tokenStart = ((Number)obj).intValue();\n          } else {\n            try {\n              tokenStart = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              LOG.warn(\"Invalid \" + OFFSET_START_KEY + \" attribute, skipped: '\" + obj + \"'\");\n              hasOffsetStart = false;\n            }\n          }\n        } else if (key.equals(OFFSET_END_KEY)) {\n          hasOffsetEnd = true;\n          Object obj = e.getValue();\n          if (obj instanceof Number) {\n            tokenEnd = ((Number)obj).intValue();\n          } else {\n            try {\n              tokenEnd = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              LOG.warn(\"Invalid \" + OFFSET_END_KEY + \" attribute, skipped: '\" + obj + \"'\");\n              hasOffsetEnd = false;\n            }\n          }\n        } else if (key.equals(POSINCR_KEY)) {\n          Object obj = e.getValue();\n          int posIncr = 1;\n          if (obj instanceof Number) {\n            posIncr = ((Number)obj).intValue();\n          } else {\n            try {\n              posIncr = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              LOG.warn(\"Invalid \" + POSINCR_KEY + \" attribute, skipped: '\" + obj + \"'\");\n            }\n          }\n          PositionIncrementAttribute patt = parent.addAttribute(PositionIncrementAttribute.class);\n          patt.setPositionIncrement(posIncr);\n        } else if (key.equals(PAYLOAD_KEY)) {\n          String str = String.valueOf(e.getValue());\n          if (str.length() > 0) {\n            byte[] data = Base64.base64ToByteArray(str);\n            PayloadAttribute p = parent.addAttribute(PayloadAttribute.class);\n            if (data != null && data.length > 0) {\n              p.setPayload(new BytesRef(data));\n            }\n          }\n        } else if (key.equals(FLAGS_KEY)) {\n          try {\n            int f = Integer.parseInt(String.valueOf(e.getValue()), 16);\n            FlagsAttribute flags = parent.addAttribute(FlagsAttribute.class);\n            flags.setFlags(f);\n          } catch (NumberFormatException nfe) {\n            LOG.warn(\"Invalid \" + FLAGS_KEY + \" attribute, skipped: '\" + e.getValue() + \"'\");            \n          }\n        } else if (key.equals(TYPE_KEY)) {\n          TypeAttribute tattr = parent.addAttribute(TypeAttribute.class);\n          tattr.setType(String.valueOf(e.getValue()));\n        } else {\n          LOG.warn(\"Unknown attribute, skipped: \" + e.getKey() + \"=\" + e.getValue());\n        }\n      }\n      // handle offset attr\n      OffsetAttribute offset = parent.addAttribute(OffsetAttribute.class);\n      if (!hasOffsetEnd && len > -1) {\n        tokenEnd = tokenStart + len;\n      }\n      offset.setOffset(tokenStart, tokenEnd);\n      if (!hasOffsetStart) {\n        tokenStart = tokenEnd + 1;\n      }\n      // capture state and add to result\n      State state = parent.captureState();\n      res.states.add(state.clone());\n      // reset for reuse\n      parent.clearAttributes();\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61f55b4999c3f858f4f4acc9c6dc57af2c1acf99","date":1571689506,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/JsonPreAnalyzedParser#parse(Reader,AttributeSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/JsonPreAnalyzedParser#parse(Reader,AttributeSource).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  @Override\n  public ParseResult parse(Reader reader, AttributeSource parent)\n      throws IOException {\n    ParseResult res = new ParseResult();\n    StringBuilder sb = new StringBuilder();\n    char[] buf = new char[128];\n    int cnt;\n    while ((cnt = reader.read(buf)) > 0) {\n      sb.append(buf, 0, cnt);\n    }\n    String val = sb.toString();\n    // empty string - accept even without version number\n    if (val.length() == 0) {\n      return res;\n    }\n    Object o = ObjectBuilder.fromJSONStrict(val);\n    if (!(o instanceof Map)) {\n      throw new IOException(\"Invalid JSON type \" + o.getClass().getName() + \", expected Map\");\n    }\n    Map<String,Object> map = (Map<String,Object>)o;\n    // check version\n    String version = (String)map.get(VERSION_KEY);\n    if (version == null) {\n      throw new IOException(\"Missing VERSION key\");\n    }\n    if (!VERSION.equals(version)) {\n      throw new IOException(\"Unknown VERSION '\" + version + \"', expected \" + VERSION);\n    }\n    if (map.containsKey(STRING_KEY) && map.containsKey(BINARY_KEY)) {\n      throw new IOException(\"Field cannot have both stringValue and binaryValue\");\n    }\n    res.str = (String)map.get(STRING_KEY);\n    String bin = (String)map.get(BINARY_KEY);\n    if (bin != null) {\n      byte[] data = Base64.base64ToByteArray(bin);\n      res.bin = data;\n    }\n    List<Object> tokens = (List<Object>)map.get(TOKENS_KEY);\n    if (tokens == null) {\n      return res;\n    }\n    int tokenStart = 0;\n    int tokenEnd = 0;\n    parent.clearAttributes();\n    for (Object ot : tokens) {\n      tokenStart = tokenEnd + 1; // automatic increment by 1 separator\n      Map<String,Object> tok = (Map<String,Object>)ot;\n      boolean hasOffsetStart = false;\n      boolean hasOffsetEnd = false;\n      int len = -1;\n      for (Entry<String,Object> e : tok.entrySet()) {\n        String key = e.getKey();\n        if (key.equals(TOKEN_KEY)) {\n          CharTermAttribute catt = parent.addAttribute(CharTermAttribute.class);\n          String str = String.valueOf(e.getValue());\n          catt.append(str);\n          len = str.length();\n        } else if (key.equals(OFFSET_START_KEY)) {\n          Object obj = e.getValue();\n          hasOffsetStart = true;\n          if (obj instanceof Number) {\n            tokenStart = ((Number)obj).intValue();\n          } else {\n            try {\n              tokenStart = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              log.warn(\"Invalid \" + OFFSET_START_KEY + \" attribute, skipped: '\" + obj + \"'\");\n              hasOffsetStart = false;\n            }\n          }\n        } else if (key.equals(OFFSET_END_KEY)) {\n          hasOffsetEnd = true;\n          Object obj = e.getValue();\n          if (obj instanceof Number) {\n            tokenEnd = ((Number)obj).intValue();\n          } else {\n            try {\n              tokenEnd = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              log.warn(\"Invalid \" + OFFSET_END_KEY + \" attribute, skipped: '\" + obj + \"'\");\n              hasOffsetEnd = false;\n            }\n          }\n        } else if (key.equals(POSINCR_KEY)) {\n          Object obj = e.getValue();\n          int posIncr = 1;\n          if (obj instanceof Number) {\n            posIncr = ((Number)obj).intValue();\n          } else {\n            try {\n              posIncr = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              log.warn(\"Invalid \" + POSINCR_KEY + \" attribute, skipped: '\" + obj + \"'\");\n            }\n          }\n          PositionIncrementAttribute patt = parent.addAttribute(PositionIncrementAttribute.class);\n          patt.setPositionIncrement(posIncr);\n        } else if (key.equals(PAYLOAD_KEY)) {\n          String str = String.valueOf(e.getValue());\n          if (str.length() > 0) {\n            byte[] data = Base64.base64ToByteArray(str);\n            PayloadAttribute p = parent.addAttribute(PayloadAttribute.class);\n            if (data != null && data.length > 0) {\n              p.setPayload(new BytesRef(data));\n            }\n          }\n        } else if (key.equals(FLAGS_KEY)) {\n          try {\n            int f = Integer.parseInt(String.valueOf(e.getValue()), 16);\n            FlagsAttribute flags = parent.addAttribute(FlagsAttribute.class);\n            flags.setFlags(f);\n          } catch (NumberFormatException nfe) {\n            log.warn(\"Invalid \" + FLAGS_KEY + \" attribute, skipped: '\" + e.getValue() + \"'\");\n          }\n        } else if (key.equals(TYPE_KEY)) {\n          TypeAttribute tattr = parent.addAttribute(TypeAttribute.class);\n          tattr.setType(String.valueOf(e.getValue()));\n        } else {\n          log.warn(\"Unknown attribute, skipped: \" + e.getKey() + \"=\" + e.getValue());\n        }\n      }\n      // handle offset attr\n      OffsetAttribute offset = parent.addAttribute(OffsetAttribute.class);\n      if (!hasOffsetEnd && len > -1) {\n        tokenEnd = tokenStart + len;\n      }\n      offset.setOffset(tokenStart, tokenEnd);\n      if (!hasOffsetStart) {\n        tokenStart = tokenEnd + 1;\n      }\n      // capture state and add to result\n      State state = parent.captureState();\n      res.states.add(state.clone());\n      // reset for reuse\n      parent.clearAttributes();\n    }\n    return res;\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  @Override\n  public ParseResult parse(Reader reader, AttributeSource parent)\n      throws IOException {\n    ParseResult res = new ParseResult();\n    StringBuilder sb = new StringBuilder();\n    char[] buf = new char[128];\n    int cnt;\n    while ((cnt = reader.read(buf)) > 0) {\n      sb.append(buf, 0, cnt);\n    }\n    String val = sb.toString();\n    // empty string - accept even without version number\n    if (val.length() == 0) {\n      return res;\n    }\n    Object o = ObjectBuilder.fromJSON(val);\n    if (!(o instanceof Map)) {\n      throw new IOException(\"Invalid JSON type \" + o.getClass().getName() + \", expected Map\");\n    }\n    Map<String,Object> map = (Map<String,Object>)o;\n    // check version\n    String version = (String)map.get(VERSION_KEY);\n    if (version == null) {\n      throw new IOException(\"Missing VERSION key\");\n    }\n    if (!VERSION.equals(version)) {\n      throw new IOException(\"Unknown VERSION '\" + version + \"', expected \" + VERSION);\n    }\n    if (map.containsKey(STRING_KEY) && map.containsKey(BINARY_KEY)) {\n      throw new IOException(\"Field cannot have both stringValue and binaryValue\");\n    }\n    res.str = (String)map.get(STRING_KEY);\n    String bin = (String)map.get(BINARY_KEY);\n    if (bin != null) {\n      byte[] data = Base64.base64ToByteArray(bin);\n      res.bin = data;\n    }\n    List<Object> tokens = (List<Object>)map.get(TOKENS_KEY);\n    if (tokens == null) {\n      return res;\n    }\n    int tokenStart = 0;\n    int tokenEnd = 0;\n    parent.clearAttributes();\n    for (Object ot : tokens) {\n      tokenStart = tokenEnd + 1; // automatic increment by 1 separator\n      Map<String,Object> tok = (Map<String,Object>)ot;\n      boolean hasOffsetStart = false;\n      boolean hasOffsetEnd = false;\n      int len = -1;\n      for (Entry<String,Object> e : tok.entrySet()) {\n        String key = e.getKey();\n        if (key.equals(TOKEN_KEY)) {\n          CharTermAttribute catt = parent.addAttribute(CharTermAttribute.class);\n          String str = String.valueOf(e.getValue());\n          catt.append(str);\n          len = str.length();\n        } else if (key.equals(OFFSET_START_KEY)) {\n          Object obj = e.getValue();\n          hasOffsetStart = true;\n          if (obj instanceof Number) {\n            tokenStart = ((Number)obj).intValue();\n          } else {\n            try {\n              tokenStart = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              log.warn(\"Invalid \" + OFFSET_START_KEY + \" attribute, skipped: '\" + obj + \"'\");\n              hasOffsetStart = false;\n            }\n          }\n        } else if (key.equals(OFFSET_END_KEY)) {\n          hasOffsetEnd = true;\n          Object obj = e.getValue();\n          if (obj instanceof Number) {\n            tokenEnd = ((Number)obj).intValue();\n          } else {\n            try {\n              tokenEnd = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              log.warn(\"Invalid \" + OFFSET_END_KEY + \" attribute, skipped: '\" + obj + \"'\");\n              hasOffsetEnd = false;\n            }\n          }\n        } else if (key.equals(POSINCR_KEY)) {\n          Object obj = e.getValue();\n          int posIncr = 1;\n          if (obj instanceof Number) {\n            posIncr = ((Number)obj).intValue();\n          } else {\n            try {\n              posIncr = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              log.warn(\"Invalid \" + POSINCR_KEY + \" attribute, skipped: '\" + obj + \"'\");\n            }\n          }\n          PositionIncrementAttribute patt = parent.addAttribute(PositionIncrementAttribute.class);\n          patt.setPositionIncrement(posIncr);\n        } else if (key.equals(PAYLOAD_KEY)) {\n          String str = String.valueOf(e.getValue());\n          if (str.length() > 0) {\n            byte[] data = Base64.base64ToByteArray(str);\n            PayloadAttribute p = parent.addAttribute(PayloadAttribute.class);\n            if (data != null && data.length > 0) {\n              p.setPayload(new BytesRef(data));\n            }\n          }\n        } else if (key.equals(FLAGS_KEY)) {\n          try {\n            int f = Integer.parseInt(String.valueOf(e.getValue()), 16);\n            FlagsAttribute flags = parent.addAttribute(FlagsAttribute.class);\n            flags.setFlags(f);\n          } catch (NumberFormatException nfe) {\n            log.warn(\"Invalid \" + FLAGS_KEY + \" attribute, skipped: '\" + e.getValue() + \"'\");\n          }\n        } else if (key.equals(TYPE_KEY)) {\n          TypeAttribute tattr = parent.addAttribute(TypeAttribute.class);\n          tattr.setType(String.valueOf(e.getValue()));\n        } else {\n          log.warn(\"Unknown attribute, skipped: \" + e.getKey() + \"=\" + e.getValue());\n        }\n      }\n      // handle offset attr\n      OffsetAttribute offset = parent.addAttribute(OffsetAttribute.class);\n      if (!hasOffsetEnd && len > -1) {\n        tokenEnd = tokenStart + len;\n      }\n      offset.setOffset(tokenStart, tokenEnd);\n      if (!hasOffsetStart) {\n        tokenStart = tokenEnd + 1;\n      }\n      // capture state and add to result\n      State state = parent.captureState();\n      res.states.add(state.clone());\n      // reset for reuse\n      parent.clearAttributes();\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9df8125ba9193a2e2e285ed92157810b1952a244","date":1587326330,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/JsonPreAnalyzedParser#parse(Reader,AttributeSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/JsonPreAnalyzedParser#parse(Reader,AttributeSource).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  @Override\n  public ParseResult parse(Reader reader, AttributeSource parent)\n      throws IOException {\n    ParseResult res = new ParseResult();\n    StringBuilder sb = new StringBuilder();\n    char[] buf = new char[128];\n    int cnt;\n    while ((cnt = reader.read(buf)) > 0) {\n      sb.append(buf, 0, cnt);\n    }\n    String val = sb.toString();\n    // empty string - accept even without version number\n    if (val.length() == 0) {\n      return res;\n    }\n    Object o = ObjectBuilder.fromJSONStrict(val);\n    if (!(o instanceof Map)) {\n      throw new IOException(\"Invalid JSON type \" + o.getClass().getName() + \", expected Map\");\n    }\n    Map<String,Object> map = (Map<String,Object>)o;\n    // check version\n    String version = (String)map.get(VERSION_KEY);\n    if (version == null) {\n      throw new IOException(\"Missing VERSION key\");\n    }\n    if (!VERSION.equals(version)) {\n      throw new IOException(\"Unknown VERSION '\" + version + \"', expected \" + VERSION);\n    }\n    if (map.containsKey(STRING_KEY) && map.containsKey(BINARY_KEY)) {\n      throw new IOException(\"Field cannot have both stringValue and binaryValue\");\n    }\n    res.str = (String)map.get(STRING_KEY);\n    String bin = (String)map.get(BINARY_KEY);\n    if (bin != null) {\n      byte[] data = Base64.base64ToByteArray(bin);\n      res.bin = data;\n    }\n    List<Object> tokens = (List<Object>)map.get(TOKENS_KEY);\n    if (tokens == null) {\n      return res;\n    }\n    int tokenStart = 0;\n    int tokenEnd = 0;\n    parent.clearAttributes();\n    for (Object ot : tokens) {\n      tokenStart = tokenEnd + 1; // automatic increment by 1 separator\n      Map<String,Object> tok = (Map<String,Object>)ot;\n      boolean hasOffsetStart = false;\n      boolean hasOffsetEnd = false;\n      int len = -1;\n      for (Entry<String,Object> e : tok.entrySet()) {\n        String key = e.getKey();\n        if (key.equals(TOKEN_KEY)) {\n          CharTermAttribute catt = parent.addAttribute(CharTermAttribute.class);\n          String str = String.valueOf(e.getValue());\n          catt.append(str);\n          len = str.length();\n        } else if (key.equals(OFFSET_START_KEY)) {\n          Object obj = e.getValue();\n          hasOffsetStart = true;\n          if (obj instanceof Number) {\n            tokenStart = ((Number)obj).intValue();\n          } else {\n            try {\n              tokenStart = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              log.warn(\"Invalid {} attribute, skipped: '{}'\", OFFSET_START_KEY, obj);\n              hasOffsetStart = false;\n            }\n          }\n        } else if (key.equals(OFFSET_END_KEY)) {\n          hasOffsetEnd = true;\n          Object obj = e.getValue();\n          if (obj instanceof Number) {\n            tokenEnd = ((Number)obj).intValue();\n          } else {\n            try {\n              tokenEnd = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              log.warn(\"Invalid {} attribute, skipped: '{}'\", OFFSET_END_KEY, obj);\n              hasOffsetEnd = false;\n            }\n          }\n        } else if (key.equals(POSINCR_KEY)) {\n          Object obj = e.getValue();\n          int posIncr = 1;\n          if (obj instanceof Number) {\n            posIncr = ((Number)obj).intValue();\n          } else {\n            try {\n              posIncr = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              log.warn(\"Invalid {} attribute, skipped: '{}'\", POSINCR_KEY, obj);\n            }\n          }\n          PositionIncrementAttribute patt = parent.addAttribute(PositionIncrementAttribute.class);\n          patt.setPositionIncrement(posIncr);\n        } else if (key.equals(PAYLOAD_KEY)) {\n          String str = String.valueOf(e.getValue());\n          if (str.length() > 0) {\n            byte[] data = Base64.base64ToByteArray(str);\n            PayloadAttribute p = parent.addAttribute(PayloadAttribute.class);\n            if (data != null && data.length > 0) {\n              p.setPayload(new BytesRef(data));\n            }\n          }\n        } else if (key.equals(FLAGS_KEY)) {\n          try {\n            int f = Integer.parseInt(String.valueOf(e.getValue()), 16);\n            FlagsAttribute flags = parent.addAttribute(FlagsAttribute.class);\n            flags.setFlags(f);\n          } catch (NumberFormatException nfe) {\n            if (log.isWarnEnabled()) {\n              log.warn(\"Invalid {} attribute, skipped: '{}'\", FLAGS_KEY, e.getValue());\n            }\n          }\n        } else if (key.equals(TYPE_KEY)) {\n          TypeAttribute tattr = parent.addAttribute(TypeAttribute.class);\n          tattr.setType(String.valueOf(e.getValue()));\n        } else {\n          if (log.isWarnEnabled()) {\n            log.warn(\"Unknown attribute, skipped: {} = {}\", e.getKey(), e.getValue());\n          }\n        }\n      }\n      // handle offset attr\n      OffsetAttribute offset = parent.addAttribute(OffsetAttribute.class);\n      if (!hasOffsetEnd && len > -1) {\n        tokenEnd = tokenStart + len;\n      }\n      offset.setOffset(tokenStart, tokenEnd);\n      if (!hasOffsetStart) {\n        tokenStart = tokenEnd + 1;\n      }\n      // capture state and add to result\n      State state = parent.captureState();\n      res.states.add(state.clone());\n      // reset for reuse\n      parent.clearAttributes();\n    }\n    return res;\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  @Override\n  public ParseResult parse(Reader reader, AttributeSource parent)\n      throws IOException {\n    ParseResult res = new ParseResult();\n    StringBuilder sb = new StringBuilder();\n    char[] buf = new char[128];\n    int cnt;\n    while ((cnt = reader.read(buf)) > 0) {\n      sb.append(buf, 0, cnt);\n    }\n    String val = sb.toString();\n    // empty string - accept even without version number\n    if (val.length() == 0) {\n      return res;\n    }\n    Object o = ObjectBuilder.fromJSONStrict(val);\n    if (!(o instanceof Map)) {\n      throw new IOException(\"Invalid JSON type \" + o.getClass().getName() + \", expected Map\");\n    }\n    Map<String,Object> map = (Map<String,Object>)o;\n    // check version\n    String version = (String)map.get(VERSION_KEY);\n    if (version == null) {\n      throw new IOException(\"Missing VERSION key\");\n    }\n    if (!VERSION.equals(version)) {\n      throw new IOException(\"Unknown VERSION '\" + version + \"', expected \" + VERSION);\n    }\n    if (map.containsKey(STRING_KEY) && map.containsKey(BINARY_KEY)) {\n      throw new IOException(\"Field cannot have both stringValue and binaryValue\");\n    }\n    res.str = (String)map.get(STRING_KEY);\n    String bin = (String)map.get(BINARY_KEY);\n    if (bin != null) {\n      byte[] data = Base64.base64ToByteArray(bin);\n      res.bin = data;\n    }\n    List<Object> tokens = (List<Object>)map.get(TOKENS_KEY);\n    if (tokens == null) {\n      return res;\n    }\n    int tokenStart = 0;\n    int tokenEnd = 0;\n    parent.clearAttributes();\n    for (Object ot : tokens) {\n      tokenStart = tokenEnd + 1; // automatic increment by 1 separator\n      Map<String,Object> tok = (Map<String,Object>)ot;\n      boolean hasOffsetStart = false;\n      boolean hasOffsetEnd = false;\n      int len = -1;\n      for (Entry<String,Object> e : tok.entrySet()) {\n        String key = e.getKey();\n        if (key.equals(TOKEN_KEY)) {\n          CharTermAttribute catt = parent.addAttribute(CharTermAttribute.class);\n          String str = String.valueOf(e.getValue());\n          catt.append(str);\n          len = str.length();\n        } else if (key.equals(OFFSET_START_KEY)) {\n          Object obj = e.getValue();\n          hasOffsetStart = true;\n          if (obj instanceof Number) {\n            tokenStart = ((Number)obj).intValue();\n          } else {\n            try {\n              tokenStart = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              log.warn(\"Invalid \" + OFFSET_START_KEY + \" attribute, skipped: '\" + obj + \"'\");\n              hasOffsetStart = false;\n            }\n          }\n        } else if (key.equals(OFFSET_END_KEY)) {\n          hasOffsetEnd = true;\n          Object obj = e.getValue();\n          if (obj instanceof Number) {\n            tokenEnd = ((Number)obj).intValue();\n          } else {\n            try {\n              tokenEnd = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              log.warn(\"Invalid \" + OFFSET_END_KEY + \" attribute, skipped: '\" + obj + \"'\");\n              hasOffsetEnd = false;\n            }\n          }\n        } else if (key.equals(POSINCR_KEY)) {\n          Object obj = e.getValue();\n          int posIncr = 1;\n          if (obj instanceof Number) {\n            posIncr = ((Number)obj).intValue();\n          } else {\n            try {\n              posIncr = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              log.warn(\"Invalid \" + POSINCR_KEY + \" attribute, skipped: '\" + obj + \"'\");\n            }\n          }\n          PositionIncrementAttribute patt = parent.addAttribute(PositionIncrementAttribute.class);\n          patt.setPositionIncrement(posIncr);\n        } else if (key.equals(PAYLOAD_KEY)) {\n          String str = String.valueOf(e.getValue());\n          if (str.length() > 0) {\n            byte[] data = Base64.base64ToByteArray(str);\n            PayloadAttribute p = parent.addAttribute(PayloadAttribute.class);\n            if (data != null && data.length > 0) {\n              p.setPayload(new BytesRef(data));\n            }\n          }\n        } else if (key.equals(FLAGS_KEY)) {\n          try {\n            int f = Integer.parseInt(String.valueOf(e.getValue()), 16);\n            FlagsAttribute flags = parent.addAttribute(FlagsAttribute.class);\n            flags.setFlags(f);\n          } catch (NumberFormatException nfe) {\n            log.warn(\"Invalid \" + FLAGS_KEY + \" attribute, skipped: '\" + e.getValue() + \"'\");\n          }\n        } else if (key.equals(TYPE_KEY)) {\n          TypeAttribute tattr = parent.addAttribute(TypeAttribute.class);\n          tattr.setType(String.valueOf(e.getValue()));\n        } else {\n          log.warn(\"Unknown attribute, skipped: \" + e.getKey() + \"=\" + e.getValue());\n        }\n      }\n      // handle offset attr\n      OffsetAttribute offset = parent.addAttribute(OffsetAttribute.class);\n      if (!hasOffsetEnd && len > -1) {\n        tokenEnd = tokenStart + len;\n      }\n      offset.setOffset(tokenStart, tokenEnd);\n      if (!hasOffsetStart) {\n        tokenStart = tokenEnd + 1;\n      }\n      // capture state and add to result\n      State state = parent.captureState();\n      res.states.add(state.clone());\n      // reset for reuse\n      parent.clearAttributes();\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/JsonPreAnalyzedParser#parse(Reader,AttributeSource).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/JsonPreAnalyzedParser#parse(Reader,AttributeSource).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  @Override\n  public ParseResult parse(Reader reader, AttributeSource parent)\n      throws IOException {\n    ParseResult res = new ParseResult();\n    StringBuilder sb = new StringBuilder();\n    char[] buf = new char[128];\n    int cnt;\n    while ((cnt = reader.read(buf)) > 0) {\n      sb.append(buf, 0, cnt);\n    }\n    String val = sb.toString();\n    // empty string - accept even without version number\n    if (val.length() == 0) {\n      return res;\n    }\n    Object o = ObjectBuilder.fromJSONStrict(val);\n    if (!(o instanceof Map)) {\n      throw new IOException(\"Invalid JSON type \" + o.getClass().getName() + \", expected Map\");\n    }\n    Map<String,Object> map = (Map<String,Object>)o;\n    // check version\n    String version = (String)map.get(VERSION_KEY);\n    if (version == null) {\n      throw new IOException(\"Missing VERSION key\");\n    }\n    if (!VERSION.equals(version)) {\n      throw new IOException(\"Unknown VERSION '\" + version + \"', expected \" + VERSION);\n    }\n    if (map.containsKey(STRING_KEY) && map.containsKey(BINARY_KEY)) {\n      throw new IOException(\"Field cannot have both stringValue and binaryValue\");\n    }\n    res.str = (String)map.get(STRING_KEY);\n    String bin = (String)map.get(BINARY_KEY);\n    if (bin != null) {\n      byte[] data = Base64.base64ToByteArray(bin);\n      res.bin = data;\n    }\n    List<Object> tokens = (List<Object>)map.get(TOKENS_KEY);\n    if (tokens == null) {\n      return res;\n    }\n    int tokenStart = 0;\n    int tokenEnd = 0;\n    parent.clearAttributes();\n    for (Object ot : tokens) {\n      tokenStart = tokenEnd + 1; // automatic increment by 1 separator\n      Map<String,Object> tok = (Map<String,Object>)ot;\n      boolean hasOffsetStart = false;\n      boolean hasOffsetEnd = false;\n      int len = -1;\n      for (Entry<String,Object> e : tok.entrySet()) {\n        String key = e.getKey();\n        if (key.equals(TOKEN_KEY)) {\n          CharTermAttribute catt = parent.addAttribute(CharTermAttribute.class);\n          String str = String.valueOf(e.getValue());\n          catt.append(str);\n          len = str.length();\n        } else if (key.equals(OFFSET_START_KEY)) {\n          Object obj = e.getValue();\n          hasOffsetStart = true;\n          if (obj instanceof Number) {\n            tokenStart = ((Number)obj).intValue();\n          } else {\n            try {\n              tokenStart = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              log.warn(\"Invalid {} attribute, skipped: '{}'\", OFFSET_START_KEY, obj);\n              hasOffsetStart = false;\n            }\n          }\n        } else if (key.equals(OFFSET_END_KEY)) {\n          hasOffsetEnd = true;\n          Object obj = e.getValue();\n          if (obj instanceof Number) {\n            tokenEnd = ((Number)obj).intValue();\n          } else {\n            try {\n              tokenEnd = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              log.warn(\"Invalid {} attribute, skipped: '{}'\", OFFSET_END_KEY, obj);\n              hasOffsetEnd = false;\n            }\n          }\n        } else if (key.equals(POSINCR_KEY)) {\n          Object obj = e.getValue();\n          int posIncr = 1;\n          if (obj instanceof Number) {\n            posIncr = ((Number)obj).intValue();\n          } else {\n            try {\n              posIncr = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              log.warn(\"Invalid {} attribute, skipped: '{}'\", POSINCR_KEY, obj);\n            }\n          }\n          PositionIncrementAttribute patt = parent.addAttribute(PositionIncrementAttribute.class);\n          patt.setPositionIncrement(posIncr);\n        } else if (key.equals(PAYLOAD_KEY)) {\n          String str = String.valueOf(e.getValue());\n          if (str.length() > 0) {\n            byte[] data = Base64.base64ToByteArray(str);\n            PayloadAttribute p = parent.addAttribute(PayloadAttribute.class);\n            if (data != null && data.length > 0) {\n              p.setPayload(new BytesRef(data));\n            }\n          }\n        } else if (key.equals(FLAGS_KEY)) {\n          try {\n            int f = Integer.parseInt(String.valueOf(e.getValue()), 16);\n            FlagsAttribute flags = parent.addAttribute(FlagsAttribute.class);\n            flags.setFlags(f);\n          } catch (NumberFormatException nfe) {\n            log.warn(\"Invalid {} attribute, skipped: '{}'\", FLAGS_KEY, e.getValue());\n          }\n        } else if (key.equals(TYPE_KEY)) {\n          TypeAttribute tattr = parent.addAttribute(TypeAttribute.class);\n          tattr.setType(String.valueOf(e.getValue()));\n        } else {\n          log.warn(\"Unknown attribute, skipped: {} = {}\", e.getKey(), e.getValue());\n        }\n      }\n      // handle offset attr\n      OffsetAttribute offset = parent.addAttribute(OffsetAttribute.class);\n      if (!hasOffsetEnd && len > -1) {\n        tokenEnd = tokenStart + len;\n      }\n      offset.setOffset(tokenStart, tokenEnd);\n      if (!hasOffsetStart) {\n        tokenStart = tokenEnd + 1;\n      }\n      // capture state and add to result\n      State state = parent.captureState();\n      res.states.add(state.clone());\n      // reset for reuse\n      parent.clearAttributes();\n    }\n    return res;\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  @Override\n  public ParseResult parse(Reader reader, AttributeSource parent)\n      throws IOException {\n    ParseResult res = new ParseResult();\n    StringBuilder sb = new StringBuilder();\n    char[] buf = new char[128];\n    int cnt;\n    while ((cnt = reader.read(buf)) > 0) {\n      sb.append(buf, 0, cnt);\n    }\n    String val = sb.toString();\n    // empty string - accept even without version number\n    if (val.length() == 0) {\n      return res;\n    }\n    Object o = ObjectBuilder.fromJSONStrict(val);\n    if (!(o instanceof Map)) {\n      throw new IOException(\"Invalid JSON type \" + o.getClass().getName() + \", expected Map\");\n    }\n    Map<String,Object> map = (Map<String,Object>)o;\n    // check version\n    String version = (String)map.get(VERSION_KEY);\n    if (version == null) {\n      throw new IOException(\"Missing VERSION key\");\n    }\n    if (!VERSION.equals(version)) {\n      throw new IOException(\"Unknown VERSION '\" + version + \"', expected \" + VERSION);\n    }\n    if (map.containsKey(STRING_KEY) && map.containsKey(BINARY_KEY)) {\n      throw new IOException(\"Field cannot have both stringValue and binaryValue\");\n    }\n    res.str = (String)map.get(STRING_KEY);\n    String bin = (String)map.get(BINARY_KEY);\n    if (bin != null) {\n      byte[] data = Base64.base64ToByteArray(bin);\n      res.bin = data;\n    }\n    List<Object> tokens = (List<Object>)map.get(TOKENS_KEY);\n    if (tokens == null) {\n      return res;\n    }\n    int tokenStart = 0;\n    int tokenEnd = 0;\n    parent.clearAttributes();\n    for (Object ot : tokens) {\n      tokenStart = tokenEnd + 1; // automatic increment by 1 separator\n      Map<String,Object> tok = (Map<String,Object>)ot;\n      boolean hasOffsetStart = false;\n      boolean hasOffsetEnd = false;\n      int len = -1;\n      for (Entry<String,Object> e : tok.entrySet()) {\n        String key = e.getKey();\n        if (key.equals(TOKEN_KEY)) {\n          CharTermAttribute catt = parent.addAttribute(CharTermAttribute.class);\n          String str = String.valueOf(e.getValue());\n          catt.append(str);\n          len = str.length();\n        } else if (key.equals(OFFSET_START_KEY)) {\n          Object obj = e.getValue();\n          hasOffsetStart = true;\n          if (obj instanceof Number) {\n            tokenStart = ((Number)obj).intValue();\n          } else {\n            try {\n              tokenStart = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              log.warn(\"Invalid {} attribute, skipped: '{}'\", OFFSET_START_KEY, obj);\n              hasOffsetStart = false;\n            }\n          }\n        } else if (key.equals(OFFSET_END_KEY)) {\n          hasOffsetEnd = true;\n          Object obj = e.getValue();\n          if (obj instanceof Number) {\n            tokenEnd = ((Number)obj).intValue();\n          } else {\n            try {\n              tokenEnd = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              log.warn(\"Invalid {} attribute, skipped: '{}'\", OFFSET_END_KEY, obj);\n              hasOffsetEnd = false;\n            }\n          }\n        } else if (key.equals(POSINCR_KEY)) {\n          Object obj = e.getValue();\n          int posIncr = 1;\n          if (obj instanceof Number) {\n            posIncr = ((Number)obj).intValue();\n          } else {\n            try {\n              posIncr = Integer.parseInt(String.valueOf(obj));\n            } catch (NumberFormatException nfe) {\n              log.warn(\"Invalid {} attribute, skipped: '{}'\", POSINCR_KEY, obj);\n            }\n          }\n          PositionIncrementAttribute patt = parent.addAttribute(PositionIncrementAttribute.class);\n          patt.setPositionIncrement(posIncr);\n        } else if (key.equals(PAYLOAD_KEY)) {\n          String str = String.valueOf(e.getValue());\n          if (str.length() > 0) {\n            byte[] data = Base64.base64ToByteArray(str);\n            PayloadAttribute p = parent.addAttribute(PayloadAttribute.class);\n            if (data != null && data.length > 0) {\n              p.setPayload(new BytesRef(data));\n            }\n          }\n        } else if (key.equals(FLAGS_KEY)) {\n          try {\n            int f = Integer.parseInt(String.valueOf(e.getValue()), 16);\n            FlagsAttribute flags = parent.addAttribute(FlagsAttribute.class);\n            flags.setFlags(f);\n          } catch (NumberFormatException nfe) {\n            if (log.isWarnEnabled()) {\n              log.warn(\"Invalid {} attribute, skipped: '{}'\", FLAGS_KEY, e.getValue());\n            }\n          }\n        } else if (key.equals(TYPE_KEY)) {\n          TypeAttribute tattr = parent.addAttribute(TypeAttribute.class);\n          tattr.setType(String.valueOf(e.getValue()));\n        } else {\n          if (log.isWarnEnabled()) {\n            log.warn(\"Unknown attribute, skipped: {} = {}\", e.getKey(), e.getValue());\n          }\n        }\n      }\n      // handle offset attr\n      OffsetAttribute offset = parent.addAttribute(OffsetAttribute.class);\n      if (!hasOffsetEnd && len > -1) {\n        tokenEnd = tokenStart + len;\n      }\n      offset.setOffset(tokenStart, tokenEnd);\n      if (!hasOffsetStart) {\n        tokenStart = tokenEnd + 1;\n      }\n      // capture state and add to result\n      State state = parent.captureState();\n      res.states.add(state.clone());\n      // reset for reuse\n      parent.clearAttributes();\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"61f55b4999c3f858f4f4acc9c6dc57af2c1acf99":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"575e66bd4b2349209027f6801184da7fc3cba13f":["9df8125ba9193a2e2e285ed92157810b1952a244"],"76fa9933adb0556e752e8af9734c4d0ae14622ff":["232d48b2fd10ac5189a0ac4480ace7421be9de93"],"232d48b2fd10ac5189a0ac4480ace7421be9de93":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["575e66bd4b2349209027f6801184da7fc3cba13f"],"9df8125ba9193a2e2e285ed92157810b1952a244":["61f55b4999c3f858f4f4acc9c6dc57af2c1acf99"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["76fa9933adb0556e752e8af9734c4d0ae14622ff"]},"commit2Childs":{"61f55b4999c3f858f4f4acc9c6dc57af2c1acf99":["9df8125ba9193a2e2e285ed92157810b1952a244"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["232d48b2fd10ac5189a0ac4480ace7421be9de93"],"575e66bd4b2349209027f6801184da7fc3cba13f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"76fa9933adb0556e752e8af9734c4d0ae14622ff":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"232d48b2fd10ac5189a0ac4480ace7421be9de93":["76fa9933adb0556e752e8af9734c4d0ae14622ff"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["61f55b4999c3f858f4f4acc9c6dc57af2c1acf99"],"9df8125ba9193a2e2e285ed92157810b1952a244":["575e66bd4b2349209027f6801184da7fc3cba13f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}