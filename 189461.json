{"path":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","commits":[{"id":"9409650933cc688e77e565092a25e58adfc2e18d","date":1366663164,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CoreMaps#clearMaps(ConfigSolr).mjava","sourceNew":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    List<String> coreNames;\n    List<String> transientNames;\n    List<SolrCore> pendingToClose;\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n\n    while (true) {\n      synchronized (modifyLock) {\n        coreNames = new ArrayList<String>(cores.keySet());\n        transientNames = new ArrayList<String>(transientCores.keySet());\n        pendingToClose = new ArrayList<SolrCore>(pendingCloses);\n      }\n\n      if (coreNames.size() == 0 && transientNames.size() == 0 && pendingToClose.size() == 0) break;\n\n      for (String coreName : coreNames) {\n        SolrCore core = cores.get(coreName);\n        if (core == null) {\n          CoreContainer.log.info(\"Core \" + coreName + \" moved from core container list before closing.\");\n        } else {\n          try {\n            // nocommit: wtf is this?\n           // addPersistOneCore(cfg, container.loader, core.getCoreDescriptor(), getCoreToOrigName(core));\n\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(CoreContainer.log, \"Error shutting down core\", t);\n          } finally {\n            synchronized (modifyLock) {\n              cores.remove(coreName);\n            }\n          }\n        }\n      }\n\n      for (String coreName : transientNames) {\n        SolrCore core = transientCores.get(coreName);\n        if (core == null) {\n          CoreContainer.log.info(\"Core \" + coreName + \" moved from transient core container list before closing.\");\n        } else {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(CoreContainer.log, \"Error shutting down core\", t);\n          } finally {\n            synchronized (modifyLock) {\n              transientCores.remove(coreName);\n            }\n          }\n        }\n      }\n\n      // We might have some cores that we were _thinking_ about shutting down, so take care of those too.\n      for (SolrCore core : pendingToClose) {\n        try {\n          core.close();\n        } catch (Throwable t) {\n          SolrException.log(CoreContainer.log, \"Error shutting down core\", t);\n        } finally {\n          synchronized (modifyLock) {\n            pendingCloses.remove(core);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void clearMaps(ConfigSolr cfg) {\n    List<String> coreNames;\n    List<String> transientNames;\n    List<SolrCore> pendingToClose;\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n\n    while (true) {\n      synchronized (locker) {\n        coreNames = new ArrayList<String>(cores.keySet());\n        transientNames = new ArrayList<String>(transientCores.keySet());\n        pendingToClose = new ArrayList<SolrCore>(pendingCloses);\n      }\n\n      if (coreNames.size() == 0 && transientNames.size() == 0 && pendingToClose.size() == 0) break;\n\n      for (String coreName : coreNames) {\n        SolrCore core = cores.get(coreName);\n        if (core == null) {\n          CoreContainer.log.info(\"Core \" + coreName + \" moved from core container list before closing.\");\n        } else {\n          try {\n            // nocommit: wtf is this?\n           // addPersistOneCore(cfg, container.loader, core.getCoreDescriptor(), getCoreToOrigName(core));\n\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(CoreContainer.log, \"Error shutting down core\", t);\n          } finally {\n            synchronized (locker) {\n              cores.remove(coreName);\n            }\n          }\n        }\n      }\n\n      for (String coreName : transientNames) {\n        SolrCore core = transientCores.get(coreName);\n        if (core == null) {\n          CoreContainer.log.info(\"Core \" + coreName + \" moved from transient core container list before closing.\");\n        } else {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(CoreContainer.log, \"Error shutting down core\", t);\n          } finally {\n            synchronized (locker) {\n              transientCores.remove(coreName);\n            }\n          }\n        }\n      }\n\n      // We might have some cores that we were _thinking_ about shutting down, so take care of those too.\n      for (SolrCore core : pendingToClose) {\n        try {\n          core.close();\n        } catch (Throwable t) {\n          SolrException.log(CoreContainer.log, \"Error shutting down core\", t);\n        } finally {\n          synchronized (locker) {\n            pendingCloses.remove(core);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aff95548e98887da066e6b1f625edf80658ea345","date":1366679225,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","sourceNew":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    List<String> coreNames;\n    List<String> transientNames;\n    List<SolrCore> pendingToClose;\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n\n    while (true) {\n      synchronized (modifyLock) {\n        coreNames = new ArrayList<String>(cores.keySet());\n        transientNames = new ArrayList<String>(transientCores.keySet());\n        pendingToClose = new ArrayList<SolrCore>(pendingCloses);\n      }\n\n      if (coreNames.size() == 0 && transientNames.size() == 0 && pendingToClose.size() == 0) break;\n\n      for (String coreName : coreNames) {\n        SolrCore core = cores.get(coreName);\n        if (core == null) {\n          CoreContainer.log.info(\"Core \" + coreName + \" moved from core container list before closing.\");\n        } else {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(CoreContainer.log, \"Error shutting down core\", t);\n          } finally {\n            synchronized (modifyLock) {\n              cores.remove(coreName);\n            }\n          }\n        }\n      }\n\n      for (String coreName : transientNames) {\n        SolrCore core = transientCores.get(coreName);\n        if (core == null) {\n          CoreContainer.log.info(\"Core \" + coreName + \" moved from transient core container list before closing.\");\n        } else {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(CoreContainer.log, \"Error shutting down core\", t);\n          } finally {\n            synchronized (modifyLock) {\n              transientCores.remove(coreName);\n            }\n          }\n        }\n      }\n\n      // We might have some cores that we were _thinking_ about shutting down, so take care of those too.\n      for (SolrCore core : pendingToClose) {\n        try {\n          core.close();\n        } catch (Throwable t) {\n          SolrException.log(CoreContainer.log, \"Error shutting down core\", t);\n        } finally {\n          synchronized (modifyLock) {\n            pendingCloses.remove(core);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    List<String> coreNames;\n    List<String> transientNames;\n    List<SolrCore> pendingToClose;\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n\n    while (true) {\n      synchronized (modifyLock) {\n        coreNames = new ArrayList<String>(cores.keySet());\n        transientNames = new ArrayList<String>(transientCores.keySet());\n        pendingToClose = new ArrayList<SolrCore>(pendingCloses);\n      }\n\n      if (coreNames.size() == 0 && transientNames.size() == 0 && pendingToClose.size() == 0) break;\n\n      for (String coreName : coreNames) {\n        SolrCore core = cores.get(coreName);\n        if (core == null) {\n          CoreContainer.log.info(\"Core \" + coreName + \" moved from core container list before closing.\");\n        } else {\n          try {\n            // nocommit: wtf is this?\n           // addPersistOneCore(cfg, container.loader, core.getCoreDescriptor(), getCoreToOrigName(core));\n\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(CoreContainer.log, \"Error shutting down core\", t);\n          } finally {\n            synchronized (modifyLock) {\n              cores.remove(coreName);\n            }\n          }\n        }\n      }\n\n      for (String coreName : transientNames) {\n        SolrCore core = transientCores.get(coreName);\n        if (core == null) {\n          CoreContainer.log.info(\"Core \" + coreName + \" moved from transient core container list before closing.\");\n        } else {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(CoreContainer.log, \"Error shutting down core\", t);\n          } finally {\n            synchronized (modifyLock) {\n              transientCores.remove(coreName);\n            }\n          }\n        }\n      }\n\n      // We might have some cores that we were _thinking_ about shutting down, so take care of those too.\n      for (SolrCore core : pendingToClose) {\n        try {\n          core.close();\n        } catch (Throwable t) {\n          SolrException.log(CoreContainer.log, \"Error shutting down core\", t);\n        } finally {\n          synchronized (modifyLock) {\n            pendingCloses.remove(core);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"97a4062691ab4faf2efd2fac975cba45352ff123","date":1372180726,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","sourceNew":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    Collection<SolrCore> coreList;\n    List<String> transientNames;\n    List<SolrCore> pendingToClose;\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n\n    while (true) {\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList = new ArrayList<SolrCore>(cores.values());\n        cores.clear();\n\n        transientNames = new ArrayList<String>(transientCores.keySet());\n        pendingToClose = new ArrayList<SolrCore>(pendingCloses);\n      }\n\n      if (coreList.size() == 0 && transientNames.size() == 0 && pendingToClose.size() == 0) break;\n\n      for (SolrCore core : coreList) {\n        try {\n          core.close();\n        } catch (Throwable t) {\n          SolrException.log(CoreContainer.log, \"Error shutting down core\", t);\n        }\n      }\n\n      for (String coreName : transientNames) {\n        SolrCore core = transientCores.get(coreName);\n        if (core == null) {\n          CoreContainer.log.info(\"Core \" + coreName + \" moved from transient core container list before closing.\");\n        } else {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(CoreContainer.log, \"Error shutting down core\", t);\n          } finally {\n            synchronized (modifyLock) {\n              transientCores.remove(coreName);\n            }\n          }\n        }\n      }\n\n      // We might have some cores that we were _thinking_ about shutting down, so take care of those too.\n      for (SolrCore core : pendingToClose) {\n        try {\n          core.close();\n        } catch (Throwable t) {\n          SolrException.log(CoreContainer.log, \"Error shutting down core\", t);\n        } finally {\n          synchronized (modifyLock) {\n            pendingCloses.remove(core);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    List<String> coreNames;\n    List<String> transientNames;\n    List<SolrCore> pendingToClose;\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n\n    while (true) {\n      synchronized (modifyLock) {\n        coreNames = new ArrayList<String>(cores.keySet());\n        transientNames = new ArrayList<String>(transientCores.keySet());\n        pendingToClose = new ArrayList<SolrCore>(pendingCloses);\n      }\n\n      if (coreNames.size() == 0 && transientNames.size() == 0 && pendingToClose.size() == 0) break;\n\n      for (String coreName : coreNames) {\n        SolrCore core = cores.get(coreName);\n        if (core == null) {\n          CoreContainer.log.info(\"Core \" + coreName + \" moved from core container list before closing.\");\n        } else {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(CoreContainer.log, \"Error shutting down core\", t);\n          } finally {\n            synchronized (modifyLock) {\n              cores.remove(coreName);\n            }\n          }\n        }\n      }\n\n      for (String coreName : transientNames) {\n        SolrCore core = transientCores.get(coreName);\n        if (core == null) {\n          CoreContainer.log.info(\"Core \" + coreName + \" moved from transient core container list before closing.\");\n        } else {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(CoreContainer.log, \"Error shutting down core\", t);\n          } finally {\n            synchronized (modifyLock) {\n              transientCores.remove(coreName);\n            }\n          }\n        }\n      }\n\n      // We might have some cores that we were _thinking_ about shutting down, so take care of those too.\n      for (SolrCore core : pendingToClose) {\n        try {\n          core.close();\n        } catch (Throwable t) {\n          SolrException.log(CoreContainer.log, \"Error shutting down core\", t);\n        } finally {\n          synchronized (modifyLock) {\n            pendingCloses.remove(core);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["b540aa475db4eb68f3c95c2a88fc5abb314a9961","b16415d71f34d00bd12f3db116f7cac330f123e0","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b16415d71f34d00bd12f3db116f7cac330f123e0","date":1372531249,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","sourceNew":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    Collection<SolrCore> coreList = new ArrayList<SolrCore>();\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n\n        coreList.addAll(transientCores.values());\n        transientCores.clear();\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n\n      for (SolrCore core : coreList) {\n        try {\n          core.close();\n        } catch (Throwable t) {\n          SolrException.log(CoreContainer.log, \"Error shutting down core\", t);\n        }\n      }\n    } while (coreList.size() > 0);\n  }\n\n","sourceOld":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    Collection<SolrCore> coreList;\n    List<String> transientNames;\n    List<SolrCore> pendingToClose;\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n\n    while (true) {\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList = new ArrayList<SolrCore>(cores.values());\n        cores.clear();\n\n        transientNames = new ArrayList<String>(transientCores.keySet());\n        pendingToClose = new ArrayList<SolrCore>(pendingCloses);\n      }\n\n      if (coreList.size() == 0 && transientNames.size() == 0 && pendingToClose.size() == 0) break;\n\n      for (SolrCore core : coreList) {\n        try {\n          core.close();\n        } catch (Throwable t) {\n          SolrException.log(CoreContainer.log, \"Error shutting down core\", t);\n        }\n      }\n\n      for (String coreName : transientNames) {\n        SolrCore core = transientCores.get(coreName);\n        if (core == null) {\n          CoreContainer.log.info(\"Core \" + coreName + \" moved from transient core container list before closing.\");\n        } else {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(CoreContainer.log, \"Error shutting down core\", t);\n          } finally {\n            synchronized (modifyLock) {\n              transientCores.remove(coreName);\n            }\n          }\n        }\n      }\n\n      // We might have some cores that we were _thinking_ about shutting down, so take care of those too.\n      for (SolrCore core : pendingToClose) {\n        try {\n          core.close();\n        } catch (Throwable t) {\n          SolrException.log(CoreContainer.log, \"Error shutting down core\", t);\n        } finally {\n          synchronized (modifyLock) {\n            pendingCloses.remove(core);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":["8b6f42dee5a60f46a3fdf3ab93b39aefb356e245","bdcaae89af8d976c4fd37deb584705a6f94b32d1","9409650933cc688e77e565092a25e58adfc2e18d","97a4062691ab4faf2efd2fac975cba45352ff123","a837c064b67fa63a9394136e31218b908cdcf783","338ae28910f94d90dc1177c1f745412354fa2f96","c7c73b6560033b6dcc828fbcc94ba9315c20f3c0"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","sourceNew":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    Collection<SolrCore> coreList = new ArrayList<SolrCore>();\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n\n        coreList.addAll(transientCores.values());\n        transientCores.clear();\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n\n      for (SolrCore core : coreList) {\n        try {\n          core.close();\n        } catch (Throwable t) {\n          SolrException.log(CoreContainer.log, \"Error shutting down core\", t);\n        }\n      }\n    } while (coreList.size() > 0);\n  }\n\n","sourceOld":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    List<String> coreNames;\n    List<String> transientNames;\n    List<SolrCore> pendingToClose;\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n\n    while (true) {\n      synchronized (modifyLock) {\n        coreNames = new ArrayList<String>(cores.keySet());\n        transientNames = new ArrayList<String>(transientCores.keySet());\n        pendingToClose = new ArrayList<SolrCore>(pendingCloses);\n      }\n\n      if (coreNames.size() == 0 && transientNames.size() == 0 && pendingToClose.size() == 0) break;\n\n      for (String coreName : coreNames) {\n        SolrCore core = cores.get(coreName);\n        if (core == null) {\n          CoreContainer.log.info(\"Core \" + coreName + \" moved from core container list before closing.\");\n        } else {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(CoreContainer.log, \"Error shutting down core\", t);\n          } finally {\n            synchronized (modifyLock) {\n              cores.remove(coreName);\n            }\n          }\n        }\n      }\n\n      for (String coreName : transientNames) {\n        SolrCore core = transientCores.get(coreName);\n        if (core == null) {\n          CoreContainer.log.info(\"Core \" + coreName + \" moved from transient core container list before closing.\");\n        } else {\n          try {\n            core.close();\n          } catch (Throwable t) {\n            SolrException.log(CoreContainer.log, \"Error shutting down core\", t);\n          } finally {\n            synchronized (modifyLock) {\n              transientCores.remove(coreName);\n            }\n          }\n        }\n      }\n\n      // We might have some cores that we were _thinking_ about shutting down, so take care of those too.\n      for (SolrCore core : pendingToClose) {\n        try {\n          core.close();\n        } catch (Throwable t) {\n          SolrException.log(CoreContainer.log, \"Error shutting down core\", t);\n        } finally {\n          synchronized (modifyLock) {\n            pendingCloses.remove(core);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","date":1389633998,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","sourceNew":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    Collection<SolrCore> coreList = new ArrayList<SolrCore>();\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n\n        coreList.addAll(transientCores.values());\n        transientCores.clear();\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n\n      for (SolrCore core : coreList) {\n        try {\n          core.close();\n        } catch (Throwable e) {\n          SolrException.log(CoreContainer.log, \"Error shutting down core\", e);\n          if (e instanceof Error) {\n            throw (Error) e;\n          }\n        }\n      }\n    } while (coreList.size() > 0);\n  }\n\n","sourceOld":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    Collection<SolrCore> coreList = new ArrayList<SolrCore>();\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n\n        coreList.addAll(transientCores.values());\n        transientCores.clear();\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n\n      for (SolrCore core : coreList) {\n        try {\n          core.close();\n        } catch (Throwable t) {\n          SolrException.log(CoreContainer.log, \"Error shutting down core\", t);\n        }\n      }\n    } while (coreList.size() > 0);\n  }\n\n","bugFix":["97a4062691ab4faf2efd2fac975cba45352ff123"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","sourceNew":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    Collection<SolrCore> coreList = new ArrayList<>();\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n\n        coreList.addAll(transientCores.values());\n        transientCores.clear();\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n\n      for (SolrCore core : coreList) {\n        try {\n          core.close();\n        } catch (Throwable e) {\n          SolrException.log(CoreContainer.log, \"Error shutting down core\", e);\n          if (e instanceof Error) {\n            throw (Error) e;\n          }\n        }\n      }\n    } while (coreList.size() > 0);\n  }\n\n","sourceOld":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    Collection<SolrCore> coreList = new ArrayList<SolrCore>();\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n\n        coreList.addAll(transientCores.values());\n        transientCores.clear();\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n\n      for (SolrCore core : coreList) {\n        try {\n          core.close();\n        } catch (Throwable e) {\n          SolrException.log(CoreContainer.log, \"Error shutting down core\", e);\n          if (e instanceof Error) {\n            throw (Error) e;\n          }\n        }\n      }\n    } while (coreList.size() > 0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"439c63ae5d22132fca810a0029a854e97d2c1a3e","date":1432733612,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","sourceNew":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    Collection<SolrCore> coreList = new ArrayList<>();\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n\n        coreList.addAll(transientCores.values());\n        transientCores.clear();\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n\n      for (SolrCore core : coreList) {\n        MDCLoggingContext.setCore(core);\n        try {\n          core.close();\n        } catch (Throwable e) {\n          SolrException.log(CoreContainer.log, \"Error shutting down core\", e);\n          if (e instanceof Error) {\n            throw (Error) e;\n          }\n        } finally {\n          MDCLoggingContext.clear();\n        }\n      }\n    } while (coreList.size() > 0);\n  }\n\n","sourceOld":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    Collection<SolrCore> coreList = new ArrayList<>();\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n\n        coreList.addAll(transientCores.values());\n        transientCores.clear();\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n\n      for (SolrCore core : coreList) {\n        try {\n          core.close();\n        } catch (Throwable e) {\n          SolrException.log(CoreContainer.log, \"Error shutting down core\", e);\n          if (e instanceof Error) {\n            throw (Error) e;\n          }\n        }\n      }\n    } while (coreList.size() > 0);\n  }\n\n","bugFix":null,"bugIntro":["b540aa475db4eb68f3c95c2a88fc5abb314a9961"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9367dbf5b00d7764583d991c1888f4acc9c9991a","date":1449048142,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","sourceNew":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    Collection<SolrCore> coreList = new ArrayList<>();\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n\n        coreList.addAll(transientCores.values());\n        transientCores.clear();\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n\n      for (SolrCore core : coreList) {\n        MDCLoggingContext.setCore(core);\n        try {\n          core.close();\n        } catch (Throwable e) {\n          SolrException.log(log, \"Error shutting down core\", e);\n          if (e instanceof Error) {\n            throw (Error) e;\n          }\n        } finally {\n          MDCLoggingContext.clear();\n        }\n      }\n    } while (coreList.size() > 0);\n  }\n\n","sourceOld":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    Collection<SolrCore> coreList = new ArrayList<>();\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n\n        coreList.addAll(transientCores.values());\n        transientCores.clear();\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n\n      for (SolrCore core : coreList) {\n        MDCLoggingContext.setCore(core);\n        try {\n          core.close();\n        } catch (Throwable e) {\n          SolrException.log(CoreContainer.log, \"Error shutting down core\", e);\n          if (e instanceof Error) {\n            throw (Error) e;\n          }\n        } finally {\n          MDCLoggingContext.clear();\n        }\n      }\n    } while (coreList.size() > 0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f5ee35ede64922eb1ba3ad4d2ebc7fb9ee350b8a","date":1454982064,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","sourceNew":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    Collection<SolrCore> coreList = new ArrayList<>();\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n\n        coreList.addAll(transientCores.values());\n        transientCores.clear();\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n      \n      for (SolrCore core : coreList) {\n        ExecutorService coreCloseExecutor = ExecutorUtil.newMDCAwareFixedThreadPool(Integer.MAX_VALUE,\n            new DefaultSolrThreadFactory(\"coreCloseExecutor\"));\n        try {\n          coreCloseExecutor.submit(new Callable<SolrCore>() {\n            @Override\n            public SolrCore call() throws Exception {\n              MDCLoggingContext.setCore(core);\n              try {\n                core.close();\n              } catch (Throwable e) {\n                SolrException.log(log, \"Error shutting down core\", e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                MDCLoggingContext.clear();\n              }\n              return core;\n            }\n          });\n        } finally {\n          ExecutorUtil.shutdownAndAwaitTermination(coreCloseExecutor);\n        }\n\n      }\n    } while (coreList.size() > 0);\n  }\n\n","sourceOld":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    Collection<SolrCore> coreList = new ArrayList<>();\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n\n        coreList.addAll(transientCores.values());\n        transientCores.clear();\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n\n      for (SolrCore core : coreList) {\n        MDCLoggingContext.setCore(core);\n        try {\n          core.close();\n        } catch (Throwable e) {\n          SolrException.log(log, \"Error shutting down core\", e);\n          if (e instanceof Error) {\n            throw (Error) e;\n          }\n        } finally {\n          MDCLoggingContext.clear();\n        }\n      }\n    } while (coreList.size() > 0);\n  }\n\n","bugFix":null,"bugIntro":["b540aa475db4eb68f3c95c2a88fc5abb314a9961"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b540aa475db4eb68f3c95c2a88fc5abb314a9961","date":1456863236,"type":3,"author":"Mark Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","sourceNew":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    Collection<SolrCore> coreList = new ArrayList<>();\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n\n        coreList.addAll(transientCores.values());\n        transientCores.clear();\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n      \n      ExecutorService coreCloseExecutor = ExecutorUtil.newMDCAwareFixedThreadPool(Integer.MAX_VALUE,\n          new DefaultSolrThreadFactory(\"coreCloseExecutor\"));\n      try {\n        for (SolrCore core : coreList) {\n          coreCloseExecutor.submit(new Callable<SolrCore>() {\n            @Override\n            public SolrCore call() throws Exception {\n              MDCLoggingContext.setCore(core);\n              try {\n                core.close();\n              } catch (Throwable e) {\n                SolrException.log(log, \"Error shutting down core\", e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                MDCLoggingContext.clear();\n              }\n              return core;\n            }\n          });\n        }\n      } finally {\n        ExecutorUtil.shutdownAndAwaitTermination(coreCloseExecutor);\n      }\n\n    } while (coreList.size() > 0);\n  }\n\n","sourceOld":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    Collection<SolrCore> coreList = new ArrayList<>();\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n\n        coreList.addAll(transientCores.values());\n        transientCores.clear();\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n      \n      for (SolrCore core : coreList) {\n        ExecutorService coreCloseExecutor = ExecutorUtil.newMDCAwareFixedThreadPool(Integer.MAX_VALUE,\n            new DefaultSolrThreadFactory(\"coreCloseExecutor\"));\n        try {\n          coreCloseExecutor.submit(new Callable<SolrCore>() {\n            @Override\n            public SolrCore call() throws Exception {\n              MDCLoggingContext.setCore(core);\n              try {\n                core.close();\n              } catch (Throwable e) {\n                SolrException.log(log, \"Error shutting down core\", e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                MDCLoggingContext.clear();\n              }\n              return core;\n            }\n          });\n        } finally {\n          ExecutorUtil.shutdownAndAwaitTermination(coreCloseExecutor);\n        }\n\n      }\n    } while (coreList.size() > 0);\n  }\n\n","bugFix":["f5ee35ede64922eb1ba3ad4d2ebc7fb9ee350b8a","97a4062691ab4faf2efd2fac975cba45352ff123","439c63ae5d22132fca810a0029a854e97d2c1a3e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","sourceNew":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    Collection<SolrCore> coreList = new ArrayList<>();\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n\n        coreList.addAll(transientCores.values());\n        transientCores.clear();\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n      \n      ExecutorService coreCloseExecutor = ExecutorUtil.newMDCAwareFixedThreadPool(Integer.MAX_VALUE,\n          new DefaultSolrThreadFactory(\"coreCloseExecutor\"));\n      try {\n        for (SolrCore core : coreList) {\n          coreCloseExecutor.submit(new Callable<SolrCore>() {\n            @Override\n            public SolrCore call() throws Exception {\n              MDCLoggingContext.setCore(core);\n              try {\n                core.close();\n              } catch (Throwable e) {\n                SolrException.log(log, \"Error shutting down core\", e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                MDCLoggingContext.clear();\n              }\n              return core;\n            }\n          });\n        }\n      } finally {\n        ExecutorUtil.shutdownAndAwaitTermination(coreCloseExecutor);\n      }\n\n    } while (coreList.size() > 0);\n  }\n\n","sourceOld":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    Collection<SolrCore> coreList = new ArrayList<>();\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n\n        coreList.addAll(transientCores.values());\n        transientCores.clear();\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n      \n      for (SolrCore core : coreList) {\n        ExecutorService coreCloseExecutor = ExecutorUtil.newMDCAwareFixedThreadPool(Integer.MAX_VALUE,\n            new DefaultSolrThreadFactory(\"coreCloseExecutor\"));\n        try {\n          coreCloseExecutor.submit(new Callable<SolrCore>() {\n            @Override\n            public SolrCore call() throws Exception {\n              MDCLoggingContext.setCore(core);\n              try {\n                core.close();\n              } catch (Throwable e) {\n                SolrException.log(log, \"Error shutting down core\", e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                MDCLoggingContext.clear();\n              }\n              return core;\n            }\n          });\n        } finally {\n          ExecutorUtil.shutdownAndAwaitTermination(coreCloseExecutor);\n        }\n\n      }\n    } while (coreList.size() > 0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"043df2e9a841864922c32756a44c939ed768cb89","date":1459876536,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","sourceNew":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    Collection<SolrCore> coreList = new ArrayList<>();\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n\n        coreList.addAll(transientCores.values());\n        transientCores.clear();\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n      \n      ExecutorService coreCloseExecutor = ExecutorUtil.newMDCAwareFixedThreadPool(Integer.MAX_VALUE,\n          new DefaultSolrThreadFactory(\"coreCloseExecutor\"));\n      try {\n        for (SolrCore core : coreList) {\n          coreCloseExecutor.submit(() -> {\n            MDCLoggingContext.setCore(core);\n            try {\n              core.close();\n            } catch (Throwable e) {\n              SolrException.log(log, \"Error shutting down core\", e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              MDCLoggingContext.clear();\n            }\n            return core;\n          });\n        }\n      } finally {\n        ExecutorUtil.shutdownAndAwaitTermination(coreCloseExecutor);\n      }\n\n    } while (coreList.size() > 0);\n  }\n\n","sourceOld":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    Collection<SolrCore> coreList = new ArrayList<>();\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n\n        coreList.addAll(transientCores.values());\n        transientCores.clear();\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n      \n      ExecutorService coreCloseExecutor = ExecutorUtil.newMDCAwareFixedThreadPool(Integer.MAX_VALUE,\n          new DefaultSolrThreadFactory(\"coreCloseExecutor\"));\n      try {\n        for (SolrCore core : coreList) {\n          coreCloseExecutor.submit(new Callable<SolrCore>() {\n            @Override\n            public SolrCore call() throws Exception {\n              MDCLoggingContext.setCore(core);\n              try {\n                core.close();\n              } catch (Throwable e) {\n                SolrException.log(log, \"Error shutting down core\", e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                MDCLoggingContext.clear();\n              }\n              return core;\n            }\n          });\n        }\n      } finally {\n        ExecutorUtil.shutdownAndAwaitTermination(coreCloseExecutor);\n      }\n\n    } while (coreList.size() > 0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6284684320a9808c41a5e43de958b2da22f89bd","date":1459977490,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","sourceNew":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    Collection<SolrCore> coreList = new ArrayList<>();\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n\n        coreList.addAll(transientCores.values());\n        transientCores.clear();\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n      \n      ExecutorService coreCloseExecutor = ExecutorUtil.newMDCAwareFixedThreadPool(Integer.MAX_VALUE,\n          new DefaultSolrThreadFactory(\"coreCloseExecutor\"));\n      try {\n        for (SolrCore core : coreList) {\n          coreCloseExecutor.submit(() -> {\n            MDCLoggingContext.setCore(core);\n            try {\n              core.close();\n            } catch (Throwable e) {\n              SolrException.log(log, \"Error shutting down core\", e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              MDCLoggingContext.clear();\n            }\n            return core;\n          });\n        }\n      } finally {\n        ExecutorUtil.shutdownAndAwaitTermination(coreCloseExecutor);\n      }\n\n    } while (coreList.size() > 0);\n  }\n\n","sourceOld":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    Collection<SolrCore> coreList = new ArrayList<>();\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n\n        coreList.addAll(transientCores.values());\n        transientCores.clear();\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n      \n      ExecutorService coreCloseExecutor = ExecutorUtil.newMDCAwareFixedThreadPool(Integer.MAX_VALUE,\n          new DefaultSolrThreadFactory(\"coreCloseExecutor\"));\n      try {\n        for (SolrCore core : coreList) {\n          coreCloseExecutor.submit(new Callable<SolrCore>() {\n            @Override\n            public SolrCore call() throws Exception {\n              MDCLoggingContext.setCore(core);\n              try {\n                core.close();\n              } catch (Throwable e) {\n                SolrException.log(log, \"Error shutting down core\", e);\n                if (e instanceof Error) {\n                  throw (Error) e;\n                }\n              } finally {\n                MDCLoggingContext.clear();\n              }\n              return core;\n            }\n          });\n        }\n      } finally {\n        ExecutorUtil.shutdownAndAwaitTermination(coreCloseExecutor);\n      }\n\n    } while (coreList.size() > 0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9435d55e3ea95c5d94406d3affc36f9505b6a736","date":1491251232,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","sourceNew":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    Collection<SolrCore> coreList = new ArrayList<>();\n\n    \n    TransientSolrCoreCache transientSolrCoreCache = container.getTransientCacheHandler();\n    // Release observer\n    if (transientSolrCoreCache != null) {\n      transientSolrCoreCache.close();\n    }\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n        if (transientSolrCoreCache != null) {\n          coreList.addAll(transientSolrCoreCache.prepareForShutdown());\n        }\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n      \n      ExecutorService coreCloseExecutor = ExecutorUtil.newMDCAwareFixedThreadPool(Integer.MAX_VALUE,\n          new DefaultSolrThreadFactory(\"coreCloseExecutor\"));\n      try {\n        for (SolrCore core : coreList) {\n          coreCloseExecutor.submit(() -> {\n            MDCLoggingContext.setCore(core);\n            try {\n              core.close();\n            } catch (Throwable e) {\n              SolrException.log(log, \"Error shutting down core\", e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              MDCLoggingContext.clear();\n            }\n            return core;\n          });\n        }\n      } finally {\n        ExecutorUtil.shutdownAndAwaitTermination(coreCloseExecutor);\n      }\n\n    } while (coreList.size() > 0);\n  }\n\n","sourceOld":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    Collection<SolrCore> coreList = new ArrayList<>();\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n\n        coreList.addAll(transientCores.values());\n        transientCores.clear();\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n      \n      ExecutorService coreCloseExecutor = ExecutorUtil.newMDCAwareFixedThreadPool(Integer.MAX_VALUE,\n          new DefaultSolrThreadFactory(\"coreCloseExecutor\"));\n      try {\n        for (SolrCore core : coreList) {\n          coreCloseExecutor.submit(() -> {\n            MDCLoggingContext.setCore(core);\n            try {\n              core.close();\n            } catch (Throwable e) {\n              SolrException.log(log, \"Error shutting down core\", e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              MDCLoggingContext.clear();\n            }\n            return core;\n          });\n        }\n      } finally {\n        ExecutorUtil.shutdownAndAwaitTermination(coreCloseExecutor);\n      }\n\n    } while (coreList.size() > 0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b6a4b585aed7660a589375f6a09b90efd29c961","date":1491296430,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","sourceNew":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    Collection<SolrCore> coreList = new ArrayList<>();\n\n    \n    TransientSolrCoreCache transientSolrCoreCache = container.getTransientCacheHandler();\n    // Release observer\n    if (transientSolrCoreCache != null) {\n      transientSolrCoreCache.close();\n    }\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n        if (transientSolrCoreCache != null) {\n          coreList.addAll(transientSolrCoreCache.prepareForShutdown());\n        }\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n      \n      ExecutorService coreCloseExecutor = ExecutorUtil.newMDCAwareFixedThreadPool(Integer.MAX_VALUE,\n          new DefaultSolrThreadFactory(\"coreCloseExecutor\"));\n      try {\n        for (SolrCore core : coreList) {\n          coreCloseExecutor.submit(() -> {\n            MDCLoggingContext.setCore(core);\n            try {\n              core.close();\n            } catch (Throwable e) {\n              SolrException.log(log, \"Error shutting down core\", e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              MDCLoggingContext.clear();\n            }\n            return core;\n          });\n        }\n      } finally {\n        ExecutorUtil.shutdownAndAwaitTermination(coreCloseExecutor);\n      }\n\n    } while (coreList.size() > 0);\n  }\n\n","sourceOld":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    Collection<SolrCore> coreList = new ArrayList<>();\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n\n        coreList.addAll(transientCores.values());\n        transientCores.clear();\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n      \n      ExecutorService coreCloseExecutor = ExecutorUtil.newMDCAwareFixedThreadPool(Integer.MAX_VALUE,\n          new DefaultSolrThreadFactory(\"coreCloseExecutor\"));\n      try {\n        for (SolrCore core : coreList) {\n          coreCloseExecutor.submit(() -> {\n            MDCLoggingContext.setCore(core);\n            try {\n              core.close();\n            } catch (Throwable e) {\n              SolrException.log(log, \"Error shutting down core\", e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              MDCLoggingContext.clear();\n            }\n            return core;\n          });\n        }\n      } finally {\n        ExecutorUtil.shutdownAndAwaitTermination(coreCloseExecutor);\n      }\n\n    } while (coreList.size() > 0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6130fcaa36d42a71fc464c80399af8098c42de5a","date":1493878512,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","sourceNew":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    waitForLoadingCoresToFinish(30*1000);\n    Collection<SolrCore> coreList = new ArrayList<>();\n\n    \n    TransientSolrCoreCache transientSolrCoreCache = container.getTransientCacheHandler();\n    // Release observer\n    if (transientSolrCoreCache != null) {\n      transientSolrCoreCache.close();\n    }\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n        if (transientSolrCoreCache != null) {\n          coreList.addAll(transientSolrCoreCache.prepareForShutdown());\n        }\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n      \n      ExecutorService coreCloseExecutor = ExecutorUtil.newMDCAwareFixedThreadPool(Integer.MAX_VALUE,\n          new DefaultSolrThreadFactory(\"coreCloseExecutor\"));\n      try {\n        for (SolrCore core : coreList) {\n          coreCloseExecutor.submit(() -> {\n            MDCLoggingContext.setCore(core);\n            try {\n              core.close();\n            } catch (Throwable e) {\n              SolrException.log(log, \"Error shutting down core\", e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              MDCLoggingContext.clear();\n            }\n            return core;\n          });\n        }\n      } finally {\n        ExecutorUtil.shutdownAndAwaitTermination(coreCloseExecutor);\n      }\n\n    } while (coreList.size() > 0);\n  }\n\n","sourceOld":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    Collection<SolrCore> coreList = new ArrayList<>();\n\n    \n    TransientSolrCoreCache transientSolrCoreCache = container.getTransientCacheHandler();\n    // Release observer\n    if (transientSolrCoreCache != null) {\n      transientSolrCoreCache.close();\n    }\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n        if (transientSolrCoreCache != null) {\n          coreList.addAll(transientSolrCoreCache.prepareForShutdown());\n        }\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n      \n      ExecutorService coreCloseExecutor = ExecutorUtil.newMDCAwareFixedThreadPool(Integer.MAX_VALUE,\n          new DefaultSolrThreadFactory(\"coreCloseExecutor\"));\n      try {\n        for (SolrCore core : coreList) {\n          coreCloseExecutor.submit(() -> {\n            MDCLoggingContext.setCore(core);\n            try {\n              core.close();\n            } catch (Throwable e) {\n              SolrException.log(log, \"Error shutting down core\", e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              MDCLoggingContext.clear();\n            }\n            return core;\n          });\n        }\n      } finally {\n        ExecutorUtil.shutdownAndAwaitTermination(coreCloseExecutor);\n      }\n\n    } while (coreList.size() > 0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","sourceNew":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    waitForLoadingCoresToFinish(30*1000);\n    Collection<SolrCore> coreList = new ArrayList<>();\n\n    \n    TransientSolrCoreCache transientSolrCoreCache = container.getTransientCacheHandler();\n    // Release observer\n    if (transientSolrCoreCache != null) {\n      transientSolrCoreCache.close();\n    }\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n        if (transientSolrCoreCache != null) {\n          coreList.addAll(transientSolrCoreCache.prepareForShutdown());\n        }\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n      \n      ExecutorService coreCloseExecutor = ExecutorUtil.newMDCAwareFixedThreadPool(Integer.MAX_VALUE,\n          new DefaultSolrThreadFactory(\"coreCloseExecutor\"));\n      try {\n        for (SolrCore core : coreList) {\n          coreCloseExecutor.submit(() -> {\n            MDCLoggingContext.setCore(core);\n            try {\n              core.close();\n            } catch (Throwable e) {\n              SolrException.log(log, \"Error shutting down core\", e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              MDCLoggingContext.clear();\n            }\n            return core;\n          });\n        }\n      } finally {\n        ExecutorUtil.shutdownAndAwaitTermination(coreCloseExecutor);\n      }\n\n    } while (coreList.size() > 0);\n  }\n\n","sourceOld":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    Collection<SolrCore> coreList = new ArrayList<>();\n\n    \n    TransientSolrCoreCache transientSolrCoreCache = container.getTransientCacheHandler();\n    // Release observer\n    if (transientSolrCoreCache != null) {\n      transientSolrCoreCache.close();\n    }\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n        if (transientSolrCoreCache != null) {\n          coreList.addAll(transientSolrCoreCache.prepareForShutdown());\n        }\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n      \n      ExecutorService coreCloseExecutor = ExecutorUtil.newMDCAwareFixedThreadPool(Integer.MAX_VALUE,\n          new DefaultSolrThreadFactory(\"coreCloseExecutor\"));\n      try {\n        for (SolrCore core : coreList) {\n          coreCloseExecutor.submit(() -> {\n            MDCLoggingContext.setCore(core);\n            try {\n              core.close();\n            } catch (Throwable e) {\n              SolrException.log(log, \"Error shutting down core\", e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              MDCLoggingContext.clear();\n            }\n            return core;\n          });\n        }\n      } finally {\n        ExecutorUtil.shutdownAndAwaitTermination(coreCloseExecutor);\n      }\n\n    } while (coreList.size() > 0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7871f9c286dce2a9370bcf517a3e7d12e3bd9602","date":1498708934,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","sourceNew":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    waitForLoadingCoresToFinish(30*1000);\n    Collection<SolrCore> coreList = new ArrayList<>();\n\n    \n    TransientSolrCoreCache transientSolrCoreCache = getTransientCacheHandler();\n    // Release observer\n    if (transientSolrCoreCache != null) {\n      transientSolrCoreCache.close();\n    }\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n        if (transientSolrCoreCache != null) {\n          coreList.addAll(transientSolrCoreCache.prepareForShutdown());\n        }\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n      \n      ExecutorService coreCloseExecutor = ExecutorUtil.newMDCAwareFixedThreadPool(Integer.MAX_VALUE,\n          new DefaultSolrThreadFactory(\"coreCloseExecutor\"));\n      try {\n        for (SolrCore core : coreList) {\n          coreCloseExecutor.submit(() -> {\n            MDCLoggingContext.setCore(core);\n            try {\n              core.close();\n            } catch (Throwable e) {\n              SolrException.log(log, \"Error shutting down core\", e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              MDCLoggingContext.clear();\n            }\n            return core;\n          });\n        }\n      } finally {\n        ExecutorUtil.shutdownAndAwaitTermination(coreCloseExecutor);\n      }\n\n    } while (coreList.size() > 0);\n  }\n\n","sourceOld":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    waitForLoadingCoresToFinish(30*1000);\n    Collection<SolrCore> coreList = new ArrayList<>();\n\n    \n    TransientSolrCoreCache transientSolrCoreCache = container.getTransientCacheHandler();\n    // Release observer\n    if (transientSolrCoreCache != null) {\n      transientSolrCoreCache.close();\n    }\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n        if (transientSolrCoreCache != null) {\n          coreList.addAll(transientSolrCoreCache.prepareForShutdown());\n        }\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n      \n      ExecutorService coreCloseExecutor = ExecutorUtil.newMDCAwareFixedThreadPool(Integer.MAX_VALUE,\n          new DefaultSolrThreadFactory(\"coreCloseExecutor\"));\n      try {\n        for (SolrCore core : coreList) {\n          coreCloseExecutor.submit(() -> {\n            MDCLoggingContext.setCore(core);\n            try {\n              core.close();\n            } catch (Throwable e) {\n              SolrException.log(log, \"Error shutting down core\", e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              MDCLoggingContext.clear();\n            }\n            return core;\n          });\n        }\n      } finally {\n        ExecutorUtil.shutdownAndAwaitTermination(coreCloseExecutor);\n      }\n\n    } while (coreList.size() > 0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","sourceNew":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    waitForLoadingCoresToFinish(30*1000);\n    Collection<SolrCore> coreList = new ArrayList<>();\n\n    \n    TransientSolrCoreCache transientSolrCoreCache = getTransientCacheHandler();\n    // Release observer\n    if (transientSolrCoreCache != null) {\n      transientSolrCoreCache.close();\n    }\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n        if (transientSolrCoreCache != null) {\n          coreList.addAll(transientSolrCoreCache.prepareForShutdown());\n        }\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n      \n      ExecutorService coreCloseExecutor = ExecutorUtil.newMDCAwareFixedThreadPool(Integer.MAX_VALUE,\n          new DefaultSolrThreadFactory(\"coreCloseExecutor\"));\n      try {\n        for (SolrCore core : coreList) {\n          coreCloseExecutor.submit(() -> {\n            MDCLoggingContext.setCore(core);\n            try {\n              core.close();\n            } catch (Throwable e) {\n              SolrException.log(log, \"Error shutting down core\", e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              MDCLoggingContext.clear();\n            }\n            return core;\n          });\n        }\n      } finally {\n        ExecutorUtil.shutdownAndAwaitTermination(coreCloseExecutor);\n      }\n\n    } while (coreList.size() > 0);\n  }\n\n","sourceOld":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    waitForLoadingCoresToFinish(30*1000);\n    Collection<SolrCore> coreList = new ArrayList<>();\n\n    \n    TransientSolrCoreCache transientSolrCoreCache = container.getTransientCacheHandler();\n    // Release observer\n    if (transientSolrCoreCache != null) {\n      transientSolrCoreCache.close();\n    }\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n        if (transientSolrCoreCache != null) {\n          coreList.addAll(transientSolrCoreCache.prepareForShutdown());\n        }\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n      \n      ExecutorService coreCloseExecutor = ExecutorUtil.newMDCAwareFixedThreadPool(Integer.MAX_VALUE,\n          new DefaultSolrThreadFactory(\"coreCloseExecutor\"));\n      try {\n        for (SolrCore core : coreList) {\n          coreCloseExecutor.submit(() -> {\n            MDCLoggingContext.setCore(core);\n            try {\n              core.close();\n            } catch (Throwable e) {\n              SolrException.log(log, \"Error shutting down core\", e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              MDCLoggingContext.clear();\n            }\n            return core;\n          });\n        }\n      } finally {\n        ExecutorUtil.shutdownAndAwaitTermination(coreCloseExecutor);\n      }\n\n    } while (coreList.size() > 0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30c8e5574b55d57947e989443dfde611646530ee","date":1499131153,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","sourceNew":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    waitForLoadingCoresToFinish(30*1000);\n    Collection<SolrCore> coreList = new ArrayList<>();\n\n    \n    TransientSolrCoreCache transientSolrCoreCache = getTransientCacheHandler();\n    // Release observer\n    if (transientSolrCoreCache != null) {\n      transientSolrCoreCache.close();\n    }\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n        if (transientSolrCoreCache != null) {\n          coreList.addAll(transientSolrCoreCache.prepareForShutdown());\n        }\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n      \n      ExecutorService coreCloseExecutor = ExecutorUtil.newMDCAwareFixedThreadPool(Integer.MAX_VALUE,\n          new DefaultSolrThreadFactory(\"coreCloseExecutor\"));\n      try {\n        for (SolrCore core : coreList) {\n          coreCloseExecutor.submit(() -> {\n            MDCLoggingContext.setCore(core);\n            try {\n              core.close();\n            } catch (Throwable e) {\n              SolrException.log(log, \"Error shutting down core\", e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              MDCLoggingContext.clear();\n            }\n            return core;\n          });\n        }\n      } finally {\n        ExecutorUtil.shutdownAndAwaitTermination(coreCloseExecutor);\n      }\n\n    } while (coreList.size() > 0);\n  }\n\n","sourceOld":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    waitForLoadingCoresToFinish(30*1000);\n    Collection<SolrCore> coreList = new ArrayList<>();\n\n    \n    TransientSolrCoreCache transientSolrCoreCache = container.getTransientCacheHandler();\n    // Release observer\n    if (transientSolrCoreCache != null) {\n      transientSolrCoreCache.close();\n    }\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n        if (transientSolrCoreCache != null) {\n          coreList.addAll(transientSolrCoreCache.prepareForShutdown());\n        }\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n      \n      ExecutorService coreCloseExecutor = ExecutorUtil.newMDCAwareFixedThreadPool(Integer.MAX_VALUE,\n          new DefaultSolrThreadFactory(\"coreCloseExecutor\"));\n      try {\n        for (SolrCore core : coreList) {\n          coreCloseExecutor.submit(() -> {\n            MDCLoggingContext.setCore(core);\n            try {\n              core.close();\n            } catch (Throwable e) {\n              SolrException.log(log, \"Error shutting down core\", e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              MDCLoggingContext.clear();\n            }\n            return core;\n          });\n        }\n      } finally {\n        ExecutorUtil.shutdownAndAwaitTermination(coreCloseExecutor);\n      }\n\n    } while (coreList.size() > 0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb03700c9690d16b15fb4f56f6ec36b128fd894e","date":1586745995,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCores#close().mjava","sourceNew":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    waitForLoadingCoresToFinish(30*1000);\n    Collection<SolrCore> coreList = new ArrayList<>();\n\n    \n    TransientSolrCoreCache transientSolrCoreCache = getTransientCacheHandler();\n    // Release observer\n    if (transientSolrCoreCache != null) {\n      transientSolrCoreCache.close();\n    }\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n        if (transientSolrCoreCache != null) {\n          coreList.addAll(transientSolrCoreCache.prepareForShutdown());\n        }\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n      \n      ExecutorService coreCloseExecutor = ExecutorUtil.newMDCAwareFixedThreadPool(Integer.MAX_VALUE,\n          new SolrNamedThreadFactory(\"coreCloseExecutor\"));\n      try {\n        for (SolrCore core : coreList) {\n          coreCloseExecutor.submit(() -> {\n            MDCLoggingContext.setCore(core);\n            try {\n              core.close();\n            } catch (Throwable e) {\n              SolrException.log(log, \"Error shutting down core\", e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              MDCLoggingContext.clear();\n            }\n            return core;\n          });\n        }\n      } finally {\n        ExecutorUtil.shutdownAndAwaitTermination(coreCloseExecutor);\n      }\n\n    } while (coreList.size() > 0);\n  }\n\n","sourceOld":"  // We are shutting down. You can't hold the lock on the various lists of cores while they shut down, so we need to\n  // make a temporary copy of the names and shut them down outside the lock.\n  protected void close() {\n    waitForLoadingCoresToFinish(30*1000);\n    Collection<SolrCore> coreList = new ArrayList<>();\n\n    \n    TransientSolrCoreCache transientSolrCoreCache = getTransientCacheHandler();\n    // Release observer\n    if (transientSolrCoreCache != null) {\n      transientSolrCoreCache.close();\n    }\n\n    // It might be possible for one of the cores to move from one list to another while we're closing them. So\n    // loop through the lists until they're all empty. In particular, the core could have moved from the transient\n    // list to the pendingCloses list.\n    do {\n      coreList.clear();\n      synchronized (modifyLock) {\n        // make a copy of the cores then clear the map so the core isn't handed out to a request again\n        coreList.addAll(cores.values());\n        cores.clear();\n        if (transientSolrCoreCache != null) {\n          coreList.addAll(transientSolrCoreCache.prepareForShutdown());\n        }\n\n        coreList.addAll(pendingCloses);\n        pendingCloses.clear();\n      }\n      \n      ExecutorService coreCloseExecutor = ExecutorUtil.newMDCAwareFixedThreadPool(Integer.MAX_VALUE,\n          new DefaultSolrThreadFactory(\"coreCloseExecutor\"));\n      try {\n        for (SolrCore core : coreList) {\n          coreCloseExecutor.submit(() -> {\n            MDCLoggingContext.setCore(core);\n            try {\n              core.close();\n            } catch (Throwable e) {\n              SolrException.log(log, \"Error shutting down core\", e);\n              if (e instanceof Error) {\n                throw (Error) e;\n              }\n            } finally {\n              MDCLoggingContext.clear();\n            }\n            return core;\n          });\n        }\n      } finally {\n        ExecutorUtil.shutdownAndAwaitTermination(coreCloseExecutor);\n      }\n\n    } while (coreList.size() > 0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9435d55e3ea95c5d94406d3affc36f9505b6a736":["b6284684320a9808c41a5e43de958b2da22f89bd"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"043df2e9a841864922c32756a44c939ed768cb89":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"b540aa475db4eb68f3c95c2a88fc5abb314a9961":["f5ee35ede64922eb1ba3ad4d2ebc7fb9ee350b8a"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["aff95548e98887da066e6b1f625edf80658ea345","b16415d71f34d00bd12f3db116f7cac330f123e0"],"7871f9c286dce2a9370bcf517a3e7d12e3bd9602":["6130fcaa36d42a71fc464c80399af8098c42de5a"],"30c8e5574b55d57947e989443dfde611646530ee":["e9017cf144952056066919f1ebc7897ff9bd71b1","28288370235ed02234a64753cdbf0c6ec096304a"],"8b6a4b585aed7660a589375f6a09b90efd29c961":["b6284684320a9808c41a5e43de958b2da22f89bd"],"97a4062691ab4faf2efd2fac975cba45352ff123":["aff95548e98887da066e6b1f625edf80658ea345"],"9367dbf5b00d7764583d991c1888f4acc9c9991a":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"f5ee35ede64922eb1ba3ad4d2ebc7fb9ee350b8a":["9367dbf5b00d7764583d991c1888f4acc9c9991a"],"28288370235ed02234a64753cdbf0c6ec096304a":["6130fcaa36d42a71fc464c80399af8098c42de5a","7871f9c286dce2a9370bcf517a3e7d12e3bd9602"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["8b6a4b585aed7660a589375f6a09b90efd29c961","6130fcaa36d42a71fc464c80399af8098c42de5a"],"b6284684320a9808c41a5e43de958b2da22f89bd":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273","043df2e9a841864922c32756a44c939ed768cb89"],"aff95548e98887da066e6b1f625edf80658ea345":["9409650933cc688e77e565092a25e58adfc2e18d"],"9409650933cc688e77e565092a25e58adfc2e18d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b16415d71f34d00bd12f3db116f7cac330f123e0":["97a4062691ab4faf2efd2fac975cba45352ff123"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["28288370235ed02234a64753cdbf0c6ec096304a"],"6130fcaa36d42a71fc464c80399af8098c42de5a":["9435d55e3ea95c5d94406d3affc36f9505b6a736"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["f5ee35ede64922eb1ba3ad4d2ebc7fb9ee350b8a","b540aa475db4eb68f3c95c2a88fc5abb314a9961"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["b16415d71f34d00bd12f3db116f7cac330f123e0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"]},"commit2Childs":{"9435d55e3ea95c5d94406d3affc36f9505b6a736":["6130fcaa36d42a71fc464c80399af8098c42de5a"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"043df2e9a841864922c32756a44c939ed768cb89":["b6284684320a9808c41a5e43de958b2da22f89bd"],"b540aa475db4eb68f3c95c2a88fc5abb314a9961":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"7871f9c286dce2a9370bcf517a3e7d12e3bd9602":["28288370235ed02234a64753cdbf0c6ec096304a"],"30c8e5574b55d57947e989443dfde611646530ee":[],"8b6a4b585aed7660a589375f6a09b90efd29c961":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"97a4062691ab4faf2efd2fac975cba45352ff123":["b16415d71f34d00bd12f3db116f7cac330f123e0"],"9367dbf5b00d7764583d991c1888f4acc9c9991a":["f5ee35ede64922eb1ba3ad4d2ebc7fb9ee350b8a"],"f5ee35ede64922eb1ba3ad4d2ebc7fb9ee350b8a":["b540aa475db4eb68f3c95c2a88fc5abb314a9961","cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"28288370235ed02234a64753cdbf0c6ec096304a":["30c8e5574b55d57947e989443dfde611646530ee","fb03700c9690d16b15fb4f56f6ec36b128fd894e"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["9367dbf5b00d7764583d991c1888f4acc9c9991a"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["30c8e5574b55d57947e989443dfde611646530ee"],"b6284684320a9808c41a5e43de958b2da22f89bd":["9435d55e3ea95c5d94406d3affc36f9505b6a736","8b6a4b585aed7660a589375f6a09b90efd29c961"],"aff95548e98887da066e6b1f625edf80658ea345":["37a0f60745e53927c4c876cfe5b5a58170f0646c","97a4062691ab4faf2efd2fac975cba45352ff123"],"9409650933cc688e77e565092a25e58adfc2e18d":["aff95548e98887da066e6b1f625edf80658ea345"],"b16415d71f34d00bd12f3db116f7cac330f123e0":["37a0f60745e53927c4c876cfe5b5a58170f0646c","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9409650933cc688e77e565092a25e58adfc2e18d"],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6130fcaa36d42a71fc464c80399af8098c42de5a":["7871f9c286dce2a9370bcf517a3e7d12e3bd9602","28288370235ed02234a64753cdbf0c6ec096304a","e9017cf144952056066919f1ebc7897ff9bd71b1"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["043df2e9a841864922c32756a44c939ed768cb89","b6284684320a9808c41a5e43de958b2da22f89bd"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","30c8e5574b55d57947e989443dfde611646530ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}