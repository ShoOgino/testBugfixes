{"path":"lucene/core/src/test/org/apache/lucene/index/TestRandomStoredFields#testRandomStoredFields().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestRandomStoredFields#testRandomStoredFields().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestRandomStoredFields#testRandomStoredFields().mjava","sourceNew":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random;\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(_TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setUseCompoundFile(false);\n    final int docCount = atLeast(200);\n    final int fieldCount = _TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<Integer>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<String,Document>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = _TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs);\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random;\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(_TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setUseCompoundFile(false);\n    final int docCount = atLeast(200);\n    final int fieldCount = _TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<Integer>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<String,Document>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = _TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs);\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a78a90fc9701e511308346ea29f4f5e548bb39fe","date":1329489995,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestRandomStoredFields#testRandomStoredFields().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestRandomStoredFields#testRandomStoredFields().mjava","sourceNew":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random;\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(_TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setUseCompoundFile(false);\n    final int docCount = atLeast(200);\n    final int fieldCount = _TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<Integer>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<String,Document>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = _TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs);\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random;\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(_TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setUseCompoundFile(false);\n    final int docCount = atLeast(200);\n    final int fieldCount = _TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<Integer>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<String,Document>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = _TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs);\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","bugFix":["57d5dad190acf63cb17e05df3882de97b1105c1c"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestRandomStoredFields#testRandomStoredFields().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestRandomStoredFields#testRandomStoredFields().mjava","sourceNew":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(_TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setUseCompoundFile(false);\n    final int docCount = atLeast(200);\n    final int fieldCount = _TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<Integer>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<String,Document>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = _TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs);\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random;\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(_TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setUseCompoundFile(false);\n    final int docCount = atLeast(200);\n    final int fieldCount = _TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<Integer>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<String,Document>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = _TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs);\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8f0e28f2a7f0f3f0fca1a2ffedaa10c7ac9536c4","date":1341839195,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestRandomStoredFields#testRandomStoredFields().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestRandomStoredFields#testRandomStoredFields().mjava","sourceNew":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(_TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setUseCompoundFile(false);\n    final int docCount = atLeast(200);\n    final int fieldCount = _TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<Integer>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<String,Document>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = _TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs);\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          StoredDocument doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(_TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setUseCompoundFile(false);\n    final int docCount = atLeast(200);\n    final int fieldCount = _TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<Integer>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<String,Document>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = _TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs);\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1d028314cced5858683a1bb4741423d0f934257b","date":1346596535,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestRandomStoredFields#testRandomStoredFields().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestRandomStoredFields#testRandomStoredFields().mjava","sourceNew":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(_TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setUseCompoundFile(false);\n    final int docCount = atLeast(200);\n    final int fieldCount = _TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<Integer>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<String,Document>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = _TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs);\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          StoredDocument doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(_TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setUseCompoundFile(false);\n    final int docCount = atLeast(200);\n    final int fieldCount = _TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<Integer>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<String,Document>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = _TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs);\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"70b55953b6a72596cb534ead735a8b849a473cac","date":1363634568,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase#testRandomStoredFields().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestRandomStoredFields#testRandomStoredFields().mjava","sourceNew":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(_TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setUseCompoundFile(false);\n    final int docCount = atLeast(200);\n    final int fieldCount = _TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<Integer>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<String,Document>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = _TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs);\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          StoredDocument doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(_TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setUseCompoundFile(false);\n    final int docCount = atLeast(200);\n    final int fieldCount = _TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<Integer>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<String,Document>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = _TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs);\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          StoredDocument doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a78a90fc9701e511308346ea29f4f5e548bb39fe":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"8f0e28f2a7f0f3f0fca1a2ffedaa10c7ac9536c4":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"1d028314cced5858683a1bb4741423d0f934257b":["629c38c4ae4e303d0617e05fbfe508140b32f0a3","8f0e28f2a7f0f3f0fca1a2ffedaa10c7ac9536c4"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"70b55953b6a72596cb534ead735a8b849a473cac":["1d028314cced5858683a1bb4741423d0f934257b"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["70b55953b6a72596cb534ead735a8b849a473cac"]},"commit2Childs":{"a78a90fc9701e511308346ea29f4f5e548bb39fe":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"8f0e28f2a7f0f3f0fca1a2ffedaa10c7ac9536c4":["1d028314cced5858683a1bb4741423d0f934257b"],"1d028314cced5858683a1bb4741423d0f934257b":["70b55953b6a72596cb534ead735a8b849a473cac"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a78a90fc9701e511308346ea29f4f5e548bb39fe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"70b55953b6a72596cb534ead735a8b849a473cac":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["8f0e28f2a7f0f3f0fca1a2ffedaa10c7ac9536c4","1d028314cced5858683a1bb4741423d0f934257b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}