{"path":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long,BytesReader,Arc[Long],Arc[Long],IntsRefBuilder).mjava","commits":[{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long,BytesReader,Arc[Long],Arc[Long],IntsRefBuilder).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long,BytesReader,Arc[Long],Arc[Long],IntsRef).mjava","sourceNew":"  /** \n   * Expert: like {@link Util#getByOutput(FST, long)} except reusing \n   * BytesReader, initial and scratch Arc, and result.\n   */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput, BytesReader in, Arc<Long> arc, Arc<Long> scratchArc, IntsRefBuilder result) throws IOException {\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.setLength(upto);\n          //System.out.println(\"    found!\");\n          return result.get();\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        result.grow(1+upto);\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.setPosition(arc.posArcsStart);\n            in.skipBytes(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" label=\" + (char) label + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.setIntAt(upto++, arc.label);\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.setIntAt(upto++, arc.label);\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.setIntAt(upto++, arc.label);\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.setIntAt(upto++, arc.label);\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","sourceOld":"  /** \n   * Expert: like {@link Util#getByOutput(FST, long)} except reusing \n   * BytesReader, initial and scratch Arc, and result.\n   */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput, BytesReader in, Arc<Long> arc, Arc<Long> scratchArc, IntsRef result) throws IOException {\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.length = upto;\n          //System.out.println(\"    found!\");\n          return result;\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        if (result.ints.length == upto) {\n          result.grow(1+upto);\n        }\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.setPosition(arc.posArcsStart);\n            in.skipBytes(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" label=\" + (char) label + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.ints[upto++] = arc.label;\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.ints[upto++] = arc.label;\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.ints[upto++] = arc.label;\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.ints[upto++] = arc.label;\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae67e1f82a53594208ca929f382ee861dad3d7a8","date":1557134375,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long,BytesReader,Arc[Long],Arc[Long],IntsRefBuilder).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long,BytesReader,Arc[Long],Arc[Long],IntsRefBuilder).mjava","sourceNew":"  /** \n   * Expert: like {@link Util#getByOutput(FST, long)} except reusing \n   * BytesReader, initial and scratch Arc, and result.\n   */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput, BytesReader in, Arc<Long> arc, Arc<Long> scratchArc, IntsRefBuilder result) throws IOException {\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.setLength(upto);\n          //System.out.println(\"    found!\");\n          return result.get();\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        result.grow(1+upto);\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0 && arc.arcIdx > Integer.MIN_VALUE) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.setPosition(arc.posArcsStart);\n            in.skipBytes(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.setIntAt(upto++, arc.label);\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.setIntAt(upto++, arc.label);\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.setIntAt(upto++, arc.label);\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.setIntAt(upto++, arc.label);\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","sourceOld":"  /** \n   * Expert: like {@link Util#getByOutput(FST, long)} except reusing \n   * BytesReader, initial and scratch Arc, and result.\n   */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput, BytesReader in, Arc<Long> arc, Arc<Long> scratchArc, IntsRefBuilder result) throws IOException {\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.setLength(upto);\n          //System.out.println(\"    found!\");\n          return result.get();\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        result.grow(1+upto);\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.setPosition(arc.posArcsStart);\n            in.skipBytes(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" label=\" + (char) label + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.setIntAt(upto++, arc.label);\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.setIntAt(upto++, arc.label);\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.setIntAt(upto++, arc.label);\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.setIntAt(upto++, arc.label);\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"723b1fb5f51ea75fafffc4b062c9dab819d9bd37","date":1562204013,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long,BytesReader,Arc[Long],Arc[Long],IntsRefBuilder).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long,BytesReader,Arc[Long],Arc[Long],IntsRefBuilder).mjava","sourceNew":"  /** \n   * Expert: like {@link Util#getByOutput(FST, long)} except reusing \n   * BytesReader, initial and scratch Arc, and result.\n   */\n  @Deprecated\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput, BytesReader in, Arc<Long> arc, Arc<Long> scratchArc, IntsRefBuilder result) throws IOException {\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.setLength(upto);\n          //System.out.println(\"    found!\");\n          return result.get();\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        result.grow(1+upto);\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0 && arc.arcIdx > Integer.MIN_VALUE) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.setPosition(arc.posArcsStart);\n            in.skipBytes(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.setIntAt(upto++, arc.label);\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.setIntAt(upto++, arc.label);\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.setIntAt(upto++, arc.label);\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.setIntAt(upto++, arc.label);\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","sourceOld":"  /** \n   * Expert: like {@link Util#getByOutput(FST, long)} except reusing \n   * BytesReader, initial and scratch Arc, and result.\n   */\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput, BytesReader in, Arc<Long> arc, Arc<Long> scratchArc, IntsRefBuilder result) throws IOException {\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.setLength(upto);\n          //System.out.println(\"    found!\");\n          return result.get();\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        result.grow(1+upto);\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0 && arc.arcIdx > Integer.MIN_VALUE) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.setPosition(arc.posArcsStart);\n            in.skipBytes(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.setIntAt(upto++, arc.label);\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.setIntAt(upto++, arc.label);\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.setIntAt(upto++, arc.label);\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.setIntAt(upto++, arc.label);\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54204c8a3ca26aeafd273139fc29baf70d0f6786","date":1564170395,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long,BytesReader,Arc[Long],Arc[Long],IntsRefBuilder).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long,BytesReader,Arc[Long],Arc[Long],IntsRefBuilder).mjava","sourceNew":"  /** \n   * Expert: like {@link Util#getByOutput(FST, long)} except reusing \n   * BytesReader, initial and scratch Arc, and result.\n   */\n  @Deprecated\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput, BytesReader in, Arc<Long> arc, Arc<Long> scratchArc, IntsRefBuilder result) throws IOException {\n    long output = arc.output();\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput();\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.setLength(upto);\n          //System.out.println(\"    found!\");\n          return result.get();\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        result.grow(1+upto);\n        \n        fst.readFirstRealTargetArc(arc.target(), arc, in);\n\n        if (arc.bytesPerArc() != 0 && arc.arcIdx() > Integer.MIN_VALUE) {\n\n          int low = 0;\n          int high = arc.numArcs() -1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.setPosition(arc.posArcsStart());\n            in.skipBytes(arc.bytesPerArc() *mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          int idx;\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            idx = mid;\n          } else {\n            idx = low - 1;\n          }\n\n          arc.arcIdx(idx - 1);\n          fst.readNextRealArc(arc, in);\n          result.setIntAt(upto++, arc.label());\n          output += arc.output();\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output();\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.setIntAt(upto++, arc.label());\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.setIntAt(upto++, arc.label());\n                output += arc.output();\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.setIntAt(upto++, arc.label());\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","sourceOld":"  /** \n   * Expert: like {@link Util#getByOutput(FST, long)} except reusing \n   * BytesReader, initial and scratch Arc, and result.\n   */\n  @Deprecated\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput, BytesReader in, Arc<Long> arc, Arc<Long> scratchArc, IntsRefBuilder result) throws IOException {\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.setLength(upto);\n          //System.out.println(\"    found!\");\n          return result.get();\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        result.grow(1+upto);\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0 && arc.arcIdx > Integer.MIN_VALUE) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.setPosition(arc.posArcsStart);\n            in.skipBytes(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.setIntAt(upto++, arc.label);\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.setIntAt(upto++, arc.label);\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.setIntAt(upto++, arc.label);\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.setIntAt(upto++, arc.label);\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f9b7d62e1503063c6f8cd0aeaa3ca4f8428cd244","date":1564170395,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long,BytesReader,Arc[Long],Arc[Long],IntsRefBuilder).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long,BytesReader,Arc[Long],Arc[Long],IntsRefBuilder).mjava","sourceNew":"  /** \n   * Expert: like {@link Util#getByOutput(FST, long)} except reusing \n   * BytesReader, initial and scratch Arc, and result.\n   */\n  @Deprecated\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput, BytesReader in, Arc<Long> arc, Arc<Long> scratchArc, IntsRefBuilder result) throws IOException {\n    long output = arc.output();\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput();\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.setLength(upto);\n          //System.out.println(\"    found!\");\n          return result.get();\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        result.grow(1+upto);\n        \n        fst.readFirstRealTargetArc(arc.target(), arc, in);\n\n        if (arc.bytesPerArc() != 0 && arc.arcIdx() > Integer.MIN_VALUE) {\n\n          int low = 0;\n          int high = arc.numArcs() -1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.setPosition(arc.posArcsStart());\n            in.skipBytes(arc.bytesPerArc() *mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          int idx;\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            idx = mid;\n          } else {\n            idx = low - 1;\n          }\n\n          fst.readArcByIndex(arc, in, idx);\n          result.setIntAt(upto++, arc.label());\n          output += arc.output();\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output();\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.setIntAt(upto++, arc.label());\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.setIntAt(upto++, arc.label());\n                output += arc.output();\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.setIntAt(upto++, arc.label());\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","sourceOld":"  /** \n   * Expert: like {@link Util#getByOutput(FST, long)} except reusing \n   * BytesReader, initial and scratch Arc, and result.\n   */\n  @Deprecated\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput, BytesReader in, Arc<Long> arc, Arc<Long> scratchArc, IntsRefBuilder result) throws IOException {\n    long output = arc.output();\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput();\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.setLength(upto);\n          //System.out.println(\"    found!\");\n          return result.get();\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        result.grow(1+upto);\n        \n        fst.readFirstRealTargetArc(arc.target(), arc, in);\n\n        if (arc.bytesPerArc() != 0 && arc.arcIdx() > Integer.MIN_VALUE) {\n\n          int low = 0;\n          int high = arc.numArcs() -1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.setPosition(arc.posArcsStart());\n            in.skipBytes(arc.bytesPerArc() *mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          int idx;\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            idx = mid;\n          } else {\n            idx = low - 1;\n          }\n\n          arc.arcIdx(idx - 1);\n          fst.readNextRealArc(arc, in);\n          result.setIntAt(upto++, arc.label());\n          output += arc.output();\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output();\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.setIntAt(upto++, arc.label());\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.setIntAt(upto++, arc.label());\n                output += arc.output();\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.setIntAt(upto++, arc.label());\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8061ddd97f3352007d927dae445884a6f3d857b","date":1564988276,"type":3,"author":"Atri Sharma","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long,BytesReader,Arc[Long],Arc[Long],IntsRefBuilder).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long,BytesReader,Arc[Long],Arc[Long],IntsRefBuilder).mjava","sourceNew":"  /** \n   * Expert: like {@link Util#getByOutput(FST, long)} except reusing \n   * BytesReader, initial and scratch Arc, and result.\n   */\n  @Deprecated\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput, BytesReader in, Arc<Long> arc, Arc<Long> scratchArc, IntsRefBuilder result) throws IOException {\n    long output = arc.output();\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput();\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.setLength(upto);\n          //System.out.println(\"    found!\");\n          return result.get();\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        result.grow(1+upto);\n        \n        fst.readFirstRealTargetArc(arc.target(), arc, in);\n\n        if (arc.bytesPerArc() != 0 && arc.arcIdx() > Integer.MIN_VALUE) {\n\n          int low = 0;\n          int high = arc.numArcs() -1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.setPosition(arc.posArcsStart());\n            in.skipBytes(arc.bytesPerArc() *mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          int idx;\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            idx = mid;\n          } else {\n            idx = low - 1;\n          }\n\n          fst.readArcByIndex(arc, in, idx);\n          result.setIntAt(upto++, arc.label());\n          output += arc.output();\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output();\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.setIntAt(upto++, arc.label());\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.setIntAt(upto++, arc.label());\n                output += arc.output();\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.setIntAt(upto++, arc.label());\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","sourceOld":"  /** \n   * Expert: like {@link Util#getByOutput(FST, long)} except reusing \n   * BytesReader, initial and scratch Arc, and result.\n   */\n  @Deprecated\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput, BytesReader in, Arc<Long> arc, Arc<Long> scratchArc, IntsRefBuilder result) throws IOException {\n    long output = arc.output;\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput;\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.setLength(upto);\n          //System.out.println(\"    found!\");\n          return result.get();\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        result.grow(1+upto);\n        \n        fst.readFirstRealTargetArc(arc.target, arc, in);\n\n        if (arc.bytesPerArc != 0 && arc.arcIdx > Integer.MIN_VALUE) {\n\n          int low = 0;\n          int high = arc.numArcs-1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.setPosition(arc.posArcsStart);\n            in.skipBytes(arc.bytesPerArc*mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            arc.arcIdx = mid-1;\n          } else {\n            arc.arcIdx = low-2;\n          }\n\n          fst.readNextRealArc(arc, in);\n          result.setIntAt(upto++, arc.label);\n          output += arc.output;\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output;\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.setIntAt(upto++, arc.label);\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.setIntAt(upto++, arc.label);\n                output += arc.output;\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.setIntAt(upto++, arc.label);\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"71d31a7d5773508492505519bb5230b87c8937ad","date":1573681693,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long,BytesReader,Arc[Long],Arc[Long],IntsRefBuilder).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#getByOutput(FST[Long],long,BytesReader,Arc[Long],Arc[Long],IntsRefBuilder).mjava","sourceNew":"  /** \n   * Expert: like {@link Util#getByOutput(FST, long)} except reusing \n   * BytesReader, initial and scratch Arc, and result.\n   */\n  @Deprecated\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput, BytesReader in, Arc<Long> arc, Arc<Long> scratchArc, IntsRefBuilder result) throws IOException {\n    long output = arc.output();\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput();\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.setLength(upto);\n          //System.out.println(\"    found!\");\n          return result.get();\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        result.grow(1+upto);\n        \n        fst.readFirstRealTargetArc(arc.target(), arc, in);\n\n        if (arc.bytesPerArc() != 0 && arc.nodeFlags() == FST.ARCS_FOR_BINARY_SEARCH) {\n\n          int low = 0;\n          int high = arc.numArcs() -1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.setPosition(arc.posArcsStart());\n            in.skipBytes(arc.bytesPerArc() *mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          int idx;\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            idx = mid;\n          } else {\n            idx = low - 1;\n          }\n\n          fst.readArcByIndex(arc, in, idx);\n          result.setIntAt(upto++, arc.label());\n          output += arc.output();\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output();\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.setIntAt(upto++, arc.label());\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.setIntAt(upto++, arc.label());\n                output += arc.output();\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.setIntAt(upto++, arc.label());\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","sourceOld":"  /** \n   * Expert: like {@link Util#getByOutput(FST, long)} except reusing \n   * BytesReader, initial and scratch Arc, and result.\n   */\n  @Deprecated\n  public static IntsRef getByOutput(FST<Long> fst, long targetOutput, BytesReader in, Arc<Long> arc, Arc<Long> scratchArc, IntsRefBuilder result) throws IOException {\n    long output = arc.output();\n    int upto = 0;\n\n    //System.out.println(\"reverseLookup output=\" + targetOutput);\n\n    while(true) {\n      //System.out.println(\"loop: output=\" + output + \" upto=\" + upto + \" arc=\" + arc);\n      if (arc.isFinal()) {\n        final long finalOutput = output + arc.nextFinalOutput();\n        //System.out.println(\"  isFinal finalOutput=\" + finalOutput);\n        if (finalOutput == targetOutput) {\n          result.setLength(upto);\n          //System.out.println(\"    found!\");\n          return result.get();\n        } else if (finalOutput > targetOutput) {\n          //System.out.println(\"    not found!\");\n          return null;\n        }\n      }\n\n      if (FST.targetHasArcs(arc)) {\n        //System.out.println(\"  targetHasArcs\");\n        result.grow(1+upto);\n        \n        fst.readFirstRealTargetArc(arc.target(), arc, in);\n\n        if (arc.bytesPerArc() != 0 && arc.arcIdx() > Integer.MIN_VALUE) {\n\n          int low = 0;\n          int high = arc.numArcs() -1;\n          int mid = 0;\n          //System.out.println(\"bsearch: numArcs=\" + arc.numArcs + \" target=\" + targetOutput + \" output=\" + output);\n          boolean exact = false;\n          while (low <= high) {\n            mid = (low + high) >>> 1;\n            in.setPosition(arc.posArcsStart());\n            in.skipBytes(arc.bytesPerArc() *mid);\n            final byte flags = in.readByte();\n            fst.readLabel(in);\n            final long minArcOutput;\n            if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {\n              final long arcOutput = fst.outputs.read(in);\n              minArcOutput = output + arcOutput;\n            } else {\n              minArcOutput = output;\n            }\n            //System.out.println(\"  cycle mid=\" + mid + \" output=\" + minArcOutput);\n            if (minArcOutput == targetOutput) {\n              exact = true;\n              break;\n            } else if (minArcOutput < targetOutput) {\n              low = mid + 1;\n            } else {\n              high = mid - 1;\n            }\n          }\n\n          int idx;\n          if (high == -1) {\n            return null;\n          } else if (exact) {\n            idx = mid;\n          } else {\n            idx = low - 1;\n          }\n\n          fst.readArcByIndex(arc, in, idx);\n          result.setIntAt(upto++, arc.label());\n          output += arc.output();\n\n        } else {\n\n          FST.Arc<Long> prevArc = null;\n\n          while(true) {\n            //System.out.println(\"    cycle label=\" + arc.label + \" output=\" + arc.output);\n\n            // This is the min output we'd hit if we follow\n            // this arc:\n            final long minArcOutput = output + arc.output();\n\n            if (minArcOutput == targetOutput) {\n              // Recurse on this arc:\n              //System.out.println(\"  match!  break\");\n              output = minArcOutput;\n              result.setIntAt(upto++, arc.label());\n              break;\n            } else if (minArcOutput > targetOutput) {\n              if (prevArc == null) {\n                // Output doesn't exist\n                return null;\n              } else {\n                // Recurse on previous arc:\n                arc.copyFrom(prevArc);\n                result.setIntAt(upto++, arc.label());\n                output += arc.output();\n                //System.out.println(\"    recurse prev label=\" + (char) arc.label + \" output=\" + output);\n                break;\n              }\n            } else if (arc.isLast()) {\n              // Recurse on this arc:\n              output = minArcOutput;\n              //System.out.println(\"    recurse last label=\" + (char) arc.label + \" output=\" + output);\n              result.setIntAt(upto++, arc.label());\n              break;\n            } else {\n              // Read next arc in this node:\n              prevArc = scratchArc;\n              prevArc.copyFrom(arc);\n              //System.out.println(\"      after copy label=\" + (char) prevArc.label + \" vs \" + (char) arc.label);\n              fst.readNextRealArc(arc, in);\n            }\n          }\n        }\n      } else {\n        //System.out.println(\"  no target arcs; not found!\");\n        return null;\n      }\n    }    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54204c8a3ca26aeafd273139fc29baf70d0f6786":["723b1fb5f51ea75fafffc4b062c9dab819d9bd37"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f9b7d62e1503063c6f8cd0aeaa3ca4f8428cd244":["54204c8a3ca26aeafd273139fc29baf70d0f6786"],"723b1fb5f51ea75fafffc4b062c9dab819d9bd37":["ae67e1f82a53594208ca929f382ee861dad3d7a8"],"71d31a7d5773508492505519bb5230b87c8937ad":["f9b7d62e1503063c6f8cd0aeaa3ca4f8428cd244"],"ae67e1f82a53594208ca929f382ee861dad3d7a8":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f8061ddd97f3352007d927dae445884a6f3d857b":["723b1fb5f51ea75fafffc4b062c9dab819d9bd37","f9b7d62e1503063c6f8cd0aeaa3ca4f8428cd244"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["71d31a7d5773508492505519bb5230b87c8937ad"]},"commit2Childs":{"54204c8a3ca26aeafd273139fc29baf70d0f6786":["f9b7d62e1503063c6f8cd0aeaa3ca4f8428cd244"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"f9b7d62e1503063c6f8cd0aeaa3ca4f8428cd244":["71d31a7d5773508492505519bb5230b87c8937ad","f8061ddd97f3352007d927dae445884a6f3d857b"],"723b1fb5f51ea75fafffc4b062c9dab819d9bd37":["54204c8a3ca26aeafd273139fc29baf70d0f6786","f8061ddd97f3352007d927dae445884a6f3d857b"],"ae67e1f82a53594208ca929f382ee861dad3d7a8":["723b1fb5f51ea75fafffc4b062c9dab819d9bd37"],"71d31a7d5773508492505519bb5230b87c8937ad":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["ae67e1f82a53594208ca929f382ee861dad3d7a8"],"f8061ddd97f3352007d927dae445884a6f3d857b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["f8061ddd97f3352007d927dae445884a6f3d857b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}