{"path":"lucene/core/src/java/org/apache/lucene/index/ParallelCompositeReader#prepareSubReaders(CompositeReader[],CompositeReader[]).mjava","commits":[{"id":"6e09a3a223be07d75777515a717312813221fe58","date":1328908385,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelCompositeReader#prepareSubReaders(CompositeReader[],CompositeReader[]).mjava","pathOld":"/dev/null","sourceNew":"  private static IndexReader[] prepareSubReaders(CompositeReader[] readers, CompositeReader[] storedFieldsReaders) throws IOException {\n    if (readers.length == 0) {\n      if (storedFieldsReaders.length > 0)\n        throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n      return new IndexReader[0];\n    } else {\n      final IndexReader[] firstSubReaders = readers[0].getSequentialSubReaders();\n\n      // check compatibility:\n      final int maxDoc = readers[0].maxDoc();\n      final int[] childMaxDoc = new int[firstSubReaders.length];\n      for (int i = 0; i < firstSubReaders.length; i++) {\n        childMaxDoc[i] = firstSubReaders[i].maxDoc();\n      }\n      validate(readers, maxDoc, childMaxDoc);\n      validate(storedFieldsReaders, maxDoc, childMaxDoc);\n\n      // hierarchically build the same subreader structure as the first CompositeReader with Parallel*Readers:\n      final IndexReader[] subReaders = new IndexReader[firstSubReaders.length];\n      for (int i = 0; i < subReaders.length; i++) {\n        if (firstSubReaders[i] instanceof AtomicReader) {\n          final AtomicReader[] atomicSubs = new AtomicReader[readers.length];\n          for (int j = 0; j < readers.length; j++) {\n            atomicSubs[j] = (AtomicReader) readers[j].getSequentialSubReaders()[i];\n          }\n          final AtomicReader[] storedSubs = new AtomicReader[storedFieldsReaders.length];\n          for (int j = 0; j < storedFieldsReaders.length; j++) {\n            storedSubs[j] = (AtomicReader) storedFieldsReaders[j].getSequentialSubReaders()[i];\n          }\n          // we simply enable closing of subReaders, to prevent incRefs on subReaders\n          // -> for synthetic subReaders, close() is never\n          // called by our doClose()\n          subReaders[i] = new ParallelAtomicReader(true, atomicSubs, storedSubs);\n        } else {\n          assert firstSubReaders[i] instanceof CompositeReader;\n          final CompositeReader[] compositeSubs = new CompositeReader[readers.length];\n          for (int j = 0; j < readers.length; j++) {\n            compositeSubs[j] = (CompositeReader) readers[j].getSequentialSubReaders()[i];\n          }\n          final CompositeReader[] storedSubs = new CompositeReader[storedFieldsReaders.length];\n          for (int j = 0; j < storedFieldsReaders.length; j++) {\n            storedSubs[j] = (CompositeReader) storedFieldsReaders[j].getSequentialSubReaders()[i];\n          }\n          // we simply enable closing of subReaders, to prevent incRefs on subReaders\n          // -> for synthetic subReaders, close() is never called by our doClose()\n          subReaders[i] = new ParallelCompositeReader(true, compositeSubs, storedSubs);\n        }\n      }\n      return subReaders;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["48180ea0d6210cab36e06798b916a39e0607713b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8be807b98a5aab36b690a9bd4ef0e4b5d33b8689","date":1329492225,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelCompositeReader#prepareSubReaders(CompositeReader[],CompositeReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelCompositeReader#prepareSubReaders(CompositeReader[],CompositeReader[]).mjava","sourceNew":"  private static IndexReader[] prepareSubReaders(CompositeReader[] readers, CompositeReader[] storedFieldsReaders) throws IOException {\n    if (readers.length == 0) {\n      if (storedFieldsReaders.length > 0)\n        throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n      return new IndexReader[0];\n    } else {\n      final IndexReader[] firstSubReaders = readers[0].getSequentialSubReaders();\n\n      // check compatibility:\n      final int maxDoc = readers[0].maxDoc();\n      final int[] childMaxDoc = new int[firstSubReaders.length];\n      final boolean[] childAtomic = new boolean[firstSubReaders.length];\n      for (int i = 0; i < firstSubReaders.length; i++) {\n        childMaxDoc[i] = firstSubReaders[i].maxDoc();\n        childAtomic[i] = firstSubReaders[i] instanceof AtomicReader;\n      }\n      validate(readers, maxDoc, childMaxDoc, childAtomic);\n      validate(storedFieldsReaders, maxDoc, childMaxDoc, childAtomic);\n\n      // hierarchically build the same subreader structure as the first CompositeReader with Parallel*Readers:\n      final IndexReader[] subReaders = new IndexReader[firstSubReaders.length];\n      for (int i = 0; i < subReaders.length; i++) {\n        if (firstSubReaders[i] instanceof AtomicReader) {\n          final AtomicReader[] atomicSubs = new AtomicReader[readers.length];\n          for (int j = 0; j < readers.length; j++) {\n            atomicSubs[j] = (AtomicReader) readers[j].getSequentialSubReaders()[i];\n          }\n          final AtomicReader[] storedSubs = new AtomicReader[storedFieldsReaders.length];\n          for (int j = 0; j < storedFieldsReaders.length; j++) {\n            storedSubs[j] = (AtomicReader) storedFieldsReaders[j].getSequentialSubReaders()[i];\n          }\n          // we simply enable closing of subReaders, to prevent incRefs on subReaders\n          // -> for synthetic subReaders, close() is never\n          // called by our doClose()\n          subReaders[i] = new ParallelAtomicReader(true, atomicSubs, storedSubs);\n        } else {\n          assert firstSubReaders[i] instanceof CompositeReader;\n          final CompositeReader[] compositeSubs = new CompositeReader[readers.length];\n          for (int j = 0; j < readers.length; j++) {\n            compositeSubs[j] = (CompositeReader) readers[j].getSequentialSubReaders()[i];\n          }\n          final CompositeReader[] storedSubs = new CompositeReader[storedFieldsReaders.length];\n          for (int j = 0; j < storedFieldsReaders.length; j++) {\n            storedSubs[j] = (CompositeReader) storedFieldsReaders[j].getSequentialSubReaders()[i];\n          }\n          // we simply enable closing of subReaders, to prevent incRefs on subReaders\n          // -> for synthetic subReaders, close() is never called by our doClose()\n          subReaders[i] = new ParallelCompositeReader(true, compositeSubs, storedSubs);\n        }\n      }\n      return subReaders;\n    }\n  }\n\n","sourceOld":"  private static IndexReader[] prepareSubReaders(CompositeReader[] readers, CompositeReader[] storedFieldsReaders) throws IOException {\n    if (readers.length == 0) {\n      if (storedFieldsReaders.length > 0)\n        throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n      return new IndexReader[0];\n    } else {\n      final IndexReader[] firstSubReaders = readers[0].getSequentialSubReaders();\n\n      // check compatibility:\n      final int maxDoc = readers[0].maxDoc();\n      final int[] childMaxDoc = new int[firstSubReaders.length];\n      for (int i = 0; i < firstSubReaders.length; i++) {\n        childMaxDoc[i] = firstSubReaders[i].maxDoc();\n      }\n      validate(readers, maxDoc, childMaxDoc);\n      validate(storedFieldsReaders, maxDoc, childMaxDoc);\n\n      // hierarchically build the same subreader structure as the first CompositeReader with Parallel*Readers:\n      final IndexReader[] subReaders = new IndexReader[firstSubReaders.length];\n      for (int i = 0; i < subReaders.length; i++) {\n        if (firstSubReaders[i] instanceof AtomicReader) {\n          final AtomicReader[] atomicSubs = new AtomicReader[readers.length];\n          for (int j = 0; j < readers.length; j++) {\n            atomicSubs[j] = (AtomicReader) readers[j].getSequentialSubReaders()[i];\n          }\n          final AtomicReader[] storedSubs = new AtomicReader[storedFieldsReaders.length];\n          for (int j = 0; j < storedFieldsReaders.length; j++) {\n            storedSubs[j] = (AtomicReader) storedFieldsReaders[j].getSequentialSubReaders()[i];\n          }\n          // we simply enable closing of subReaders, to prevent incRefs on subReaders\n          // -> for synthetic subReaders, close() is never\n          // called by our doClose()\n          subReaders[i] = new ParallelAtomicReader(true, atomicSubs, storedSubs);\n        } else {\n          assert firstSubReaders[i] instanceof CompositeReader;\n          final CompositeReader[] compositeSubs = new CompositeReader[readers.length];\n          for (int j = 0; j < readers.length; j++) {\n            compositeSubs[j] = (CompositeReader) readers[j].getSequentialSubReaders()[i];\n          }\n          final CompositeReader[] storedSubs = new CompositeReader[storedFieldsReaders.length];\n          for (int j = 0; j < storedFieldsReaders.length; j++) {\n            storedSubs[j] = (CompositeReader) storedFieldsReaders[j].getSequentialSubReaders()[i];\n          }\n          // we simply enable closing of subReaders, to prevent incRefs on subReaders\n          // -> for synthetic subReaders, close() is never called by our doClose()\n          subReaders[i] = new ParallelCompositeReader(true, compositeSubs, storedSubs);\n        }\n      }\n      return subReaders;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","date":1340090669,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelCompositeReader#prepareSubReaders(CompositeReader[],CompositeReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelCompositeReader#prepareSubReaders(CompositeReader[],CompositeReader[]).mjava","sourceNew":"  private static IndexReader[] prepareSubReaders(CompositeReader[] readers, CompositeReader[] storedFieldsReaders) throws IOException {\n    if (readers.length == 0) {\n      if (storedFieldsReaders.length > 0)\n        throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n      return new IndexReader[0];\n    } else {\n      final List<? extends IndexReader> firstSubReaders = readers[0].getSequentialSubReaders();\n\n      // check compatibility:\n      final int maxDoc = readers[0].maxDoc(), noSubs = firstSubReaders.size();\n      final int[] childMaxDoc = new int[noSubs];\n      final boolean[] childAtomic = new boolean[noSubs];\n      for (int i = 0; i < noSubs; i++) {\n        final IndexReader r = firstSubReaders.get(i);\n        childMaxDoc[i] = r.maxDoc();\n        childAtomic[i] = r instanceof AtomicReader;\n      }\n      validate(readers, maxDoc, childMaxDoc, childAtomic);\n      validate(storedFieldsReaders, maxDoc, childMaxDoc, childAtomic);\n\n      // hierarchically build the same subreader structure as the first CompositeReader with Parallel*Readers:\n      final IndexReader[] subReaders = new IndexReader[noSubs];\n      for (int i = 0; i < subReaders.length; i++) {\n        if (firstSubReaders.get(i) instanceof AtomicReader) {\n          final AtomicReader[] atomicSubs = new AtomicReader[readers.length];\n          for (int j = 0; j < readers.length; j++) {\n            atomicSubs[j] = (AtomicReader) readers[j].getSequentialSubReaders().get(i);\n          }\n          final AtomicReader[] storedSubs = new AtomicReader[storedFieldsReaders.length];\n          for (int j = 0; j < storedFieldsReaders.length; j++) {\n            storedSubs[j] = (AtomicReader) storedFieldsReaders[j].getSequentialSubReaders().get(i);\n          }\n          // we simply enable closing of subReaders, to prevent incRefs on subReaders\n          // -> for synthetic subReaders, close() is never\n          // called by our doClose()\n          subReaders[i] = new ParallelAtomicReader(true, atomicSubs, storedSubs);\n        } else {\n          assert firstSubReaders.get(i) instanceof CompositeReader;\n          final CompositeReader[] compositeSubs = new CompositeReader[readers.length];\n          for (int j = 0; j < readers.length; j++) {\n            compositeSubs[j] = (CompositeReader) readers[j].getSequentialSubReaders().get(i);\n          }\n          final CompositeReader[] storedSubs = new CompositeReader[storedFieldsReaders.length];\n          for (int j = 0; j < storedFieldsReaders.length; j++) {\n            storedSubs[j] = (CompositeReader) storedFieldsReaders[j].getSequentialSubReaders().get(i);\n          }\n          // we simply enable closing of subReaders, to prevent incRefs on subReaders\n          // -> for synthetic subReaders, close() is never called by our doClose()\n          subReaders[i] = new ParallelCompositeReader(true, compositeSubs, storedSubs);\n        }\n      }\n      return subReaders;\n    }\n  }\n\n","sourceOld":"  private static IndexReader[] prepareSubReaders(CompositeReader[] readers, CompositeReader[] storedFieldsReaders) throws IOException {\n    if (readers.length == 0) {\n      if (storedFieldsReaders.length > 0)\n        throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n      return new IndexReader[0];\n    } else {\n      final IndexReader[] firstSubReaders = readers[0].getSequentialSubReaders();\n\n      // check compatibility:\n      final int maxDoc = readers[0].maxDoc();\n      final int[] childMaxDoc = new int[firstSubReaders.length];\n      final boolean[] childAtomic = new boolean[firstSubReaders.length];\n      for (int i = 0; i < firstSubReaders.length; i++) {\n        childMaxDoc[i] = firstSubReaders[i].maxDoc();\n        childAtomic[i] = firstSubReaders[i] instanceof AtomicReader;\n      }\n      validate(readers, maxDoc, childMaxDoc, childAtomic);\n      validate(storedFieldsReaders, maxDoc, childMaxDoc, childAtomic);\n\n      // hierarchically build the same subreader structure as the first CompositeReader with Parallel*Readers:\n      final IndexReader[] subReaders = new IndexReader[firstSubReaders.length];\n      for (int i = 0; i < subReaders.length; i++) {\n        if (firstSubReaders[i] instanceof AtomicReader) {\n          final AtomicReader[] atomicSubs = new AtomicReader[readers.length];\n          for (int j = 0; j < readers.length; j++) {\n            atomicSubs[j] = (AtomicReader) readers[j].getSequentialSubReaders()[i];\n          }\n          final AtomicReader[] storedSubs = new AtomicReader[storedFieldsReaders.length];\n          for (int j = 0; j < storedFieldsReaders.length; j++) {\n            storedSubs[j] = (AtomicReader) storedFieldsReaders[j].getSequentialSubReaders()[i];\n          }\n          // we simply enable closing of subReaders, to prevent incRefs on subReaders\n          // -> for synthetic subReaders, close() is never\n          // called by our doClose()\n          subReaders[i] = new ParallelAtomicReader(true, atomicSubs, storedSubs);\n        } else {\n          assert firstSubReaders[i] instanceof CompositeReader;\n          final CompositeReader[] compositeSubs = new CompositeReader[readers.length];\n          for (int j = 0; j < readers.length; j++) {\n            compositeSubs[j] = (CompositeReader) readers[j].getSequentialSubReaders()[i];\n          }\n          final CompositeReader[] storedSubs = new CompositeReader[storedFieldsReaders.length];\n          for (int j = 0; j < storedFieldsReaders.length; j++) {\n            storedSubs[j] = (CompositeReader) storedFieldsReaders[j].getSequentialSubReaders()[i];\n          }\n          // we simply enable closing of subReaders, to prevent incRefs on subReaders\n          // -> for synthetic subReaders, close() is never called by our doClose()\n          subReaders[i] = new ParallelCompositeReader(true, compositeSubs, storedSubs);\n        }\n      }\n      return subReaders;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"48180ea0d6210cab36e06798b916a39e0607713b","date":1367051483,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelCompositeReader#prepareSubReaders(CompositeReader[],CompositeReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelCompositeReader#prepareSubReaders(CompositeReader[],CompositeReader[]).mjava","sourceNew":"  private static IndexReader[] prepareSubReaders(CompositeReader[] readers, CompositeReader[] storedFieldsReaders) throws IOException {\n    if (readers.length == 0) {\n      if (storedFieldsReaders.length > 0)\n        throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n      return new IndexReader[0];\n    } else {\n      final List<? extends IndexReader> firstSubReaders = readers[0].getSequentialSubReaders();\n\n      // check compatibility:\n      final int maxDoc = readers[0].maxDoc(), noSubs = firstSubReaders.size();\n      final int[] childMaxDoc = new int[noSubs];\n      final boolean[] childAtomic = new boolean[noSubs];\n      for (int i = 0; i < noSubs; i++) {\n        final IndexReader r = firstSubReaders.get(i);\n        childMaxDoc[i] = r.maxDoc();\n        childAtomic[i] = r instanceof AtomicReader;\n      }\n      validate(readers, maxDoc, childMaxDoc, childAtomic);\n      validate(storedFieldsReaders, maxDoc, childMaxDoc, childAtomic);\n\n      // hierarchically build the same subreader structure as the first CompositeReader with Parallel*Readers:\n      final IndexReader[] subReaders = new IndexReader[noSubs];\n      for (int i = 0; i < subReaders.length; i++) {\n        if (firstSubReaders.get(i) instanceof AtomicReader) {\n          final AtomicReader[] atomicSubs = new AtomicReader[readers.length];\n          for (int j = 0; j < readers.length; j++) {\n            atomicSubs[j] = (AtomicReader) readers[j].getSequentialSubReaders().get(i);\n          }\n          final AtomicReader[] storedSubs = new AtomicReader[storedFieldsReaders.length];\n          for (int j = 0; j < storedFieldsReaders.length; j++) {\n            storedSubs[j] = (AtomicReader) storedFieldsReaders[j].getSequentialSubReaders().get(i);\n          }\n          // We pass true for closeSubs and we prevent closing of subreaders in doClose():\n          // By this the synthetic throw-away readers used here are completely invisible to ref-counting\n          subReaders[i] = new ParallelAtomicReader(true, atomicSubs, storedSubs) {\n            @Override\n            protected void doClose() {}\n          };\n        } else {\n          assert firstSubReaders.get(i) instanceof CompositeReader;\n          final CompositeReader[] compositeSubs = new CompositeReader[readers.length];\n          for (int j = 0; j < readers.length; j++) {\n            compositeSubs[j] = (CompositeReader) readers[j].getSequentialSubReaders().get(i);\n          }\n          final CompositeReader[] storedSubs = new CompositeReader[storedFieldsReaders.length];\n          for (int j = 0; j < storedFieldsReaders.length; j++) {\n            storedSubs[j] = (CompositeReader) storedFieldsReaders[j].getSequentialSubReaders().get(i);\n          }\n          // We pass true for closeSubs and we prevent closing of subreaders in doClose():\n          // By this the synthetic throw-away readers used here are completely invisible to ref-counting\n          subReaders[i] = new ParallelCompositeReader(true, compositeSubs, storedSubs) {\n            @Override\n            protected void doClose() {}\n          };\n        }\n      }\n      return subReaders;\n    }\n  }\n\n","sourceOld":"  private static IndexReader[] prepareSubReaders(CompositeReader[] readers, CompositeReader[] storedFieldsReaders) throws IOException {\n    if (readers.length == 0) {\n      if (storedFieldsReaders.length > 0)\n        throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n      return new IndexReader[0];\n    } else {\n      final List<? extends IndexReader> firstSubReaders = readers[0].getSequentialSubReaders();\n\n      // check compatibility:\n      final int maxDoc = readers[0].maxDoc(), noSubs = firstSubReaders.size();\n      final int[] childMaxDoc = new int[noSubs];\n      final boolean[] childAtomic = new boolean[noSubs];\n      for (int i = 0; i < noSubs; i++) {\n        final IndexReader r = firstSubReaders.get(i);\n        childMaxDoc[i] = r.maxDoc();\n        childAtomic[i] = r instanceof AtomicReader;\n      }\n      validate(readers, maxDoc, childMaxDoc, childAtomic);\n      validate(storedFieldsReaders, maxDoc, childMaxDoc, childAtomic);\n\n      // hierarchically build the same subreader structure as the first CompositeReader with Parallel*Readers:\n      final IndexReader[] subReaders = new IndexReader[noSubs];\n      for (int i = 0; i < subReaders.length; i++) {\n        if (firstSubReaders.get(i) instanceof AtomicReader) {\n          final AtomicReader[] atomicSubs = new AtomicReader[readers.length];\n          for (int j = 0; j < readers.length; j++) {\n            atomicSubs[j] = (AtomicReader) readers[j].getSequentialSubReaders().get(i);\n          }\n          final AtomicReader[] storedSubs = new AtomicReader[storedFieldsReaders.length];\n          for (int j = 0; j < storedFieldsReaders.length; j++) {\n            storedSubs[j] = (AtomicReader) storedFieldsReaders[j].getSequentialSubReaders().get(i);\n          }\n          // we simply enable closing of subReaders, to prevent incRefs on subReaders\n          // -> for synthetic subReaders, close() is never\n          // called by our doClose()\n          subReaders[i] = new ParallelAtomicReader(true, atomicSubs, storedSubs);\n        } else {\n          assert firstSubReaders.get(i) instanceof CompositeReader;\n          final CompositeReader[] compositeSubs = new CompositeReader[readers.length];\n          for (int j = 0; j < readers.length; j++) {\n            compositeSubs[j] = (CompositeReader) readers[j].getSequentialSubReaders().get(i);\n          }\n          final CompositeReader[] storedSubs = new CompositeReader[storedFieldsReaders.length];\n          for (int j = 0; j < storedFieldsReaders.length; j++) {\n            storedSubs[j] = (CompositeReader) storedFieldsReaders[j].getSequentialSubReaders().get(i);\n          }\n          // we simply enable closing of subReaders, to prevent incRefs on subReaders\n          // -> for synthetic subReaders, close() is never called by our doClose()\n          subReaders[i] = new ParallelCompositeReader(true, compositeSubs, storedSubs);\n        }\n      }\n      return subReaders;\n    }\n  }\n\n","bugFix":["6e09a3a223be07d75777515a717312813221fe58"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ParallelCompositeReader#prepareSubReaders(CompositeReader[],CompositeReader[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelCompositeReader#prepareSubReaders(CompositeReader[],CompositeReader[]).mjava","sourceNew":"  private static IndexReader[] prepareSubReaders(CompositeReader[] readers, CompositeReader[] storedFieldsReaders) throws IOException {\n    if (readers.length == 0) {\n      if (storedFieldsReaders.length > 0)\n        throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n      return new IndexReader[0];\n    } else {\n      final List<? extends IndexReader> firstSubReaders = readers[0].getSequentialSubReaders();\n\n      // check compatibility:\n      final int maxDoc = readers[0].maxDoc(), noSubs = firstSubReaders.size();\n      final int[] childMaxDoc = new int[noSubs];\n      final boolean[] childAtomic = new boolean[noSubs];\n      for (int i = 0; i < noSubs; i++) {\n        final IndexReader r = firstSubReaders.get(i);\n        childMaxDoc[i] = r.maxDoc();\n        childAtomic[i] = r instanceof LeafReader;\n      }\n      validate(readers, maxDoc, childMaxDoc, childAtomic);\n      validate(storedFieldsReaders, maxDoc, childMaxDoc, childAtomic);\n\n      // hierarchically build the same subreader structure as the first CompositeReader with Parallel*Readers:\n      final IndexReader[] subReaders = new IndexReader[noSubs];\n      for (int i = 0; i < subReaders.length; i++) {\n        if (firstSubReaders.get(i) instanceof LeafReader) {\n          final LeafReader[] atomicSubs = new LeafReader[readers.length];\n          for (int j = 0; j < readers.length; j++) {\n            atomicSubs[j] = (LeafReader) readers[j].getSequentialSubReaders().get(i);\n          }\n          final LeafReader[] storedSubs = new LeafReader[storedFieldsReaders.length];\n          for (int j = 0; j < storedFieldsReaders.length; j++) {\n            storedSubs[j] = (LeafReader) storedFieldsReaders[j].getSequentialSubReaders().get(i);\n          }\n          // We pass true for closeSubs and we prevent closing of subreaders in doClose():\n          // By this the synthetic throw-away readers used here are completely invisible to ref-counting\n          subReaders[i] = new ParallelLeafReader(true, atomicSubs, storedSubs) {\n            @Override\n            protected void doClose() {}\n          };\n        } else {\n          assert firstSubReaders.get(i) instanceof CompositeReader;\n          final CompositeReader[] compositeSubs = new CompositeReader[readers.length];\n          for (int j = 0; j < readers.length; j++) {\n            compositeSubs[j] = (CompositeReader) readers[j].getSequentialSubReaders().get(i);\n          }\n          final CompositeReader[] storedSubs = new CompositeReader[storedFieldsReaders.length];\n          for (int j = 0; j < storedFieldsReaders.length; j++) {\n            storedSubs[j] = (CompositeReader) storedFieldsReaders[j].getSequentialSubReaders().get(i);\n          }\n          // We pass true for closeSubs and we prevent closing of subreaders in doClose():\n          // By this the synthetic throw-away readers used here are completely invisible to ref-counting\n          subReaders[i] = new ParallelCompositeReader(true, compositeSubs, storedSubs) {\n            @Override\n            protected void doClose() {}\n          };\n        }\n      }\n      return subReaders;\n    }\n  }\n\n","sourceOld":"  private static IndexReader[] prepareSubReaders(CompositeReader[] readers, CompositeReader[] storedFieldsReaders) throws IOException {\n    if (readers.length == 0) {\n      if (storedFieldsReaders.length > 0)\n        throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n      return new IndexReader[0];\n    } else {\n      final List<? extends IndexReader> firstSubReaders = readers[0].getSequentialSubReaders();\n\n      // check compatibility:\n      final int maxDoc = readers[0].maxDoc(), noSubs = firstSubReaders.size();\n      final int[] childMaxDoc = new int[noSubs];\n      final boolean[] childAtomic = new boolean[noSubs];\n      for (int i = 0; i < noSubs; i++) {\n        final IndexReader r = firstSubReaders.get(i);\n        childMaxDoc[i] = r.maxDoc();\n        childAtomic[i] = r instanceof AtomicReader;\n      }\n      validate(readers, maxDoc, childMaxDoc, childAtomic);\n      validate(storedFieldsReaders, maxDoc, childMaxDoc, childAtomic);\n\n      // hierarchically build the same subreader structure as the first CompositeReader with Parallel*Readers:\n      final IndexReader[] subReaders = new IndexReader[noSubs];\n      for (int i = 0; i < subReaders.length; i++) {\n        if (firstSubReaders.get(i) instanceof AtomicReader) {\n          final AtomicReader[] atomicSubs = new AtomicReader[readers.length];\n          for (int j = 0; j < readers.length; j++) {\n            atomicSubs[j] = (AtomicReader) readers[j].getSequentialSubReaders().get(i);\n          }\n          final AtomicReader[] storedSubs = new AtomicReader[storedFieldsReaders.length];\n          for (int j = 0; j < storedFieldsReaders.length; j++) {\n            storedSubs[j] = (AtomicReader) storedFieldsReaders[j].getSequentialSubReaders().get(i);\n          }\n          // We pass true for closeSubs and we prevent closing of subreaders in doClose():\n          // By this the synthetic throw-away readers used here are completely invisible to ref-counting\n          subReaders[i] = new ParallelAtomicReader(true, atomicSubs, storedSubs) {\n            @Override\n            protected void doClose() {}\n          };\n        } else {\n          assert firstSubReaders.get(i) instanceof CompositeReader;\n          final CompositeReader[] compositeSubs = new CompositeReader[readers.length];\n          for (int j = 0; j < readers.length; j++) {\n            compositeSubs[j] = (CompositeReader) readers[j].getSequentialSubReaders().get(i);\n          }\n          final CompositeReader[] storedSubs = new CompositeReader[storedFieldsReaders.length];\n          for (int j = 0; j < storedFieldsReaders.length; j++) {\n            storedSubs[j] = (CompositeReader) storedFieldsReaders[j].getSequentialSubReaders().get(i);\n          }\n          // We pass true for closeSubs and we prevent closing of subreaders in doClose():\n          // By this the synthetic throw-away readers used here are completely invisible to ref-counting\n          subReaders[i] = new ParallelCompositeReader(true, compositeSubs, storedSubs) {\n            @Override\n            protected void doClose() {}\n          };\n        }\n      }\n      return subReaders;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f6279d779b4584858af04f499e8aac0ae132c29","date":1432729989,"type":4,"author":"Uwe Schindler","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/ParallelCompositeReader#prepareSubReaders(CompositeReader[],CompositeReader[]).mjava","sourceNew":null,"sourceOld":"  private static IndexReader[] prepareSubReaders(CompositeReader[] readers, CompositeReader[] storedFieldsReaders) throws IOException {\n    if (readers.length == 0) {\n      if (storedFieldsReaders.length > 0)\n        throw new IllegalArgumentException(\"There must be at least one main reader if storedFieldsReaders are used.\");\n      return new IndexReader[0];\n    } else {\n      final List<? extends IndexReader> firstSubReaders = readers[0].getSequentialSubReaders();\n\n      // check compatibility:\n      final int maxDoc = readers[0].maxDoc(), noSubs = firstSubReaders.size();\n      final int[] childMaxDoc = new int[noSubs];\n      final boolean[] childAtomic = new boolean[noSubs];\n      for (int i = 0; i < noSubs; i++) {\n        final IndexReader r = firstSubReaders.get(i);\n        childMaxDoc[i] = r.maxDoc();\n        childAtomic[i] = r instanceof LeafReader;\n      }\n      validate(readers, maxDoc, childMaxDoc, childAtomic);\n      validate(storedFieldsReaders, maxDoc, childMaxDoc, childAtomic);\n\n      // hierarchically build the same subreader structure as the first CompositeReader with Parallel*Readers:\n      final IndexReader[] subReaders = new IndexReader[noSubs];\n      for (int i = 0; i < subReaders.length; i++) {\n        if (firstSubReaders.get(i) instanceof LeafReader) {\n          final LeafReader[] atomicSubs = new LeafReader[readers.length];\n          for (int j = 0; j < readers.length; j++) {\n            atomicSubs[j] = (LeafReader) readers[j].getSequentialSubReaders().get(i);\n          }\n          final LeafReader[] storedSubs = new LeafReader[storedFieldsReaders.length];\n          for (int j = 0; j < storedFieldsReaders.length; j++) {\n            storedSubs[j] = (LeafReader) storedFieldsReaders[j].getSequentialSubReaders().get(i);\n          }\n          // We pass true for closeSubs and we prevent closing of subreaders in doClose():\n          // By this the synthetic throw-away readers used here are completely invisible to ref-counting\n          subReaders[i] = new ParallelLeafReader(true, atomicSubs, storedSubs) {\n            @Override\n            protected void doClose() {}\n          };\n        } else {\n          assert firstSubReaders.get(i) instanceof CompositeReader;\n          final CompositeReader[] compositeSubs = new CompositeReader[readers.length];\n          for (int j = 0; j < readers.length; j++) {\n            compositeSubs[j] = (CompositeReader) readers[j].getSequentialSubReaders().get(i);\n          }\n          final CompositeReader[] storedSubs = new CompositeReader[storedFieldsReaders.length];\n          for (int j = 0; j < storedFieldsReaders.length; j++) {\n            storedSubs[j] = (CompositeReader) storedFieldsReaders[j].getSequentialSubReaders().get(i);\n          }\n          // We pass true for closeSubs and we prevent closing of subreaders in doClose():\n          // By this the synthetic throw-away readers used here are completely invisible to ref-counting\n          subReaders[i] = new ParallelCompositeReader(true, compositeSubs, storedSubs) {\n            @Override\n            protected void doClose() {}\n          };\n        }\n      }\n      return subReaders;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"48180ea0d6210cab36e06798b916a39e0607713b":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["8be807b98a5aab36b690a9bd4ef0e4b5d33b8689"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5f6279d779b4584858af04f499e8aac0ae132c29":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"6e09a3a223be07d75777515a717312813221fe58":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["48180ea0d6210cab36e06798b916a39e0607713b"],"8be807b98a5aab36b690a9bd4ef0e4b5d33b8689":["6e09a3a223be07d75777515a717312813221fe58"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5f6279d779b4584858af04f499e8aac0ae132c29"]},"commit2Childs":{"48180ea0d6210cab36e06798b916a39e0607713b":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["48180ea0d6210cab36e06798b916a39e0607713b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6e09a3a223be07d75777515a717312813221fe58"],"5f6279d779b4584858af04f499e8aac0ae132c29":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6e09a3a223be07d75777515a717312813221fe58":["8be807b98a5aab36b690a9bd4ef0e4b5d33b8689"],"8be807b98a5aab36b690a9bd4ef0e4b5d33b8689":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["5f6279d779b4584858af04f499e8aac0ae132c29"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}