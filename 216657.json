{"path":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#nextDoc().mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#nextDoc().mjava","pathOld":"modules/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#nextDoc().mjava","sourceNew":"    @Override\n    public int nextDoc() throws IOException {\n      //System.out.println(\"Q.nextDoc() nextChildDoc=\" + nextChildDoc);\n\n      // Loop until we hit a parentDoc that's accepted\n      while (true) {\n        if (nextChildDoc == NO_MORE_DOCS) {\n          //System.out.println(\"  end\");\n          return parentDoc = NO_MORE_DOCS;\n        }\n\n        // Gather all children sharing the same parent as\n        // nextChildDoc\n\n        parentDoc = parentBits.nextSetBit(nextChildDoc);\n\n        //System.out.println(\"  parentDoc=\" + parentDoc);\n        assert parentDoc != -1;\n\n        //System.out.println(\"  nextChildDoc=\" + nextChildDoc);\n        if (acceptDocs != null && !acceptDocs.get(parentDoc)) {\n          // Parent doc not accepted; skip child docs until\n          // we hit a new parent doc:\n          do {\n            nextChildDoc = childScorer.nextDoc();\n          } while (nextChildDoc < parentDoc);\n          continue;\n        }\n\n        float totalScore = 0;\n        float maxScore = Float.NEGATIVE_INFINITY;\n\n        childDocUpto = 0;\n        do {\n\n          //System.out.println(\"  c=\" + nextChildDoc);\n          if (pendingChildDocs.length == childDocUpto) {\n            pendingChildDocs = ArrayUtil.grow(pendingChildDocs);\n          }\n          if (scoreMode != ScoreMode.None && pendingChildScores.length == childDocUpto) {\n            pendingChildScores = ArrayUtil.grow(pendingChildScores);\n          }\n          pendingChildDocs[childDocUpto] = nextChildDoc;\n          if (scoreMode != ScoreMode.None) {\n            // TODO: specialize this into dedicated classes per-scoreMode\n            final float childScore = childScorer.score();\n            pendingChildScores[childDocUpto] = childScore;\n            maxScore = Math.max(childScore, maxScore);\n            totalScore += childScore;\n          }\n          childDocUpto++;\n          nextChildDoc = childScorer.nextDoc();\n        } while (nextChildDoc < parentDoc);\n\n        // Parent & child docs are supposed to be orthogonal:\n        assert nextChildDoc != parentDoc;\n\n        switch(scoreMode) {\n        case Avg:\n          parentScore = totalScore / childDocUpto;\n          break;\n        case Max:\n          parentScore = maxScore;\n          break;\n        case Total:\n          parentScore = totalScore;\n          break;\n        case None:\n          break;\n        }\n\n        //System.out.println(\"  return parentDoc=\" + parentDoc);\n        return parentDoc;\n      }\n    }\n\n","sourceOld":"    @Override\n    public int nextDoc() throws IOException {\n      //System.out.println(\"Q.nextDoc() nextChildDoc=\" + nextChildDoc);\n\n      // Loop until we hit a parentDoc that's accepted\n      while (true) {\n        if (nextChildDoc == NO_MORE_DOCS) {\n          //System.out.println(\"  end\");\n          return parentDoc = NO_MORE_DOCS;\n        }\n\n        // Gather all children sharing the same parent as\n        // nextChildDoc\n\n        parentDoc = parentBits.nextSetBit(nextChildDoc);\n\n        //System.out.println(\"  parentDoc=\" + parentDoc);\n        assert parentDoc != -1;\n\n        //System.out.println(\"  nextChildDoc=\" + nextChildDoc);\n        if (acceptDocs != null && !acceptDocs.get(parentDoc)) {\n          // Parent doc not accepted; skip child docs until\n          // we hit a new parent doc:\n          do {\n            nextChildDoc = childScorer.nextDoc();\n          } while (nextChildDoc < parentDoc);\n          continue;\n        }\n\n        float totalScore = 0;\n        float maxScore = Float.NEGATIVE_INFINITY;\n\n        childDocUpto = 0;\n        do {\n\n          //System.out.println(\"  c=\" + nextChildDoc);\n          if (pendingChildDocs.length == childDocUpto) {\n            pendingChildDocs = ArrayUtil.grow(pendingChildDocs);\n          }\n          if (scoreMode != ScoreMode.None && pendingChildScores.length == childDocUpto) {\n            pendingChildScores = ArrayUtil.grow(pendingChildScores);\n          }\n          pendingChildDocs[childDocUpto] = nextChildDoc;\n          if (scoreMode != ScoreMode.None) {\n            // TODO: specialize this into dedicated classes per-scoreMode\n            final float childScore = childScorer.score();\n            pendingChildScores[childDocUpto] = childScore;\n            maxScore = Math.max(childScore, maxScore);\n            totalScore += childScore;\n          }\n          childDocUpto++;\n          nextChildDoc = childScorer.nextDoc();\n        } while (nextChildDoc < parentDoc);\n\n        // Parent & child docs are supposed to be orthogonal:\n        assert nextChildDoc != parentDoc;\n\n        switch(scoreMode) {\n        case Avg:\n          parentScore = totalScore / childDocUpto;\n          break;\n        case Max:\n          parentScore = maxScore;\n          break;\n        case Total:\n          parentScore = totalScore;\n          break;\n        case None:\n          break;\n        }\n\n        //System.out.println(\"  return parentDoc=\" + parentDoc);\n        return parentDoc;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ea8268d5f00bb25a4ea1d0bac6e2ffe238712c45","date":1342645458,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#nextDoc().mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#nextDoc().mjava","sourceNew":"    @Override\n    public int nextDoc() throws IOException {\n      //System.out.println(\"Q.nextDoc() nextChildDoc=\" + nextChildDoc);\n\n      // Loop until we hit a parentDoc that's accepted\n      while (true) {\n        if (nextChildDoc == NO_MORE_DOCS) {\n          //System.out.println(\"  end\");\n          return parentDoc = NO_MORE_DOCS;\n        }\n\n        // Gather all children sharing the same parent as\n        // nextChildDoc\n\n        parentDoc = parentBits.nextSetBit(nextChildDoc);\n\n        //System.out.println(\"  parentDoc=\" + parentDoc);\n        assert parentDoc != -1;\n\n        //System.out.println(\"  nextChildDoc=\" + nextChildDoc);\n        if (acceptDocs != null && !acceptDocs.get(parentDoc)) {\n          // Parent doc not accepted; skip child docs until\n          // we hit a new parent doc:\n          do {\n            nextChildDoc = childScorer.nextDoc();\n          } while (nextChildDoc < parentDoc);\n          continue;\n        }\n\n        float totalScore = 0;\n        float totalFreq = 0;\n        float maxScore = Float.NEGATIVE_INFINITY;\n        float maxFreq = 0;\n\n        childDocUpto = 0;\n        do {\n\n          //System.out.println(\"  c=\" + nextChildDoc);\n          if (pendingChildDocs.length == childDocUpto) {\n            pendingChildDocs = ArrayUtil.grow(pendingChildDocs);\n          }\n          if (scoreMode != ScoreMode.None && pendingChildScores.length == childDocUpto) {\n            pendingChildScores = ArrayUtil.grow(pendingChildScores);\n          }\n          pendingChildDocs[childDocUpto] = nextChildDoc;\n          if (scoreMode != ScoreMode.None) {\n            // TODO: specialize this into dedicated classes per-scoreMode\n            final float childScore = childScorer.score();\n            final float childFreq = childScorer.freq();\n            pendingChildScores[childDocUpto] = childScore;\n            maxScore = Math.max(childScore, maxScore);\n            maxFreq = Math.max(childFreq, maxFreq);\n            totalScore += childScore;\n            totalFreq += childFreq;\n          }\n          childDocUpto++;\n          nextChildDoc = childScorer.nextDoc();\n        } while (nextChildDoc < parentDoc);\n\n        // Parent & child docs are supposed to be orthogonal:\n        assert nextChildDoc != parentDoc;\n\n        switch(scoreMode) {\n        case Avg:\n          parentScore = totalScore / childDocUpto;\n          parentFreq = totalFreq / childDocUpto;\n          break;\n        case Max:\n          parentScore = maxScore;\n          parentFreq = maxFreq;\n          break;\n        case Total:\n          parentScore = totalScore;\n          parentFreq = totalFreq;\n          break;\n        case None:\n          break;\n        }\n\n        //System.out.println(\"  return parentDoc=\" + parentDoc);\n        return parentDoc;\n      }\n    }\n\n","sourceOld":"    @Override\n    public int nextDoc() throws IOException {\n      //System.out.println(\"Q.nextDoc() nextChildDoc=\" + nextChildDoc);\n\n      // Loop until we hit a parentDoc that's accepted\n      while (true) {\n        if (nextChildDoc == NO_MORE_DOCS) {\n          //System.out.println(\"  end\");\n          return parentDoc = NO_MORE_DOCS;\n        }\n\n        // Gather all children sharing the same parent as\n        // nextChildDoc\n\n        parentDoc = parentBits.nextSetBit(nextChildDoc);\n\n        //System.out.println(\"  parentDoc=\" + parentDoc);\n        assert parentDoc != -1;\n\n        //System.out.println(\"  nextChildDoc=\" + nextChildDoc);\n        if (acceptDocs != null && !acceptDocs.get(parentDoc)) {\n          // Parent doc not accepted; skip child docs until\n          // we hit a new parent doc:\n          do {\n            nextChildDoc = childScorer.nextDoc();\n          } while (nextChildDoc < parentDoc);\n          continue;\n        }\n\n        float totalScore = 0;\n        float maxScore = Float.NEGATIVE_INFINITY;\n\n        childDocUpto = 0;\n        do {\n\n          //System.out.println(\"  c=\" + nextChildDoc);\n          if (pendingChildDocs.length == childDocUpto) {\n            pendingChildDocs = ArrayUtil.grow(pendingChildDocs);\n          }\n          if (scoreMode != ScoreMode.None && pendingChildScores.length == childDocUpto) {\n            pendingChildScores = ArrayUtil.grow(pendingChildScores);\n          }\n          pendingChildDocs[childDocUpto] = nextChildDoc;\n          if (scoreMode != ScoreMode.None) {\n            // TODO: specialize this into dedicated classes per-scoreMode\n            final float childScore = childScorer.score();\n            pendingChildScores[childDocUpto] = childScore;\n            maxScore = Math.max(childScore, maxScore);\n            totalScore += childScore;\n          }\n          childDocUpto++;\n          nextChildDoc = childScorer.nextDoc();\n        } while (nextChildDoc < parentDoc);\n\n        // Parent & child docs are supposed to be orthogonal:\n        assert nextChildDoc != parentDoc;\n\n        switch(scoreMode) {\n        case Avg:\n          parentScore = totalScore / childDocUpto;\n          break;\n        case Max:\n          parentScore = maxScore;\n          break;\n        case Total:\n          parentScore = totalScore;\n          break;\n        case None:\n          break;\n        }\n\n        //System.out.println(\"  return parentDoc=\" + parentDoc);\n        return parentDoc;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#nextDoc().mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#nextDoc().mjava","sourceNew":"    @Override\n    public int nextDoc() throws IOException {\n      //System.out.println(\"Q.nextDoc() nextChildDoc=\" + nextChildDoc);\n\n      // Loop until we hit a parentDoc that's accepted\n      while (true) {\n        if (nextChildDoc == NO_MORE_DOCS) {\n          //System.out.println(\"  end\");\n          return parentDoc = NO_MORE_DOCS;\n        }\n\n        // Gather all children sharing the same parent as\n        // nextChildDoc\n\n        parentDoc = parentBits.nextSetBit(nextChildDoc);\n\n        //System.out.println(\"  parentDoc=\" + parentDoc);\n        assert parentDoc != -1;\n\n        //System.out.println(\"  nextChildDoc=\" + nextChildDoc);\n        if (acceptDocs != null && !acceptDocs.get(parentDoc)) {\n          // Parent doc not accepted; skip child docs until\n          // we hit a new parent doc:\n          do {\n            nextChildDoc = childScorer.nextDoc();\n          } while (nextChildDoc < parentDoc);\n          continue;\n        }\n\n        float totalScore = 0;\n        float totalFreq = 0;\n        float maxScore = Float.NEGATIVE_INFINITY;\n        float maxFreq = 0;\n\n        childDocUpto = 0;\n        do {\n\n          //System.out.println(\"  c=\" + nextChildDoc);\n          if (pendingChildDocs.length == childDocUpto) {\n            pendingChildDocs = ArrayUtil.grow(pendingChildDocs);\n          }\n          if (scoreMode != ScoreMode.None && pendingChildScores.length == childDocUpto) {\n            pendingChildScores = ArrayUtil.grow(pendingChildScores);\n          }\n          pendingChildDocs[childDocUpto] = nextChildDoc;\n          if (scoreMode != ScoreMode.None) {\n            // TODO: specialize this into dedicated classes per-scoreMode\n            final float childScore = childScorer.score();\n            final float childFreq = childScorer.freq();\n            pendingChildScores[childDocUpto] = childScore;\n            maxScore = Math.max(childScore, maxScore);\n            maxFreq = Math.max(childFreq, maxFreq);\n            totalScore += childScore;\n            totalFreq += childFreq;\n          }\n          childDocUpto++;\n          nextChildDoc = childScorer.nextDoc();\n        } while (nextChildDoc < parentDoc);\n\n        // Parent & child docs are supposed to be orthogonal:\n        assert nextChildDoc != parentDoc;\n\n        switch(scoreMode) {\n        case Avg:\n          parentScore = totalScore / childDocUpto;\n          parentFreq = totalFreq / childDocUpto;\n          break;\n        case Max:\n          parentScore = maxScore;\n          parentFreq = maxFreq;\n          break;\n        case Total:\n          parentScore = totalScore;\n          parentFreq = totalFreq;\n          break;\n        case None:\n          break;\n        }\n\n        //System.out.println(\"  return parentDoc=\" + parentDoc);\n        return parentDoc;\n      }\n    }\n\n","sourceOld":"    @Override\n    public int nextDoc() throws IOException {\n      //System.out.println(\"Q.nextDoc() nextChildDoc=\" + nextChildDoc);\n\n      // Loop until we hit a parentDoc that's accepted\n      while (true) {\n        if (nextChildDoc == NO_MORE_DOCS) {\n          //System.out.println(\"  end\");\n          return parentDoc = NO_MORE_DOCS;\n        }\n\n        // Gather all children sharing the same parent as\n        // nextChildDoc\n\n        parentDoc = parentBits.nextSetBit(nextChildDoc);\n\n        //System.out.println(\"  parentDoc=\" + parentDoc);\n        assert parentDoc != -1;\n\n        //System.out.println(\"  nextChildDoc=\" + nextChildDoc);\n        if (acceptDocs != null && !acceptDocs.get(parentDoc)) {\n          // Parent doc not accepted; skip child docs until\n          // we hit a new parent doc:\n          do {\n            nextChildDoc = childScorer.nextDoc();\n          } while (nextChildDoc < parentDoc);\n          continue;\n        }\n\n        float totalScore = 0;\n        float maxScore = Float.NEGATIVE_INFINITY;\n\n        childDocUpto = 0;\n        do {\n\n          //System.out.println(\"  c=\" + nextChildDoc);\n          if (pendingChildDocs.length == childDocUpto) {\n            pendingChildDocs = ArrayUtil.grow(pendingChildDocs);\n          }\n          if (scoreMode != ScoreMode.None && pendingChildScores.length == childDocUpto) {\n            pendingChildScores = ArrayUtil.grow(pendingChildScores);\n          }\n          pendingChildDocs[childDocUpto] = nextChildDoc;\n          if (scoreMode != ScoreMode.None) {\n            // TODO: specialize this into dedicated classes per-scoreMode\n            final float childScore = childScorer.score();\n            pendingChildScores[childDocUpto] = childScore;\n            maxScore = Math.max(childScore, maxScore);\n            totalScore += childScore;\n          }\n          childDocUpto++;\n          nextChildDoc = childScorer.nextDoc();\n        } while (nextChildDoc < parentDoc);\n\n        // Parent & child docs are supposed to be orthogonal:\n        assert nextChildDoc != parentDoc;\n\n        switch(scoreMode) {\n        case Avg:\n          parentScore = totalScore / childDocUpto;\n          break;\n        case Max:\n          parentScore = maxScore;\n          break;\n        case Total:\n          parentScore = totalScore;\n          break;\n        case None:\n          break;\n        }\n\n        //System.out.println(\"  return parentDoc=\" + parentDoc);\n        return parentDoc;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#nextDoc().mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#nextDoc().mjava","sourceNew":"    @Override\n    public int nextDoc() throws IOException {\n      //System.out.println(\"Q.nextDoc() nextChildDoc=\" + nextChildDoc);\n\n      // Loop until we hit a parentDoc that's accepted\n      while (true) {\n        if (nextChildDoc == NO_MORE_DOCS) {\n          //System.out.println(\"  end\");\n          return parentDoc = NO_MORE_DOCS;\n        }\n\n        // Gather all children sharing the same parent as\n        // nextChildDoc\n\n        parentDoc = parentBits.nextSetBit(nextChildDoc);\n\n        //System.out.println(\"  parentDoc=\" + parentDoc);\n        assert parentDoc != -1;\n\n        //System.out.println(\"  nextChildDoc=\" + nextChildDoc);\n        if (acceptDocs != null && !acceptDocs.get(parentDoc)) {\n          // Parent doc not accepted; skip child docs until\n          // we hit a new parent doc:\n          do {\n            nextChildDoc = childScorer.nextDoc();\n          } while (nextChildDoc < parentDoc);\n          continue;\n        }\n\n        float totalScore = 0;\n        float totalFreq = 0;\n        float maxScore = Float.NEGATIVE_INFINITY;\n        float maxFreq = 0;\n\n        childDocUpto = 0;\n        do {\n\n          //System.out.println(\"  c=\" + nextChildDoc);\n          if (pendingChildDocs.length == childDocUpto) {\n            pendingChildDocs = ArrayUtil.grow(pendingChildDocs);\n          }\n          if (scoreMode != ScoreMode.None && pendingChildScores.length == childDocUpto) {\n            pendingChildScores = ArrayUtil.grow(pendingChildScores);\n          }\n          pendingChildDocs[childDocUpto] = nextChildDoc;\n          if (scoreMode != ScoreMode.None) {\n            // TODO: specialize this into dedicated classes per-scoreMode\n            final float childScore = childScorer.score();\n            final float childFreq = childScorer.freq();\n            pendingChildScores[childDocUpto] = childScore;\n            maxScore = Math.max(childScore, maxScore);\n            maxFreq = Math.max(childFreq, maxFreq);\n            totalScore += childScore;\n            totalFreq += childFreq;\n          }\n          childDocUpto++;\n          nextChildDoc = childScorer.nextDoc();\n        } while (nextChildDoc < parentDoc);\n\n        // Parent & child docs are supposed to be orthogonal:\n        assert nextChildDoc != parentDoc;\n\n        switch(scoreMode) {\n        case Avg:\n          parentScore = totalScore / childDocUpto;\n          parentFreq = totalFreq / childDocUpto;\n          break;\n        case Max:\n          parentScore = maxScore;\n          parentFreq = maxFreq;\n          break;\n        case Total:\n          parentScore = totalScore;\n          parentFreq = totalFreq;\n          break;\n        case None:\n          break;\n        }\n\n        //System.out.println(\"  return parentDoc=\" + parentDoc);\n        return parentDoc;\n      }\n    }\n\n","sourceOld":"    @Override\n    public int nextDoc() throws IOException {\n      //System.out.println(\"Q.nextDoc() nextChildDoc=\" + nextChildDoc);\n\n      // Loop until we hit a parentDoc that's accepted\n      while (true) {\n        if (nextChildDoc == NO_MORE_DOCS) {\n          //System.out.println(\"  end\");\n          return parentDoc = NO_MORE_DOCS;\n        }\n\n        // Gather all children sharing the same parent as\n        // nextChildDoc\n\n        parentDoc = parentBits.nextSetBit(nextChildDoc);\n\n        //System.out.println(\"  parentDoc=\" + parentDoc);\n        assert parentDoc != -1;\n\n        //System.out.println(\"  nextChildDoc=\" + nextChildDoc);\n        if (acceptDocs != null && !acceptDocs.get(parentDoc)) {\n          // Parent doc not accepted; skip child docs until\n          // we hit a new parent doc:\n          do {\n            nextChildDoc = childScorer.nextDoc();\n          } while (nextChildDoc < parentDoc);\n          continue;\n        }\n\n        float totalScore = 0;\n        float maxScore = Float.NEGATIVE_INFINITY;\n\n        childDocUpto = 0;\n        do {\n\n          //System.out.println(\"  c=\" + nextChildDoc);\n          if (pendingChildDocs.length == childDocUpto) {\n            pendingChildDocs = ArrayUtil.grow(pendingChildDocs);\n          }\n          if (scoreMode != ScoreMode.None && pendingChildScores.length == childDocUpto) {\n            pendingChildScores = ArrayUtil.grow(pendingChildScores);\n          }\n          pendingChildDocs[childDocUpto] = nextChildDoc;\n          if (scoreMode != ScoreMode.None) {\n            // TODO: specialize this into dedicated classes per-scoreMode\n            final float childScore = childScorer.score();\n            pendingChildScores[childDocUpto] = childScore;\n            maxScore = Math.max(childScore, maxScore);\n            totalScore += childScore;\n          }\n          childDocUpto++;\n          nextChildDoc = childScorer.nextDoc();\n        } while (nextChildDoc < parentDoc);\n\n        // Parent & child docs are supposed to be orthogonal:\n        assert nextChildDoc != parentDoc;\n\n        switch(scoreMode) {\n        case Avg:\n          parentScore = totalScore / childDocUpto;\n          break;\n        case Max:\n          parentScore = maxScore;\n          break;\n        case Total:\n          parentScore = totalScore;\n          break;\n        case None:\n          break;\n        }\n\n        //System.out.println(\"  return parentDoc=\" + parentDoc);\n        return parentDoc;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"05a9119f665d52b16e936bb48c5b836609aadbc5","date":1351605383,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#nextDoc().mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#nextDoc().mjava","sourceNew":"    @Override\n    public int nextDoc() throws IOException {\n      //System.out.println(\"Q.nextDoc() nextChildDoc=\" + nextChildDoc);\n\n      // Loop until we hit a parentDoc that's accepted\n      while (true) {\n        if (nextChildDoc == NO_MORE_DOCS) {\n          //System.out.println(\"  end\");\n          return parentDoc = NO_MORE_DOCS;\n        }\n\n        // Gather all children sharing the same parent as\n        // nextChildDoc\n\n        parentDoc = parentBits.nextSetBit(nextChildDoc);\n\n        //System.out.println(\"  parentDoc=\" + parentDoc);\n        assert parentDoc != -1;\n\n        //System.out.println(\"  nextChildDoc=\" + nextChildDoc);\n        if (acceptDocs != null && !acceptDocs.get(parentDoc)) {\n          // Parent doc not accepted; skip child docs until\n          // we hit a new parent doc:\n          do {\n            nextChildDoc = childScorer.nextDoc();\n          } while (nextChildDoc < parentDoc);\n          continue;\n        }\n\n        float totalScore = 0;\n        float maxScore = Float.NEGATIVE_INFINITY;\n\n        childDocUpto = 0;\n        parentFreq = 0;\n        do {\n\n          //System.out.println(\"  c=\" + nextChildDoc);\n          if (pendingChildDocs.length == childDocUpto) {\n            pendingChildDocs = ArrayUtil.grow(pendingChildDocs);\n          }\n          if (scoreMode != ScoreMode.None && pendingChildScores.length == childDocUpto) {\n            pendingChildScores = ArrayUtil.grow(pendingChildScores);\n          }\n          pendingChildDocs[childDocUpto] = nextChildDoc;\n          if (scoreMode != ScoreMode.None) {\n            // TODO: specialize this into dedicated classes per-scoreMode\n            final float childScore = childScorer.score();\n            final int childFreq = childScorer.freq();\n            pendingChildScores[childDocUpto] = childScore;\n            maxScore = Math.max(childScore, maxScore);\n            totalScore += childScore;\n            parentFreq += childFreq;\n          }\n          childDocUpto++;\n          nextChildDoc = childScorer.nextDoc();\n        } while (nextChildDoc < parentDoc);\n\n        // Parent & child docs are supposed to be orthogonal:\n        assert nextChildDoc != parentDoc;\n\n        switch(scoreMode) {\n        case Avg:\n          parentScore = totalScore / childDocUpto;\n          break;\n        case Max:\n          parentScore = maxScore;\n          break;\n        case Total:\n          parentScore = totalScore;\n          break;\n        case None:\n          break;\n        }\n\n        //System.out.println(\"  return parentDoc=\" + parentDoc);\n        return parentDoc;\n      }\n    }\n\n","sourceOld":"    @Override\n    public int nextDoc() throws IOException {\n      //System.out.println(\"Q.nextDoc() nextChildDoc=\" + nextChildDoc);\n\n      // Loop until we hit a parentDoc that's accepted\n      while (true) {\n        if (nextChildDoc == NO_MORE_DOCS) {\n          //System.out.println(\"  end\");\n          return parentDoc = NO_MORE_DOCS;\n        }\n\n        // Gather all children sharing the same parent as\n        // nextChildDoc\n\n        parentDoc = parentBits.nextSetBit(nextChildDoc);\n\n        //System.out.println(\"  parentDoc=\" + parentDoc);\n        assert parentDoc != -1;\n\n        //System.out.println(\"  nextChildDoc=\" + nextChildDoc);\n        if (acceptDocs != null && !acceptDocs.get(parentDoc)) {\n          // Parent doc not accepted; skip child docs until\n          // we hit a new parent doc:\n          do {\n            nextChildDoc = childScorer.nextDoc();\n          } while (nextChildDoc < parentDoc);\n          continue;\n        }\n\n        float totalScore = 0;\n        float totalFreq = 0;\n        float maxScore = Float.NEGATIVE_INFINITY;\n        float maxFreq = 0;\n\n        childDocUpto = 0;\n        do {\n\n          //System.out.println(\"  c=\" + nextChildDoc);\n          if (pendingChildDocs.length == childDocUpto) {\n            pendingChildDocs = ArrayUtil.grow(pendingChildDocs);\n          }\n          if (scoreMode != ScoreMode.None && pendingChildScores.length == childDocUpto) {\n            pendingChildScores = ArrayUtil.grow(pendingChildScores);\n          }\n          pendingChildDocs[childDocUpto] = nextChildDoc;\n          if (scoreMode != ScoreMode.None) {\n            // TODO: specialize this into dedicated classes per-scoreMode\n            final float childScore = childScorer.score();\n            final float childFreq = childScorer.freq();\n            pendingChildScores[childDocUpto] = childScore;\n            maxScore = Math.max(childScore, maxScore);\n            maxFreq = Math.max(childFreq, maxFreq);\n            totalScore += childScore;\n            totalFreq += childFreq;\n          }\n          childDocUpto++;\n          nextChildDoc = childScorer.nextDoc();\n        } while (nextChildDoc < parentDoc);\n\n        // Parent & child docs are supposed to be orthogonal:\n        assert nextChildDoc != parentDoc;\n\n        switch(scoreMode) {\n        case Avg:\n          parentScore = totalScore / childDocUpto;\n          parentFreq = totalFreq / childDocUpto;\n          break;\n        case Max:\n          parentScore = maxScore;\n          parentFreq = maxFreq;\n          break;\n        case Total:\n          parentScore = totalScore;\n          parentFreq = totalFreq;\n          break;\n        case None:\n          break;\n        }\n\n        //System.out.println(\"  return parentDoc=\" + parentDoc);\n        return parentDoc;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"757496f10c991c553a874f78fb06c3f0dc110dff","date":1351616733,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#nextDoc().mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#nextDoc().mjava","sourceNew":"    @Override\n    public int nextDoc() throws IOException {\n      //System.out.println(\"Q.nextDoc() nextChildDoc=\" + nextChildDoc);\n\n      // Loop until we hit a parentDoc that's accepted\n      while (true) {\n        if (nextChildDoc == NO_MORE_DOCS) {\n          //System.out.println(\"  end\");\n          return parentDoc = NO_MORE_DOCS;\n        }\n\n        // Gather all children sharing the same parent as\n        // nextChildDoc\n\n        parentDoc = parentBits.nextSetBit(nextChildDoc);\n\n        //System.out.println(\"  parentDoc=\" + parentDoc);\n        assert parentDoc != -1;\n\n        //System.out.println(\"  nextChildDoc=\" + nextChildDoc);\n        if (acceptDocs != null && !acceptDocs.get(parentDoc)) {\n          // Parent doc not accepted; skip child docs until\n          // we hit a new parent doc:\n          do {\n            nextChildDoc = childScorer.nextDoc();\n          } while (nextChildDoc < parentDoc);\n          continue;\n        }\n\n        float totalScore = 0;\n        float maxScore = Float.NEGATIVE_INFINITY;\n\n        childDocUpto = 0;\n        parentFreq = 0;\n        do {\n\n          //System.out.println(\"  c=\" + nextChildDoc);\n          if (pendingChildDocs.length == childDocUpto) {\n            pendingChildDocs = ArrayUtil.grow(pendingChildDocs);\n          }\n          if (scoreMode != ScoreMode.None && pendingChildScores.length == childDocUpto) {\n            pendingChildScores = ArrayUtil.grow(pendingChildScores);\n          }\n          pendingChildDocs[childDocUpto] = nextChildDoc;\n          if (scoreMode != ScoreMode.None) {\n            // TODO: specialize this into dedicated classes per-scoreMode\n            final float childScore = childScorer.score();\n            final int childFreq = childScorer.freq();\n            pendingChildScores[childDocUpto] = childScore;\n            maxScore = Math.max(childScore, maxScore);\n            totalScore += childScore;\n            parentFreq += childFreq;\n          }\n          childDocUpto++;\n          nextChildDoc = childScorer.nextDoc();\n        } while (nextChildDoc < parentDoc);\n\n        // Parent & child docs are supposed to be orthogonal:\n        assert nextChildDoc != parentDoc;\n\n        switch(scoreMode) {\n        case Avg:\n          parentScore = totalScore / childDocUpto;\n          break;\n        case Max:\n          parentScore = maxScore;\n          break;\n        case Total:\n          parentScore = totalScore;\n          break;\n        case None:\n          break;\n        }\n\n        //System.out.println(\"  return parentDoc=\" + parentDoc);\n        return parentDoc;\n      }\n    }\n\n","sourceOld":"    @Override\n    public int nextDoc() throws IOException {\n      //System.out.println(\"Q.nextDoc() nextChildDoc=\" + nextChildDoc);\n\n      // Loop until we hit a parentDoc that's accepted\n      while (true) {\n        if (nextChildDoc == NO_MORE_DOCS) {\n          //System.out.println(\"  end\");\n          return parentDoc = NO_MORE_DOCS;\n        }\n\n        // Gather all children sharing the same parent as\n        // nextChildDoc\n\n        parentDoc = parentBits.nextSetBit(nextChildDoc);\n\n        //System.out.println(\"  parentDoc=\" + parentDoc);\n        assert parentDoc != -1;\n\n        //System.out.println(\"  nextChildDoc=\" + nextChildDoc);\n        if (acceptDocs != null && !acceptDocs.get(parentDoc)) {\n          // Parent doc not accepted; skip child docs until\n          // we hit a new parent doc:\n          do {\n            nextChildDoc = childScorer.nextDoc();\n          } while (nextChildDoc < parentDoc);\n          continue;\n        }\n\n        float totalScore = 0;\n        float totalFreq = 0;\n        float maxScore = Float.NEGATIVE_INFINITY;\n        float maxFreq = 0;\n\n        childDocUpto = 0;\n        do {\n\n          //System.out.println(\"  c=\" + nextChildDoc);\n          if (pendingChildDocs.length == childDocUpto) {\n            pendingChildDocs = ArrayUtil.grow(pendingChildDocs);\n          }\n          if (scoreMode != ScoreMode.None && pendingChildScores.length == childDocUpto) {\n            pendingChildScores = ArrayUtil.grow(pendingChildScores);\n          }\n          pendingChildDocs[childDocUpto] = nextChildDoc;\n          if (scoreMode != ScoreMode.None) {\n            // TODO: specialize this into dedicated classes per-scoreMode\n            final float childScore = childScorer.score();\n            final float childFreq = childScorer.freq();\n            pendingChildScores[childDocUpto] = childScore;\n            maxScore = Math.max(childScore, maxScore);\n            maxFreq = Math.max(childFreq, maxFreq);\n            totalScore += childScore;\n            totalFreq += childFreq;\n          }\n          childDocUpto++;\n          nextChildDoc = childScorer.nextDoc();\n        } while (nextChildDoc < parentDoc);\n\n        // Parent & child docs are supposed to be orthogonal:\n        assert nextChildDoc != parentDoc;\n\n        switch(scoreMode) {\n        case Avg:\n          parentScore = totalScore / childDocUpto;\n          parentFreq = totalFreq / childDocUpto;\n          break;\n        case Max:\n          parentScore = maxScore;\n          parentFreq = maxFreq;\n          break;\n        case Total:\n          parentScore = totalScore;\n          parentFreq = totalFreq;\n          break;\n        case None:\n          break;\n        }\n\n        //System.out.println(\"  return parentDoc=\" + parentDoc);\n        return parentDoc;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ab5548b8f3ccb00ab6a8702dfc85a949d2a05a11","date":1367321736,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#nextDoc().mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#nextDoc().mjava","sourceNew":"    @Override\n    public int nextDoc() throws IOException {\n      //System.out.println(\"Q.nextDoc() nextChildDoc=\" + nextChildDoc);\n      // Loop until we hit a parentDoc that's accepted\n      while (true) {\n        if (nextChildDoc == NO_MORE_DOCS) {\n          //System.out.println(\"  end\");\n          return parentDoc = NO_MORE_DOCS;\n        }\n\n        // Gather all children sharing the same parent as\n        // nextChildDoc\n\n        parentDoc = parentBits.nextSetBit(nextChildDoc);\n\n        // Parent & child docs are supposed to be\n        // orthogonal:\n        if (nextChildDoc == parentDoc) {\n          throw new IllegalStateException(\"child query must only match non-parent docs, but parent docID=\" + nextChildDoc + \" matched childScorer=\" + childScorer.getClass());\n        }\n\n        //System.out.println(\"  parentDoc=\" + parentDoc);\n        assert parentDoc != -1;\n\n        //System.out.println(\"  nextChildDoc=\" + nextChildDoc);\n        if (acceptDocs != null && !acceptDocs.get(parentDoc)) {\n          // Parent doc not accepted; skip child docs until\n          // we hit a new parent doc:\n          do {\n            nextChildDoc = childScorer.nextDoc();\n          } while (nextChildDoc < parentDoc);\n\n          // Parent & child docs are supposed to be\n          // orthogonal:\n          if (nextChildDoc == parentDoc) {\n            throw new IllegalStateException(\"child query must only match non-parent docs, but parent docID=\" + nextChildDoc + \" matched childScorer=\" + childScorer.getClass());\n          }\n\n          continue;\n        }\n\n        float totalScore = 0;\n        float maxScore = Float.NEGATIVE_INFINITY;\n\n        childDocUpto = 0;\n        parentFreq = 0;\n        do {\n\n          //System.out.println(\"  c=\" + nextChildDoc);\n          if (pendingChildDocs.length == childDocUpto) {\n            pendingChildDocs = ArrayUtil.grow(pendingChildDocs);\n          }\n          if (scoreMode != ScoreMode.None && pendingChildScores.length == childDocUpto) {\n            pendingChildScores = ArrayUtil.grow(pendingChildScores);\n          }\n          pendingChildDocs[childDocUpto] = nextChildDoc;\n          if (scoreMode != ScoreMode.None) {\n            // TODO: specialize this into dedicated classes per-scoreMode\n            final float childScore = childScorer.score();\n            final int childFreq = childScorer.freq();\n            pendingChildScores[childDocUpto] = childScore;\n            maxScore = Math.max(childScore, maxScore);\n            totalScore += childScore;\n            parentFreq += childFreq;\n          }\n          childDocUpto++;\n          nextChildDoc = childScorer.nextDoc();\n        } while (nextChildDoc < parentDoc);\n\n        // Parent & child docs are supposed to be\n        // orthogonal:\n        if (nextChildDoc == parentDoc) {\n          throw new IllegalStateException(\"child query must only match non-parent docs, but parent docID=\" + nextChildDoc + \" matched childScorer=\" + childScorer.getClass());\n        }\n\n        switch(scoreMode) {\n        case Avg:\n          parentScore = totalScore / childDocUpto;\n          break;\n        case Max:\n          parentScore = maxScore;\n          break;\n        case Total:\n          parentScore = totalScore;\n          break;\n        case None:\n          break;\n        }\n\n        //System.out.println(\"  return parentDoc=\" + parentDoc + \" childDocUpto=\" + childDocUpto);\n        return parentDoc;\n      }\n    }\n\n","sourceOld":"    @Override\n    public int nextDoc() throws IOException {\n      //System.out.println(\"Q.nextDoc() nextChildDoc=\" + nextChildDoc);\n\n      // Loop until we hit a parentDoc that's accepted\n      while (true) {\n        if (nextChildDoc == NO_MORE_DOCS) {\n          //System.out.println(\"  end\");\n          return parentDoc = NO_MORE_DOCS;\n        }\n\n        // Gather all children sharing the same parent as\n        // nextChildDoc\n\n        parentDoc = parentBits.nextSetBit(nextChildDoc);\n\n        //System.out.println(\"  parentDoc=\" + parentDoc);\n        assert parentDoc != -1;\n\n        //System.out.println(\"  nextChildDoc=\" + nextChildDoc);\n        if (acceptDocs != null && !acceptDocs.get(parentDoc)) {\n          // Parent doc not accepted; skip child docs until\n          // we hit a new parent doc:\n          do {\n            nextChildDoc = childScorer.nextDoc();\n          } while (nextChildDoc < parentDoc);\n          continue;\n        }\n\n        float totalScore = 0;\n        float maxScore = Float.NEGATIVE_INFINITY;\n\n        childDocUpto = 0;\n        parentFreq = 0;\n        do {\n\n          //System.out.println(\"  c=\" + nextChildDoc);\n          if (pendingChildDocs.length == childDocUpto) {\n            pendingChildDocs = ArrayUtil.grow(pendingChildDocs);\n          }\n          if (scoreMode != ScoreMode.None && pendingChildScores.length == childDocUpto) {\n            pendingChildScores = ArrayUtil.grow(pendingChildScores);\n          }\n          pendingChildDocs[childDocUpto] = nextChildDoc;\n          if (scoreMode != ScoreMode.None) {\n            // TODO: specialize this into dedicated classes per-scoreMode\n            final float childScore = childScorer.score();\n            final int childFreq = childScorer.freq();\n            pendingChildScores[childDocUpto] = childScore;\n            maxScore = Math.max(childScore, maxScore);\n            totalScore += childScore;\n            parentFreq += childFreq;\n          }\n          childDocUpto++;\n          nextChildDoc = childScorer.nextDoc();\n        } while (nextChildDoc < parentDoc);\n\n        // Parent & child docs are supposed to be orthogonal:\n        assert nextChildDoc != parentDoc;\n\n        switch(scoreMode) {\n        case Avg:\n          parentScore = totalScore / childDocUpto;\n          break;\n        case Max:\n          parentScore = maxScore;\n          break;\n        case Total:\n          parentScore = totalScore;\n          break;\n        case None:\n          break;\n        }\n\n        //System.out.println(\"  return parentDoc=\" + parentDoc);\n        return parentDoc;\n      }\n    }\n\n","bugFix":["b5a3548d95924aea5ee6d88499a7d166498a8e49","97e30c53fd81463c6ccd52402c91a6548cf42acb"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5db3cbd9c8643765faaef10ef026c766b653290","date":1380617685,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#nextDoc().mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#nextDoc().mjava","sourceNew":"    @Override\n    public int nextDoc() throws IOException {\n      //System.out.println(\"Q.nextDoc() nextChildDoc=\" + nextChildDoc);\n      // Loop until we hit a parentDoc that's accepted\n      while (true) {\n        if (nextChildDoc == NO_MORE_DOCS) {\n          //System.out.println(\"  end\");\n          return parentDoc = NO_MORE_DOCS;\n        }\n\n        // Gather all children sharing the same parent as\n        // nextChildDoc\n\n        parentDoc = parentBits.nextSetBit(nextChildDoc);\n\n        // Parent & child docs are supposed to be\n        // orthogonal:\n        if (nextChildDoc == parentDoc) {\n          throw new IllegalStateException(\"child query must only match non-parent docs, but parent docID=\" + nextChildDoc + \" matched childScorer=\" + childScorer.getClass());\n        }\n\n        //System.out.println(\"  parentDoc=\" + parentDoc);\n        assert parentDoc != -1;\n\n        //System.out.println(\"  nextChildDoc=\" + nextChildDoc);\n        if (acceptDocs != null && !acceptDocs.get(parentDoc)) {\n          // Parent doc not accepted; skip child docs until\n          // we hit a new parent doc:\n          do {\n            nextChildDoc = childScorer.nextDoc();\n          } while (nextChildDoc < parentDoc);\n\n          // Parent & child docs are supposed to be\n          // orthogonal:\n          if (nextChildDoc == parentDoc) {\n            throw new IllegalStateException(\"child query must only match non-parent docs, but parent docID=\" + nextChildDoc + \" matched childScorer=\" + childScorer.getClass());\n          }\n\n          continue;\n        }\n\n        float totalScore = 0;\n        float maxScore = Float.NEGATIVE_INFINITY;\n\n        childDocUpto = 0;\n        parentFreq = 0;\n        do {\n\n          //System.out.println(\"  c=\" + nextChildDoc);\n          if (pendingChildDocs != null && pendingChildDocs.length == childDocUpto) {\n            pendingChildDocs = ArrayUtil.grow(pendingChildDocs);\n          }\n          if (pendingChildScores != null && scoreMode != ScoreMode.None && pendingChildScores.length == childDocUpto) {\n            pendingChildScores = ArrayUtil.grow(pendingChildScores);\n          }\n          if (pendingChildDocs != null) {\n            pendingChildDocs[childDocUpto] = nextChildDoc;\n          }\n          if (scoreMode != ScoreMode.None) {\n            // TODO: specialize this into dedicated classes per-scoreMode\n            final float childScore = childScorer.score();\n            final int childFreq = childScorer.freq();\n            if (pendingChildScores != null) {\n              pendingChildScores[childDocUpto] = childScore;\n            }\n            maxScore = Math.max(childScore, maxScore);\n            totalScore += childScore;\n            parentFreq += childFreq;\n          }\n          childDocUpto++;\n          nextChildDoc = childScorer.nextDoc();\n        } while (nextChildDoc < parentDoc);\n\n        // Parent & child docs are supposed to be\n        // orthogonal:\n        if (nextChildDoc == parentDoc) {\n          throw new IllegalStateException(\"child query must only match non-parent docs, but parent docID=\" + nextChildDoc + \" matched childScorer=\" + childScorer.getClass());\n        }\n\n        switch(scoreMode) {\n        case Avg:\n          parentScore = totalScore / childDocUpto;\n          break;\n        case Max:\n          parentScore = maxScore;\n          break;\n        case Total:\n          parentScore = totalScore;\n          break;\n        case None:\n          break;\n        }\n\n        //System.out.println(\"  return parentDoc=\" + parentDoc + \" childDocUpto=\" + childDocUpto);\n        return parentDoc;\n      }\n    }\n\n","sourceOld":"    @Override\n    public int nextDoc() throws IOException {\n      //System.out.println(\"Q.nextDoc() nextChildDoc=\" + nextChildDoc);\n      // Loop until we hit a parentDoc that's accepted\n      while (true) {\n        if (nextChildDoc == NO_MORE_DOCS) {\n          //System.out.println(\"  end\");\n          return parentDoc = NO_MORE_DOCS;\n        }\n\n        // Gather all children sharing the same parent as\n        // nextChildDoc\n\n        parentDoc = parentBits.nextSetBit(nextChildDoc);\n\n        // Parent & child docs are supposed to be\n        // orthogonal:\n        if (nextChildDoc == parentDoc) {\n          throw new IllegalStateException(\"child query must only match non-parent docs, but parent docID=\" + nextChildDoc + \" matched childScorer=\" + childScorer.getClass());\n        }\n\n        //System.out.println(\"  parentDoc=\" + parentDoc);\n        assert parentDoc != -1;\n\n        //System.out.println(\"  nextChildDoc=\" + nextChildDoc);\n        if (acceptDocs != null && !acceptDocs.get(parentDoc)) {\n          // Parent doc not accepted; skip child docs until\n          // we hit a new parent doc:\n          do {\n            nextChildDoc = childScorer.nextDoc();\n          } while (nextChildDoc < parentDoc);\n\n          // Parent & child docs are supposed to be\n          // orthogonal:\n          if (nextChildDoc == parentDoc) {\n            throw new IllegalStateException(\"child query must only match non-parent docs, but parent docID=\" + nextChildDoc + \" matched childScorer=\" + childScorer.getClass());\n          }\n\n          continue;\n        }\n\n        float totalScore = 0;\n        float maxScore = Float.NEGATIVE_INFINITY;\n\n        childDocUpto = 0;\n        parentFreq = 0;\n        do {\n\n          //System.out.println(\"  c=\" + nextChildDoc);\n          if (pendingChildDocs.length == childDocUpto) {\n            pendingChildDocs = ArrayUtil.grow(pendingChildDocs);\n          }\n          if (scoreMode != ScoreMode.None && pendingChildScores.length == childDocUpto) {\n            pendingChildScores = ArrayUtil.grow(pendingChildScores);\n          }\n          pendingChildDocs[childDocUpto] = nextChildDoc;\n          if (scoreMode != ScoreMode.None) {\n            // TODO: specialize this into dedicated classes per-scoreMode\n            final float childScore = childScorer.score();\n            final int childFreq = childScorer.freq();\n            pendingChildScores[childDocUpto] = childScore;\n            maxScore = Math.max(childScore, maxScore);\n            totalScore += childScore;\n            parentFreq += childFreq;\n          }\n          childDocUpto++;\n          nextChildDoc = childScorer.nextDoc();\n        } while (nextChildDoc < parentDoc);\n\n        // Parent & child docs are supposed to be\n        // orthogonal:\n        if (nextChildDoc == parentDoc) {\n          throw new IllegalStateException(\"child query must only match non-parent docs, but parent docID=\" + nextChildDoc + \" matched childScorer=\" + childScorer.getClass());\n        }\n\n        switch(scoreMode) {\n        case Avg:\n          parentScore = totalScore / childDocUpto;\n          break;\n        case Max:\n          parentScore = maxScore;\n          break;\n        case Total:\n          parentScore = totalScore;\n          break;\n        case None:\n          break;\n        }\n\n        //System.out.println(\"  return parentDoc=\" + parentDoc + \" childDocUpto=\" + childDocUpto);\n        return parentDoc;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e","date":1414135939,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#nextDoc().mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#nextDoc().mjava","sourceNew":"    @Override\n    public int nextDoc() throws IOException {\n      //System.out.println(\"Q.nextDoc() nextChildDoc=\" + nextChildDoc);\n      // Loop until we hit a parentDoc that's accepted\n      while (true) {\n        if (nextChildDoc == NO_MORE_DOCS) {\n          //System.out.println(\"  end\");\n          return parentDoc = NO_MORE_DOCS;\n        }\n\n        // Gather all children sharing the same parent as\n        // nextChildDoc\n\n        parentDoc = parentBits.nextSetBit(nextChildDoc);\n\n        // Parent & child docs are supposed to be\n        // orthogonal:\n        if (nextChildDoc == parentDoc) {\n          throw new IllegalStateException(\"child query must only match non-parent docs, but parent docID=\" + nextChildDoc + \" matched childScorer=\" + childScorer.getClass());\n        }\n\n        //System.out.println(\"  parentDoc=\" + parentDoc);\n        assert parentDoc != DocIdSetIterator.NO_MORE_DOCS;\n\n        //System.out.println(\"  nextChildDoc=\" + nextChildDoc);\n        if (acceptDocs != null && !acceptDocs.get(parentDoc)) {\n          // Parent doc not accepted; skip child docs until\n          // we hit a new parent doc:\n          do {\n            nextChildDoc = childScorer.nextDoc();\n          } while (nextChildDoc < parentDoc);\n\n          // Parent & child docs are supposed to be\n          // orthogonal:\n          if (nextChildDoc == parentDoc) {\n            throw new IllegalStateException(\"child query must only match non-parent docs, but parent docID=\" + nextChildDoc + \" matched childScorer=\" + childScorer.getClass());\n          }\n\n          continue;\n        }\n\n        float totalScore = 0;\n        float maxScore = Float.NEGATIVE_INFINITY;\n\n        childDocUpto = 0;\n        parentFreq = 0;\n        do {\n\n          //System.out.println(\"  c=\" + nextChildDoc);\n          if (pendingChildDocs != null && pendingChildDocs.length == childDocUpto) {\n            pendingChildDocs = ArrayUtil.grow(pendingChildDocs);\n          }\n          if (pendingChildScores != null && scoreMode != ScoreMode.None && pendingChildScores.length == childDocUpto) {\n            pendingChildScores = ArrayUtil.grow(pendingChildScores);\n          }\n          if (pendingChildDocs != null) {\n            pendingChildDocs[childDocUpto] = nextChildDoc;\n          }\n          if (scoreMode != ScoreMode.None) {\n            // TODO: specialize this into dedicated classes per-scoreMode\n            final float childScore = childScorer.score();\n            final int childFreq = childScorer.freq();\n            if (pendingChildScores != null) {\n              pendingChildScores[childDocUpto] = childScore;\n            }\n            maxScore = Math.max(childScore, maxScore);\n            totalScore += childScore;\n            parentFreq += childFreq;\n          }\n          childDocUpto++;\n          nextChildDoc = childScorer.nextDoc();\n        } while (nextChildDoc < parentDoc);\n\n        // Parent & child docs are supposed to be\n        // orthogonal:\n        if (nextChildDoc == parentDoc) {\n          throw new IllegalStateException(\"child query must only match non-parent docs, but parent docID=\" + nextChildDoc + \" matched childScorer=\" + childScorer.getClass());\n        }\n\n        switch(scoreMode) {\n        case Avg:\n          parentScore = totalScore / childDocUpto;\n          break;\n        case Max:\n          parentScore = maxScore;\n          break;\n        case Total:\n          parentScore = totalScore;\n          break;\n        case None:\n          break;\n        }\n\n        //System.out.println(\"  return parentDoc=\" + parentDoc + \" childDocUpto=\" + childDocUpto);\n        return parentDoc;\n      }\n    }\n\n","sourceOld":"    @Override\n    public int nextDoc() throws IOException {\n      //System.out.println(\"Q.nextDoc() nextChildDoc=\" + nextChildDoc);\n      // Loop until we hit a parentDoc that's accepted\n      while (true) {\n        if (nextChildDoc == NO_MORE_DOCS) {\n          //System.out.println(\"  end\");\n          return parentDoc = NO_MORE_DOCS;\n        }\n\n        // Gather all children sharing the same parent as\n        // nextChildDoc\n\n        parentDoc = parentBits.nextSetBit(nextChildDoc);\n\n        // Parent & child docs are supposed to be\n        // orthogonal:\n        if (nextChildDoc == parentDoc) {\n          throw new IllegalStateException(\"child query must only match non-parent docs, but parent docID=\" + nextChildDoc + \" matched childScorer=\" + childScorer.getClass());\n        }\n\n        //System.out.println(\"  parentDoc=\" + parentDoc);\n        assert parentDoc != -1;\n\n        //System.out.println(\"  nextChildDoc=\" + nextChildDoc);\n        if (acceptDocs != null && !acceptDocs.get(parentDoc)) {\n          // Parent doc not accepted; skip child docs until\n          // we hit a new parent doc:\n          do {\n            nextChildDoc = childScorer.nextDoc();\n          } while (nextChildDoc < parentDoc);\n\n          // Parent & child docs are supposed to be\n          // orthogonal:\n          if (nextChildDoc == parentDoc) {\n            throw new IllegalStateException(\"child query must only match non-parent docs, but parent docID=\" + nextChildDoc + \" matched childScorer=\" + childScorer.getClass());\n          }\n\n          continue;\n        }\n\n        float totalScore = 0;\n        float maxScore = Float.NEGATIVE_INFINITY;\n\n        childDocUpto = 0;\n        parentFreq = 0;\n        do {\n\n          //System.out.println(\"  c=\" + nextChildDoc);\n          if (pendingChildDocs != null && pendingChildDocs.length == childDocUpto) {\n            pendingChildDocs = ArrayUtil.grow(pendingChildDocs);\n          }\n          if (pendingChildScores != null && scoreMode != ScoreMode.None && pendingChildScores.length == childDocUpto) {\n            pendingChildScores = ArrayUtil.grow(pendingChildScores);\n          }\n          if (pendingChildDocs != null) {\n            pendingChildDocs[childDocUpto] = nextChildDoc;\n          }\n          if (scoreMode != ScoreMode.None) {\n            // TODO: specialize this into dedicated classes per-scoreMode\n            final float childScore = childScorer.score();\n            final int childFreq = childScorer.freq();\n            if (pendingChildScores != null) {\n              pendingChildScores[childDocUpto] = childScore;\n            }\n            maxScore = Math.max(childScore, maxScore);\n            totalScore += childScore;\n            parentFreq += childFreq;\n          }\n          childDocUpto++;\n          nextChildDoc = childScorer.nextDoc();\n        } while (nextChildDoc < parentDoc);\n\n        // Parent & child docs are supposed to be\n        // orthogonal:\n        if (nextChildDoc == parentDoc) {\n          throw new IllegalStateException(\"child query must only match non-parent docs, but parent docID=\" + nextChildDoc + \" matched childScorer=\" + childScorer.getClass());\n        }\n\n        switch(scoreMode) {\n        case Avg:\n          parentScore = totalScore / childDocUpto;\n          break;\n        case Max:\n          parentScore = maxScore;\n          break;\n        case Total:\n          parentScore = totalScore;\n          break;\n        case None:\n          break;\n        }\n\n        //System.out.println(\"  return parentDoc=\" + parentDoc + \" childDocUpto=\" + childDocUpto);\n        return parentDoc;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe4b37941dda041ab19456b15412aacb9c657a26","date":1429449253,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#nextDoc().mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#nextDoc().mjava","sourceNew":"    @Override\n    public int nextDoc() throws IOException {\n      //System.out.println(\"Q.nextDoc() nextChildDoc=\" + nextChildDoc);\n      // Loop until we hit a parentDoc that's accepted\n      while (true) {\n        if (nextChildDoc == NO_MORE_DOCS) {\n          //System.out.println(\"  end\");\n          return parentDoc = NO_MORE_DOCS;\n        }\n\n        // Gather all children sharing the same parent as\n        // nextChildDoc\n\n        parentDoc = parentBits.nextSetBit(nextChildDoc);\n\n        // Parent & child docs are supposed to be\n        // orthogonal:\n        if (nextChildDoc == parentDoc) {\n          throw new IllegalStateException(\"child query must only match non-parent docs, but parent docID=\" + nextChildDoc + \" matched childScorer=\" + childScorer.getClass());\n        }\n\n        //System.out.println(\"  parentDoc=\" + parentDoc);\n        assert parentDoc != DocIdSetIterator.NO_MORE_DOCS;\n\n        //System.out.println(\"  nextChildDoc=\" + nextChildDoc);\n        if (acceptDocs != null && !acceptDocs.get(parentDoc)) {\n          // Parent doc not accepted; skip child docs until\n          // we hit a new parent doc:\n          do {\n            nextChildDoc = childScorer.nextDoc();\n          } while (nextChildDoc < parentDoc);\n\n          // Parent & child docs are supposed to be\n          // orthogonal:\n          if (nextChildDoc == parentDoc) {\n            throw new IllegalStateException(\"child query must only match non-parent docs, but parent docID=\" + nextChildDoc + \" matched childScorer=\" + childScorer.getClass());\n          }\n\n          continue;\n        }\n\n        float totalScore = 0;\n        float maxScore = Float.NEGATIVE_INFINITY;\n        float minScore = Float.POSITIVE_INFINITY;\n\n        childDocUpto = 0;\n        parentFreq = 0;\n        do {\n\n          //System.out.println(\"  c=\" + nextChildDoc);\n          if (pendingChildDocs != null && pendingChildDocs.length == childDocUpto) {\n            pendingChildDocs = ArrayUtil.grow(pendingChildDocs);\n          }\n          if (pendingChildScores != null && scoreMode != ScoreMode.None && pendingChildScores.length == childDocUpto) {\n            pendingChildScores = ArrayUtil.grow(pendingChildScores);\n          }\n          if (pendingChildDocs != null) {\n            pendingChildDocs[childDocUpto] = nextChildDoc;\n          }\n          if (scoreMode != ScoreMode.None) {\n            // TODO: specialize this into dedicated classes per-scoreMode\n            final float childScore = childScorer.score();\n            final int childFreq = childScorer.freq();\n            if (pendingChildScores != null) {\n              pendingChildScores[childDocUpto] = childScore;\n            }\n            maxScore = Math.max(childScore, maxScore);\n            minScore = Math.min(childFreq, minScore);\n            totalScore += childScore;\n            parentFreq += childFreq;\n          }\n          childDocUpto++;\n          nextChildDoc = childScorer.nextDoc();\n        } while (nextChildDoc < parentDoc);\n\n        // Parent & child docs are supposed to be\n        // orthogonal:\n        if (nextChildDoc == parentDoc) {\n          throw new IllegalStateException(\"child query must only match non-parent docs, but parent docID=\" + nextChildDoc + \" matched childScorer=\" + childScorer.getClass());\n        }\n\n        switch(scoreMode) {\n        case Avg:\n          parentScore = totalScore / childDocUpto;\n          break;\n        case Max:\n          parentScore = maxScore;\n          break;\n        case Min:\n          parentScore = minScore;\n          break;\n        case Total:\n          parentScore = totalScore;\n          break;\n        case None:\n          break;\n        }\n\n        //System.out.println(\"  return parentDoc=\" + parentDoc + \" childDocUpto=\" + childDocUpto);\n        return parentDoc;\n      }\n    }\n\n","sourceOld":"    @Override\n    public int nextDoc() throws IOException {\n      //System.out.println(\"Q.nextDoc() nextChildDoc=\" + nextChildDoc);\n      // Loop until we hit a parentDoc that's accepted\n      while (true) {\n        if (nextChildDoc == NO_MORE_DOCS) {\n          //System.out.println(\"  end\");\n          return parentDoc = NO_MORE_DOCS;\n        }\n\n        // Gather all children sharing the same parent as\n        // nextChildDoc\n\n        parentDoc = parentBits.nextSetBit(nextChildDoc);\n\n        // Parent & child docs are supposed to be\n        // orthogonal:\n        if (nextChildDoc == parentDoc) {\n          throw new IllegalStateException(\"child query must only match non-parent docs, but parent docID=\" + nextChildDoc + \" matched childScorer=\" + childScorer.getClass());\n        }\n\n        //System.out.println(\"  parentDoc=\" + parentDoc);\n        assert parentDoc != DocIdSetIterator.NO_MORE_DOCS;\n\n        //System.out.println(\"  nextChildDoc=\" + nextChildDoc);\n        if (acceptDocs != null && !acceptDocs.get(parentDoc)) {\n          // Parent doc not accepted; skip child docs until\n          // we hit a new parent doc:\n          do {\n            nextChildDoc = childScorer.nextDoc();\n          } while (nextChildDoc < parentDoc);\n\n          // Parent & child docs are supposed to be\n          // orthogonal:\n          if (nextChildDoc == parentDoc) {\n            throw new IllegalStateException(\"child query must only match non-parent docs, but parent docID=\" + nextChildDoc + \" matched childScorer=\" + childScorer.getClass());\n          }\n\n          continue;\n        }\n\n        float totalScore = 0;\n        float maxScore = Float.NEGATIVE_INFINITY;\n\n        childDocUpto = 0;\n        parentFreq = 0;\n        do {\n\n          //System.out.println(\"  c=\" + nextChildDoc);\n          if (pendingChildDocs != null && pendingChildDocs.length == childDocUpto) {\n            pendingChildDocs = ArrayUtil.grow(pendingChildDocs);\n          }\n          if (pendingChildScores != null && scoreMode != ScoreMode.None && pendingChildScores.length == childDocUpto) {\n            pendingChildScores = ArrayUtil.grow(pendingChildScores);\n          }\n          if (pendingChildDocs != null) {\n            pendingChildDocs[childDocUpto] = nextChildDoc;\n          }\n          if (scoreMode != ScoreMode.None) {\n            // TODO: specialize this into dedicated classes per-scoreMode\n            final float childScore = childScorer.score();\n            final int childFreq = childScorer.freq();\n            if (pendingChildScores != null) {\n              pendingChildScores[childDocUpto] = childScore;\n            }\n            maxScore = Math.max(childScore, maxScore);\n            totalScore += childScore;\n            parentFreq += childFreq;\n          }\n          childDocUpto++;\n          nextChildDoc = childScorer.nextDoc();\n        } while (nextChildDoc < parentDoc);\n\n        // Parent & child docs are supposed to be\n        // orthogonal:\n        if (nextChildDoc == parentDoc) {\n          throw new IllegalStateException(\"child query must only match non-parent docs, but parent docID=\" + nextChildDoc + \" matched childScorer=\" + childScorer.getClass());\n        }\n\n        switch(scoreMode) {\n        case Avg:\n          parentScore = totalScore / childDocUpto;\n          break;\n        case Max:\n          parentScore = maxScore;\n          break;\n        case Total:\n          parentScore = totalScore;\n          break;\n        case None:\n          break;\n        }\n\n        //System.out.println(\"  return parentDoc=\" + parentDoc + \" childDocUpto=\" + childDocUpto);\n        return parentDoc;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#nextDoc().mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#nextDoc().mjava","sourceNew":"    @Override\n    public int nextDoc() throws IOException {\n      //System.out.println(\"Q.nextDoc() nextChildDoc=\" + nextChildDoc);\n      if (nextChildDoc == NO_MORE_DOCS) {\n        //System.out.println(\"  end\");\n        return parentDoc = NO_MORE_DOCS;\n      }\n\n      // Gather all children sharing the same parent as\n      // nextChildDoc\n\n      parentDoc = parentBits.nextSetBit(nextChildDoc);\n\n      // Parent & child docs are supposed to be\n      // orthogonal:\n      if (nextChildDoc == parentDoc) {\n        throw new IllegalStateException(\"child query must only match non-parent docs, but parent docID=\" + nextChildDoc + \" matched childScorer=\" + childScorer.getClass());\n      }\n\n      //System.out.println(\"  parentDoc=\" + parentDoc);\n      assert parentDoc != DocIdSetIterator.NO_MORE_DOCS;\n\n      float totalScore = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      float minScore = Float.POSITIVE_INFINITY;\n\n      childDocUpto = 0;\n      parentFreq = 0;\n      do {\n\n        //System.out.println(\"  c=\" + nextChildDoc);\n        if (pendingChildDocs != null && pendingChildDocs.length == childDocUpto) {\n          pendingChildDocs = ArrayUtil.grow(pendingChildDocs);\n        }\n        if (pendingChildScores != null && scoreMode != ScoreMode.None && pendingChildScores.length == childDocUpto) {\n          pendingChildScores = ArrayUtil.grow(pendingChildScores);\n        }\n        if (pendingChildDocs != null) {\n          pendingChildDocs[childDocUpto] = nextChildDoc;\n        }\n        if (scoreMode != ScoreMode.None) {\n          // TODO: specialize this into dedicated classes per-scoreMode\n          final float childScore = childScorer.score();\n          final int childFreq = childScorer.freq();\n          if (pendingChildScores != null) {\n            pendingChildScores[childDocUpto] = childScore;\n          }\n          maxScore = Math.max(childScore, maxScore);\n          minScore = Math.min(childFreq, minScore);\n          totalScore += childScore;\n          parentFreq += childFreq;\n        }\n        childDocUpto++;\n        nextChildDoc = childScorer.nextDoc();\n      } while (nextChildDoc < parentDoc);\n\n      // Parent & child docs are supposed to be\n      // orthogonal:\n      if (nextChildDoc == parentDoc) {\n        throw new IllegalStateException(\"child query must only match non-parent docs, but parent docID=\" + nextChildDoc + \" matched childScorer=\" + childScorer.getClass());\n      }\n\n      switch(scoreMode) {\n      case Avg:\n        parentScore = totalScore / childDocUpto;\n        break;\n      case Max:\n        parentScore = maxScore;\n        break;\n      case Min:\n        parentScore = minScore;\n        break;\n      case Total:\n        parentScore = totalScore;\n        break;\n      case None:\n        break;\n      }\n\n      //System.out.println(\"  return parentDoc=\" + parentDoc + \" childDocUpto=\" + childDocUpto);\n      return parentDoc;\n    }\n\n","sourceOld":"    @Override\n    public int nextDoc() throws IOException {\n      //System.out.println(\"Q.nextDoc() nextChildDoc=\" + nextChildDoc);\n      // Loop until we hit a parentDoc that's accepted\n      while (true) {\n        if (nextChildDoc == NO_MORE_DOCS) {\n          //System.out.println(\"  end\");\n          return parentDoc = NO_MORE_DOCS;\n        }\n\n        // Gather all children sharing the same parent as\n        // nextChildDoc\n\n        parentDoc = parentBits.nextSetBit(nextChildDoc);\n\n        // Parent & child docs are supposed to be\n        // orthogonal:\n        if (nextChildDoc == parentDoc) {\n          throw new IllegalStateException(\"child query must only match non-parent docs, but parent docID=\" + nextChildDoc + \" matched childScorer=\" + childScorer.getClass());\n        }\n\n        //System.out.println(\"  parentDoc=\" + parentDoc);\n        assert parentDoc != DocIdSetIterator.NO_MORE_DOCS;\n\n        //System.out.println(\"  nextChildDoc=\" + nextChildDoc);\n        if (acceptDocs != null && !acceptDocs.get(parentDoc)) {\n          // Parent doc not accepted; skip child docs until\n          // we hit a new parent doc:\n          do {\n            nextChildDoc = childScorer.nextDoc();\n          } while (nextChildDoc < parentDoc);\n\n          // Parent & child docs are supposed to be\n          // orthogonal:\n          if (nextChildDoc == parentDoc) {\n            throw new IllegalStateException(\"child query must only match non-parent docs, but parent docID=\" + nextChildDoc + \" matched childScorer=\" + childScorer.getClass());\n          }\n\n          continue;\n        }\n\n        float totalScore = 0;\n        float maxScore = Float.NEGATIVE_INFINITY;\n        float minScore = Float.POSITIVE_INFINITY;\n\n        childDocUpto = 0;\n        parentFreq = 0;\n        do {\n\n          //System.out.println(\"  c=\" + nextChildDoc);\n          if (pendingChildDocs != null && pendingChildDocs.length == childDocUpto) {\n            pendingChildDocs = ArrayUtil.grow(pendingChildDocs);\n          }\n          if (pendingChildScores != null && scoreMode != ScoreMode.None && pendingChildScores.length == childDocUpto) {\n            pendingChildScores = ArrayUtil.grow(pendingChildScores);\n          }\n          if (pendingChildDocs != null) {\n            pendingChildDocs[childDocUpto] = nextChildDoc;\n          }\n          if (scoreMode != ScoreMode.None) {\n            // TODO: specialize this into dedicated classes per-scoreMode\n            final float childScore = childScorer.score();\n            final int childFreq = childScorer.freq();\n            if (pendingChildScores != null) {\n              pendingChildScores[childDocUpto] = childScore;\n            }\n            maxScore = Math.max(childScore, maxScore);\n            minScore = Math.min(childFreq, minScore);\n            totalScore += childScore;\n            parentFreq += childFreq;\n          }\n          childDocUpto++;\n          nextChildDoc = childScorer.nextDoc();\n        } while (nextChildDoc < parentDoc);\n\n        // Parent & child docs are supposed to be\n        // orthogonal:\n        if (nextChildDoc == parentDoc) {\n          throw new IllegalStateException(\"child query must only match non-parent docs, but parent docID=\" + nextChildDoc + \" matched childScorer=\" + childScorer.getClass());\n        }\n\n        switch(scoreMode) {\n        case Avg:\n          parentScore = totalScore / childDocUpto;\n          break;\n        case Max:\n          parentScore = maxScore;\n          break;\n        case Min:\n          parentScore = minScore;\n          break;\n        case Total:\n          parentScore = totalScore;\n          break;\n        case None:\n          break;\n        }\n\n        //System.out.println(\"  return parentDoc=\" + parentDoc + \" childDocUpto=\" + childDocUpto);\n        return parentDoc;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0b5dc820d653826ca85d4355563ef001f156c644","date":1438618492,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#nextDoc().mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#nextDoc().mjava","sourceNew":"    @Override\n    public int nextDoc() throws IOException {\n      //System.out.println(\"Q.nextDoc() nextChildDoc=\" + nextChildDoc);\n      if (nextChildDoc == NO_MORE_DOCS) {\n        //System.out.println(\"  end\");\n        return parentDoc = NO_MORE_DOCS;\n      }\n\n      // Gather all children sharing the same parent as\n      // nextChildDoc\n\n      parentDoc = parentBits.nextSetBit(nextChildDoc);\n\n      // Parent & child docs are supposed to be\n      // orthogonal:\n      if (nextChildDoc == parentDoc) {\n        throw new IllegalStateException(\"child query must only match non-parent docs, but parent docID=\" + nextChildDoc + \" matched childScorer=\" + childScorer.getClass());\n      }\n\n      //System.out.println(\"  parentDoc=\" + parentDoc);\n      assert parentDoc != DocIdSetIterator.NO_MORE_DOCS;\n\n      float totalScore = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      float minScore = Float.POSITIVE_INFINITY;\n\n      childDocUpto = 0;\n      parentFreq = 0;\n      do {\n\n        //System.out.println(\"  c=\" + nextChildDoc);\n        if (pendingChildDocs != null && pendingChildDocs.length == childDocUpto) {\n          pendingChildDocs = ArrayUtil.grow(pendingChildDocs);\n        }\n        if (pendingChildScores != null && scoreMode != ScoreMode.None && pendingChildScores.length == childDocUpto) {\n          pendingChildScores = ArrayUtil.grow(pendingChildScores);\n        }\n        if (pendingChildDocs != null) {\n          pendingChildDocs[childDocUpto] = nextChildDoc;\n        }\n        if (scoreMode != ScoreMode.None) {\n          // TODO: specialize this into dedicated classes per-scoreMode\n          final float childScore = childScorer.score();\n          final int childFreq = childScorer.freq();\n          if (pendingChildScores != null) {\n            pendingChildScores[childDocUpto] = childScore;\n          }\n          maxScore = Math.max(childScore, maxScore);\n          minScore = Math.min(childScore, minScore);\n          totalScore += childScore;\n          parentFreq += childFreq;\n        }\n        childDocUpto++;\n        nextChildDoc = childScorer.nextDoc();\n      } while (nextChildDoc < parentDoc);\n\n      // Parent & child docs are supposed to be\n      // orthogonal:\n      if (nextChildDoc == parentDoc) {\n        throw new IllegalStateException(\"child query must only match non-parent docs, but parent docID=\" + nextChildDoc + \" matched childScorer=\" + childScorer.getClass());\n      }\n\n      switch(scoreMode) {\n      case Avg:\n        parentScore = totalScore / childDocUpto;\n        break;\n      case Max:\n        parentScore = maxScore;\n        break;\n      case Min:\n        parentScore = minScore;\n        break;\n      case Total:\n        parentScore = totalScore;\n        break;\n      case None:\n        break;\n      }\n\n      //System.out.println(\"  return parentDoc=\" + parentDoc + \" childDocUpto=\" + childDocUpto);\n      return parentDoc;\n    }\n\n","sourceOld":"    @Override\n    public int nextDoc() throws IOException {\n      //System.out.println(\"Q.nextDoc() nextChildDoc=\" + nextChildDoc);\n      if (nextChildDoc == NO_MORE_DOCS) {\n        //System.out.println(\"  end\");\n        return parentDoc = NO_MORE_DOCS;\n      }\n\n      // Gather all children sharing the same parent as\n      // nextChildDoc\n\n      parentDoc = parentBits.nextSetBit(nextChildDoc);\n\n      // Parent & child docs are supposed to be\n      // orthogonal:\n      if (nextChildDoc == parentDoc) {\n        throw new IllegalStateException(\"child query must only match non-parent docs, but parent docID=\" + nextChildDoc + \" matched childScorer=\" + childScorer.getClass());\n      }\n\n      //System.out.println(\"  parentDoc=\" + parentDoc);\n      assert parentDoc != DocIdSetIterator.NO_MORE_DOCS;\n\n      float totalScore = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      float minScore = Float.POSITIVE_INFINITY;\n\n      childDocUpto = 0;\n      parentFreq = 0;\n      do {\n\n        //System.out.println(\"  c=\" + nextChildDoc);\n        if (pendingChildDocs != null && pendingChildDocs.length == childDocUpto) {\n          pendingChildDocs = ArrayUtil.grow(pendingChildDocs);\n        }\n        if (pendingChildScores != null && scoreMode != ScoreMode.None && pendingChildScores.length == childDocUpto) {\n          pendingChildScores = ArrayUtil.grow(pendingChildScores);\n        }\n        if (pendingChildDocs != null) {\n          pendingChildDocs[childDocUpto] = nextChildDoc;\n        }\n        if (scoreMode != ScoreMode.None) {\n          // TODO: specialize this into dedicated classes per-scoreMode\n          final float childScore = childScorer.score();\n          final int childFreq = childScorer.freq();\n          if (pendingChildScores != null) {\n            pendingChildScores[childDocUpto] = childScore;\n          }\n          maxScore = Math.max(childScore, maxScore);\n          minScore = Math.min(childFreq, minScore);\n          totalScore += childScore;\n          parentFreq += childFreq;\n        }\n        childDocUpto++;\n        nextChildDoc = childScorer.nextDoc();\n      } while (nextChildDoc < parentDoc);\n\n      // Parent & child docs are supposed to be\n      // orthogonal:\n      if (nextChildDoc == parentDoc) {\n        throw new IllegalStateException(\"child query must only match non-parent docs, but parent docID=\" + nextChildDoc + \" matched childScorer=\" + childScorer.getClass());\n      }\n\n      switch(scoreMode) {\n      case Avg:\n        parentScore = totalScore / childDocUpto;\n        break;\n      case Max:\n        parentScore = maxScore;\n        break;\n      case Min:\n        parentScore = minScore;\n        break;\n      case Total:\n        parentScore = totalScore;\n        break;\n      case None:\n        break;\n      }\n\n      //System.out.println(\"  return parentDoc=\" + parentDoc + \" childDocUpto=\" + childDocUpto);\n      return parentDoc;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7dd748bb245633a8195281556bb0e68a6ea97d18","date":1449755030,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.BlockJoinScorer#nextDoc().mjava","sourceNew":null,"sourceOld":"    @Override\n    public int nextDoc() throws IOException {\n      //System.out.println(\"Q.nextDoc() nextChildDoc=\" + nextChildDoc);\n      if (nextChildDoc == NO_MORE_DOCS) {\n        //System.out.println(\"  end\");\n        return parentDoc = NO_MORE_DOCS;\n      }\n\n      // Gather all children sharing the same parent as\n      // nextChildDoc\n\n      parentDoc = parentBits.nextSetBit(nextChildDoc);\n\n      // Parent & child docs are supposed to be\n      // orthogonal:\n      if (nextChildDoc == parentDoc) {\n        throw new IllegalStateException(\"child query must only match non-parent docs, but parent docID=\" + nextChildDoc + \" matched childScorer=\" + childScorer.getClass());\n      }\n\n      //System.out.println(\"  parentDoc=\" + parentDoc);\n      assert parentDoc != DocIdSetIterator.NO_MORE_DOCS;\n\n      float totalScore = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      float minScore = Float.POSITIVE_INFINITY;\n\n      childDocUpto = 0;\n      parentFreq = 0;\n      do {\n\n        //System.out.println(\"  c=\" + nextChildDoc);\n        if (pendingChildDocs != null && pendingChildDocs.length == childDocUpto) {\n          pendingChildDocs = ArrayUtil.grow(pendingChildDocs);\n        }\n        if (pendingChildScores != null && scoreMode != ScoreMode.None && pendingChildScores.length == childDocUpto) {\n          pendingChildScores = ArrayUtil.grow(pendingChildScores);\n        }\n        if (pendingChildDocs != null) {\n          pendingChildDocs[childDocUpto] = nextChildDoc;\n        }\n        if (scoreMode != ScoreMode.None) {\n          // TODO: specialize this into dedicated classes per-scoreMode\n          final float childScore = childScorer.score();\n          final int childFreq = childScorer.freq();\n          if (pendingChildScores != null) {\n            pendingChildScores[childDocUpto] = childScore;\n          }\n          maxScore = Math.max(childScore, maxScore);\n          minScore = Math.min(childScore, minScore);\n          totalScore += childScore;\n          parentFreq += childFreq;\n        }\n        childDocUpto++;\n        nextChildDoc = childScorer.nextDoc();\n      } while (nextChildDoc < parentDoc);\n\n      // Parent & child docs are supposed to be\n      // orthogonal:\n      if (nextChildDoc == parentDoc) {\n        throw new IllegalStateException(\"child query must only match non-parent docs, but parent docID=\" + nextChildDoc + \" matched childScorer=\" + childScorer.getClass());\n      }\n\n      switch(scoreMode) {\n      case Avg:\n        parentScore = totalScore / childDocUpto;\n        break;\n      case Max:\n        parentScore = maxScore;\n        break;\n      case Min:\n        parentScore = minScore;\n        break;\n      case Total:\n        parentScore = totalScore;\n        break;\n      case None:\n        break;\n      }\n\n      //System.out.println(\"  return parentDoc=\" + parentDoc + \" childDocUpto=\" + childDocUpto);\n      return parentDoc;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0b5dc820d653826ca85d4355563ef001f156c644":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"ea8268d5f00bb25a4ea1d0bac6e2ffe238712c45":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"757496f10c991c553a874f78fb06c3f0dc110dff":["ea8268d5f00bb25a4ea1d0bac6e2ffe238712c45","05a9119f665d52b16e936bb48c5b836609aadbc5"],"fe4b37941dda041ab19456b15412aacb9c657a26":["0abcec02c9851c46c70a75bd42fb6e4d5348ac9e"],"05a9119f665d52b16e936bb48c5b836609aadbc5":["ea8268d5f00bb25a4ea1d0bac6e2ffe238712c45"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["fe4b37941dda041ab19456b15412aacb9c657a26"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"aba371508186796cc6151d8223a5b4e16d02e26e":["b89678825b68eccaf09e6ab71675fc0b0af1e099","ea8268d5f00bb25a4ea1d0bac6e2ffe238712c45"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["b89678825b68eccaf09e6ab71675fc0b0af1e099","ea8268d5f00bb25a4ea1d0bac6e2ffe238712c45"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a5db3cbd9c8643765faaef10ef026c766b653290":["ab5548b8f3ccb00ab6a8702dfc85a949d2a05a11"],"ab5548b8f3ccb00ab6a8702dfc85a949d2a05a11":["757496f10c991c553a874f78fb06c3f0dc110dff"],"7dd748bb245633a8195281556bb0e68a6ea97d18":["0b5dc820d653826ca85d4355563ef001f156c644"],"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e":["a5db3cbd9c8643765faaef10ef026c766b653290"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7dd748bb245633a8195281556bb0e68a6ea97d18"]},"commit2Childs":{"0b5dc820d653826ca85d4355563ef001f156c644":["7dd748bb245633a8195281556bb0e68a6ea97d18"],"ea8268d5f00bb25a4ea1d0bac6e2ffe238712c45":["757496f10c991c553a874f78fb06c3f0dc110dff","05a9119f665d52b16e936bb48c5b836609aadbc5","aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"757496f10c991c553a874f78fb06c3f0dc110dff":["ab5548b8f3ccb00ab6a8702dfc85a949d2a05a11"],"fe4b37941dda041ab19456b15412aacb9c657a26":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"05a9119f665d52b16e936bb48c5b836609aadbc5":["757496f10c991c553a874f78fb06c3f0dc110dff"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["0b5dc820d653826ca85d4355563ef001f156c644"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["ea8268d5f00bb25a4ea1d0bac6e2ffe238712c45","aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"a5db3cbd9c8643765faaef10ef026c766b653290":["0abcec02c9851c46c70a75bd42fb6e4d5348ac9e"],"ab5548b8f3ccb00ab6a8702dfc85a949d2a05a11":["a5db3cbd9c8643765faaef10ef026c766b653290"],"7dd748bb245633a8195281556bb0e68a6ea97d18":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e":["fe4b37941dda041ab19456b15412aacb9c657a26"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}