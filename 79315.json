{"path":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#closeSegmentStates(IndexWriter.ReaderPool,SegmentState[],boolean).mjava","commits":[{"id":"f4363cd33f6eff7fb4753574a441e2d18c1022a4","date":1498067235,"type":1,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#closeSegmentStates(IndexWriter.ReaderPool,SegmentState[],boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#closeSegmentStates(IndexWriter.ReaderPool,SegmentState[],boolean,long).mjava","sourceNew":"  /** Close segment states previously opened with openSegmentStates. */\n  public ApplyDeletesResult closeSegmentStates(IndexWriter.ReaderPool pool, SegmentState[] segStates, boolean success) throws IOException {\n    int count = segStates.length;\n    Throwable firstExc = null;\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n\n    for (int j=0;j<count;j++) {\n      SegmentState segState = segStates[j];\n      if (success) {\n        totDelCount += segState.rld.getPendingDeleteCount() - segState.startDelCount;\n        int fullDelCount = segState.rld.info.getDelCount() + segState.rld.getPendingDeleteCount();\n        assert fullDelCount <= segState.rld.info.info.maxDoc();\n        if (fullDelCount == segState.rld.info.info.maxDoc()) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(segState.reader.getSegmentInfo());\n        }\n      }\n      try {\n        segStates[j].finish(pool);\n      } catch (Throwable th) {\n        if (firstExc == null) {\n          firstExc = th;\n        }\n      }\n    }\n\n    if (success) {\n      if (firstExc != null) {\n        throw IOUtils.rethrowAlways(firstExc);\n      }\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"closeSegmentStates: \" + totDelCount + \" new deleted documents; pool \" + updates.size() + \" packets; bytesUsed=\" + pool.ramBytesUsed());\n    }\n\n    return new ApplyDeletesResult(totDelCount > 0, allDeleted);      \n  }\n\n","sourceOld":"  /** Close segment states previously opened with openSegmentStates. */\n  private ApplyDeletesResult closeSegmentStates(IndexWriter.ReaderPool pool, SegmentState[] segStates, boolean success, long gen) throws IOException {\n    int numReaders = segStates.length;\n    Throwable firstExc = null;\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n    for (int j=0;j<numReaders;j++) {\n      SegmentState segState = segStates[j];\n      if (success) {\n        totDelCount += segState.rld.getPendingDeleteCount() - segState.startDelCount;\n        segState.reader.getSegmentInfo().setBufferedDeletesGen(gen);\n        int fullDelCount = segState.rld.info.getDelCount() + segState.rld.getPendingDeleteCount();\n        assert fullDelCount <= segState.rld.info.info.maxDoc();\n        if (fullDelCount == segState.rld.info.info.maxDoc()) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(segState.reader.getSegmentInfo());\n        }\n      }\n      try {\n        segStates[j].finish(pool);\n      } catch (Throwable th) {\n        if (firstExc == null) {\n          firstExc = th;\n        }\n      }\n    }\n\n    if (success) {\n      if (firstExc != null) {\n        throw IOUtils.rethrowAlways(firstExc);\n      }\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: \" + totDelCount + \" new deleted documents\");\n    }\n\n    return new ApplyDeletesResult(totDelCount > 0, gen, allDeleted);      \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":1,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#closeSegmentStates(IndexWriter.ReaderPool,SegmentState[],boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#closeSegmentStates(IndexWriter.ReaderPool,SegmentState[],boolean,long).mjava","sourceNew":"  /** Close segment states previously opened with openSegmentStates. */\n  public ApplyDeletesResult closeSegmentStates(IndexWriter.ReaderPool pool, SegmentState[] segStates, boolean success) throws IOException {\n    int count = segStates.length;\n    Throwable firstExc = null;\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n\n    for (int j=0;j<count;j++) {\n      SegmentState segState = segStates[j];\n      if (success) {\n        totDelCount += segState.rld.getPendingDeleteCount() - segState.startDelCount;\n        int fullDelCount = segState.rld.info.getDelCount() + segState.rld.getPendingDeleteCount();\n        assert fullDelCount <= segState.rld.info.info.maxDoc();\n        if (fullDelCount == segState.rld.info.info.maxDoc()) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(segState.reader.getSegmentInfo());\n        }\n      }\n      try {\n        segStates[j].finish(pool);\n      } catch (Throwable th) {\n        if (firstExc == null) {\n          firstExc = th;\n        }\n      }\n    }\n\n    if (success) {\n      if (firstExc != null) {\n        throw IOUtils.rethrowAlways(firstExc);\n      }\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"closeSegmentStates: \" + totDelCount + \" new deleted documents; pool \" + updates.size() + \" packets; bytesUsed=\" + pool.ramBytesUsed());\n    }\n\n    return new ApplyDeletesResult(totDelCount > 0, allDeleted);      \n  }\n\n","sourceOld":"  /** Close segment states previously opened with openSegmentStates. */\n  private ApplyDeletesResult closeSegmentStates(IndexWriter.ReaderPool pool, SegmentState[] segStates, boolean success, long gen) throws IOException {\n    int numReaders = segStates.length;\n    Throwable firstExc = null;\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n    for (int j=0;j<numReaders;j++) {\n      SegmentState segState = segStates[j];\n      if (success) {\n        totDelCount += segState.rld.getPendingDeleteCount() - segState.startDelCount;\n        segState.reader.getSegmentInfo().setBufferedDeletesGen(gen);\n        int fullDelCount = segState.rld.info.getDelCount() + segState.rld.getPendingDeleteCount();\n        assert fullDelCount <= segState.rld.info.info.maxDoc();\n        if (fullDelCount == segState.rld.info.info.maxDoc()) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(segState.reader.getSegmentInfo());\n        }\n      }\n      try {\n        segStates[j].finish(pool);\n      } catch (Throwable th) {\n        if (firstExc == null) {\n          firstExc = th;\n        }\n      }\n    }\n\n    if (success) {\n      if (firstExc != null) {\n        throw IOUtils.rethrowAlways(firstExc);\n      }\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"applyDeletes: \" + totDelCount + \" new deleted documents\");\n    }\n\n    return new ApplyDeletesResult(totDelCount > 0, gen, allDeleted);      \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#closeSegmentStates(IndexWriter.ReaderPool,SegmentState[],boolean).mjava","pathOld":"/dev/null","sourceNew":"  /** Close segment states previously opened with openSegmentStates. */\n  public ApplyDeletesResult closeSegmentStates(IndexWriter.ReaderPool pool, SegmentState[] segStates, boolean success) throws IOException {\n    int count = segStates.length;\n    Throwable firstExc = null;\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n\n    for (int j=0;j<count;j++) {\n      SegmentState segState = segStates[j];\n      if (success) {\n        totDelCount += segState.rld.getPendingDeleteCount() - segState.startDelCount;\n        int fullDelCount = segState.rld.info.getDelCount() + segState.rld.getPendingDeleteCount();\n        assert fullDelCount <= segState.rld.info.info.maxDoc();\n        if (fullDelCount == segState.rld.info.info.maxDoc()) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(segState.reader.getSegmentInfo());\n        }\n      }\n      try {\n        segStates[j].finish(pool);\n      } catch (Throwable th) {\n        if (firstExc == null) {\n          firstExc = th;\n        }\n      }\n    }\n\n    if (success) {\n      if (firstExc != null) {\n        throw IOUtils.rethrowAlways(firstExc);\n      }\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"closeSegmentStates: \" + totDelCount + \" new deleted documents; pool \" + updates.size() + \" packets; bytesUsed=\" + pool.ramBytesUsed());\n    }\n\n    return new ApplyDeletesResult(totDelCount > 0, allDeleted);      \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14d66d86a8b184a86bcaebcf6e15fcef486e0876","date":1521539412,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#closeSegmentStates(IndexWriter.ReaderPool,SegmentState[],boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#closeSegmentStates(IndexWriter.ReaderPool,SegmentState[],boolean).mjava","sourceNew":"  /** Close segment states previously opened with openSegmentStates. */\n  public ApplyDeletesResult closeSegmentStates(IndexWriter.ReaderPool pool, SegmentState[] segStates, boolean success) throws IOException {\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n    final List<SegmentState> segmentStates = Arrays.asList(segStates);\n    for (SegmentState segState : segmentStates) {\n      if (success) {\n        totDelCount += segState.rld.getPendingDeleteCount() - segState.startDelCount;\n        int fullDelCount = segState.rld.info.getDelCount() + segState.rld.getPendingDeleteCount();\n        assert fullDelCount <= segState.rld.info.info.maxDoc();\n        if (fullDelCount == segState.rld.info.info.maxDoc()) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(segState.reader.getSegmentInfo());\n        }\n      }\n    }\n    IOUtils.applyToAll(segmentStates, s -> s.finish(pool));\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"closeSegmentStates: \" + totDelCount + \" new deleted documents; pool \" + updates.size() + \" packets; bytesUsed=\" + pool.ramBytesUsed());\n    }\n\n    return new ApplyDeletesResult(totDelCount > 0, allDeleted);      \n  }\n\n","sourceOld":"  /** Close segment states previously opened with openSegmentStates. */\n  public ApplyDeletesResult closeSegmentStates(IndexWriter.ReaderPool pool, SegmentState[] segStates, boolean success) throws IOException {\n    int count = segStates.length;\n    Throwable firstExc = null;\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n\n    for (int j=0;j<count;j++) {\n      SegmentState segState = segStates[j];\n      if (success) {\n        totDelCount += segState.rld.getPendingDeleteCount() - segState.startDelCount;\n        int fullDelCount = segState.rld.info.getDelCount() + segState.rld.getPendingDeleteCount();\n        assert fullDelCount <= segState.rld.info.info.maxDoc();\n        if (fullDelCount == segState.rld.info.info.maxDoc()) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(segState.reader.getSegmentInfo());\n        }\n      }\n      try {\n        segStates[j].finish(pool);\n      } catch (Throwable th) {\n        if (firstExc == null) {\n          firstExc = th;\n        }\n      }\n    }\n\n    if (success) {\n      if (firstExc != null) {\n        throw IOUtils.rethrowAlways(firstExc);\n      }\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"closeSegmentStates: \" + totDelCount + \" new deleted documents; pool \" + updates.size() + \" packets; bytesUsed=\" + pool.ramBytesUsed());\n    }\n\n    return new ApplyDeletesResult(totDelCount > 0, allDeleted);      \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43","date":1521731438,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#closeSegmentStates(IndexWriter.ReaderPool,SegmentState[],boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#closeSegmentStates(IndexWriter.ReaderPool,SegmentState[],boolean).mjava","sourceNew":"  /** Close segment states previously opened with openSegmentStates. */\n  public ApplyDeletesResult closeSegmentStates(IndexWriter.ReaderPool pool, SegmentState[] segStates, boolean success) throws IOException {\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n    final List<SegmentState> segmentStates = Arrays.asList(segStates);\n    for (SegmentState segState : segmentStates) {\n      if (success) {\n        totDelCount += segState.rld.getPendingDeleteCount() - segState.startDelCount;\n        int fullDelCount = segState.rld.info.getDelCount() + segState.rld.getPendingDeleteCount();\n        assert fullDelCount <= segState.rld.info.info.maxDoc();\n        if (fullDelCount == segState.rld.info.info.maxDoc()) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(segState.reader.getSegmentInfo());\n        }\n      }\n    }\n    IOUtils.applyToAll(segmentStates, s -> s.finish(pool));\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"closeSegmentStates: \" + totDelCount + \" new deleted documents; pool \" + updates.size() + \" packets; bytesUsed=\" + pool.ramBytesUsed());\n    }\n\n    return new ApplyDeletesResult(totDelCount > 0, allDeleted);      \n  }\n\n","sourceOld":"  /** Close segment states previously opened with openSegmentStates. */\n  public ApplyDeletesResult closeSegmentStates(IndexWriter.ReaderPool pool, SegmentState[] segStates, boolean success) throws IOException {\n    int count = segStates.length;\n    Throwable firstExc = null;\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n\n    for (int j=0;j<count;j++) {\n      SegmentState segState = segStates[j];\n      if (success) {\n        totDelCount += segState.rld.getPendingDeleteCount() - segState.startDelCount;\n        int fullDelCount = segState.rld.info.getDelCount() + segState.rld.getPendingDeleteCount();\n        assert fullDelCount <= segState.rld.info.info.maxDoc();\n        if (fullDelCount == segState.rld.info.info.maxDoc()) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(segState.reader.getSegmentInfo());\n        }\n      }\n      try {\n        segStates[j].finish(pool);\n      } catch (Throwable th) {\n        if (firstExc == null) {\n          firstExc = th;\n        }\n      }\n    }\n\n    if (success) {\n      if (firstExc != null) {\n        throw IOUtils.rethrowAlways(firstExc);\n      }\n    }\n\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"closeSegmentStates: \" + totDelCount + \" new deleted documents; pool \" + updates.size() + \" packets; bytesUsed=\" + pool.ramBytesUsed());\n    }\n\n    return new ApplyDeletesResult(totDelCount > 0, allDeleted);      \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d60c1bb96a28a26d197c36299f7b6c9c5da617a1","date":1522484702,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#closeSegmentStates(IndexWriter.ReaderPool,SegmentState[],boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#closeSegmentStates(IndexWriter.ReaderPool,SegmentState[],boolean).mjava","sourceNew":"  /** Close segment states previously opened with openSegmentStates. */\n  public ApplyDeletesResult closeSegmentStates(IndexWriter.ReaderPool pool, SegmentState[] segStates, boolean success) throws IOException {\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n    final List<SegmentState> segmentStates = Arrays.asList(segStates);\n    for (SegmentState segState : segmentStates) {\n      if (success) {\n        totDelCount += segState.rld.getPendingDeleteCount() - segState.startDelCount;\n        int fullDelCount = segState.rld.info.getDelCount() + segState.rld.getPendingDeleteCount();\n        assert fullDelCount <= segState.rld.info.info.maxDoc() : fullDelCount + \" > \" + segState.rld.info.info.maxDoc();\n        if (segState.rld.isFullyDeleted()) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(segState.reader.getSegmentInfo());\n        }\n      }\n    }\n    IOUtils.applyToAll(segmentStates, s -> s.finish(pool));\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"closeSegmentStates: \" + totDelCount + \" new deleted documents; pool \" + updates.size() + \" packets; bytesUsed=\" + pool.ramBytesUsed());\n    }\n\n    return new ApplyDeletesResult(totDelCount > 0, allDeleted);      \n  }\n\n","sourceOld":"  /** Close segment states previously opened with openSegmentStates. */\n  public ApplyDeletesResult closeSegmentStates(IndexWriter.ReaderPool pool, SegmentState[] segStates, boolean success) throws IOException {\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n    final List<SegmentState> segmentStates = Arrays.asList(segStates);\n    for (SegmentState segState : segmentStates) {\n      if (success) {\n        totDelCount += segState.rld.getPendingDeleteCount() - segState.startDelCount;\n        int fullDelCount = segState.rld.info.getDelCount() + segState.rld.getPendingDeleteCount();\n        assert fullDelCount <= segState.rld.info.info.maxDoc();\n        if (fullDelCount == segState.rld.info.info.maxDoc()) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(segState.reader.getSegmentInfo());\n        }\n      }\n    }\n    IOUtils.applyToAll(segmentStates, s -> s.finish(pool));\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"closeSegmentStates: \" + totDelCount + \" new deleted documents; pool \" + updates.size() + \" packets; bytesUsed=\" + pool.ramBytesUsed());\n    }\n\n    return new ApplyDeletesResult(totDelCount > 0, allDeleted);      \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa5e39259dfd4a68287c824d3b7e1bc9097dc895","date":1522505041,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#closeSegmentStates(IndexWriter.ReaderPool,SegmentState[],boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#closeSegmentStates(IndexWriter.ReaderPool,SegmentState[],boolean).mjava","sourceNew":"  /** Close segment states previously opened with openSegmentStates. */\n  public ApplyDeletesResult closeSegmentStates(IndexWriter.ReaderPool pool, SegmentState[] segStates, boolean success) throws IOException {\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n    final List<SegmentState> segmentStates = Arrays.asList(segStates);\n    for (SegmentState segState : segmentStates) {\n      if (success) {\n        totDelCount += segState.rld.getPendingDeleteCount() - segState.startDelCount;\n        int fullDelCount = segState.rld.info.getDelCount() + segState.rld.getPendingDeleteCount();\n        assert fullDelCount <= segState.rld.info.info.maxDoc() : fullDelCount + \" > \" + segState.rld.info.info.maxDoc();\n        if (segState.rld.isFullyDeleted()) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(segState.reader.getSegmentInfo());\n        }\n      }\n    }\n    IOUtils.applyToAll(segmentStates, s -> s.finish(pool));\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"closeSegmentStates: \" + totDelCount + \" new deleted documents; pool \" + updates.size() + \" packets; bytesUsed=\" + pool.ramBytesUsed());\n    }\n\n    return new ApplyDeletesResult(totDelCount > 0, allDeleted);      \n  }\n\n","sourceOld":"  /** Close segment states previously opened with openSegmentStates. */\n  public ApplyDeletesResult closeSegmentStates(IndexWriter.ReaderPool pool, SegmentState[] segStates, boolean success) throws IOException {\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n    final List<SegmentState> segmentStates = Arrays.asList(segStates);\n    for (SegmentState segState : segmentStates) {\n      if (success) {\n        totDelCount += segState.rld.getPendingDeleteCount() - segState.startDelCount;\n        int fullDelCount = segState.rld.info.getDelCount() + segState.rld.getPendingDeleteCount();\n        assert fullDelCount <= segState.rld.info.info.maxDoc();\n        if (fullDelCount == segState.rld.info.info.maxDoc()) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(segState.reader.getSegmentInfo());\n        }\n      }\n    }\n    IOUtils.applyToAll(segmentStates, s -> s.finish(pool));\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"closeSegmentStates: \" + totDelCount + \" new deleted documents; pool \" + updates.size() + \" packets; bytesUsed=\" + pool.ramBytesUsed());\n    }\n\n    return new ApplyDeletesResult(totDelCount > 0, allDeleted);      \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ee0394b8176abd7c90a4be8c05465be1879db79","date":1522842314,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#closeSegmentStates(IndexWriter.ReaderPool,SegmentState[],boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#closeSegmentStates(IndexWriter.ReaderPool,SegmentState[],boolean).mjava","sourceNew":"  /** Close segment states previously opened with openSegmentStates. */\n  public ApplyDeletesResult closeSegmentStates(IndexWriter.ReaderPool pool, SegmentState[] segStates, boolean success) throws IOException {\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n    final List<SegmentState> segmentStates = Arrays.asList(segStates);\n    for (SegmentState segState : segmentStates) {\n      if (success) {\n        totDelCount += segState.rld.getPendingDeleteCount() - segState.startDelCount;\n        int fullDelCount = segState.rld.info.getDelCount() + segState.rld.getPendingDeleteCount();\n        assert fullDelCount <= segState.rld.info.info.maxDoc() : fullDelCount + \" > \" + segState.rld.info.info.maxDoc();\n        if (segState.rld.isFullyDeleted() && writer.getConfig().mergePolicy.keepFullyDeletedSegment(segState.reader) == false) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(segState.reader.getSegmentInfo());\n        }\n      }\n    }\n    IOUtils.applyToAll(segmentStates, s -> s.finish(pool));\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"closeSegmentStates: \" + totDelCount + \" new deleted documents; pool \" + updates.size() + \" packets; bytesUsed=\" + pool.ramBytesUsed());\n    }\n\n    return new ApplyDeletesResult(totDelCount > 0, allDeleted);      \n  }\n\n","sourceOld":"  /** Close segment states previously opened with openSegmentStates. */\n  public ApplyDeletesResult closeSegmentStates(IndexWriter.ReaderPool pool, SegmentState[] segStates, boolean success) throws IOException {\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n    final List<SegmentState> segmentStates = Arrays.asList(segStates);\n    for (SegmentState segState : segmentStates) {\n      if (success) {\n        totDelCount += segState.rld.getPendingDeleteCount() - segState.startDelCount;\n        int fullDelCount = segState.rld.info.getDelCount() + segState.rld.getPendingDeleteCount();\n        assert fullDelCount <= segState.rld.info.info.maxDoc() : fullDelCount + \" > \" + segState.rld.info.info.maxDoc();\n        if (segState.rld.isFullyDeleted()) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(segState.reader.getSegmentInfo());\n        }\n      }\n    }\n    IOUtils.applyToAll(segmentStates, s -> s.finish(pool));\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"closeSegmentStates: \" + totDelCount + \" new deleted documents; pool \" + updates.size() + \" packets; bytesUsed=\" + pool.ramBytesUsed());\n    }\n\n    return new ApplyDeletesResult(totDelCount > 0, allDeleted);      \n  }\n\n","bugFix":null,"bugIntro":["15e716649e2bd79a98b5e68c464154ea4c44677a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15e716649e2bd79a98b5e68c464154ea4c44677a","date":1523975212,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#closeSegmentStates(IndexWriter.ReaderPool,SegmentState[],boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#closeSegmentStates(IndexWriter.ReaderPool,SegmentState[],boolean).mjava","sourceNew":"  /** Close segment states previously opened with openSegmentStates. */\n  public ApplyDeletesResult closeSegmentStates(IndexWriter.ReaderPool pool, SegmentState[] segStates, boolean success) throws IOException {\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n    final List<SegmentState> segmentStates = Arrays.asList(segStates);\n    for (SegmentState segState : segmentStates) {\n      if (success) {\n        totDelCount += segState.rld.getPendingDeleteCount() - segState.startDelCount;\n        int fullDelCount = segState.rld.info.getDelCount() + segState.rld.getPendingDeleteCount();\n        assert fullDelCount <= segState.rld.info.info.maxDoc() : fullDelCount + \" > \" + segState.rld.info.info.maxDoc();\n        if (segState.rld.isFullyDeleted() && writer.getConfig().mergePolicy.keepFullyDeletedSegment(() -> segState.reader) == false) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(segState.reader.getSegmentInfo());\n        }\n      }\n    }\n    IOUtils.applyToAll(segmentStates, s -> s.finish(pool));\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"closeSegmentStates: \" + totDelCount + \" new deleted documents; pool \" + updates.size() + \" packets; bytesUsed=\" + pool.ramBytesUsed());\n    }\n\n    return new ApplyDeletesResult(totDelCount > 0, allDeleted);      \n  }\n\n","sourceOld":"  /** Close segment states previously opened with openSegmentStates. */\n  public ApplyDeletesResult closeSegmentStates(IndexWriter.ReaderPool pool, SegmentState[] segStates, boolean success) throws IOException {\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n    final List<SegmentState> segmentStates = Arrays.asList(segStates);\n    for (SegmentState segState : segmentStates) {\n      if (success) {\n        totDelCount += segState.rld.getPendingDeleteCount() - segState.startDelCount;\n        int fullDelCount = segState.rld.info.getDelCount() + segState.rld.getPendingDeleteCount();\n        assert fullDelCount <= segState.rld.info.info.maxDoc() : fullDelCount + \" > \" + segState.rld.info.info.maxDoc();\n        if (segState.rld.isFullyDeleted() && writer.getConfig().mergePolicy.keepFullyDeletedSegment(segState.reader) == false) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(segState.reader.getSegmentInfo());\n        }\n      }\n    }\n    IOUtils.applyToAll(segmentStates, s -> s.finish(pool));\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"closeSegmentStates: \" + totDelCount + \" new deleted documents; pool \" + updates.size() + \" packets; bytesUsed=\" + pool.ramBytesUsed());\n    }\n\n    return new ApplyDeletesResult(totDelCount > 0, allDeleted);      \n  }\n\n","bugFix":["5ee0394b8176abd7c90a4be8c05465be1879db79"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1926100d9b67becc9701c54266fee3ba7878a5f0","date":1524472150,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#closeSegmentStates(SegmentState[],boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#closeSegmentStates(IndexWriter.ReaderPool,SegmentState[],boolean).mjava","sourceNew":"  /** Close segment states previously opened with openSegmentStates. */\n  public ApplyDeletesResult closeSegmentStates(SegmentState[] segStates, boolean success) throws IOException {\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n    final List<SegmentState> segmentStates = Arrays.asList(segStates);\n    for (SegmentState segState : segmentStates) {\n      if (success) {\n        totDelCount += segState.rld.getPendingDeleteCount() - segState.startDelCount;\n        int fullDelCount = segState.rld.info.getDelCount() + segState.rld.getPendingDeleteCount();\n        assert fullDelCount <= segState.rld.info.info.maxDoc() : fullDelCount + \" > \" + segState.rld.info.info.maxDoc();\n        if (segState.rld.isFullyDeleted() && writer.getConfig().mergePolicy.keepFullyDeletedSegment(() -> segState.reader) == false) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(segState.reader.getSegmentInfo());\n        }\n      }\n    }\n    finishSegmentStates(segmentStates);\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"closeSegmentStates: \" + totDelCount + \" new deleted documents; pool \" + updates.size() + \" packets; bytesUsed=\" + writer.getReaderPoolRamBytesUsed());\n    }\n\n    return new ApplyDeletesResult(totDelCount > 0, allDeleted);      \n  }\n\n","sourceOld":"  /** Close segment states previously opened with openSegmentStates. */\n  public ApplyDeletesResult closeSegmentStates(IndexWriter.ReaderPool pool, SegmentState[] segStates, boolean success) throws IOException {\n    List<SegmentCommitInfo> allDeleted = null;\n    long totDelCount = 0;\n    final List<SegmentState> segmentStates = Arrays.asList(segStates);\n    for (SegmentState segState : segmentStates) {\n      if (success) {\n        totDelCount += segState.rld.getPendingDeleteCount() - segState.startDelCount;\n        int fullDelCount = segState.rld.info.getDelCount() + segState.rld.getPendingDeleteCount();\n        assert fullDelCount <= segState.rld.info.info.maxDoc() : fullDelCount + \" > \" + segState.rld.info.info.maxDoc();\n        if (segState.rld.isFullyDeleted() && writer.getConfig().mergePolicy.keepFullyDeletedSegment(() -> segState.reader) == false) {\n          if (allDeleted == null) {\n            allDeleted = new ArrayList<>();\n          }\n          allDeleted.add(segState.reader.getSegmentInfo());\n        }\n      }\n    }\n    IOUtils.applyToAll(segmentStates, s -> s.finish(pool));\n    if (infoStream.isEnabled(\"BD\")) {\n      infoStream.message(\"BD\", \"closeSegmentStates: \" + totDelCount + \" new deleted documents; pool \" + updates.size() + \" packets; bytesUsed=\" + pool.ramBytesUsed());\n    }\n\n    return new ApplyDeletesResult(totDelCount > 0, allDeleted);      \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43":["28288370235ed02234a64753cdbf0c6ec096304a","14d66d86a8b184a86bcaebcf6e15fcef486e0876"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5ee0394b8176abd7c90a4be8c05465be1879db79":["aa5e39259dfd4a68287c824d3b7e1bc9097dc895"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"15e716649e2bd79a98b5e68c464154ea4c44677a":["5ee0394b8176abd7c90a4be8c05465be1879db79"],"aa5e39259dfd4a68287c824d3b7e1bc9097dc895":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43","d60c1bb96a28a26d197c36299f7b6c9c5da617a1"],"1926100d9b67becc9701c54266fee3ba7878a5f0":["15e716649e2bd79a98b5e68c464154ea4c44677a"],"d60c1bb96a28a26d197c36299f7b6c9c5da617a1":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"28288370235ed02234a64753cdbf0c6ec096304a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1926100d9b67becc9701c54266fee3ba7878a5f0"],"14d66d86a8b184a86bcaebcf6e15fcef486e0876":["28288370235ed02234a64753cdbf0c6ec096304a"]},"commit2Childs":{"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43":["aa5e39259dfd4a68287c824d3b7e1bc9097dc895","d60c1bb96a28a26d197c36299f7b6c9c5da617a1"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f4363cd33f6eff7fb4753574a441e2d18c1022a4","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"5ee0394b8176abd7c90a4be8c05465be1879db79":["15e716649e2bd79a98b5e68c464154ea4c44677a"],"15e716649e2bd79a98b5e68c464154ea4c44677a":["1926100d9b67becc9701c54266fee3ba7878a5f0"],"aa5e39259dfd4a68287c824d3b7e1bc9097dc895":["5ee0394b8176abd7c90a4be8c05465be1879db79"],"d60c1bb96a28a26d197c36299f7b6c9c5da617a1":["aa5e39259dfd4a68287c824d3b7e1bc9097dc895"],"1926100d9b67becc9701c54266fee3ba7878a5f0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43","14d66d86a8b184a86bcaebcf6e15fcef486e0876"],"14d66d86a8b184a86bcaebcf6e15fcef486e0876":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}