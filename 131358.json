{"path":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.TermsWriter#writeBlocks(int,int).mjava","commits":[{"id":"f838187609fee3a1afa5f162f93c796046242c84","date":1406216791,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.TermsWriter#writeBlocks(int,int).mjava","pathOld":"/dev/null","sourceNew":"    /** Writes the top count entries in pending, using prevTerm to compute the prefix. */\n    void writeBlocks(int prefixLength, int count) throws IOException {\n\n      assert count > 0;\n\n      /*\n      if (DEBUG) {\n        BytesRef br = new BytesRef(lastTerm.bytes);\n        br.offset = lastTerm.offset;\n        br.length = prefixLength;\n        System.out.println(\"writeBlocks: \" + br.utf8ToString() + \" count=\" + count);\n      }\n      */\n\n      // Root block better write all remaining pending entries:\n      assert prefixLength > 0 || count == pending.size();\n\n      int lastSuffixLeadLabel = -1;\n\n      // True if we saw at least one term in this block (we record if a block\n      // only points to sub-blocks in the terms index so we can avoid seeking\n      // to it when we are looking for a term):\n      boolean hasTerms = false;\n      boolean hasSubBlocks = false;\n\n      int start = pending.size()-count;\n      int end = pending.size();\n      int nextBlockStart = start;\n      int nextFloorLeadLabel = -1;\n\n      for (int i=start; i<end; i++) {\n\n        PendingEntry ent = pending.get(i);\n\n        int suffixLeadLabel;\n\n        if (ent.isTerm) {\n          PendingTerm term = (PendingTerm) ent;\n          if (term.termBytes.length == prefixLength) {\n            // Suffix is 0, i.e. prefix 'foo' and term is\n            // 'foo' so the term has empty string suffix\n            // in this block\n            assert lastSuffixLeadLabel == -1;\n            suffixLeadLabel = -1;\n          } else {\n            suffixLeadLabel = term.termBytes[prefixLength] & 0xff;\n          }\n        } else {\n          PendingBlock block = (PendingBlock) ent;\n          assert block.prefix.length > prefixLength;\n          suffixLeadLabel = block.prefix.bytes[block.prefix.offset + prefixLength] & 0xff;\n        }\n        // if (DEBUG) System.out.println(\"  i=\" + i + \" ent=\" + ent + \" suffixLeadLabel=\" + suffixLeadLabel);\n\n        if (suffixLeadLabel != lastSuffixLeadLabel) {\n          int itemsInBlock = i - nextBlockStart;\n          if (itemsInBlock >= minItemsInBlock && end-nextBlockStart > maxItemsInBlock) {\n            // The count is too large for one block, so we must break it into \"floor\" blocks, where we record\n            // the leading label of the suffix of the first term in each floor block, so at search time we can\n            // jump to the right floor block.  We just use a naive greedy segmenter here: make a new floor\n            // block as soon as we have at least minItemsInBlock.  This is not always best: it often produces\n            // a too-small block as the final block:\n            boolean isFloor = itemsInBlock < count;\n            newBlocks.add(writeBlock(prefixLength, isFloor, nextFloorLeadLabel, nextBlockStart, i, hasTerms, hasSubBlocks));\n\n            hasTerms = false;\n            hasSubBlocks = false;\n            nextFloorLeadLabel = suffixLeadLabel;\n            nextBlockStart = i;\n          }\n\n          lastSuffixLeadLabel = suffixLeadLabel;\n        }\n\n        if (ent.isTerm) {\n          hasTerms = true;\n        } else {\n          hasSubBlocks = true;\n        }\n      }\n\n      // Write last block, if any:\n      if (nextBlockStart < end) {\n        int itemsInBlock = end - nextBlockStart;\n        boolean isFloor = itemsInBlock < count;\n        newBlocks.add(writeBlock(prefixLength, isFloor, nextFloorLeadLabel, nextBlockStart, end, hasTerms, hasSubBlocks));\n      }\n\n      assert newBlocks.isEmpty() == false;\n\n      PendingBlock firstBlock = newBlocks.get(0);\n\n      assert firstBlock.isFloor || newBlocks.size() == 1;\n\n      firstBlock.compileIndex(newBlocks, scratchBytes, scratchIntsRef);\n\n      // Remove slice from the top of the pending stack, that we just wrote:\n      pending.subList(pending.size()-count, pending.size()).clear();\n\n      // Append new block\n      pending.add(firstBlock);\n\n      newBlocks.clear();\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e8715d826e588419327562287d5d6a8040d63d6","date":1427987148,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.TermsWriter#writeBlocks(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.TermsWriter#writeBlocks(int,int).mjava","sourceNew":"    /** Writes the top count entries in pending, using prevTerm to compute the prefix. */\n    void writeBlocks(int prefixLength, int count) throws IOException {\n\n      assert count > 0;\n\n      //if (DEBUG2) {\n      //  BytesRef br = new BytesRef(lastTerm.bytes());\n      //  br.length = prefixLength;\n      //  System.out.println(\"writeBlocks: seg=\" + segment + \" prefix=\" + brToString(br) + \" count=\" + count);\n      //}\n\n      // Root block better write all remaining pending entries:\n      assert prefixLength > 0 || count == pending.size();\n\n      int lastSuffixLeadLabel = -1;\n\n      // True if we saw at least one term in this block (we record if a block\n      // only points to sub-blocks in the terms index so we can avoid seeking\n      // to it when we are looking for a term):\n      boolean hasTerms = false;\n      boolean hasPrefixTerms = false;\n      boolean hasSubBlocks = false;\n\n      int start = pending.size()-count;\n      int end = pending.size();\n      int nextBlockStart = start;\n      int nextFloorLeadLabel = -1;\n\n      for (int i=start; i<end; i++) {\n\n        PendingEntry ent = pending.get(i);\n\n        int suffixLeadLabel;\n\n        if (ent.isTerm) {\n          PendingTerm term = (PendingTerm) ent;\n          if (term.termBytes.length == prefixLength) {\n            // Suffix is 0, i.e. prefix 'foo' and term is\n            // 'foo' so the term has empty string suffix\n            // in this block\n            assert lastSuffixLeadLabel == -1: \"i=\" + i + \" lastSuffixLeadLabel=\" + lastSuffixLeadLabel;\n            suffixLeadLabel = -1;\n          } else {\n            suffixLeadLabel = term.termBytes[prefixLength] & 0xff;\n          }\n        } else {\n          PendingBlock block = (PendingBlock) ent;\n          assert block.prefix.length > prefixLength;\n          suffixLeadLabel = block.prefix.bytes[block.prefix.offset + prefixLength] & 0xff;\n        }\n        // if (DEBUG) System.out.println(\"  i=\" + i + \" ent=\" + ent + \" suffixLeadLabel=\" + suffixLeadLabel);\n\n        if (suffixLeadLabel != lastSuffixLeadLabel) {\n          int itemsInBlock = i - nextBlockStart;\n          if (itemsInBlock >= minItemsInBlock && end-nextBlockStart > maxItemsInBlock) {\n            // The count is too large for one block, so we must break it into \"floor\" blocks, where we record\n            // the leading label of the suffix of the first term in each floor block, so at search time we can\n            // jump to the right floor block.  We just use a naive greedy segmenter here: make a new floor\n            // block as soon as we have at least minItemsInBlock.  This is not always best: it often produces\n            // a too-small block as the final block:\n            boolean isFloor = itemsInBlock < count;\n            newBlocks.add(writeBlock(prefixLength, isFloor, nextFloorLeadLabel, nextBlockStart, i, hasTerms, hasPrefixTerms, hasSubBlocks));\n\n            hasTerms = false;\n            hasSubBlocks = false;\n            hasPrefixTerms = false;\n            nextFloorLeadLabel = suffixLeadLabel;\n            nextBlockStart = i;\n          }\n\n          lastSuffixLeadLabel = suffixLeadLabel;\n        }\n\n        if (ent.isTerm) {\n          hasTerms = true;\n          hasPrefixTerms |= ((PendingTerm) ent).prefixTerm != null;\n        } else {\n          hasSubBlocks = true;\n        }\n      }\n\n      // Write last block, if any:\n      if (nextBlockStart < end) {\n        int itemsInBlock = end - nextBlockStart;\n        boolean isFloor = itemsInBlock < count;\n        newBlocks.add(writeBlock(prefixLength, isFloor, nextFloorLeadLabel, nextBlockStart, end, hasTerms, hasPrefixTerms, hasSubBlocks));\n      }\n\n      assert newBlocks.isEmpty() == false;\n\n      PendingBlock firstBlock = newBlocks.get(0);\n\n      assert firstBlock.isFloor || newBlocks.size() == 1;\n\n      firstBlock.compileIndex(newBlocks, scratchBytes, scratchIntsRef);\n\n      // Remove slice from the top of the pending stack, that we just wrote:\n      pending.subList(pending.size()-count, pending.size()).clear();\n\n      // Append new block\n      pending.add(firstBlock);\n\n      newBlocks.clear();\n    }\n\n","sourceOld":"    /** Writes the top count entries in pending, using prevTerm to compute the prefix. */\n    void writeBlocks(int prefixLength, int count) throws IOException {\n\n      assert count > 0;\n\n      /*\n      if (DEBUG) {\n        BytesRef br = new BytesRef(lastTerm.bytes);\n        br.offset = lastTerm.offset;\n        br.length = prefixLength;\n        System.out.println(\"writeBlocks: \" + br.utf8ToString() + \" count=\" + count);\n      }\n      */\n\n      // Root block better write all remaining pending entries:\n      assert prefixLength > 0 || count == pending.size();\n\n      int lastSuffixLeadLabel = -1;\n\n      // True if we saw at least one term in this block (we record if a block\n      // only points to sub-blocks in the terms index so we can avoid seeking\n      // to it when we are looking for a term):\n      boolean hasTerms = false;\n      boolean hasSubBlocks = false;\n\n      int start = pending.size()-count;\n      int end = pending.size();\n      int nextBlockStart = start;\n      int nextFloorLeadLabel = -1;\n\n      for (int i=start; i<end; i++) {\n\n        PendingEntry ent = pending.get(i);\n\n        int suffixLeadLabel;\n\n        if (ent.isTerm) {\n          PendingTerm term = (PendingTerm) ent;\n          if (term.termBytes.length == prefixLength) {\n            // Suffix is 0, i.e. prefix 'foo' and term is\n            // 'foo' so the term has empty string suffix\n            // in this block\n            assert lastSuffixLeadLabel == -1;\n            suffixLeadLabel = -1;\n          } else {\n            suffixLeadLabel = term.termBytes[prefixLength] & 0xff;\n          }\n        } else {\n          PendingBlock block = (PendingBlock) ent;\n          assert block.prefix.length > prefixLength;\n          suffixLeadLabel = block.prefix.bytes[block.prefix.offset + prefixLength] & 0xff;\n        }\n        // if (DEBUG) System.out.println(\"  i=\" + i + \" ent=\" + ent + \" suffixLeadLabel=\" + suffixLeadLabel);\n\n        if (suffixLeadLabel != lastSuffixLeadLabel) {\n          int itemsInBlock = i - nextBlockStart;\n          if (itemsInBlock >= minItemsInBlock && end-nextBlockStart > maxItemsInBlock) {\n            // The count is too large for one block, so we must break it into \"floor\" blocks, where we record\n            // the leading label of the suffix of the first term in each floor block, so at search time we can\n            // jump to the right floor block.  We just use a naive greedy segmenter here: make a new floor\n            // block as soon as we have at least minItemsInBlock.  This is not always best: it often produces\n            // a too-small block as the final block:\n            boolean isFloor = itemsInBlock < count;\n            newBlocks.add(writeBlock(prefixLength, isFloor, nextFloorLeadLabel, nextBlockStart, i, hasTerms, hasSubBlocks));\n\n            hasTerms = false;\n            hasSubBlocks = false;\n            nextFloorLeadLabel = suffixLeadLabel;\n            nextBlockStart = i;\n          }\n\n          lastSuffixLeadLabel = suffixLeadLabel;\n        }\n\n        if (ent.isTerm) {\n          hasTerms = true;\n        } else {\n          hasSubBlocks = true;\n        }\n      }\n\n      // Write last block, if any:\n      if (nextBlockStart < end) {\n        int itemsInBlock = end - nextBlockStart;\n        boolean isFloor = itemsInBlock < count;\n        newBlocks.add(writeBlock(prefixLength, isFloor, nextFloorLeadLabel, nextBlockStart, end, hasTerms, hasSubBlocks));\n      }\n\n      assert newBlocks.isEmpty() == false;\n\n      PendingBlock firstBlock = newBlocks.get(0);\n\n      assert firstBlock.isFloor || newBlocks.size() == 1;\n\n      firstBlock.compileIndex(newBlocks, scratchBytes, scratchIntsRef);\n\n      // Remove slice from the top of the pending stack, that we just wrote:\n      pending.subList(pending.size()-count, pending.size()).clear();\n\n      // Append new block\n      pending.add(firstBlock);\n\n      newBlocks.clear();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.TermsWriter#writeBlocks(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.TermsWriter#writeBlocks(int,int).mjava","sourceNew":"    /** Writes the top count entries in pending, using prevTerm to compute the prefix. */\n    void writeBlocks(int prefixLength, int count) throws IOException {\n\n      assert count > 0;\n\n      //if (DEBUG2) {\n      //  BytesRef br = new BytesRef(lastTerm.bytes());\n      //  br.length = prefixLength;\n      //  System.out.println(\"writeBlocks: seg=\" + segment + \" prefix=\" + brToString(br) + \" count=\" + count);\n      //}\n\n      // Root block better write all remaining pending entries:\n      assert prefixLength > 0 || count == pending.size();\n\n      int lastSuffixLeadLabel = -1;\n\n      // True if we saw at least one term in this block (we record if a block\n      // only points to sub-blocks in the terms index so we can avoid seeking\n      // to it when we are looking for a term):\n      boolean hasTerms = false;\n      boolean hasPrefixTerms = false;\n      boolean hasSubBlocks = false;\n\n      int start = pending.size()-count;\n      int end = pending.size();\n      int nextBlockStart = start;\n      int nextFloorLeadLabel = -1;\n\n      for (int i=start; i<end; i++) {\n\n        PendingEntry ent = pending.get(i);\n\n        int suffixLeadLabel;\n\n        if (ent.isTerm) {\n          PendingTerm term = (PendingTerm) ent;\n          if (term.termBytes.length == prefixLength) {\n            // Suffix is 0, i.e. prefix 'foo' and term is\n            // 'foo' so the term has empty string suffix\n            // in this block\n            assert lastSuffixLeadLabel == -1: \"i=\" + i + \" lastSuffixLeadLabel=\" + lastSuffixLeadLabel;\n            suffixLeadLabel = -1;\n          } else {\n            suffixLeadLabel = term.termBytes[prefixLength] & 0xff;\n          }\n        } else {\n          PendingBlock block = (PendingBlock) ent;\n          assert block.prefix.length > prefixLength;\n          suffixLeadLabel = block.prefix.bytes[block.prefix.offset + prefixLength] & 0xff;\n        }\n        // if (DEBUG) System.out.println(\"  i=\" + i + \" ent=\" + ent + \" suffixLeadLabel=\" + suffixLeadLabel);\n\n        if (suffixLeadLabel != lastSuffixLeadLabel) {\n          int itemsInBlock = i - nextBlockStart;\n          if (itemsInBlock >= minItemsInBlock && end-nextBlockStart > maxItemsInBlock) {\n            // The count is too large for one block, so we must break it into \"floor\" blocks, where we record\n            // the leading label of the suffix of the first term in each floor block, so at search time we can\n            // jump to the right floor block.  We just use a naive greedy segmenter here: make a new floor\n            // block as soon as we have at least minItemsInBlock.  This is not always best: it often produces\n            // a too-small block as the final block:\n            boolean isFloor = itemsInBlock < count;\n            newBlocks.add(writeBlock(prefixLength, isFloor, nextFloorLeadLabel, nextBlockStart, i, hasTerms, hasPrefixTerms, hasSubBlocks));\n\n            hasTerms = false;\n            hasSubBlocks = false;\n            hasPrefixTerms = false;\n            nextFloorLeadLabel = suffixLeadLabel;\n            nextBlockStart = i;\n          }\n\n          lastSuffixLeadLabel = suffixLeadLabel;\n        }\n\n        if (ent.isTerm) {\n          hasTerms = true;\n          hasPrefixTerms |= ((PendingTerm) ent).prefixTerm != null;\n        } else {\n          hasSubBlocks = true;\n        }\n      }\n\n      // Write last block, if any:\n      if (nextBlockStart < end) {\n        int itemsInBlock = end - nextBlockStart;\n        boolean isFloor = itemsInBlock < count;\n        newBlocks.add(writeBlock(prefixLength, isFloor, nextFloorLeadLabel, nextBlockStart, end, hasTerms, hasPrefixTerms, hasSubBlocks));\n      }\n\n      assert newBlocks.isEmpty() == false;\n\n      PendingBlock firstBlock = newBlocks.get(0);\n\n      assert firstBlock.isFloor || newBlocks.size() == 1;\n\n      firstBlock.compileIndex(newBlocks, scratchBytes, scratchIntsRef);\n\n      // Remove slice from the top of the pending stack, that we just wrote:\n      pending.subList(pending.size()-count, pending.size()).clear();\n\n      // Append new block\n      pending.add(firstBlock);\n\n      newBlocks.clear();\n    }\n\n","sourceOld":"    /** Writes the top count entries in pending, using prevTerm to compute the prefix. */\n    void writeBlocks(int prefixLength, int count) throws IOException {\n\n      assert count > 0;\n\n      /*\n      if (DEBUG) {\n        BytesRef br = new BytesRef(lastTerm.bytes);\n        br.offset = lastTerm.offset;\n        br.length = prefixLength;\n        System.out.println(\"writeBlocks: \" + br.utf8ToString() + \" count=\" + count);\n      }\n      */\n\n      // Root block better write all remaining pending entries:\n      assert prefixLength > 0 || count == pending.size();\n\n      int lastSuffixLeadLabel = -1;\n\n      // True if we saw at least one term in this block (we record if a block\n      // only points to sub-blocks in the terms index so we can avoid seeking\n      // to it when we are looking for a term):\n      boolean hasTerms = false;\n      boolean hasSubBlocks = false;\n\n      int start = pending.size()-count;\n      int end = pending.size();\n      int nextBlockStart = start;\n      int nextFloorLeadLabel = -1;\n\n      for (int i=start; i<end; i++) {\n\n        PendingEntry ent = pending.get(i);\n\n        int suffixLeadLabel;\n\n        if (ent.isTerm) {\n          PendingTerm term = (PendingTerm) ent;\n          if (term.termBytes.length == prefixLength) {\n            // Suffix is 0, i.e. prefix 'foo' and term is\n            // 'foo' so the term has empty string suffix\n            // in this block\n            assert lastSuffixLeadLabel == -1;\n            suffixLeadLabel = -1;\n          } else {\n            suffixLeadLabel = term.termBytes[prefixLength] & 0xff;\n          }\n        } else {\n          PendingBlock block = (PendingBlock) ent;\n          assert block.prefix.length > prefixLength;\n          suffixLeadLabel = block.prefix.bytes[block.prefix.offset + prefixLength] & 0xff;\n        }\n        // if (DEBUG) System.out.println(\"  i=\" + i + \" ent=\" + ent + \" suffixLeadLabel=\" + suffixLeadLabel);\n\n        if (suffixLeadLabel != lastSuffixLeadLabel) {\n          int itemsInBlock = i - nextBlockStart;\n          if (itemsInBlock >= minItemsInBlock && end-nextBlockStart > maxItemsInBlock) {\n            // The count is too large for one block, so we must break it into \"floor\" blocks, where we record\n            // the leading label of the suffix of the first term in each floor block, so at search time we can\n            // jump to the right floor block.  We just use a naive greedy segmenter here: make a new floor\n            // block as soon as we have at least minItemsInBlock.  This is not always best: it often produces\n            // a too-small block as the final block:\n            boolean isFloor = itemsInBlock < count;\n            newBlocks.add(writeBlock(prefixLength, isFloor, nextFloorLeadLabel, nextBlockStart, i, hasTerms, hasSubBlocks));\n\n            hasTerms = false;\n            hasSubBlocks = false;\n            nextFloorLeadLabel = suffixLeadLabel;\n            nextBlockStart = i;\n          }\n\n          lastSuffixLeadLabel = suffixLeadLabel;\n        }\n\n        if (ent.isTerm) {\n          hasTerms = true;\n        } else {\n          hasSubBlocks = true;\n        }\n      }\n\n      // Write last block, if any:\n      if (nextBlockStart < end) {\n        int itemsInBlock = end - nextBlockStart;\n        boolean isFloor = itemsInBlock < count;\n        newBlocks.add(writeBlock(prefixLength, isFloor, nextFloorLeadLabel, nextBlockStart, end, hasTerms, hasSubBlocks));\n      }\n\n      assert newBlocks.isEmpty() == false;\n\n      PendingBlock firstBlock = newBlocks.get(0);\n\n      assert firstBlock.isFloor || newBlocks.size() == 1;\n\n      firstBlock.compileIndex(newBlocks, scratchBytes, scratchIntsRef);\n\n      // Remove slice from the top of the pending stack, that we just wrote:\n      pending.subList(pending.size()-count, pending.size()).clear();\n\n      // Append new block\n      pending.add(firstBlock);\n\n      newBlocks.clear();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"25b8a027ba57951e63075a2ae9647c5c4a8c5c5f","date":1466407389,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.TermsWriter#writeBlocks(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.TermsWriter#writeBlocks(int,int).mjava","sourceNew":"    /** Writes the top count entries in pending, using prevTerm to compute the prefix. */\n    void writeBlocks(int prefixLength, int count) throws IOException {\n\n      assert count > 0;\n\n      //if (DEBUG2) {\n      //  BytesRef br = new BytesRef(lastTerm.bytes());\n      //  br.length = prefixLength;\n      //  System.out.println(\"writeBlocks: seg=\" + segment + \" prefix=\" + brToString(br) + \" count=\" + count);\n      //}\n\n      // Root block better write all remaining pending entries:\n      assert prefixLength > 0 || count == pending.size();\n\n      int lastSuffixLeadLabel = -1;\n\n      // True if we saw at least one term in this block (we record if a block\n      // only points to sub-blocks in the terms index so we can avoid seeking\n      // to it when we are looking for a term):\n      boolean hasTerms = false;\n      boolean hasSubBlocks = false;\n\n      int start = pending.size()-count;\n      int end = pending.size();\n      int nextBlockStart = start;\n      int nextFloorLeadLabel = -1;\n\n      for (int i=start; i<end; i++) {\n\n        PendingEntry ent = pending.get(i);\n\n        int suffixLeadLabel;\n\n        if (ent.isTerm) {\n          PendingTerm term = (PendingTerm) ent;\n          if (term.termBytes.length == prefixLength) {\n            // Suffix is 0, i.e. prefix 'foo' and term is\n            // 'foo' so the term has empty string suffix\n            // in this block\n            assert lastSuffixLeadLabel == -1: \"i=\" + i + \" lastSuffixLeadLabel=\" + lastSuffixLeadLabel;\n            suffixLeadLabel = -1;\n          } else {\n            suffixLeadLabel = term.termBytes[prefixLength] & 0xff;\n          }\n        } else {\n          PendingBlock block = (PendingBlock) ent;\n          assert block.prefix.length > prefixLength;\n          suffixLeadLabel = block.prefix.bytes[block.prefix.offset + prefixLength] & 0xff;\n        }\n        // if (DEBUG) System.out.println(\"  i=\" + i + \" ent=\" + ent + \" suffixLeadLabel=\" + suffixLeadLabel);\n\n        if (suffixLeadLabel != lastSuffixLeadLabel) {\n          int itemsInBlock = i - nextBlockStart;\n          if (itemsInBlock >= minItemsInBlock && end-nextBlockStart > maxItemsInBlock) {\n            // The count is too large for one block, so we must break it into \"floor\" blocks, where we record\n            // the leading label of the suffix of the first term in each floor block, so at search time we can\n            // jump to the right floor block.  We just use a naive greedy segmenter here: make a new floor\n            // block as soon as we have at least minItemsInBlock.  This is not always best: it often produces\n            // a too-small block as the final block:\n            boolean isFloor = itemsInBlock < count;\n            newBlocks.add(writeBlock(prefixLength, isFloor, nextFloorLeadLabel, nextBlockStart, i, hasTerms, hasSubBlocks));\n\n            hasTerms = false;\n            hasSubBlocks = false;\n            nextFloorLeadLabel = suffixLeadLabel;\n            nextBlockStart = i;\n          }\n\n          lastSuffixLeadLabel = suffixLeadLabel;\n        }\n\n        if (ent.isTerm) {\n          hasTerms = true;\n        } else {\n          hasSubBlocks = true;\n        }\n      }\n\n      // Write last block, if any:\n      if (nextBlockStart < end) {\n        int itemsInBlock = end - nextBlockStart;\n        boolean isFloor = itemsInBlock < count;\n        newBlocks.add(writeBlock(prefixLength, isFloor, nextFloorLeadLabel, nextBlockStart, end, hasTerms, hasSubBlocks));\n      }\n\n      assert newBlocks.isEmpty() == false;\n\n      PendingBlock firstBlock = newBlocks.get(0);\n\n      assert firstBlock.isFloor || newBlocks.size() == 1;\n\n      firstBlock.compileIndex(newBlocks, scratchBytes, scratchIntsRef);\n\n      // Remove slice from the top of the pending stack, that we just wrote:\n      pending.subList(pending.size()-count, pending.size()).clear();\n\n      // Append new block\n      pending.add(firstBlock);\n\n      newBlocks.clear();\n    }\n\n","sourceOld":"    /** Writes the top count entries in pending, using prevTerm to compute the prefix. */\n    void writeBlocks(int prefixLength, int count) throws IOException {\n\n      assert count > 0;\n\n      //if (DEBUG2) {\n      //  BytesRef br = new BytesRef(lastTerm.bytes());\n      //  br.length = prefixLength;\n      //  System.out.println(\"writeBlocks: seg=\" + segment + \" prefix=\" + brToString(br) + \" count=\" + count);\n      //}\n\n      // Root block better write all remaining pending entries:\n      assert prefixLength > 0 || count == pending.size();\n\n      int lastSuffixLeadLabel = -1;\n\n      // True if we saw at least one term in this block (we record if a block\n      // only points to sub-blocks in the terms index so we can avoid seeking\n      // to it when we are looking for a term):\n      boolean hasTerms = false;\n      boolean hasPrefixTerms = false;\n      boolean hasSubBlocks = false;\n\n      int start = pending.size()-count;\n      int end = pending.size();\n      int nextBlockStart = start;\n      int nextFloorLeadLabel = -1;\n\n      for (int i=start; i<end; i++) {\n\n        PendingEntry ent = pending.get(i);\n\n        int suffixLeadLabel;\n\n        if (ent.isTerm) {\n          PendingTerm term = (PendingTerm) ent;\n          if (term.termBytes.length == prefixLength) {\n            // Suffix is 0, i.e. prefix 'foo' and term is\n            // 'foo' so the term has empty string suffix\n            // in this block\n            assert lastSuffixLeadLabel == -1: \"i=\" + i + \" lastSuffixLeadLabel=\" + lastSuffixLeadLabel;\n            suffixLeadLabel = -1;\n          } else {\n            suffixLeadLabel = term.termBytes[prefixLength] & 0xff;\n          }\n        } else {\n          PendingBlock block = (PendingBlock) ent;\n          assert block.prefix.length > prefixLength;\n          suffixLeadLabel = block.prefix.bytes[block.prefix.offset + prefixLength] & 0xff;\n        }\n        // if (DEBUG) System.out.println(\"  i=\" + i + \" ent=\" + ent + \" suffixLeadLabel=\" + suffixLeadLabel);\n\n        if (suffixLeadLabel != lastSuffixLeadLabel) {\n          int itemsInBlock = i - nextBlockStart;\n          if (itemsInBlock >= minItemsInBlock && end-nextBlockStart > maxItemsInBlock) {\n            // The count is too large for one block, so we must break it into \"floor\" blocks, where we record\n            // the leading label of the suffix of the first term in each floor block, so at search time we can\n            // jump to the right floor block.  We just use a naive greedy segmenter here: make a new floor\n            // block as soon as we have at least minItemsInBlock.  This is not always best: it often produces\n            // a too-small block as the final block:\n            boolean isFloor = itemsInBlock < count;\n            newBlocks.add(writeBlock(prefixLength, isFloor, nextFloorLeadLabel, nextBlockStart, i, hasTerms, hasPrefixTerms, hasSubBlocks));\n\n            hasTerms = false;\n            hasSubBlocks = false;\n            hasPrefixTerms = false;\n            nextFloorLeadLabel = suffixLeadLabel;\n            nextBlockStart = i;\n          }\n\n          lastSuffixLeadLabel = suffixLeadLabel;\n        }\n\n        if (ent.isTerm) {\n          hasTerms = true;\n          hasPrefixTerms |= ((PendingTerm) ent).prefixTerm != null;\n        } else {\n          hasSubBlocks = true;\n        }\n      }\n\n      // Write last block, if any:\n      if (nextBlockStart < end) {\n        int itemsInBlock = end - nextBlockStart;\n        boolean isFloor = itemsInBlock < count;\n        newBlocks.add(writeBlock(prefixLength, isFloor, nextFloorLeadLabel, nextBlockStart, end, hasTerms, hasPrefixTerms, hasSubBlocks));\n      }\n\n      assert newBlocks.isEmpty() == false;\n\n      PendingBlock firstBlock = newBlocks.get(0);\n\n      assert firstBlock.isFloor || newBlocks.size() == 1;\n\n      firstBlock.compileIndex(newBlocks, scratchBytes, scratchIntsRef);\n\n      // Remove slice from the top of the pending stack, that we just wrote:\n      pending.subList(pending.size()-count, pending.size()).clear();\n\n      // Append new block\n      pending.add(firstBlock);\n\n      newBlocks.clear();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6aaba221b22442bdf0ef28770c25fe259dfb3f55","date":1466496193,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.TermsWriter#writeBlocks(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.TermsWriter#writeBlocks(int,int).mjava","sourceNew":"    /** Writes the top count entries in pending, using prevTerm to compute the prefix. */\n    void writeBlocks(int prefixLength, int count) throws IOException {\n\n      assert count > 0;\n\n      //if (DEBUG2) {\n      //  BytesRef br = new BytesRef(lastTerm.bytes());\n      //  br.length = prefixLength;\n      //  System.out.println(\"writeBlocks: seg=\" + segment + \" prefix=\" + brToString(br) + \" count=\" + count);\n      //}\n\n      // Root block better write all remaining pending entries:\n      assert prefixLength > 0 || count == pending.size();\n\n      int lastSuffixLeadLabel = -1;\n\n      // True if we saw at least one term in this block (we record if a block\n      // only points to sub-blocks in the terms index so we can avoid seeking\n      // to it when we are looking for a term):\n      boolean hasTerms = false;\n      boolean hasSubBlocks = false;\n\n      int start = pending.size()-count;\n      int end = pending.size();\n      int nextBlockStart = start;\n      int nextFloorLeadLabel = -1;\n\n      for (int i=start; i<end; i++) {\n\n        PendingEntry ent = pending.get(i);\n\n        int suffixLeadLabel;\n\n        if (ent.isTerm) {\n          PendingTerm term = (PendingTerm) ent;\n          if (term.termBytes.length == prefixLength) {\n            // Suffix is 0, i.e. prefix 'foo' and term is\n            // 'foo' so the term has empty string suffix\n            // in this block\n            assert lastSuffixLeadLabel == -1: \"i=\" + i + \" lastSuffixLeadLabel=\" + lastSuffixLeadLabel;\n            suffixLeadLabel = -1;\n          } else {\n            suffixLeadLabel = term.termBytes[prefixLength] & 0xff;\n          }\n        } else {\n          PendingBlock block = (PendingBlock) ent;\n          assert block.prefix.length > prefixLength;\n          suffixLeadLabel = block.prefix.bytes[block.prefix.offset + prefixLength] & 0xff;\n        }\n        // if (DEBUG) System.out.println(\"  i=\" + i + \" ent=\" + ent + \" suffixLeadLabel=\" + suffixLeadLabel);\n\n        if (suffixLeadLabel != lastSuffixLeadLabel) {\n          int itemsInBlock = i - nextBlockStart;\n          if (itemsInBlock >= minItemsInBlock && end-nextBlockStart > maxItemsInBlock) {\n            // The count is too large for one block, so we must break it into \"floor\" blocks, where we record\n            // the leading label of the suffix of the first term in each floor block, so at search time we can\n            // jump to the right floor block.  We just use a naive greedy segmenter here: make a new floor\n            // block as soon as we have at least minItemsInBlock.  This is not always best: it often produces\n            // a too-small block as the final block:\n            boolean isFloor = itemsInBlock < count;\n            newBlocks.add(writeBlock(prefixLength, isFloor, nextFloorLeadLabel, nextBlockStart, i, hasTerms, hasSubBlocks));\n\n            hasTerms = false;\n            hasSubBlocks = false;\n            nextFloorLeadLabel = suffixLeadLabel;\n            nextBlockStart = i;\n          }\n\n          lastSuffixLeadLabel = suffixLeadLabel;\n        }\n\n        if (ent.isTerm) {\n          hasTerms = true;\n        } else {\n          hasSubBlocks = true;\n        }\n      }\n\n      // Write last block, if any:\n      if (nextBlockStart < end) {\n        int itemsInBlock = end - nextBlockStart;\n        boolean isFloor = itemsInBlock < count;\n        newBlocks.add(writeBlock(prefixLength, isFloor, nextFloorLeadLabel, nextBlockStart, end, hasTerms, hasSubBlocks));\n      }\n\n      assert newBlocks.isEmpty() == false;\n\n      PendingBlock firstBlock = newBlocks.get(0);\n\n      assert firstBlock.isFloor || newBlocks.size() == 1;\n\n      firstBlock.compileIndex(newBlocks, scratchBytes, scratchIntsRef);\n\n      // Remove slice from the top of the pending stack, that we just wrote:\n      pending.subList(pending.size()-count, pending.size()).clear();\n\n      // Append new block\n      pending.add(firstBlock);\n\n      newBlocks.clear();\n    }\n\n","sourceOld":"    /** Writes the top count entries in pending, using prevTerm to compute the prefix. */\n    void writeBlocks(int prefixLength, int count) throws IOException {\n\n      assert count > 0;\n\n      //if (DEBUG2) {\n      //  BytesRef br = new BytesRef(lastTerm.bytes());\n      //  br.length = prefixLength;\n      //  System.out.println(\"writeBlocks: seg=\" + segment + \" prefix=\" + brToString(br) + \" count=\" + count);\n      //}\n\n      // Root block better write all remaining pending entries:\n      assert prefixLength > 0 || count == pending.size();\n\n      int lastSuffixLeadLabel = -1;\n\n      // True if we saw at least one term in this block (we record if a block\n      // only points to sub-blocks in the terms index so we can avoid seeking\n      // to it when we are looking for a term):\n      boolean hasTerms = false;\n      boolean hasPrefixTerms = false;\n      boolean hasSubBlocks = false;\n\n      int start = pending.size()-count;\n      int end = pending.size();\n      int nextBlockStart = start;\n      int nextFloorLeadLabel = -1;\n\n      for (int i=start; i<end; i++) {\n\n        PendingEntry ent = pending.get(i);\n\n        int suffixLeadLabel;\n\n        if (ent.isTerm) {\n          PendingTerm term = (PendingTerm) ent;\n          if (term.termBytes.length == prefixLength) {\n            // Suffix is 0, i.e. prefix 'foo' and term is\n            // 'foo' so the term has empty string suffix\n            // in this block\n            assert lastSuffixLeadLabel == -1: \"i=\" + i + \" lastSuffixLeadLabel=\" + lastSuffixLeadLabel;\n            suffixLeadLabel = -1;\n          } else {\n            suffixLeadLabel = term.termBytes[prefixLength] & 0xff;\n          }\n        } else {\n          PendingBlock block = (PendingBlock) ent;\n          assert block.prefix.length > prefixLength;\n          suffixLeadLabel = block.prefix.bytes[block.prefix.offset + prefixLength] & 0xff;\n        }\n        // if (DEBUG) System.out.println(\"  i=\" + i + \" ent=\" + ent + \" suffixLeadLabel=\" + suffixLeadLabel);\n\n        if (suffixLeadLabel != lastSuffixLeadLabel) {\n          int itemsInBlock = i - nextBlockStart;\n          if (itemsInBlock >= minItemsInBlock && end-nextBlockStart > maxItemsInBlock) {\n            // The count is too large for one block, so we must break it into \"floor\" blocks, where we record\n            // the leading label of the suffix of the first term in each floor block, so at search time we can\n            // jump to the right floor block.  We just use a naive greedy segmenter here: make a new floor\n            // block as soon as we have at least minItemsInBlock.  This is not always best: it often produces\n            // a too-small block as the final block:\n            boolean isFloor = itemsInBlock < count;\n            newBlocks.add(writeBlock(prefixLength, isFloor, nextFloorLeadLabel, nextBlockStart, i, hasTerms, hasPrefixTerms, hasSubBlocks));\n\n            hasTerms = false;\n            hasSubBlocks = false;\n            hasPrefixTerms = false;\n            nextFloorLeadLabel = suffixLeadLabel;\n            nextBlockStart = i;\n          }\n\n          lastSuffixLeadLabel = suffixLeadLabel;\n        }\n\n        if (ent.isTerm) {\n          hasTerms = true;\n          hasPrefixTerms |= ((PendingTerm) ent).prefixTerm != null;\n        } else {\n          hasSubBlocks = true;\n        }\n      }\n\n      // Write last block, if any:\n      if (nextBlockStart < end) {\n        int itemsInBlock = end - nextBlockStart;\n        boolean isFloor = itemsInBlock < count;\n        newBlocks.add(writeBlock(prefixLength, isFloor, nextFloorLeadLabel, nextBlockStart, end, hasTerms, hasPrefixTerms, hasSubBlocks));\n      }\n\n      assert newBlocks.isEmpty() == false;\n\n      PendingBlock firstBlock = newBlocks.get(0);\n\n      assert firstBlock.isFloor || newBlocks.size() == 1;\n\n      firstBlock.compileIndex(newBlocks, scratchBytes, scratchIntsRef);\n\n      // Remove slice from the top of the pending stack, that we just wrote:\n      pending.subList(pending.size()-count, pending.size()).clear();\n\n      // Append new block\n      pending.add(firstBlock);\n\n      newBlocks.clear();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.TermsWriter#writeBlocks(int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.TermsWriter#writeBlocks(int,int).mjava","sourceNew":"    /** Writes the top count entries in pending, using prevTerm to compute the prefix. */\n    void writeBlocks(int prefixLength, int count) throws IOException {\n\n      assert count > 0;\n\n      //if (DEBUG2) {\n      //  BytesRef br = new BytesRef(lastTerm.bytes());\n      //  br.length = prefixLength;\n      //  System.out.println(\"writeBlocks: seg=\" + segment + \" prefix=\" + brToString(br) + \" count=\" + count);\n      //}\n\n      // Root block better write all remaining pending entries:\n      assert prefixLength > 0 || count == pending.size();\n\n      int lastSuffixLeadLabel = -1;\n\n      // True if we saw at least one term in this block (we record if a block\n      // only points to sub-blocks in the terms index so we can avoid seeking\n      // to it when we are looking for a term):\n      boolean hasTerms = false;\n      boolean hasSubBlocks = false;\n\n      int start = pending.size()-count;\n      int end = pending.size();\n      int nextBlockStart = start;\n      int nextFloorLeadLabel = -1;\n\n      for (int i=start; i<end; i++) {\n\n        PendingEntry ent = pending.get(i);\n\n        int suffixLeadLabel;\n\n        if (ent.isTerm) {\n          PendingTerm term = (PendingTerm) ent;\n          if (term.termBytes.length == prefixLength) {\n            // Suffix is 0, i.e. prefix 'foo' and term is\n            // 'foo' so the term has empty string suffix\n            // in this block\n            assert lastSuffixLeadLabel == -1: \"i=\" + i + \" lastSuffixLeadLabel=\" + lastSuffixLeadLabel;\n            suffixLeadLabel = -1;\n          } else {\n            suffixLeadLabel = term.termBytes[prefixLength] & 0xff;\n          }\n        } else {\n          PendingBlock block = (PendingBlock) ent;\n          assert block.prefix.length > prefixLength;\n          suffixLeadLabel = block.prefix.bytes[block.prefix.offset + prefixLength] & 0xff;\n        }\n        // if (DEBUG) System.out.println(\"  i=\" + i + \" ent=\" + ent + \" suffixLeadLabel=\" + suffixLeadLabel);\n\n        if (suffixLeadLabel != lastSuffixLeadLabel) {\n          int itemsInBlock = i - nextBlockStart;\n          if (itemsInBlock >= minItemsInBlock && end-nextBlockStart > maxItemsInBlock) {\n            // The count is too large for one block, so we must break it into \"floor\" blocks, where we record\n            // the leading label of the suffix of the first term in each floor block, so at search time we can\n            // jump to the right floor block.  We just use a naive greedy segmenter here: make a new floor\n            // block as soon as we have at least minItemsInBlock.  This is not always best: it often produces\n            // a too-small block as the final block:\n            boolean isFloor = itemsInBlock < count;\n            newBlocks.add(writeBlock(prefixLength, isFloor, nextFloorLeadLabel, nextBlockStart, i, hasTerms, hasSubBlocks));\n\n            hasTerms = false;\n            hasSubBlocks = false;\n            nextFloorLeadLabel = suffixLeadLabel;\n            nextBlockStart = i;\n          }\n\n          lastSuffixLeadLabel = suffixLeadLabel;\n        }\n\n        if (ent.isTerm) {\n          hasTerms = true;\n        } else {\n          hasSubBlocks = true;\n        }\n      }\n\n      // Write last block, if any:\n      if (nextBlockStart < end) {\n        int itemsInBlock = end - nextBlockStart;\n        boolean isFloor = itemsInBlock < count;\n        newBlocks.add(writeBlock(prefixLength, isFloor, nextFloorLeadLabel, nextBlockStart, end, hasTerms, hasSubBlocks));\n      }\n\n      assert newBlocks.isEmpty() == false;\n\n      PendingBlock firstBlock = newBlocks.get(0);\n\n      assert firstBlock.isFloor || newBlocks.size() == 1;\n\n      firstBlock.compileIndex(newBlocks, scratchBytes, scratchIntsRef);\n\n      // Remove slice from the top of the pending stack, that we just wrote:\n      pending.subList(pending.size()-count, pending.size()).clear();\n\n      // Append new block\n      pending.add(firstBlock);\n\n      newBlocks.clear();\n    }\n\n","sourceOld":"    /** Writes the top count entries in pending, using prevTerm to compute the prefix. */\n    void writeBlocks(int prefixLength, int count) throws IOException {\n\n      assert count > 0;\n\n      //if (DEBUG2) {\n      //  BytesRef br = new BytesRef(lastTerm.bytes());\n      //  br.length = prefixLength;\n      //  System.out.println(\"writeBlocks: seg=\" + segment + \" prefix=\" + brToString(br) + \" count=\" + count);\n      //}\n\n      // Root block better write all remaining pending entries:\n      assert prefixLength > 0 || count == pending.size();\n\n      int lastSuffixLeadLabel = -1;\n\n      // True if we saw at least one term in this block (we record if a block\n      // only points to sub-blocks in the terms index so we can avoid seeking\n      // to it when we are looking for a term):\n      boolean hasTerms = false;\n      boolean hasPrefixTerms = false;\n      boolean hasSubBlocks = false;\n\n      int start = pending.size()-count;\n      int end = pending.size();\n      int nextBlockStart = start;\n      int nextFloorLeadLabel = -1;\n\n      for (int i=start; i<end; i++) {\n\n        PendingEntry ent = pending.get(i);\n\n        int suffixLeadLabel;\n\n        if (ent.isTerm) {\n          PendingTerm term = (PendingTerm) ent;\n          if (term.termBytes.length == prefixLength) {\n            // Suffix is 0, i.e. prefix 'foo' and term is\n            // 'foo' so the term has empty string suffix\n            // in this block\n            assert lastSuffixLeadLabel == -1: \"i=\" + i + \" lastSuffixLeadLabel=\" + lastSuffixLeadLabel;\n            suffixLeadLabel = -1;\n          } else {\n            suffixLeadLabel = term.termBytes[prefixLength] & 0xff;\n          }\n        } else {\n          PendingBlock block = (PendingBlock) ent;\n          assert block.prefix.length > prefixLength;\n          suffixLeadLabel = block.prefix.bytes[block.prefix.offset + prefixLength] & 0xff;\n        }\n        // if (DEBUG) System.out.println(\"  i=\" + i + \" ent=\" + ent + \" suffixLeadLabel=\" + suffixLeadLabel);\n\n        if (suffixLeadLabel != lastSuffixLeadLabel) {\n          int itemsInBlock = i - nextBlockStart;\n          if (itemsInBlock >= minItemsInBlock && end-nextBlockStart > maxItemsInBlock) {\n            // The count is too large for one block, so we must break it into \"floor\" blocks, where we record\n            // the leading label of the suffix of the first term in each floor block, so at search time we can\n            // jump to the right floor block.  We just use a naive greedy segmenter here: make a new floor\n            // block as soon as we have at least minItemsInBlock.  This is not always best: it often produces\n            // a too-small block as the final block:\n            boolean isFloor = itemsInBlock < count;\n            newBlocks.add(writeBlock(prefixLength, isFloor, nextFloorLeadLabel, nextBlockStart, i, hasTerms, hasPrefixTerms, hasSubBlocks));\n\n            hasTerms = false;\n            hasSubBlocks = false;\n            hasPrefixTerms = false;\n            nextFloorLeadLabel = suffixLeadLabel;\n            nextBlockStart = i;\n          }\n\n          lastSuffixLeadLabel = suffixLeadLabel;\n        }\n\n        if (ent.isTerm) {\n          hasTerms = true;\n          hasPrefixTerms |= ((PendingTerm) ent).prefixTerm != null;\n        } else {\n          hasSubBlocks = true;\n        }\n      }\n\n      // Write last block, if any:\n      if (nextBlockStart < end) {\n        int itemsInBlock = end - nextBlockStart;\n        boolean isFloor = itemsInBlock < count;\n        newBlocks.add(writeBlock(prefixLength, isFloor, nextFloorLeadLabel, nextBlockStart, end, hasTerms, hasPrefixTerms, hasSubBlocks));\n      }\n\n      assert newBlocks.isEmpty() == false;\n\n      PendingBlock firstBlock = newBlocks.get(0);\n\n      assert firstBlock.isFloor || newBlocks.size() == 1;\n\n      firstBlock.compileIndex(newBlocks, scratchBytes, scratchIntsRef);\n\n      // Remove slice from the top of the pending stack, that we just wrote:\n      pending.subList(pending.size()-count, pending.size()).clear();\n\n      // Append new block\n      pending.add(firstBlock);\n\n      newBlocks.clear();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6aaba221b22442bdf0ef28770c25fe259dfb3f55":["3e8715d826e588419327562287d5d6a8040d63d6","25b8a027ba57951e63075a2ae9647c5c4a8c5c5f"],"25b8a027ba57951e63075a2ae9647c5c4a8c5c5f":["3e8715d826e588419327562287d5d6a8040d63d6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["f838187609fee3a1afa5f162f93c796046242c84","3e8715d826e588419327562287d5d6a8040d63d6"],"3e8715d826e588419327562287d5d6a8040d63d6":["f838187609fee3a1afa5f162f93c796046242c84"],"f838187609fee3a1afa5f162f93c796046242c84":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["3e8715d826e588419327562287d5d6a8040d63d6","6aaba221b22442bdf0ef28770c25fe259dfb3f55"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6aaba221b22442bdf0ef28770c25fe259dfb3f55"]},"commit2Childs":{"6aaba221b22442bdf0ef28770c25fe259dfb3f55":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"25b8a027ba57951e63075a2ae9647c5c4a8c5c5f":["6aaba221b22442bdf0ef28770c25fe259dfb3f55"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f838187609fee3a1afa5f162f93c796046242c84"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"3e8715d826e588419327562287d5d6a8040d63d6":["6aaba221b22442bdf0ef28770c25fe259dfb3f55","25b8a027ba57951e63075a2ae9647c5c4a8c5c5f","d2638f781be724518ff6c2263d14a48cf6e68017","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"f838187609fee3a1afa5f162f93c796046242c84":["d2638f781be724518ff6c2263d14a48cf6e68017","3e8715d826e588419327562287d5d6a8040d63d6"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d2638f781be724518ff6c2263d14a48cf6e68017","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}