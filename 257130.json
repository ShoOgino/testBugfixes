{"path":"lucene/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfosReader#read(Directory,String,ChecksumIndexInput,SegmentInfos,IOContext).mjava","commits":[{"id":"7e0127a0bf2a1895ba6109cbbd451359b9c0653d","date":1326981970,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfosReader#read(Directory,String,ChecksumIndexInput,SegmentInfos,IOContext).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void read(Directory directory, String segmentsFileName, ChecksumIndexInput input, SegmentInfos infos, IOContext context) throws IOException { \n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    final int format = infos.getFormat();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = readSegmentInfo(directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), context, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context, false);\n        }\n\n        try {\n          Lucene40StoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1538bc2b1cdbe17dacb2c1e6d11a8dc7a18c6d30","date":1327936772,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfosReader#read(Directory,String,ChecksumIndexInput,SegmentInfos,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfosReader#read(Directory,String,ChecksumIndexInput,SegmentInfos,IOContext).mjava","sourceNew":"  @Override\n  public void read(Directory directory, String segmentsFileName, ChecksumIndexInput input, SegmentInfos infos, IOContext context) throws IOException { \n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    final int format = infos.getFormat();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = readSegmentInfo(directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), context, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context, false);\n        }\n\n        try {\n          Lucene3xStoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, ChecksumIndexInput input, SegmentInfos infos, IOContext context) throws IOException { \n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    final int format = infos.getFormat();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = readSegmentInfo(directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), context, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context, false);\n        }\n\n        try {\n          Lucene40StoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"be9e3e7d2fc880996ffcfe9a8fc47057b647e9e3","date":1327944832,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfosReader#read(Directory,String,ChecksumIndexInput,SegmentInfos,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfosReader#read(Directory,String,ChecksumIndexInput,SegmentInfos,IOContext).mjava","sourceNew":"  @Override\n  public void read(Directory directory, String segmentsFileName, ChecksumIndexInput input, SegmentInfos infos, IOContext context) throws IOException { \n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    final int format = infos.getFormat();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = readSegmentInfo(directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION), context, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context, false);\n        }\n\n        try {\n          Lucene3xStoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, ChecksumIndexInput input, SegmentInfos infos, IOContext context) throws IOException { \n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    final int format = infos.getFormat();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = readSegmentInfo(directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), context, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context, false);\n        }\n\n        try {\n          Lucene3xStoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"296df632fd63421ea20756fa11ad36fbc6f4c8a9","date":1327957998,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfosReader#read(Directory,String,ChecksumIndexInput,SegmentInfos,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfosReader#read(Directory,String,ChecksumIndexInput,SegmentInfos,IOContext).mjava","sourceNew":"  @Override\n  public void read(Directory directory, String segmentsFileName, ChecksumIndexInput input, SegmentInfos infos, IOContext context) throws IOException { \n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    final int format = infos.getFormat();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = readSegmentInfo(directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION), context, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context, false);\n        }\n\n        try {\n          Lucene3xStoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, ChecksumIndexInput input, SegmentInfos infos, IOContext context) throws IOException { \n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    final int format = infos.getFormat();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = readSegmentInfo(directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), context, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context, false);\n        }\n\n        try {\n          Lucene40StoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"410e066f093e407222d9681429d209084e783149","date":1327958394,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfosReader#read(Directory,String,ChecksumIndexInput,SegmentInfos,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfosReader#read(Directory,String,ChecksumIndexInput,SegmentInfos,IOContext).mjava","sourceNew":"  @Override\n  public void read(Directory directory, String segmentsFileName, ChecksumIndexInput input, SegmentInfos infos, IOContext context) throws IOException { \n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    final int format = infos.getFormat();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = readSegmentInfo(directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION), context, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context, false);\n        }\n\n        try {\n          Lucene3xStoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, ChecksumIndexInput input, SegmentInfos infos, IOContext context) throws IOException { \n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    final int format = infos.getFormat();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = readSegmentInfo(directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                IndexFileNames.COMPOUND_FILE_STORE_EXTENSION), context, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context, false);\n        }\n\n        try {\n          Lucene40StoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfosReader#read(Directory,String,ChecksumIndexInput,SegmentInfos,IOContext).mjava","pathOld":"lucene/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfosReader#read(Directory,String,ChecksumIndexInput,SegmentInfos,IOContext).mjava","sourceNew":"  @Override\n  public void read(Directory directory, String segmentsFileName, ChecksumIndexInput input, SegmentInfos infos, IOContext context) throws IOException { \n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    final int format = infos.getFormat();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = readSegmentInfo(directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION), context, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context, false);\n        }\n\n        try {\n          Lucene3xStoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","sourceOld":"  @Override\n  public void read(Directory directory, String segmentsFileName, ChecksumIndexInput input, SegmentInfos infos, IOContext context) throws IOException { \n    infos.version = input.readLong(); // read version\n    infos.counter = input.readInt(); // read counter\n    final int format = infos.getFormat();\n    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos\n      SegmentInfo si = readSegmentInfo(directory, format, input);\n      if (si.getVersion() == null) {\n        // Could be a 3.0 - try to open the doc stores - if it fails, it's a\n        // 2.x segment, and an IndexFormatTooOldException will be thrown,\n        // which is what we want.\n        Directory dir = directory;\n        if (si.getDocStoreOffset() != -1) {\n          if (si.getDocStoreIsCompoundFile()) {\n            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n                si.getDocStoreSegment(), \"\",\n                Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION), context, false);\n          }\n        } else if (si.getUseCompoundFile()) {\n          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(\n              si.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION), context, false);\n        }\n\n        try {\n          Lucene3xStoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());\n        } finally {\n          // If we opened the directory, close it\n          if (dir != directory) dir.close();\n        }\n          \n        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next\n        // time the segment is read, its version won't be null and we won't\n        // need to open FieldsReader every time for each such segment.\n        si.setVersion(\"3.0\");\n      } else if (si.getVersion().equals(\"2.x\")) {\n        // If it's a 3x index touched by 3.1+ code, then segments record their\n        // version, whether they are 2.x ones or not. We detect that and throw\n        // appropriate exception.\n        throw new IndexFormatTooOldException(\"segment \" + si.name + \" in resource \" + input, si.getVersion());\n      }\n      infos.add(si);\n    }\n      \n    infos.userData = input.readStringStringMap();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"410e066f093e407222d9681429d209084e783149":["7e0127a0bf2a1895ba6109cbbd451359b9c0653d","296df632fd63421ea20756fa11ad36fbc6f4c8a9"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["296df632fd63421ea20756fa11ad36fbc6f4c8a9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"296df632fd63421ea20756fa11ad36fbc6f4c8a9":["7e0127a0bf2a1895ba6109cbbd451359b9c0653d","be9e3e7d2fc880996ffcfe9a8fc47057b647e9e3"],"7e0127a0bf2a1895ba6109cbbd451359b9c0653d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1538bc2b1cdbe17dacb2c1e6d11a8dc7a18c6d30":["7e0127a0bf2a1895ba6109cbbd451359b9c0653d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"be9e3e7d2fc880996ffcfe9a8fc47057b647e9e3":["1538bc2b1cdbe17dacb2c1e6d11a8dc7a18c6d30"]},"commit2Childs":{"410e066f093e407222d9681429d209084e783149":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7e0127a0bf2a1895ba6109cbbd451359b9c0653d"],"296df632fd63421ea20756fa11ad36fbc6f4c8a9":["410e066f093e407222d9681429d209084e783149","3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"7e0127a0bf2a1895ba6109cbbd451359b9c0653d":["410e066f093e407222d9681429d209084e783149","296df632fd63421ea20756fa11ad36fbc6f4c8a9","1538bc2b1cdbe17dacb2c1e6d11a8dc7a18c6d30"],"1538bc2b1cdbe17dacb2c1e6d11a8dc7a18c6d30":["be9e3e7d2fc880996ffcfe9a8fc47057b647e9e3"],"be9e3e7d2fc880996ffcfe9a8fc47057b647e9e3":["296df632fd63421ea20756fa11ad36fbc6f4c8a9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["410e066f093e407222d9681429d209084e783149","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}