{"path":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/kuromoji/KuromojiTokenizer#pruneAndRescore(int,int,int).mjava","commits":[{"id":"0984ad47974c2d5d354519ddb2aa8358973a6271","date":1330868053,"type":0,"author":"Christian Moen","isMerge":false,"pathNew":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/kuromoji/KuromojiTokenizer#pruneAndRescore(int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  private void pruneAndRescore(int startPos, int endPos, int bestStartIDX) throws IOException {\n    if (VERBOSE) {\n      System.out.println(\"  pruneAndRescore startPos=\" + startPos + \" endPos=\" + endPos + \" bestStartIDX=\" + bestStartIDX);\n    }\n\n    // First pass: walk backwards, building up the forward\n    // arcs and pruning inadmissible arcs:\n    for(int pos=endPos; pos > startPos; pos--) {\n      final Position posData = positions.get(pos);\n      if (VERBOSE) {\n        System.out.println(\"    back pos=\" + pos);\n      }\n      for(int arcIDX=0;arcIDX<posData.count;arcIDX++) {\n        final int backPos = posData.backPos[arcIDX];\n        if (backPos >= startPos) {\n          // Keep this arc:\n          //System.out.println(\"      keep backPos=\" + backPos);\n          positions.get(backPos).addForward(pos,\n                                            arcIDX,\n                                            posData.backID[arcIDX],\n                                            posData.backType[arcIDX]);\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"      prune\");\n          }\n        }\n      }\n      if (pos != startPos) {\n        posData.count = 0;\n      }\n    }\n\n    // Second pass: walk forward, re-scoring:\n    for(int pos=startPos; pos < endPos; pos++) {\n      final Position posData = positions.get(pos);\n      if (VERBOSE) {\n        System.out.println(\"    forward pos=\" + pos + \" count=\" + posData.forwardCount);\n      }\n      if (posData.count == 0) {\n        // No arcs arrive here...\n        if (VERBOSE) {\n          System.out.println(\"      skip\");\n        }\n        posData.forwardCount = 0;\n        continue;\n      }\n\n      if (pos == startPos) {\n        // On the initial position, only consider the best\n        // path so we \"force congruence\":  the\n        // sub-segmentation is \"in context\" of what the best\n        // path (compound token) had matched:\n        final int rightID;\n        if (startPos == 0) {\n          rightID = 0;\n        } else {\n          rightID = getDict(posData.backType[bestStartIDX]).getRightId(posData.backID[bestStartIDX]);\n        }\n        final int pathCost = posData.costs[bestStartIDX];\n        for(int forwardArcIDX=0;forwardArcIDX<posData.forwardCount;forwardArcIDX++) {\n          final Type forwardType = posData.forwardType[forwardArcIDX];\n          final Dictionary dict2 = getDict(forwardType);\n          final int wordID = posData.forwardID[forwardArcIDX];\n          final int toPos = posData.forwardPos[forwardArcIDX];\n          final int newCost = pathCost + dict2.getWordCost(wordID) + \n            costs.get(rightID, dict2.getLeftId(wordID)) +\n            computePenalty(pos, toPos-pos);\n          if (VERBOSE) {\n            System.out.println(\"      + \" + forwardType + \" word \" + new String(buffer.get(pos, toPos-pos)) + \" toPos=\" + toPos + \" cost=\" + newCost + \" penalty=\" + computePenalty(pos, toPos-pos) + \" toPos.idx=\" + positions.get(toPos).count);\n          }\n          positions.get(toPos).add(newCost,\n                                   dict2.getRightId(wordID),\n                                   pos,\n                                   bestStartIDX,\n                                   wordID,\n                                   forwardType);\n        }\n      } else {\n        // On non-initial positions, we maximize score\n        // across all arriving lastRightIDs:\n        for(int forwardArcIDX=0;forwardArcIDX<posData.forwardCount;forwardArcIDX++) {\n          final Type forwardType = posData.forwardType[forwardArcIDX];\n          final int toPos = posData.forwardPos[forwardArcIDX];\n          if (VERBOSE) {\n            System.out.println(\"      + \" + forwardType + \" word \" + new String(buffer.get(pos, toPos-pos)) + \" toPos=\" + toPos);\n          }\n          add(getDict(forwardType),\n              posData,\n              toPos,\n              posData.forwardID[forwardArcIDX],\n              forwardType,\n              true);\n        }\n      }\n      posData.forwardCount = 0;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":0,"author":"Ryan McKinley","isMerge":true,"pathNew":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/kuromoji/KuromojiTokenizer#pruneAndRescore(int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  private void pruneAndRescore(int startPos, int endPos, int bestStartIDX) throws IOException {\n    if (VERBOSE) {\n      System.out.println(\"  pruneAndRescore startPos=\" + startPos + \" endPos=\" + endPos + \" bestStartIDX=\" + bestStartIDX);\n    }\n\n    // First pass: walk backwards, building up the forward\n    // arcs and pruning inadmissible arcs:\n    for(int pos=endPos; pos > startPos; pos--) {\n      final Position posData = positions.get(pos);\n      if (VERBOSE) {\n        System.out.println(\"    back pos=\" + pos);\n      }\n      for(int arcIDX=0;arcIDX<posData.count;arcIDX++) {\n        final int backPos = posData.backPos[arcIDX];\n        if (backPos >= startPos) {\n          // Keep this arc:\n          //System.out.println(\"      keep backPos=\" + backPos);\n          positions.get(backPos).addForward(pos,\n                                            arcIDX,\n                                            posData.backID[arcIDX],\n                                            posData.backType[arcIDX]);\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"      prune\");\n          }\n        }\n      }\n      if (pos != startPos) {\n        posData.count = 0;\n      }\n    }\n\n    // Second pass: walk forward, re-scoring:\n    for(int pos=startPos; pos < endPos; pos++) {\n      final Position posData = positions.get(pos);\n      if (VERBOSE) {\n        System.out.println(\"    forward pos=\" + pos + \" count=\" + posData.forwardCount);\n      }\n      if (posData.count == 0) {\n        // No arcs arrive here...\n        if (VERBOSE) {\n          System.out.println(\"      skip\");\n        }\n        posData.forwardCount = 0;\n        continue;\n      }\n\n      if (pos == startPos) {\n        // On the initial position, only consider the best\n        // path so we \"force congruence\":  the\n        // sub-segmentation is \"in context\" of what the best\n        // path (compound token) had matched:\n        final int rightID;\n        if (startPos == 0) {\n          rightID = 0;\n        } else {\n          rightID = getDict(posData.backType[bestStartIDX]).getRightId(posData.backID[bestStartIDX]);\n        }\n        final int pathCost = posData.costs[bestStartIDX];\n        for(int forwardArcIDX=0;forwardArcIDX<posData.forwardCount;forwardArcIDX++) {\n          final Type forwardType = posData.forwardType[forwardArcIDX];\n          final Dictionary dict2 = getDict(forwardType);\n          final int wordID = posData.forwardID[forwardArcIDX];\n          final int toPos = posData.forwardPos[forwardArcIDX];\n          final int newCost = pathCost + dict2.getWordCost(wordID) + \n            costs.get(rightID, dict2.getLeftId(wordID)) +\n            computePenalty(pos, toPos-pos);\n          if (VERBOSE) {\n            System.out.println(\"      + \" + forwardType + \" word \" + new String(buffer.get(pos, toPos-pos)) + \" toPos=\" + toPos + \" cost=\" + newCost + \" penalty=\" + computePenalty(pos, toPos-pos) + \" toPos.idx=\" + positions.get(toPos).count);\n          }\n          positions.get(toPos).add(newCost,\n                                   dict2.getRightId(wordID),\n                                   pos,\n                                   bestStartIDX,\n                                   wordID,\n                                   forwardType);\n        }\n      } else {\n        // On non-initial positions, we maximize score\n        // across all arriving lastRightIDs:\n        for(int forwardArcIDX=0;forwardArcIDX<posData.forwardCount;forwardArcIDX++) {\n          final Type forwardType = posData.forwardType[forwardArcIDX];\n          final int toPos = posData.forwardPos[forwardArcIDX];\n          if (VERBOSE) {\n            System.out.println(\"      + \" + forwardType + \" word \" + new String(buffer.get(pos, toPos-pos)) + \" toPos=\" + toPos);\n          }\n          add(getDict(forwardType),\n              posData,\n              toPos,\n              posData.forwardID[forwardArcIDX],\n              forwardType,\n              true);\n        }\n      }\n      posData.forwardCount = 0;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98d45c1ff2c99694b6de2201175f9b8b8b27b597","date":1332757908,"type":5,"author":"Christian Moen","isMerge":false,"pathNew":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/JapaneseTokenizer#pruneAndRescore(int,int,int).mjava","pathOld":"modules/analysis/kuromoji/src/java/org/apache/lucene/analysis/kuromoji/KuromojiTokenizer#pruneAndRescore(int,int,int).mjava","sourceNew":"  private void pruneAndRescore(int startPos, int endPos, int bestStartIDX) throws IOException {\n    if (VERBOSE) {\n      System.out.println(\"  pruneAndRescore startPos=\" + startPos + \" endPos=\" + endPos + \" bestStartIDX=\" + bestStartIDX);\n    }\n\n    // First pass: walk backwards, building up the forward\n    // arcs and pruning inadmissible arcs:\n    for(int pos=endPos; pos > startPos; pos--) {\n      final Position posData = positions.get(pos);\n      if (VERBOSE) {\n        System.out.println(\"    back pos=\" + pos);\n      }\n      for(int arcIDX=0;arcIDX<posData.count;arcIDX++) {\n        final int backPos = posData.backPos[arcIDX];\n        if (backPos >= startPos) {\n          // Keep this arc:\n          //System.out.println(\"      keep backPos=\" + backPos);\n          positions.get(backPos).addForward(pos,\n                                            arcIDX,\n                                            posData.backID[arcIDX],\n                                            posData.backType[arcIDX]);\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"      prune\");\n          }\n        }\n      }\n      if (pos != startPos) {\n        posData.count = 0;\n      }\n    }\n\n    // Second pass: walk forward, re-scoring:\n    for(int pos=startPos; pos < endPos; pos++) {\n      final Position posData = positions.get(pos);\n      if (VERBOSE) {\n        System.out.println(\"    forward pos=\" + pos + \" count=\" + posData.forwardCount);\n      }\n      if (posData.count == 0) {\n        // No arcs arrive here...\n        if (VERBOSE) {\n          System.out.println(\"      skip\");\n        }\n        posData.forwardCount = 0;\n        continue;\n      }\n\n      if (pos == startPos) {\n        // On the initial position, only consider the best\n        // path so we \"force congruence\":  the\n        // sub-segmentation is \"in context\" of what the best\n        // path (compound token) had matched:\n        final int rightID;\n        if (startPos == 0) {\n          rightID = 0;\n        } else {\n          rightID = getDict(posData.backType[bestStartIDX]).getRightId(posData.backID[bestStartIDX]);\n        }\n        final int pathCost = posData.costs[bestStartIDX];\n        for(int forwardArcIDX=0;forwardArcIDX<posData.forwardCount;forwardArcIDX++) {\n          final Type forwardType = posData.forwardType[forwardArcIDX];\n          final Dictionary dict2 = getDict(forwardType);\n          final int wordID = posData.forwardID[forwardArcIDX];\n          final int toPos = posData.forwardPos[forwardArcIDX];\n          final int newCost = pathCost + dict2.getWordCost(wordID) + \n            costs.get(rightID, dict2.getLeftId(wordID)) +\n            computePenalty(pos, toPos-pos);\n          if (VERBOSE) {\n            System.out.println(\"      + \" + forwardType + \" word \" + new String(buffer.get(pos, toPos-pos)) + \" toPos=\" + toPos + \" cost=\" + newCost + \" penalty=\" + computePenalty(pos, toPos-pos) + \" toPos.idx=\" + positions.get(toPos).count);\n          }\n          positions.get(toPos).add(newCost,\n                                   dict2.getRightId(wordID),\n                                   pos,\n                                   bestStartIDX,\n                                   wordID,\n                                   forwardType);\n        }\n      } else {\n        // On non-initial positions, we maximize score\n        // across all arriving lastRightIDs:\n        for(int forwardArcIDX=0;forwardArcIDX<posData.forwardCount;forwardArcIDX++) {\n          final Type forwardType = posData.forwardType[forwardArcIDX];\n          final int toPos = posData.forwardPos[forwardArcIDX];\n          if (VERBOSE) {\n            System.out.println(\"      + \" + forwardType + \" word \" + new String(buffer.get(pos, toPos-pos)) + \" toPos=\" + toPos);\n          }\n          add(getDict(forwardType),\n              posData,\n              toPos,\n              posData.forwardID[forwardArcIDX],\n              forwardType,\n              true);\n        }\n      }\n      posData.forwardCount = 0;\n    }\n  }\n\n","sourceOld":"  private void pruneAndRescore(int startPos, int endPos, int bestStartIDX) throws IOException {\n    if (VERBOSE) {\n      System.out.println(\"  pruneAndRescore startPos=\" + startPos + \" endPos=\" + endPos + \" bestStartIDX=\" + bestStartIDX);\n    }\n\n    // First pass: walk backwards, building up the forward\n    // arcs and pruning inadmissible arcs:\n    for(int pos=endPos; pos > startPos; pos--) {\n      final Position posData = positions.get(pos);\n      if (VERBOSE) {\n        System.out.println(\"    back pos=\" + pos);\n      }\n      for(int arcIDX=0;arcIDX<posData.count;arcIDX++) {\n        final int backPos = posData.backPos[arcIDX];\n        if (backPos >= startPos) {\n          // Keep this arc:\n          //System.out.println(\"      keep backPos=\" + backPos);\n          positions.get(backPos).addForward(pos,\n                                            arcIDX,\n                                            posData.backID[arcIDX],\n                                            posData.backType[arcIDX]);\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"      prune\");\n          }\n        }\n      }\n      if (pos != startPos) {\n        posData.count = 0;\n      }\n    }\n\n    // Second pass: walk forward, re-scoring:\n    for(int pos=startPos; pos < endPos; pos++) {\n      final Position posData = positions.get(pos);\n      if (VERBOSE) {\n        System.out.println(\"    forward pos=\" + pos + \" count=\" + posData.forwardCount);\n      }\n      if (posData.count == 0) {\n        // No arcs arrive here...\n        if (VERBOSE) {\n          System.out.println(\"      skip\");\n        }\n        posData.forwardCount = 0;\n        continue;\n      }\n\n      if (pos == startPos) {\n        // On the initial position, only consider the best\n        // path so we \"force congruence\":  the\n        // sub-segmentation is \"in context\" of what the best\n        // path (compound token) had matched:\n        final int rightID;\n        if (startPos == 0) {\n          rightID = 0;\n        } else {\n          rightID = getDict(posData.backType[bestStartIDX]).getRightId(posData.backID[bestStartIDX]);\n        }\n        final int pathCost = posData.costs[bestStartIDX];\n        for(int forwardArcIDX=0;forwardArcIDX<posData.forwardCount;forwardArcIDX++) {\n          final Type forwardType = posData.forwardType[forwardArcIDX];\n          final Dictionary dict2 = getDict(forwardType);\n          final int wordID = posData.forwardID[forwardArcIDX];\n          final int toPos = posData.forwardPos[forwardArcIDX];\n          final int newCost = pathCost + dict2.getWordCost(wordID) + \n            costs.get(rightID, dict2.getLeftId(wordID)) +\n            computePenalty(pos, toPos-pos);\n          if (VERBOSE) {\n            System.out.println(\"      + \" + forwardType + \" word \" + new String(buffer.get(pos, toPos-pos)) + \" toPos=\" + toPos + \" cost=\" + newCost + \" penalty=\" + computePenalty(pos, toPos-pos) + \" toPos.idx=\" + positions.get(toPos).count);\n          }\n          positions.get(toPos).add(newCost,\n                                   dict2.getRightId(wordID),\n                                   pos,\n                                   bestStartIDX,\n                                   wordID,\n                                   forwardType);\n        }\n      } else {\n        // On non-initial positions, we maximize score\n        // across all arriving lastRightIDs:\n        for(int forwardArcIDX=0;forwardArcIDX<posData.forwardCount;forwardArcIDX++) {\n          final Type forwardType = posData.forwardType[forwardArcIDX];\n          final int toPos = posData.forwardPos[forwardArcIDX];\n          if (VERBOSE) {\n            System.out.println(\"      + \" + forwardType + \" word \" + new String(buffer.get(pos, toPos-pos)) + \" toPos=\" + toPos);\n          }\n          add(getDict(forwardType),\n              posData,\n              toPos,\n              posData.forwardID[forwardArcIDX],\n              forwardType,\n              true);\n        }\n      }\n      posData.forwardCount = 0;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0984ad47974c2d5d354519ddb2aa8358973a6271"],"0984ad47974c2d5d354519ddb2aa8358973a6271":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"98d45c1ff2c99694b6de2201175f9b8b8b27b597":["0984ad47974c2d5d354519ddb2aa8358973a6271"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["98d45c1ff2c99694b6de2201175f9b8b8b27b597"]},"commit2Childs":{"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"0984ad47974c2d5d354519ddb2aa8358973a6271":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","98d45c1ff2c99694b6de2201175f9b8b8b27b597"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","0984ad47974c2d5d354519ddb2aa8358973a6271"],"98d45c1ff2c99694b6de2201175f9b8b8b27b597":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}