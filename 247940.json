{"path":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","commits":[{"id":"8b241ea5e635d896cc0af83cd96ffd0322e0aba7","date":1294226200,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(Searcher).mjava","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      @Override\n      public float getValue() { return value; }\n      \n      @Override\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n\n      @Override\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n\n      @Override\n      public Explanation explain (IndexReader ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(IndexReader indexReader, boolean scoreDocsInOrder, boolean topScorer)\n          throws IOException {\n        final Scorer scorer = weight.scorer(indexReader, true, false);\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(indexReader);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(similarity, this) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final Searcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      @Override\n      public float getValue() { return value; }\n      \n      @Override\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n\n      @Override\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n\n      @Override\n      public Explanation explain (IndexReader ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(IndexReader indexReader, boolean scoreDocsInOrder, boolean topScorer)\n          throws IOException {\n        final Scorer scorer = weight.scorer(indexReader, true, false);\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(indexReader);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(similarity, this) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70ad682703b8585f5d0a637efec044d57ec05efb","date":1294259117,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      @Override\n      public float getValue() { return value; }\n      \n      @Override\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n\n      @Override\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n\n      @Override\n      public Explanation explain (IndexReader ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(IndexReader indexReader, boolean scoreDocsInOrder, boolean topScorer)\n          throws IOException {\n        final Scorer scorer = weight.scorer(indexReader, true, false);\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(indexReader);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(similarity, this) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n        };\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2dadf0f3286a34a0fee6e788ffce88624bf2984e","date":1294260428,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      @Override\n      public float getValue() { return value; }\n      \n      @Override\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n\n      @Override\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n\n      @Override\n      public Explanation explain (ReaderContext ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(ReaderContext indexReader, boolean scoreDocsInOrder, boolean topScorer)\n          throws IOException {\n        final Scorer scorer = weight.scorer(indexReader, true, false);\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(indexReader);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(similarity, this) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      @Override\n      public float getValue() { return value; }\n      \n      @Override\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n\n      @Override\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n\n      @Override\n      public Explanation explain (IndexReader ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(IndexReader indexReader, boolean scoreDocsInOrder, boolean topScorer)\n          throws IOException {\n        final Scorer scorer = weight.scorer(indexReader, true, false);\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(indexReader);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(similarity, this) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a10b98ef1ef4bf9e38d2e07a9e425a916afa8705","date":1294747166,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      @Override\n      public float getValue() { return value; }\n      \n      @Override\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n\n      @Override\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n\n      @Override\n      public Explanation explain (AtomicReaderContext ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(AtomicReaderContext indexReader, boolean scoreDocsInOrder, boolean topScorer)\n          throws IOException {\n        final Scorer scorer = weight.scorer(indexReader, true, false);\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(indexReader);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(similarity, this) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      @Override\n      public float getValue() { return value; }\n      \n      @Override\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n\n      @Override\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n\n      @Override\n      public Explanation explain (ReaderContext ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(ReaderContext indexReader, boolean scoreDocsInOrder, boolean topScorer)\n          throws IOException {\n        final Scorer scorer = weight.scorer(indexReader, true, false);\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(indexReader);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(similarity, this) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dc63f17f42c64d6ccc8c361cfcdf074f115f770c","date":1294930751,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      @Override\n      public float getValue() { return value; }\n      \n      @Override\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n\n      @Override\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n\n      @Override\n      public Explanation explain (AtomicReaderContext ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(AtomicReaderContext context, ScorerContext scoreContext)\n          throws IOException {\n        final Scorer scorer = weight.scorer(context, ScorerContext.def());\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(context);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(similarity, this) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      @Override\n      public float getValue() { return value; }\n      \n      @Override\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n\n      @Override\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n\n      @Override\n      public Explanation explain (AtomicReaderContext ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(AtomicReaderContext indexReader, boolean scoreDocsInOrder, boolean topScorer)\n          throws IOException {\n        final Scorer scorer = weight.scorer(indexReader, true, false);\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(indexReader);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(similarity, this) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      @Override\n      public float getValue() { return value; }\n      \n      @Override\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n\n      @Override\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n\n      @Override\n      public Explanation explain (AtomicReaderContext ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(AtomicReaderContext context, ScorerContext scoreContext)\n          throws IOException {\n        final Scorer scorer = weight.scorer(context, ScorerContext.def());\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(context);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(similarity, this) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n        };\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"03cb5827cf46528aa8d9b3ef5eaeeccda861b1f4","date":1295478199,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = searcher.getSimilarity();\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      @Override\n      public float getValue() { return value; }\n      \n      @Override\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n\n      @Override\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n\n      @Override\n      public Explanation explain (AtomicReaderContext ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(AtomicReaderContext context, ScorerContext scoreContext)\n          throws IOException {\n        final Scorer scorer = weight.scorer(context, ScorerContext.def());\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(context);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(similarity, this) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      @Override\n      public float getValue() { return value; }\n      \n      @Override\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n\n      @Override\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n\n      @Override\n      public Explanation explain (AtomicReaderContext ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(AtomicReaderContext context, ScorerContext scoreContext)\n          throws IOException {\n        final Scorer scorer = weight.scorer(context, ScorerContext.def());\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(context);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(similarity, this) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e5e679b9c5f68f1f331de920ae8366af75b44060","date":1295555804,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      @Override\n      public float getValue() { return value; }\n      \n      @Override\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n\n      @Override\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n\n      @Override\n      public Explanation explain (AtomicReaderContext ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(AtomicReaderContext context, ScorerContext scoreContext)\n          throws IOException {\n        final Scorer scorer = weight.scorer(context, ScorerContext.def());\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(context);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(this) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = searcher.getSimilarity();\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      @Override\n      public float getValue() { return value; }\n      \n      @Override\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n\n      @Override\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n\n      @Override\n      public Explanation explain (AtomicReaderContext ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(AtomicReaderContext context, ScorerContext scoreContext)\n          throws IOException {\n        final Scorer scorer = weight.scorer(context, ScorerContext.def());\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(context);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(similarity, this) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e79a6d080bdd5b2a8f56342cf571b5476de04180","date":1295638686,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      @Override\n      public float getValue() { return value; }\n      \n      @Override\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n\n      @Override\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n\n      @Override\n      public Explanation explain (AtomicReaderContext ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(AtomicReaderContext context, ScorerContext scoreContext)\n          throws IOException {\n        final Scorer scorer = weight.scorer(context, ScorerContext.def());\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(context);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(this) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      @Override\n      public float getValue() { return value; }\n      \n      @Override\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n\n      @Override\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n\n      @Override\n      public Explanation explain (AtomicReaderContext ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(AtomicReaderContext context, ScorerContext scoreContext)\n          throws IOException {\n        final Scorer scorer = weight.scorer(context, ScorerContext.def());\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(context);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(similarity, this) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      @Override\n      public float getValue() { return value; }\n      \n      @Override\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n\n      @Override\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n\n      @Override\n      public Explanation explain (AtomicReaderContext ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(AtomicReaderContext context, ScorerContext scoreContext)\n          throws IOException {\n        final Scorer scorer = weight.scorer(context, ScorerContext.def());\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(context);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(this) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    final Similarity similarity = query.getSimilarity(searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      @Override\n      public float getValue() { return value; }\n      \n      @Override\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n\n      @Override\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n\n      @Override\n      public Explanation explain (IndexReader ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(IndexReader indexReader, boolean scoreDocsInOrder, boolean topScorer)\n          throws IOException {\n        final Scorer scorer = weight.scorer(indexReader, true, false);\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(indexReader);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(similarity, this) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f3cee3d20b0c786e6fca20539454262e29edcab","date":1310101685,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    return new Weight() {\n      \n      @Override\n      public float getValueForNormalization() throws IOException { \n        return weight.getValueForNormalization() * getBoost() * getBoost(); \n      }\n\n      @Override\n      public void normalize (float norm, float topLevelBoost) { \n        weight.normalize(norm, topLevelBoost);\n      }\n\n      @Override\n      public Explanation explain (AtomicReaderContext ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(AtomicReaderContext context, ScorerContext scoreContext)\n          throws IOException {\n        final Scorer scorer = weight.scorer(context, ScorerContext.def());\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(context);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(this) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      @Override\n      public float getValue() { return value; }\n      \n      @Override\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n\n      @Override\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n\n      @Override\n      public Explanation explain (AtomicReaderContext ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(AtomicReaderContext context, ScorerContext scoreContext)\n          throws IOException {\n        final Scorer scorer = weight.scorer(context, ScorerContext.def());\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(context);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(this) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f0b9507caf22f292ac0e5e59f62db4275adf4511","date":1310107283,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    return new Weight() {\n      \n      @Override\n      public float getValueForNormalization() throws IOException { \n        return weight.getValueForNormalization() * getBoost() * getBoost(); \n      }\n\n      @Override\n      public void normalize (float norm, float topLevelBoost) { \n        weight.normalize(norm, topLevelBoost);\n      }\n\n      @Override\n      public Explanation explain (AtomicReaderContext ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(AtomicReaderContext context, ScorerContext scoreContext)\n          throws IOException {\n        final Scorer scorer = weight.scorer(context, ScorerContext.def());\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(context);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(this) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      @Override\n      public float getValue() { return value; }\n      \n      @Override\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n\n      @Override\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n\n      @Override\n      public Explanation explain (AtomicReaderContext ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(AtomicReaderContext context, ScorerContext scoreContext)\n          throws IOException {\n        final Scorer scorer = weight.scorer(context, ScorerContext.def());\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(context);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(this) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1291e4568eb7d9463d751627596ef14baf4c1603","date":1310112572,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    return new Weight() {\n      \n      @Override\n      public float getValueForNormalization() throws IOException { \n        return weight.getValueForNormalization() * getBoost() * getBoost(); \n      }\n\n      @Override\n      public void normalize (float norm, float topLevelBoost) { \n        weight.normalize(norm, topLevelBoost);\n      }\n\n      @Override\n      public Explanation explain (AtomicReaderContext ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(AtomicReaderContext context, ScorerContext scoreContext)\n          throws IOException {\n        final Scorer scorer = weight.scorer(context, ScorerContext.def());\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(context);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(this) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    return new Weight() {\n      private float value;\n        \n      // pass these methods through to enclosed query's weight\n      @Override\n      public float getValue() { return value; }\n      \n      @Override\n      public float sumOfSquaredWeights() throws IOException { \n        return weight.sumOfSquaredWeights() * getBoost() * getBoost(); \n      }\n\n      @Override\n      public void normalize (float v) { \n        weight.normalize(v);\n        value = weight.getValue() * getBoost();\n      }\n\n      @Override\n      public Explanation explain (AtomicReaderContext ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(AtomicReaderContext context, ScorerContext scoreContext)\n          throws IOException {\n        final Scorer scorer = weight.scorer(context, ScorerContext.def());\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(context);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(this) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3fc1f3f78b299e125f7e60f43b5d457392bea23f","date":1317431015,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    return new Weight() {\n      \n      @Override\n      public float getValueForNormalization() throws IOException { \n        return weight.getValueForNormalization() * getBoost() * getBoost(); \n      }\n\n      @Override\n      public void normalize (float norm, float topLevelBoost) { \n        weight.normalize(norm, topLevelBoost);\n      }\n\n      @Override\n      public Explanation explain (AtomicReaderContext ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(AtomicReaderContext context, boolean scoreDocsInOrder,\n          boolean topScorer, Bits acceptDocs)\n          throws IOException {\n        // we will advance() the subscorer\n        final Scorer scorer = weight.scorer(context, true, false, acceptDocs);\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(context);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(this) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    return new Weight() {\n      \n      @Override\n      public float getValueForNormalization() throws IOException { \n        return weight.getValueForNormalization() * getBoost() * getBoost(); \n      }\n\n      @Override\n      public void normalize (float norm, float topLevelBoost) { \n        weight.normalize(norm, topLevelBoost);\n      }\n\n      @Override\n      public Explanation explain (AtomicReaderContext ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(AtomicReaderContext context, ScorerContext scoreContext)\n          throws IOException {\n        final Scorer scorer = weight.scorer(context, ScorerContext.def());\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(context);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(this) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b89714bac7d9b077b27981d36cede2e833bb1da","date":1317916863,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    return new Weight() {\n      \n      @Override\n      public float getValueForNormalization() throws IOException { \n        return weight.getValueForNormalization() * getBoost() * getBoost(); // boost sub-weight\n      }\n\n      @Override\n      public void normalize (float norm, float topLevelBoost) { \n        weight.normalize(norm, topLevelBoost * getBoost()); // incorporate boost\n      }\n\n      @Override\n      public Explanation explain (AtomicReaderContext ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(AtomicReaderContext context, boolean scoreDocsInOrder,\n          boolean topScorer, Bits acceptDocs)\n          throws IOException {\n        // we will advance() the subscorer\n        final Scorer scorer = weight.scorer(context, true, false, acceptDocs);\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(context);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(this) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return scorer.score(); }\n        };\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    return new Weight() {\n      \n      @Override\n      public float getValueForNormalization() throws IOException { \n        return weight.getValueForNormalization() * getBoost() * getBoost(); \n      }\n\n      @Override\n      public void normalize (float norm, float topLevelBoost) { \n        weight.normalize(norm, topLevelBoost);\n      }\n\n      @Override\n      public Explanation explain (AtomicReaderContext ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        if (getBoost()!=1) {\n          Explanation preBoost = inner;\n          inner = new Explanation(inner.getValue()*getBoost(),\"product of:\");\n          inner.addDetail(new Explanation(getBoost(),\"boost\"));\n          inner.addDetail(preBoost);\n        }\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(AtomicReaderContext context, boolean scoreDocsInOrder,\n          boolean topScorer, Bits acceptDocs)\n          throws IOException {\n        // we will advance() the subscorer\n        final Scorer scorer = weight.scorer(context, true, false, acceptDocs);\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(context);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(this) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return getBoost() * scorer.score(); }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6620df8541b174097b1133a4fc370adb2e570524","date":1319544675,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    return new Weight() {\n      \n      @Override\n      public boolean scoresDocsOutOfOrder() {\n        // TODO: Support out-of-order scoring!\n        // For now we return false here, as we always get the scorer in order\n        return false;\n      }\n\n      @Override\n      public float getValueForNormalization() throws IOException { \n        return weight.getValueForNormalization() * getBoost() * getBoost(); // boost sub-weight\n      }\n\n      @Override\n      public void normalize (float norm, float topLevelBoost) { \n        weight.normalize(norm, topLevelBoost * getBoost()); // incorporate boost\n      }\n\n      @Override\n      public Explanation explain (AtomicReaderContext ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir, ir.reader.getLiveDocs());\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(AtomicReaderContext context, boolean scoreDocsInOrder, boolean topScorer, Bits acceptDocs) throws IOException {\n        assert filter != null;\n\n        final DocIdSet filterDocIdSet = filter.getDocIdSet(context, acceptDocs);\n        if (filterDocIdSet == null) {\n          // this means the filter does not accept any documents.\n          return null;\n        }\n        \n        final DocIdSetIterator filterIter = filterDocIdSet.iterator();\n        if (filterIter == null) {\n          // this means the filter does not accept any documents.\n          return null;\n        }\n\n        final int firstFilterDoc = filterIter.nextDoc();\n        if (firstFilterDoc == DocIdSetIterator.NO_MORE_DOCS) {\n          return null;\n        }\n        \n        final Bits filterAcceptDocs = filterDocIdSet.bits();\n        final boolean useRandomAccess = (filterAcceptDocs != null && FilteredQuery.this.useRandomAccess(filterAcceptDocs, firstFilterDoc));\n\n        if (useRandomAccess) {\n          // if we are using random access, we return the inner scorer, just with other acceptDocs\n          // TODO, replace this by when BooleanWeight is fixed to be consistent with its scorer implementations:\n          // return weight.scorer(context, scoreDocsInOrder, topScorer, filterAcceptDocs);\n          return weight.scorer(context, true, topScorer, filterAcceptDocs);\n        } else {\n          assert firstFilterDoc > -1;\n          // we are gonna advance() this scorer, so we set inorder=true/toplevel=false\n          // we pass null as acceptDocs, as our filter has already respected acceptDocs, no need to do twice\n          final Scorer scorer = weight.scorer(context, true, false, null);\n          return (scorer == null) ? null : new Scorer(this) {\n            private int scorerDoc = -1, filterDoc = firstFilterDoc;\n            \n            // optimization: we are topScorer and collect directly using short-circuited algo\n            @Override\n            public void score(Collector collector) throws IOException {\n              int filterDoc = firstFilterDoc;\n              int scorerDoc = scorer.advance(filterDoc);\n              // the normalization trick already applies the boost of this query,\n              // so we can use the wrapped scorer directly:\n              collector.setScorer(scorer);\n              for (;;) {\n                if (scorerDoc == filterDoc) {\n                  // Check if scorer has exhausted, only before collecting.\n                  if (scorerDoc == DocIdSetIterator.NO_MORE_DOCS) {\n                    break;\n                  }\n                  collector.collect(scorerDoc);\n                  filterDoc = filterIter.nextDoc();\n                  scorerDoc = scorer.advance(filterDoc);\n                } else if (scorerDoc > filterDoc) {\n                  filterDoc = filterIter.advance(scorerDoc);\n                } else {\n                  scorerDoc = scorer.advance(filterDoc);\n                }\n              }\n            }\n            \n            private int advanceToNextCommonDoc() throws IOException {\n              for (;;) {\n                if (scorerDoc < filterDoc) {\n                  scorerDoc = scorer.advance(filterDoc);\n                } else if (scorerDoc == filterDoc) {\n                  return scorerDoc;\n                } else {\n                  filterDoc = filterIter.advance(scorerDoc);\n                }\n              }\n            }\n\n            @Override\n            public int nextDoc() throws IOException {\n              // don't go to next doc on first call\n              // (because filterIter is already on first doc):\n              if (scorerDoc != -1) {\n                filterDoc = filterIter.nextDoc();\n              }\n              return advanceToNextCommonDoc();\n            }\n            \n            @Override\n            public int advance(int target) throws IOException {\n              if (target > filterDoc) {\n                filterDoc = filterIter.advance(target);\n              }\n              return advanceToNextCommonDoc();\n            }\n\n            @Override\n            public int docID() {\n              return scorerDoc;\n            }\n            \n            @Override\n            public float score() throws IOException {\n              return scorer.score();\n            }\n          };\n        }\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    return new Weight() {\n      \n      @Override\n      public float getValueForNormalization() throws IOException { \n        return weight.getValueForNormalization() * getBoost() * getBoost(); // boost sub-weight\n      }\n\n      @Override\n      public void normalize (float norm, float topLevelBoost) { \n        weight.normalize(norm, topLevelBoost * getBoost()); // incorporate boost\n      }\n\n      @Override\n      public Explanation explain (AtomicReaderContext ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir);\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(AtomicReaderContext context, boolean scoreDocsInOrder,\n          boolean topScorer, Bits acceptDocs)\n          throws IOException {\n        // we will advance() the subscorer\n        final Scorer scorer = weight.scorer(context, true, false, acceptDocs);\n        if (scorer == null) {\n          return null;\n        }\n        DocIdSet docIdSet = filter.getDocIdSet(context);\n        if (docIdSet == null) {\n          return null;\n        }\n        final DocIdSetIterator docIdSetIterator = docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          return null;\n        }\n\n        return new Scorer(this) {\n\n          private int doc = -1;\n          \n          private int advanceToCommon(int scorerDoc, int disiDoc) throws IOException {\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                scorerDoc = scorer.advance(disiDoc);\n              } else {\n                disiDoc = docIdSetIterator.advance(scorerDoc);\n              }\n            }\n            return scorerDoc;\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            int scorerDoc, disiDoc;\n            return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS\n                && (scorerDoc = scorer.nextDoc()) != NO_MORE_DOCS\n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n          \n          @Override\n          public int docID() { return doc; }\n          \n          @Override\n          public int advance(int target) throws IOException {\n            int disiDoc, scorerDoc;\n            return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS\n                && (scorerDoc = scorer.advance(disiDoc)) != NO_MORE_DOCS \n                && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;\n          }\n\n          @Override\n          public float score() throws IOException { return scorer.score(); }\n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6fff8f4b218bd0626afcdce82027bafeb84a50a4","date":1327229950,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    return new Weight() {\n      \n      @Override\n      public boolean scoresDocsOutOfOrder() {\n        // TODO: Support out-of-order scoring!\n        // For now we return false here, as we always get the scorer in order\n        return false;\n      }\n\n      @Override\n      public float getValueForNormalization() throws IOException { \n        return weight.getValueForNormalization() * getBoost() * getBoost(); // boost sub-weight\n      }\n\n      @Override\n      public void normalize (float norm, float topLevelBoost) { \n        weight.normalize(norm, topLevelBoost * getBoost()); // incorporate boost\n      }\n\n      @Override\n      public Explanation explain (AtomicReaderContext ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir, ir.reader().getLiveDocs());\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(AtomicReaderContext context, boolean scoreDocsInOrder, boolean topScorer, Bits acceptDocs) throws IOException {\n        assert filter != null;\n\n        final DocIdSet filterDocIdSet = filter.getDocIdSet(context, acceptDocs);\n        if (filterDocIdSet == null) {\n          // this means the filter does not accept any documents.\n          return null;\n        }\n        \n        final DocIdSetIterator filterIter = filterDocIdSet.iterator();\n        if (filterIter == null) {\n          // this means the filter does not accept any documents.\n          return null;\n        }\n\n        final int firstFilterDoc = filterIter.nextDoc();\n        if (firstFilterDoc == DocIdSetIterator.NO_MORE_DOCS) {\n          return null;\n        }\n        \n        final Bits filterAcceptDocs = filterDocIdSet.bits();\n        final boolean useRandomAccess = (filterAcceptDocs != null && FilteredQuery.this.useRandomAccess(filterAcceptDocs, firstFilterDoc));\n\n        if (useRandomAccess) {\n          // if we are using random access, we return the inner scorer, just with other acceptDocs\n          // TODO, replace this by when BooleanWeight is fixed to be consistent with its scorer implementations:\n          // return weight.scorer(context, scoreDocsInOrder, topScorer, filterAcceptDocs);\n          return weight.scorer(context, true, topScorer, filterAcceptDocs);\n        } else {\n          assert firstFilterDoc > -1;\n          // we are gonna advance() this scorer, so we set inorder=true/toplevel=false\n          // we pass null as acceptDocs, as our filter has already respected acceptDocs, no need to do twice\n          final Scorer scorer = weight.scorer(context, true, false, null);\n          return (scorer == null) ? null : new Scorer(this) {\n            private int scorerDoc = -1, filterDoc = firstFilterDoc;\n            \n            // optimization: we are topScorer and collect directly using short-circuited algo\n            @Override\n            public void score(Collector collector) throws IOException {\n              int filterDoc = firstFilterDoc;\n              int scorerDoc = scorer.advance(filterDoc);\n              // the normalization trick already applies the boost of this query,\n              // so we can use the wrapped scorer directly:\n              collector.setScorer(scorer);\n              for (;;) {\n                if (scorerDoc == filterDoc) {\n                  // Check if scorer has exhausted, only before collecting.\n                  if (scorerDoc == DocIdSetIterator.NO_MORE_DOCS) {\n                    break;\n                  }\n                  collector.collect(scorerDoc);\n                  filterDoc = filterIter.nextDoc();\n                  scorerDoc = scorer.advance(filterDoc);\n                } else if (scorerDoc > filterDoc) {\n                  filterDoc = filterIter.advance(scorerDoc);\n                } else {\n                  scorerDoc = scorer.advance(filterDoc);\n                }\n              }\n            }\n            \n            private int advanceToNextCommonDoc() throws IOException {\n              for (;;) {\n                if (scorerDoc < filterDoc) {\n                  scorerDoc = scorer.advance(filterDoc);\n                } else if (scorerDoc == filterDoc) {\n                  return scorerDoc;\n                } else {\n                  filterDoc = filterIter.advance(scorerDoc);\n                }\n              }\n            }\n\n            @Override\n            public int nextDoc() throws IOException {\n              // don't go to next doc on first call\n              // (because filterIter is already on first doc):\n              if (scorerDoc != -1) {\n                filterDoc = filterIter.nextDoc();\n              }\n              return advanceToNextCommonDoc();\n            }\n            \n            @Override\n            public int advance(int target) throws IOException {\n              if (target > filterDoc) {\n                filterDoc = filterIter.advance(target);\n              }\n              return advanceToNextCommonDoc();\n            }\n\n            @Override\n            public int docID() {\n              return scorerDoc;\n            }\n            \n            @Override\n            public float score() throws IOException {\n              return scorer.score();\n            }\n          };\n        }\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    return new Weight() {\n      \n      @Override\n      public boolean scoresDocsOutOfOrder() {\n        // TODO: Support out-of-order scoring!\n        // For now we return false here, as we always get the scorer in order\n        return false;\n      }\n\n      @Override\n      public float getValueForNormalization() throws IOException { \n        return weight.getValueForNormalization() * getBoost() * getBoost(); // boost sub-weight\n      }\n\n      @Override\n      public void normalize (float norm, float topLevelBoost) { \n        weight.normalize(norm, topLevelBoost * getBoost()); // incorporate boost\n      }\n\n      @Override\n      public Explanation explain (AtomicReaderContext ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir, ir.reader.getLiveDocs());\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(AtomicReaderContext context, boolean scoreDocsInOrder, boolean topScorer, Bits acceptDocs) throws IOException {\n        assert filter != null;\n\n        final DocIdSet filterDocIdSet = filter.getDocIdSet(context, acceptDocs);\n        if (filterDocIdSet == null) {\n          // this means the filter does not accept any documents.\n          return null;\n        }\n        \n        final DocIdSetIterator filterIter = filterDocIdSet.iterator();\n        if (filterIter == null) {\n          // this means the filter does not accept any documents.\n          return null;\n        }\n\n        final int firstFilterDoc = filterIter.nextDoc();\n        if (firstFilterDoc == DocIdSetIterator.NO_MORE_DOCS) {\n          return null;\n        }\n        \n        final Bits filterAcceptDocs = filterDocIdSet.bits();\n        final boolean useRandomAccess = (filterAcceptDocs != null && FilteredQuery.this.useRandomAccess(filterAcceptDocs, firstFilterDoc));\n\n        if (useRandomAccess) {\n          // if we are using random access, we return the inner scorer, just with other acceptDocs\n          // TODO, replace this by when BooleanWeight is fixed to be consistent with its scorer implementations:\n          // return weight.scorer(context, scoreDocsInOrder, topScorer, filterAcceptDocs);\n          return weight.scorer(context, true, topScorer, filterAcceptDocs);\n        } else {\n          assert firstFilterDoc > -1;\n          // we are gonna advance() this scorer, so we set inorder=true/toplevel=false\n          // we pass null as acceptDocs, as our filter has already respected acceptDocs, no need to do twice\n          final Scorer scorer = weight.scorer(context, true, false, null);\n          return (scorer == null) ? null : new Scorer(this) {\n            private int scorerDoc = -1, filterDoc = firstFilterDoc;\n            \n            // optimization: we are topScorer and collect directly using short-circuited algo\n            @Override\n            public void score(Collector collector) throws IOException {\n              int filterDoc = firstFilterDoc;\n              int scorerDoc = scorer.advance(filterDoc);\n              // the normalization trick already applies the boost of this query,\n              // so we can use the wrapped scorer directly:\n              collector.setScorer(scorer);\n              for (;;) {\n                if (scorerDoc == filterDoc) {\n                  // Check if scorer has exhausted, only before collecting.\n                  if (scorerDoc == DocIdSetIterator.NO_MORE_DOCS) {\n                    break;\n                  }\n                  collector.collect(scorerDoc);\n                  filterDoc = filterIter.nextDoc();\n                  scorerDoc = scorer.advance(filterDoc);\n                } else if (scorerDoc > filterDoc) {\n                  filterDoc = filterIter.advance(scorerDoc);\n                } else {\n                  scorerDoc = scorer.advance(filterDoc);\n                }\n              }\n            }\n            \n            private int advanceToNextCommonDoc() throws IOException {\n              for (;;) {\n                if (scorerDoc < filterDoc) {\n                  scorerDoc = scorer.advance(filterDoc);\n                } else if (scorerDoc == filterDoc) {\n                  return scorerDoc;\n                } else {\n                  filterDoc = filterIter.advance(scorerDoc);\n                }\n              }\n            }\n\n            @Override\n            public int nextDoc() throws IOException {\n              // don't go to next doc on first call\n              // (because filterIter is already on first doc):\n              if (scorerDoc != -1) {\n                filterDoc = filterIter.nextDoc();\n              }\n              return advanceToNextCommonDoc();\n            }\n            \n            @Override\n            public int advance(int target) throws IOException {\n              if (target > filterDoc) {\n                filterDoc = filterIter.advance(target);\n              }\n              return advanceToNextCommonDoc();\n            }\n\n            @Override\n            public int docID() {\n              return scorerDoc;\n            }\n            \n            @Override\n            public float score() throws IOException {\n              return scorer.score();\n            }\n          };\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    return new Weight() {\n      \n      @Override\n      public boolean scoresDocsOutOfOrder() {\n        // TODO: Support out-of-order scoring!\n        // For now we return false here, as we always get the scorer in order\n        return false;\n      }\n\n      @Override\n      public float getValueForNormalization() throws IOException { \n        return weight.getValueForNormalization() * getBoost() * getBoost(); // boost sub-weight\n      }\n\n      @Override\n      public void normalize (float norm, float topLevelBoost) { \n        weight.normalize(norm, topLevelBoost * getBoost()); // incorporate boost\n      }\n\n      @Override\n      public Explanation explain (AtomicReaderContext ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir, ir.reader().getLiveDocs());\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(AtomicReaderContext context, boolean scoreDocsInOrder, boolean topScorer, Bits acceptDocs) throws IOException {\n        assert filter != null;\n\n        final DocIdSet filterDocIdSet = filter.getDocIdSet(context, acceptDocs);\n        if (filterDocIdSet == null) {\n          // this means the filter does not accept any documents.\n          return null;\n        }\n        \n        final DocIdSetIterator filterIter = filterDocIdSet.iterator();\n        if (filterIter == null) {\n          // this means the filter does not accept any documents.\n          return null;\n        }\n\n        final int firstFilterDoc = filterIter.nextDoc();\n        if (firstFilterDoc == DocIdSetIterator.NO_MORE_DOCS) {\n          return null;\n        }\n        \n        final Bits filterAcceptDocs = filterDocIdSet.bits();\n        final boolean useRandomAccess = (filterAcceptDocs != null && FilteredQuery.this.useRandomAccess(filterAcceptDocs, firstFilterDoc));\n\n        if (useRandomAccess) {\n          // if we are using random access, we return the inner scorer, just with other acceptDocs\n          // TODO, replace this by when BooleanWeight is fixed to be consistent with its scorer implementations:\n          // return weight.scorer(context, scoreDocsInOrder, topScorer, filterAcceptDocs);\n          return weight.scorer(context, true, topScorer, filterAcceptDocs);\n        } else {\n          assert firstFilterDoc > -1;\n          // we are gonna advance() this scorer, so we set inorder=true/toplevel=false\n          // we pass null as acceptDocs, as our filter has already respected acceptDocs, no need to do twice\n          final Scorer scorer = weight.scorer(context, true, false, null);\n          return (scorer == null) ? null : new Scorer(this) {\n            private int scorerDoc = -1, filterDoc = firstFilterDoc;\n            \n            // optimization: we are topScorer and collect directly using short-circuited algo\n            @Override\n            public void score(Collector collector) throws IOException {\n              int filterDoc = firstFilterDoc;\n              int scorerDoc = scorer.advance(filterDoc);\n              // the normalization trick already applies the boost of this query,\n              // so we can use the wrapped scorer directly:\n              collector.setScorer(scorer);\n              for (;;) {\n                if (scorerDoc == filterDoc) {\n                  // Check if scorer has exhausted, only before collecting.\n                  if (scorerDoc == DocIdSetIterator.NO_MORE_DOCS) {\n                    break;\n                  }\n                  collector.collect(scorerDoc);\n                  filterDoc = filterIter.nextDoc();\n                  scorerDoc = scorer.advance(filterDoc);\n                } else if (scorerDoc > filterDoc) {\n                  filterDoc = filterIter.advance(scorerDoc);\n                } else {\n                  scorerDoc = scorer.advance(filterDoc);\n                }\n              }\n            }\n            \n            private int advanceToNextCommonDoc() throws IOException {\n              for (;;) {\n                if (scorerDoc < filterDoc) {\n                  scorerDoc = scorer.advance(filterDoc);\n                } else if (scorerDoc == filterDoc) {\n                  return scorerDoc;\n                } else {\n                  filterDoc = filterIter.advance(scorerDoc);\n                }\n              }\n            }\n\n            @Override\n            public int nextDoc() throws IOException {\n              // don't go to next doc on first call\n              // (because filterIter is already on first doc):\n              if (scorerDoc != -1) {\n                filterDoc = filterIter.nextDoc();\n              }\n              return advanceToNextCommonDoc();\n            }\n            \n            @Override\n            public int advance(int target) throws IOException {\n              if (target > filterDoc) {\n                filterDoc = filterIter.advance(target);\n              }\n              return advanceToNextCommonDoc();\n            }\n\n            @Override\n            public int docID() {\n              return scorerDoc;\n            }\n            \n            @Override\n            public float score() throws IOException {\n              return scorer.score();\n            }\n          };\n        }\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    return new Weight() {\n      \n      @Override\n      public boolean scoresDocsOutOfOrder() {\n        // TODO: Support out-of-order scoring!\n        // For now we return false here, as we always get the scorer in order\n        return false;\n      }\n\n      @Override\n      public float getValueForNormalization() throws IOException { \n        return weight.getValueForNormalization() * getBoost() * getBoost(); // boost sub-weight\n      }\n\n      @Override\n      public void normalize (float norm, float topLevelBoost) { \n        weight.normalize(norm, topLevelBoost * getBoost()); // incorporate boost\n      }\n\n      @Override\n      public Explanation explain (AtomicReaderContext ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir, ir.reader.getLiveDocs());\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(AtomicReaderContext context, boolean scoreDocsInOrder, boolean topScorer, Bits acceptDocs) throws IOException {\n        assert filter != null;\n\n        final DocIdSet filterDocIdSet = filter.getDocIdSet(context, acceptDocs);\n        if (filterDocIdSet == null) {\n          // this means the filter does not accept any documents.\n          return null;\n        }\n        \n        final DocIdSetIterator filterIter = filterDocIdSet.iterator();\n        if (filterIter == null) {\n          // this means the filter does not accept any documents.\n          return null;\n        }\n\n        final int firstFilterDoc = filterIter.nextDoc();\n        if (firstFilterDoc == DocIdSetIterator.NO_MORE_DOCS) {\n          return null;\n        }\n        \n        final Bits filterAcceptDocs = filterDocIdSet.bits();\n        final boolean useRandomAccess = (filterAcceptDocs != null && FilteredQuery.this.useRandomAccess(filterAcceptDocs, firstFilterDoc));\n\n        if (useRandomAccess) {\n          // if we are using random access, we return the inner scorer, just with other acceptDocs\n          // TODO, replace this by when BooleanWeight is fixed to be consistent with its scorer implementations:\n          // return weight.scorer(context, scoreDocsInOrder, topScorer, filterAcceptDocs);\n          return weight.scorer(context, true, topScorer, filterAcceptDocs);\n        } else {\n          assert firstFilterDoc > -1;\n          // we are gonna advance() this scorer, so we set inorder=true/toplevel=false\n          // we pass null as acceptDocs, as our filter has already respected acceptDocs, no need to do twice\n          final Scorer scorer = weight.scorer(context, true, false, null);\n          return (scorer == null) ? null : new Scorer(this) {\n            private int scorerDoc = -1, filterDoc = firstFilterDoc;\n            \n            // optimization: we are topScorer and collect directly using short-circuited algo\n            @Override\n            public void score(Collector collector) throws IOException {\n              int filterDoc = firstFilterDoc;\n              int scorerDoc = scorer.advance(filterDoc);\n              // the normalization trick already applies the boost of this query,\n              // so we can use the wrapped scorer directly:\n              collector.setScorer(scorer);\n              for (;;) {\n                if (scorerDoc == filterDoc) {\n                  // Check if scorer has exhausted, only before collecting.\n                  if (scorerDoc == DocIdSetIterator.NO_MORE_DOCS) {\n                    break;\n                  }\n                  collector.collect(scorerDoc);\n                  filterDoc = filterIter.nextDoc();\n                  scorerDoc = scorer.advance(filterDoc);\n                } else if (scorerDoc > filterDoc) {\n                  filterDoc = filterIter.advance(scorerDoc);\n                } else {\n                  scorerDoc = scorer.advance(filterDoc);\n                }\n              }\n            }\n            \n            private int advanceToNextCommonDoc() throws IOException {\n              for (;;) {\n                if (scorerDoc < filterDoc) {\n                  scorerDoc = scorer.advance(filterDoc);\n                } else if (scorerDoc == filterDoc) {\n                  return scorerDoc;\n                } else {\n                  filterDoc = filterIter.advance(scorerDoc);\n                }\n              }\n            }\n\n            @Override\n            public int nextDoc() throws IOException {\n              // don't go to next doc on first call\n              // (because filterIter is already on first doc):\n              if (scorerDoc != -1) {\n                filterDoc = filterIter.nextDoc();\n              }\n              return advanceToNextCommonDoc();\n            }\n            \n            @Override\n            public int advance(int target) throws IOException {\n              if (target > filterDoc) {\n                filterDoc = filterIter.advance(target);\n              }\n              return advanceToNextCommonDoc();\n            }\n\n            @Override\n            public int docID() {\n              return scorerDoc;\n            }\n            \n            @Override\n            public float score() throws IOException {\n              return scorer.score();\n            }\n          };\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FilteredQuery#createWeight(IndexSearcher).mjava","sourceNew":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    return new Weight() {\n      \n      @Override\n      public boolean scoresDocsOutOfOrder() {\n        // TODO: Support out-of-order scoring!\n        // For now we return false here, as we always get the scorer in order\n        return false;\n      }\n\n      @Override\n      public float getValueForNormalization() throws IOException { \n        return weight.getValueForNormalization() * getBoost() * getBoost(); // boost sub-weight\n      }\n\n      @Override\n      public void normalize (float norm, float topLevelBoost) { \n        weight.normalize(norm, topLevelBoost * getBoost()); // incorporate boost\n      }\n\n      @Override\n      public Explanation explain (AtomicReaderContext ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir, ir.reader().getLiveDocs());\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(AtomicReaderContext context, boolean scoreDocsInOrder, boolean topScorer, Bits acceptDocs) throws IOException {\n        assert filter != null;\n\n        final DocIdSet filterDocIdSet = filter.getDocIdSet(context, acceptDocs);\n        if (filterDocIdSet == null) {\n          // this means the filter does not accept any documents.\n          return null;\n        }\n        \n        final DocIdSetIterator filterIter = filterDocIdSet.iterator();\n        if (filterIter == null) {\n          // this means the filter does not accept any documents.\n          return null;\n        }\n\n        final int firstFilterDoc = filterIter.nextDoc();\n        if (firstFilterDoc == DocIdSetIterator.NO_MORE_DOCS) {\n          return null;\n        }\n        \n        final Bits filterAcceptDocs = filterDocIdSet.bits();\n        final boolean useRandomAccess = (filterAcceptDocs != null && FilteredQuery.this.useRandomAccess(filterAcceptDocs, firstFilterDoc));\n\n        if (useRandomAccess) {\n          // if we are using random access, we return the inner scorer, just with other acceptDocs\n          // TODO, replace this by when BooleanWeight is fixed to be consistent with its scorer implementations:\n          // return weight.scorer(context, scoreDocsInOrder, topScorer, filterAcceptDocs);\n          return weight.scorer(context, true, topScorer, filterAcceptDocs);\n        } else {\n          assert firstFilterDoc > -1;\n          // we are gonna advance() this scorer, so we set inorder=true/toplevel=false\n          // we pass null as acceptDocs, as our filter has already respected acceptDocs, no need to do twice\n          final Scorer scorer = weight.scorer(context, true, false, null);\n          return (scorer == null) ? null : new Scorer(this) {\n            private int scorerDoc = -1, filterDoc = firstFilterDoc;\n            \n            // optimization: we are topScorer and collect directly using short-circuited algo\n            @Override\n            public void score(Collector collector) throws IOException {\n              int filterDoc = firstFilterDoc;\n              int scorerDoc = scorer.advance(filterDoc);\n              // the normalization trick already applies the boost of this query,\n              // so we can use the wrapped scorer directly:\n              collector.setScorer(scorer);\n              for (;;) {\n                if (scorerDoc == filterDoc) {\n                  // Check if scorer has exhausted, only before collecting.\n                  if (scorerDoc == DocIdSetIterator.NO_MORE_DOCS) {\n                    break;\n                  }\n                  collector.collect(scorerDoc);\n                  filterDoc = filterIter.nextDoc();\n                  scorerDoc = scorer.advance(filterDoc);\n                } else if (scorerDoc > filterDoc) {\n                  filterDoc = filterIter.advance(scorerDoc);\n                } else {\n                  scorerDoc = scorer.advance(filterDoc);\n                }\n              }\n            }\n            \n            private int advanceToNextCommonDoc() throws IOException {\n              for (;;) {\n                if (scorerDoc < filterDoc) {\n                  scorerDoc = scorer.advance(filterDoc);\n                } else if (scorerDoc == filterDoc) {\n                  return scorerDoc;\n                } else {\n                  filterDoc = filterIter.advance(scorerDoc);\n                }\n              }\n            }\n\n            @Override\n            public int nextDoc() throws IOException {\n              // don't go to next doc on first call\n              // (because filterIter is already on first doc):\n              if (scorerDoc != -1) {\n                filterDoc = filterIter.nextDoc();\n              }\n              return advanceToNextCommonDoc();\n            }\n            \n            @Override\n            public int advance(int target) throws IOException {\n              if (target > filterDoc) {\n                filterDoc = filterIter.advance(target);\n              }\n              return advanceToNextCommonDoc();\n            }\n\n            @Override\n            public int docID() {\n              return scorerDoc;\n            }\n            \n            @Override\n            public float score() throws IOException {\n              return scorer.score();\n            }\n          };\n        }\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Returns a Weight that applies the filter to the enclosed query's Weight.\n   * This is accomplished by overriding the Scorer returned by the Weight.\n   */\n  @Override\n  public Weight createWeight(final IndexSearcher searcher) throws IOException {\n    final Weight weight = query.createWeight (searcher);\n    return new Weight() {\n      \n      @Override\n      public boolean scoresDocsOutOfOrder() {\n        // TODO: Support out-of-order scoring!\n        // For now we return false here, as we always get the scorer in order\n        return false;\n      }\n\n      @Override\n      public float getValueForNormalization() throws IOException { \n        return weight.getValueForNormalization() * getBoost() * getBoost(); // boost sub-weight\n      }\n\n      @Override\n      public void normalize (float norm, float topLevelBoost) { \n        weight.normalize(norm, topLevelBoost * getBoost()); // incorporate boost\n      }\n\n      @Override\n      public Explanation explain (AtomicReaderContext ir, int i) throws IOException {\n        Explanation inner = weight.explain (ir, i);\n        Filter f = FilteredQuery.this.filter;\n        DocIdSet docIdSet = f.getDocIdSet(ir, ir.reader().getLiveDocs());\n        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();\n        if (docIdSetIterator == null) {\n          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();\n        }\n        if (docIdSetIterator.advance(i) == i) {\n          return inner;\n        } else {\n          Explanation result = new Explanation\n            (0.0f, \"failure to match filter: \" + f.toString());\n          result.addDetail(inner);\n          return result;\n        }\n      }\n\n      // return this query\n      @Override\n      public Query getQuery() { return FilteredQuery.this; }\n\n      // return a filtering scorer\n      @Override\n      public Scorer scorer(AtomicReaderContext context, boolean scoreDocsInOrder, boolean topScorer, Bits acceptDocs) throws IOException {\n        assert filter != null;\n\n        final DocIdSet filterDocIdSet = filter.getDocIdSet(context, acceptDocs);\n        if (filterDocIdSet == null) {\n          // this means the filter does not accept any documents.\n          return null;\n        }\n        \n        final DocIdSetIterator filterIter = filterDocIdSet.iterator();\n        if (filterIter == null) {\n          // this means the filter does not accept any documents.\n          return null;\n        }\n\n        final int firstFilterDoc = filterIter.nextDoc();\n        if (firstFilterDoc == DocIdSetIterator.NO_MORE_DOCS) {\n          return null;\n        }\n        \n        final Bits filterAcceptDocs = filterDocIdSet.bits();\n        final boolean useRandomAccess = (filterAcceptDocs != null && FilteredQuery.this.useRandomAccess(filterAcceptDocs, firstFilterDoc));\n\n        if (useRandomAccess) {\n          // if we are using random access, we return the inner scorer, just with other acceptDocs\n          // TODO, replace this by when BooleanWeight is fixed to be consistent with its scorer implementations:\n          // return weight.scorer(context, scoreDocsInOrder, topScorer, filterAcceptDocs);\n          return weight.scorer(context, true, topScorer, filterAcceptDocs);\n        } else {\n          assert firstFilterDoc > -1;\n          // we are gonna advance() this scorer, so we set inorder=true/toplevel=false\n          // we pass null as acceptDocs, as our filter has already respected acceptDocs, no need to do twice\n          final Scorer scorer = weight.scorer(context, true, false, null);\n          return (scorer == null) ? null : new Scorer(this) {\n            private int scorerDoc = -1, filterDoc = firstFilterDoc;\n            \n            // optimization: we are topScorer and collect directly using short-circuited algo\n            @Override\n            public void score(Collector collector) throws IOException {\n              int filterDoc = firstFilterDoc;\n              int scorerDoc = scorer.advance(filterDoc);\n              // the normalization trick already applies the boost of this query,\n              // so we can use the wrapped scorer directly:\n              collector.setScorer(scorer);\n              for (;;) {\n                if (scorerDoc == filterDoc) {\n                  // Check if scorer has exhausted, only before collecting.\n                  if (scorerDoc == DocIdSetIterator.NO_MORE_DOCS) {\n                    break;\n                  }\n                  collector.collect(scorerDoc);\n                  filterDoc = filterIter.nextDoc();\n                  scorerDoc = scorer.advance(filterDoc);\n                } else if (scorerDoc > filterDoc) {\n                  filterDoc = filterIter.advance(scorerDoc);\n                } else {\n                  scorerDoc = scorer.advance(filterDoc);\n                }\n              }\n            }\n            \n            private int advanceToNextCommonDoc() throws IOException {\n              for (;;) {\n                if (scorerDoc < filterDoc) {\n                  scorerDoc = scorer.advance(filterDoc);\n                } else if (scorerDoc == filterDoc) {\n                  return scorerDoc;\n                } else {\n                  filterDoc = filterIter.advance(scorerDoc);\n                }\n              }\n            }\n\n            @Override\n            public int nextDoc() throws IOException {\n              // don't go to next doc on first call\n              // (because filterIter is already on first doc):\n              if (scorerDoc != -1) {\n                filterDoc = filterIter.nextDoc();\n              }\n              return advanceToNextCommonDoc();\n            }\n            \n            @Override\n            public int advance(int target) throws IOException {\n              if (target > filterDoc) {\n                filterDoc = filterIter.advance(target);\n              }\n              return advanceToNextCommonDoc();\n            }\n\n            @Override\n            public int docID() {\n              return scorerDoc;\n            }\n            \n            @Override\n            public float score() throws IOException {\n              return scorer.score();\n            }\n          };\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"70ad682703b8585f5d0a637efec044d57ec05efb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","8b241ea5e635d896cc0af83cd96ffd0322e0aba7"],"0f3cee3d20b0c786e6fca20539454262e29edcab":["e5e679b9c5f68f1f331de920ae8366af75b44060"],"6620df8541b174097b1133a4fc370adb2e570524":["6b89714bac7d9b077b27981d36cede2e833bb1da"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"3fc1f3f78b299e125f7e60f43b5d457392bea23f":["0f3cee3d20b0c786e6fca20539454262e29edcab"],"03cb5827cf46528aa8d9b3ef5eaeeccda861b1f4":["dc63f17f42c64d6ccc8c361cfcdf074f115f770c"],"6fff8f4b218bd0626afcdce82027bafeb84a50a4":["6620df8541b174097b1133a4fc370adb2e570524"],"dc63f17f42c64d6ccc8c361cfcdf074f115f770c":["a10b98ef1ef4bf9e38d2e07a9e425a916afa8705"],"e79a6d080bdd5b2a8f56342cf571b5476de04180":["868da859b43505d9d2a023bfeae6dd0c795f5295","e5e679b9c5f68f1f331de920ae8366af75b44060"],"6b89714bac7d9b077b27981d36cede2e833bb1da":["3fc1f3f78b299e125f7e60f43b5d457392bea23f"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["6620df8541b174097b1133a4fc370adb2e570524","6fff8f4b218bd0626afcdce82027bafeb84a50a4"],"1291e4568eb7d9463d751627596ef14baf4c1603":["e5e679b9c5f68f1f331de920ae8366af75b44060","0f3cee3d20b0c786e6fca20539454262e29edcab"],"8b241ea5e635d896cc0af83cd96ffd0322e0aba7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f0b9507caf22f292ac0e5e59f62db4275adf4511":["e5e679b9c5f68f1f331de920ae8366af75b44060","0f3cee3d20b0c786e6fca20539454262e29edcab"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["70ad682703b8585f5d0a637efec044d57ec05efb","e5e679b9c5f68f1f331de920ae8366af75b44060"],"2dadf0f3286a34a0fee6e788ffce88624bf2984e":["8b241ea5e635d896cc0af83cd96ffd0322e0aba7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a10b98ef1ef4bf9e38d2e07a9e425a916afa8705":["2dadf0f3286a34a0fee6e788ffce88624bf2984e"],"e5e679b9c5f68f1f331de920ae8366af75b44060":["03cb5827cf46528aa8d9b3ef5eaeeccda861b1f4"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","dc63f17f42c64d6ccc8c361cfcdf074f115f770c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"70ad682703b8585f5d0a637efec044d57ec05efb":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"0f3cee3d20b0c786e6fca20539454262e29edcab":["3fc1f3f78b299e125f7e60f43b5d457392bea23f","1291e4568eb7d9463d751627596ef14baf4c1603","f0b9507caf22f292ac0e5e59f62db4275adf4511"],"6620df8541b174097b1133a4fc370adb2e570524":["6fff8f4b218bd0626afcdce82027bafeb84a50a4","5cab9a86bd67202d20b6adc463008c8e982b070a"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3fc1f3f78b299e125f7e60f43b5d457392bea23f":["6b89714bac7d9b077b27981d36cede2e833bb1da"],"03cb5827cf46528aa8d9b3ef5eaeeccda861b1f4":["e5e679b9c5f68f1f331de920ae8366af75b44060"],"6fff8f4b218bd0626afcdce82027bafeb84a50a4":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"dc63f17f42c64d6ccc8c361cfcdf074f115f770c":["03cb5827cf46528aa8d9b3ef5eaeeccda861b1f4","868da859b43505d9d2a023bfeae6dd0c795f5295"],"e79a6d080bdd5b2a8f56342cf571b5476de04180":[],"6b89714bac7d9b077b27981d36cede2e833bb1da":["6620df8541b174097b1133a4fc370adb2e570524"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"1291e4568eb7d9463d751627596ef14baf4c1603":[],"8b241ea5e635d896cc0af83cd96ffd0322e0aba7":["70ad682703b8585f5d0a637efec044d57ec05efb","2dadf0f3286a34a0fee6e788ffce88624bf2984e"],"f0b9507caf22f292ac0e5e59f62db4275adf4511":[],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["70ad682703b8585f5d0a637efec044d57ec05efb","8b241ea5e635d896cc0af83cd96ffd0322e0aba7","868da859b43505d9d2a023bfeae6dd0c795f5295"],"2dadf0f3286a34a0fee6e788ffce88624bf2984e":["a10b98ef1ef4bf9e38d2e07a9e425a916afa8705"],"a10b98ef1ef4bf9e38d2e07a9e425a916afa8705":["dc63f17f42c64d6ccc8c361cfcdf074f115f770c"],"e5e679b9c5f68f1f331de920ae8366af75b44060":["0f3cee3d20b0c786e6fca20539454262e29edcab","e79a6d080bdd5b2a8f56342cf571b5476de04180","1291e4568eb7d9463d751627596ef14baf4c1603","f0b9507caf22f292ac0e5e59f62db4275adf4511","29ef99d61cda9641b6250bf9567329a6e65f901d"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["e79a6d080bdd5b2a8f56342cf571b5476de04180"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e79a6d080bdd5b2a8f56342cf571b5476de04180","1291e4568eb7d9463d751627596ef14baf4c1603","f0b9507caf22f292ac0e5e59f62db4275adf4511","29ef99d61cda9641b6250bf9567329a6e65f901d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}