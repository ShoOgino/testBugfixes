{"path":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","commits":[{"id":"e3ce1ef883d26aa73919aa2d53991726e96caa13","date":1445421402,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","pathOld":"/dev/null","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n    long indexFP;\n    try (BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB)) {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID);\n      }\n\n      boolean success = false;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n        success = true;\n      } finally {\n        if (success == false) {\n          IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\");\n        }\n      }\n    }\n\n    try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (BKDUtil.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new BKDReader.IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (BKDUtil.compare(numBytesPerDim, packedValue, dim, queryMin[dim], 0) < 0 ||\n                    BKDUtil.compare(numBytesPerDim, packedValue, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public BKDReader.Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = BKDUtil.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = BKDUtil.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (BKDUtil.compare(numBytesPerDim, maxPacked, dim, queryMin[dim], 0) < 0 ||\n                    BKDUtil.compare(numBytesPerDim, minPacked, dim, queryMax[dim], 0) > 0) {\n                  return BKDReader.Relation.QUERY_OUTSIDE_CELL;\n                } else if (BKDUtil.compare(numBytesPerDim, minPacked, dim, queryMin[dim], 0) < 0 ||\n                           BKDUtil.compare(numBytesPerDim, maxPacked, dim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return BKDReader.Relation.QUERY_CROSSES_CELL;\n              } else {\n                return BKDReader.Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (BKDUtil.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                BKDUtil.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n    }\n\n    dir.deleteFile(\"bkd\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"84f731d3a83b5ad26ada4066861424b12b21c233","date":1445465867,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n    long indexFP;\n    try (BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB)) {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID);\n      }\n\n      boolean success = false;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n        success = true;\n      } finally {\n        if (success == false) {\n          IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\");\n        }\n      }\n    }\n\n    try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (BKDUtil.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new BKDReader.IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (BKDUtil.compare(numBytesPerDim, packedValue, dim, queryMin[dim], 0) < 0 ||\n                    BKDUtil.compare(numBytesPerDim, packedValue, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public BKDReader.Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = BKDUtil.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = BKDUtil.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (BKDUtil.compare(numBytesPerDim, maxPacked, dim, queryMin[dim], 0) < 0 ||\n                    BKDUtil.compare(numBytesPerDim, minPacked, dim, queryMax[dim], 0) > 0) {\n                  return BKDReader.Relation.QUERY_OUTSIDE_CELL;\n                } else if (BKDUtil.compare(numBytesPerDim, minPacked, dim, queryMin[dim], 0) < 0 ||\n                           BKDUtil.compare(numBytesPerDim, maxPacked, dim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return BKDReader.Relation.QUERY_CROSSES_CELL;\n              } else {\n                return BKDReader.Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (BKDUtil.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                BKDUtil.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n    } finally {\n      dir.deleteFile(\"bkd\");\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n    long indexFP;\n    try (BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB)) {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID);\n      }\n\n      boolean success = false;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n        success = true;\n      } finally {\n        if (success == false) {\n          IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\");\n        }\n      }\n    }\n\n    try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (BKDUtil.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new BKDReader.IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (BKDUtil.compare(numBytesPerDim, packedValue, dim, queryMin[dim], 0) < 0 ||\n                    BKDUtil.compare(numBytesPerDim, packedValue, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public BKDReader.Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = BKDUtil.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = BKDUtil.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (BKDUtil.compare(numBytesPerDim, maxPacked, dim, queryMin[dim], 0) < 0 ||\n                    BKDUtil.compare(numBytesPerDim, minPacked, dim, queryMax[dim], 0) > 0) {\n                  return BKDReader.Relation.QUERY_OUTSIDE_CELL;\n                } else if (BKDUtil.compare(numBytesPerDim, minPacked, dim, queryMin[dim], 0) < 0 ||\n                           BKDUtil.compare(numBytesPerDim, maxPacked, dim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return BKDReader.Relation.QUERY_CROSSES_CELL;\n              } else {\n                return BKDReader.Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (BKDUtil.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                BKDUtil.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n    }\n\n    dir.deleteFile(\"bkd\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca792c26af46bd6c4a08d81117c60440cf6a7e3d","date":1445938295,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n    long indexFP;\n    try (BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB)) {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID);\n      }\n\n      boolean success = false;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n        success = true;\n      } finally {\n        if (success == false) {\n          IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\");\n        }\n      }\n    }\n\n    try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (BKDUtil.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (BKDUtil.compare(numBytesPerDim, packedValue, dim, queryMin[dim], 0) < 0 ||\n                    BKDUtil.compare(numBytesPerDim, packedValue, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (BKDUtil.compare(numBytesPerDim, maxPacked, dim, queryMin[dim], 0) < 0 ||\n                    BKDUtil.compare(numBytesPerDim, minPacked, dim, queryMax[dim], 0) > 0) {\n                  return Relation.QUERY_OUTSIDE_CELL;\n                } else if (BKDUtil.compare(numBytesPerDim, minPacked, dim, queryMin[dim], 0) < 0 ||\n                           BKDUtil.compare(numBytesPerDim, maxPacked, dim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.QUERY_CROSSES_CELL;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (BKDUtil.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                BKDUtil.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n    } finally {\n      dir.deleteFile(\"bkd\");\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n    long indexFP;\n    try (BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB)) {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID);\n      }\n\n      boolean success = false;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n        success = true;\n      } finally {\n        if (success == false) {\n          IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\");\n        }\n      }\n    }\n\n    try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (BKDUtil.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new BKDReader.IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (BKDUtil.compare(numBytesPerDim, packedValue, dim, queryMin[dim], 0) < 0 ||\n                    BKDUtil.compare(numBytesPerDim, packedValue, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public BKDReader.Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = BKDUtil.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = BKDUtil.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (BKDUtil.compare(numBytesPerDim, maxPacked, dim, queryMin[dim], 0) < 0 ||\n                    BKDUtil.compare(numBytesPerDim, minPacked, dim, queryMax[dim], 0) > 0) {\n                  return BKDReader.Relation.QUERY_OUTSIDE_CELL;\n                } else if (BKDUtil.compare(numBytesPerDim, minPacked, dim, queryMin[dim], 0) < 0 ||\n                           BKDUtil.compare(numBytesPerDim, maxPacked, dim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return BKDReader.Relation.QUERY_CROSSES_CELL;\n              } else {\n                return BKDReader.Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (BKDUtil.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                BKDUtil.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n    } finally {\n      dir.deleteFile(\"bkd\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1904709ea0185dc04e3d77ea01c79e909caf2796","date":1447006699,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n    long indexFP;\n    try (BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB)) {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID);\n      }\n\n      boolean success = false;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n        success = true;\n      } finally {\n        if (success == false) {\n          IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\");\n        }\n      }\n    }\n\n    try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (BKDUtil.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (BKDUtil.compare(numBytesPerDim, packedValue, dim, queryMin[dim], 0) < 0 ||\n                    BKDUtil.compare(numBytesPerDim, packedValue, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (BKDUtil.compare(numBytesPerDim, maxPacked, dim, queryMin[dim], 0) < 0 ||\n                    BKDUtil.compare(numBytesPerDim, minPacked, dim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (BKDUtil.compare(numBytesPerDim, minPacked, dim, queryMin[dim], 0) < 0 ||\n                           BKDUtil.compare(numBytesPerDim, maxPacked, dim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (BKDUtil.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                BKDUtil.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n    } finally {\n      dir.deleteFile(\"bkd\");\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n    long indexFP;\n    try (BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB)) {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID);\n      }\n\n      boolean success = false;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n        success = true;\n      } finally {\n        if (success == false) {\n          IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\");\n        }\n      }\n    }\n\n    try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (BKDUtil.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (BKDUtil.compare(numBytesPerDim, packedValue, dim, queryMin[dim], 0) < 0 ||\n                    BKDUtil.compare(numBytesPerDim, packedValue, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (BKDUtil.compare(numBytesPerDim, maxPacked, dim, queryMin[dim], 0) < 0 ||\n                    BKDUtil.compare(numBytesPerDim, minPacked, dim, queryMax[dim], 0) > 0) {\n                  return Relation.QUERY_OUTSIDE_CELL;\n                } else if (BKDUtil.compare(numBytesPerDim, minPacked, dim, queryMin[dim], 0) < 0 ||\n                           BKDUtil.compare(numBytesPerDim, maxPacked, dim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.QUERY_CROSSES_CELL;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (BKDUtil.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                BKDUtil.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n    } finally {\n      dir.deleteFile(\"bkd\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1786be6a11f9cf5e48ce84869d1bb71e9c02f966","date":1448381196,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<Integer> docIDBases = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docIDBases = new ArrayList<>();\n          }\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        System.out.println(\"merge \" + toMerge.size());\n        if (segCount > 0) {\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, null, readers, docIDBases);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (BKDUtil.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (BKDUtil.compare(numBytesPerDim, packedValue, dim, queryMin[dim], 0) < 0 ||\n                    BKDUtil.compare(numBytesPerDim, packedValue, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (BKDUtil.compare(numBytesPerDim, maxPacked, dim, queryMin[dim], 0) < 0 ||\n                    BKDUtil.compare(numBytesPerDim, minPacked, dim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (BKDUtil.compare(numBytesPerDim, minPacked, dim, queryMin[dim], 0) < 0 ||\n                           BKDUtil.compare(numBytesPerDim, maxPacked, dim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (BKDUtil.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                BKDUtil.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n    long indexFP;\n    try (BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB)) {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID);\n      }\n\n      boolean success = false;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n        success = true;\n      } finally {\n        if (success == false) {\n          IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\");\n        }\n      }\n    }\n\n    try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (BKDUtil.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (BKDUtil.compare(numBytesPerDim, packedValue, dim, queryMin[dim], 0) < 0 ||\n                    BKDUtil.compare(numBytesPerDim, packedValue, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (BKDUtil.compare(numBytesPerDim, maxPacked, dim, queryMin[dim], 0) < 0 ||\n                    BKDUtil.compare(numBytesPerDim, minPacked, dim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (BKDUtil.compare(numBytesPerDim, minPacked, dim, queryMin[dim], 0) < 0 ||\n                           BKDUtil.compare(numBytesPerDim, maxPacked, dim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (BKDUtil.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                BKDUtil.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n    } finally {\n      dir.deleteFile(\"bkd\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"770342641f7b505eaa8dccdc666158bff2419109","date":1449868421,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<Integer> docIDBases = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docIDBases = new ArrayList<>();\n          }\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        System.out.println(\"merge \" + toMerge.size());\n        if (segCount > 0) {\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, null, readers, docIDBases);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (NumericUtils.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (NumericUtils.compare(numBytesPerDim, packedValue, dim, queryMin[dim], 0) < 0 ||\n                    NumericUtils.compare(numBytesPerDim, packedValue, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (NumericUtils.compare(numBytesPerDim, maxPacked, dim, queryMin[dim], 0) < 0 ||\n                    NumericUtils.compare(numBytesPerDim, minPacked, dim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (NumericUtils.compare(numBytesPerDim, minPacked, dim, queryMin[dim], 0) < 0 ||\n                           NumericUtils.compare(numBytesPerDim, maxPacked, dim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (NumericUtils.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                NumericUtils.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<Integer> docIDBases = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docIDBases = new ArrayList<>();\n          }\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        System.out.println(\"merge \" + toMerge.size());\n        if (segCount > 0) {\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, null, readers, docIDBases);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (BKDUtil.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (BKDUtil.compare(numBytesPerDim, packedValue, dim, queryMin[dim], 0) < 0 ||\n                    BKDUtil.compare(numBytesPerDim, packedValue, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (BKDUtil.compare(numBytesPerDim, maxPacked, dim, queryMin[dim], 0) < 0 ||\n                    BKDUtil.compare(numBytesPerDim, minPacked, dim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (BKDUtil.compare(numBytesPerDim, minPacked, dim, queryMin[dim], 0) < 0 ||\n                           BKDUtil.compare(numBytesPerDim, maxPacked, dim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (BKDUtil.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                BKDUtil.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bfe104fc023fadc9e709f8d17403d2cc61133fe","date":1454446396,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<Integer> docIDBases = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docIDBases = new ArrayList<>();\n          }\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        System.out.println(\"merge \" + toMerge.size());\n        if (segCount > 0) {\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, null, readers, docIDBases);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (NumericUtils.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (NumericUtils.compare(numBytesPerDim, packedValue, dim, queryMin[dim], 0) < 0 ||\n                    NumericUtils.compare(numBytesPerDim, packedValue, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (NumericUtils.compare(numBytesPerDim, maxPacked, dim, queryMin[dim], 0) < 0 ||\n                    NumericUtils.compare(numBytesPerDim, minPacked, dim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (NumericUtils.compare(numBytesPerDim, minPacked, dim, queryMin[dim], 0) < 0 ||\n                           NumericUtils.compare(numBytesPerDim, maxPacked, dim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (NumericUtils.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                NumericUtils.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFiles(Collections.singleton(\"bkd\"));\n      if (toMerge != null) {\n        dir.deleteFiles(Collections.singleton(\"bkd2\"));\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<Integer> docIDBases = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docIDBases = new ArrayList<>();\n          }\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        System.out.println(\"merge \" + toMerge.size());\n        if (segCount > 0) {\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, null, readers, docIDBases);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (NumericUtils.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (NumericUtils.compare(numBytesPerDim, packedValue, dim, queryMin[dim], 0) < 0 ||\n                    NumericUtils.compare(numBytesPerDim, packedValue, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (NumericUtils.compare(numBytesPerDim, maxPacked, dim, queryMin[dim], 0) < 0 ||\n                    NumericUtils.compare(numBytesPerDim, minPacked, dim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (NumericUtils.compare(numBytesPerDim, minPacked, dim, queryMin[dim], 0) < 0 ||\n                           NumericUtils.compare(numBytesPerDim, maxPacked, dim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (NumericUtils.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                NumericUtils.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1","date":1454513757,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<Integer> docIDBases = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docIDBases = new ArrayList<>();\n          }\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        System.out.println(\"merge \" + toMerge.size());\n        if (segCount > 0) {\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, null, readers, docIDBases);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (NumericUtils.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (NumericUtils.compare(numBytesPerDim, packedValue, dim, queryMin[dim], 0) < 0 ||\n                    NumericUtils.compare(numBytesPerDim, packedValue, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (NumericUtils.compare(numBytesPerDim, maxPacked, dim, queryMin[dim], 0) < 0 ||\n                    NumericUtils.compare(numBytesPerDim, minPacked, dim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (NumericUtils.compare(numBytesPerDim, minPacked, dim, queryMin[dim], 0) < 0 ||\n                           NumericUtils.compare(numBytesPerDim, maxPacked, dim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (NumericUtils.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                NumericUtils.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<Integer> docIDBases = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docIDBases = new ArrayList<>();\n          }\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        System.out.println(\"merge \" + toMerge.size());\n        if (segCount > 0) {\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, null, readers, docIDBases);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (NumericUtils.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (NumericUtils.compare(numBytesPerDim, packedValue, dim, queryMin[dim], 0) < 0 ||\n                    NumericUtils.compare(numBytesPerDim, packedValue, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (NumericUtils.compare(numBytesPerDim, maxPacked, dim, queryMin[dim], 0) < 0 ||\n                    NumericUtils.compare(numBytesPerDim, minPacked, dim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (NumericUtils.compare(numBytesPerDim, minPacked, dim, queryMin[dim], 0) < 0 ||\n                           NumericUtils.compare(numBytesPerDim, maxPacked, dim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (NumericUtils.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                NumericUtils.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFiles(Collections.singleton(\"bkd\"));\n      if (toMerge != null) {\n        dir.deleteFiles(Collections.singleton(\"bkd2\"));\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"12bfdc932307442b651432f92845942f9041ace8","date":1456860728,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<Integer> docIDBases = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docIDBases = new ArrayList<>();\n          }\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        System.out.println(\"merge \" + toMerge.size());\n        if (segCount > 0) {\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, null, readers, docIDBases);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                           StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<Integer> docIDBases = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docIDBases = new ArrayList<>();\n          }\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        System.out.println(\"merge \" + toMerge.size());\n        if (segCount > 0) {\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, null, readers, docIDBases);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (NumericUtils.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (NumericUtils.compare(numBytesPerDim, packedValue, dim, queryMin[dim], 0) < 0 ||\n                    NumericUtils.compare(numBytesPerDim, packedValue, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (NumericUtils.compare(numBytesPerDim, maxPacked, dim, queryMin[dim], 0) < 0 ||\n                    NumericUtils.compare(numBytesPerDim, minPacked, dim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (NumericUtils.compare(numBytesPerDim, minPacked, dim, queryMin[dim], 0) < 0 ||\n                           NumericUtils.compare(numBytesPerDim, maxPacked, dim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (NumericUtils.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                NumericUtils.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"251c5b33f0a2c8988550b63c78ed22b0e84524e5","date":1456961997,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<Integer> docIDBases = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docIDBases = new ArrayList<>();\n          }\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        System.out.println(\"merge \" + toMerge.size());\n        if (segCount > 0) {\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, null, readers, docIDBases);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                           StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<Integer> docIDBases = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docIDBases = new ArrayList<>();\n          }\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        System.out.println(\"merge \" + toMerge.size());\n        if (segCount > 0) {\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, null, readers, docIDBases);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                           StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"02b353fc2be5047a3b7223d4f11a2a5fbd3dd86f","date":1456964948,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<Integer> docIDBases = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docIDBases = new ArrayList<>();\n          }\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, null, readers, docIDBases);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                           StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<Integer> docIDBases = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docIDBases = new ArrayList<>();\n          }\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        System.out.println(\"merge \" + toMerge.size());\n        if (segCount > 0) {\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, null, readers, docIDBases);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                           StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<Integer> docIDBases = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docIDBases = new ArrayList<>();\n          }\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, null, readers, docIDBases);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                           StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<Integer> docIDBases = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docIDBases = new ArrayList<>();\n          }\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        System.out.println(\"merge \" + toMerge.size());\n        if (segCount > 0) {\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, null, readers, docIDBases);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (NumericUtils.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (NumericUtils.compare(numBytesPerDim, packedValue, dim, queryMin[dim], 0) < 0 ||\n                    NumericUtils.compare(numBytesPerDim, packedValue, dim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (NumericUtils.compare(numBytesPerDim, maxPacked, dim, queryMin[dim], 0) < 0 ||\n                    NumericUtils.compare(numBytesPerDim, minPacked, dim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (NumericUtils.compare(numBytesPerDim, minPacked, dim, queryMin[dim], 0) < 0 ||\n                           NumericUtils.compare(numBytesPerDim, maxPacked, dim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (NumericUtils.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                NumericUtils.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9a5a0f27d9486cd33de88627ed3d2ff8dc5074ca","date":1457777566,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<Integer> docIDBases = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, randomPointCount());\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docIDBases = new ArrayList<>();\n          }\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, randomPointCount());\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, randomPointCount());\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, null, readers, docIDBases);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                           StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<Integer> docIDBases = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docIDBases = new ArrayList<>();\n          }\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, null, readers, docIDBases);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                           StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"416f9e28900210be57b69bc12e2954fb98ed7ebe","date":1458479803,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<Integer> docIDBases = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, randomPointCount(false), false);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docIDBases = new ArrayList<>();\n          }\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, randomPointCount(false), false);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, randomPointCount(false), false);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, null, readers, docIDBases);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                           StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<Integer> docIDBases = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, randomPointCount());\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docIDBases = new ArrayList<>();\n          }\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, randomPointCount());\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, randomPointCount());\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, null, readers, docIDBases);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                           StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f3d902d9e126b838f492796a117a4d9e532d597a","date":1458810839,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<Integer> docIDBases = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docIDBases = new ArrayList<>();\n          }\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, null, readers, docIDBases);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                           StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<Integer> docIDBases = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, randomPointCount(false), false);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docIDBases = new ArrayList<>();\n          }\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, randomPointCount(false), false);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, randomPointCount(false), false);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, null, readers, docIDBases);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                           StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ceaef6cfc68c8ab22a684192e469a8280f9e6e70","date":1462354657,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<MergeState.DocMap> docMaps = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docMaps = new ArrayList<>();\n          }\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          toMerge.add(w.finish(out));\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, docMaps, readers);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                           StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<Integer> docIDBases = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docIDBases = new ArrayList<>();\n          }\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, null, readers, docIDBases);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                           StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d33e731a93d4b57e662ff094f64f94a745422d4","date":1463128289,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<MergeState.DocMap> docMaps = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docMaps = new ArrayList<>();\n          }\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          toMerge.add(w.finish(out));\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, docMaps, readers);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                           StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<Integer> docIDBases = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docIDBases = new ArrayList<>();\n          }\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, null, readers, docIDBases);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                           StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ad30c6a479e764150a3316e57263319775f1df2","date":1463395403,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<MergeState.DocMap> docMaps = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docMaps = new ArrayList<>();\n          }\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          toMerge.add(w.finish(out));\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, docMaps, readers);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                           StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<Integer> docIDBases = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docIDBases = new ArrayList<>();\n          }\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, null, readers, docIDBases);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                           StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<MergeState.DocMap> docMaps = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docMaps = new ArrayList<>();\n          }\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          toMerge.add(w.finish(out));\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, docMaps, readers);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                           StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<Integer> docIDBases = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docIDBases = new ArrayList<>();\n          }\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, null, readers, docIDBases);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                           StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<MergeState.DocMap> docMaps = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docMaps = new ArrayList<>();\n          }\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          toMerge.add(w.finish(out));\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, docMaps, readers);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                           StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<Integer> docIDBases = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docIDBases = new ArrayList<>();\n          }\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          docIDBases.add(lastDocIDBase);\n          toMerge.add(w.finish(out));\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, null, readers, docIDBases);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                           StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"41f60ea1802fda42d3c91d023406066d00ddb5f8","date":1535615991,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<MergeState.DocMap> docMaps = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docMaps = new ArrayList<>();\n          }\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          toMerge.add(w.finish(out));\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, docMaps, readers);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (FutureArrays.compareUnsigned(queryMin[dim], 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (FutureArrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    FutureArrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (FutureArrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    FutureArrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (FutureArrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                           FutureArrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (FutureArrays.compareUnsigned(x, 0, numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                FutureArrays.compareUnsigned(x, 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<MergeState.DocMap> docMaps = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docMaps = new ArrayList<>();\n          }\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          toMerge.add(w.finish(out));\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, docMaps, readers);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (StringHelper.compare(numBytesPerDim, queryMin[dim], 0, queryMax[dim], 0) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, packedValue, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                    StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (StringHelper.compare(numBytesPerDim, minPacked, dim*numBytesPerDim, queryMin[dim], 0) < 0 ||\n                           StringHelper.compare(numBytesPerDim, maxPacked, dim*numBytesPerDim, queryMax[dim], 0) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (StringHelper.compare(numBytesPerDim, x, 0, queryMin[dim], 0) < 0 ||\n                StringHelper.compare(numBytesPerDim, x, 0, queryMax[dim], 0) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6652c943595e92c187ee904c382863013eae28f","date":1539042663,"type":5,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,int,double).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#verify(Directory,byte[][][],int[],int,int,int,double).mjava","sourceNew":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDataDims, int numIndexDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDataDims=\" + numDataDims + \" numIndexDims=\" + numIndexDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<MergeState.DocMap> docMaps = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDataDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDataDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDataDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docMaps = new ArrayList<>();\n          }\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          toMerge.add(w.finish(out));\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDataDims, numIndexDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, docMaps, readers);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDataDims][];\n        byte[][] queryMax = new byte[numDataDims][];\n        for(int dim=0;dim<numDataDims;dim++) {\n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (FutureArrays.compareUnsigned(queryMin[dim], 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (FutureArrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    FutureArrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numIndexDims;dim++) {\n                if (FutureArrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    FutureArrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (FutureArrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                           FutureArrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numIndexDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (FutureArrays.compareUnsigned(x, 0, numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                FutureArrays.compareUnsigned(x, 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","sourceOld":"  private void verify(Directory dir, byte[][][] docValues, int[] docIDs, int numDims, int numBytesPerDim, int maxPointsInLeafNode, double maxMB) throws Exception {\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim + \" maxPointsInLeafNode=\" + maxPointsInLeafNode + \" maxMB=\" + maxMB);\n    }\n\n    List<Long> toMerge = null;\n    List<MergeState.DocMap> docMaps = null;\n    int seg = 0;\n\n    BKDWriter w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n    IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT);\n    IndexInput in = null;\n\n    boolean success = false;\n\n    try {\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      int lastDocIDBase = 0;\n      boolean useMerge = numDims == 1 && numValues >= 10 && random().nextBoolean();\n      int valuesInThisSeg;\n      if (useMerge) {\n        // Sometimes we will call merge with a single segment:\n        valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues);\n      } else {\n        valuesInThisSeg = 0;\n      }\n\n      int segCount = 0;\n\n      for(int ord=0;ord<numValues;ord++) {\n        int docID;\n        if (docIDs == null) {\n          docID = ord;\n        } else {\n          docID = docIDs[ord];\n        }\n        if (VERBOSE) {\n          System.out.println(\"  ord=\" + ord + \" docID=\" + docID + \" lastDocIDBase=\" + lastDocIDBase);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + new BytesRef(docValues[ord][dim]));\n          }\n          System.arraycopy(docValues[ord][dim], 0, scratch, dim*numBytesPerDim, numBytesPerDim);\n        }\n        w.add(scratch, docID-lastDocIDBase);\n\n        segCount++;\n\n        if (useMerge && segCount == valuesInThisSeg) {\n          if (toMerge == null) {\n            toMerge = new ArrayList<>();\n            docMaps = new ArrayList<>();\n          }\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n          toMerge.add(w.finish(out));\n          valuesInThisSeg = TestUtil.nextInt(random(), numValues/10, numValues/2);\n          segCount = 0;\n\n          seg++;\n          maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 1000);\n          maxMB = (float) 3.0 + (3*random().nextDouble());\n          w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n          lastDocIDBase = docID;\n        }\n      }\n\n      long indexFP;\n\n      if (toMerge != null) {\n        if (segCount > 0) {\n          toMerge.add(w.finish(out));\n          final int curDocIDBase = lastDocIDBase;\n          docMaps.add(new MergeState.DocMap() {\n              @Override\n              public int get(int docID) {\n                return curDocIDBase + docID;\n              }\n            });\n        }\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n        seg++;\n        w = new BKDWriter(numValues, dir, \"_\" + seg, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, docValues.length, false);\n        List<BKDReader> readers = new ArrayList<>();\n        for(long fp : toMerge) {\n          in.seek(fp);\n          readers.add(new BKDReader(in));\n        }\n        out = dir.createOutput(\"bkd2\", IOContext.DEFAULT);\n        indexFP = w.merge(out, docMaps, readers);\n        out.close();\n        in.close();\n        in = dir.openInput(\"bkd2\", IOContext.DEFAULT);\n      } else {\n        indexFP = w.finish(out);\n        out.close();\n        in = dir.openInput(\"bkd\", IOContext.DEFAULT);\n      }\n\n      in.seek(indexFP);\n      BKDReader r = new BKDReader(in);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        byte[][] queryMin = new byte[numDims][];\n        byte[][] queryMax = new byte[numDims][];    \n        for(int dim=0;dim<numDims;dim++) {    \n          queryMin[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMin[dim]);\n          queryMax[dim] = new byte[numBytesPerDim];\n          random().nextBytes(queryMax[dim]);\n          if (FutureArrays.compareUnsigned(queryMin[dim], 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n            byte[] x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                if (FutureArrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    FutureArrays.compareUnsigned(packedValue, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                if (FutureArrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                    FutureArrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (FutureArrays.compareUnsigned(minPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                           FutureArrays.compareUnsigned(maxPacked, dim * numBytesPerDim, dim * numBytesPerDim + numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        BitSet expected = new BitSet();\n        for(int ord=0;ord<numValues;ord++) {\n          boolean matches = true;\n          for(int dim=0;dim<numDims;dim++) {\n            byte[] x = docValues[ord][dim];\n            if (FutureArrays.compareUnsigned(x, 0, numBytesPerDim, queryMin[dim], 0, numBytesPerDim) < 0 ||\n                FutureArrays.compareUnsigned(x, 0, numBytesPerDim, queryMax[dim], 0, numBytesPerDim) > 0) {\n              matches = false;\n              break;\n            }\n          }\n\n          if (matches) {\n            int docID;\n            if (docIDs == null) {\n              docID = ord;\n            } else {\n              docID = docIDs[ord];\n            }\n            expected.set(docID);\n          }\n        }\n\n        int limit = Math.max(expected.length(), hits.length());\n        for(int docID=0;docID<limit;docID++) {\n          assertEquals(\"docID=\" + docID, expected.get(docID), hits.get(docID));\n        }\n      }\n      in.close();\n      dir.deleteFile(\"bkd\");\n      if (toMerge != null) {\n        dir.deleteFile(\"bkd2\");\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        IOUtils.closeWhileHandlingException(w, in, out);\n        IOUtils.deleteFilesIgnoringExceptions(dir, \"bkd\", \"bkd2\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1786be6a11f9cf5e48ce84869d1bb71e9c02f966":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"f6652c943595e92c187ee904c382863013eae28f":["41f60ea1802fda42d3c91d023406066d00ddb5f8"],"1904709ea0185dc04e3d77ea01c79e909caf2796":["ca792c26af46bd6c4a08d81117c60440cf6a7e3d"],"e3ce1ef883d26aa73919aa2d53991726e96caa13":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0ad30c6a479e764150a3316e57263319775f1df2":["f3d902d9e126b838f492796a117a4d9e532d597a","3d33e731a93d4b57e662ff094f64f94a745422d4"],"02b353fc2be5047a3b7223d4f11a2a5fbd3dd86f":["251c5b33f0a2c8988550b63c78ed22b0e84524e5"],"770342641f7b505eaa8dccdc666158bff2419109":["1786be6a11f9cf5e48ce84869d1bb71e9c02f966"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["f3d902d9e126b838f492796a117a4d9e532d597a","d470c8182e92b264680e34081b75e70a9f2b3c89"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["f3d902d9e126b838f492796a117a4d9e532d597a","0ad30c6a479e764150a3316e57263319775f1df2"],"251c5b33f0a2c8988550b63c78ed22b0e84524e5":["12bfdc932307442b651432f92845942f9041ace8"],"12bfdc932307442b651432f92845942f9041ace8":["770342641f7b505eaa8dccdc666158bff2419109"],"84f731d3a83b5ad26ada4066861424b12b21c233":["e3ce1ef883d26aa73919aa2d53991726e96caa13"],"ceaef6cfc68c8ab22a684192e469a8280f9e6e70":["f3d902d9e126b838f492796a117a4d9e532d597a"],"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1":["6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"9a5a0f27d9486cd33de88627ed3d2ff8dc5074ca":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"41f60ea1802fda42d3c91d023406066d00ddb5f8":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"ca792c26af46bd6c4a08d81117c60440cf6a7e3d":["84f731d3a83b5ad26ada4066861424b12b21c233"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"416f9e28900210be57b69bc12e2954fb98ed7ebe":["9a5a0f27d9486cd33de88627ed3d2ff8dc5074ca"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["770342641f7b505eaa8dccdc666158bff2419109"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["770342641f7b505eaa8dccdc666158bff2419109","02b353fc2be5047a3b7223d4f11a2a5fbd3dd86f"],"f3d902d9e126b838f492796a117a4d9e532d597a":["416f9e28900210be57b69bc12e2954fb98ed7ebe"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["f3d902d9e126b838f492796a117a4d9e532d597a","ceaef6cfc68c8ab22a684192e469a8280f9e6e70"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f6652c943595e92c187ee904c382863013eae28f"]},"commit2Childs":{"1786be6a11f9cf5e48ce84869d1bb71e9c02f966":["770342641f7b505eaa8dccdc666158bff2419109"],"f6652c943595e92c187ee904c382863013eae28f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1904709ea0185dc04e3d77ea01c79e909caf2796":["1786be6a11f9cf5e48ce84869d1bb71e9c02f966"],"e3ce1ef883d26aa73919aa2d53991726e96caa13":["84f731d3a83b5ad26ada4066861424b12b21c233"],"0ad30c6a479e764150a3316e57263319775f1df2":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"02b353fc2be5047a3b7223d4f11a2a5fbd3dd86f":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"770342641f7b505eaa8dccdc666158bff2419109":["12bfdc932307442b651432f92845942f9041ace8","6bfe104fc023fadc9e709f8d17403d2cc61133fe","cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","41f60ea1802fda42d3c91d023406066d00ddb5f8"],"251c5b33f0a2c8988550b63c78ed22b0e84524e5":["02b353fc2be5047a3b7223d4f11a2a5fbd3dd86f"],"12bfdc932307442b651432f92845942f9041ace8":["251c5b33f0a2c8988550b63c78ed22b0e84524e5"],"84f731d3a83b5ad26ada4066861424b12b21c233":["ca792c26af46bd6c4a08d81117c60440cf6a7e3d"],"ceaef6cfc68c8ab22a684192e469a8280f9e6e70":["3d33e731a93d4b57e662ff094f64f94a745422d4"],"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1":[],"9a5a0f27d9486cd33de88627ed3d2ff8dc5074ca":["416f9e28900210be57b69bc12e2954fb98ed7ebe"],"41f60ea1802fda42d3c91d023406066d00ddb5f8":["f6652c943595e92c187ee904c382863013eae28f"],"ca792c26af46bd6c4a08d81117c60440cf6a7e3d":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e3ce1ef883d26aa73919aa2d53991726e96caa13"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["8f4e2dcb5e470991d83a63c264bfe20880d3b3c1"],"416f9e28900210be57b69bc12e2954fb98ed7ebe":["f3d902d9e126b838f492796a117a4d9e532d597a"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["9a5a0f27d9486cd33de88627ed3d2ff8dc5074ca"],"f3d902d9e126b838f492796a117a4d9e532d597a":["0ad30c6a479e764150a3316e57263319775f1df2","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","ceaef6cfc68c8ab22a684192e469a8280f9e6e70","3d33e731a93d4b57e662ff094f64f94a745422d4"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["0ad30c6a479e764150a3316e57263319775f1df2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","8f4e2dcb5e470991d83a63c264bfe20880d3b3c1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}