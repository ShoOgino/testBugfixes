{"path":"solr/core/src/java/org/apache/solr/response/transform/ChildDocTransformer[ChildDocTransformerFactory]#transform(SolrDocument,int).mjava","commits":[{"id":"9a862f08ffeb00b03b4c641de86b167b1d6f7cd1","date":1402094642,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/transform/ChildDocTransformer[ChildDocTransformerFactory]#transform(SolrDocument,int).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void transform(SolrDocument doc, int docid) {\n\n    String parentId;\n    Object parentIdField = doc.get(idField);\n    if (parentIdField instanceof StoredField) {\n      parentId = ((StoredField) parentIdField).stringValue();\n    } else if (parentIdField instanceof Field){\n      parentId = ((Field) parentIdField).stringValue();\n      if(parentId == null) {\n        parentId = ((Field) parentIdField).binaryValue().utf8ToString();\n      }\n    } else {\n      parentId = (String) parentIdField;\n    }\n\n    try {\n      Query parentQuery = new TermQuery(new Term(idField, schema.getFieldType(idField).readableToIndexed(parentId)));\n      Query query = new ToChildBlockJoinQuery(parentQuery, parentsFilter, false);\n      DocList children = context.searcher.getDocList(query, childFilterQuery, new Sort(), 0, limit);\n      if(children.matches() > 0) {\n        DocIterator i = children.iterator();\n        while(i.hasNext()) {\n          Integer childDocNum = i.next();\n          StoredDocument childDoc = context.searcher.doc(childDocNum);\n          SolrDocument solrChildDoc = ResponseWriterUtil.toSolrDocument(childDoc, schema);\n\n          // TODO: future enhancement...\n          // support an fl local param in the transformer, which is used to build\n          // a private ReturnFields instance that we use to prune unwanted field \n          // names from solrChildDoc\n          doc.addChildDocument(solrChildDoc);\n        }\n      }\n      \n    } catch (IOException e) {\n      doc.put(name, \"Could not fetch child Documents\");\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["b5d3613911d665344055ef7970e1783b3348b5c0","b5d3613911d665344055ef7970e1783b3348b5c0","b5d3613911d665344055ef7970e1783b3348b5c0","b5d3613911d665344055ef7970e1783b3348b5c0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"efbabb5fe919f9ebda7f487692e57506bc3246f8","date":1402102128,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/transform/ChildDocTransformer[ChildDocTransformerFactory]#transform(SolrDocument,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/transform/ChildDocTransformer[ChildDocTransformerFactory]#transform(SolrDocument,int).mjava","sourceNew":"  @Override\n  public void transform(SolrDocument doc, int docid) {\n\n    FieldType idFt = idField.getType();\n    Object parentIdField = doc.getFirstValue(idField.getName());\n    \n    String parentIdExt = parentIdField instanceof StorableField\n      ? idFt.toExternal((StorableField)parentIdField)\n      : parentIdField.toString();\n\n    try {\n      Query parentQuery = idFt.getFieldQuery(null, idField, parentIdExt);\n      Query query = new ToChildBlockJoinQuery(parentQuery, parentsFilter, false);\n      DocList children = context.searcher.getDocList(query, childFilterQuery, new Sort(), 0, limit);\n      if(children.matches() > 0) {\n        DocIterator i = children.iterator();\n        while(i.hasNext()) {\n          Integer childDocNum = i.next();\n          StoredDocument childDoc = context.searcher.doc(childDocNum);\n          SolrDocument solrChildDoc = ResponseWriterUtil.toSolrDocument(childDoc, schema);\n\n          // TODO: future enhancement...\n          // support an fl local param in the transformer, which is used to build\n          // a private ReturnFields instance that we use to prune unwanted field \n          // names from solrChildDoc\n          doc.addChildDocument(solrChildDoc);\n        }\n      }\n      \n    } catch (IOException e) {\n      doc.put(name, \"Could not fetch child Documents\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void transform(SolrDocument doc, int docid) {\n\n    String parentId;\n    Object parentIdField = doc.get(idField);\n    if (parentIdField instanceof StoredField) {\n      parentId = ((StoredField) parentIdField).stringValue();\n    } else if (parentIdField instanceof Field){\n      parentId = ((Field) parentIdField).stringValue();\n      if(parentId == null) {\n        parentId = ((Field) parentIdField).binaryValue().utf8ToString();\n      }\n    } else {\n      parentId = (String) parentIdField;\n    }\n\n    try {\n      Query parentQuery = new TermQuery(new Term(idField, schema.getFieldType(idField).readableToIndexed(parentId)));\n      Query query = new ToChildBlockJoinQuery(parentQuery, parentsFilter, false);\n      DocList children = context.searcher.getDocList(query, childFilterQuery, new Sort(), 0, limit);\n      if(children.matches() > 0) {\n        DocIterator i = children.iterator();\n        while(i.hasNext()) {\n          Integer childDocNum = i.next();\n          StoredDocument childDoc = context.searcher.doc(childDocNum);\n          SolrDocument solrChildDoc = ResponseWriterUtil.toSolrDocument(childDoc, schema);\n\n          // TODO: future enhancement...\n          // support an fl local param in the transformer, which is used to build\n          // a private ReturnFields instance that we use to prune unwanted field \n          // names from solrChildDoc\n          doc.addChildDocument(solrChildDoc);\n        }\n      }\n      \n    } catch (IOException e) {\n      doc.put(name, \"Could not fetch child Documents\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fb17639909a369c1e64866842e5c213440acc17e","date":1423238093,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/transform/ChildDocTransformer[ChildDocTransformerFactory]#transform(SolrDocument,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/transform/ChildDocTransformer[ChildDocTransformerFactory]#transform(SolrDocument,int).mjava","sourceNew":"  @Override\n  public void transform(SolrDocument doc, int docid) {\n\n    FieldType idFt = idField.getType();\n    Object parentIdField = doc.getFirstValue(idField.getName());\n    \n    String parentIdExt = parentIdField instanceof StorableField\n      ? idFt.toExternal((StorableField)parentIdField)\n      : parentIdField.toString();\n\n    try {\n      Query parentQuery = idFt.getFieldQuery(null, idField, parentIdExt);\n      Query query = new ToChildBlockJoinQuery(parentQuery, parentsFilter);\n      DocList children = context.searcher.getDocList(query, childFilterQuery, new Sort(), 0, limit);\n      if(children.matches() > 0) {\n        DocIterator i = children.iterator();\n        while(i.hasNext()) {\n          Integer childDocNum = i.next();\n          StoredDocument childDoc = context.searcher.doc(childDocNum);\n          SolrDocument solrChildDoc = ResponseWriterUtil.toSolrDocument(childDoc, schema);\n\n          // TODO: future enhancement...\n          // support an fl local param in the transformer, which is used to build\n          // a private ReturnFields instance that we use to prune unwanted field \n          // names from solrChildDoc\n          doc.addChildDocument(solrChildDoc);\n        }\n      }\n      \n    } catch (IOException e) {\n      doc.put(name, \"Could not fetch child Documents\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void transform(SolrDocument doc, int docid) {\n\n    FieldType idFt = idField.getType();\n    Object parentIdField = doc.getFirstValue(idField.getName());\n    \n    String parentIdExt = parentIdField instanceof StorableField\n      ? idFt.toExternal((StorableField)parentIdField)\n      : parentIdField.toString();\n\n    try {\n      Query parentQuery = idFt.getFieldQuery(null, idField, parentIdExt);\n      Query query = new ToChildBlockJoinQuery(parentQuery, parentsFilter, false);\n      DocList children = context.searcher.getDocList(query, childFilterQuery, new Sort(), 0, limit);\n      if(children.matches() > 0) {\n        DocIterator i = children.iterator();\n        while(i.hasNext()) {\n          Integer childDocNum = i.next();\n          StoredDocument childDoc = context.searcher.doc(childDocNum);\n          SolrDocument solrChildDoc = ResponseWriterUtil.toSolrDocument(childDoc, schema);\n\n          // TODO: future enhancement...\n          // support an fl local param in the transformer, which is used to build\n          // a private ReturnFields instance that we use to prune unwanted field \n          // names from solrChildDoc\n          doc.addChildDocument(solrChildDoc);\n        }\n      }\n      \n    } catch (IOException e) {\n      doc.put(name, \"Could not fetch child Documents\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b263a3dc926f93ae0dadfc542cdcaa2f8c5a95c9","date":1434467834,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/transform/ChildDocTransformer[ChildDocTransformerFactory]#transform(SolrDocument,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/transform/ChildDocTransformer[ChildDocTransformerFactory]#transform(SolrDocument,int).mjava","sourceNew":"  @Override\n  public void transform(SolrDocument doc, int docid) {\n\n    FieldType idFt = idField.getType();\n    Object parentIdField = doc.getFirstValue(idField.getName());\n    \n    String parentIdExt = parentIdField instanceof StorableField\n      ? idFt.toExternal((StorableField)parentIdField)\n      : parentIdField.toString();\n\n    try {\n      Query parentQuery = idFt.getFieldQuery(null, idField, parentIdExt);\n      Query query = new ToChildBlockJoinQuery(parentQuery, parentsFilter);\n      DocList children = context.searcher.getDocList(query, childFilterQuery, new Sort(), 0, limit);\n      if(children.matches() > 0) {\n        DocIterator i = children.iterator();\n        while(i.hasNext()) {\n          Integer childDocNum = i.next();\n          StoredDocument childDoc = context.searcher.doc(childDocNum);\n          SolrDocument solrChildDoc = DocsStreamer.getDoc(childDoc, schema);\n\n          // TODO: future enhancement...\n          // support an fl local param in the transformer, which is used to build\n          // a private ReturnFields instance that we use to prune unwanted field \n          // names from solrChildDoc\n          doc.addChildDocument(solrChildDoc);\n        }\n      }\n      \n    } catch (IOException e) {\n      doc.put(name, \"Could not fetch child Documents\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void transform(SolrDocument doc, int docid) {\n\n    FieldType idFt = idField.getType();\n    Object parentIdField = doc.getFirstValue(idField.getName());\n    \n    String parentIdExt = parentIdField instanceof StorableField\n      ? idFt.toExternal((StorableField)parentIdField)\n      : parentIdField.toString();\n\n    try {\n      Query parentQuery = idFt.getFieldQuery(null, idField, parentIdExt);\n      Query query = new ToChildBlockJoinQuery(parentQuery, parentsFilter);\n      DocList children = context.searcher.getDocList(query, childFilterQuery, new Sort(), 0, limit);\n      if(children.matches() > 0) {\n        DocIterator i = children.iterator();\n        while(i.hasNext()) {\n          Integer childDocNum = i.next();\n          StoredDocument childDoc = context.searcher.doc(childDocNum);\n          SolrDocument solrChildDoc = ResponseWriterUtil.toSolrDocument(childDoc, schema);\n\n          // TODO: future enhancement...\n          // support an fl local param in the transformer, which is used to build\n          // a private ReturnFields instance that we use to prune unwanted field \n          // names from solrChildDoc\n          doc.addChildDocument(solrChildDoc);\n        }\n      }\n      \n    } catch (IOException e) {\n      doc.put(name, \"Could not fetch child Documents\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7b8f0dc1dfedc7fda86aefc0cdabde0efae2d1dc","date":1440797084,"type":5,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/transform/ChildDocTransformer[ChildDocTransformerFactory]#transform(SolrDocument,int,float).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/transform/ChildDocTransformer[ChildDocTransformerFactory]#transform(SolrDocument,int).mjava","sourceNew":"  @Override\n  public void transform(SolrDocument doc, int docid, float score) {\n\n    FieldType idFt = idField.getType();\n    Object parentIdField = doc.getFirstValue(idField.getName());\n    \n    String parentIdExt = parentIdField instanceof StorableField\n      ? idFt.toExternal((StorableField)parentIdField)\n      : parentIdField.toString();\n\n    try {\n      Query parentQuery = idFt.getFieldQuery(null, idField, parentIdExt);\n      Query query = new ToChildBlockJoinQuery(parentQuery, parentsFilter);\n      DocList children = context.getSearcher().getDocList(query, childFilterQuery, new Sort(), 0, limit);\n      if(children.matches() > 0) {\n        DocIterator i = children.iterator();\n        while(i.hasNext()) {\n          Integer childDocNum = i.next();\n          StoredDocument childDoc = context.getSearcher().doc(childDocNum);\n          SolrDocument solrChildDoc = DocsStreamer.getDoc(childDoc, schema);\n\n          // TODO: future enhancement...\n          // support an fl local param in the transformer, which is used to build\n          // a private ReturnFields instance that we use to prune unwanted field \n          // names from solrChildDoc\n          doc.addChildDocument(solrChildDoc);\n        }\n      }\n      \n    } catch (IOException e) {\n      doc.put(name, \"Could not fetch child Documents\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void transform(SolrDocument doc, int docid) {\n\n    FieldType idFt = idField.getType();\n    Object parentIdField = doc.getFirstValue(idField.getName());\n    \n    String parentIdExt = parentIdField instanceof StorableField\n      ? idFt.toExternal((StorableField)parentIdField)\n      : parentIdField.toString();\n\n    try {\n      Query parentQuery = idFt.getFieldQuery(null, idField, parentIdExt);\n      Query query = new ToChildBlockJoinQuery(parentQuery, parentsFilter);\n      DocList children = context.searcher.getDocList(query, childFilterQuery, new Sort(), 0, limit);\n      if(children.matches() > 0) {\n        DocIterator i = children.iterator();\n        while(i.hasNext()) {\n          Integer childDocNum = i.next();\n          StoredDocument childDoc = context.searcher.doc(childDocNum);\n          SolrDocument solrChildDoc = DocsStreamer.getDoc(childDoc, schema);\n\n          // TODO: future enhancement...\n          // support an fl local param in the transformer, which is used to build\n          // a private ReturnFields instance that we use to prune unwanted field \n          // names from solrChildDoc\n          doc.addChildDocument(solrChildDoc);\n        }\n      }\n      \n    } catch (IOException e) {\n      doc.put(name, \"Could not fetch child Documents\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"320eec6599df6f97f2461a5d1ad49cd93b324a14","date":1503502574,"type":1,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/transform/ChildDocTransformer[ChildDocTransformerFactory]#transform(SolrDocument,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/transform/ChildDocTransformer[ChildDocTransformerFactory]#transform(SolrDocument,int,float).mjava","sourceNew":"  @Override\n  public void transform(SolrDocument doc, int docid) {\n\n    FieldType idFt = idField.getType();\n    Object parentIdField = doc.getFirstValue(idField.getName());\n    \n    String parentIdExt = parentIdField instanceof IndexableField\n      ? idFt.toExternal((IndexableField)parentIdField)\n      : parentIdField.toString();\n\n    try {\n      Query parentQuery = idFt.getFieldQuery(null, idField, parentIdExt);\n      Query query = new ToChildBlockJoinQuery(parentQuery, parentsFilter);\n      DocList children = context.getSearcher().getDocList(query, childFilterQuery, new Sort(), 0, limit);\n      if(children.matches() > 0) {\n        SolrDocumentFetcher docFetcher = context.getSearcher().getDocFetcher();\n\n        Set<String> dvFieldsToReturn = docFetcher.getNonStoredDVs(true);\n        boolean shouldDecorateWithDVs = dvFieldsToReturn.size() > 0;\n        DocIterator i = children.iterator();\n\n        while(i.hasNext()) {\n          Integer childDocNum = i.next();\n          Document childDoc = context.getSearcher().doc(childDocNum);\n          SolrDocument solrChildDoc = DocsStreamer.convertLuceneDocToSolrDoc(childDoc, schema);\n\n          if (shouldDecorateWithDVs) {\n            docFetcher.decorateDocValueFields(solrChildDoc, childDocNum, dvFieldsToReturn);\n          }\n\n          // TODO: future enhancement...\n          // support an fl local param in the transformer, which is used to build\n          // a private ReturnFields instance that we use to prune unwanted field \n          // names from solrChildDoc\n          doc.addChildDocument(solrChildDoc);\n        }\n      }\n      \n    } catch (IOException e) {\n      doc.put(name, \"Could not fetch child Documents\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void transform(SolrDocument doc, int docid, float score) {\n\n    FieldType idFt = idField.getType();\n    Object parentIdField = doc.getFirstValue(idField.getName());\n    \n    String parentIdExt = parentIdField instanceof IndexableField\n      ? idFt.toExternal((IndexableField)parentIdField)\n      : parentIdField.toString();\n\n    try {\n      Query parentQuery = idFt.getFieldQuery(null, idField, parentIdExt);\n      Query query = new ToChildBlockJoinQuery(parentQuery, parentsFilter);\n      DocList children = context.getSearcher().getDocList(query, childFilterQuery, new Sort(), 0, limit);\n      if(children.matches() > 0) {\n        SolrDocumentFetcher docFetcher = context.getSearcher().getDocFetcher();\n\n        Set<String> dvFieldsToReturn = docFetcher.getNonStoredDVs(true);\n        boolean shouldDecorateWithDVs = dvFieldsToReturn.size() > 0;\n        DocIterator i = children.iterator();\n\n        while(i.hasNext()) {\n          Integer childDocNum = i.next();\n          Document childDoc = context.getSearcher().doc(childDocNum);\n          SolrDocument solrChildDoc = DocsStreamer.convertLuceneDocToSolrDoc(childDoc, schema);\n\n          if (shouldDecorateWithDVs) {\n            docFetcher.decorateDocValueFields(solrChildDoc, childDocNum, dvFieldsToReturn);\n          }\n\n          // TODO: future enhancement...\n          // support an fl local param in the transformer, which is used to build\n          // a private ReturnFields instance that we use to prune unwanted field \n          // names from solrChildDoc\n          doc.addChildDocument(solrChildDoc);\n        }\n      }\n      \n    } catch (IOException e) {\n      doc.put(name, \"Could not fetch child Documents\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"182384b20c064aa16998ddebe9f36e649279c5a6","date":1503596494,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/response/transform/ChildDocTransformer[ChildDocTransformerFactory]#transform(SolrDocument,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/transform/ChildDocTransformer[ChildDocTransformerFactory]#transform(SolrDocument,int,float).mjava","sourceNew":"  @Override\n  public void transform(SolrDocument doc, int docid) {\n\n    FieldType idFt = idField.getType();\n    Object parentIdField = doc.getFirstValue(idField.getName());\n    \n    String parentIdExt = parentIdField instanceof IndexableField\n      ? idFt.toExternal((IndexableField)parentIdField)\n      : parentIdField.toString();\n\n    try {\n      Query parentQuery = idFt.getFieldQuery(null, idField, parentIdExt);\n      Query query = new ToChildBlockJoinQuery(parentQuery, parentsFilter);\n      DocList children = context.getSearcher().getDocList(query, childFilterQuery, new Sort(), 0, limit);\n      if(children.matches() > 0) {\n        SolrDocumentFetcher docFetcher = context.getSearcher().getDocFetcher();\n\n        Set<String> dvFieldsToReturn = docFetcher.getNonStoredDVs(true);\n        boolean shouldDecorateWithDVs = dvFieldsToReturn.size() > 0;\n        DocIterator i = children.iterator();\n\n        while(i.hasNext()) {\n          Integer childDocNum = i.next();\n          Document childDoc = context.getSearcher().doc(childDocNum);\n          SolrDocument solrChildDoc = DocsStreamer.convertLuceneDocToSolrDoc(childDoc, schema);\n\n          if (shouldDecorateWithDVs) {\n            docFetcher.decorateDocValueFields(solrChildDoc, childDocNum, dvFieldsToReturn);\n          }\n\n          // TODO: future enhancement...\n          // support an fl local param in the transformer, which is used to build\n          // a private ReturnFields instance that we use to prune unwanted field \n          // names from solrChildDoc\n          doc.addChildDocument(solrChildDoc);\n        }\n      }\n      \n    } catch (IOException e) {\n      doc.put(name, \"Could not fetch child Documents\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void transform(SolrDocument doc, int docid, float score) {\n\n    FieldType idFt = idField.getType();\n    Object parentIdField = doc.getFirstValue(idField.getName());\n    \n    String parentIdExt = parentIdField instanceof IndexableField\n      ? idFt.toExternal((IndexableField)parentIdField)\n      : parentIdField.toString();\n\n    try {\n      Query parentQuery = idFt.getFieldQuery(null, idField, parentIdExt);\n      Query query = new ToChildBlockJoinQuery(parentQuery, parentsFilter);\n      DocList children = context.getSearcher().getDocList(query, childFilterQuery, new Sort(), 0, limit);\n      if(children.matches() > 0) {\n        SolrDocumentFetcher docFetcher = context.getSearcher().getDocFetcher();\n\n        Set<String> dvFieldsToReturn = docFetcher.getNonStoredDVs(true);\n        boolean shouldDecorateWithDVs = dvFieldsToReturn.size() > 0;\n        DocIterator i = children.iterator();\n\n        while(i.hasNext()) {\n          Integer childDocNum = i.next();\n          Document childDoc = context.getSearcher().doc(childDocNum);\n          SolrDocument solrChildDoc = DocsStreamer.convertLuceneDocToSolrDoc(childDoc, schema);\n\n          if (shouldDecorateWithDVs) {\n            docFetcher.decorateDocValueFields(solrChildDoc, childDocNum, dvFieldsToReturn);\n          }\n\n          // TODO: future enhancement...\n          // support an fl local param in the transformer, which is used to build\n          // a private ReturnFields instance that we use to prune unwanted field \n          // names from solrChildDoc\n          doc.addChildDocument(solrChildDoc);\n        }\n      }\n      \n    } catch (IOException e) {\n      doc.put(name, \"Could not fetch child Documents\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a7809d1d753b67f48b1a706e17034bf8b624ea3","date":1504366927,"type":1,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/response/transform/ChildDocTransformer[ChildDocTransformerFactory]#transform(SolrDocument,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/transform/ChildDocTransformer[ChildDocTransformerFactory]#transform(SolrDocument,int,float).mjava","sourceNew":"  @Override\n  public void transform(SolrDocument doc, int docid) {\n\n    FieldType idFt = idField.getType();\n    Object parentIdField = doc.getFirstValue(idField.getName());\n    \n    String parentIdExt = parentIdField instanceof IndexableField\n      ? idFt.toExternal((IndexableField)parentIdField)\n      : parentIdField.toString();\n\n    try {\n      Query parentQuery = idFt.getFieldQuery(null, idField, parentIdExt);\n      Query query = new ToChildBlockJoinQuery(parentQuery, parentsFilter);\n      DocList children = context.getSearcher().getDocList(query, childFilterQuery, new Sort(), 0, limit);\n      if(children.matches() > 0) {\n        SolrDocumentFetcher docFetcher = context.getSearcher().getDocFetcher();\n\n        Set<String> dvFieldsToReturn = docFetcher.getNonStoredDVs(true);\n        boolean shouldDecorateWithDVs = dvFieldsToReturn.size() > 0;\n        DocIterator i = children.iterator();\n\n        while(i.hasNext()) {\n          Integer childDocNum = i.next();\n          Document childDoc = context.getSearcher().doc(childDocNum);\n          SolrDocument solrChildDoc = DocsStreamer.convertLuceneDocToSolrDoc(childDoc, schema);\n\n          if (shouldDecorateWithDVs) {\n            docFetcher.decorateDocValueFields(solrChildDoc, childDocNum, dvFieldsToReturn);\n          }\n\n          // TODO: future enhancement...\n          // support an fl local param in the transformer, which is used to build\n          // a private ReturnFields instance that we use to prune unwanted field \n          // names from solrChildDoc\n          doc.addChildDocument(solrChildDoc);\n        }\n      }\n      \n    } catch (IOException e) {\n      doc.put(name, \"Could not fetch child Documents\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void transform(SolrDocument doc, int docid, float score) {\n\n    FieldType idFt = idField.getType();\n    Object parentIdField = doc.getFirstValue(idField.getName());\n    \n    String parentIdExt = parentIdField instanceof IndexableField\n      ? idFt.toExternal((IndexableField)parentIdField)\n      : parentIdField.toString();\n\n    try {\n      Query parentQuery = idFt.getFieldQuery(null, idField, parentIdExt);\n      Query query = new ToChildBlockJoinQuery(parentQuery, parentsFilter);\n      DocList children = context.getSearcher().getDocList(query, childFilterQuery, new Sort(), 0, limit);\n      if(children.matches() > 0) {\n        SolrDocumentFetcher docFetcher = context.getSearcher().getDocFetcher();\n\n        Set<String> dvFieldsToReturn = docFetcher.getNonStoredDVs(true);\n        boolean shouldDecorateWithDVs = dvFieldsToReturn.size() > 0;\n        DocIterator i = children.iterator();\n\n        while(i.hasNext()) {\n          Integer childDocNum = i.next();\n          Document childDoc = context.getSearcher().doc(childDocNum);\n          SolrDocument solrChildDoc = DocsStreamer.convertLuceneDocToSolrDoc(childDoc, schema);\n\n          if (shouldDecorateWithDVs) {\n            docFetcher.decorateDocValueFields(solrChildDoc, childDocNum, dvFieldsToReturn);\n          }\n\n          // TODO: future enhancement...\n          // support an fl local param in the transformer, which is used to build\n          // a private ReturnFields instance that we use to prune unwanted field \n          // names from solrChildDoc\n          doc.addChildDocument(solrChildDoc);\n        }\n      }\n      \n    } catch (IOException e) {\n      doc.put(name, \"Could not fetch child Documents\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b5d3613911d665344055ef7970e1783b3348b5c0","date":1521487734,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/response/transform/ChildDocTransformer[ChildDocTransformerFactory]#transform(SolrDocument,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/response/transform/ChildDocTransformer[ChildDocTransformerFactory]#transform(SolrDocument,int).mjava","sourceNew":"  @Override\n  public void transform(SolrDocument doc, int docid) {\n\n    FieldType idFt = idField.getType();\n    Object parentIdField = doc.getFirstValue(idField.getName());\n    \n    String parentIdExt = parentIdField instanceof IndexableField\n      ? idFt.toExternal((IndexableField)parentIdField)\n      : parentIdField.toString();\n\n    try {\n      Query parentQuery = idFt.getFieldQuery(null, idField, parentIdExt);\n      Query query = new ToChildBlockJoinQuery(parentQuery, parentsFilter);\n      DocList children = context.getSearcher().getDocList(query, childFilterQuery, new Sort(), 0, limit);\n      if(children.matches() > 0) {\n        SolrDocumentFetcher docFetcher = context.getSearcher().getDocFetcher();\n\n        Set<String> dvFieldsToReturn = docFetcher.getNonStoredDVs(true);\n        boolean shouldDecorateWithDVs = dvFieldsToReturn.size() > 0;\n        DocIterator i = children.iterator();\n\n        while(i.hasNext()) {\n          Integer childDocNum = i.next();\n          Document childDoc = context.getSearcher().doc(childDocNum);\n          // TODO: future enhancement...\n          // support an fl local param in the transformer, which is used to build\n          // a private ReturnFields instance that we use to prune unwanted field \n          // names from solrChildDoc\n          SolrDocument solrChildDoc = DocsStreamer.convertLuceneDocToSolrDoc(childDoc, schema,\n                                                                             new SolrReturnFields());\n\n          if (shouldDecorateWithDVs) {\n            docFetcher.decorateDocValueFields(solrChildDoc, childDocNum, dvFieldsToReturn);\n          }\n          doc.addChildDocument(solrChildDoc);\n        }\n      }\n      \n    } catch (IOException e) {\n      doc.put(name, \"Could not fetch child Documents\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void transform(SolrDocument doc, int docid) {\n\n    FieldType idFt = idField.getType();\n    Object parentIdField = doc.getFirstValue(idField.getName());\n    \n    String parentIdExt = parentIdField instanceof IndexableField\n      ? idFt.toExternal((IndexableField)parentIdField)\n      : parentIdField.toString();\n\n    try {\n      Query parentQuery = idFt.getFieldQuery(null, idField, parentIdExt);\n      Query query = new ToChildBlockJoinQuery(parentQuery, parentsFilter);\n      DocList children = context.getSearcher().getDocList(query, childFilterQuery, new Sort(), 0, limit);\n      if(children.matches() > 0) {\n        SolrDocumentFetcher docFetcher = context.getSearcher().getDocFetcher();\n\n        Set<String> dvFieldsToReturn = docFetcher.getNonStoredDVs(true);\n        boolean shouldDecorateWithDVs = dvFieldsToReturn.size() > 0;\n        DocIterator i = children.iterator();\n\n        while(i.hasNext()) {\n          Integer childDocNum = i.next();\n          Document childDoc = context.getSearcher().doc(childDocNum);\n          SolrDocument solrChildDoc = DocsStreamer.convertLuceneDocToSolrDoc(childDoc, schema);\n\n          if (shouldDecorateWithDVs) {\n            docFetcher.decorateDocValueFields(solrChildDoc, childDocNum, dvFieldsToReturn);\n          }\n\n          // TODO: future enhancement...\n          // support an fl local param in the transformer, which is used to build\n          // a private ReturnFields instance that we use to prune unwanted field \n          // names from solrChildDoc\n          doc.addChildDocument(solrChildDoc);\n        }\n      }\n      \n    } catch (IOException e) {\n      doc.put(name, \"Could not fetch child Documents\");\n    }\n  }\n\n","bugFix":["29397a0f9fc4ed10ca165fd668636b82d2041b5f","63a9344cff6a72bc4c1ef080c69e10ad0635b811","9a862f08ffeb00b03b4c641de86b167b1d6f7cd1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"44e1477dd67ee1fbc72871f23fb51369bb42cadd","date":1535551329,"type":4,"author":"David Smiley","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/response/transform/ChildDocTransformer[ChildDocTransformerFactory]#transform(SolrDocument,int).mjava","sourceNew":null,"sourceOld":"  @Override\n  public void transform(SolrDocument doc, int docid) {\n\n    FieldType idFt = idField.getType();\n    Object parentIdField = doc.getFirstValue(idField.getName());\n    \n    String parentIdExt = parentIdField instanceof IndexableField\n      ? idFt.toExternal((IndexableField)parentIdField)\n      : parentIdField.toString();\n\n    try {\n      Query parentQuery = idFt.getFieldQuery(null, idField, parentIdExt);\n      Query query = new ToChildBlockJoinQuery(parentQuery, parentsFilter);\n      DocList children = context.getSearcher().getDocList(query, childFilterQuery, new Sort(), 0, limit);\n      if(children.matches() > 0) {\n        SolrDocumentFetcher docFetcher = context.getSearcher().getDocFetcher();\n\n        Set<String> dvFieldsToReturn = docFetcher.getNonStoredDVs(true);\n        boolean shouldDecorateWithDVs = dvFieldsToReturn.size() > 0;\n        DocIterator i = children.iterator();\n\n        while(i.hasNext()) {\n          Integer childDocNum = i.next();\n          Document childDoc = context.getSearcher().doc(childDocNum);\n          // TODO: future enhancement...\n          // support an fl local param in the transformer, which is used to build\n          // a private ReturnFields instance that we use to prune unwanted field \n          // names from solrChildDoc\n          SolrDocument solrChildDoc = DocsStreamer.convertLuceneDocToSolrDoc(childDoc, schema,\n                                                                             new SolrReturnFields());\n\n          if (shouldDecorateWithDVs) {\n            docFetcher.decorateDocValueFields(solrChildDoc, childDocNum, dvFieldsToReturn);\n          }\n          doc.addChildDocument(solrChildDoc);\n        }\n      }\n      \n    } catch (IOException e) {\n      doc.put(name, \"Could not fetch child Documents\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b5d3613911d665344055ef7970e1783b3348b5c0":["182384b20c064aa16998ddebe9f36e649279c5a6"],"fb17639909a369c1e64866842e5c213440acc17e":["efbabb5fe919f9ebda7f487692e57506bc3246f8"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":["7b8f0dc1dfedc7fda86aefc0cdabde0efae2d1dc","182384b20c064aa16998ddebe9f36e649279c5a6"],"320eec6599df6f97f2461a5d1ad49cd93b324a14":["7b8f0dc1dfedc7fda86aefc0cdabde0efae2d1dc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"182384b20c064aa16998ddebe9f36e649279c5a6":["7b8f0dc1dfedc7fda86aefc0cdabde0efae2d1dc","320eec6599df6f97f2461a5d1ad49cd93b324a14"],"efbabb5fe919f9ebda7f487692e57506bc3246f8":["9a862f08ffeb00b03b4c641de86b167b1d6f7cd1"],"9a862f08ffeb00b03b4c641de86b167b1d6f7cd1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7b8f0dc1dfedc7fda86aefc0cdabde0efae2d1dc":["b263a3dc926f93ae0dadfc542cdcaa2f8c5a95c9"],"44e1477dd67ee1fbc72871f23fb51369bb42cadd":["b5d3613911d665344055ef7970e1783b3348b5c0"],"b263a3dc926f93ae0dadfc542cdcaa2f8c5a95c9":["fb17639909a369c1e64866842e5c213440acc17e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["44e1477dd67ee1fbc72871f23fb51369bb42cadd"]},"commit2Childs":{"b5d3613911d665344055ef7970e1783b3348b5c0":["44e1477dd67ee1fbc72871f23fb51369bb42cadd"],"fb17639909a369c1e64866842e5c213440acc17e":["b263a3dc926f93ae0dadfc542cdcaa2f8c5a95c9"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":[],"320eec6599df6f97f2461a5d1ad49cd93b324a14":["182384b20c064aa16998ddebe9f36e649279c5a6"],"182384b20c064aa16998ddebe9f36e649279c5a6":["b5d3613911d665344055ef7970e1783b3348b5c0","3a7809d1d753b67f48b1a706e17034bf8b624ea3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9a862f08ffeb00b03b4c641de86b167b1d6f7cd1"],"efbabb5fe919f9ebda7f487692e57506bc3246f8":["fb17639909a369c1e64866842e5c213440acc17e"],"9a862f08ffeb00b03b4c641de86b167b1d6f7cd1":["efbabb5fe919f9ebda7f487692e57506bc3246f8"],"7b8f0dc1dfedc7fda86aefc0cdabde0efae2d1dc":["3a7809d1d753b67f48b1a706e17034bf8b624ea3","320eec6599df6f97f2461a5d1ad49cd93b324a14","182384b20c064aa16998ddebe9f36e649279c5a6"],"b263a3dc926f93ae0dadfc542cdcaa2f8c5a95c9":["7b8f0dc1dfedc7fda86aefc0cdabde0efae2d1dc"],"44e1477dd67ee1fbc72871f23fb51369bb42cadd":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3a7809d1d753b67f48b1a706e17034bf8b624ea3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}