{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/io/graph/GatherNodesStream#GatherNodesStream(StreamExpression,StreamFactory).mjava","commits":[{"id":"afdf6ff5b1319d8ae254212f1203a6233ed3e1dc","date":1461010196,"type":0,"author":"jbernste","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/graph/GatherNodesStream#GatherNodesStream(StreamExpression,StreamFactory).mjava","pathOld":"/dev/null","sourceNew":"  public GatherNodesStream(StreamExpression expression, StreamFactory factory) throws IOException {\n\n\n    String collectionName = factory.getValueOperand(expression, 0);\n    List<StreamExpressionNamedParameter> namedParams = factory.getNamedOperands(expression);\n    StreamExpressionNamedParameter zkHostExpression = factory.getNamedOperand(expression, \"zkHost\");\n\n    List<StreamExpression> streamExpressions = factory.getExpressionOperandsRepresentingTypes(expression, Expressible.class, TupleStream.class);\n    // Collection Name\n    if(null == collectionName) {\n      throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - collectionName expected as first operand\",expression));\n    }\n\n\n    Set<Traversal.Scatter> scatter = new HashSet();\n\n    StreamExpressionNamedParameter scatterExpression = factory.getNamedOperand(expression, \"scatter\");\n\n    if(scatterExpression == null) {\n      scatter.add(Traversal.Scatter.LEAVES);\n    } else {\n      String s =  ((StreamExpressionValue)scatterExpression.getParameter()).getValue();\n      String[] sArray = s.split(\",\");\n      for(String sv : sArray) {\n        sv = sv.trim();\n        if(Traversal.Scatter.BRANCHES.toString().equalsIgnoreCase(sv)) {\n          scatter.add(Traversal.Scatter.BRANCHES);\n        } else if (Traversal.Scatter.LEAVES.toString().equalsIgnoreCase(sv)) {\n          scatter.add(Traversal.Scatter.LEAVES);\n        }\n      }\n    }\n\n    String gather = null;\n    StreamExpressionNamedParameter gatherExpression = factory.getNamedOperand(expression, \"gather\");\n\n    if(gatherExpression == null) {\n      throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - from param is required\",expression));\n    } else {\n      gather = ((StreamExpressionValue)gatherExpression.getParameter()).getValue();\n    }\n\n    String traverseFrom = null;\n    String traverseTo = null;\n    StreamExpressionNamedParameter edgeExpression = factory.getNamedOperand(expression, \"walk\");\n\n    TupleStream stream = null;\n\n    if(edgeExpression == null) {\n      throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - walk param is required\", expression));\n    } else {\n      if(streamExpressions.size() > 0) {\n        stream = factory.constructStream(streamExpressions.get(0));\n        String edge = ((StreamExpressionValue) edgeExpression.getParameter()).getValue();\n        String[] fields = edge.split(\"->\");\n        if (fields.length != 2) {\n          throw new IOException(String.format(Locale.ROOT, \"invalid expression %s - walk param separated by an -> and must contain two fields\", expression));\n        }\n        traverseFrom = fields[0].trim();\n        traverseTo = fields[1].trim();\n      } else {\n        String edge = ((StreamExpressionValue) edgeExpression.getParameter()).getValue();\n        String[] fields = edge.split(\"->\");\n        if (fields.length != 2) {\n          throw new IOException(String.format(Locale.ROOT, \"invalid expression %s - walk param separated by an -> and must contain two fields\", expression));\n        }\n\n        String[] rootNodes = fields[0].split(\",\");\n        List<String> l = new ArrayList();\n        for(String n : rootNodes) {\n          l.add(n.trim());\n        }\n\n        stream = new NodeStream(l);\n        traverseFrom = \"node\";\n        traverseTo = fields[1].trim();\n      }\n    }\n\n    List<StreamExpression> metricExpressions = factory.getExpressionOperandsRepresentingTypes(expression, Expressible.class, Metric.class);\n    List<Metric> metrics = new ArrayList();\n    for(int idx = 0; idx < metricExpressions.size(); ++idx){\n      metrics.add(factory.constructMetric(metricExpressions.get(idx)));\n    }\n\n    boolean trackTraversal = false;\n\n    StreamExpressionNamedParameter trackExpression = factory.getNamedOperand(expression, \"trackTraversal\");\n\n    if(trackExpression != null) {\n      trackTraversal = Boolean.parseBoolean(((StreamExpressionValue) trackExpression.getParameter()).getValue());\n    } else {\n      useDefaultTraversal = true;\n    }\n\n    StreamExpressionNamedParameter scopeExpression = factory.getNamedOperand(expression, \"localScope\");\n\n    if(trackExpression != null) {\n      trackTraversal = Boolean.parseBoolean(((StreamExpressionValue) trackExpression.getParameter()).getValue());\n    }\n\n    Map<String,String> params = new HashMap<String,String>();\n    for(StreamExpressionNamedParameter namedParam : namedParams){\n      if(!namedParam.getName().equals(\"zkHost\") &&\n          !namedParam.getName().equals(\"gather\") &&\n          !namedParam.getName().equals(\"walk\") &&\n          !namedParam.getName().equals(\"scatter\") &&\n          !namedParam.getName().equals(\"trackTraversal\"))\n      {\n        params.put(namedParam.getName(), namedParam.getParameter().toString().trim());\n      }\n    }\n\n    // zkHost, optional - if not provided then will look into factory list to get\n    String zkHost = null;\n    if(null == zkHostExpression){\n      zkHost = factory.getCollectionZkHost(collectionName);\n      if(zkHost == null) {\n        zkHost = factory.getDefaultZkHost();\n      }\n    } else if(zkHostExpression.getParameter() instanceof StreamExpressionValue) {\n      zkHost = ((StreamExpressionValue)zkHostExpression.getParameter()).getValue();\n    }\n\n    if(null == zkHost){\n      throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - zkHost not found for collection '%s'\",expression,collectionName));\n    }\n\n    // We've got all the required items\n    init(zkHost,\n         collectionName,\n         stream,\n         traverseFrom,\n         traverseTo ,\n         gather,\n         params,\n         metrics,\n         trackTraversal,\n         scatter);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e15955b4980562a0c1c81d08654904f3fadb83b","date":1461068916,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/graph/GatherNodesStream#GatherNodesStream(StreamExpression,StreamFactory).mjava","pathOld":"/dev/null","sourceNew":"  public GatherNodesStream(StreamExpression expression, StreamFactory factory) throws IOException {\n\n\n    String collectionName = factory.getValueOperand(expression, 0);\n    List<StreamExpressionNamedParameter> namedParams = factory.getNamedOperands(expression);\n    StreamExpressionNamedParameter zkHostExpression = factory.getNamedOperand(expression, \"zkHost\");\n\n    List<StreamExpression> streamExpressions = factory.getExpressionOperandsRepresentingTypes(expression, Expressible.class, TupleStream.class);\n    // Collection Name\n    if(null == collectionName) {\n      throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - collectionName expected as first operand\",expression));\n    }\n\n\n    Set<Traversal.Scatter> scatter = new HashSet();\n\n    StreamExpressionNamedParameter scatterExpression = factory.getNamedOperand(expression, \"scatter\");\n\n    if(scatterExpression == null) {\n      scatter.add(Traversal.Scatter.LEAVES);\n    } else {\n      String s =  ((StreamExpressionValue)scatterExpression.getParameter()).getValue();\n      String[] sArray = s.split(\",\");\n      for(String sv : sArray) {\n        sv = sv.trim();\n        if(Traversal.Scatter.BRANCHES.toString().equalsIgnoreCase(sv)) {\n          scatter.add(Traversal.Scatter.BRANCHES);\n        } else if (Traversal.Scatter.LEAVES.toString().equalsIgnoreCase(sv)) {\n          scatter.add(Traversal.Scatter.LEAVES);\n        }\n      }\n    }\n\n    String gather = null;\n    StreamExpressionNamedParameter gatherExpression = factory.getNamedOperand(expression, \"gather\");\n\n    if(gatherExpression == null) {\n      throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - from param is required\",expression));\n    } else {\n      gather = ((StreamExpressionValue)gatherExpression.getParameter()).getValue();\n    }\n\n    String traverseFrom = null;\n    String traverseTo = null;\n    StreamExpressionNamedParameter edgeExpression = factory.getNamedOperand(expression, \"walk\");\n\n    TupleStream stream = null;\n\n    if(edgeExpression == null) {\n      throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - walk param is required\", expression));\n    } else {\n      if(streamExpressions.size() > 0) {\n        stream = factory.constructStream(streamExpressions.get(0));\n        String edge = ((StreamExpressionValue) edgeExpression.getParameter()).getValue();\n        String[] fields = edge.split(\"->\");\n        if (fields.length != 2) {\n          throw new IOException(String.format(Locale.ROOT, \"invalid expression %s - walk param separated by an -> and must contain two fields\", expression));\n        }\n        traverseFrom = fields[0].trim();\n        traverseTo = fields[1].trim();\n      } else {\n        String edge = ((StreamExpressionValue) edgeExpression.getParameter()).getValue();\n        String[] fields = edge.split(\"->\");\n        if (fields.length != 2) {\n          throw new IOException(String.format(Locale.ROOT, \"invalid expression %s - walk param separated by an -> and must contain two fields\", expression));\n        }\n\n        String[] rootNodes = fields[0].split(\",\");\n        List<String> l = new ArrayList();\n        for(String n : rootNodes) {\n          l.add(n.trim());\n        }\n\n        stream = new NodeStream(l);\n        traverseFrom = \"node\";\n        traverseTo = fields[1].trim();\n      }\n    }\n\n    List<StreamExpression> metricExpressions = factory.getExpressionOperandsRepresentingTypes(expression, Expressible.class, Metric.class);\n    List<Metric> metrics = new ArrayList();\n    for(int idx = 0; idx < metricExpressions.size(); ++idx){\n      metrics.add(factory.constructMetric(metricExpressions.get(idx)));\n    }\n\n    boolean trackTraversal = false;\n\n    StreamExpressionNamedParameter trackExpression = factory.getNamedOperand(expression, \"trackTraversal\");\n\n    if(trackExpression != null) {\n      trackTraversal = Boolean.parseBoolean(((StreamExpressionValue) trackExpression.getParameter()).getValue());\n    } else {\n      useDefaultTraversal = true;\n    }\n\n    StreamExpressionNamedParameter scopeExpression = factory.getNamedOperand(expression, \"localScope\");\n\n    if(trackExpression != null) {\n      trackTraversal = Boolean.parseBoolean(((StreamExpressionValue) trackExpression.getParameter()).getValue());\n    }\n\n    Map<String,String> params = new HashMap<String,String>();\n    for(StreamExpressionNamedParameter namedParam : namedParams){\n      if(!namedParam.getName().equals(\"zkHost\") &&\n          !namedParam.getName().equals(\"gather\") &&\n          !namedParam.getName().equals(\"walk\") &&\n          !namedParam.getName().equals(\"scatter\") &&\n          !namedParam.getName().equals(\"trackTraversal\"))\n      {\n        params.put(namedParam.getName(), namedParam.getParameter().toString().trim());\n      }\n    }\n\n    // zkHost, optional - if not provided then will look into factory list to get\n    String zkHost = null;\n    if(null == zkHostExpression){\n      zkHost = factory.getCollectionZkHost(collectionName);\n      if(zkHost == null) {\n        zkHost = factory.getDefaultZkHost();\n      }\n    } else if(zkHostExpression.getParameter() instanceof StreamExpressionValue) {\n      zkHost = ((StreamExpressionValue)zkHostExpression.getParameter()).getValue();\n    }\n\n    if(null == zkHost){\n      throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - zkHost not found for collection '%s'\",expression,collectionName));\n    }\n\n    // We've got all the required items\n    init(zkHost,\n         collectionName,\n         stream,\n         traverseFrom,\n         traverseTo ,\n         gather,\n         params,\n         metrics,\n         trackTraversal,\n         scatter);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"94ac27a7f2b3e27d17f14b7aeeb3fcd450b7cc96","date":1461702806,"type":3,"author":"jbernste","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/graph/GatherNodesStream#GatherNodesStream(StreamExpression,StreamFactory).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/graph/GatherNodesStream#GatherNodesStream(StreamExpression,StreamFactory).mjava","sourceNew":"  public GatherNodesStream(StreamExpression expression, StreamFactory factory) throws IOException {\n\n\n    String collectionName = factory.getValueOperand(expression, 0);\n    List<StreamExpressionNamedParameter> namedParams = factory.getNamedOperands(expression);\n    StreamExpressionNamedParameter zkHostExpression = factory.getNamedOperand(expression, \"zkHost\");\n\n    List<StreamExpression> streamExpressions = factory.getExpressionOperandsRepresentingTypes(expression, Expressible.class, TupleStream.class);\n    // Collection Name\n    if(null == collectionName) {\n      throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - collectionName expected as first operand\",expression));\n    }\n\n\n    Set<Traversal.Scatter> scatter = new HashSet();\n\n    StreamExpressionNamedParameter scatterExpression = factory.getNamedOperand(expression, \"scatter\");\n\n    if(scatterExpression == null) {\n      scatter.add(Traversal.Scatter.LEAVES);\n    } else {\n      String s =  ((StreamExpressionValue)scatterExpression.getParameter()).getValue();\n      String[] sArray = s.split(\",\");\n      for(String sv : sArray) {\n        sv = sv.trim();\n        if(Traversal.Scatter.BRANCHES.toString().equalsIgnoreCase(sv)) {\n          scatter.add(Traversal.Scatter.BRANCHES);\n        } else if (Traversal.Scatter.LEAVES.toString().equalsIgnoreCase(sv)) {\n          scatter.add(Traversal.Scatter.LEAVES);\n        }\n      }\n    }\n\n    String gather = null;\n    StreamExpressionNamedParameter gatherExpression = factory.getNamedOperand(expression, \"gather\");\n\n    if(gatherExpression == null) {\n      throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - from param is required\",expression));\n    } else {\n      gather = ((StreamExpressionValue)gatherExpression.getParameter()).getValue();\n    }\n\n    String traverseFrom = null;\n    String traverseTo = null;\n    StreamExpressionNamedParameter edgeExpression = factory.getNamedOperand(expression, \"walk\");\n\n    TupleStream stream = null;\n\n    if(edgeExpression == null) {\n      throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - walk param is required\", expression));\n    } else {\n      if(streamExpressions.size() > 0) {\n        stream = factory.constructStream(streamExpressions.get(0));\n        String edge = ((StreamExpressionValue) edgeExpression.getParameter()).getValue();\n        String[] fields = edge.split(\"->\");\n        if (fields.length != 2) {\n          throw new IOException(String.format(Locale.ROOT, \"invalid expression %s - walk param separated by an -> and must contain two fields\", expression));\n        }\n        traverseFrom = fields[0].trim();\n        traverseTo = fields[1].trim();\n      } else {\n        String edge = ((StreamExpressionValue) edgeExpression.getParameter()).getValue();\n        String[] fields = edge.split(\"->\");\n        if (fields.length != 2) {\n          throw new IOException(String.format(Locale.ROOT, \"invalid expression %s - walk param separated by an -> and must contain two fields\", expression));\n        }\n\n        String[] rootNodes = fields[0].split(\",\");\n        List<String> l = new ArrayList();\n        for(String n : rootNodes) {\n          l.add(n.trim());\n        }\n\n        stream = new NodeStream(l);\n        traverseFrom = \"node\";\n        traverseTo = fields[1].trim();\n      }\n    }\n\n    List<StreamExpression> metricExpressions = factory.getExpressionOperandsRepresentingTypes(expression, Expressible.class, Metric.class);\n    List<Metric> metrics = new ArrayList();\n    for(int idx = 0; idx < metricExpressions.size(); ++idx){\n      metrics.add(factory.constructMetric(metricExpressions.get(idx)));\n    }\n\n    boolean trackTraversal = false;\n\n    StreamExpressionNamedParameter trackExpression = factory.getNamedOperand(expression, \"trackTraversal\");\n\n    if(trackExpression != null) {\n      trackTraversal = Boolean.parseBoolean(((StreamExpressionValue) trackExpression.getParameter()).getValue());\n    } else {\n      useDefaultTraversal = true;\n    }\n\n    StreamExpressionNamedParameter docFreqExpression = factory.getNamedOperand(expression, \"maxDocFreq\");\n    int docFreq = -1;\n\n    if(docFreqExpression != null) {\n      docFreq = Integer.parseInt(((StreamExpressionValue) docFreqExpression.getParameter()).getValue());\n    }\n\n    Map<String,String> params = new HashMap<String,String>();\n    for(StreamExpressionNamedParameter namedParam : namedParams){\n      if(!namedParam.getName().equals(\"zkHost\") &&\n          !namedParam.getName().equals(\"gather\") &&\n          !namedParam.getName().equals(\"walk\") &&\n          !namedParam.getName().equals(\"scatter\") &&\n          !namedParam.getName().equals(\"maxDocFreq\") &&\n          !namedParam.getName().equals(\"trackTraversal\"))\n      {\n        params.put(namedParam.getName(), namedParam.getParameter().toString().trim());\n      }\n    }\n\n    // zkHost, optional - if not provided then will look into factory list to get\n    String zkHost = null;\n    if(null == zkHostExpression){\n      zkHost = factory.getCollectionZkHost(collectionName);\n      if(zkHost == null) {\n        zkHost = factory.getDefaultZkHost();\n      }\n    } else if(zkHostExpression.getParameter() instanceof StreamExpressionValue) {\n      zkHost = ((StreamExpressionValue)zkHostExpression.getParameter()).getValue();\n    }\n\n    if(null == zkHost){\n      throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - zkHost not found for collection '%s'\",expression,collectionName));\n    }\n\n    // We've got all the required items\n    init(zkHost,\n         collectionName,\n         stream,\n         traverseFrom,\n         traverseTo ,\n         gather,\n         params,\n         metrics,\n         trackTraversal,\n         scatter,\n         docFreq);\n  }\n\n","sourceOld":"  public GatherNodesStream(StreamExpression expression, StreamFactory factory) throws IOException {\n\n\n    String collectionName = factory.getValueOperand(expression, 0);\n    List<StreamExpressionNamedParameter> namedParams = factory.getNamedOperands(expression);\n    StreamExpressionNamedParameter zkHostExpression = factory.getNamedOperand(expression, \"zkHost\");\n\n    List<StreamExpression> streamExpressions = factory.getExpressionOperandsRepresentingTypes(expression, Expressible.class, TupleStream.class);\n    // Collection Name\n    if(null == collectionName) {\n      throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - collectionName expected as first operand\",expression));\n    }\n\n\n    Set<Traversal.Scatter> scatter = new HashSet();\n\n    StreamExpressionNamedParameter scatterExpression = factory.getNamedOperand(expression, \"scatter\");\n\n    if(scatterExpression == null) {\n      scatter.add(Traversal.Scatter.LEAVES);\n    } else {\n      String s =  ((StreamExpressionValue)scatterExpression.getParameter()).getValue();\n      String[] sArray = s.split(\",\");\n      for(String sv : sArray) {\n        sv = sv.trim();\n        if(Traversal.Scatter.BRANCHES.toString().equalsIgnoreCase(sv)) {\n          scatter.add(Traversal.Scatter.BRANCHES);\n        } else if (Traversal.Scatter.LEAVES.toString().equalsIgnoreCase(sv)) {\n          scatter.add(Traversal.Scatter.LEAVES);\n        }\n      }\n    }\n\n    String gather = null;\n    StreamExpressionNamedParameter gatherExpression = factory.getNamedOperand(expression, \"gather\");\n\n    if(gatherExpression == null) {\n      throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - from param is required\",expression));\n    } else {\n      gather = ((StreamExpressionValue)gatherExpression.getParameter()).getValue();\n    }\n\n    String traverseFrom = null;\n    String traverseTo = null;\n    StreamExpressionNamedParameter edgeExpression = factory.getNamedOperand(expression, \"walk\");\n\n    TupleStream stream = null;\n\n    if(edgeExpression == null) {\n      throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - walk param is required\", expression));\n    } else {\n      if(streamExpressions.size() > 0) {\n        stream = factory.constructStream(streamExpressions.get(0));\n        String edge = ((StreamExpressionValue) edgeExpression.getParameter()).getValue();\n        String[] fields = edge.split(\"->\");\n        if (fields.length != 2) {\n          throw new IOException(String.format(Locale.ROOT, \"invalid expression %s - walk param separated by an -> and must contain two fields\", expression));\n        }\n        traverseFrom = fields[0].trim();\n        traverseTo = fields[1].trim();\n      } else {\n        String edge = ((StreamExpressionValue) edgeExpression.getParameter()).getValue();\n        String[] fields = edge.split(\"->\");\n        if (fields.length != 2) {\n          throw new IOException(String.format(Locale.ROOT, \"invalid expression %s - walk param separated by an -> and must contain two fields\", expression));\n        }\n\n        String[] rootNodes = fields[0].split(\",\");\n        List<String> l = new ArrayList();\n        for(String n : rootNodes) {\n          l.add(n.trim());\n        }\n\n        stream = new NodeStream(l);\n        traverseFrom = \"node\";\n        traverseTo = fields[1].trim();\n      }\n    }\n\n    List<StreamExpression> metricExpressions = factory.getExpressionOperandsRepresentingTypes(expression, Expressible.class, Metric.class);\n    List<Metric> metrics = new ArrayList();\n    for(int idx = 0; idx < metricExpressions.size(); ++idx){\n      metrics.add(factory.constructMetric(metricExpressions.get(idx)));\n    }\n\n    boolean trackTraversal = false;\n\n    StreamExpressionNamedParameter trackExpression = factory.getNamedOperand(expression, \"trackTraversal\");\n\n    if(trackExpression != null) {\n      trackTraversal = Boolean.parseBoolean(((StreamExpressionValue) trackExpression.getParameter()).getValue());\n    } else {\n      useDefaultTraversal = true;\n    }\n\n    StreamExpressionNamedParameter scopeExpression = factory.getNamedOperand(expression, \"localScope\");\n\n    if(trackExpression != null) {\n      trackTraversal = Boolean.parseBoolean(((StreamExpressionValue) trackExpression.getParameter()).getValue());\n    }\n\n    Map<String,String> params = new HashMap<String,String>();\n    for(StreamExpressionNamedParameter namedParam : namedParams){\n      if(!namedParam.getName().equals(\"zkHost\") &&\n          !namedParam.getName().equals(\"gather\") &&\n          !namedParam.getName().equals(\"walk\") &&\n          !namedParam.getName().equals(\"scatter\") &&\n          !namedParam.getName().equals(\"trackTraversal\"))\n      {\n        params.put(namedParam.getName(), namedParam.getParameter().toString().trim());\n      }\n    }\n\n    // zkHost, optional - if not provided then will look into factory list to get\n    String zkHost = null;\n    if(null == zkHostExpression){\n      zkHost = factory.getCollectionZkHost(collectionName);\n      if(zkHost == null) {\n        zkHost = factory.getDefaultZkHost();\n      }\n    } else if(zkHostExpression.getParameter() instanceof StreamExpressionValue) {\n      zkHost = ((StreamExpressionValue)zkHostExpression.getParameter()).getValue();\n    }\n\n    if(null == zkHost){\n      throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - zkHost not found for collection '%s'\",expression,collectionName));\n    }\n\n    // We've got all the required items\n    init(zkHost,\n         collectionName,\n         stream,\n         traverseFrom,\n         traverseTo ,\n         gather,\n         params,\n         metrics,\n         trackTraversal,\n         scatter);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d","date":1592006776,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/graph/GatherNodesStream#GatherNodesStream(StreamExpression,StreamFactory).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/graph/GatherNodesStream#GatherNodesStream(StreamExpression,StreamFactory).mjava","sourceNew":"  public GatherNodesStream(StreamExpression expression, StreamFactory factory) throws IOException {\n\n\n    String collectionName = factory.getValueOperand(expression, 0);\n    List<StreamExpressionNamedParameter> namedParams = factory.getNamedOperands(expression);\n    StreamExpressionNamedParameter zkHostExpression = factory.getNamedOperand(expression, \"zkHost\");\n\n    List<StreamExpression> streamExpressions = factory.getExpressionOperandsRepresentingTypes(expression, Expressible.class, TupleStream.class);\n    // Collection Name\n    if(null == collectionName) {\n      throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - collectionName expected as first operand\",expression));\n    }\n\n\n    Set<Traversal.Scatter> scatter = new HashSet<>();\n\n    StreamExpressionNamedParameter scatterExpression = factory.getNamedOperand(expression, \"scatter\");\n\n    if(scatterExpression == null) {\n      scatter.add(Traversal.Scatter.LEAVES);\n    } else {\n      String s =  ((StreamExpressionValue)scatterExpression.getParameter()).getValue();\n      String[] sArray = s.split(\",\");\n      for(String sv : sArray) {\n        sv = sv.trim();\n        if(Traversal.Scatter.BRANCHES.toString().equalsIgnoreCase(sv)) {\n          scatter.add(Traversal.Scatter.BRANCHES);\n        } else if (Traversal.Scatter.LEAVES.toString().equalsIgnoreCase(sv)) {\n          scatter.add(Traversal.Scatter.LEAVES);\n        }\n      }\n    }\n\n    String gather = null;\n    StreamExpressionNamedParameter gatherExpression = factory.getNamedOperand(expression, \"gather\");\n\n    if(gatherExpression == null) {\n      throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - from param is required\",expression));\n    } else {\n      gather = ((StreamExpressionValue)gatherExpression.getParameter()).getValue();\n    }\n\n    String traverseFrom = null;\n    String traverseTo = null;\n    StreamExpressionNamedParameter edgeExpression = factory.getNamedOperand(expression, \"walk\");\n\n    TupleStream stream = null;\n\n    if(edgeExpression == null) {\n      throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - walk param is required\", expression));\n    } else {\n      if(streamExpressions.size() > 0) {\n        stream = factory.constructStream(streamExpressions.get(0));\n        String edge = ((StreamExpressionValue) edgeExpression.getParameter()).getValue();\n        String[] fields = edge.split(\"->\");\n        if (fields.length != 2) {\n          throw new IOException(String.format(Locale.ROOT, \"invalid expression %s - walk param separated by an -> and must contain two fields\", expression));\n        }\n        traverseFrom = fields[0].trim();\n        traverseTo = fields[1].trim();\n      } else {\n        String edge = ((StreamExpressionValue) edgeExpression.getParameter()).getValue();\n        String[] fields = edge.split(\"->\");\n        if (fields.length != 2) {\n          throw new IOException(String.format(Locale.ROOT, \"invalid expression %s - walk param separated by an -> and must contain two fields\", expression));\n        }\n\n        String[] rootNodes = fields[0].split(\",\");\n        List<String> l = new ArrayList<>();\n        for(String n : rootNodes) {\n          l.add(n.trim());\n        }\n\n        stream = new NodeStream(l);\n        traverseFrom = \"node\";\n        traverseTo = fields[1].trim();\n      }\n    }\n\n    List<StreamExpression> metricExpressions = factory.getExpressionOperandsRepresentingTypes(expression, Expressible.class, Metric.class);\n    List<Metric> metrics = new ArrayList<>();\n    for(int idx = 0; idx < metricExpressions.size(); ++idx){\n      metrics.add(factory.constructMetric(metricExpressions.get(idx)));\n    }\n\n    boolean trackTraversal = false;\n\n    StreamExpressionNamedParameter trackExpression = factory.getNamedOperand(expression, \"trackTraversal\");\n\n    if(trackExpression != null) {\n      trackTraversal = Boolean.parseBoolean(((StreamExpressionValue) trackExpression.getParameter()).getValue());\n    } else {\n      useDefaultTraversal = true;\n    }\n\n    StreamExpressionNamedParameter docFreqExpression = factory.getNamedOperand(expression, \"maxDocFreq\");\n    int docFreq = -1;\n\n    if(docFreqExpression != null) {\n      docFreq = Integer.parseInt(((StreamExpressionValue) docFreqExpression.getParameter()).getValue());\n    }\n\n    Map<String,String> params = new HashMap<String,String>();\n    for(StreamExpressionNamedParameter namedParam : namedParams){\n      if(!namedParam.getName().equals(\"zkHost\") &&\n          !namedParam.getName().equals(\"gather\") &&\n          !namedParam.getName().equals(\"walk\") &&\n          !namedParam.getName().equals(\"scatter\") &&\n          !namedParam.getName().equals(\"maxDocFreq\") &&\n          !namedParam.getName().equals(\"trackTraversal\"))\n      {\n        params.put(namedParam.getName(), namedParam.getParameter().toString().trim());\n      }\n    }\n\n    // zkHost, optional - if not provided then will look into factory list to get\n    String zkHost = null;\n    if(null == zkHostExpression){\n      zkHost = factory.getCollectionZkHost(collectionName);\n      if(zkHost == null) {\n        zkHost = factory.getDefaultZkHost();\n      }\n    } else if(zkHostExpression.getParameter() instanceof StreamExpressionValue) {\n      zkHost = ((StreamExpressionValue)zkHostExpression.getParameter()).getValue();\n    }\n\n    if(null == zkHost){\n      throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - zkHost not found for collection '%s'\",expression,collectionName));\n    }\n\n    // We've got all the required items\n    init(zkHost,\n         collectionName,\n         stream,\n         traverseFrom,\n         traverseTo ,\n         gather,\n         params,\n         metrics,\n         trackTraversal,\n         scatter,\n         docFreq);\n  }\n\n","sourceOld":"  public GatherNodesStream(StreamExpression expression, StreamFactory factory) throws IOException {\n\n\n    String collectionName = factory.getValueOperand(expression, 0);\n    List<StreamExpressionNamedParameter> namedParams = factory.getNamedOperands(expression);\n    StreamExpressionNamedParameter zkHostExpression = factory.getNamedOperand(expression, \"zkHost\");\n\n    List<StreamExpression> streamExpressions = factory.getExpressionOperandsRepresentingTypes(expression, Expressible.class, TupleStream.class);\n    // Collection Name\n    if(null == collectionName) {\n      throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - collectionName expected as first operand\",expression));\n    }\n\n\n    Set<Traversal.Scatter> scatter = new HashSet();\n\n    StreamExpressionNamedParameter scatterExpression = factory.getNamedOperand(expression, \"scatter\");\n\n    if(scatterExpression == null) {\n      scatter.add(Traversal.Scatter.LEAVES);\n    } else {\n      String s =  ((StreamExpressionValue)scatterExpression.getParameter()).getValue();\n      String[] sArray = s.split(\",\");\n      for(String sv : sArray) {\n        sv = sv.trim();\n        if(Traversal.Scatter.BRANCHES.toString().equalsIgnoreCase(sv)) {\n          scatter.add(Traversal.Scatter.BRANCHES);\n        } else if (Traversal.Scatter.LEAVES.toString().equalsIgnoreCase(sv)) {\n          scatter.add(Traversal.Scatter.LEAVES);\n        }\n      }\n    }\n\n    String gather = null;\n    StreamExpressionNamedParameter gatherExpression = factory.getNamedOperand(expression, \"gather\");\n\n    if(gatherExpression == null) {\n      throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - from param is required\",expression));\n    } else {\n      gather = ((StreamExpressionValue)gatherExpression.getParameter()).getValue();\n    }\n\n    String traverseFrom = null;\n    String traverseTo = null;\n    StreamExpressionNamedParameter edgeExpression = factory.getNamedOperand(expression, \"walk\");\n\n    TupleStream stream = null;\n\n    if(edgeExpression == null) {\n      throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - walk param is required\", expression));\n    } else {\n      if(streamExpressions.size() > 0) {\n        stream = factory.constructStream(streamExpressions.get(0));\n        String edge = ((StreamExpressionValue) edgeExpression.getParameter()).getValue();\n        String[] fields = edge.split(\"->\");\n        if (fields.length != 2) {\n          throw new IOException(String.format(Locale.ROOT, \"invalid expression %s - walk param separated by an -> and must contain two fields\", expression));\n        }\n        traverseFrom = fields[0].trim();\n        traverseTo = fields[1].trim();\n      } else {\n        String edge = ((StreamExpressionValue) edgeExpression.getParameter()).getValue();\n        String[] fields = edge.split(\"->\");\n        if (fields.length != 2) {\n          throw new IOException(String.format(Locale.ROOT, \"invalid expression %s - walk param separated by an -> and must contain two fields\", expression));\n        }\n\n        String[] rootNodes = fields[0].split(\",\");\n        List<String> l = new ArrayList();\n        for(String n : rootNodes) {\n          l.add(n.trim());\n        }\n\n        stream = new NodeStream(l);\n        traverseFrom = \"node\";\n        traverseTo = fields[1].trim();\n      }\n    }\n\n    List<StreamExpression> metricExpressions = factory.getExpressionOperandsRepresentingTypes(expression, Expressible.class, Metric.class);\n    List<Metric> metrics = new ArrayList();\n    for(int idx = 0; idx < metricExpressions.size(); ++idx){\n      metrics.add(factory.constructMetric(metricExpressions.get(idx)));\n    }\n\n    boolean trackTraversal = false;\n\n    StreamExpressionNamedParameter trackExpression = factory.getNamedOperand(expression, \"trackTraversal\");\n\n    if(trackExpression != null) {\n      trackTraversal = Boolean.parseBoolean(((StreamExpressionValue) trackExpression.getParameter()).getValue());\n    } else {\n      useDefaultTraversal = true;\n    }\n\n    StreamExpressionNamedParameter docFreqExpression = factory.getNamedOperand(expression, \"maxDocFreq\");\n    int docFreq = -1;\n\n    if(docFreqExpression != null) {\n      docFreq = Integer.parseInt(((StreamExpressionValue) docFreqExpression.getParameter()).getValue());\n    }\n\n    Map<String,String> params = new HashMap<String,String>();\n    for(StreamExpressionNamedParameter namedParam : namedParams){\n      if(!namedParam.getName().equals(\"zkHost\") &&\n          !namedParam.getName().equals(\"gather\") &&\n          !namedParam.getName().equals(\"walk\") &&\n          !namedParam.getName().equals(\"scatter\") &&\n          !namedParam.getName().equals(\"maxDocFreq\") &&\n          !namedParam.getName().equals(\"trackTraversal\"))\n      {\n        params.put(namedParam.getName(), namedParam.getParameter().toString().trim());\n      }\n    }\n\n    // zkHost, optional - if not provided then will look into factory list to get\n    String zkHost = null;\n    if(null == zkHostExpression){\n      zkHost = factory.getCollectionZkHost(collectionName);\n      if(zkHost == null) {\n        zkHost = factory.getDefaultZkHost();\n      }\n    } else if(zkHostExpression.getParameter() instanceof StreamExpressionValue) {\n      zkHost = ((StreamExpressionValue)zkHostExpression.getParameter()).getValue();\n    }\n\n    if(null == zkHost){\n      throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - zkHost not found for collection '%s'\",expression,collectionName));\n    }\n\n    // We've got all the required items\n    init(zkHost,\n         collectionName,\n         stream,\n         traverseFrom,\n         traverseTo ,\n         gather,\n         params,\n         metrics,\n         trackTraversal,\n         scatter,\n         docFreq);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"afdf6ff5b1319d8ae254212f1203a6233ed3e1dc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d":["94ac27a7f2b3e27d17f14b7aeeb3fcd450b7cc96"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"94ac27a7f2b3e27d17f14b7aeeb3fcd450b7cc96":["0e15955b4980562a0c1c81d08654904f3fadb83b"],"0e15955b4980562a0c1c81d08654904f3fadb83b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","afdf6ff5b1319d8ae254212f1203a6233ed3e1dc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d"]},"commit2Childs":{"afdf6ff5b1319d8ae254212f1203a6233ed3e1dc":["0e15955b4980562a0c1c81d08654904f3fadb83b"],"0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["afdf6ff5b1319d8ae254212f1203a6233ed3e1dc","0e15955b4980562a0c1c81d08654904f3fadb83b"],"94ac27a7f2b3e27d17f14b7aeeb3fcd450b7cc96":["0f4f6e13eb95702dc635119d2ccd4fa5fafcc88d"],"0e15955b4980562a0c1c81d08654904f3fadb83b":["94ac27a7f2b3e27d17f14b7aeeb3fcd450b7cc96"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}