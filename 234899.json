{"path":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testDeleteHappensBeforeWhileFlush().mjava","commits":[{"id":"9664831d785795f0f380fccc6db560efb979fdbb","date":1526559002,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testDeleteHappensBeforeWhileFlush().mjava","pathOld":"/dev/null","sourceNew":"  public void testDeleteHappensBeforeWhileFlush() throws IOException, InterruptedException {\n    CountDownLatch latch = new CountDownLatch(1);\n    CountDownLatch inFlush = new CountDownLatch(1);\n    try (Directory dir = new FilterDirectory(newDirectory()) {\n      @Override\n      public IndexOutput createOutput(String name, IOContext context) throws IOException {\n        StackTraceElement[] trace = new Exception().getStackTrace();\n        for (int i = 0; i < trace.length; i++) {\n          if (\"flush\".equals(trace[i].getMethodName()) && DefaultIndexingChain.class.getName().equals(trace[i].getClassName())) {\n            try {\n              inFlush.countDown();\n              latch.await();\n            } catch (InterruptedException e) {\n              throw new AssertionError(e);\n            }\n          }\n        }\n        return super.createOutput(name, context);\n      }\n    }; IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig())) {\n      Document document = new Document();\n      document.add(new StringField(\"id\", \"1\", Field.Store.YES));\n      writer.addDocument(document);\n      Thread t = new Thread(() -> {\n        try {\n          inFlush.await();\n          writer.docWriter.flushControl.setApplyAllDeletes();\n          if (random().nextBoolean()) {\n            writer.updateDocument(new Term(\"id\", \"1\"), document);\n          } else {\n            writer.deleteDocuments(new Term(\"id\", \"1\"));\n          }\n\n        } catch (Exception e) {\n          throw new AssertionError(e);\n        } finally {\n          latch.countDown();\n        }\n      });\n      t.start();\n      try (IndexReader reader = writer.getReader()) {\n        assertEquals(1, reader.numDocs());\n      };\n      t.join();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2916966cc9815e973c01452a0d76c98c5e0d0926","date":1577444040,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testDeleteHappensBeforeWhileFlush().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testDeleteHappensBeforeWhileFlush().mjava","sourceNew":"  public void testDeleteHappensBeforeWhileFlush() throws IOException, InterruptedException {\n    CountDownLatch latch = new CountDownLatch(1);\n    CountDownLatch inFlush = new CountDownLatch(1);\n    try (Directory dir = new FilterDirectory(newDirectory()) {\n      @Override\n      public IndexOutput createOutput(String name, IOContext context) throws IOException {\n        if (callStackContains(DefaultIndexingChain.class, \"flush\")) {\n          try {\n            inFlush.countDown();\n            latch.await();\n          } catch (InterruptedException e) {\n            throw new AssertionError(e);\n          }\n        }\n        return super.createOutput(name, context);\n      }\n    }; IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig())) {\n      Document document = new Document();\n      document.add(new StringField(\"id\", \"1\", Field.Store.YES));\n      writer.addDocument(document);\n      Thread t = new Thread(() -> {\n        try {\n          inFlush.await();\n          writer.docWriter.flushControl.setApplyAllDeletes();\n          if (random().nextBoolean()) {\n            writer.updateDocument(new Term(\"id\", \"1\"), document);\n          } else {\n            writer.deleteDocuments(new Term(\"id\", \"1\"));\n          }\n\n        } catch (Exception e) {\n          throw new AssertionError(e);\n        } finally {\n          latch.countDown();\n        }\n      });\n      t.start();\n      try (IndexReader reader = writer.getReader()) {\n        assertEquals(1, reader.numDocs());\n      };\n      t.join();\n    }\n  }\n\n","sourceOld":"  public void testDeleteHappensBeforeWhileFlush() throws IOException, InterruptedException {\n    CountDownLatch latch = new CountDownLatch(1);\n    CountDownLatch inFlush = new CountDownLatch(1);\n    try (Directory dir = new FilterDirectory(newDirectory()) {\n      @Override\n      public IndexOutput createOutput(String name, IOContext context) throws IOException {\n        StackTraceElement[] trace = new Exception().getStackTrace();\n        for (int i = 0; i < trace.length; i++) {\n          if (\"flush\".equals(trace[i].getMethodName()) && DefaultIndexingChain.class.getName().equals(trace[i].getClassName())) {\n            try {\n              inFlush.countDown();\n              latch.await();\n            } catch (InterruptedException e) {\n              throw new AssertionError(e);\n            }\n          }\n        }\n        return super.createOutput(name, context);\n      }\n    }; IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig())) {\n      Document document = new Document();\n      document.add(new StringField(\"id\", \"1\", Field.Store.YES));\n      writer.addDocument(document);\n      Thread t = new Thread(() -> {\n        try {\n          inFlush.await();\n          writer.docWriter.flushControl.setApplyAllDeletes();\n          if (random().nextBoolean()) {\n            writer.updateDocument(new Term(\"id\", \"1\"), document);\n          } else {\n            writer.deleteDocuments(new Term(\"id\", \"1\"));\n          }\n\n        } catch (Exception e) {\n          throw new AssertionError(e);\n        } finally {\n          latch.countDown();\n        }\n      });\n      t.start();\n      try (IndexReader reader = writer.getReader()) {\n        assertEquals(1, reader.numDocs());\n      };\n      t.join();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"94ec73c5617c177b1d81ddfe04bbff1d08fccecc","date":1577456244,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testDeleteHappensBeforeWhileFlush().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testDeleteHappensBeforeWhileFlush().mjava","sourceNew":"  public void testDeleteHappensBeforeWhileFlush() throws IOException, InterruptedException {\n    CountDownLatch latch = new CountDownLatch(1);\n    CountDownLatch inFlush = new CountDownLatch(1);\n    try (Directory dir = new FilterDirectory(newDirectory()) {\n      @Override\n      public IndexOutput createOutput(String name, IOContext context) throws IOException {\n        if (callStackContains(DefaultIndexingChain.class, \"flush\")) {\n          try {\n            inFlush.countDown();\n            latch.await();\n          } catch (InterruptedException e) {\n            throw new AssertionError(e);\n          }\n        }\n        return super.createOutput(name, context);\n      }\n    }; IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig())) {\n      Document document = new Document();\n      document.add(new StringField(\"id\", \"1\", Field.Store.YES));\n      writer.addDocument(document);\n      Thread t = new Thread(() -> {\n        try {\n          inFlush.await();\n          writer.docWriter.flushControl.setApplyAllDeletes();\n          if (random().nextBoolean()) {\n            writer.updateDocument(new Term(\"id\", \"1\"), document);\n          } else {\n            writer.deleteDocuments(new Term(\"id\", \"1\"));\n          }\n\n        } catch (Exception e) {\n          throw new AssertionError(e);\n        } finally {\n          latch.countDown();\n        }\n      });\n      t.start();\n      try (IndexReader reader = writer.getReader()) {\n        assertEquals(1, reader.numDocs());\n      };\n      t.join();\n    }\n  }\n\n","sourceOld":"  public void testDeleteHappensBeforeWhileFlush() throws IOException, InterruptedException {\n    CountDownLatch latch = new CountDownLatch(1);\n    CountDownLatch inFlush = new CountDownLatch(1);\n    try (Directory dir = new FilterDirectory(newDirectory()) {\n      @Override\n      public IndexOutput createOutput(String name, IOContext context) throws IOException {\n        StackTraceElement[] trace = new Exception().getStackTrace();\n        for (int i = 0; i < trace.length; i++) {\n          if (\"flush\".equals(trace[i].getMethodName()) && DefaultIndexingChain.class.getName().equals(trace[i].getClassName())) {\n            try {\n              inFlush.countDown();\n              latch.await();\n            } catch (InterruptedException e) {\n              throw new AssertionError(e);\n            }\n          }\n        }\n        return super.createOutput(name, context);\n      }\n    }; IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig())) {\n      Document document = new Document();\n      document.add(new StringField(\"id\", \"1\", Field.Store.YES));\n      writer.addDocument(document);\n      Thread t = new Thread(() -> {\n        try {\n          inFlush.await();\n          writer.docWriter.flushControl.setApplyAllDeletes();\n          if (random().nextBoolean()) {\n            writer.updateDocument(new Term(\"id\", \"1\"), document);\n          } else {\n            writer.deleteDocuments(new Term(\"id\", \"1\"));\n          }\n\n        } catch (Exception e) {\n          throw new AssertionError(e);\n        } finally {\n          latch.countDown();\n        }\n      });\n      t.start();\n      try (IndexReader reader = writer.getReader()) {\n        assertEquals(1, reader.numDocs());\n      };\n      t.join();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a6f8af01d9b3067b143bbdc0a492720e2af97cf","date":1600157724,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testDeleteHappensBeforeWhileFlush().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testDeleteHappensBeforeWhileFlush().mjava","sourceNew":"  public void testDeleteHappensBeforeWhileFlush() throws IOException, InterruptedException {\n    CountDownLatch latch = new CountDownLatch(1);\n    CountDownLatch inFlush = new CountDownLatch(1);\n    try (Directory dir = new FilterDirectory(newDirectory()) {\n      @Override\n      public IndexOutput createOutput(String name, IOContext context) throws IOException {\n        if (callStackContains(IndexingChain.class, \"flush\")) {\n          try {\n            inFlush.countDown();\n            latch.await();\n          } catch (InterruptedException e) {\n            throw new AssertionError(e);\n          }\n        }\n        return super.createOutput(name, context);\n      }\n    }; IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig())) {\n      Document document = new Document();\n      document.add(new StringField(\"id\", \"1\", Field.Store.YES));\n      writer.addDocument(document);\n      Thread t = new Thread(() -> {\n        try {\n          inFlush.await();\n          writer.docWriter.flushControl.setApplyAllDeletes();\n          if (random().nextBoolean()) {\n            writer.updateDocument(new Term(\"id\", \"1\"), document);\n          } else {\n            writer.deleteDocuments(new Term(\"id\", \"1\"));\n          }\n\n        } catch (Exception e) {\n          throw new AssertionError(e);\n        } finally {\n          latch.countDown();\n        }\n      });\n      t.start();\n      try (IndexReader reader = writer.getReader()) {\n        assertEquals(1, reader.numDocs());\n      };\n      t.join();\n    }\n  }\n\n","sourceOld":"  public void testDeleteHappensBeforeWhileFlush() throws IOException, InterruptedException {\n    CountDownLatch latch = new CountDownLatch(1);\n    CountDownLatch inFlush = new CountDownLatch(1);\n    try (Directory dir = new FilterDirectory(newDirectory()) {\n      @Override\n      public IndexOutput createOutput(String name, IOContext context) throws IOException {\n        if (callStackContains(DefaultIndexingChain.class, \"flush\")) {\n          try {\n            inFlush.countDown();\n            latch.await();\n          } catch (InterruptedException e) {\n            throw new AssertionError(e);\n          }\n        }\n        return super.createOutput(name, context);\n      }\n    }; IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig())) {\n      Document document = new Document();\n      document.add(new StringField(\"id\", \"1\", Field.Store.YES));\n      writer.addDocument(document);\n      Thread t = new Thread(() -> {\n        try {\n          inFlush.await();\n          writer.docWriter.flushControl.setApplyAllDeletes();\n          if (random().nextBoolean()) {\n            writer.updateDocument(new Term(\"id\", \"1\"), document);\n          } else {\n            writer.deleteDocuments(new Term(\"id\", \"1\"));\n          }\n\n        } catch (Exception e) {\n          throw new AssertionError(e);\n        } finally {\n          latch.countDown();\n        }\n      });\n      t.start();\n      try (IndexReader reader = writer.getReader()) {\n        assertEquals(1, reader.numDocs());\n      };\n      t.join();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"680b6449f09827f58fe987aff279e014c311d966","date":1600247985,"type":3,"author":"noblepaul","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testDeleteHappensBeforeWhileFlush().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testDeleteHappensBeforeWhileFlush().mjava","sourceNew":"  public void testDeleteHappensBeforeWhileFlush() throws IOException, InterruptedException {\n    CountDownLatch latch = new CountDownLatch(1);\n    CountDownLatch inFlush = new CountDownLatch(1);\n    try (Directory dir = new FilterDirectory(newDirectory()) {\n      @Override\n      public IndexOutput createOutput(String name, IOContext context) throws IOException {\n        if (callStackContains(IndexingChain.class, \"flush\")) {\n          try {\n            inFlush.countDown();\n            latch.await();\n          } catch (InterruptedException e) {\n            throw new AssertionError(e);\n          }\n        }\n        return super.createOutput(name, context);\n      }\n    }; IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig())) {\n      Document document = new Document();\n      document.add(new StringField(\"id\", \"1\", Field.Store.YES));\n      writer.addDocument(document);\n      Thread t = new Thread(() -> {\n        try {\n          inFlush.await();\n          writer.docWriter.flushControl.setApplyAllDeletes();\n          if (random().nextBoolean()) {\n            writer.updateDocument(new Term(\"id\", \"1\"), document);\n          } else {\n            writer.deleteDocuments(new Term(\"id\", \"1\"));\n          }\n\n        } catch (Exception e) {\n          throw new AssertionError(e);\n        } finally {\n          latch.countDown();\n        }\n      });\n      t.start();\n      try (IndexReader reader = writer.getReader()) {\n        assertEquals(1, reader.numDocs());\n      };\n      t.join();\n    }\n  }\n\n","sourceOld":"  public void testDeleteHappensBeforeWhileFlush() throws IOException, InterruptedException {\n    CountDownLatch latch = new CountDownLatch(1);\n    CountDownLatch inFlush = new CountDownLatch(1);\n    try (Directory dir = new FilterDirectory(newDirectory()) {\n      @Override\n      public IndexOutput createOutput(String name, IOContext context) throws IOException {\n        if (callStackContains(DefaultIndexingChain.class, \"flush\")) {\n          try {\n            inFlush.countDown();\n            latch.await();\n          } catch (InterruptedException e) {\n            throw new AssertionError(e);\n          }\n        }\n        return super.createOutput(name, context);\n      }\n    }; IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig())) {\n      Document document = new Document();\n      document.add(new StringField(\"id\", \"1\", Field.Store.YES));\n      writer.addDocument(document);\n      Thread t = new Thread(() -> {\n        try {\n          inFlush.await();\n          writer.docWriter.flushControl.setApplyAllDeletes();\n          if (random().nextBoolean()) {\n            writer.updateDocument(new Term(\"id\", \"1\"), document);\n          } else {\n            writer.deleteDocuments(new Term(\"id\", \"1\"));\n          }\n\n        } catch (Exception e) {\n          throw new AssertionError(e);\n        } finally {\n          latch.countDown();\n        }\n      });\n      t.start();\n      try (IndexReader reader = writer.getReader()) {\n        assertEquals(1, reader.numDocs());\n      };\n      t.join();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"680b6449f09827f58fe987aff279e014c311d966":["2916966cc9815e973c01452a0d76c98c5e0d0926","7a6f8af01d9b3067b143bbdc0a492720e2af97cf"],"7a6f8af01d9b3067b143bbdc0a492720e2af97cf":["2916966cc9815e973c01452a0d76c98c5e0d0926"],"9664831d785795f0f380fccc6db560efb979fdbb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2916966cc9815e973c01452a0d76c98c5e0d0926":["9664831d785795f0f380fccc6db560efb979fdbb"],"94ec73c5617c177b1d81ddfe04bbff1d08fccecc":["9664831d785795f0f380fccc6db560efb979fdbb","2916966cc9815e973c01452a0d76c98c5e0d0926"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["680b6449f09827f58fe987aff279e014c311d966"]},"commit2Childs":{"680b6449f09827f58fe987aff279e014c311d966":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7a6f8af01d9b3067b143bbdc0a492720e2af97cf":["680b6449f09827f58fe987aff279e014c311d966"],"9664831d785795f0f380fccc6db560efb979fdbb":["2916966cc9815e973c01452a0d76c98c5e0d0926","94ec73c5617c177b1d81ddfe04bbff1d08fccecc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9664831d785795f0f380fccc6db560efb979fdbb"],"2916966cc9815e973c01452a0d76c98c5e0d0926":["680b6449f09827f58fe987aff279e014c311d966","7a6f8af01d9b3067b143bbdc0a492720e2af97cf","94ec73c5617c177b1d81ddfe04bbff1d08fccecc"],"94ec73c5617c177b1d81ddfe04bbff1d08fccecc":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["94ec73c5617c177b1d81ddfe04bbff1d08fccecc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}