{"path":"contrib/memory/src/java/org/apache/lucene/index/memory/SynonymMap#read(byte[]).mjava","commits":[{"id":"4c9661df01b81c277277a01afbca7851557a2148","date":1133588656,"type":0,"author":"Wolfgang Hoschek","isMerge":false,"pathNew":"contrib/memory/src/java/org/apache/lucene/index/memory/SynonymMap#read(byte[]).mjava","pathOld":"/dev/null","sourceNew":"\tprivate HashMap read(byte[] data) {\n\t\tint WORDS  = (int) (76401 / 0.7); // presizing\n\t\tint GROUPS = (int) (88022 / 0.7); // presizing\n\t\tHashMap word2Groups = new HashMap(WORDS);  // Map<String word, int[] groups>\n\t\tHashMap group2Words = new HashMap(GROUPS); // Map<int group, String[] words>\n\t\tHashMap internedWords = new HashMap(WORDS);// Map<String word, String word>\n\n\t\tCharset charset = Charset.forName(\"UTF-8\");\n\t\tint lastNum = -1;\n\t\tInteger lastGroup = null;\n\t\tint len = data.length;\n\t\tint i=0;\n\t\t\n\t\twhile (i < len) { // until EOF\n\t\t\t/* Part A: Parse a line */\n\t\t\t\n\t\t\t// scan to beginning of group\n\t\t\twhile (i < len && data[i] != '(') i++;\n\t\t\tif (i >= len) break; // EOF\n\t\t\ti++;\n\t\t\t\n\t\t\t// parse group\n\t\t\tint num = 0;\n\t\t\twhile (i < len && data[i] != ',') {\n\t\t\t\tnum = 10*num + (data[i] - 48);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\ti++;\n//\t\t\tif (DEBUG) System.err.println(\"num=\"+ num);\n\t\t\t\n\t\t\t// scan to beginning of word\n\t\t\twhile (i < len && data[i] != '\\'') i++;\n\t\t\ti++;\n\t\n\t\t\t// scan to end of word\n\t\t\tint start = i;\n\t\t\tdo {\n\t\t\t\twhile (i < len && data[i] != '\\'') i++;\n\t\t\t\ti++;\n\t\t\t} while (i < len && data[i] != ','); // word must end with \"',\"\n\t\t\t\n\t\t\tif (i >= len) break; // EOF\n\t\t\tString word = charset.decode(ByteBuffer.wrap(data, start, i-start-1)).toString();\n//\t\t\tString word = new String(data, 0, start, i-start-1); // ASCII\n\t\t\t\n\t\t\t/*\n\t\t\t * Part B: ignore phrases (with spaces and hyphens) and\n\t\t\t * non-alphabetic words, and let user customize word (e.g. do some\n\t\t\t * stemming)\n\t\t\t */\n\t\t\tif (!isValid(word)) continue; // ignore\n\t\t\tword = analyze(word);\n\t\t\tif (word == null || word.length() == 0) continue; // ignore\n\t\t\t\n\t\t\t\n\t\t\t/* Part C: Add (group,word) to tables */\n\t\t\t\n\t\t\t// ensure compact string representation, minimizing memory overhead\n\t\t\tString w = (String) internedWords.get(word);\n\t\t\tif (w == null) {\n\t\t\t\tword = new String(word); // ensure compact string\n\t\t\t\tinternedWords.put(word, word);\n\t\t\t} else {\n\t\t\t\tword = w;\n\t\t\t}\n\t\t\t\n\t\t\tInteger group = lastGroup;\n\t\t\tif (num != lastNum) {\n\t\t\t\tgroup = new Integer(num);\n\t\t\t\tlastGroup = group;\n\t\t\t\tlastNum = num;\n\t\t\t}\n\t\t\t\n\t\t\t// add word --> group\n\t\t\tArrayList groups = (ArrayList) word2Groups.get(word);\n\t\t\tif (groups == null) {\n\t\t\t\tgroups = new ArrayList(1);\n\t\t\t\tword2Groups.put(word, groups);\n\t\t\t}\n\t\t\tgroups.add(group);\n\n\t\t\t// add group --> word\n\t\t\tArrayList words = (ArrayList) group2Words.get(group);\n\t\t\tif (words == null) {\n\t\t\t\twords = new ArrayList(1);\n\t\t\t\tgroup2Words.put(group, words);\n\t\t\t} \n\t\t\twords.add(word);\n\t\t}\n\t\t\n\t\t\n\t\t/* Part D: compute index data structure */\n\t\tHashMap word2Syns = createIndex(word2Groups, group2Words);\t\t\n\t\t\t\t\n\t\t/* Part E: minimize memory consumption by a factor 3 (or so) */\n//\t\tif (true) return word2Syns;\n\t\tword2Groups = null; // help gc\n\t\tgroup2Words = null; // help gc\t\t\n\t\treturn optimize(word2Syns, internedWords);\n\t}\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7f68e24227d5556d33ee6d586fd9010cd9ff8bec","date":1150091176,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"contrib/memory/src/java/org/apache/lucene/index/memory/SynonymMap#read(byte[]).mjava","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/SynonymMap#read(byte[]).mjava","sourceNew":"  private HashMap read(byte[] data) {\n    int WORDS  = (int) (76401 / 0.7); // presizing\n    int GROUPS = (int) (88022 / 0.7); // presizing\n    HashMap word2Groups = new HashMap(WORDS);  // Map<String word, int[] groups>\n    HashMap group2Words = new HashMap(GROUPS); // Map<int group, String[] words>\n    HashMap internedWords = new HashMap(WORDS);// Map<String word, String word>\n\n    Charset charset = Charset.forName(\"UTF-8\");\n    int lastNum = -1;\n    Integer lastGroup = null;\n    int len = data.length;\n    int i=0;\n    \n    while (i < len) { // until EOF\n      /* Part A: Parse a line */\n      \n      // scan to beginning of group\n      while (i < len && data[i] != '(') i++;\n      if (i >= len) break; // EOF\n      i++;\n      \n      // parse group\n      int num = 0;\n      while (i < len && data[i] != ',') {\n        num = 10*num + (data[i] - 48);\n        i++;\n      }\n      i++;\n//      if (DEBUG) System.err.println(\"num=\"+ num);\n      \n      // scan to beginning of word\n      while (i < len && data[i] != '\\'') i++;\n      i++;\n  \n      // scan to end of word\n      int start = i;\n      do {\n        while (i < len && data[i] != '\\'') i++;\n        i++;\n      } while (i < len && data[i] != ','); // word must end with \"',\"\n      \n      if (i >= len) break; // EOF\n      String word = charset.decode(ByteBuffer.wrap(data, start, i-start-1)).toString();\n//      String word = new String(data, 0, start, i-start-1); // ASCII\n      \n      /*\n       * Part B: ignore phrases (with spaces and hyphens) and\n       * non-alphabetic words, and let user customize word (e.g. do some\n       * stemming)\n       */\n      if (!isValid(word)) continue; // ignore\n      word = analyze(word);\n      if (word == null || word.length() == 0) continue; // ignore\n      \n      \n      /* Part C: Add (group,word) to tables */\n      \n      // ensure compact string representation, minimizing memory overhead\n      String w = (String) internedWords.get(word);\n      if (w == null) {\n        word = new String(word); // ensure compact string\n        internedWords.put(word, word);\n      } else {\n        word = w;\n      }\n      \n      Integer group = lastGroup;\n      if (num != lastNum) {\n        group = new Integer(num);\n        lastGroup = group;\n        lastNum = num;\n      }\n      \n      // add word --> group\n      ArrayList groups = (ArrayList) word2Groups.get(word);\n      if (groups == null) {\n        groups = new ArrayList(1);\n        word2Groups.put(word, groups);\n      }\n      groups.add(group);\n\n      // add group --> word\n      ArrayList words = (ArrayList) group2Words.get(group);\n      if (words == null) {\n        words = new ArrayList(1);\n        group2Words.put(group, words);\n      } \n      words.add(word);\n    }\n    \n    \n    /* Part D: compute index data structure */\n    HashMap word2Syns = createIndex(word2Groups, group2Words);    \n        \n    /* Part E: minimize memory consumption by a factor 3 (or so) */\n//    if (true) return word2Syns;\n    word2Groups = null; // help gc\n    group2Words = null; // help gc    \n    return optimize(word2Syns, internedWords);\n  }\n\n","sourceOld":"\tprivate HashMap read(byte[] data) {\n\t\tint WORDS  = (int) (76401 / 0.7); // presizing\n\t\tint GROUPS = (int) (88022 / 0.7); // presizing\n\t\tHashMap word2Groups = new HashMap(WORDS);  // Map<String word, int[] groups>\n\t\tHashMap group2Words = new HashMap(GROUPS); // Map<int group, String[] words>\n\t\tHashMap internedWords = new HashMap(WORDS);// Map<String word, String word>\n\n\t\tCharset charset = Charset.forName(\"UTF-8\");\n\t\tint lastNum = -1;\n\t\tInteger lastGroup = null;\n\t\tint len = data.length;\n\t\tint i=0;\n\t\t\n\t\twhile (i < len) { // until EOF\n\t\t\t/* Part A: Parse a line */\n\t\t\t\n\t\t\t// scan to beginning of group\n\t\t\twhile (i < len && data[i] != '(') i++;\n\t\t\tif (i >= len) break; // EOF\n\t\t\ti++;\n\t\t\t\n\t\t\t// parse group\n\t\t\tint num = 0;\n\t\t\twhile (i < len && data[i] != ',') {\n\t\t\t\tnum = 10*num + (data[i] - 48);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\ti++;\n//\t\t\tif (DEBUG) System.err.println(\"num=\"+ num);\n\t\t\t\n\t\t\t// scan to beginning of word\n\t\t\twhile (i < len && data[i] != '\\'') i++;\n\t\t\ti++;\n\t\n\t\t\t// scan to end of word\n\t\t\tint start = i;\n\t\t\tdo {\n\t\t\t\twhile (i < len && data[i] != '\\'') i++;\n\t\t\t\ti++;\n\t\t\t} while (i < len && data[i] != ','); // word must end with \"',\"\n\t\t\t\n\t\t\tif (i >= len) break; // EOF\n\t\t\tString word = charset.decode(ByteBuffer.wrap(data, start, i-start-1)).toString();\n//\t\t\tString word = new String(data, 0, start, i-start-1); // ASCII\n\t\t\t\n\t\t\t/*\n\t\t\t * Part B: ignore phrases (with spaces and hyphens) and\n\t\t\t * non-alphabetic words, and let user customize word (e.g. do some\n\t\t\t * stemming)\n\t\t\t */\n\t\t\tif (!isValid(word)) continue; // ignore\n\t\t\tword = analyze(word);\n\t\t\tif (word == null || word.length() == 0) continue; // ignore\n\t\t\t\n\t\t\t\n\t\t\t/* Part C: Add (group,word) to tables */\n\t\t\t\n\t\t\t// ensure compact string representation, minimizing memory overhead\n\t\t\tString w = (String) internedWords.get(word);\n\t\t\tif (w == null) {\n\t\t\t\tword = new String(word); // ensure compact string\n\t\t\t\tinternedWords.put(word, word);\n\t\t\t} else {\n\t\t\t\tword = w;\n\t\t\t}\n\t\t\t\n\t\t\tInteger group = lastGroup;\n\t\t\tif (num != lastNum) {\n\t\t\t\tgroup = new Integer(num);\n\t\t\t\tlastGroup = group;\n\t\t\t\tlastNum = num;\n\t\t\t}\n\t\t\t\n\t\t\t// add word --> group\n\t\t\tArrayList groups = (ArrayList) word2Groups.get(word);\n\t\t\tif (groups == null) {\n\t\t\t\tgroups = new ArrayList(1);\n\t\t\t\tword2Groups.put(word, groups);\n\t\t\t}\n\t\t\tgroups.add(group);\n\n\t\t\t// add group --> word\n\t\t\tArrayList words = (ArrayList) group2Words.get(group);\n\t\t\tif (words == null) {\n\t\t\t\twords = new ArrayList(1);\n\t\t\t\tgroup2Words.put(group, words);\n\t\t\t} \n\t\t\twords.add(word);\n\t\t}\n\t\t\n\t\t\n\t\t/* Part D: compute index data structure */\n\t\tHashMap word2Syns = createIndex(word2Groups, group2Words);\t\t\n\t\t\t\t\n\t\t/* Part E: minimize memory consumption by a factor 3 (or so) */\n//\t\tif (true) return word2Syns;\n\t\tword2Groups = null; // help gc\n\t\tgroup2Words = null; // help gc\t\t\n\t\treturn optimize(word2Syns, internedWords);\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bcde5e3f23911110baa101ed062b544162825b5","date":1254521804,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"contrib/memory/src/java/org/apache/lucene/index/memory/SynonymMap#read(byte[]).mjava","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/SynonymMap#read(byte[]).mjava","sourceNew":"  private HashMap read(byte[] data) {\n    int WORDS  = (int) (76401 / 0.7); // presizing\n    int GROUPS = (int) (88022 / 0.7); // presizing\n    HashMap word2Groups = new HashMap(WORDS);  // Map<String word, int[] groups>\n    HashMap group2Words = new HashMap(GROUPS); // Map<int group, String[] words>\n    HashMap internedWords = new HashMap(WORDS);// Map<String word, String word>\n\n    Charset charset = Charset.forName(\"UTF-8\");\n    int lastNum = -1;\n    Integer lastGroup = null;\n    int len = data.length;\n    int i=0;\n    \n    while (i < len) { // until EOF\n      /* Part A: Parse a line */\n      \n      // scan to beginning of group\n      while (i < len && data[i] != '(') i++;\n      if (i >= len) break; // EOF\n      i++;\n      \n      // parse group\n      int num = 0;\n      while (i < len && data[i] != ',') {\n        num = 10*num + (data[i] - 48);\n        i++;\n      }\n      i++;\n//      if (DEBUG) System.err.println(\"num=\"+ num);\n      \n      // scan to beginning of word\n      while (i < len && data[i] != '\\'') i++;\n      i++;\n  \n      // scan to end of word\n      int start = i;\n      do {\n        while (i < len && data[i] != '\\'') i++;\n        i++;\n      } while (i < len && data[i] != ','); // word must end with \"',\"\n      \n      if (i >= len) break; // EOF\n      String word = charset.decode(ByteBuffer.wrap(data, start, i-start-1)).toString();\n//      String word = new String(data, 0, start, i-start-1); // ASCII\n      \n      /*\n       * Part B: ignore phrases (with spaces and hyphens) and\n       * non-alphabetic words, and let user customize word (e.g. do some\n       * stemming)\n       */\n      if (!isValid(word)) continue; // ignore\n      word = analyze(word);\n      if (word == null || word.length() == 0) continue; // ignore\n      \n      \n      /* Part C: Add (group,word) to tables */\n      \n      // ensure compact string representation, minimizing memory overhead\n      String w = (String) internedWords.get(word);\n      if (w == null) {\n        word = new String(word); // ensure compact string\n        internedWords.put(word, word);\n      } else {\n        word = w;\n      }\n      \n      Integer group = lastGroup;\n      if (num != lastNum) {\n        group = Integer.valueOf(num);\n        lastGroup = group;\n        lastNum = num;\n      }\n      \n      // add word --> group\n      ArrayList groups = (ArrayList) word2Groups.get(word);\n      if (groups == null) {\n        groups = new ArrayList(1);\n        word2Groups.put(word, groups);\n      }\n      groups.add(group);\n\n      // add group --> word\n      ArrayList words = (ArrayList) group2Words.get(group);\n      if (words == null) {\n        words = new ArrayList(1);\n        group2Words.put(group, words);\n      } \n      words.add(word);\n    }\n    \n    \n    /* Part D: compute index data structure */\n    HashMap word2Syns = createIndex(word2Groups, group2Words);    \n        \n    /* Part E: minimize memory consumption by a factor 3 (or so) */\n//    if (true) return word2Syns;\n    word2Groups = null; // help gc\n    group2Words = null; // help gc    \n    return optimize(word2Syns, internedWords);\n  }\n\n","sourceOld":"  private HashMap read(byte[] data) {\n    int WORDS  = (int) (76401 / 0.7); // presizing\n    int GROUPS = (int) (88022 / 0.7); // presizing\n    HashMap word2Groups = new HashMap(WORDS);  // Map<String word, int[] groups>\n    HashMap group2Words = new HashMap(GROUPS); // Map<int group, String[] words>\n    HashMap internedWords = new HashMap(WORDS);// Map<String word, String word>\n\n    Charset charset = Charset.forName(\"UTF-8\");\n    int lastNum = -1;\n    Integer lastGroup = null;\n    int len = data.length;\n    int i=0;\n    \n    while (i < len) { // until EOF\n      /* Part A: Parse a line */\n      \n      // scan to beginning of group\n      while (i < len && data[i] != '(') i++;\n      if (i >= len) break; // EOF\n      i++;\n      \n      // parse group\n      int num = 0;\n      while (i < len && data[i] != ',') {\n        num = 10*num + (data[i] - 48);\n        i++;\n      }\n      i++;\n//      if (DEBUG) System.err.println(\"num=\"+ num);\n      \n      // scan to beginning of word\n      while (i < len && data[i] != '\\'') i++;\n      i++;\n  \n      // scan to end of word\n      int start = i;\n      do {\n        while (i < len && data[i] != '\\'') i++;\n        i++;\n      } while (i < len && data[i] != ','); // word must end with \"',\"\n      \n      if (i >= len) break; // EOF\n      String word = charset.decode(ByteBuffer.wrap(data, start, i-start-1)).toString();\n//      String word = new String(data, 0, start, i-start-1); // ASCII\n      \n      /*\n       * Part B: ignore phrases (with spaces and hyphens) and\n       * non-alphabetic words, and let user customize word (e.g. do some\n       * stemming)\n       */\n      if (!isValid(word)) continue; // ignore\n      word = analyze(word);\n      if (word == null || word.length() == 0) continue; // ignore\n      \n      \n      /* Part C: Add (group,word) to tables */\n      \n      // ensure compact string representation, minimizing memory overhead\n      String w = (String) internedWords.get(word);\n      if (w == null) {\n        word = new String(word); // ensure compact string\n        internedWords.put(word, word);\n      } else {\n        word = w;\n      }\n      \n      Integer group = lastGroup;\n      if (num != lastNum) {\n        group = new Integer(num);\n        lastGroup = group;\n        lastNum = num;\n      }\n      \n      // add word --> group\n      ArrayList groups = (ArrayList) word2Groups.get(word);\n      if (groups == null) {\n        groups = new ArrayList(1);\n        word2Groups.put(word, groups);\n      }\n      groups.add(group);\n\n      // add group --> word\n      ArrayList words = (ArrayList) group2Words.get(group);\n      if (words == null) {\n        words = new ArrayList(1);\n        group2Words.put(group, words);\n      } \n      words.add(word);\n    }\n    \n    \n    /* Part D: compute index data structure */\n    HashMap word2Syns = createIndex(word2Groups, group2Words);    \n        \n    /* Part E: minimize memory consumption by a factor 3 (or so) */\n//    if (true) return word2Syns;\n    word2Groups = null; // help gc\n    group2Words = null; // help gc    \n    return optimize(word2Syns, internedWords);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d68e5c46e6a5ebdf4dafec4a123344092b915cc0","date":1256752193,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"contrib/wordnet/src/java/org/apache/lucene/wordnet/SynonymMap#read(byte[]).mjava","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/SynonymMap#read(byte[]).mjava","sourceNew":"  private HashMap read(byte[] data) {\n    int WORDS  = (int) (76401 / 0.7); // presizing\n    int GROUPS = (int) (88022 / 0.7); // presizing\n    HashMap word2Groups = new HashMap(WORDS);  // Map<String word, int[] groups>\n    HashMap group2Words = new HashMap(GROUPS); // Map<int group, String[] words>\n    HashMap internedWords = new HashMap(WORDS);// Map<String word, String word>\n\n    Charset charset = Charset.forName(\"UTF-8\");\n    int lastNum = -1;\n    Integer lastGroup = null;\n    int len = data.length;\n    int i=0;\n    \n    while (i < len) { // until EOF\n      /* Part A: Parse a line */\n      \n      // scan to beginning of group\n      while (i < len && data[i] != '(') i++;\n      if (i >= len) break; // EOF\n      i++;\n      \n      // parse group\n      int num = 0;\n      while (i < len && data[i] != ',') {\n        num = 10*num + (data[i] - 48);\n        i++;\n      }\n      i++;\n//      if (DEBUG) System.err.println(\"num=\"+ num);\n      \n      // scan to beginning of word\n      while (i < len && data[i] != '\\'') i++;\n      i++;\n  \n      // scan to end of word\n      int start = i;\n      do {\n        while (i < len && data[i] != '\\'') i++;\n        i++;\n      } while (i < len && data[i] != ','); // word must end with \"',\"\n      \n      if (i >= len) break; // EOF\n      String word = charset.decode(ByteBuffer.wrap(data, start, i-start-1)).toString();\n//      String word = new String(data, 0, start, i-start-1); // ASCII\n      \n      /*\n       * Part B: ignore phrases (with spaces and hyphens) and\n       * non-alphabetic words, and let user customize word (e.g. do some\n       * stemming)\n       */\n      if (!isValid(word)) continue; // ignore\n      word = analyze(word);\n      if (word == null || word.length() == 0) continue; // ignore\n      \n      \n      /* Part C: Add (group,word) to tables */\n      \n      // ensure compact string representation, minimizing memory overhead\n      String w = (String) internedWords.get(word);\n      if (w == null) {\n        word = new String(word); // ensure compact string\n        internedWords.put(word, word);\n      } else {\n        word = w;\n      }\n      \n      Integer group = lastGroup;\n      if (num != lastNum) {\n        group = Integer.valueOf(num);\n        lastGroup = group;\n        lastNum = num;\n      }\n      \n      // add word --> group\n      ArrayList groups = (ArrayList) word2Groups.get(word);\n      if (groups == null) {\n        groups = new ArrayList(1);\n        word2Groups.put(word, groups);\n      }\n      groups.add(group);\n\n      // add group --> word\n      ArrayList words = (ArrayList) group2Words.get(group);\n      if (words == null) {\n        words = new ArrayList(1);\n        group2Words.put(group, words);\n      } \n      words.add(word);\n    }\n    \n    \n    /* Part D: compute index data structure */\n    HashMap word2Syns = createIndex(word2Groups, group2Words);    \n        \n    /* Part E: minimize memory consumption by a factor 3 (or so) */\n//    if (true) return word2Syns;\n    word2Groups = null; // help gc\n    group2Words = null; // help gc    \n    return optimize(word2Syns, internedWords);\n  }\n\n","sourceOld":"  private HashMap read(byte[] data) {\n    int WORDS  = (int) (76401 / 0.7); // presizing\n    int GROUPS = (int) (88022 / 0.7); // presizing\n    HashMap word2Groups = new HashMap(WORDS);  // Map<String word, int[] groups>\n    HashMap group2Words = new HashMap(GROUPS); // Map<int group, String[] words>\n    HashMap internedWords = new HashMap(WORDS);// Map<String word, String word>\n\n    Charset charset = Charset.forName(\"UTF-8\");\n    int lastNum = -1;\n    Integer lastGroup = null;\n    int len = data.length;\n    int i=0;\n    \n    while (i < len) { // until EOF\n      /* Part A: Parse a line */\n      \n      // scan to beginning of group\n      while (i < len && data[i] != '(') i++;\n      if (i >= len) break; // EOF\n      i++;\n      \n      // parse group\n      int num = 0;\n      while (i < len && data[i] != ',') {\n        num = 10*num + (data[i] - 48);\n        i++;\n      }\n      i++;\n//      if (DEBUG) System.err.println(\"num=\"+ num);\n      \n      // scan to beginning of word\n      while (i < len && data[i] != '\\'') i++;\n      i++;\n  \n      // scan to end of word\n      int start = i;\n      do {\n        while (i < len && data[i] != '\\'') i++;\n        i++;\n      } while (i < len && data[i] != ','); // word must end with \"',\"\n      \n      if (i >= len) break; // EOF\n      String word = charset.decode(ByteBuffer.wrap(data, start, i-start-1)).toString();\n//      String word = new String(data, 0, start, i-start-1); // ASCII\n      \n      /*\n       * Part B: ignore phrases (with spaces and hyphens) and\n       * non-alphabetic words, and let user customize word (e.g. do some\n       * stemming)\n       */\n      if (!isValid(word)) continue; // ignore\n      word = analyze(word);\n      if (word == null || word.length() == 0) continue; // ignore\n      \n      \n      /* Part C: Add (group,word) to tables */\n      \n      // ensure compact string representation, minimizing memory overhead\n      String w = (String) internedWords.get(word);\n      if (w == null) {\n        word = new String(word); // ensure compact string\n        internedWords.put(word, word);\n      } else {\n        word = w;\n      }\n      \n      Integer group = lastGroup;\n      if (num != lastNum) {\n        group = Integer.valueOf(num);\n        lastGroup = group;\n        lastNum = num;\n      }\n      \n      // add word --> group\n      ArrayList groups = (ArrayList) word2Groups.get(word);\n      if (groups == null) {\n        groups = new ArrayList(1);\n        word2Groups.put(word, groups);\n      }\n      groups.add(group);\n\n      // add group --> word\n      ArrayList words = (ArrayList) group2Words.get(group);\n      if (words == null) {\n        words = new ArrayList(1);\n        group2Words.put(group, words);\n      } \n      words.add(word);\n    }\n    \n    \n    /* Part D: compute index data structure */\n    HashMap word2Syns = createIndex(word2Groups, group2Words);    \n        \n    /* Part E: minimize memory consumption by a factor 3 (or so) */\n//    if (true) return word2Syns;\n    word2Groups = null; // help gc\n    group2Words = null; // help gc    \n    return optimize(word2Syns, internedWords);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6bcde5e3f23911110baa101ed062b544162825b5":["7f68e24227d5556d33ee6d586fd9010cd9ff8bec"],"4c9661df01b81c277277a01afbca7851557a2148":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7f68e24227d5556d33ee6d586fd9010cd9ff8bec":["4c9661df01b81c277277a01afbca7851557a2148"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d68e5c46e6a5ebdf4dafec4a123344092b915cc0"],"d68e5c46e6a5ebdf4dafec4a123344092b915cc0":["6bcde5e3f23911110baa101ed062b544162825b5"]},"commit2Childs":{"6bcde5e3f23911110baa101ed062b544162825b5":["d68e5c46e6a5ebdf4dafec4a123344092b915cc0"],"4c9661df01b81c277277a01afbca7851557a2148":["7f68e24227d5556d33ee6d586fd9010cd9ff8bec"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4c9661df01b81c277277a01afbca7851557a2148"],"7f68e24227d5556d33ee6d586fd9010cd9ff8bec":["6bcde5e3f23911110baa101ed062b544162825b5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"d68e5c46e6a5ebdf4dafec4a123344092b915cc0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}