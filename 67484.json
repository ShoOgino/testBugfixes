{"path":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#updateDocuments(Iterable[#-extends-Iterable[#-extends-IndexableField]],DocumentsWriterDeleteQueue.Node[#]).mjava","commits":[{"id":"8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2","date":1588002560,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#updateDocuments(Iterable[#-extends-Iterable[#-extends-IndexableField]],DocumentsWriterDeleteQueue.Node[#]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#updateDocuments(Iterable[#-extends-Iterable[#-extends-IndexableField]],Analyzer,DocumentsWriterDeleteQueue.Node[#]).mjava","sourceNew":"  long updateDocuments(final Iterable<? extends Iterable<? extends IndexableField>> docs,\n                       final DocumentsWriterDeleteQueue.Node<?> delNode) throws IOException {\n    boolean hasEvents = preUpdate();\n\n    final DocumentsWriterPerThread dwpt = flushControl.obtainAndLock();\n    final DocumentsWriterPerThread flushingDWPT;\n    long seqNo;\n\n    try {\n      // This must happen after we've pulled the DWPT because IW.close\n      // waits for all DWPT to be released:\n      ensureOpen();\n      final int dwptNumDocs = dwpt.getNumDocsInRAM();\n      try {\n        seqNo = dwpt.updateDocuments(docs, delNode, flushNotifications);\n      } finally {\n        if (dwpt.isAborted()) {\n          flushControl.doOnAbort(dwpt);\n        }\n        // We don't know how many documents were actually\n        // counted as indexed, so we must subtract here to\n        // accumulate our separate counter:\n        numDocsInRAM.addAndGet(dwpt.getNumDocsInRAM() - dwptNumDocs);\n      }\n      final boolean isUpdate = delNode != null && delNode.isDelete();\n      flushingDWPT = flushControl.doAfterDocument(dwpt, isUpdate);\n    } finally {\n      if (dwpt.isFlushPending() || dwpt.isAborted()) {\n        dwpt.unlock();\n      } else {\n        perThreadPool.marksAsFreeAndUnlock(dwpt);\n      }\n      assert dwpt.isHeldByCurrentThread() == false : \"we didn't release the dwpt even on abort\";\n    }\n\n    if (postUpdate(flushingDWPT, hasEvents)) {\n      seqNo = -seqNo;\n    }\n    return seqNo;\n  }\n\n","sourceOld":"  long updateDocuments(final Iterable<? extends Iterable<? extends IndexableField>> docs, final Analyzer analyzer,\n                       final DocumentsWriterDeleteQueue.Node<?> delNode) throws IOException {\n    boolean hasEvents = preUpdate();\n\n    final DocumentsWriterPerThread dwpt = flushControl.obtainAndLock();\n    final DocumentsWriterPerThread flushingDWPT;\n    long seqNo;\n\n    try {\n      // This must happen after we've pulled the DWPT because IW.close\n      // waits for all DWPT to be released:\n      ensureOpen();\n      final int dwptNumDocs = dwpt.getNumDocsInRAM();\n      try {\n        seqNo = dwpt.updateDocuments(docs, analyzer, delNode, flushNotifications);\n      } finally {\n        if (dwpt.isAborted()) {\n          flushControl.doOnAbort(dwpt);\n        }\n        // We don't know how many documents were actually\n        // counted as indexed, so we must subtract here to\n        // accumulate our separate counter:\n        numDocsInRAM.addAndGet(dwpt.getNumDocsInRAM() - dwptNumDocs);\n      }\n      final boolean isUpdate = delNode != null && delNode.isDelete();\n      flushingDWPT = flushControl.doAfterDocument(dwpt, isUpdate);\n    } finally {\n      if (dwpt.isFlushPending() || dwpt.isAborted()) {\n        dwpt.unlock();\n      } else {\n        perThreadPool.marksAsFreeAndUnlock(dwpt);\n      }\n      assert dwpt.isHeldByCurrentThread() == false : \"we didn't release the dwpt even on abort\";\n    }\n\n    if (postUpdate(flushingDWPT, hasEvents)) {\n      seqNo = -seqNo;\n    }\n    return seqNo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2"],"8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}