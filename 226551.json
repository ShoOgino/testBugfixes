{"path":"src/java/org/apache/lucene/search/BooleanScorer#next().mjava","commits":[{"id":"15c469602973ef1a33c9a07367a380d278ffab20","date":1074206555,"type":0,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanScorer#next().mjava","pathOld":"/dev/null","sourceNew":"  public boolean next() throws IOException {\n    boolean more = false;\n    do {\n      while (bucketTable.first != null) {         // more queued\n        current = bucketTable.first;\n        bucketTable.first = current.next;         // pop the queue\n\n        // check prohibited & required\n        if ((current.bits & prohibitedMask) == 0 && \n            (current.bits & requiredMask) == requiredMask) {\n          return true;\n        }\n      }\n\n      // refill the queue\n      end += BucketTable.SIZE;\n      for (SubScorer sub = scorers; sub != null; sub = sub.next) {\n        Scorer scorer = sub.scorer;\n        while (!sub.done && scorer.doc() < end) {\n          sub.collector.collect(scorer.doc(), scorer.score());\n          sub.done = !scorer.next();\n        }\n        if (!sub.done) {\n          more  = true;\n        }\n      }\n    } while (bucketTable.first != null | more);\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"130c51bbcab2d28f7501142bdbad2f23a4b670c7","date":1077128911,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanScorer#next().mjava","pathOld":"src/java/org/apache/lucene/search/BooleanScorer#next().mjava","sourceNew":"  public boolean next() throws IOException {\n    boolean more;\n    do {\n      while (bucketTable.first != null) {         // more queued\n        current = bucketTable.first;\n        bucketTable.first = current.next;         // pop the queue\n\n        // check prohibited & required\n        if ((current.bits & prohibitedMask) == 0 && \n            (current.bits & requiredMask) == requiredMask) {\n          return true;\n        }\n      }\n\n      // refill the queue\n      more = false;\n      end += BucketTable.SIZE;\n      for (SubScorer sub = scorers; sub != null; sub = sub.next) {\n        Scorer scorer = sub.scorer;\n        while (!sub.done && scorer.doc() < end) {\n          sub.collector.collect(scorer.doc(), scorer.score());\n          sub.done = !scorer.next();\n        }\n        if (!sub.done) {\n          more = true;\n        }\n      }\n    } while (bucketTable.first != null | more);\n\n    return false;\n  }\n\n","sourceOld":"  public boolean next() throws IOException {\n    boolean more = false;\n    do {\n      while (bucketTable.first != null) {         // more queued\n        current = bucketTable.first;\n        bucketTable.first = current.next;         // pop the queue\n\n        // check prohibited & required\n        if ((current.bits & prohibitedMask) == 0 && \n            (current.bits & requiredMask) == requiredMask) {\n          return true;\n        }\n      }\n\n      // refill the queue\n      end += BucketTable.SIZE;\n      for (SubScorer sub = scorers; sub != null; sub = sub.next) {\n        Scorer scorer = sub.scorer;\n        while (!sub.done && scorer.doc() < end) {\n          sub.collector.collect(scorer.doc(), scorer.score());\n          sub.done = !scorer.next();\n        }\n        if (!sub.done) {\n          more  = true;\n        }\n      }\n    } while (bucketTable.first != null | more);\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3964395e0878318f8d5b032ba6256ab9607d7002","date":1092656482,"type":3,"author":"Daniel Naber","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanScorer#next().mjava","pathOld":"src/java/org/apache/lucene/search/BooleanScorer#next().mjava","sourceNew":"  public boolean next() throws IOException {\n    boolean more;\n    do {\n      while (bucketTable.first != null) {         // more queued\n        current = bucketTable.first;\n        bucketTable.first = current.next;         // pop the queue\n\n        // check prohibited & required\n        if ((current.bits & prohibitedMask) == 0 && \n            (current.bits & requiredMask) == requiredMask) {\n          return true;\n        }\n      }\n\n      // refill the queue\n      more = false;\n      end += BucketTable.SIZE;\n      for (SubScorer sub = scorers; sub != null; sub = sub.next) {\n        Scorer scorer = sub.scorer;\n        while (!sub.done && scorer.doc() < end) {\n          sub.collector.collect(scorer.doc(), scorer.score());\n          sub.done = !scorer.next();\n        }\n        if (!sub.done) {\n          more = true;\n        }\n      }\n    } while (bucketTable.first != null || more);\n\n    return false;\n  }\n\n","sourceOld":"  public boolean next() throws IOException {\n    boolean more;\n    do {\n      while (bucketTable.first != null) {         // more queued\n        current = bucketTable.first;\n        bucketTable.first = current.next;         // pop the queue\n\n        // check prohibited & required\n        if ((current.bits & prohibitedMask) == 0 && \n            (current.bits & requiredMask) == requiredMask) {\n          return true;\n        }\n      }\n\n      // refill the queue\n      more = false;\n      end += BucketTable.SIZE;\n      for (SubScorer sub = scorers; sub != null; sub = sub.next) {\n        Scorer scorer = sub.scorer;\n        while (!sub.done && scorer.doc() < end) {\n          sub.collector.collect(scorer.doc(), scorer.score());\n          sub.done = !scorer.next();\n        }\n        if (!sub.done) {\n          more = true;\n        }\n      }\n    } while (bucketTable.first != null | more);\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"76349ae49451ab1e1e63e8eeb254f82684b1da25","date":1176847207,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanScorer#next().mjava","pathOld":"src/java/org/apache/lucene/search/BooleanScorer#next().mjava","sourceNew":"  public boolean next() throws IOException {\n    boolean more;\n    do {\n      while (bucketTable.first != null) {         // more queued\n        current = bucketTable.first;\n        bucketTable.first = current.next;         // pop the queue\n\n        // check prohibited & required, and minNrShouldMatch\n        if ((current.bits & prohibitedMask) == 0 &&\n            (current.bits & requiredMask) == requiredMask &&\n            current.coord >= minNrShouldMatch) {\n          return true;\n        }\n      }\n\n      // refill the queue\n      more = false;\n      end += BucketTable.SIZE;\n      for (SubScorer sub = scorers; sub != null; sub = sub.next) {\n        Scorer scorer = sub.scorer;\n        while (!sub.done && scorer.doc() < end) {\n          sub.collector.collect(scorer.doc(), scorer.score());\n          sub.done = !scorer.next();\n        }\n        if (!sub.done) {\n          more = true;\n        }\n      }\n    } while (bucketTable.first != null || more);\n\n    return false;\n  }\n\n","sourceOld":"  public boolean next() throws IOException {\n    boolean more;\n    do {\n      while (bucketTable.first != null) {         // more queued\n        current = bucketTable.first;\n        bucketTable.first = current.next;         // pop the queue\n\n        // check prohibited & required\n        if ((current.bits & prohibitedMask) == 0 && \n            (current.bits & requiredMask) == requiredMask) {\n          return true;\n        }\n      }\n\n      // refill the queue\n      more = false;\n      end += BucketTable.SIZE;\n      for (SubScorer sub = scorers; sub != null; sub = sub.next) {\n        Scorer scorer = sub.scorer;\n        while (!sub.done && scorer.doc() < end) {\n          sub.collector.collect(scorer.doc(), scorer.score());\n          sub.done = !scorer.next();\n        }\n        if (!sub.done) {\n          more = true;\n        }\n      }\n    } while (bucketTable.first != null || more);\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"64714133cf5ec732e3bbceee63351bb9af0117dc","date":1239647636,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanScorer#next().mjava","pathOld":"src/java/org/apache/lucene/search/BooleanScorer#next().mjava","sourceNew":"  public boolean next() throws IOException {\n    boolean more;\n    do {\n      while (bucketTable.first != null) {         // more queued\n        current = bucketTable.first;\n        bucketTable.first = current.next;         // pop the queue\n\n        // check prohibited & required, and minNrShouldMatch\n        if ((current.bits & prohibitedMask) == 0 &&\n            (current.bits & requiredMask) == requiredMask &&\n            current.coord >= minNrShouldMatch) {\n          return true;\n        }\n      }\n\n      // refill the queue\n      more = false;\n      end += BucketTable.SIZE;\n      for (SubScorer sub = scorers; sub != null; sub = sub.next) {\n        Scorer scorer = sub.scorer;\n        sub.collector.setScorer(scorer);\n        while (!sub.done && scorer.doc() < end) {\n          sub.collector.collect(scorer.doc());\n          sub.done = !scorer.next();\n        }\n        if (!sub.done) {\n          more = true;\n        }\n      }\n    } while (bucketTable.first != null || more);\n\n    return false;\n  }\n\n","sourceOld":"  public boolean next() throws IOException {\n    boolean more;\n    do {\n      while (bucketTable.first != null) {         // more queued\n        current = bucketTable.first;\n        bucketTable.first = current.next;         // pop the queue\n\n        // check prohibited & required, and minNrShouldMatch\n        if ((current.bits & prohibitedMask) == 0 &&\n            (current.bits & requiredMask) == requiredMask &&\n            current.coord >= minNrShouldMatch) {\n          return true;\n        }\n      }\n\n      // refill the queue\n      more = false;\n      end += BucketTable.SIZE;\n      for (SubScorer sub = scorers; sub != null; sub = sub.next) {\n        Scorer scorer = sub.scorer;\n        while (!sub.done && scorer.doc() < end) {\n          sub.collector.collect(scorer.doc(), scorer.score());\n          sub.done = !scorer.next();\n        }\n        if (!sub.done) {\n          more = true;\n        }\n      }\n    } while (bucketTable.first != null || more);\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30a558487f2298c2c19ceca9103c1b6865d64708","date":1244393921,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanScorer#next().mjava","pathOld":"src/java/org/apache/lucene/search/BooleanScorer#next().mjava","sourceNew":"  /** @deprecated use {@link #nextDoc()} instead. */\n  public boolean next() throws IOException {\n    return nextDoc() != NO_MORE_DOCS;\n  }\n\n","sourceOld":"  public boolean next() throws IOException {\n    boolean more;\n    do {\n      while (bucketTable.first != null) {         // more queued\n        current = bucketTable.first;\n        bucketTable.first = current.next;         // pop the queue\n\n        // check prohibited & required, and minNrShouldMatch\n        if ((current.bits & prohibitedMask) == 0 &&\n            (current.bits & requiredMask) == requiredMask &&\n            current.coord >= minNrShouldMatch) {\n          return true;\n        }\n      }\n\n      // refill the queue\n      more = false;\n      end += BucketTable.SIZE;\n      for (SubScorer sub = scorers; sub != null; sub = sub.next) {\n        Scorer scorer = sub.scorer;\n        sub.collector.setScorer(scorer);\n        while (!sub.done && scorer.doc() < end) {\n          sub.collector.collect(scorer.doc());\n          sub.done = !scorer.next();\n        }\n        if (!sub.done) {\n          more = true;\n        }\n      }\n    } while (bucketTable.first != null || more);\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"438aef2dc00a23f2716882753fe225fbce4cfbfc","date":1255281460,"type":4,"author":"Michael Busch","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/search/BooleanScorer#next().mjava","sourceNew":null,"sourceOld":"  /** @deprecated use {@link #nextDoc()} instead. */\n  public boolean next() throws IOException {\n    return nextDoc() != NO_MORE_DOCS;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3964395e0878318f8d5b032ba6256ab9607d7002":["130c51bbcab2d28f7501142bdbad2f23a4b670c7"],"30a558487f2298c2c19ceca9103c1b6865d64708":["64714133cf5ec732e3bbceee63351bb9af0117dc"],"64714133cf5ec732e3bbceee63351bb9af0117dc":["76349ae49451ab1e1e63e8eeb254f82684b1da25"],"438aef2dc00a23f2716882753fe225fbce4cfbfc":["30a558487f2298c2c19ceca9103c1b6865d64708"],"76349ae49451ab1e1e63e8eeb254f82684b1da25":["3964395e0878318f8d5b032ba6256ab9607d7002"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["438aef2dc00a23f2716882753fe225fbce4cfbfc"],"130c51bbcab2d28f7501142bdbad2f23a4b670c7":["15c469602973ef1a33c9a07367a380d278ffab20"],"15c469602973ef1a33c9a07367a380d278ffab20":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"3964395e0878318f8d5b032ba6256ab9607d7002":["76349ae49451ab1e1e63e8eeb254f82684b1da25"],"30a558487f2298c2c19ceca9103c1b6865d64708":["438aef2dc00a23f2716882753fe225fbce4cfbfc"],"64714133cf5ec732e3bbceee63351bb9af0117dc":["30a558487f2298c2c19ceca9103c1b6865d64708"],"438aef2dc00a23f2716882753fe225fbce4cfbfc":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"76349ae49451ab1e1e63e8eeb254f82684b1da25":["64714133cf5ec732e3bbceee63351bb9af0117dc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["15c469602973ef1a33c9a07367a380d278ffab20"],"130c51bbcab2d28f7501142bdbad2f23a4b670c7":["3964395e0878318f8d5b032ba6256ab9607d7002"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"15c469602973ef1a33c9a07367a380d278ffab20":["130c51bbcab2d28f7501142bdbad2f23a4b670c7"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}