{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.Tree#compareForAdd(double,double,double,double).mjava","commits":[{"id":"5b3ccbc7c0d21f9643de6c5c7894f67336dcb57a","date":1461845562,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.Tree#compareForAdd(double,double,double,double).mjava","pathOld":"/dev/null","sourceNew":"    /** Compare a node against a subrange of a new edge.\n     * @param node is the node to compare.\n     * @param newEdge is the edge being added.\n     * @param minimumValue is the minimum value for the edge being added.\n     * @param maximumValue is the maximum value for the edge being added.\n     * @return the comparison result.\n     */\n    protected int compareForAdd(final double nodeMinimumValue, final double nodeMaximumValue, final double minimumValue, final double maximumValue) {\n      if (minimumValue <= nodeMinimumValue && maximumValue >= nodeMaximumValue) {\n        return CONTAINED;\n      } else if (nodeMinimumValue <= minimumValue && nodeMaximumValue >= maximumValue) {\n        return WITHIN;\n      } else if (maximumValue < nodeMinimumValue) {\n        return LESS;\n      } else if (minimumValue > nodeMaximumValue) {\n        return GREATER;\n      } else if (minimumValue < nodeMinimumValue) {\n        return OVERLAPS_MINIMUM;\n      } else {\n        return OVERLAPS_MAXIMUM;\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e2e6c261ef8e208234dd6adcbdd3594e5583a6a","date":1461887935,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.Tree#compareForAdd(double,double,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.Tree#compareForAdd(double,double,double,double).mjava","sourceNew":"    /** Compare a node against a subrange of a new edge.\n     * @param nodeMinimumValue is the node's minimum value.\n     * @param nodeMaximumValue is the node's maximum value.\n     * @param minimumValue is the minimum value for the edge being added.\n     * @param maximumValue is the maximum value for the edge being added.\n     * @return the comparison result.\n     */\n    protected int compareForAdd(final double nodeMinimumValue, final double nodeMaximumValue, final double minimumValue, final double maximumValue) {\n      if (minimumValue <= nodeMinimumValue && maximumValue >= nodeMaximumValue) {\n        return CONTAINED;\n      } else if (nodeMinimumValue <= minimumValue && nodeMaximumValue >= maximumValue) {\n        return WITHIN;\n      } else if (maximumValue < nodeMinimumValue) {\n        return LESS;\n      } else if (minimumValue > nodeMaximumValue) {\n        return GREATER;\n      } else if (minimumValue < nodeMinimumValue) {\n        return OVERLAPS_MINIMUM;\n      } else {\n        return OVERLAPS_MAXIMUM;\n      }\n    }\n\n","sourceOld":"    /** Compare a node against a subrange of a new edge.\n     * @param node is the node to compare.\n     * @param newEdge is the edge being added.\n     * @param minimumValue is the minimum value for the edge being added.\n     * @param maximumValue is the maximum value for the edge being added.\n     * @return the comparison result.\n     */\n    protected int compareForAdd(final double nodeMinimumValue, final double nodeMaximumValue, final double minimumValue, final double maximumValue) {\n      if (minimumValue <= nodeMinimumValue && maximumValue >= nodeMaximumValue) {\n        return CONTAINED;\n      } else if (nodeMinimumValue <= minimumValue && nodeMaximumValue >= maximumValue) {\n        return WITHIN;\n      } else if (maximumValue < nodeMinimumValue) {\n        return LESS;\n      } else if (minimumValue > nodeMaximumValue) {\n        return GREATER;\n      } else if (minimumValue < nodeMinimumValue) {\n        return OVERLAPS_MINIMUM;\n      } else {\n        return OVERLAPS_MAXIMUM;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0","date":1461888019,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.Tree#compareForAdd(double,double,double,double).mjava","pathOld":"/dev/null","sourceNew":"    /** Compare a node against a subrange of a new edge.\n     * @param nodeMinimumValue is the node's minimum value.\n     * @param nodeMaximumValue is the node's maximum value.\n     * @param minimumValue is the minimum value for the edge being added.\n     * @param maximumValue is the maximum value for the edge being added.\n     * @return the comparison result.\n     */\n    protected int compareForAdd(final double nodeMinimumValue, final double nodeMaximumValue, final double minimumValue, final double maximumValue) {\n      if (minimumValue <= nodeMinimumValue && maximumValue >= nodeMaximumValue) {\n        return CONTAINED;\n      } else if (nodeMinimumValue <= minimumValue && nodeMaximumValue >= maximumValue) {\n        return WITHIN;\n      } else if (maximumValue < nodeMinimumValue) {\n        return LESS;\n      } else if (minimumValue > nodeMaximumValue) {\n        return GREATER;\n      } else if (minimumValue < nodeMinimumValue) {\n        return OVERLAPS_MINIMUM;\n      } else {\n        return OVERLAPS_MAXIMUM;\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9167ab2d333bb6419d787660d5738852c9f1db60","date":1462255679,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.Tree#compareForAdd(double,double,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.Tree#compareForAdd(double,double,double,double).mjava","sourceNew":"    /** Compare a node against a subrange of a new edge.\n     * @param nodeMinimumValue is the node's minimum value.\n     * @param nodeMaximumValue is the node's maximum value.\n     * @param minimumValue is the minimum value for the edge being added.\n     * @param maximumValue is the maximum value for the edge being added.\n     * @return the comparison result.\n     */\n    protected int compareForAdd(final double nodeMinimumValue, final double nodeMaximumValue, final double minimumValue, final double maximumValue) {\n      if (minimumValue == nodeMinimumValue && maximumValue == nodeMaximumValue) {\n        return EXACT;\n      } else if (minimumValue <= nodeMinimumValue && maximumValue >= nodeMaximumValue) {\n        return CONTAINED;\n      } else if (nodeMinimumValue <= minimumValue && nodeMaximumValue >= maximumValue) {\n        return WITHIN;\n      } else if (maximumValue < nodeMinimumValue) {\n        return LESS;\n      } else if (minimumValue > nodeMaximumValue) {\n        return GREATER;\n      } else if (minimumValue < nodeMinimumValue) {\n        return OVERLAPS_MINIMUM;\n      } else {\n        return OVERLAPS_MAXIMUM;\n      }\n    }\n\n","sourceOld":"    /** Compare a node against a subrange of a new edge.\n     * @param nodeMinimumValue is the node's minimum value.\n     * @param nodeMaximumValue is the node's maximum value.\n     * @param minimumValue is the minimum value for the edge being added.\n     * @param maximumValue is the maximum value for the edge being added.\n     * @return the comparison result.\n     */\n    protected int compareForAdd(final double nodeMinimumValue, final double nodeMaximumValue, final double minimumValue, final double maximumValue) {\n      if (minimumValue <= nodeMinimumValue && maximumValue >= nodeMaximumValue) {\n        return CONTAINED;\n      } else if (nodeMinimumValue <= minimumValue && nodeMaximumValue >= maximumValue) {\n        return WITHIN;\n      } else if (maximumValue < nodeMinimumValue) {\n        return LESS;\n      } else if (minimumValue > nodeMaximumValue) {\n        return GREATER;\n      } else if (minimumValue < nodeMinimumValue) {\n        return OVERLAPS_MINIMUM;\n      } else {\n        return OVERLAPS_MAXIMUM;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"083674ea80108c4053d9526cdef6f77b2494e551","date":1462313169,"type":4,"author":"Karl Wright","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.Tree#compareForAdd(double,double,double,double).mjava","sourceNew":null,"sourceOld":"    /** Compare a node against a subrange of a new edge.\n     * @param nodeMinimumValue is the node's minimum value.\n     * @param nodeMaximumValue is the node's maximum value.\n     * @param minimumValue is the minimum value for the edge being added.\n     * @param maximumValue is the maximum value for the edge being added.\n     * @return the comparison result.\n     */\n    protected int compareForAdd(final double nodeMinimumValue, final double nodeMaximumValue, final double minimumValue, final double maximumValue) {\n      if (minimumValue == nodeMinimumValue && maximumValue == nodeMaximumValue) {\n        return EXACT;\n      } else if (minimumValue <= nodeMinimumValue && maximumValue >= nodeMaximumValue) {\n        return CONTAINED;\n      } else if (nodeMinimumValue <= minimumValue && nodeMaximumValue >= maximumValue) {\n        return WITHIN;\n      } else if (maximumValue < nodeMinimumValue) {\n        return LESS;\n      } else if (minimumValue > nodeMaximumValue) {\n        return GREATER;\n      } else if (minimumValue < nodeMinimumValue) {\n        return OVERLAPS_MINIMUM;\n      } else {\n        return OVERLAPS_MAXIMUM;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1e2e6c261ef8e208234dd6adcbdd3594e5583a6a":["5b3ccbc7c0d21f9643de6c5c7894f67336dcb57a"],"083674ea80108c4053d9526cdef6f77b2494e551":["9167ab2d333bb6419d787660d5738852c9f1db60"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1e2e6c261ef8e208234dd6adcbdd3594e5583a6a"],"5b3ccbc7c0d21f9643de6c5c7894f67336dcb57a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9167ab2d333bb6419d787660d5738852c9f1db60":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["083674ea80108c4053d9526cdef6f77b2494e551"]},"commit2Childs":{"1e2e6c261ef8e208234dd6adcbdd3594e5583a6a":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0"],"083674ea80108c4053d9526cdef6f77b2494e551":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c46db27f3364a67a1c77a0f4e462cc7c5b4147f0","5b3ccbc7c0d21f9643de6c5c7894f67336dcb57a"],"c46db27f3364a67a1c77a0f4e462cc7c5b4147f0":["9167ab2d333bb6419d787660d5738852c9f1db60"],"5b3ccbc7c0d21f9643de6c5c7894f67336dcb57a":["1e2e6c261ef8e208234dd6adcbdd3594e5583a6a"],"9167ab2d333bb6419d787660d5738852c9f1db60":["083674ea80108c4053d9526cdef6f77b2494e551"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}